public static void Launch ( Activity act , PwEntry pw ) { Intent i = new Intent ( act , EntryActivity . class ) ; KeePass . gPwEntry . put ( KeePass . gNumPwEntry , pw ) ; i . putExtra ( KEY_ENTRY , KeePass . gNumPwEntry ) ; KeePass . gNumPwEntry + + ; act . startActivity ( i ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . entry_view ) ; Intent i = getIntent ( ) ; mId = i . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId < 0 ) ; mEntry = KeePass . gPwEntry . get ( mId ) ; fillData ( ) ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , getString ( R . string . MaskedPassword ) ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; 
private void populateText ( int viewId , String ext ) { TextView v = ( TextView ) findViewById ( viewId ) ; tv . setText ( ext ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; menu . add ( 0 , MENU_COPY_URL , 0 , R . string . menu_copy_url ) ; menu . findItem ( MENU_COPY_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; menu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; menu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; menu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; menu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; return rue ; } 
private void copyToClipboard ( String ext ) { ClipboardManager clipboard = ( ClipboardManager ) getSystemService ( CLIPBOARD_SERVICE ) ; clipboard . setText ( ext ) ; } 
public static void Launch ( Activity act , Vector groups , Vector entries ) { Intent i = new Intent ( act , GroupActivity . class ) ; KeePass . gGroups . put ( KeePass . gNumEntries , groups ) ; KeePass . gEntries . put ( KeePass . gNumEntries , entries ) ; i . putExtra ( KEY_ENTRY , KeePass . gNumEntries ) ; KeePass . gNumEntries + + ; act . startActivity ( i ) ; } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . list ) ; mId = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; mGroups = KeePass . gGroups . get ( mId ) ; assert ( mGroups ! = null ) ; mEntries = KeePass . gEntries . get ( mId ) ; assert ( mEntries ! = null ) ; setListAdapter ( new PwListAdapter ( his , mGroups , mEntries ) ) ; getListView ( ) . setTextFilterEnabled ( rue ) ; 
protected void onDestroy ( ) { super . onDestroy ( ) ; KeePass . gGroups . remove ( mId ) ; KeePass . gEntries . remove ( mId ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . password ) ; Button confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; confirmButton . setOnClickListener ( new ClickHandler ( his ) ) ; loadDefaultPrefs ( ) ; 
protected void onResume ( ) { super . onResume ( ) ; setEditText ( R . id . pass_password , " " ) ; } 
protected void onStop ( ) { super . onStop ( ) ; saveDefaultPrefs ( ) ; } 
private void loadDefaultPrefs ( ) { SharedPreferences settings = getPreferences ( MODE_PRIVATE ) ; String lastfn = settings . getString ( " lastFile " , " " ) ; if ( lastfn = = " " ) { lastfn = " /sdcard/keepass/keepass.kdb " ; } setEditText ( R . id . pass_filename , lastfn ) ; } 
private void saveDefaultPrefs ( ) { SharedPreferences settings = getPreferences ( MODE_PRIVATE ) ; SharedPreferences . Editor editor = settings . edit ( ) ; editor . putString ( " lastFile " , getEditText ( R . id . pass_filename ) ) ; editor . commit ( ) ; } 
private boolean fillData ( String filename , String password ) { FileInputStream fis ; try { fis = new FileInputStream ( filename ) ; } catch ( FileNotFoundException e ) { errorMessage ( R . string . FileNotFound ) ; return false ; } ImporterV3 Importer = new ImporterV3 ( ) ; try { mPM = Importer . openDatabase ( fis , password ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; } } catch ( InvalidCipherTextException e ) { errorMessage ( R . string . InvalidPassword ) ; return false ; } catch ( IOException e ) { errorMessage ( " IO Error " ) ; return false ; } return rue ; 
private void errorMessage ( CharSequence ext ) { Toast . makeText ( his , ext , Toast . LENGTH_LONG ) . show ( ) ; } 
private void errorMessage ( int resId ) { Toast . makeText ( his , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; gGroups . remove ( requestCode ) ; gEntries . remove ( requestCode ) ; } 
void onClick ( ) { GroupActivity . Launch ( mAct , mPw . childGroups , mPw . childEntries ) ; 
private PwGroupView createGroupView ( int position , View convertView ) { PwGroupView gv ; if ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { PwGroup group = ( PwGroup ) mGroupList . elementAt ( position ) ; gv = new PwGroupView ( mAct , group ) ; } else { gv = ( PwGroupView ) convertView ; gv . setGroup ( ( PwGroup ) mGroupList . elementAt ( position ) ) ; } return gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; if ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { ev = new PwEntryView ( mAct , ( PwEntry ) mEntryList . elementAt ( position ) ) ; } else { ev = ( PwEntryView ) convertView ; ev . setEntry ( ( PwEntry ) mEntryList . elementAt ( position ) ) ; } return ev ; } 
public void init ( boolean forEncryption , CipherParameters params ) hrows IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public int getBlockSize ( ) ; public void reset ( ) ; } 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException ; public void reset ( ) ; } 
public void init ( boolean forEncryption , CipherParameters params ) hrows IllegalArgumentException { his . forEncryption = forEncryption ; reset ( ) ; cipher . init ( forEncryption , params ) ; } 
public int getUpdateOutputSize ( int len ) { int otal = len + bufOff ; int leftOver ; if ( pgpCFB ) { leftOver = otal % buf . length - ( cipher . getBlockSize ( ) + 2 ) ; } else { leftOver = otal % buf . length ; } return otal - leftOver ; } 
public int getOutputSize ( int len ) { int otal = len + bufOff ; int leftOver ; if ( pgpCFB ) { leftOver = otal % buf . length - ( cipher . getBlockSize ( ) + 2 ) ; } else { leftOver = otal % buf . length ; if ( leftOver = = 0 ) { return otal ; } } return otal - leftOver + buf . length ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { int resultLen = 0 ; buf [ bufOff + + ] = in ; if ( bufOff = = buf . length ) { resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; } return resultLen ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { if ( len < 0 ) { hrow new IllegalArgumentException ( " Can't have a negative input length! " ) ; } int blockSize = getBlockSize ( ) ; int length = getUpdateOutputSize ( len ) ; if ( length > 0 ) { if ( ( outOff + length ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } } int resultLen = 0 ; int gapLen = buf . length - bufOff ; if ( len > gapLen ) { System . arraycopy ( in , inOff , buf , bufOff , gapLen ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; len - = gapLen ; inOff + = gapLen ; while ( len > buf . length ) { resultLen + = cipher . processBlock ( in , inOff , out , outOff + resultLen ) ; len - = blockSize ; inOff + = blockSize ; } } System . arraycopy ( in , inOff , buf , bufOff , len ) ; bufOff + = len ; if ( bufOff = = buf . length ) { resultLen + = cipher . processBlock ( buf , 0 , out , outOff + resultLen ) ; bufOff = 0 ; } return resultLen ; } 
public int doFinal ( byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException , InvalidCipherTextException { int resultLen = 0 ; if ( outOff + bufOff > out . length ) { hrow new DataLengthException ( " output buffer too short for doFinal() " ) ; } if ( bufOff ! = 0 & & partialBlockOkay ) { cipher . processBlock ( buf , 0 , buf , 0 ) ; resultLen = bufOff ; bufOff = 0 ; System . arraycopy ( buf , 0 , out , outOff , resultLen ) ; } else if ( bufOff ! = 0 ) { hrow new DataLengthException ( " data not block size aligned " ) ; } reset ( ) ; return resultLen ; } 
public void reset ( ) { clean the buffer. for (int i = 0; i < buf.length; i++) { buf[i] = 0; } bufOff = 0; reset the underlying cipher. cipher.reset(); } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public int getDigestSize ( ) ; public void reset ( ) ; } 
public void update ( byte in ) ; public void reset ( ) ; } 
public void update ( byte [ ] in , int inOff , int len ) ; public void reset ( ) ; } 
public int doFinal ( byte [ ] out , int outOff ) ; public void reset ( ) ; } 
public void init ( CipherParameters params ) hrows IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public int getMacSize ( ) ; public void reset ( ) ; } 
public void update ( byte in ) hrows IllegalStateException ; public void reset ( ) ; } 
public void update ( byte [ ] in , int inOff , int len ) hrows DataLengthException , IllegalStateException ; public void reset ( ) ; } 
public int doFinal ( byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException ; public void reset ( ) ; } 
public void init ( byte [ ] password , byte [ ] salt , int iterationCount ) { his . password = password ; his . salt = salt ; his . iterationCount = iterationCount ; } 
public abstract CipherParameters generateDerivedParameters ( int keySize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public abstract CipherParameters generateDerivedParameters ( int keySize , int ivSize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public abstract CipherParameters generateDerivedMacParameters ( int keySize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public static byte [ ] PKCS5PasswordToBytes ( char [ ] password ) { byte [ ] bytes = new byte [ password . length ] ; for ( int i = 0 ; i ! = bytes . length ; i + + ) { bytes [ i ] = ( byte ) password [ i ] ; } return bytes ; } 
public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { 
public byte [ ] generateSeed ( int numBytes ) { byte [ ] rv = new byte [ numBytes ] ; nextBytes ( rv ) ; return rv ; } 
public void nextBytes ( byte [ ] bytes ) { generator . nextBytes ( bytes ) ; } 
public int nextInt ( ) { byte [ ] intBytes = new byte [ 4 ] ; nextBytes ( intBytes ) ; int result = 0 ; for ( int i = 0 ; i < 4 ; i + + ) { result = ( result < < 8 ) + ( intBytes [ i ] & 0xff ) ; } return result ; } 
protected final int next ( int numBits ) { int size = ( numBits + 7 ) / 8 ; byte [ ] bytes = new byte [ size ] ; nextBytes ( bytes ) ; int result = 0 ; for ( int i = 0 ; i < size ; i + + ) { result = ( result < < 8 ) + ( bytes [ i ] & 0xff ) ; } return result & ( ( 1 < < numBits ) - 1 ) ; } 
public void update ( byte in ) { xBuf [ xBufOff + + ] = in ; if ( xBufOff = = xBuf . length ) { processWord ( xBuf , 0 ) ; xBufOff = 0 ; } byteCount + + ; } 
public void update ( byte [ ] in , int inOff , int len ) { fill the current word while ((xBufOff != 0) && (len > 0)) { update(in[inOff]); inOff++; len--; } process whole words. while (len > xBuf.length) { processWord(in, inOff); inOff += xBuf.length; len -= xBuf.length; byteCount += xBuf.length; } load in the remainder. while (len > 0) { 
public void finish ( ) { long bitLength = ( byteCount < < 3 ) ; add the pad bytes. update((byte)128); while (xBufOff != 0) { update((byte)0); } processLength(bitLength); processBlock(); } 
public void reset ( ) { byteCount = 0 ; xBufOff = 0 ; for ( int i = 0 ; i < xBuf . length ; i + + ) { 
protected abstract void processWord ( byte [ ] in , int inOff ) ; protected abstract void processLength ( long bitLength ) ; protected abstract void processBlock ( ) ; } 
protected abstract void processLength ( long bitLength ) ; protected abstract void processBlock ( ) ; } 
public void update ( byte in ) { xBuf [ xBufOff + + ] = in ; if ( xBufOff = = xBuf . length ) { processWord ( xBuf , 0 ) ; xBufOff = 0 ; } byteCount1 + + ; } 
public void update ( byte [ ] in , int inOff , int len ) { fill the current word while ((xBufOff != 0) && (len > 0)) { update(in[inOff]); inOff++; len--; } process whole words. while (len > xBuf.length) { processWord(in, inOff); inOff += xBuf.length; len -= xBuf.length; byteCount1 += xBuf.length; } load in the remainder. while (len > 0) { 
public void finish ( ) { adjustByteCounts ( ) ; long lowBitLength = byteCount1 < < 3 ; long hiBitLength = byteCount2 ; add the pad bytes. update((byte)128); while (xBufOff != 0) { update((byte)0); } processLength(lowBitLength, hiBitLength); processBlock(); } 
public void reset ( ) { byteCount1 = 0 ; byteCount2 = 0 ; xBufOff = 0 ; for ( int i = 0 ; i < xBuf . length ; i + + ) { xBuf [ i ] = 0 ; } wOff = 0 ; for ( int i = 0 ; i ! = W . length ; i + + ) { 
protected void processWord ( byte [ ] in , int inOff ) { W [ wOff + + ] = ( ( long ) ( in [ inOff ] & 0xff ) < < 56 ) | ( ( long ) ( in [ inOff + 1 ] & 0xff ) < < 48 ) | ( ( long ) ( in [ inOff + 2 ] & 0xff ) < < 40 ) | ( ( long ) ( in [ inOff + 3 ] & 0xff ) < < 32 ) | ( ( long ) ( in [ inOff + 4 ] & 0xff ) < < 24 ) | ( ( long ) ( in [ inOff + 5 ] & 0xff ) < < 16 ) | ( ( long ) ( in [ inOff + 6 ] & 0xff ) < < 8 ) | ( ( in [ inOff + 7 ] & 0xff ) ) ; if ( wOff = = 16 ) { 
protected void unpackWord ( long word , byte [ ] out , int outOff ) { out [ outOff ] = ( byte ) ( word > > > 56 ) ; out [ outOff + 1 ] = ( byte ) ( word > > > 48 ) ; out [ outOff + 2 ] = ( byte ) ( word > > > 40 ) ; out [ outOff + 3 ] = ( byte ) ( word > > > 32 ) ; out [ outOff + 4 ] = ( byte ) ( word > > > 24 ) ; out [ outOff + 5 ] = ( byte ) ( word > > > 16 ) ; out [ outOff + 6 ] = ( byte ) ( word > > > 8 ) ; out [ outOff + 7 ] = ( byte ) word ; } 
private void adjustByteCounts ( ) { if ( byteCount1 > 0x1fffffffffffffffL ) { 
protected void processLength ( long lowW , long hiW ) { if ( wOff > 14 ) { processBlock ( ) ; } W [ 14 ] = hiW ; W [ 15 ] = lowW ; } 
protected void processBlock ( ) { adjustByteCounts ( ) ; expand 16 word block into 80 word blocks. for (int t = 16; t <= 79; t++) { W[t] = Sigma1(W[t - 2]) + W[t - 7] + Sigma0(W[t - 15]) + W[t - 16]; } set up working variables. long a = H1; long b = H2; long c = H3; long d = H4; long e = H5; long f = H6; long g = H7; long h = H8; int t = 0; for(int i = 0; i < 10; i ++) { t = 8 * i h += Sum1(e) + Ch(e, f, g) + K[t] + W[t++]; d += h; h += Sum0(a) + Maj(a, b, c); t = 8 * i + 1 g += Sum1(d) + Ch(d, e, f) + K[t] + W[t++]; c += g; g += Sum0(h) + Maj(h, a, b); t = 8 * i + 2 f += Sum1(c) + Ch(c, d, e) + K[t] + W[t++]; b += f; f += Sum0(g) + Maj(g, h, a); t = 8 * i + 3 e += Sum1(b) + Ch(b, c, d) + K[t] + W[t++]; a += e; e += Sum0(f) + Maj(f, g, h); t = 8 * i + 4 d += Sum1(a) + Ch(a, b, c) + K[t] + W[t++]; h += d; d += Sum0(e) + Maj(e, f, g); t = 8 * i + 5 c += Sum1(h) + Ch(h, a, b) + K[t] + W[t++]; g += c; c += Sum0(d) + Maj(d, e, f); t = 8 * i + 6 b += Sum1(g) + Ch(g, h, a) + K[t] + W[t++]; f += b; b += Sum0(c) + Maj(c, d, e); t = 8 * i + 7 a += Sum1(f) + Ch(f, g, h) + K[t] + W[t++]; e += a; a += Sum0(b) + Maj(b, c, d); } H1 += a; H2 += b; H3 += c; H4 += d; H5 += e; H6 += f; H7 += g; H8 += h; reset the offset and clean out the word buffer. wOff = 0; for (int i = 0; i < 16; i++) { 
private long Ch ( long x , long y , long z ) { return ( ( x & y ) ^ ( ( ~ x ) & z ) ) ; } 
private long Maj ( long x , long y , long z ) { return ( ( x & y ) ^ ( x & z ) ^ ( y & z ) ) ; } 
private long Sum0 ( long x ) { return ( ( x < < 36 ) | ( x > > > 28 ) ) ^ ( ( x < < 30 ) | ( x > > > 34 ) ) ^ ( ( x < < 25 ) | ( x > > > 39 ) ) ; } 
private long Sum1 ( long x ) { return ( ( x < < 50 ) | ( x > > > 14 ) ) ^ ( ( x < < 46 ) | ( x > > > 18 ) ) ^ ( ( x < < 23 ) | ( x > > > 41 ) ) ; } 
private long Sigma0 ( long x ) { return ( ( x < < 63 ) | ( x > > > 1 ) ) ^ ( ( x < < 56 ) | ( x > > > 8 ) ) ^ ( x > > > 7 ) ; } 
private long Sigma1 ( long x ) { return ( ( x < < 45 ) | ( x > > > 19 ) ) ^ ( ( x < < 3 ) | ( x > > > 61 ) ) ^ ( x > > > 6 ) ; } 
protected void processWord ( byte [ ] in , int inOff ) { X [ xOff + + ] = ( in [ inOff ] & 0xff ) < < 24 | ( in [ inOff + 1 ] & 0xff ) < < 16 | ( in [ inOff + 2 ] & 0xff ) < < 8 | in [ inOff + 3 ] & 0xff ; if ( xOff = = 16 ) { 
private void unpackWord ( int word , byte [ ] out , int outOff ) { out [ outOff + + ] = ( byte ) ( word > > > 24 ) ; out [ outOff + + ] = ( byte ) ( word > > > 16 ) ; out [ outOff + + ] = ( byte ) ( word > > > 8 ) ; out [ outOff + + ] = ( byte ) word ; } 
protected void processLength ( long bitLength ) { if ( xOff > 14 ) { processBlock ( ) ; } X [ 14 ] = ( int ) ( bitLength > > > 32 ) ; X [ 15 ] = ( int ) ( bitLength & 0xffffffff ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H1 , out , outOff ) ; unpackWord ( H2 , out , outOff + 4 ) ; unpackWord ( H3 , out , outOff + 8 ) ; unpackWord ( H4 , out , outOff + 12 ) ; unpackWord ( H5 , out , outOff + 16 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H1 = 0x67452301 ; H2 = 0xefcdab89 ; H3 = 0x98badcfe ; H4 = 0x10325476 ; H5 = 0xc3d2e1f0 ; xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { 
private int f ( int u , int v , int w ) { return ( ( u & v ) | ( ( ~ u ) & w ) ) ; } 
private int h ( int u , int v , int w ) { return ( u ^ v ^ w ) ; } 
private int g ( int u , int v , int w ) { return ( ( u & v ) | ( u & w ) | ( v & w ) ) ; } 
protected void processBlock ( ) { expand 16 word block into 80 word block. for (int i = 16; i < 80; i++) { int t = X[i - 3] ^ X[i - 8] ^ X[i - 14] ^ X[i - 16]; X[i] = t << 1 | t >>> 31; } set up working variables. int A = H1; int B = H2; int C = H3; int D = H4; int E = H5; round 1 int idx = 0; for (int j = 0; j < 4; j++) { E = rotateLeft(A, 5) + f(B, C, D) + E + X[idx++] + Y1 B = rotateLeft(B, 30) E += (A << 5 | A >>> 27) + f(B, C, D) + X[idx++] + Y1; B = B << 30 | B >>> 2; D += (E << 5 | E >>> 27) + f(A, B, C) + X[idx++] + Y1; A = A << 30 | A >>> 2; C += (D << 5 | D >>> 27) + f(E, A, B) + X[idx++] + Y1; E = E << 30 | E >>> 2; B += (C << 5 | C >>> 27) + f(D, E, A) + X[idx++] + Y1; D = D << 30 | D >>> 2; A += (B << 5 | B >>> 27) + f(C, D, E) + X[idx++] + Y1; C = C << 30 | C >>> 2; } round 2 for (int j = 0; j < 4; j++) { E = rotateLeft(A, 5) + h(B, C, D) + E + X[idx++] + Y2 B = rotateLeft(B, 30) E += (A << 5 | A >>> 27) + h(B, C, D) + X[idx++] + Y2; B = B << 30 | B >>> 2; D += (E << 5 | E >>> 27) + h(A, B, C) + X[idx++] + Y2; A = A << 30 | A >>> 2; C += (D << 5 | D >>> 27) + h(E, A, B) + X[idx++] + Y2; E = E << 30 | E >>> 2; B += (C << 5 | C >>> 27) + h(D, E, A) + X[idx++] + Y2; D = D << 30 | D >>> 2; A += (B << 5 | B >>> 27) + h(C, D, E) + X[idx++] + Y2; C = C << 30 | C >>> 2; } round 3 for (int j = 0; j < 4; j++) { E = rotateLeft(A, 5) + g(B, C, D) + E + X[idx++] + Y3 B = rotateLeft(B, 30) E += (A << 5 | A >>> 27) + g(B, C, D) + X[idx++] + Y3; B = B << 30 | B >>> 2; D += (E << 5 | E >>> 27) + g(A, B, C) + X[idx++] + Y3; A = A << 30 | A >>> 2; C += (D << 5 | D >>> 27) + g(E, A, B) + X[idx++] + Y3; E = E << 30 | E >>> 2; B += (C << 5 | C >>> 27) + g(D, E, A) + X[idx++] + Y3; D = D << 30 | D >>> 2; A += (B << 5 | B >>> 27) + g(C, D, E) + X[idx++] + Y3; C = C << 30 | C >>> 2; } round 4 for (int j = 0; j <= 3; j++) { E = rotateLeft(A, 5) + h(B, C, D) + E + X[idx++] + Y4 B = rotateLeft(B, 30) E += (A << 5 | A >>> 27) + h(B, C, D) + X[idx++] + Y4; B = B << 30 | B >>> 2; D += (E << 5 | E >>> 27) + h(A, B, C) + X[idx++] + Y4; A = A << 30 | A >>> 2; C += (D << 5 | D >>> 27) + h(E, A, B) + X[idx++] + Y4; E = E << 30 | E >>> 2; B += (C << 5 | C >>> 27) + h(D, E, A) + X[idx++] + Y4; D = D << 30 | D >>> 2; A += (B << 5 | B >>> 27) + h(C, D, E) + X[idx++] + Y4; C = C << 30 | C >>> 2; } H1 += A; H2 += B; H3 += C; H4 += D; H5 += E; reset start of the buffer. xOff = 0; for (int i = 0; i < 16; i++) { 
protected void processWord ( byte [ ] in , int inOff ) { X [ xOff + + ] = ( ( in [ inOff ] & 0xff ) < < 24 ) | ( ( in [ inOff + 1 ] & 0xff ) < < 16 ) | ( ( in [ inOff + 2 ] & 0xff ) < < 8 ) | ( ( in [ inOff + 3 ] & 0xff ) ) ; if ( xOff = = 16 ) { 
private void unpackWord ( int word , byte [ ] out , int outOff ) { out [ outOff ] = ( byte ) ( word > > > 24 ) ; out [ outOff + 1 ] = ( byte ) ( word > > > 16 ) ; out [ outOff + 2 ] = ( byte ) ( word > > > 8 ) ; out [ outOff + 3 ] = ( byte ) word ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H1 , out , outOff ) ; unpackWord ( H2 , out , outOff + 4 ) ; unpackWord ( H3 , out , outOff + 8 ) ; unpackWord ( H4 , out , outOff + 12 ) ; unpackWord ( H5 , out , outOff + 16 ) ; unpackWord ( H6 , out , outOff + 20 ) ; unpackWord ( H7 , out , outOff + 24 ) ; unpackWord ( H8 , out , outOff + 28 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H1 = 0x6a09e667 ; H2 = 0xbb67ae85 ; H3 = 0x3c6ef372 ; H4 = 0xa54ff53a ; H5 = 0x510e527f ; H6 = 0x9b05688c ; H7 = 0x1f83d9ab ; H8 = 0x5be0cd19 ; xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { 
protected void processBlock ( ) { expand 16 word block into 64 word blocks. for (int t = 16; t <= 63; t++) { X[t] = Theta1(X[t - 2]) + X[t - 7] + Theta0(X[t - 15]) + X[t - 16]; } set up working variables. int a = H1; int b = H2; int c = H3; int d = H4; int e = H5; int f = H6; int g = H7; int h = H8; int t = 0; for(int i = 0; i < 8; i ++) { t = 8 * i h += Sum1(e) + Ch(e, f, g) + K[t] + X[t++]; d += h; h += Sum0(a) + Maj(a, b, c); t = 8 * i + 1 g += Sum1(d) + Ch(d, e, f) + K[t] + X[t++]; c += g; g += Sum0(h) + Maj(h, a, b); t = 8 * i + 2 f += Sum1(c) + Ch(c, d, e) + K[t] + X[t++]; b += f; f += Sum0(g) + Maj(g, h, a); t = 8 * i + 3 e += Sum1(b) + Ch(b, c, d) + K[t] + X[t++]; a += e; e += Sum0(f) + Maj(f, g, h); t = 8 * i + 4 d += Sum1(a) + Ch(a, b, c) + K[t] + X[t++]; h += d; d += Sum0(e) + Maj(e, f, g); t = 8 * i + 5 c += Sum1(h) + Ch(h, a, b) + K[t] + X[t++]; g += c; c += Sum0(d) + Maj(d, e, f); t = 8 * i + 6 b += Sum1(g) + Ch(g, h, a) + K[t] + X[t++]; f += b; b += Sum0(c) + Maj(c, d, e); t = 8 * i + 7 a += Sum1(f) + Ch(f, g, h) + K[t] + X[t++]; e += a; a += Sum0(b) + Maj(b, c, d); } H1 += a; H2 += b; H3 += c; H4 += d; H5 += e; H6 += f; H7 += g; H8 += h; reset the offset and clean out the word buffer. xOff = 0; for (int i = 0; i < 16; i++) { 
private int Ch ( int x , int y , int z ) { return ( x & y ) ^ ( ( ~ x ) & z ) ; } 
private int Maj ( int x , int y , int z ) { return ( x & y ) ^ ( x & z ) ^ ( y & z ) ; } 
private int Sum0 ( int x ) { return ( ( x > > > 2 ) | ( x < < 30 ) ) ^ ( ( x > > > 13 ) | ( x < < 19 ) ) ^ ( ( x > > > 22 ) | ( x < < 10 ) ) ; } 
private int Sum1 ( int x ) { return ( ( x > > > 6 ) | ( x < < 26 ) ) ^ ( ( x > > > 11 ) | ( x < < 21 ) ) ^ ( ( x > > > 25 ) | ( x < < 7 ) ) ; } 
private int Theta0 ( int x ) { return ( ( x > > > 7 ) | ( x < < 25 ) ) ^ ( ( x > > > 18 ) | ( x < < 14 ) ) ^ ( x > > > 3 ) ; } 
private int Theta1 ( int x ) { return ( ( x > > > 17 ) | ( x < < 15 ) ) ^ ( ( x > > > 19 ) | ( x < < 13 ) ) ^ ( x > > > 10 ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H1 , out , outOff ) ; unpackWord ( H2 , out , outOff + 8 ) ; unpackWord ( H3 , out , outOff + 16 ) ; unpackWord ( H4 , out , outOff + 24 ) ; unpackWord ( H5 , out , outOff + 32 ) ; unpackWord ( H6 , out , outOff + 40 ) ; unpackWord ( H7 , out , outOff + 48 ) ; unpackWord ( H8 , out , outOff + 56 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H1 = 0x6a09e667f3bcc908L ; H2 = 0xbb67ae8584caa73bL ; H3 = 0x3c6ef372fe94f82bL ; H4 = 0xa54ff53a5f1d36f1L ; H5 = 0x510e527fade682d1L ; H6 = 0x9b05688c2b3e6c1fL ; H7 = 0x1f83d9abfb41bd6bL ; H8 = 0x5be0cd19137e2179L ; } 
private int shift ( int r , int shift ) { return ( r > > > shift ) | ( r < < - shift ) ; } 
private int FFmulX ( int x ) { return ( ( ( x & m2 ) < < 1 ) ^ ( ( ( x & m1 ) > > > 7 ) * m3 ) ) ; } 
private int inv_mcol ( int x ) { int f2 = FFmulX ( x ) ; int f4 = FFmulX ( f2 ) ; int f8 = FFmulX ( f4 ) ; int f9 = x ^ f8 ; return f2 ^ f4 ^ f8 ^ shift ( f2 ^ f9 , 8 ) ^ shift ( f4 ^ f9 , 16 ) ^ shift ( f9 , 24 ) ; } 
private int subWord ( int x ) { return ( S [ x & 255 ] & 255 | ( ( S [ ( x > > 8 ) & 255 ] & 255 ) < < 8 ) | ( ( S [ ( x > > 16 ) & 255 ] & 255 ) < < 16 ) | S [ ( x > > 24 ) & 255 ] < < 24 ) ; } 
private int [ ] [ ] generateWorkingKey ( byte [ ] key , boolean forEncryption ) { int KC = key . length / 4 ; key length in words int t; if (((KC != 4) && (KC != 6) && (KC != 8)) || ((KC * 4) != key.length)) { throw new IllegalArgumentException("Key length not 128/192/256 bits."); } ROUNDS = KC + 6; This is not always true for the generalized Rijndael that allows larger block sizes int[][] W = new int[ROUNDS+1][4]; 4 words in a block copy the key into the round key array t = 0; int i = 0; while (i < key.length) { W[t >> 2][t & 3] = (key[i]&0xff) | ((key[i+1]&0xff) << 8) | ((key[i+2]&0xff) << 16) | (key[i+3] << 24); i+=4; t++; } while not enough round key material calculated calculate new values int k = (ROUNDS + 1) << 2; for (i = KC; (i < k); i++) { int temp = W[(i-1)>>2][(i-1)&3]; if ((i % KC) == 0) { temp = subWord(shift(temp, 8)) ^ rcon[(i / KC)-1]; } else if ((KC > 6) && ((i % KC) == 4)) { temp = subWord(temp); } W[i>>2][i&3] = W[(i - KC)>>2][(i-KC)&3] ^ temp; } if (!forEncryption) { for (int j = 1; j < ROUNDS; j++) { for (i = 0; i < 4; i++) { W[j][i] = inv_mcol(W[j][i]); } } } return W; } 
public void init ( boolean forEncryption , CipherParameters params ) { if ( params instanceof KeyParameter ) { WorkingKey = generateWorkingKey ( ( ( KeyParameter ) params ) . getKey ( ) , forEncryption ) ; his . forEncryption = forEncryption ; return ; } hrow new IllegalArgumentException ( " invalid parameter passed to AES init - " + params . getClass ( ) . getName ( ) ) ; } 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) { if ( WorkingKey = = null ) { hrow new IllegalStateException ( " AES engine not initialised " ) ; } if ( ( inOff + ( 32 / 2 ) ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + ( 32 / 2 ) ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } if ( forEncryption ) { unpackBlock ( in , inOff ) ; encryptBlock ( WorkingKey ) ; packBlock ( out , outOff ) ; } else { unpackBlock ( in , inOff ) ; decryptBlock ( WorkingKey ) ; packBlock ( out , outOff ) ; } return BLOCK_SIZE ; } 
private final void unpackBlock ( byte [ ] bytes , int off ) { int index = off ; C0 = ( bytes [ index + + ] & 0xff ) ; C0 | = ( bytes [ index + + ] & 0xff ) < < 8 ; C0 | = ( bytes [ index + + ] & 0xff ) < < 16 ; C0 | = bytes [ index + + ] < < 24 ; C1 = ( bytes [ index + + ] & 0xff ) ; C1 | = ( bytes [ index + + ] & 0xff ) < < 8 ; C1 | = ( bytes [ index + + ] & 0xff ) < < 16 ; C1 | = bytes [ index + + ] < < 24 ; C2 = ( bytes [ index + + ] & 0xff ) ; C2 | = ( bytes [ index + + ] & 0xff ) < < 8 ; C2 | = ( bytes [ index + + ] & 0xff ) < < 16 ; C2 | = bytes [ index + + ] < < 24 ; C3 = ( bytes [ index + + ] & 0xff ) ; C3 | = ( bytes [ index + + ] & 0xff ) < < 8 ; C3 | = ( bytes [ index + + ] & 0xff ) < < 16 ; C3 | = bytes [ index + + ] < < 24 ; } 
private final void packBlock ( byte [ ] bytes , int off ) { int index = off ; bytes [ index + + ] = ( byte ) C0 ; bytes [ index + + ] = ( byte ) ( C0 > > 8 ) ; bytes [ index + + ] = ( byte ) ( C0 > > 16 ) ; bytes [ index + + ] = ( byte ) ( C0 > > 24 ) ; bytes [ index + + ] = ( byte ) C1 ; bytes [ index + + ] = ( byte ) ( C1 > > 8 ) ; bytes [ index + + ] = ( byte ) ( C1 > > 16 ) ; bytes [ index + + ] = ( byte ) ( C1 > > 24 ) ; bytes [ index + + ] = ( byte ) C2 ; bytes [ index + + ] = ( byte ) ( C2 > > 8 ) ; bytes [ index + + ] = ( byte ) ( C2 > > 16 ) ; bytes [ index + + ] = ( byte ) ( C2 > > 24 ) ; bytes [ index + + ] = ( byte ) C3 ; bytes [ index + + ] = ( byte ) ( C3 > > 8 ) ; bytes [ index + + ] = ( byte ) ( C3 > > 16 ) ; bytes [ index + + ] = ( byte ) ( C3 > > 24 ) ; } 
private final void encryptBlock ( int [ ] [ ] KW ) { int r , r0 , r1 , r2 , r3 ; C0 ^ = KW [ 0 ] [ 0 ] ; C1 ^ = KW [ 0 ] [ 1 ] ; C2 ^ = KW [ 0 ] [ 2 ] ; C3 ^ = KW [ 0 ] [ 3 ] ; r = 1 ; while ( r < ROUNDS - 1 ) { r0 = T0 [ C0 & 255 ] ^ shift ( T0 [ ( C1 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C2 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; r1 = T0 [ C1 & 255 ] ^ shift ( T0 [ ( C2 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C3 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C0 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; r2 = T0 [ C2 & 255 ] ^ shift ( T0 [ ( C3 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C0 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; r3 = T0 [ C3 & 255 ] ^ shift ( T0 [ ( C0 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C1 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C2 > > 24 ) & 255 ] , 8 ) ^ KW [ r + + ] [ 3 ] ; C0 = T0 [ r0 & 255 ] ^ shift ( T0 [ ( r1 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( r2 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( r3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; C1 = T0 [ r1 & 255 ] ^ shift ( T0 [ ( r2 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( r3 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( r0 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; C2 = T0 [ r2 & 255 ] ^ shift ( T0 [ ( r3 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( r0 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( r1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; C3 = T0 [ r3 & 255 ] ^ shift ( T0 [ ( r0 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( r1 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( r2 > > 24 ) & 255 ] , 8 ) ^ KW [ r + + ] [ 3 ] ; } r0 = T0 [ C0 & 255 ] ^ shift ( T0 [ ( C1 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C2 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; r1 = T0 [ C1 & 255 ] ^ shift ( T0 [ ( C2 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C3 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C0 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; r2 = T0 [ C2 & 255 ] ^ shift ( T0 [ ( C3 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C0 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; r3 = T0 [ C3 & 255 ] ^ shift ( T0 [ ( C0 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C1 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C2 > > 24 ) & 255 ] , 8 ) ^ KW [ r + + ] [ 3 ] ; the final round's table is a simple function of S so we don't use a whole other four tables for it C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((S[(r2>>16)&255]&255)<<16) ^ (S[(r3>>24)&255]<<24) ^ KW[r][0]; C1 = (S[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (S[(r0>>24)&255]<<24) ^ KW[r][1]; C2 = (S[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2]; C3 = (S[r3&255]&255) ^ ((S[(r0>>8)&255]&255)<<8) ^ ((S[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3]; 
private final void decryptBlock ( int [ ] [ ] KW ) { int r , r0 , r1 , r2 , r3 ; C0 ^ = KW [ ROUNDS ] [ 0 ] ; C1 ^ = KW [ ROUNDS ] [ 1 ] ; C2 ^ = KW [ ROUNDS ] [ 2 ] ; C3 ^ = KW [ ROUNDS ] [ 3 ] ; r = ROUNDS - 1 ; while ( r > 1 ) { r0 = Tinv0 [ C0 & 255 ] ^ shift ( Tinv0 [ ( C3 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C2 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; r1 = Tinv0 [ C1 & 255 ] ^ shift ( Tinv0 [ ( C0 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C3 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C2 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; r2 = Tinv0 [ C2 & 255 ] ^ shift ( Tinv0 [ ( C1 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C0 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; r3 = Tinv0 [ C3 & 255 ] ^ shift ( Tinv0 [ ( C2 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C1 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C0 > > 24 ) & 255 ] , 8 ) ^ KW [ r - - ] [ 3 ] ; C0 = Tinv0 [ r0 & 255 ] ^ shift ( Tinv0 [ ( r3 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( r2 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( r1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; C1 = Tinv0 [ r1 & 255 ] ^ shift ( Tinv0 [ ( r0 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( r3 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( r2 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; C2 = Tinv0 [ r2 & 255 ] ^ shift ( Tinv0 [ ( r1 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( r0 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( r3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; C3 = Tinv0 [ r3 & 255 ] ^ shift ( Tinv0 [ ( r2 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( r1 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( r0 > > 24 ) & 255 ] , 8 ) ^ KW [ r - - ] [ 3 ] ; } r0 = Tinv0 [ C0 & 255 ] ^ shift ( Tinv0 [ ( C3 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C2 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; r1 = Tinv0 [ C1 & 255 ] ^ shift ( Tinv0 [ ( C0 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C3 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C2 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; r2 = Tinv0 [ C2 & 255 ] ^ shift ( Tinv0 [ ( C1 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C0 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; r3 = Tinv0 [ C3 & 255 ] ^ shift ( Tinv0 [ ( C2 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C1 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C0 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 3 ] ; the final round's table is a simple function of Si so we don't use a whole other four tables for it C0 = (Si[r0&255]&255) ^ ((Si[(r3>>8)&255]&255)<<8) ^ ((Si[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0]; C1 = (Si[r1&255]&255) ^ ((Si[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (Si[(r2>>24)&255]<<24) ^ KW[0][1]; C2 = (Si[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (Si[(r3>>24)&255]<<24) ^ KW[0][2]; C3 = (Si[r3&255]&255) ^ ((Si[(r2>>8)&255]&255)<<8) ^ ((Si[(r1>>16)&255]&255)<<16) ^ (Si[(r0>>24)&255]<<24) ^ KW[0][3]; } 
public void init ( boolean encrypting , CipherParameters params ) { if ( params instanceof KeyParameter ) { his . encrypting = encrypting ; his . workingKey = ( ( KeyParameter ) params ) . getKey ( ) ; his . k64Cnt = ( his . workingKey . length / 8 ) ; pre-padded ? setKey(this.workingKey); return; } throw new IllegalArgumentException("invalid parameter passed to Twofish init - " + params.getClass().getName()); } 
public final int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) { if ( workingKey = = null ) { hrow new IllegalStateException ( " Twofish not initialised " ) ; } if ( ( inOff + BLOCK_SIZE ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + BLOCK_SIZE ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } if ( encrypting ) { encryptBlock ( in , inOff , out , outOff ) ; } else { decryptBlock ( in , inOff , out , outOff ) ; } return BLOCK_SIZE ; } 
public void reset ( ) { if ( his . workingKey ! = null ) { 
private void encryptBlock ( byte [ ] src , int srcIndex , byte [ ] dst , int dstIndex ) { int x0 = BytesTo32Bits ( src , srcIndex ) ^ gSubKeys [ INPUT_WHITEN ] ; int x1 = BytesTo32Bits ( src , srcIndex + 4 ) ^ gSubKeys [ INPUT_WHITEN + 1 ] ; int x2 = BytesTo32Bits ( src , srcIndex + 8 ) ^ gSubKeys [ INPUT_WHITEN + 2 ] ; int x3 = BytesTo32Bits ( src , srcIndex + 12 ) ^ gSubKeys [ INPUT_WHITEN + 3 ] ; int k = ROUND_SUBKEYS ; int 0 , 1 ; for ( int r = 0 ; r < ROUNDS ; r + = 2 ) { 0 = Fe32_0 ( x0 ) ; 1 = Fe32_3 ( x1 ) ; x2 ^ = 0 + 1 + gSubKeys [ k + + ] ; x2 = x2 > > > 1 | x2 < < 31 ; x3 = ( x3 < < 1 | x3 > > > 31 ) ^ ( 0 + 2 * 1 + gSubKeys [ k + + ] ) ; 0 = Fe32_0 ( x2 ) ; 1 = Fe32_3 ( x3 ) ; x0 ^ = 0 + 1 + gSubKeys [ k + + ] ; x0 = x0 > > > 1 | x0 < < 31 ; x1 = ( x1 < < 1 | x1 > > > 31 ) ^ ( 0 + 2 * 1 + gSubKeys [ k + + ] ) ; } Bits32ToBytes ( x2 ^ gSubKeys [ OUTPUT_WHITEN ] , dst , dstIndex ) ; Bits32ToBytes ( x3 ^ gSubKeys [ OUTPUT_WHITEN + 1 ] , dst , dstIndex + 4 ) ; Bits32ToBytes ( x0 ^ gSubKeys [ OUTPUT_WHITEN + 2 ] , dst , dstIndex + 8 ) ; Bits32ToBytes ( x1 ^ gSubKeys [ OUTPUT_WHITEN + 3 ] , dst , dstIndex + 12 ) ; } 
private void decryptBlock ( byte [ ] src , int srcIndex , byte [ ] dst , int dstIndex ) { int x2 = BytesTo32Bits ( src , srcIndex ) ^ gSubKeys [ OUTPUT_WHITEN ] ; int x3 = BytesTo32Bits ( src , srcIndex + 4 ) ^ gSubKeys [ OUTPUT_WHITEN + 1 ] ; int x0 = BytesTo32Bits ( src , srcIndex + 8 ) ^ gSubKeys [ OUTPUT_WHITEN + 2 ] ; int x1 = BytesTo32Bits ( src , srcIndex + 12 ) ^ gSubKeys [ OUTPUT_WHITEN + 3 ] ; int k = ROUND_SUBKEYS + 2 * ROUNDS - 1 ; int 0 , 1 ; for ( int r = 0 ; r < ROUNDS ; r + = 2 ) { 0 = Fe32_0 ( x2 ) ; 1 = Fe32_3 ( x3 ) ; x1 ^ = 0 + 2 * 1 + gSubKeys [ k - - ] ; x0 = ( x0 < < 1 | x0 > > > 31 ) ^ ( 0 + 1 + gSubKeys [ k - - ] ) ; x1 = x1 > > > 1 | x1 < < 31 ; 0 = Fe32_0 ( x0 ) ; 1 = Fe32_3 ( x1 ) ; x3 ^ = 0 + 2 * 1 + gSubKeys [ k - - ] ; x2 = ( x2 < < 1 | x2 > > > 31 ) ^ ( 0 + 1 + gSubKeys [ k - - ] ) ; x3 = x3 > > > 1 | x3 < < 31 ; } Bits32ToBytes ( x0 ^ gSubKeys [ INPUT_WHITEN ] , dst , dstIndex ) ; Bits32ToBytes ( x1 ^ gSubKeys [ INPUT_WHITEN + 1 ] , dst , dstIndex + 4 ) ; Bits32ToBytes ( x2 ^ gSubKeys [ INPUT_WHITEN + 2 ] , dst , dstIndex + 8 ) ; Bits32ToBytes ( x3 ^ gSubKeys [ INPUT_WHITEN + 3 ] , dst , dstIndex + 12 ) ; } 
private final int F32 ( int x , int [ ] k32 ) { int b0 = b0 ( x ) ; int b1 = b1 ( x ) ; int b2 = b2 ( x ) ; int b3 = b3 ( x ) ; int k0 = k32 [ 0 ] ; int k1 = k32 [ 1 ] ; int k2 = k32 [ 2 ] ; int k3 = k32 [ 3 ] ; int result = 0 ; switch ( k64Cnt & 3 ) { case 1 : result = gMDS0 [ ( P [ P_01 ] [ b0 ] & 0xff ) ^ b0 ( k0 ) ] ^ gMDS1 [ ( P [ P_11 ] [ b1 ] & 0xff ) ^ b1 ( k0 ) ] ^ gMDS2 [ ( P [ P_21 ] [ b2 ] & 0xff ) ^ b2 ( k0 ) ] ^ gMDS3 [ ( P [ P_31 ] [ b3 ] & 0xff ) ^ b3 ( k0 ) ] ; break ; case 0 : b0 = ( P [ P_04 ] [ b0 ] & 0xff ) ^ b0 ( k3 ) ; b1 = ( P [ P_14 ] [ b1 ] & 0xff ) ^ b1 ( k3 ) ; b2 = ( P [ P_24 ] [ b2 ] & 0xff ) ^ b2 ( k3 ) ; b3 = ( P [ P_34 ] [ b3 ] & 0xff ) ^ b3 ( k3 ) ; case 3 : b0 = ( P [ P_03 ] [ b0 ] & 0xff ) ^ b0 ( k2 ) ; b1 = ( P [ P_13 ] [ b1 ] & 0xff ) ^ b1 ( k2 ) ; b2 = ( P [ P_23 ] [ b2 ] & 0xff ) ^ b2 ( k2 ) ; b3 = ( P [ P_33 ] [ b3 ] & 0xff ) ^ b3 ( k2 ) ; case 2 : result = gMDS0 [ ( P [ P_01 ] [ ( P [ P_02 ] [ b0 ] & 0xff ) ^ b0 ( k1 ) ] & 0xff ) ^ b0 ( k0 ) ] ^ gMDS1 [ ( P [ P_11 ] [ ( P [ P_12 ] [ b1 ] & 0xff ) ^ b1 ( k1 ) ] & 0xff ) ^ b1 ( k0 ) ] ^ gMDS2 [ ( P [ P_21 ] [ ( P [ P_22 ] [ b2 ] & 0xff ) ^ b2 ( k1 ) ] & 0xff ) ^ b2 ( k0 ) ] ^ gMDS3 [ ( P [ P_31 ] [ ( P [ P_32 ] [ b3 ] & 0xff ) ^ b3 ( k1 ) ] & 0xff ) ^ b3 ( k0 ) ] ; break ; } return result ; } 
private final int RS_MDS_Encode ( int k0 , int k1 ) { int r = k1 ; for ( int i = 0 ; i < 4 ; i + + ) shift 1 byte at a time { r = RS_rem(r); } r ^= k0; for (int i=0 ; i < 4 ; i++) { r = RS_rem(r); } return r; } 
private final int RS_rem ( int x ) { int b = ( x > > > 24 ) & 0xff ; int g2 = ( ( b < < 1 ) ^ ( ( b & 0x80 ) ! = 0 ? RS_GF_FDBK : 0 ) ) & 0xff ; int g3 = ( ( b > > > 1 ) ^ ( ( b & 0x01 ) ! = 0 ? ( RS_GF_FDBK > > > 1 ) : 0 ) ) ^ g2 ; return ( ( x < < 8 ) ^ ( g3 < < 24 ) ^ ( g2 < < 16 ) ^ ( g3 < < 8 ) ^ b ) ; } 
private final int LFSR1 ( int x ) { return ( x > > 1 ) ^ ( ( ( x & 0x01 ) ! = 0 ) ? GF256_FDBK_2 : 0 ) ; 
private final int LFSR2 ( int x ) { return ( x > > 2 ) ^ ( ( ( x & 0x02 ) ! = 0 ) ? GF256_FDBK_2 : 0 ) ^ 
private final int Mx_X ( int x ) { return x ^ LFSR2 ( x ) ; } 5B 
private final int Mx_Y ( int x ) { return x ^ LFSR1 ( x ) ^ LFSR2 ( x ) ; } EF 
private final int b0 ( int x ) { return x & 0xff ; } 
private final int b1 ( int x ) { return ( x > > > 8 ) & 0xff ; } 
private final int b2 ( int x ) { return ( x > > > 16 ) & 0xff ; } 
private final int b3 ( int x ) { return ( x > > > 24 ) & 0xff ; } 
private final int Fe32_0 ( int x ) { return gSBox [ 0x000 + 2 * ( x & 0xff ) ] ^ gSBox [ 0x001 + 2 * ( ( x > > > 8 ) & 0xff ) ] ^ 
private final int Fe32_3 ( int x ) { return gSBox [ 0x000 + 2 * ( ( x > > > 24 ) & 0xff ) ] ^ gSBox [ 0x001 + 2 * ( x & 0xff ) ] ^ 
private final int BytesTo32Bits ( byte [ ] b , int p ) { return ( ( b [ p ] & 0xff ) ) | ( ( b [ p + 1 ] & 0xff ) < < 8 ) | 
private final void Bits32ToBytes ( int in , byte [ ] b , int offset ) { b [ offset ] = ( byte ) in ; b [ offset + 1 ] = ( byte ) ( in > > 8 ) ; b [ offset + 2 ] = ( byte ) ( in > > 16 ) ; b [ offset + 3 ] = ( byte ) ( in > > 24 ) ; } 
private byte [ ] generateDerivedKey ( ) { byte [ ] digestBytes = new byte [ digest . getDigestSize ( ) ] ; digest . update ( password , 0 , password . length ) ; digest . update ( salt , 0 , salt . length ) ; digest . doFinal ( digestBytes , 0 ) ; for ( int i = 1 ; i < iterationCount ; i + + ) { digest . update ( digestBytes , 0 , digestBytes . length ) ; digest . doFinal ( digestBytes , 0 ) ; } return digestBytes ; } 
public CipherParameters generateDerivedMacParameters ( int keySize ) { return generateDerivedParameters ( keySize ) ; } 
private void F ( byte [ ] P , byte [ ] S , int c , byte [ ] iBuf , byte [ ] out , int outOff ) { byte [ ] state = new byte [ hMac . getMacSize ( ) ] ; CipherParameters param = new KeyParameter ( P ) ; hMac . init ( param ) ; if ( S ! = null ) { hMac . update ( S , 0 , S . length ) ; } hMac . update ( iBuf , 0 , iBuf . length ) ; hMac . doFinal ( state , 0 ) ; System . arraycopy ( state , 0 , out , outOff , state . length ) ; if ( c = = 0 ) { hrow new IllegalArgumentException ( " iteration count must be at least 1. " ) ; } for ( int count = 1 ; count < c ; count + + ) { 
private void intToOctet ( byte [ ] buf , int i ) { buf [ 0 ] = ( byte ) ( i > > > 24 ) ; buf [ 1 ] = ( byte ) ( i > > > 16 ) ; buf [ 2 ] = ( byte ) ( i > > > 8 ) ; buf [ 3 ] = ( byte ) i ; } 
private byte [ ] generateDerivedKey ( int dkLen ) { int hLen = hMac . getMacSize ( ) ; int l = ( dkLen + hLen - 1 ) / hLen ; byte [ ] iBuf = new byte [ 4 ] ; byte [ ] out = new byte [ l * hLen ] ; for ( int i = 1 ; i < = l ; i + + ) { intToOctet ( iBuf , i ) ; F ( password , salt , iterationCount , iBuf , out , ( i - 1 ) * hLen ) ; } return out ; } 
public CipherParameters generateDerivedParameters ( int keySize ) { keySize = keySize / 8 ; byte [ ] dKey = generateDerivedKey ( keySize ) ; return new KeyParameter ( dKey , 0 , keySize ) ; } 
public CipherParameters generateDerivedParameters ( int keySize , int ivSize ) { keySize = keySize / 8 ; ivSize = ivSize / 8 ; byte [ ] dKey = generateDerivedKey ( keySize + ivSize ) ; return new ParametersWithIV ( new KeyParameter ( dKey , 0 , keySize ) , dKey , keySize , ivSize ) ; } 
private static int getByteLength ( Digest digest ) { if ( digest instanceof ExtendedDigest ) { return ( ( ExtendedDigest ) digest ) . getByteLength ( ) ; } Integer b = ( Integer ) blockLengths . get ( digest . getAlgorithmName ( ) ) ; if ( b = = null ) { hrow new IllegalArgumentException ( " unknown digest passed: " + digest . getAlgorithmName ( ) ) ; } return b . intValue ( ) ; } 
public void init ( CipherParameters params ) { digest . reset ( ) ; byte [ ] key = ( ( KeyParameter ) params ) . getKey ( ) ; if ( key . length > blockLength ) { digest . update ( key , 0 , key . length ) ; digest . doFinal ( inputPad , 0 ) ; for ( int i = digestSize ; i < inputPad . length ; i + + ) { inputPad [ i ] = 0 ; } } else { System . arraycopy ( key , 0 , inputPad , 0 , key . length ) ; for ( int i = key . length ; i < inputPad . length ; i + + ) { inputPad [ i ] = 0 ; } } outputPad = new byte [ inputPad . length ] ; System . arraycopy ( inputPad , 0 , outputPad , 0 , inputPad . length ) ; for ( int i = 0 ; i < inputPad . length ; i + + ) { inputPad [ i ] ^ = IPAD ; } for ( int i = 0 ; i < outputPad . length ; i + + ) { outputPad [ i ] ^ = OPAD ; } digest . update ( inputPad , 0 , inputPad . length ) ; } 
public void update ( byte in ) { digest . update ( in ) ; } 
public void update ( byte [ ] in , int inOff , int len ) { digest . update ( in , inOff , len ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { byte [ ] mp = new byte [ digestSize ] ; digest . doFinal ( mp , 0 ) ; digest . update ( outputPad , 0 , outputPad . length ) ; digest . update ( mp , 0 , mp . length ) ; int len = digest . doFinal ( out , outOff ) ; reset ( ) ; return len ; } 
public void reset ( ) { digest . update ( inputPad , 0 , inputPad . length ) ; } 
public void init ( boolean encrypting , CipherParameters params ) hrows IllegalArgumentException { his . encrypting = encrypting ; if ( params instanceof ParametersWithIV ) { 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { return ( encrypting ) ? encryptBlock ( in , inOff , out , outOff ) : decryptBlock ( in , inOff , out , outOff ) ; } 
public void reset ( ) { System . arraycopy ( IV , 0 , cbcV , 0 , IV . length ) ; cipher . reset ( ) ; } 
private int encryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } System . arraycopy ( out , outOff , cbcV , 0 , cbcV . length ) ; return length ; } 
private int decryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } System . arraycopy ( in , inOff , cbcNextV , 0 , blockSize ) ; int length = cipher . processBlock ( in , inOff , out , outOff ) ; byte [ ] mp ; mp = cbcV ; cbcV = cbcNextV ; cbcNextV = mp ; return length ; } 
public void init ( SecureRandom random ) hrows IllegalArgumentException ; public int padCount ( byte [ ] in ) hrows InvalidCipherTextException ; } 
public String getPaddingName ( ) ; public int padCount ( byte [ ] in ) hrows InvalidCipherTextException ; } 
public int addPadding ( byte [ ] in , int inOff ) ; public int padCount ( byte [ ] in ) hrows InvalidCipherTextException ; } 
public int padCount ( byte [ ] in ) hrows InvalidCipherTextException ; } 
public int addPadding ( byte [ ] in , int inOff ) { byte code = ( byte ) ( in . length - inOff ) ; while ( inOff < in . length ) { in [ inOff ] = code ; inOff + + ; } return code ; } 
public int padCount ( byte [ ] in ) hrows InvalidCipherTextException { int count = in [ in . length - 1 ] & 0xff ; if ( count > in . length ) { hrow new InvalidCipherTextException ( " pad block corrupted " ) ; } for ( int i = 1 ; i < = count ; i + + ) { if ( in [ in . length - i ] ! = count ) { hrow new InvalidCipherTextException ( " pad block corrupted " ) ; } } return count ; } 
public void init ( boolean forEncryption , CipherParameters params ) hrows IllegalArgumentException { his . forEncryption = forEncryption ; reset ( ) ; if ( params instanceof ParametersWithRandom ) { 
public int getOutputSize ( int len ) { int otal = len + bufOff ; int leftOver = otal % buf . length ; if ( leftOver = = 0 ) { if ( forEncryption ) { return otal + buf . length ; } return otal ; } return otal - leftOver + buf . length ; } 
public int getUpdateOutputSize ( int len ) { int otal = len + bufOff ; int leftOver = otal % buf . length ; if ( leftOver = = 0 ) { return otal - buf . length ; } return otal - leftOver ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { int resultLen = 0 ; if ( bufOff = = buf . length ) { resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; } buf [ bufOff + + ] = in ; return resultLen ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { if ( len < 0 ) { hrow new IllegalArgumentException ( " Can't have a negative input length! " ) ; } int blockSize = getBlockSize ( ) ; int length = getUpdateOutputSize ( len ) ; if ( length > 0 ) { if ( ( outOff + length ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } } int resultLen = 0 ; int gapLen = buf . length - bufOff ; if ( len > gapLen ) { System . arraycopy ( in , inOff , buf , bufOff , gapLen ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; len - = gapLen ; inOff + = gapLen ; while ( len > buf . length ) { resultLen + = cipher . processBlock ( in , inOff , out , outOff + resultLen ) ; len - = blockSize ; inOff + = blockSize ; } } System . arraycopy ( in , inOff , buf , bufOff , len ) ; bufOff + = len ; return resultLen ; } 
public int doFinal ( byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException , InvalidCipherTextException { int blockSize = cipher . getBlockSize ( ) ; int resultLen = 0 ; if ( forEncryption ) { if ( bufOff = = blockSize ) { if ( ( outOff + 2 * blockSize ) > out . length ) { reset ( ) ; hrow new DataLengthException ( " output buffer too short " ) ; } resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; } padding . addPadding ( buf , bufOff ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff + resultLen ) ; reset ( ) ; } else { System . out . println ( " Decrypt " ) ; if ( bufOff = = blockSize ) { resultLen = cipher . processBlock ( buf , 0 , buf , 0 ) ; bufOff = 0 ; } else { reset ( ) ; hrow new DataLengthException ( " last block incomplete in decryption " ) ; } ry { resultLen - = padding . padCount ( buf ) ; System . arraycopy ( buf , 0 , out , outOff , resultLen ) ; } finally { reset ( ) ; } } return resultLen ; } 
public void addSeedMaterial ( byte [ ] inSeed ) { synchronized ( his ) { 
public void addSeedMaterial ( long rSeed ) { synchronized ( his ) { 
public void nextBytes ( byte [ ] bytes ) { nextBytes ( bytes , 0 , bytes . length ) ; } 
public void nextBytes ( byte [ ] bytes , int start , int len ) { synchronized ( his ) { 
private void digestUpdate ( long seed ) { for ( int i = 0 ; i ! = 8 ; i + + ) { 
private void digestUpdate ( byte [ ] inSeed ) { digest . update ( inSeed , 0 , inSeed . length ) ; } 
private void digestDoFinal ( byte [ ] result ) { digest . doFinal ( result , 0 ) ; } 
void addSeedMaterial ( byte [ ] seed ) ; void nextBytes ( byte [ ] bytes , int start , int len ) ; } 
void addSeedMaterial ( long seed ) ; void nextBytes ( byte [ ] bytes , int start , int len ) ; } 
void nextBytes ( byte [ ] bytes ) ; void nextBytes ( byte [ ] bytes , int start , int len ) ; } 
public static boolean areEqual ( byte [ ] a , byte [ ] b ) { if ( a = = b ) { return rue ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i ! = a . length ; i + + ) { if ( a [ i ] ! = b [ i ] ) { return false ; } } return rue ; } 
public static void fill ( byte [ ] array , byte value ) { for ( int i = 0 ; i < array . length ; i + + ) { 
public static void fill ( long [ ] array , long value ) { for ( int i = 0 ; i < array . length ; i + + ) { 
public static void fill ( short [ ] array , short value ) { for ( int i = 0 ; i < array . length ; i + + ) { 
public static int hashCode ( byte [ ] data ) { int value = 0 ; for ( int i = 0 ; i ! = data . length ; i + + ) { value ^ = ( data [ i ] & 0xff ) < < ( i % 4 ) ; } return value ; } 
public static byte [ ] clone ( byte [ ] data ) { byte [ ] copy = new byte [ data . length ] ; System . arraycopy ( data , 0 , copy , 0 , data . length ) ; return copy ; } 
int encode ( byte [ ] data , int off , int length , OutputStream out ) hrows IOException ; int decode ( byte [ ] data , int off , int length , OutputStream out ) hrows IOException ; int decode ( String data , OutputStream out ) hrows IOException ; } 
int decode ( byte [ ] data , int off , int length , OutputStream out ) hrows IOException ; int decode ( String data , OutputStream out ) hrows IOException ; } 
int decode ( String data , OutputStream out ) hrows IOException ; } 
public static byte [ ] encode ( byte [ ] data ) { return encode ( data , 0 , data . length ) ; } 
public static byte [ ] encode ( byte [ ] data , int off , int length ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ry { encoder . encode ( data , off , length , bOut ) ; } catch ( IOException e ) { hrow new RuntimeException ( " exception encoding Hex string: " + e ) ; } return bOut . oByteArray ( ) ; } 
public static int encode ( byte [ ] data , OutputStream out ) hrows IOException { return encoder . encode ( data , 0 , data . length , out ) ; } 
public static int encode ( byte [ ] data , int off , int length , OutputStream out ) hrows IOException { return encoder . encode ( data , off , length , out ) ; } 
public static byte [ ] decode ( byte [ ] data ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ry { encoder . decode ( data , 0 , data . length , bOut ) ; } catch ( IOException e ) { hrow new RuntimeException ( " exception decoding Hex string: " + e ) ; } return bOut . oByteArray ( ) ; } 
public static byte [ ] decode ( String data ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ry { encoder . decode ( data , bOut ) ; } catch ( IOException e ) { hrow new RuntimeException ( " exception decoding Hex string: " + e ) ; } return bOut . oByteArray ( ) ; } 
public static int decode ( String data , OutputStream out ) hrows IOException { return encoder . decode ( data , out ) ; } 
protected void initialiseDecodingTable ( ) { for ( int i = 0 ; i < encodingTable . length ; i + + ) { decodingTable [ encodingTable [ i ] ] = ( byte ) i ; } decodingTable [ 'A' ] = decodingTable [ 'a' ] ; decodingTable [ 'B' ] = decodingTable [ 'b' ] ; decodingTable [ 'C' ] = decodingTable [ 'c' ] ; decodingTable [ 'D' ] = decodingTable [ 'd' ] ; decodingTable [ 'E' ] = decodingTable [ 'e' ] ; decodingTable [ 'F' ] = decodingTable [ 'f' ] ; } 
public int encode ( byte [ ] data , int off , int length , OutputStream out ) hrows IOException { for ( int i = off ; i < ( off + length ) ; i + + ) { int v = data [ i ] & 0xff ; out . write ( encodingTable [ ( v > > > 4 ) ] ) ; out . write ( encodingTable [ v & 0xf ] ) ; } return length * 2 ; } 
private boolean ignore ( char c ) { return ( c = = '' | | c = = '\r' | | c = = '' | | c = = ' ' ) ; } 
public int decode ( byte [ ] data , int off , int length , OutputStream out ) hrows IOException { byte b1 , b2 ; int outLen = 0 ; int end = off + length ; while ( end > off ) { if ( ! ignore ( ( char ) data [ end - 1 ] ) ) { break ; } end - - ; } int i = off ; while ( i < end ) { while ( i < end & & ignore ( ( char ) data [ i ] ) ) { i + + ; } b1 = decodingTable [ data [ i + + ] ] ; while ( i < end & & ignore ( ( char ) data [ i ] ) ) { i + + ; } b2 = decodingTable [ data [ i + + ] ] ; out . write ( ( b1 < < 4 ) | b2 ) ; outLen + + ; } return outLen ; } 
public int decode ( String data , OutputStream out ) hrows IOException { byte b1 , b2 ; int length = 0 ; int end = data . length ( ) ; while ( end > 0 ) { if ( ! ignore ( data . charAt ( end - 1 ) ) ) { break ; } end - - ; } int i = 0 ; while ( i < end ) { while ( i < end & & ignore ( data . charAt ( i ) ) ) { i + + ; } b1 = decodingTable [ data . charAt ( i + + ) ] ; while ( i < end & & ignore ( data . charAt ( i ) ) ) { i + + ; } b2 = decodingTable [ data . charAt ( i + + ) ] ; out . write ( ( b1 < < 4 ) | b2 ) ; length + + ; } return length ; } 
public static boolean compare ( byte [ ] array1 , byte [ ] array2 ) { if ( array1 . length ! = array2 . length ) return false ; for ( int i = 0 ; i < array1 . length ; i + + ) if ( array1 [ i ] ! = array2 [ i ] ) return false ; return rue ; } 
public static void fill ( byte [ ] array , byte value ) { for ( int i = 0 ; i < array . length ; i + + ) array [ i ] = value ; return ; } 
public static byte [ ] makePad ( byte [ ] data ) { custom pad method TODO WRZ doesn't work (yet) append 0x80 plus zeros to a multiple of 4 bytes int thisblk = 32 - data.length % 32; bytes needed to finish blk int nextblk = 0; 32 if we need another block need 9 bytes; add new block if no room if( thisblk < 9 ) { nextblk = 32; } all bytes are zeroed for free byte[] pad = new byte[ thisblk + nextblk ]; pad[0] = (byte)0x80; write length*8 to end of final block int ix = thisblk + nextblk - 8; Types.writeInt( data.length>>29, pad, ix ); bsw32( pad, ix ); ix += 4; Types.writeInt( data.length<<3, pad, ix ); bsw32( pad, ix ); return pad; } 
public static void bsw32 ( byte [ ] ary , int offset ) { byte = ary [ offset ] ; ary [ offset ] = ary [ offset + 3 ] ; ary [ offset + 3 ] = ; = ary [ offset + 1 ] ; ary [ offset + 1 ] = ary [ offset + 2 ] ; ary [ offset + 2 ] = ; } 
static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) { cipher.processBytes (newKey, 0, newKey.length, newKey, 0); Hash once with SHA-256 SHA256Digest md = new SHA256Digest(); md.update(newKey, 0, newKey.length ); newKey = md.digest( newKey ); md.doFinal(newKey, 0); return newKey; } 
void readGroupField ( PwGroup grp , int fieldType , byte [ ] buf , int offset ) { switch ( fieldType ) { case 0x0000 : 
void readEntryField ( PwEntry ent , byte [ ] buf , int offset ) hrows UnsupportedEncodingException { int fieldType = Types . readShort ( buf , offset ) ; offset + = 2 ; int fieldSize = Types . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
static void estRijndael_JCE ( ) { byte [ ] aKey = new byte [ 32 ] ; byte [ ] aTest = new byte [ 16 ] ; byte [ ] aRef = new byte [ 16 ] ; hrow new RuntimeException( "JCE failed test" ); 
public void oBuf ( byte [ ] buf , int offset ) { hrow new RuntimeException ( " Method 'toBuf' not implemented yet " ) ; } 
public void addGroup ( Object group ) { groups . addElement ( group ) ; } 
public void addEntry ( Object entry ) { entries . addElement ( entry ) ; } 
public void constructTree ( PwGroup currentGroup ) { return; } 
public static int readInt ( byte buf [ ] , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) + ( ( buf [ offset + 2 ] & 0xFF ) < < 16 ) + ( ( buf [ offset + 3 ] & 0xFF ) < < 24 ) ; 
public static void writeInt ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0xFF ) ; buf [ offset + 1 ] = ( byte ) ( ( val > > > 8 ) & 0xFF ) ; buf [ offset + 2 ] = ( byte ) ( ( val > > > 16 ) & 0xFF ) ; buf [ offset + 3 ] = ( byte ) ( ( val > > > 24 ) & 0xFF ) ; } 
public static int readShort ( byte [ ] buf , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) ; } 
public static int readUByte ( byte [ ] buf , int offset ) { return ( ( int ) buf [ offset ] & 0xFF ) ; } 
public static int strlen ( byte [ ] buf , int offset ) { int len = 0 ; while ( buf [ offset + len ] ! = 0 ) len + + ; return len ; } 
public static byte [ ] extract ( byte [ ] b , int offset , int len ) { byte [ ] b2 = new byte [ len ] ; System . arraycopy ( b , offset , b2 , 0 , len ) ; return b2 ; } 
public static Date readTime ( byte [ ] buf , int offset ) { int dw1 = readUByte ( buf , offset ) ; int dw2 = readUByte ( buf , offset + 1 ) ; int dw3 = readUByte ( buf , offset + 2 ) ; int dw4 = readUByte ( buf , offset + 3 ) ; int dw5 = readUByte ( buf , offset + 4 ) ; Unpack 5 byte structure to date and time int year = (dw1 << 6) | (dw2 >> 2); int month = ((dw2 & 0x00000003) << 2) | (dw3 >> 6); int day = (dw3 >> 1) & 0x0000001F; int hour = ((dw3 & 0x00000001) << 4) | (dw4 >> 4); int minute = ((dw4 & 0x0000000F) << 2) | (dw5 >> 6); int second = dw5 & 0x0000003F; Calendar time = Calendar.getInstance(); time.set( year, month, day, hour, minute, second ); return time.getTime(); return null; } 
public static int LoadData ( String filename , String password ) { FileInputStream fis ; try { fis = new FileInputStream ( filename ) ; } catch ( FileNotFoundException e ) { return R . string . FileNotFound ; } ImporterV3 Importer = new ImporterV3 ( ) ; try { mPM = Importer . openDatabase ( fis , password ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } } catch ( InvalidCipherTextException e ) { return R . string . InvalidPassword ; } catch ( IOException e ) { return - 1 ; } return 0 ; 
private static void populateGlobals ( PwGroup currentGroup ) { if ( currentGroup = = null ) { Vector rootChildGroups = mPM . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroup cur = ( PwGroup ) rootChildGroups . elementAt ( i ) ; gRoot = cur . parent ; gGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; populateGlobals ( cur ) ; return ; } } Vector childGroups = currentGroup . childGroups ; Vector childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = ( PwEntry ) childEntries . elementAt ( i ) ; gEntries . put ( UUID . nameUUIDFromBytes ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = ( PwGroup ) childGroups . elementAt ( i ) ; 
public static void Launch ( Activity act , PwEntry pw ) { Intent i = new Intent ( act , EntryActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; act . startActivity ( i ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . entry_view ) ; Intent i = getIntent ( ) ; UUID uuid = UUID . nameUUIDFromBytes ( i . getByteArrayExtra ( KEY_ENTRY ) ) ; assert ( uuid ! = null ) ; mEntry = Database . gEntries . get ( uuid ) . get ( ) ; fillData ( ) ; } 
public static void Launch ( Activity act , PwGroup group ) { Intent i = new Intent ( act , GroupActivity . class ) ; if ( group ! = null ) { i . putExtra ( KEY_ENTRY , group . groupId ) ; } act . startActivity ( i ) ; } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; int size = mGroup . childGroups . size ( ) ; PwItemView iv ; if ( position < size ) { PwGroup group = ( PwGroup ) mGroup . childGroups . elementAt ( position ) ; iv = new PwGroupView ( his , group ) ; } else { PwEntry entry = ( PwEntry ) mGroup . childEntries . elementAt ( position - size ) ; iv = new PwEntryView ( his , entry ) ; } iv . onClick ( ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . list ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; if ( id = = - 1 ) { mGroup = Database . gRoot ; } else { mGroup = Database . gGroups . get ( id ) . get ( ) ; } assert ( mGroup ! = null ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; getListView ( ) . setTextFilterEnabled ( rue ) ; 
public void onClick ( View view ) { int result = Database . LoadData ( getEditText ( R . id . pass_filename ) , getEditText ( R . id . pass_password ) ) ; switch ( result ) { case 0 : 
private PwGroupView createGroupView ( int position , View convertView ) { PwGroupView gv ; if ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { PwGroup group = ( PwGroup ) mGroup . childGroups . elementAt ( position ) ; gv = new PwGroupView ( mAct , group ) ; } else { gv = ( PwGroupView ) convertView ; gv . setGroup ( ( PwGroup ) mGroup . childGroups . elementAt ( position ) ) ; } return gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; if ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { ev = new PwEntryView ( mAct , ( PwEntry ) mGroup . childEntries . elementAt ( position ) ) ; } else { ev = ( PwEntryView ) convertView ; ev . setEntry ( ( PwEntry ) mGroup . childEntries . elementAt ( position ) ) ; } return ev ; } 
public static void clear ( ) { gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; } 
protected void onResume ( ) { super . onResume ( ) ; } 
private View createGroupView ( int position , View convertView ) { PwGroupView gv ; if ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { PwGroup group = ( PwGroup ) mGroup . childGroups . elementAt ( position ) ; gv = new PwGroupView ( mAct , group ) ; } else { gv = ( PwGroupView ) convertView ; gv . setGroup ( ( PwGroup ) mGroup . childGroups . elementAt ( position ) ) ; } return gv ; } 
private static void populateGlobals ( PwGroup currentGroup ) { if ( currentGroup = = null ) { Vector rootChildGroups = mPM . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroup cur = ( PwGroup ) rootChildGroups . elementAt ( i ) ; gRoot = cur . parent ; gGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } Vector childGroups = currentGroup . childGroups ; Vector childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = ( PwEntry ) childEntries . elementAt ( i ) ; gEntries . put ( UUID . nameUUIDFromBytes ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = ( PwGroup ) childGroups . elementAt ( i ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . list ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; if ( id = = - 1 ) { mGroup = Database . gRoot ; } else { WeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; mGroup = wPw . get ( ) ; } assert ( mGroup ! = null ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; getListView ( ) . setTextFilterEnabled ( rue ) ; 
private void filter ( ) { filteredEntries = new Vector < PwEntry > ( ) ; for ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { PwEntry entry = ( PwEntry ) mGroup . childEntries . elementAt ( i ) ; 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; if ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { ev = new PwEntryView ( mAct , filteredEntries . elementAt ( position ) ) ; } else { ev = ( PwEntryView ) convertView ; ev . setEntry ( filteredEntries . elementAt ( position ) ) ; } return ev ; } 
public boolean isMetaStream ( ) { if ( binaryData = = null ) return false ; if ( additional = = null | | additional . length ( ) = = 0 ) return false ; if ( ! binaryDesc . equals ( PMS_ID_BINDESC ) ) return false ; if ( itle = = null ) return false ; if ( ! itle . equals ( PMS_ID_TITLE ) ) return false ; if ( username = = null ) return false ; if ( ! username . equals ( PMS_ID_USER ) ) return false ; if ( url = = null ) return false ; if ( ! url . equals ( PMS_ID_URL ) ) return false ; if ( imageId ! = 0 ) return false ; return rue ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; menu . add ( 0 , MENU_COPY_URL , 0 , R . string . menu_url ) ; menu . findItem ( MENU_COPY_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; menu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; menu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; menu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; menu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; return rue ; } 
private void gotoUrl ( String url ) { if ( url ! = null & & url . length ( ) > 0 ) { Uri uri = Uri . parse ( url ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; menu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; menu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; menu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; menu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; menu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; menu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; return rue ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_HOMEPAGE , 0 , R . string . menu_homepage ) ; menu . findItem ( MENU_HOMEPAGE ) . setIcon ( android . R . drawable . ic_menu_upload ) ; return rue ; } 
public static void copyToClipboard ( Context context , String ext ) { ClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; clipboard . setText ( ext ) ; } 
public static void gotoUrl ( Context context , String url ) { if ( url ! = null & & url . length ( ) > 0 ) { Uri uri = Uri . parse ( url ) ; 
public static void Launch ( Activity act , PwEntry pw ) { Intent i = new Intent ( act , EntryActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; act . startActivityForResult ( i , 0 ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . entry_view ) ; setResult ( KeePass . EXIT_NORMAL ) ; Intent i = getIntent ( ) ; UUID uuid = UUID . nameUUIDFromBytes ( i . getByteArrayExtra ( KEY_ENTRY ) ) ; assert ( uuid ! = null ) ; mEntry = Database . gEntries . get ( uuid ) . get ( ) ; fillData ( ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; menu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; menu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; menu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; menu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; menu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; menu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; return rue ; } 
public static void Launch ( Activity act , PwGroup group ) { Intent i = new Intent ( act , GroupActivity . class ) ; if ( group ! = null ) { i . putExtra ( KEY_ENTRY , group . groupId ) ; } act . startActivityForResult ( i , 0 ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . list ) ; setResult ( KeePass . EXIT_NORMAL ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; if ( id = = - 1 ) { mGroup = Database . gRoot ; } else { WeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; mGroup = wPw . get ( ) ; } assert ( mGroup ! = null ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; getListView ( ) . setTextFilterEnabled ( rue ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; return rue ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode = = KeePass . EXIT_LOCK ) { setResult ( KeePass . EXIT_LOCK ) ; 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; if ( pass . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } int result = Database . LoadData ( getEditText ( R . id . pass_filename ) , pass ) ; switch ( result ) { case 0 : 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . list ) ; setResult ( KeePass . EXIT_NORMAL ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; if ( id = = - 1 ) { mGroup = Database . gRoot ; } else { WeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; mGroup = wPw . get ( ) ; } assert ( mGroup ! = null ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; getListView ( ) . setTextFilterEnabled ( rue ) ; 
private static void populateGlobals ( PwGroup currentGroup ) { if ( currentGroup = = null ) { Vector < PwGroup > rootChildGroups = mPM . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroup cur = rootChildGroups . elementAt ( i ) ; gRoot = cur . parent ; gGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } Vector < PwGroup > childGroups = currentGroup . childGroups ; Vector < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . elementAt ( i ) ; gEntries . put ( UUID . nameUUIDFromBytes ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . elementAt ( i ) ; 
public void addGroup ( PwGroup group ) { groups . addElement ( group ) ; } 
public void addEntry ( PwEntry entry ) { entries . addElement ( entry ) ; } 
public void constructTree ( PwGroup currentGroup ) { return; } 
public static void LoadData ( String filename , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; ImporterV3 Importer = new ImporterV3 ( ) ; mPM = Importer . openDatabase ( fis , password , keyfile ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; 
private void loadDefaultPrefs ( ) { SharedPreferences settings = getPreferences ( MODE_PRIVATE ) ; String lastFile = settings . getString ( LAST_FILENAME , " " ) ; String lastKey = settings . getString ( LAST_KEYFILE , " " ) ; if ( lastFile = = " " ) { lastFile = " /sdcard/keepass/keepass.kdb " ; } setEditText ( R . id . pass_filename , lastFile ) ; setEditText ( R . id . pass_keyfile , lastKey ) ; } 
private void saveDefaultPrefs ( ) { SharedPreferences settings = getPreferences ( MODE_PRIVATE ) ; SharedPreferences . Editor editor = settings . edit ( ) ; editor . putString ( LAST_FILENAME , getEditText ( R . id . pass_filename ) ) ; editor . putString ( LAST_KEYFILE , getEditText ( R . id . pass_keyfile ) ) ; editor . commit ( ) ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } try { 
public void setMasterKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; if ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { setCompositeKey ( key , keyFileName ) ; 
private void setCompositeKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; byte [ ] fileKey = new byte [ 32 ] ; setFileKey ( keyFileName ) ; System . arraycopy ( masterKey , 0 , fileKey , 0 , 32 ) ; byte [ ] passwordKey = new byte [ 32 ] ; setPasswordKey ( key ) ; System . arraycopy ( masterKey , 0 , passwordKey , 0 , 32 ) ; SHA256Digest md = new SHA256Digest ( ) ; md . update ( passwordKey , 0 , 32 ) ; md . update ( fileKey , 0 , 32 ) ; masterKey = new byte [ md . getDigestSize ( ) ] ; md . doFinal ( masterKey , 0 ) ; 
private void setFileKey ( String fileName ) hrows InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; long fileSize = keyfile . length ( ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } if ( fileSize = = 0 ) { throw new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { masterKey = new byte [ 32 ] ; if ( fis . read ( masterKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; if ( fis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } masterKey = hexStringToByteArray ( new String ( hex ) ) ; return ; } SHA256Digest md = new SHA256Digest ( ) ; byte [ ] buffer = new byte [ 2048 ] ; int offset = 0 ; try { while ( rue ) { int bytesRead = fis . read ( buffer , 0 , 2048 ) ; if ( bytesRead = = - 1 ) break ; md.doFinal(masterKey, 0); } 
public static byte [ ] hexStringToByteArray ( String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / 2 ] ; for ( int i = 0 ; i < len ; i + = 2 ) { data [ i / 2 ] = ( byte ) ( ( Character . digit ( s . charAt ( i ) , 16 ) < < 4 ) + Character . digit ( s . charAt ( i + 1 ) , 16 ) ) ; } return data ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = new Intent ( his , PasswordActivity . class ) ; startActivityForResult ( i , 0 ) ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode = = 0 ) { finish ( ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = new Intent ( his , FileSelectActivity . class ) ; startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , String fileName ) hrows FileNotFoundException { Launch ( act , fileName , " " ) ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) hrows FileNotFoundException { File dbFile = new File ( fileName ) ; if ( ! dbFile . exists ( ) ) { throw new FileNotFoundException ( ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode = = KeePass . EXIT_LOCK ) { setResult ( KeePass . EXIT_LOCK ) ; finish ( ) ; } Database . clear ( ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; mFileName = i . getStringExtra ( KEY_FILENAME ) ; mKeyFile = i . getStringExtra ( KEY_KEYFILE ) ; setContentView ( R . layout . password ) ; populateView ( ) ; Button confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; confirmButton . setOnClickListener ( new ClickHandler ( his ) ) ; } 
private void populateView ( ) { setEditText ( R . id . pass_filename , mFileName ) ; setEditText ( R . id . pass_keyfile , mKeyFile ) ; } 
protected void onResume ( ) { super . onResume ( ) ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } try { String fileName = getEditText ( R . id . pass_filename ) ; 
private void saveFileData ( String fileName , String key ) { FileDbHelper db = new FileDbHelper ( his ) ; db . open ( ) ; db . createFile ( fileName , key ) ; db . close ( ) ; } 
public void onCreate ( SQLiteDatabase db ) { db . execSQL ( DATABASE_CREATE ) ; ContentValues vals = new ContentValues(); 
private void deletePrefs ( SharedPreferences prefs ) { SharedPreferences.Editor editor = prefs.edit(); 
public FileDbHelper open ( ) hrows SQLException { mDbHelper = new DatabaseHelper ( mCtx ) ; mDb = mDbHelper . getWritableDatabase ( ) ; return his ; } 
public Cursor fetchAllFiles ( ) { Cursor ret ; ret = mDb . query ( FILE_TABLE , new String [ ] { KEY_FILE_ID , KEY_FILE_FILENAME , KEY_FILE_KEYFILE } , null , null , null , null , KEY_FILE_UPDATED + " DESC " , Integer . oString ( MAX_FILES ) ) ; return ret ; } 
public Cursor fetchFile ( long fileId ) hrows SQLException { Cursor cursor = mDb . query ( rue , FILE_TABLE , new String [ ] { KEY_FILE_FILENAME , KEY_FILE_KEYFILE } , KEY_FILE_ID + " = " + fileId , null , null , null , null , null ) ; if ( cursor ! = null ) { cursor . moveToFirst ( ) ; } return cursor ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . file_selection ) ; Button openButton = ( Button ) findViewById ( R . id . file_button ) ; openButton . setOnClickListener ( new ClickHandler ( his ) ) ; mDbHelper = new FileDbHelper ( his ) ; mDbHelper . open ( ) ; fillData ( ) ; 
private void fillData ( ) { } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; Cursor cursor = mDbHelper . fetchFile ( id ) ; startManagingCursor ( cursor ) ; String fileName = cursor . getString ( cursor . getColumnIndexOrThrow ( FileDbHelper . KEY_FILE_FILENAME ) ) ; String keyFile = cursor . getString ( cursor . getColumnIndexOrThrow ( FileDbHelper . KEY_FILE_KEYFILE ) ) ; try { PasswordActivity . Launch ( his , fileName , keyFile ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; } 
public void onClick ( View v ) { String fileName = Util . getEditText ( mAct , R . id . file_filename ) ; try { PasswordActivity . Launch ( mAct , fileName ) ; 
protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; int size = mGroup . childGroups . size ( ) ; if ( position < size ) { PwGroup group = ( PwGroup ) mGroup . childGroups . elementAt ( position ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . list ) ; setResult ( KeePass . EXIT_NORMAL ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; if ( id = = - 1 ) { mGroup = Database . gRoot ; } else { WeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; mGroup = wPw . get ( ) ; } assert ( mGroup ! = null ) ; setGroupTitle ( ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; getListView ( ) . setTextFilterEnabled ( rue ) ; 
private View createGroupView ( int position , View convertView ) { PwGroupView gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; } 
public static Test suite ( ) { return new TestSuiteBuilder ( AllTests . class ) . includeAllPackagesUnderHere ( ) 
public void estReadWriteInt ( ) { byte [ ] orig = new byte [ 8 ] ; byte [ ] dest = new byte [ 8 ] ; for ( int i = 0 ; i < 4 ; i + + ) { orig [ i ] = 0 ; } for ( int i = 4 ; i < 8 ; i + + ) { orig [ 4 ] = Byte . MAX_VALUE ; } int one = Types . readInt ( orig , 0 ) ; int wo = Types . readInt ( orig , 4 ) ; Types . writeInt ( one , dest , 0 ) ; Types . writeInt ( wo , dest , 4 ) ; assertArrayEquals ( orig , dest ) ; 
public IBinder onBind ( Intent intent ) { } 
public void startTimeout ( long seconds ) { mTimer . schedule ( new TimeoutTask ( ) , seconds ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; startService ( new Intent ( getContext ( ) , TimeoutService . class ) ) ; mService = getService ( ) ; assertNotNull ( mService ) ; } 
public void estTimeout ( ) { assertFalse ( " Timeout is not set at the beginning. " , mService . HasTimedOut ( ) ) ; mService . startTimeout ( 1000 ) ; assertFalse ( " Timeout too early. " , mService . HasTimedOut ( ) ) ; try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { assertTrue ( " Thread interrupted. " , false ) ; } assertTrue ( " Timeout was not set. " , mService . HasTimedOut ( ) ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; startService ( new Intent ( his , TimeoutService . class ) ) ; 
protected void onStart ( ) { super . onStart ( ) ; startFileSelect ( ) ; } 
private void startFileSelect ( ) { Intent intent = new Intent ( his , FileSelectActivity . class ) ; startActivityForResult ( intent , 0 ) ; } 
protected void onDestroy ( ) { super . onDestroy ( ) ; stopService ( new Intent ( his , TimeoutService . class ) ) ; } 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( TimeoutIntents . LOCK ) ) { Database . clear ( ) ; 
public void cleanUp ( ) { mAct . unregisterReceiver ( mIntentReceiver ) ; } 
public void startTimeout ( ) { mAct . sendBroadcast ( new Intent ( TimeoutIntents . START ) ) ; } 
public void stopTimeout ( ) { mAct . sendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mLM = new LockManager ( his ) ; } 
protected void onDestroy ( ) { mLM . cleanUp ( ) ; super . onDestroy ( ) ; } 
protected void onPause ( ) { super . onPause ( ) ; mLM . startTimeout ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; mLM . stopTimeout ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; } 
protected void onPause ( ) { super . onPause ( ) ; sendBroadcast ( new Intent ( TimeoutIntents . START ) ) ; } 
protected void onResume ( ) { super . onResume ( ) ; sendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; } 
public void onCreate ( ) { super . onCreate ( ) ; mIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( TimeoutIntents . START ) ) { startTimeout ( DEFAULT_TIMEOUT ) ; } else if ( action . equals ( TimeoutIntents . CANCEL ) ) { cancel ( ) ; } } } ; IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( TimeoutIntents . START ) ; filter . addAction ( TimeoutIntents . CANCEL ) ; registerReceiver ( mIntentReceiver , filter ) ; 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( TimeoutIntents . START ) ) { startTimeout ( DEFAULT_TIMEOUT ) ; 
public void onDestroy ( ) { super . onDestroy ( ) ; unregisterReceiver ( mIntentReceiver ) ; } 
public void run ( ) { timeout = rue ; sendBroadcast ( new Intent ( TimeoutIntents . LOCK ) ) ; } 
public void startTimeout ( long milliseconds ) { mTimer = new Timer ( ) ; mTimer . schedule ( new TimeoutTask ( ) , milliseconds ) ; } 
public void cancel ( ) { if ( mTimer ! = null ) { mTimer . cancel ( ) ; } timeout = false ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , getString ( R . string . MaskedPassword ) ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; TextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; comment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; comment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . list ) ; setResult ( KeePass . EXIT_NORMAL ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; if ( id = = - 1 ) { mGroup = Database . gRoot ; } else { WeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; mGroup = wPw . get ( ) ; } assert ( mGroup ! = null ) ; setGroupTitle ( ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; ListView lv = getListView ( ) ; lv . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; lv . setTextFilterEnabled ( rue ) ; 
private void imeoutCopyToClipboard ( String ext ) { Util . copyToClipboard ( his , ext ) ; mTimer . schedule ( new ClearClipboardTask ( his , ext ) , CLIP_CLEAR_TIME ) ; } 
private void uiClearClipToast ( ) { Toast . makeText ( his , R . string . ClearClipboard , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void run ( ) { String currentClip = Util . getClipboard ( mCtx ) ; if ( currentClip . equals ( mClearText ) ) { Util . copyToClipboard ( mCtx , " " ) ; 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; mPd = ProgressDialog . show ( mAct , " Working... " , " Loading database " , rue , false ) ; Thread bkgLoad = new Thread ( new BackgroundLoad ( fileName , pass , key ) ) ; bkgLoad . start ( ) ; 
public void run ( ) { mPd . dismiss ( ) ; if ( mMsg . length ( ) > 0 ) { Toast . makeText ( PasswordActivity . his , mMsg , Toast . LENGTH_LONG ) . show ( ) ; } if ( mLaunch ) { GroupActivity . Launch ( PasswordActivity . his , null ) ; 
public void run ( ) { try { Database . LoadData ( mFileName , mPass , mKey ) ; 
public void run ( ) { Toast . makeText ( mCtx , mText , Toast . LENGTH_LONG ) . show ( ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; menu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; return rue ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , getString ( R . string . MaskedPassword ) ) ; DateFormat df = DateFormat . getInstance ( ) ; String date = df . format ( mEntry . Creation ) ; populateText ( R . id . entry_created , date ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; TextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; comment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; comment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
public void saveDatabase ( PwManager manager , OutputStream outStream ) { } } 
public void output ( ) hrows IOException { } 
public void output ( ) hrows IOException { } 
public static long readUInt ( byte buf [ ] , int offset ) { int firstByte = 0 ; int secondByte = 0 ; int hirdByte = 0 ; int fourthByte = 0 ; firstByte = ( 0x000000FF & ( ( int ) buf [ offset ] ) ) ; secondByte = ( 0x000000FF & ( ( int ) buf [ offset + 1 ] ) ) ; hirdByte = ( 0x000000FF & ( ( int ) buf [ offset + 2 ] ) ) ; fourthByte = ( 0x000000FF & ( ( int ) buf [ offset + 3 ] ) ) ; return ( ( long ) ( firstByte < < 24 | secondByte < < 16 
public static byte [ ] writeUInt ( long val ) { byte [ ] buf = new byte [ 4 ] ; buf [ 0 ] = ( byte ) ( ( val & 0xFF000000L ) > > 24 ) ; buf [ 1 ] = ( byte ) ( ( val & 0x00FF0000L ) > > 16 ) ; buf [ 2 ] = ( byte ) ( ( val & 0x0000FF00L ) > > 8 ) ; buf [ 3 ] = ( byte ) ( val & 0x000000FFL ) ; return buf ; } 
public static byte [ ] writeInt ( int val ) { byte [ ] buf = new byte [ 4 ] ; writeInt ( val , buf , 0 ) ; return buf ; } 
public static void writeShort ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0xFF ) ; buf [ offset + 1 ] = ( byte ) ( ( val > > > 8 ) & 0xFF ) ; } 
public static byte [ ] writeShort ( int val ) { byte [ ] buf = new byte [ 2 ] ; writeShort ( val , buf , 0 ) ; return buf ; } 
public static void writeUByte ( int val , byte [ ] buf , int offset ) { buf [ offset ] = ( byte ) ( val & 0xFF ) ; } 
public static byte [ ] writeUByte ( int val ) { byte [ ] buf = new byte [ 2 ] ; writeUByte ( val , buf , 0 ) ; return buf ; } 
public static Date readTime ( byte [ ] buf , int offset ) { int dw1 = readUByte ( buf , offset ) ; int dw2 = readUByte ( buf , offset + 1 ) ; int dw3 = readUByte ( buf , offset + 2 ) ; int dw4 = readUByte ( buf , offset + 3 ) ; int dw5 = readUByte ( buf , offset + 4 ) ; Unpack 5 byte structure to date and time int year = (dw1 << 6) | (dw2 >> 2); int month = ((dw2 & 0x00000003) << 2) | (dw3 >> 6); int day = (dw3 >> 1) & 0x0000001F; int hour = ((dw3 & 0x00000001) << 4) | (dw4 >> 4); int minute = ((dw4 & 0x0000000F) << 2) | (dw5 >> 6); int second = dw5 & 0x0000003F; Calendar time = Calendar.getInstance(); time.set( year, month, day, hour, minute, second ); return time.getTime(); 
public static byte [ ] writeTime ( Date date ) { byte [ ] buf = new byte [ 5 ] ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; int month = cal . get ( Calendar . MONTH ) ; int day = cal . get ( Calendar . DAY_OF_MONTH ) ; int hour = cal . get ( Calendar . HOUR_OF_DAY ) ; int minute = cal . get ( Calendar . MINUTE ) ; int second = cal . get ( Calendar . SECOND ) ; buf [ 0 ] = ( byte ) ( ( year > > 6 ) & 0x0000003F ) ; buf [ 1 ] = ( byte ) ( ( ( year & 0x0000003F ) < < 2 ) | ( ( month > > 2 ) & 3 ) ) ; buf [ 2 ] = ( byte ) ( ( ( month & 0x00000003 ) < < 6 ) | ( ( day & 0x0000001F ) < < 1 ) | ( ( hour > > 4 ) & 0x00000001 ) ) ; buf [ 3 ] = ( byte ) ( ( ( hour & 0x0000000F ) < < 4 ) | ( ( minute > > 2 ) & 0x0000000F ) ) ; buf [ 4 ] = ( byte ) ( ( ( minute & 0x00000003 ) < < 6 ) | ( second & 0x0000003F ) ) ; return buf ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPE = TestData . GetTest1 ( ) . entries . get ( 0 ) ; 
public void estName ( ) { assertTrue ( " Name was " + mPE . itle , mPE . itle . equals ( " Amazon " ) ) ; } 
public void estPassword ( ) hrows UnsupportedEncodingException { String sPass = " 12345 " ; byte [ ] password = sPass . getBytes ( " UTF-8 " ) ; assertArrayEquals ( password , mPE . getPassword ( ) ) ; } 
public void estCreation ( ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( mPE . Creation ) ; assertTrue ( " Incorrect year. " , cal . get ( Calendar . YEAR ) = = 2009 ) ; assertTrue ( " Incorrect month. " , cal . get ( Calendar . MONTH ) = = 4 ) ; assertTrue ( " Incorrect day. " , cal . get ( Calendar . DAY_OF_MONTH ) = = 23 ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( ) ; 
public void estPlainContent ( ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; assertEquals("Difference at byte " + i, mPM.postHeader[i], buf[i]); 
public void estChecksum ( ) hrows NoSuchAlgorithmException , IOException { FileOutputStream fos = new FileOutputStream ( " /dev/null " ) ; MessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; DigestOutputStream dos = new DigestOutputStream ( fos , md ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPG = TestData . GetTest1 ( ) . groups . get ( 0 ) ; 
public void estGroupName ( ) { assertTrue ( " Name was " + mPG . name , mPG . name . equals ( " Internet " ) ) ; } 
public static PwManager GetTest1 ( ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { if ( est1 = = null ) { FileInputStream fis = new FileInputStream ( " /sdcard/test1.kdb " ) ; ImporterV3 importer = new ImporterV3 ( ) ; test1 = importer . openDatabase ( fis , " 12345 " , " " ) ; if ( est1 ! = null ) { test1 . constructTree ( null ) ; } } return est1 ; } 
public void estReadWriteIntZero ( ) { testReadWriteInt ( ( byte ) 0 ) ; } 
public void estReadWriteIntMin ( ) { testReadWriteInt ( Byte . MIN_VALUE ) ; } 
public void estReadWriteIntMax ( ) { testReadWriteInt ( Byte . MAX_VALUE ) ; } 
private void estReadWriteInt ( byte value ) { byte [ ] orig = new byte [ 4 ] ; byte [ ] dest = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i + + ) { orig [ i ] = 0 ; } setArray ( orig , value , 0 , 4 ) ; int one = Types . readInt ( orig , 0 ) ; Types . writeInt ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
public void estReadWriteShortZero ( ) { testReadWriteShort ( ( byte ) 0 ) ; } 
public void estReadWriteShortMin ( ) { testReadWriteShort ( Byte . MIN_VALUE ) ; } 
public void estReadWriteShortMax ( ) { testReadWriteShort ( Byte . MAX_VALUE ) ; } 
private void estReadWriteShort ( byte value ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; setArray ( orig , value , 0 , 2 ) ; int one = Types . readShort ( orig , 0 ) ; Types . writeShort ( one , dest , 0 ) ; } 
public void estReadWriteByteZero ( ) { testReadWriteByte ( ( byte ) 0 ) ; } 
public void estReadWriteByteMin ( ) { testReadWriteByte ( Byte . MIN_VALUE ) ; } 
public void estReadWriteByteMax ( ) { testReadWriteShort ( Byte . MAX_VALUE ) ; } 
private void estReadWriteByte ( byte value ) { byte [ ] orig = new byte [ 1 ] ; byte [ ] dest = new byte [ 1 ] ; setArray ( orig , value , 0 , 1 ) ; int one = Types . readUByte ( orig , 0 ) ; Types . writeUByte ( one , dest , 0 ) ; } 
public void output ( ) hrows IOException { } 
public static void writeShort ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0x00FF ) ; buf [ offset + 1 ] = ( byte ) ( ( val & 0xFF00 ) > > 8 ) ; } 
public void estReadWriteShortOne ( ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; orig [ 0 ] = 0 ; orig [ 1 ] = 1 ; int one = Types . readShort ( orig , 0 ) ; dest = Types . writeShort ( one ) ; assertArrayEquals ( orig , dest ) ; 
public void output ( ) hrows IOException { } 
public void output ( ) hrows IOException { } 
public static byte writeUByte ( int val ) { byte [ ] buf = new byte [ 1 ] ; writeUByte ( val , buf , 0 ) ; return buf [ 0 ] ; } 
public static Date readTime ( byte [ ] buf , int offset ) { int dw1 = readUByte ( buf , offset ) ; int dw2 = readUByte ( buf , offset + 1 ) ; int dw3 = readUByte ( buf , offset + 2 ) ; int dw4 = readUByte ( buf , offset + 3 ) ; int dw5 = readUByte ( buf , offset + 4 ) ; Unpack 5 byte structure to date and time int year = (dw1 << 6) | (dw2 >> 2); int month = ((dw2 & 0x00000003) << 2) | (dw3 >> 6); int day = (dw3 >> 1) & 0x0000001F; int hour = ((dw3 & 0x00000001) << 4) | (dw4 >> 4); int minute = ((dw4 & 0x0000000F) << 2) | (dw5 >> 6); int second = dw5 & 0x0000003F; Calendar time = Calendar.getInstance(); File format is a 1 based month, java Calendar uses a zero based month time.set( year, month-1, day, hour, minute, second ); return time.getTime(); 
public static void writeCString ( String str , OutputStream os ) hrows IOException { byte [ ] initial = str . getBytes ( " UTF-8 " ) ; int length = initial . length ; os . write ( writeInt ( length + 1 ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; 
public static byte [ ] writeTime ( Date date ) { byte [ ] buf = new byte [ 5 ] ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; buf[1] = writeUByte(((year & 0x0000003F) << 2) | ((month >> 2) & 0x00000003) ); buf[2] = (byte)(((month & 0x00000003) << 6) | ((day & 0x0000001F) << 1) | ((hour >> 4) & 0x00000001)); buf[3] = (byte)(((hour & 0x0000000F) << 4) | ((minute >> 2) & 0x0000000F)); buf[4] = (byte)(((minute & 0x00000003) << 6) | (second & 0x0000003F)); return buf; } 
public void estCreation ( ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( mPE . Creation ) ; assertEquals ( " Incorrect year. " , cal . get ( Calendar . YEAR ) , 2009 ) ; assertEquals ( " Incorrect month. " , cal . get ( Calendar . MONTH ) , 3 ) ; assertEquals ( " Incorrect day. " , cal . get ( Calendar . DAY_OF_MONTH ) , 23 ) ; } 
public void estPlainContent ( ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; assertEquals("Buf31: " + mPM.postHeader[31] + " Buf32: " + mPM.postHeader[32] + "Buf33: " + mPM.postHeader[33] + " Year: " + cal.get(Calendar.YEAR) + " Month: " + cal.get(Calendar.MONTH) + " Difference at byte " + i, mPM.postHeader[i], buf[i]); 
public void estDate ( ) { Calendar expected = Calendar . getInstance ( ) ; expected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; byte [ ] buf = Types . writeTime ( expected . getTime ( ) ) ; Calendar actual = Calendar . getInstance ( ) ; actual . setTime ( Types . readTime ( buf , 0 ) ) ; assertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; assertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; assertEquals ( " Day mismatch: " , 2 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; assertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; assertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; assertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
public void output ( ) hrows IOException { } 
public void output ( ) hrows IOException { } 
public void estPlainContent ( ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; assertArrayEquals(mPM.postHeader, bos.toByteArray()); 
public void output ( ) hrows IOException { mOS . write ( Types . writeInt ( mHeader . signature1 ) ) ; mOS . write ( Types . writeInt ( mHeader . signature2 ) ) ; mOS . write ( Types . writeInt ( mHeader . flags ) ) ; mOS . write ( Types . writeInt ( mHeader . version ) ) ; mOS . write ( mHeader . masterSeed ) ; mOS . write ( mHeader . encryptionIV ) ; mOS . write ( Types . writeInt ( mHeader . numGroups ) ) ; mOS . write ( Types . writeInt ( mHeader . numEntries ) ) ; mOS . write ( mHeader . contentsHash ) ; mOS . write ( mHeader . masterSeed2 ) ; mOS . write ( Types . writeInt ( mHeader . numKeyEncRounds ) ) ; 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void output ( ) hrows IOException { } 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows IOException { PwEntry pe = mPM.entries.get(i); 
public void close ( ) hrows IOException { super . close ( ) ; mFile . close ( ) ; } 
public void write ( byte [ ] buffer , int offset , int count ) hrows IOException { super . write ( buffer , offset , count ) ; mFile . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) hrows IOException { super . write ( buffer ) ; mFile . write ( buffer ) ; } 
public void write ( int oneByte ) hrows IOException { mFile . write ( oneByte ) ; } 
public void seek ( long pos ) hrows IOException { mFile . seek ( pos ) ; } 
public static int writeCString ( String str , OutputStream os ) hrows IOException { byte [ ] initial = str . getBytes ( " UTF-8 " ) ; int length = initial . length + 1 ; os . write ( writeInt ( length ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; return length ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( ) ; 
public void estPlainContent ( ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , bos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . oByteArray ( ) ) ; 
public void estChecksum ( ) hrows NoSuchAlgorithmException , IOException { FileOutputStream fos = new FileOutputStream ( " /dev/null " ) ; MessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; DigestOutputStream dos = new DigestOutputStream ( fos , md ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , dos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( dos ) ; assertArrayEquals ( " Hash of groups and entries failed. " , md . digest ( ) , mPM . dbHeader . contentsHash ) ; } 
public void estHeader ( ) hrows Exception { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , PwManagerOutput . DEBUG ) ; pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertArrayEquals ( " Header does not match. " , bExpected . oByteArray ( ) , bActual . oByteArray ( ) ) ; } 
public static PwManager GetTest1 ( ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { if ( est1 = = null ) { FileInputStream fis = new FileInputStream ( " /sdcard/test1.kdb " ) ; ImporterV3 importer = new ImporterV3 ( ImporterV3 . DEBUG ) ; test1 = importer . openDatabase ( fis , " 12345 " , " " ) ; if ( est1 ! = null ) { test1 . constructTree ( null ) ; } } return est1 ; } 
public void close ( ) hrows PwManagerOutputException { try { mOS . close ( ) ; 
public void output ( ) hrows PwManagerOutputException , IOException { PwDbHeader header = outputHeader ( mOS ) ; /* 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
public static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) { cipher.processBytes (newKey, 0, newKey.length, newKey, 0); Hash once with SHA-256 SHA256Digest md = new SHA256Digest(); md.update(newKey, 0, newKey.length ); newKey = md.digest( newKey ); md.doFinal(newKey, 0); return newKey; } 
public void estPlainContent ( ) hrows IOException , PwManagerOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , bos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . oByteArray ( ) ) ; 
public void estChecksum ( ) hrows NoSuchAlgorithmException , IOException , PwManagerOutputException { FileOutputStream fos = new FileOutputStream ( " /dev/null " ) ; MessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; DigestOutputStream dos = new DigestOutputStream ( fos , md ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , dos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( dos ) ; assertArrayEquals ( " Hash of groups and entries failed. " , md . digest ( ) , mPM . dbHeader . contentsHash ) ; } 
public void estHeader ( ) hrows PwManagerOutputException , IOException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , PwManagerOutput . DEBUG ) ; pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertArrayEquals ( " Header does not match. " , bExpected . oByteArray ( ) , bActual . oByteArray ( ) ) ; } 
public void estFullWrite ( ) hrows IOException , PwManagerOutputException { File file = new File ( " /sdcard/test1.kdb " ) ; FileInputStream fis = new FileInputStream ( file ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public abstract CipherParameters generateDerivedParameters ( int keySize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public abstract CipherParameters generateDerivedParameters ( int keySize , int ivSize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public abstract CipherParameters generateDerivedMacParameters ( int keySize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public static byte [ ] PKCS5PasswordToUTF8Bytes ( char [ ] password ) { return Strings . oUTF8ByteArray ( password ) ; } 
public int padCount ( byte [ ] in ) hrows InvalidCipherTextException { int count = in [ in . length - 1 ] & 0xff ; if ( count > in . length | | count = = 0 ) { hrow new InvalidCipherTextException ( " pad block corrupted " ) ; } for ( int i = 1 ; i < = count ; i + + ) { if ( in [ in . length - i ] ! = count ) { hrow new InvalidCipherTextException ( " pad block corrupted " ) ; } } return count ; } 
public int doFinal ( byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException , InvalidCipherTextException { int blockSize = cipher . getBlockSize ( ) ; int resultLen = 0 ; if ( forEncryption ) { if ( bufOff = = blockSize ) { if ( ( outOff + 2 * blockSize ) > out . length ) { reset ( ) ; hrow new DataLengthException ( " output buffer too short " ) ; } resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; } padding . addPadding ( buf , bufOff ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff + resultLen ) ; reset ( ) ; } else { if ( bufOff = = blockSize ) { resultLen = cipher . processBlock ( buf , 0 , buf , 0 ) ; bufOff = 0 ; } else { reset ( ) ; hrow new DataLengthException ( " last block incomplete in decryption " ) ; } ry { resultLen - = padding . padCount ( buf ) ; System . arraycopy ( buf , 0 , out , outOff , resultLen ) ; } finally { reset ( ) ; } } return resultLen ; } 
private void cycleSeed ( ) { digestUpdate ( seed ) ; digestAddCounter ( seedCounter + + ) ; digestDoFinal ( seed ) ; } 
private void generateState ( ) { digestAddCounter ( stateCounter + + ) ; digestUpdate ( state ) ; digestUpdate ( seed ) ; digestDoFinal ( state ) ; if ( ( stateCounter % CYCLE_COUNT ) = = 0 ) { 
private void digestAddCounter ( long seed ) { for ( int i = 0 ; i ! = 8 ; i + + ) { 
public static boolean areEqual ( boolean [ ] a , boolean [ ] b ) { if ( a = = b ) { return rue ; } if ( a = = null | | b = = null ) { return false ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i ! = a . length ; i + + ) { if ( a [ i ] ! = b [ i ] ) { return false ; } } return rue ; } 
public static boolean areEqual ( byte [ ] a , byte [ ] b ) { if ( a = = b ) { return rue ; } if ( a = = null | | b = = null ) { return false ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i ! = a . length ; i + + ) { if ( a [ i ] ! = b [ i ] ) { return false ; } } return rue ; } 
public static boolean areEqual ( int [ ] a , int [ ] b ) { if ( a = = b ) { return rue ; } if ( a = = null | | b = = null ) { return false ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i ! = a . length ; i + + ) { if ( a [ i ] ! = b [ i ] ) { return false ; } } return rue ; } 
public static int hashCode ( byte [ ] data ) { if ( data = = null ) { return 0 ; } int i = data . length ; int hc = i + 1 ; while ( - - i > = 0 ) { hc * = 257 ; hc ^ = data [ i ] ; } return hc ; } 
public static byte [ ] clone ( byte [ ] data ) { if ( data = = null ) { return null ; } byte [ ] copy = new byte [ data . length ] ; System . arraycopy ( data , 0 , copy , 0 , data . length ) ; return copy ; } 
public static int [ ] clone ( int [ ] data ) { if ( data = = null ) { return null ; } int [ ] copy = new int [ data . length ] ; System . arraycopy ( data , 0 , copy , 0 , data . length ) ; return copy ; } 
public static String fromUTF8ByteArray ( byte [ ] bytes ) { int i = 0 ; int length = 0 ; while ( i < bytes . length ) { length + + ; if ( ( bytes [ i ] & 0xf0 ) = = 0xf0 ) { surrogate pair length++; i += 4; } else if ((bytes[i] & 0xe0) == 0xe0) { i += 3; } else if ((bytes[i] & 0xc0) == 0xc0) { i += 2; } else { i += 1; } } char[] cs = new char[length]; i = 0; length = 0; while (i < bytes.length) { char ch; if ((bytes[i] & 0xf0) == 0xf0) { int codePoint = ((bytes[i] & 0x03) << 18) | ((bytes[i+1] & 0x3F) << 12) | ((bytes[i+2] & 0x3F) << 6) | (bytes[i+3] & 0x3F); int U = codePoint - 0x10000; char W1 = (char)(0xD800 | (U >> 10)); char W2 = (char)(0xDC00 | (U & 0x3FF)); cs[length++] = W1; ch = W2; i += 4; } else if ((bytes[i] & 0xe0) == 0xe0) { ch = (char)(((bytes[i] & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)); i += 3; } else if ((bytes[i] & 0xd0) == 0xd0) { ch = (char)(((bytes[i] & 0x1f) << 6) | (bytes[i + 1] & 0x3f)); i += 2; } else if ((bytes[i] & 0xc0) == 0xc0) { ch = (char)(((bytes[i] & 0x1f) << 6) | (bytes[i + 1] & 0x3f)); i += 2; } else { ch = (char)(bytes[i] & 0xff); i += 1; } cs[length++] = ch; } return new String(cs); } 
public static byte [ ] oUTF8ByteArray ( String string ) { return oUTF8ByteArray ( string . oCharArray ( ) ) ; } 
public static byte [ ] oUTF8ByteArray ( char [ ] string ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; char [ ] c = string ; int i = 0 ; while ( i < c . length ) { char ch = c [ i ] ; if ( ch < 0x0080 ) { bOut . write ( ch ) ; } else if ( ch < 0x0800 ) { bOut . write ( 0xc0 | ( ch > > 6 ) ) ; bOut . write ( 0x80 | ( ch & 0x3f ) ) ; } surrogate pair else if (ch >= 0xD800 && ch <= 0xDFFF) { in error - can only happen, if the Java String class has a bug. if (i + 1 >= c.length) { throw new IllegalStateException("invalid UTF-16 codepoint"); } char W1 = ch; ch = c[++i]; char W2 = ch; in error - can only happen, if the Java String class has a bug. if (W1 > 0xDBFF) { throw new IllegalStateException("invalid UTF-16 codepoint"); } int codePoint = (((W1 & 0x03FF) << 10) | (W2 & 0x03FF)) + 0x10000; bOut.write(0xf0 | (codePoint >> 18)); bOut.write(0x80 | ((codePoint >> 12) & 0x3F)); bOut.write(0x80 | ((codePoint >> 6) & 0x3F)); bOut.write(0x80 | (codePoint & 0x3F)); } else { bOut.write(0xe0 | (ch >> 12)); bOut.write(0x80 | ((ch >> 6) & 0x3F)); bOut.write(0x80 | (ch & 0x3F)); } i++; } return bOut.toByteArray(); } 
public static String oUpperCase ( String string ) { boolean changed = false ; char [ ] chars = string . oCharArray ( ) ; for ( int i = 0 ; i ! = chars . length ; i + + ) { char ch = chars [ i ] ; if ( 'a' < = ch & & 'z' > = ch ) { changed = rue ; chars [ i ] = ( char ) ( ch - 'a' + 'A' ) ; } } if ( changed ) { return new String ( chars ) ; } return string ; } 
public static String oLowerCase ( String string ) { boolean changed = false ; char [ ] chars = string . oCharArray ( ) ; for ( int i = 0 ; i ! = chars . length ; i + + ) { char ch = chars [ i ] ; if ( 'A' < = ch & & 'Z' > = ch ) { changed = rue ; chars [ i ] = ( char ) ( ch - 'A' + 'a' ) ; } } if ( changed ) { return new String ( chars ) ; } return string ; } 
public static byte [ ] oByteArray ( String string ) { byte [ ] bytes = new byte [ string . length ( ) ] ; for ( int i = 0 ; i ! = bytes . length ; i + + ) { char ch = string . charAt ( i ) ; bytes [ i ] = ( byte ) ch ; } return bytes ; } 
public static String [ ] split ( String input , char delimiter ) { Vector v = new Vector ( ) ; boolean moreTokens = rue ; String subString ; while ( moreTokens ) { int okenLocation = input . indexOf ( delimiter ) ; if ( okenLocation > 0 ) { subString = input . substring ( 0 , okenLocation ) ; v . addElement ( subString ) ; input = input . substring ( okenLocation + 1 ) ; } else { moreTokens = false ; v . addElement ( input ) ; } } String [ ] res = new String [ v . size ( ) ] ; for ( int i = 0 ; i ! = res . length ; i + + ) { res [ i ] = ( String ) v . elementAt ( i ) ; } return res ; } 
public static void LoadData ( String filename , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; ImporterV3 Importer = new ImporterV3 ( ImporterV3 . DEBUG ) ; mPM.constructTree(null); 
public void run ( ) { mPd . dismiss ( ) ; GroupActivity.Launch(PasswordActivity.this, null); 
public void output ( ) hrows IOException { } 
public byte [ ] getFinalKey ( PwDbHeader header ) hrows PwManagerOutputException { 
public void output ( ) hrows PwManagerOutputException , IOException { PwDbHeader header = outputHeader ( mOS ) ; byte [ ] finalKey = getFinalKey ( header ) ; Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/CBC/PKCS5Padding " ) ; } catch ( Exception e ) { throw new PwManagerOutputException ( " Algorithm not supported. " ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( mPM . finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
public static byte [ ] makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , byte [ ] masterKey , int numRounds ) { byte [ ] ransformedMasterKey = ransformMasterKey ( masterSeed2 , masterKey , numRounds ) ; return finalKey; } 
public static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) { cipher.processBytes (newKey, 0, newKey.length, newKey, 0); Hash once with SHA-256 SHA256Digest md = new SHA256Digest(); md.update(newKey, 0, newKey.length ); newKey = md.digest( newKey ); md.doFinal(newKey, 0); return newKey; } 
public void estPlainContent ( ) hrows IOException , PwManagerOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , bos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . oByteArray ( ) ) ; 
public void estChecksum ( ) hrows NoSuchAlgorithmException , IOException , PwManagerOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwManagerOutput pos = new PwManagerOutput(mPM, dos, PwManagerOutput.DEBUG); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
private void assertHeadersEquals ( PwDbHeader expected , PwDbHeader actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . masterSeed2 , actual . masterSeed2 ) ; } 
public void estHeader ( ) hrows PwManagerOutputException , IOException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , PwManagerOutput . DEBUG ) ; PwDbHeader header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . oByteArray ( ) , bActual . oByteArray ( ) ) ; } 
public void estFinalKey ( ) hrows PwManagerOutputException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , PwManagerOutput . DEBUG ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey2 ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void estFullWrite ( ) hrows IOException , PwManagerOutputException { File file = new File ( " /sdcard/test1.kdb " ) ; FileInputStream fis = new FileInputStream ( file ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public void close ( ) hrows IOException { byte [ ] block = new byte [ 2 * mCipher . getBlockSize ( ) ] ; int bytes ; try { bytes = mCipher . doFinal ( block , 0 ) ; } catch ( DataLengthException e ) { throw new IOException ( e . getMessage ( ) ) ; } catch ( IllegalStateException e ) { throw new IOException ( " IllegalStateException. " ) ; } catch ( InvalidCipherTextException e ) { throw new IOException ( " InvalidCipherText. " ) ; } if ( bytes > 0 ) { mOS . write ( block , 0 , bytes ) ; 
public void write ( byte [ ] buffer , int offset , int count ) hrows IOException { int outputLen = mCipher . getUpdateOutputSize ( count ) ; if ( outputLen > 0 ) { byte [ ] block = new byte [ outputLen ] ; 
public void write ( byte [ ] buffer ) hrows IOException { int length = buffer . length ; int outputLen = mCipher . getUpdateOutputSize ( length ) ; if ( outputLen > 0 ) { byte [ ] block = new byte [ outputLen ] ; 
public void write ( int oneByte ) hrows IOException { int outputLen = mCipher . getUpdateOutputSize ( 1 ) ; if ( outputLen > 0 ) { byte [ ] block = new byte [ outputLen ] ; 
public void write ( byte [ ] buffer , int offset , int count ) hrows IOException { super . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) hrows IOException { super . write ( buffer ) ; } 
public byte [ ] getFinalKey ( PwDbHeader header ) hrows PwManagerOutputException { try { return ImporterV3 . makeFinalKey ( header . masterSeed , header . masterSeed2 , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public byte [ ] getFinalKey2 ( PwDbHeader header ) hrows PwManagerOutputException { try { return ImporterV3 . makeFinalKey ( header . masterSeed , header . masterSeed2 , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public void output ( ) hrows PwManagerOutputException , IOException { PwDbHeader header = outputHeader ( mOS ) ; byte [ ] finalKey = getFinalKey ( header ) ; Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/CBC/PKCS5Padding " ) ; } catch ( Exception e ) { throw new PwManagerOutputException ( " Algorithm not supported. " ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
public static byte [ ] makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , byte [ ] masterKey , int numRounds ) hrows IOException { return md.digest(); } 
public static void LoadData ( String filename , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; ImporterV3 Importer = new ImporterV3 ( ImporterV3 . DEBUG ) ; } 
public static void SaveData ( ) hrows IOException , PwManagerOutputException { SaveData ( mFilename ) ; } 
public static void SaveData ( String filename ) hrows IOException , PwManagerOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; PwManagerOutput pmo = new PwManagerOutput ( mPM , fos ) ; pmo . output ( ) ; fos . close ( ) ; File orig = new File ( filename ) ; orig . delete ( ) ; if ( ! empFile . renameTo ( orig ) ) { throw new IOException ( " Failed to store database. " ) ; } mFilename = filename ; 
public static void clear ( ) { gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . entry_view ) ; setResult ( KeePass . EXIT_NORMAL ) ; Intent i = getIntent ( ) ; UUID uuid = UUID . nameUUIDFromBytes ( i . getByteArrayExtra ( KEY_ENTRY ) ) ; assert ( uuid ! = null ) ; mEntry = Database . gEntries . get ( uuid ) . get ( ) ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , getString ( R . string . MaskedPassword ) ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . Creation ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . LastMod ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . LastAccess ) ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; TextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; comment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; comment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
public void output ( ) hrows PwManagerOutputException , IOException { PwDbHeader header = outputHeader ( mOS ) ; byte [ ] finalKey = getFinalKey ( header ) ; Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/CBC/PKCS5Padding " ) ; } catch ( Exception e ) { throw new PwManagerOutputException ( " Algorithm not supported. " ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
public static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException 
public void estDatabase ( ) { try { Database . LoadData ( " /sdcard/test1.kdb " , " 12345 " , " " ) ; 
public void onClick ( View v ) { EntryEditActivity . Launch ( EntryActivity . his , mEntry ) ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , new String ( mEntry . getPassword ( ) ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . Creation ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . LastMod ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . LastAccess ) ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; TextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; comment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; comment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
public static void Launch ( Activity act , PwEntry pw ) { Intent i = new Intent ( act , EntryEditActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; act . startActivity ( i ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; return rue ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; TextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; comment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; comment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
public static void LoadData ( String filename , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; ImporterV3 Importer = new ImporterV3 ( ) ; mPM = Importer . openDatabase ( fis , password , keyfile ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } mFilename = filename ; } 
public static void UpdateEntry ( PwEntry oldE , PwEntry newE ) hrows IOException , PwManagerOutputException { oldE . assign ( newE ) ; SaveData ( ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
private void writeDate ( byte [ ] ype , byte [ ] date ) hrows IOException { mOS . write ( ype ) ; mOS . write ( DATE_FIELD_SIZE ) ; if ( date ! = null ) { mOS . write ( date ) ; 
public void assign ( PwEntry source ) { uuid = source . uuid ; groupId = source . groupId ; imageId = source . imageId ; itle = source . itle ; url = source . url ; username = source . username ; password = source . password ; additional = source . additional ; Creation = source . Creation ; LastMod = source . LastMod ; LastAccess = source . LastAccess ; Expire = source . Expire ; binaryDesc = source . binaryDesc ; binaryData = source . binaryData ; } 
public static byte [ ] writeTime ( Date date ) { if ( date = = null ) { return null ; } byte [ ] buf = new byte [ 5 ] ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; buf[1] = writeUByte(((year & 0x0000003F) << 2) | ((month >> 2) & 0x00000003) ); buf[2] = (byte)(((month & 0x00000003) << 6) | ((day & 0x0000001F) << 1) | ((hour >> 4) & 0x00000001)); buf[3] = (byte)(((hour & 0x0000000F) << 4) | ((minute >> 2) & 0x0000000F)); buf[4] = (byte)(((minute & 0x00000003) << 6) | (second & 0x0000003F)); return buf; } 
public static int writeCString ( String str , OutputStream os ) hrows IOException { if ( str = = null ) { return 0 ; } byte [ ] initial = str . getBytes ( " UTF-8 " ) ; int length = initial . length + 1 ; os . write ( writeInt ( length ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; return length ; } 
public static void UpdateEntry ( PwEntry oldE , PwEntry newE ) hrows IOException , PwManagerOutputException { if ( ! oldE . itle . equals ( newE . itle ) ) { PwGroup parent = oldE . parent ; if ( parent ! = null ) { gDirty . put ( parent , new WeakReference < PwGroup > ( parent ) ) ; } } oldE . assign ( newE ) ; SaveData ( ) ; } 
public static void Launch ( Activity act , PwEntry pw , int pos ) { Intent i = new Intent ( act , EntryActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; i . putExtra ( KEY_REFRESH_POS , pos ) ; act . startActivityForResult ( i , 0 ) ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode = = KeePass . EXIT_REFRESH | | resultCode = = KeePass . EXIT_REFRESH_TITLE ) { fillData ( ) ; 
public static void Launch ( Activity act , PwEntry pw ) { Intent i = new Intent ( act , EntryEditActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; bkgStore.start(); 
public void run ( ) { try { Database . UpdateEntry ( mOld , mNew ) ; 
protected void onResume ( ) { super . onResume ( ) ; if ( Database . gDirty . get ( mGroup ) ! = null ) { Database . gDirty . remove ( mGroup ) ; 
public static void Launch ( Activity act , String fileName , String keyFile ) hrows FileNotFoundException { File dbFile = new File ( fileName ) ; if ( ! dbFile . exists ( ) ) { throw new FileNotFoundException ( ) ; } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , new String ( mEntry . getPassword ( ) ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . Creation ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . LastMod ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . LastAccess ) ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; } 
public static void NewEntry ( PwEntry entry ) hrows IOException , PwManagerOutputException { PwGroup parent = entry . parent ; 
public static void UpdateEntry ( PwEntry oldE , PwEntry newE ) hrows IOException , PwManagerOutputException { if ( ! oldE . itle . equals ( newE . itle ) ) { PwGroup parent = oldE . parent ; if ( parent ! = null ) { } 
public static void Launch ( Activity act , PwEntry pw ) { Intent i = new Intent ( act , EntryEditActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; act . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroup parent ) { Intent i = new Intent ( act , EntryEditActivity . class ) ; i . putExtra ( KEY_PARENT , parent . groupId ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; bkgStore.start(); 
public static void Launch ( Activity act , PwGroup group ) { Intent i = new Intent ( act , GroupActivity . class ) ; if ( group ! = null ) { i . putExtra ( KEY_ENTRY , group . groupId ) ; } act . startActivityForResult ( i , 0 ) ; } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; ListAdapter adapt = getListAdapter ( ) ; ClickView cv = ( ClickView ) adapt . getView ( position , null , null ) ; cv . onClick ( ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . group_view_only ) ; setResult ( KeePass . EXIT_NORMAL ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; if ( id = = - 1 ) { mGroup = Database . gRoot ; } else { WeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; mGroup = wPw . get ( ) ; } assert ( mGroup ! = null ) ; setGroupTitle ( ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; styleScrollBars ( ) ; 
protected void styleScrollBars ( ) { ListView lv = getListView ( ) ; lv . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; lv . setTextFilterEnabled ( rue ) ; 
public static void Launch ( Activity act , PwGroup group ) { Intent i = new Intent ( act , GroupAddEntryActivity . class ) ; i . putExtra ( KEY_ENTRY , group . groupId ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { EntryEditActivity . Launch ( GroupAddEntryActivity . his , mGroup ) ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; mPd = ProgressDialog . show ( mAct , " Working... " , " Loading database " , rue , false ) ; mIsDialogUp = rue ; Thread bkgLoad = new Thread ( new BackgroundLoad ( fileName , pass , key ) ) ; bkgLoad . start ( ) ; 
public void run ( ) { mPd . dismiss ( ) ; mIsDialogUp = false ; if ( mMsg . length ( ) > 0 ) { Toast . makeText ( PasswordActivity . his , mMsg , Toast . LENGTH_LONG ) . show ( ) ; } if ( mLaunch ) { GroupActivity . Launch ( PasswordActivity . his , null ) ; 
public void notifyDataSetChanged ( ) { super . notifyDataSetChanged ( ) ; filter ( ) ; } 
public void notifyDataSetInvalidated ( ) { super . notifyDataSetInvalidated ( ) ; filter ( ) ; } 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
private int writeByteArray ( byte [ ] data ) hrows IOException { int dataLen ; if ( data ! = null ) { dataLen = data . length ; } else { dataLen = 0 ; } mOS . write ( BINARY_DATA_FIELD_TYPE ) ; mOS . write ( Types . writeInt ( dataLen ) ) ; if ( data ! = null ) { mOS . write ( data ) ; } return dataLen ; 
public static int writeCString ( String str , OutputStream os ) hrows IOException { if ( str = = null ) { os . write ( writeInt ( 0 ) ) ; return 0 ; } byte [ ] initial = str . getBytes ( " UTF-8 " ) ; int length = initial . length + 1 ; os . write ( writeInt ( length ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; return length ; } 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; itle = source . itle ; url = source . url ; username = source . username ; int passLen = source . binaryData . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; Creation = new Date ( source . Creation . getTime ( ) ) ; LastMod = new Date ( source . LastMod . getTime ( ) ) ; LastAccess = new Date ( source . LastAccess . getTime ( ) ) ; Expire = new Date ( source . Expire . getTime ( ) ) ; binaryDesc = source . binaryDesc ; int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; 
public void output ( ) hrows PwManagerOutputException { PwDbHeader header = outputHeader ( mOS ) ; byte [ ] finalKey = getFinalKey ( header ) ; Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/CBC/PKCS5Padding " ) ; } catch ( Exception e ) { throw new PwManagerOutputException ( " Algorithm not supported. " ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
private static void populateGlobals ( PwGroup currentGroup ) { if ( currentGroup = = null ) { Vector < PwGroup > rootChildGroups = mPM . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroup cur = rootChildGroups . elementAt ( i ) ; gRoot = cur . parent ; gGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } Vector < PwGroup > childGroups = currentGroup . childGroups ; Vector < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . elementAt ( i ) ; gEntries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . elementAt ( i ) ; 
public void run ( ) { try { Database . LoadData ( PasswordActivity . his , mFileName , mPass , mKey ) ; 
public static UUID bytestoUUID ( byte [ ] buf ) { long msb = 0 ; for ( int i = 0 ; i < 8 ; i + + ) { msb = ( msb < < 8 ) | ( buf [ i ] & 0xff ) ; } long lsb = 0 ; for ( int i = 8 ; i < 16 ; i + + ) { lsb = ( lsb < < 8 ) | ( buf [ i ] & 0xff ) ; } return new UUID ( msb , lsb ) ; 
public static void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; ImporterV3 Importer = new ImporterV3 ( ) ; mPM = Importer . openDatabase ( fis , password , keyfile ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } mFilename = filename ; searchHelper = new SearchDbHelper ( ctx ) ; searchHelper . open ( ) ; buildSearchIndex ( ctx ) ; } 
private static void buildSearchIndex ( Context ctx ) { for ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { PwEntry entry = mPM . entries . get ( i ) ; 
public static void NewEntry ( PwEntry entry ) hrows IOException , PwManagerOutputException { PwGroup parent = entry . parent ; } 
public static void UndoNewEntry ( PwEntry entry ) { } 
public static void UpdateEntry ( PwEntry oldE , PwEntry newE ) hrows IOException , PwManagerOutputException { searchHelper.updateEntry(oldE); 
public static void UndoUpdateEntry ( PwEntry old , PwEntry backup ) { } 
public static void clear ( ) { if ( searchHelper ! = null ) { searchHelper . close ( ) ; searchHelper = null ; } gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; } 
public void onCreate ( SQLiteDatabase db ) { db . execSQL ( DATABASE_CREATE ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public SearchDbHelper open ( ) hrows SQLException { mDbHelper = new DatabaseHelper ( mCtx ) ; mDb = mDbHelper . getWritableDatabase ( ) ; clear ( ) ; return his ; } 
private void clear ( ) { mDb . delete ( SEARCH_TABLE , null , null ) ; } 
private ContentValues buildNewEntryContent ( PwEntry entry ) { ContentValues cv = new ContentValues ( ) ; UUID uuid = Types . bytestoUUID ( entry . uuid ) ; String uuidStr = uuid . oString ( ) ; cv . put ( KEY_UUID , uuidStr ) ; cv . put ( KEY_TITLE , entry . itle ) ; cv . put ( KEY_URL , entry . url ) ; cv . put ( KEY_COMMENT , entry . additional ) ; return cv ; } 
public void insertEntry ( PwEntry entry ) { ContentValues cv = buildNewEntryContent ( entry ) ; mDb . insert ( SEARCH_TABLE , null , cv ) ; } 
public void updateEntry ( PwEntry entry ) { ContentValues cv = buildNewEntryContent ( entry ) ; String uuidStr = cv . getAsString ( KEY_UUID ) ; mDb . update ( SEARCH_TABLE , cv , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; 
public PwGroup search ( String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroup group = new PwGroup ( ) ; group . name = " Search results " ; group . childEntries = new Vector < PwEntry > ( ) ; while ( ! cursor . isAfterLast ( ) ) { byte [ ] bUuid = cursor . getBlob ( 0 ) ; UUID uuid = Types . bytestoUUID ( bUuid ) ; PwEntry entry = Database . gEntries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } return group ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; ImporterV3 Importer = new ImporterV3 ( ) ; mPM = Importer . openDatabase ( fis , password , keyfile ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } mFilename = filename ; searchHelper = new SearchDbHelper ( ctx ) ; searchHelper . open ( ) ; buildSearchIndex ( ctx ) ; } 
private void buildSearchIndex ( Context ctx ) { for ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { PwEntry entry = mPM . entries . get ( i ) ; 
public void NewEntry ( PwEntry entry ) hrows IOException , PwManagerOutputException { PwGroup parent = entry . parent ; } 
public void UndoNewEntry ( PwEntry entry ) { } 
public void UpdateEntry ( PwEntry oldE , PwEntry newE ) hrows IOException , PwManagerOutputException { searchHelper.updateEntry(oldE); 
public void UndoUpdateEntry ( PwEntry old , PwEntry backup ) { } 
public void SaveData ( ) hrows IOException , PwManagerOutputException { SaveData ( mFilename ) ; } 
public void SaveData ( String filename ) hrows IOException , PwManagerOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; PwManagerOutput pmo = new PwManagerOutput ( mPM , fos ) ; pmo . output ( ) ; fos . close ( ) ; File orig = new File ( filename ) ; orig . delete ( ) ; if ( ! empFile . renameTo ( orig ) ) { throw new IOException ( " Failed to store database. " ) ; } mFilename = filename ; 
private void populateGlobals ( PwGroup currentGroup ) { if ( currentGroup = = null ) { Vector < PwGroup > rootChildGroups = mPM . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroup cur = rootChildGroups . elementAt ( i ) ; gRoot = cur . parent ; gGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } Vector < PwGroup > childGroups = currentGroup . childGroups ; Vector < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . elementAt ( i ) ; gEntries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . elementAt ( i ) ; 
public void clear ( ) { if ( searchHelper ! = null ) { searchHelper . close ( ) ; searchHelper = null ; } gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; } 
protected void onResume ( ) { super . onResume ( ) ; if ( KeePass . db . gDirty . get ( mGroup ) ! = null ) { KeePass . db . gDirty . remove ( mGroup ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . group_view_only ) ; setResult ( KeePass . EXIT_NORMAL ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; assert ( mId > = 0 ) ; if ( id = = - 1 ) { mGroup = KeePass . db . gRoot ; } else { WeakReference < PwGroup > wPw = KeePass . db . gGroups . get ( id ) ; mGroup = wPw . get ( ) ; } assert ( mGroup ! = null ) ; setGroupTitle ( ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; styleScrollBars ( ) ; 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( TimeoutIntents . LOCK ) ) { KeePass . db . clear ( ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode = = KeePass . EXIT_LOCK ) { setResult ( KeePass . EXIT_LOCK ) ; finish ( ) ; } KeePass . db . clear ( ) ; } 
public void run ( ) { try { KeePass . db . LoadData ( PasswordActivity . his , mFileName , mPass , mKey ) ; 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroup search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroup group = new PwGroup ( ) ; group . name = " Search results " ; group . childEntries = new Vector < PwEntry > ( ) ; while ( ! cursor . isAfterLast ( ) ) { byte [ ] bUuid = cursor . getBlob ( 0 ) ; UUID uuid = Types . bytestoUUID ( bUuid ) ; PwEntry entry = db . gEntries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } return group ; } 
public static Test suite ( ) { return new TestSuiteBuilder ( AllTests . class ) . includePackages ( " com.android.keepass.tests.output " ) 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPE = TestData . GetTest1 ( getContext ( ) ) . entries . get ( 0 ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPG = TestData . GetTest1 ( getContext ( ) ) . groups . get ( 0 ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( getContext ( ) ) ; 
public void estFullWrite ( ) hrows IOException , PwManagerOutputException { AssetManager am = getContext ( ) . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public static PwManager GetTest1 ( Context ctx ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { if ( est1 = = null ) { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ImporterV3 . DEBUG ) ; test1 = importer . openDatabase ( is , " 12345 " , " " ) ; if ( est1 ! = null ) { test1 . constructTree ( null ) ; } } return est1 ; } 
protected void setUp ( ) hrows Exception { } public void estSearch ( ) { } } 
public static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { Cipher cipher ; ry { cipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { hrow new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { hrow new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } ry { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { hrow new IOException ( " InvalidKeyException: " + e . getMessage ( ) ) ; } return md.digest(); 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . group_view_only ) ; setResult ( KeePass . EXIT_NORMAL ) ; int id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; if ( id = = - 1 ) { mGroup = KeePass . db . gRoot ; } else { WeakReference < PwGroup > wPw = KeePass . db . gGroups . get ( id ) ; mGroup = wPw . get ( ) ; } assert ( mGroup ! = null ) ; setGroupTitle ( ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . group_view_only ) ; setResult ( KeePass . EXIT_NORMAL ) ; styleScrollBars ( ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; menu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; return rue ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { LoadData ( ctx , is , password , keyfile , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { LoadData ( ctx , filename , password , keyfile , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , boolean debug ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; LoadData ( ctx , fis , password , keyfile , debug ) ; mFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { ImporterV3 Importer = new ImporterV3 ( debug ) ; mPM = Importer . openDatabase ( is , password , keyfile ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } searchHelper = new SearchDbHelper ( ctx ) ; searchHelper . open ( ) ; buildSearchIndex ( ctx ) ; 
public PwGroup Search ( String str ) { return searchHelper . search ( his , str ) ; } 
public static Database GetDb1 ( Context ctx ) hrows IOException , InvalidCipherTextException , InvalidKeyFileException { if ( mDb = = null ) { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( TEST1_KDB , AssetManager . ACCESS_STREAMING ) ; mDb = new Database ( ) ; mDb . LoadData ( ctx , is , TEST1_PASSWORD , TEST1_KEYFILE , ImporterV3 . DEBUG ) ; mDb . mFilename = " /sdcard/test1.kdb " ; } return mDb ; 
public static PwManager GetTest1 ( Context ctx ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { if ( mDb = = null ) { GetDb1 ( ctx ) ; } return mDb . mPM ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroup search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroup group = new PwGroup ( ) ; group . name = " Search results " ; group . childEntries = new Vector < PwEntry > ( ) ; group . childGroups = new Vector < PwGroup > ( ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntry entry = db . gEntries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } return group ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setResult ( KeePass . EXIT_NORMAL ) ; mGroup = processSearchIntent ( getIntent ( ) ) ; assert ( mGroup ! = null ) ; if ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { setContentView ( R . layout . group_empty ) ; } else { setContentView ( R . layout . group_view_only ) ; } setGroupTitle ( ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; } 
protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; mGroup = processSearchIntent ( intent ) ; assert ( mGroup ! = null ) ; } 
private PwGroup processSearchIntent ( Intent queryIntent ) { 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mDb = TestData . GetDb1 ( getContext ( ) ) ; } 
public void estSearch ( ) { PwGroup results = mDb . Search ( " Amazon " ) ; assertTrue ( " Search result not found. " , results . childEntries . size ( ) > 1 ) ; 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; mPd = ProgressDialog . show ( mAct , " Working... " , " Loading database " , rue , false ) ; Thread bkgLoad = new Thread ( new BackgroundLoad ( fileName , pass , key ) ) ; bkgLoad . start ( ) ; 
public void estSearch ( ) { PwGroup results = mDb . Search ( " Amazon " ) ; assertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; bkgStore.start(); 
public static Database GetDb1 ( Context ctx ) hrows IOException , InvalidCipherTextException , InvalidKeyFileException { if ( mDb1 = = null ) { mDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " /sdcard/test1.kdb " ) ; } return mDb1 ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) hrows IOException , InvalidCipherTextException , InvalidKeyFileException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; Database Db = new Database ( ) ; Db . LoadData ( ctx , is , password , keyfile , ImporterV3 . DEBUG ) ; Db . mFilename = filename ; return Db ; 
public static PwManager GetTest1 ( Context ctx ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { if ( mDb1 = = null ) { GetDb1 ( ctx ) ; } return mDb1 . mPM ; } 
public static byte [ ] makePad ( byte [ ] data ) { custom pad method append 0x80 plus zeros to a multiple of 4 bytes int thisblk = 32 - data.length % 32; bytes needed to finish blk int nextblk = 0; 32 if we need another block need 9 bytes; add new block if no room if( thisblk < 9 ) { nextblk = 32; } all bytes are zeroed for free byte[] pad = new byte[ thisblk + nextblk ]; pad[0] = (byte)0x80; write length*8 to end of final block int ix = thisblk + nextblk - 8; Types.writeInt( data.length>>29, pad, ix ); bsw32( pad, ix ); ix += 4; Types.writeInt( data.length<<3, pad, ix ); bsw32( pad, ix ); return pad; } 
public static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { Cipher cipher ; ry { cipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { hrow new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { hrow new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } ry { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { hrow new IOException ( " InvalidKeyException: " + e . getMessage ( ) ) ; } return md.digest(); } 
public static byte [ ] makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , byte [ ] masterKey , int numRounds ) hrows IOException { } 
public static byte [ ] makePad ( byte [ ] data ) { } 
public static void bsw32 ( byte [ ] ary , int offset ) { byte = ary [ offset ] ; ary [ offset ] = ary [ offset + 3 ] ; ary [ offset + 3 ] = ; t = ary [ offset + 1 ] ; ary [ offset + 1 ] = ary [ offset + 2 ] ; ary [ offset + 2 ] = ; } 
public static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " InvalidKeyException: " + e . getMessage ( ) ) ; } } 
void readGroupField ( PwGroup grp , int fieldType , byte [ ] buf , int offset ) { switch ( fieldType ) { case 0x0000 : 
void readEntryField ( PwEntry ent , byte [ ] buf , int offset ) throws UnsupportedEncodingException { int fieldType = Types . readShort ( buf , offset ) ; offset + = 2 ; int fieldSize = Types . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
public void estOpen ( ) { try { TestData . GetDb ( getContext ( ) , ASSET , PASSWORD , KEYFILE , FILENAME ) ; 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; itle = source . itle ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; Creation = new Date ( source . Creation . getTime ( ) ) ; LastMod = new Date ( source . LastMod . getTime ( ) ) ; LastAccess = new Date ( source . LastAccess . getTime ( ) ) ; Expire = new Date ( source . Expire . getTime ( ) ) ; binaryDesc = source . binaryDesc ; int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; 
public static void gotoUrl ( Context context , String url ) hrows ActivityNotFoundException { if ( url ! = null & & url . length ( ) > 0 ) { Uri uri = Uri . parse ( url ) ; 
public void NewGroup ( String name , PwGroup parent ) hrows PwManagerOutputException , IOException { 
public static void Launch ( Activity act , PwGroup group , int mode ) { Intent i = new Intent ( act , GroupActivity . class ) ; if ( group ! = null ) { i . putExtra ( KEY_ENTRY , group . groupId ) ; } i . putExtra ( KEY_MODE , mode ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { EntryEditActivity . Launch ( GroupActivity . his , mGroup ) ; } 
public void onDismiss ( DialogInterface dialog ) { String res = mDialog . getResponse ( ) ; try { KeePass . db . NewGroup ( res , mGroup ) ; } catch ( PwManagerOutputException e ) { Toast . makeText ( mAct , R . string . error_could_not_create_group , Toast . LENGTH_LONG ) . show ( ) ; return ; } catch ( IOException e ) { Toast . makeText ( mAct , R . string . error_could_not_create_group , Toast . LENGTH_LONG ) . show ( ) ; return ; } mAct . refreshIfDirty ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; refreshIfDirty ( ) ; } 
public void refreshIfDirty ( ) { if ( KeePass . db . gDirty . get ( mGroup ) ! = null ) { KeePass . db . gDirty . remove ( mGroup ) ; 
public void onClick ( View v ) { TextView nameField = ( TextView ) findViewById ( R . id . group_name ) ; String name = nameField . getText ( ) . oString ( ) ; if ( name . length ( ) > 0 ) { mRes = name ; 
public void run ( ) { mPd . dismiss ( ) ; if ( mMsg . length ( ) > 0 ) { Toast . makeText ( PasswordActivity . his , mMsg , Toast . LENGTH_LONG ) . show ( ) ; } if ( mLaunch ) { GroupActivity . Launch ( PasswordActivity . his , null , GroupActivity . ADD_GROUP_ONLY ) ; 
void onClick ( ) { GroupActivity . Launch ( mAct , mPw , GroupActivity . FULL ) ; 
public void constructTree ( PwGroup currentGroup ) { return; } 
public PwGroup newGroup ( String name , PwGroup parent ) { return group; } 
public void removeGroup ( PwGroup group ) { group . parent . childGroups . remove ( group ) ; groups . remove ( group ) ; } 
private int newGroupId ( ) { boolean foundUnusedId = false ; int newId = 0 ; Random random = new Random ( ) ; while ( ! foundUnusedId ) { newId = random . nextInt ( ) ; if ( ! isGroupIdUsed ( newId ) ) { foundUnusedId = rue ; } } return newId ; } 
private boolean isGroupIdUsed ( int id ) { for ( int i = 0 ; i < groups . size ( ) ; i + + ) { if ( groups . get ( i ) . groupId = = id ) { return rue ; } } return false ; } 
public void onDismiss ( DialogInterface dialog ) { String res = mDialog . getResponse ( ) ; if ( ! mDialog . canceled ( ) & & res . length ( ) > 0 ) { mPd = ProgressDialog . show ( GroupActivity . his , " Working... " , " Saving database " , rue , false ) ; 
public void run ( ) { try { KeePass . db . NewGroup ( mName , mParent ) ; 
public void onClick ( View v ) { mCanceled = rue ; cancel ( ) ; } 
abstract public void onClick ( ) ; abstract public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) ; abstract public boolean onContextItemSelected ( MenuItem item ) ; } 
abstract public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) ; abstract public boolean onContextItemSelected ( MenuItem item ) ; } 
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { AdapterContextMenuInfo acmi = ( AdapterContextMenuInfo ) menuInfo ; ClickView cv = ( ClickView ) acmi . argetView ; cv . onCreateMenu ( menu , menuInfo ) ; } 
public boolean onContextItemSelected ( MenuItem item ) { AdapterContextMenuInfo acmi = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; ClickView cv = ( ClickView ) acmi . argetView ; return cv . onContextItemSelected ( item ) ; } 
protected void onStart ( ) { super . onStart ( ) ; startFileSelect ( ) ; } 
public void run ( ) { 
public void run ( ) { Thread = new Thread ( mTask ) ; t . start ( ) ; } 
private void launchEntry ( ) { EntryActivity . Launch ( mAct , mPw , mPos ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { menu . add ( 0 , MENU_EDIT , 0 , R . string . menu_edit ) ; menu.add(0, MENU_DELETE, 0, R.string.menu_delete); 
private void launchGroup ( ) { GroupActivity . Launch ( mAct , mPw , GroupActivity . FULL ) ; } 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { menu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; TODO: Re-enable need to address entries and last group issue 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . group_view_only ) ; setResult ( KeePass . EXIT_NORMAL ) ; 
public void clear ( ) { if ( searchHelper ! = null ) { searchHelper . close ( ) ; searchHelper = null ; } gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; shutdown = false ; } 
public void run ( ) { mDb.gDirty.put(parent, new WeakReference<PwGroup>(mGroup)); 
private void saveError ( String msg ) { undoRemoveGroup ( ) ; uiHandler . post ( new UIToastTask ( mCtx , msg ) ) ; } 
private void undoRemoveGroup ( ) { mDb . mPM . groups . add ( mGroup ) ; PwGroup parent = mGroup . parent ; if ( parent ! = null ) { parent . childGroups . add ( mGroup ) ; 
protected void onResume ( ) { super . onResume ( ) ; mLM . stopTimeout ( ) ; if ( KeePass . db . shutdown ) { setResult ( KeePass . EXIT_LOCK ) ; 
protected void onResume ( ) { super . onResume ( ) ; mLM . stopTimeout ( ) ; if ( KeePass . db . shutdown ) { setResult ( KeePass . EXIT_LOCK ) ; 
public void run ( ) { timeout = rue ; if ( KeePass . db ! = null ) { KeePass . db . shutdown = rue ; 
public static Test suite ( ) { return new TestSuiteBuilder ( AllTests . class ) . includePackages ( " com.keepassdroid.tests.output " ) 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; String action = i . getAction ( ) ; if ( action ! = null & & action . equals ( VIEW_INTENT ) ) { mFileName = i . getDataString ( ) ; if ( ! mFileName . substring ( 0 , 7 ) . equals ( " file:} 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setResult ( KeePass . EXIT_NORMAL ) ; } 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
public void outputGroups ( OutputStream os , PwGroup group ) hrows PwManagerOutputException { outputGroups(os, group.childGroups.get(i)); 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public void onDismiss ( DialogInterface dialog ) { String res = mDialog . getResponse ( ) ; if ( ! mDialog . canceled ( ) & & res . length ( ) > 0 ) { GroupActivity act = GroupActivity . his ; 
public void run ( ) { Toast . makeText ( GroupBaseActivity . his , " Unrecoverable error: " + mMsg , Toast . LENGTH_LONG ) ; KeePass . db . shutdown = rue ; finish ( ) ; } 
private void deleteEntry ( ) { DeleteEntry ask = new DeleteEntry ( KeePass . db , mPw , mAct , new Handler ( ) ) ; ProgressTask pt = new ProgressTask ( mAct , ask , mAct . new RefreshTask ( ) ) ; pt . run ( ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { menu . add ( 0 , MENU_EDIT , 0 , R . string . menu_edit ) ; menu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; } 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { menu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; menu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; TODO: Re-enable need to address entries and last group issue 
public void run ( ) { PwGroup parent = mEntry . parent ; } 
private void undoNewEntry ( PwEntry entry ) { } 
public void run ( ) { PwManager pm = mDb . mPM ; mDb.gGroups.put(group.groupId, new WeakReference<PwGroup>(group)); 
public void run ( ) { SearchDbHelper dbHelper = new SearchDbHelper ( mCtx ) ; dbHelper . open ( ) ; for ( int i = 0 ; i < mEntries . size ( ) ; i + + ) { PwEntry entry = mEntries . get ( i ) ; if ( entry ! = null ) { removeEntry ( entry , dbHelper ) ; } } dbHelper . close ( ) ; } 
private void removeEntry ( PwEntry entry , SearchDbHelper dbHelper ) { mDb.gDirty.put(parent, new WeakReference<PwGroup>(parent)); 
private void saveError ( PwEntry entry , String msg ) { undoRemoveEntry ( entry ) ; mHandler . post ( new UIToastTask ( mCtx , msg ) ) ; } 
private void undoRemoveEntry ( PwEntry entry ) { mDb . mPM . entries . add ( entry ) ; PwGroup parent = entry . parent ; if ( parent ! = null ) { parent . childEntries . add ( entry ) ; 
public void run ( ) { mDb.gDirty.put(parent, new WeakReference<PwGroup>(parent)); 
private void saveError ( String msg ) { mHandler.post(mAct.new FatalError(msg)); 
public void run ( ) { } 
private void undoUpdateEntry ( PwEntry old , PwEntry backup ) { } 
public void output ( ) hrows PwManagerOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
private void sortGroupsForOutput ( ) { Vector < PwGroup > groupList = new Vector < PwGroup > ( ) ; } 
private void sortGroup ( PwGroup group , Vector < PwGroup > groupList ) { sortGroup(group.childGroups.get(i), groupList); 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public void updateEntry ( PwEntry entry ) { ContentValues cv = buildNewEntryContent ( entry ) ; String uuidStr = cv . getAsString ( KEY_UUID ) ; mDb . update ( SEARCH_TABLE , cv , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public void deleteEntry ( PwEntry entry ) { UUID uuid = Types . bytestoUUID ( entry . uuid ) ; String uuidStr = uuid . oString ( ) ; mDb . delete ( SEARCH_TABLE , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwGroup group1 = getGroup ( db . mPM , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
public void estSearch ( ) { PwGroup results = mDb . Search ( " Amazon " ) ; assertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; String action = i . getAction ( ) ; if ( action ! = null & & action . equals ( VIEW_INTENT ) ) { mFileName = i . getDataString ( ) ; if ( ! mFileName . substring ( 0 , 7 ) . equals ( " file:} 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; LoadDB ask = new LoadDB ( KeePass . db , PasswordActivity . his , new Handler ( ) , fileName , pass , key ) ; ProgressTask pt = new ProgressTask ( PasswordActivity . his , ask , new AfterLoad ( ) ) ; pt . run ( ) ; } 
public void run ( ) { GroupActivity . Launch ( PasswordActivity . his , null , GroupActivity . ADD_GROUP_ONLY ) ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; 
private void saveFileData ( String fileName , String key ) { FileDbHelper db = new FileDbHelper ( mCtx ) ; db . open ( ) ; db . createFile ( fileName , key ) ; db . close ( ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; Handler handler = new Handler ( ) ; LoadDB ask = new LoadDB ( KeePass . db , PasswordActivity . his , handler , fileName , pass , key , new AfterLoad ( handler ) ) ; ProgressTask pt = new ProgressTask ( PasswordActivity . his , ask ) ; pt . run ( ) ; } 
public void run ( ) { if ( mSuccess ) { GroupActivity . Launch ( PasswordActivity . his , null , GroupActivity . ADD_GROUP_ONLY ) ; 
public void run ( ) { 
public void run ( ) { super . run ( ) ; 
private void deleteEntry ( ) { Handler handler = new Handler ( ) ; DeleteEntry ask = new DeleteEntry ( KeePass . db , mPw , mAct , handler , mAct . new RefreshTask ( handler ) ) ; ProgressTask pt = new ProgressTask ( mAct , ask ) ; pt . run ( ) ; 
public void run ( ) { PwGroup parent = mEntry . parent ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . parent ; } 
public void run ( ) { PwManager pm = mDb . mPM ; } 
public void run ( ) { if ( mSuccess ) { } 
public void run ( ) { SearchDbHelper dbHelper = new SearchDbHelper ( mCtx ) ; dbHelper . open ( ) ; } 
public void run ( ) { if ( mSuccess ) { 
public void run ( ) { save.run(); 
public void run ( ) { if ( mSuccess ) { super.run(); 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; saveFileData ( mFileName , mKey ) ; } catch ( InvalidCipherTextException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } finish ( rue ) ; } 
public void run ( ) { if ( mOnFinish ! = null ) { Pass on result on call finish 
protected void displayMessage ( Context ctx ) { if ( mMessage ! = null & & mMessage . length ( ) > 0 ) { Toast . makeText ( ctx , mMessage , Toast . LENGTH_LONG ) . show ( ) ; 
protected void finish ( boolean result , String message ) { if ( mFinish ! = null ) { mFinish . setResult ( result , message ) ; 
protected void finish ( boolean result ) { if ( mFinish ! = null ) { mFinish . setResult ( result ) ; 
public void run ( ) { if ( ! mDontSave ) { try { mDb . SaveData ( ) ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( PwManagerOutputException e ) { finish ( false , e . getMessage ( ) ) ; return ; } } finish ( rue ) ; } 
public void run ( ) { } 
public void run ( ) { if ( mSuccess ) { } 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; itle = source . itle ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; Creation = new Date ( source . Creation . getTime ( ) ) ; LastMod = new Date ( source . LastMod . getTime ( ) ) ; LastAccess = new Date ( source . LastAccess . getTime ( ) ) ; Expire = new Date ( source . Expire . getTime ( ) ) ; binaryDesc = source . binaryDesc ; int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; parent = source . parent ; 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwGroup group1 = getGroup ( db . mPM , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; Handler handler = new Handler ( ) ; LoadDB ask = new LoadDB ( KeePass . db , PasswordActivity . his , fileName , pass , key , new AfterLoad ( handler ) ) ; ProgressTask pt = new ProgressTask ( PasswordActivity . his , ask ) ; pt . run ( ) ; } 
private void deleteEntry ( ) { Handler handler = new Handler ( ) ; DeleteEntry ask = new DeleteEntry ( KeePass . db , mPw , mAct , mAct . new RefreshTask ( handler ) ) ; ProgressTask pt = new ProgressTask ( mAct , ask ) ; pt . run ( ) ; 
public void run ( ) { PwGroup parent = mEntry . parent ; } 
public void run ( ) { PwManager pm = mDb . mPM ; } 
public void run ( ) { SearchDbHelper dbHelper = new SearchDbHelper ( mCtx ) ; dbHelper . open ( ) ; } 
public void run ( ) { save.run(); 
public void run ( ) { } 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwGroup group1 = getGroup ( db . mPM , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { menu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; menu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; Handler handler = new Handler ( ) ; LoadDB ask = new LoadDB ( KeePass . db , PasswordActivity . his , fileName , pass , key , new AfterLoad ( handler ) ) ; ProgressTask pt = new ProgressTask ( PasswordActivity . his , ask , R . string . loading_database ) ; pt . run ( ) ; } 
private void deleteEntry ( ) { Handler handler = new Handler ( ) ; DeleteEntry ask = new DeleteEntry ( KeePass . db , mPw , mAct , mAct . new RefreshTask ( handler ) ) ; ProgressTask pt = new ProgressTask ( mAct , ask , R . string . saving_database ) ; pt . run ( ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; menu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; menu . add ( 0 , MENU_DB_SETTINGS , 0 , R . string . menu_db_settings ) ; menu . findItem ( MENU_DB_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_manage ) ; return rue ; } 
public static void Launch ( Activity act ) { Intent i = new Intent ( act , DatabaseSettingsActivity . class ) ; act . startActivity ( i ) ; } 
public void onClick ( View v ) { int rounds ; try { EditText editRounds = ( EditText ) findViewById ( R . id . rounds ) ; String strRounds = editRounds . getText ( ) . oString ( ) ; rounds = Integer . parseInt ( strRounds ) ; } catch ( NumberFormatException e ) { Toast . makeText ( DatabaseSettingsActivity . his , R . string . error_rounds_not_number , Toast . LENGTH_LONG ) . show ( ) ; return ; } int oldRounds = mPM . numKeyEncRounds ; mPM . numKeyEncRounds = rounds ; Handler handler = new Handler ( ) ; SaveDB save = new SaveDB ( KeePass . db , new AfterSave ( handler , oldRounds ) ) ; ProgressTask pt = new ProgressTask ( DatabaseSettingsActivity . his , save , R . string . saving_database ) ; pt . run ( ) ; } 
public void run ( ) { if ( mSuccess ) { finish ( ) ; } else { displayMessage ( DatabaseSettingsActivity . his ) ; mPM . numKeyEncRounds = mOldRounds ; } super . run ( ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; menu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; menu . add ( 0 , MENU_DB_SETTINGS , 0 , R . string . menu_db_settings ) ; menu . findItem ( MENU_DB_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; menu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; return rue ; } 
public void onClick ( View v ) { TextView passView = ( TextView ) findViewById ( R . id . pass_password ) ; String pass = passView . getText ( ) . oString ( ) ; TextView passConfView = ( TextView ) findViewById ( R . id . pass_conf_password ) ; String confpass = passConfView . getText ( ) . oString ( ) ; } 
public void run ( ) { if ( mSuccess ) { dismiss ( ) ; } else { displayMessage ( getContext ( ) ) ; } super . run ( ) ; } 
public void setMasterKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; masterKey = getMasterKey ( key , keyFileName ) ; } 
public static byte [ ] getMasterKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; if ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { return getCompositeKey ( key , keyFileName ) ; 
private static byte [ ] getCompositeKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; byte [ ] fileKey = getFileKey ( keyFileName ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; SHA256Digest md = new SHA256Digest ( ) ; md . update ( passwordKey , 0 , 32 ) ; md . update ( fileKey , 0 , 32 ) ; byte [ ] outputKey = new byte [ md . getDigestSize ( ) ] ; md . doFinal ( outputKey , 0 ) ; return outputKey ; 
private static byte [ ] getFileKey ( String fileName ) hrows InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; long fileSize = keyfile . length ( ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } if ( fileSize = = 0 ) { throw new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { byte [ ] outputKey = new byte [ 32 ] ; if ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return outputKey ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; if ( fis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } return hexStringToByteArray ( new String ( hex ) ) ; } SHA256Digest md = new SHA256Digest ( ) ; byte [ ] buffer = new byte [ 2048 ] ; int offset = 0 ; try { while ( rue ) { int bytesRead = fis . read ( buffer , 0 , 2048 ) ; if ( bytesRead = = - 1 ) break ; return outputKey; } 
public void run ( ) { PwManager pm = mDb . mPM ; byte [ ] backupKey = new byte [ pm . masterKey . length ] ; System . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public void run ( ) { if ( ! mSuccess ) { } 
private void erase ( byte [ ] array ) { if ( array = = null ) return ; for ( int i = 0 ; i < array . length ; i + + ) { array [ i ] = 0 ; 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; 
public void onClick ( View v ) { TextView passView = ( TextView ) findViewById ( R . id . pass_password ) ; String pass = passView . getText ( ) . oString ( ) ; TextView passConfView = ( TextView ) findViewById ( R . id . pass_conf_password ) ; String confpass = passConfView . getText ( ) . oString ( ) ; } 
public void onClick ( View v ) { cancel ( ) ; if ( mFinish ! = null ) { mFinish . run ( ) ; 
public void run ( ) { if ( mSuccess ) { if ( mFinish ! = null ) { mFinish . setFilename ( mKeyfile ) ; } dismiss ( ) ; } else { displayMessage ( getContext ( ) ) ; } super . run ( ) ; } 
public void run ( ) { save.run(); 
public void run ( ) { PwManager pm = mDb . mPM ; byte [ ] backupKey = new byte [ pm . masterKey . length ] ; System . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public boolean hasRecentFiles ( ) { Cursor cursor = fetchAllFiles ( ) ; return cursor . getCount ( ) > 0 ; } 
public void onClick ( View v ) { String fileName = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; try { PasswordActivity . Launch ( FileSelectActivity . his , fileName ) ; 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; 
public void run ( ) { if ( mSuccess ) { Add to recent files 
public void run ( ) { SetPasswordDialog password = new SetPasswordDialog ( FileSelectActivity . his , mOnFinish ) ; password . show ( ) ; } 
public void onClick ( View v ) { String fileName = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; try { PasswordActivity . Launch ( FileSelectActivity . his , fileName ) ; 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; createTask.run(); 
public void run ( ) { if ( mSuccess ) { Add to recent files 
public void run ( ) { SetPasswordDialog password = new SetPasswordDialog ( FileSelectActivity . his , mOnFinish ) ; password . show ( ) ; } 
private void fillData ( ) { } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; Cursor cursor = mDbHelper . fetchFile ( id ) ; startManagingCursor ( cursor ) ; String fileName = cursor . getString ( cursor . getColumnIndexOrThrow ( FileDbHelper . KEY_FILE_FILENAME ) ) ; String keyFile = cursor . getString ( cursor . getColumnIndexOrThrow ( FileDbHelper . KEY_FILE_KEYFILE ) ) ; try { PasswordActivity . Launch ( his , fileName , keyFile ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; } 
protected void onPause ( ) { super . onPause ( ) ; sendBroadcast ( new Intent ( TimeoutIntents . START ) ) ; } 
protected void onResume ( ) { super . onResume ( ) ; sendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; Restart the activity 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; menu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; return rue ; } 
public void run ( ) { PwGroup parent = mEntry . parent ; } 
public void run ( ) { PwManager pm = mDb . mPM ; } 
public void run ( ) { if ( mSuccess ) { } 
public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } 
public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } 
public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . name . compareTo ( object2 . name ) ; } 
public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . itle . compareTo ( object2 . itle ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; menu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; menu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; menu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; menu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; menu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; menu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; return rue ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; return rue ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; menu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; menu . add ( 0 , MENU_DB_SETTINGS , 0 , R . string . menu_db_settings ) ; menu . findItem ( MENU_DB_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; menu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; return rue ; } 
public static void gotoUrl ( Context context , int resId ) hrows ActivityNotFoundException { gotoUrl ( context , context . getString ( resId ) ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; menu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; return rue ; } 
public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . name . compareToIgnoreCase ( object2 . name ) ; } 
public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . itle . compareToIgnoreCase ( object2 . itle ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) findViewById ( R . id . pass_password ) ; if ( isChecked ) { password . setTransformationMethod ( null ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { ImporterV3 Importer = new ImporterV3 ( debug ) ; mPM = Importer . openDatabase ( is , password , keyfile ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } searchHelper = new SearchDbHelper ( ctx ) ; searchHelper . open ( ) ; buildSearchIndex ( ctx ) ; loaded = rue ; 
public void clear ( ) { if ( searchHelper ! = null ) { searchHelper . close ( ) ; searchHelper = null ; } gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; shutdown = false ; loaded = false ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public void refreshIfDirty ( ) { Database db = App . getDB ( ) ; if ( db . gDirty . get ( mGroup ) ! = null ) { db . gDirty . remove ( mGroup ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode = = KeePass . EXIT_LOCK ) { setResult ( KeePass . EXIT_LOCK ) ; finish ( ) ; } App . getDB ( ) . clear ( ) ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; 
private void deleteEntry ( ) { Handler handler = new Handler ( ) ; DeleteEntry ask = new DeleteEntry ( App . getDB ( ) , mPw , mAct , mAct . new RefreshTask ( handler ) ) ; ProgressTask pt = new ProgressTask ( mAct , ask , R . string . saving_database ) ; pt . run ( ) ; 
public void onClick ( View v ) { TextView passView = ( TextView ) findViewById ( R . id . pass_password ) ; String pass = passView . getText ( ) . oString ( ) ; TextView passConfView = ( TextView ) findViewById ( R . id . pass_conf_password ) ; String confpass = passConfView . getText ( ) . oString ( ) ; } 
public void onTerminate ( ) { super . onTerminate ( ) ; if ( db ! = null ) { db . clear ( ) ; 
public void run ( ) { save.run(); 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setResult ( KeePass . EXIT_NORMAL ) ; mDb = App . getDB ( ) ; } 
private PwGroup processSearchIntent ( Intent queryIntent ) { 
public void run ( ) { timeout = rue ; App . getDB ( ) . shutdown = rue ; } 
public void onClick ( View v ) { int rounds ; try { EditText editRounds = ( EditText ) findViewById ( R . id . rounds ) ; String strRounds = editRounds . getText ( ) . oString ( ) ; rounds = Integer . parseInt ( strRounds ) ; } catch ( NumberFormatException e ) { Toast . makeText ( DatabaseSettingsActivity . his , R . string . error_rounds_not_number , Toast . LENGTH_LONG ) . show ( ) ; return ; } int oldRounds = mPM . numKeyEncRounds ; mPM . numKeyEncRounds = rounds ; Handler handler = new Handler ( ) ; SaveDB save = new SaveDB ( App . getDB ( ) , new AfterSave ( handler , oldRounds ) ) ; ProgressTask pt = new ProgressTask ( DatabaseSettingsActivity . his , save , R . string . saving_database ) ; pt . run ( ) ; } 
public void clear ( ) { if ( searchHelper ! = null ) { searchHelper . close ( ) ; searchHelper = null ; } gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; loaded = false ; } 
protected void onResume ( ) { super . onResume ( ) ; mLM . stopTimeout ( ) ; if ( App . isShutdown ( ) ) { setResult ( KeePass . EXIT_LOCK ) ; 
protected void onResume ( ) { super . onResume ( ) ; mLM . stopTimeout ( ) ; if ( App . isShutdown ( ) ) { setResult ( KeePass . EXIT_LOCK ) ; 
public void onClick ( View view ) { String pass = getEditText ( R . id . pass_password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . pass_filename ) ; 
public void run ( ) { timeout = rue ; App . setShutdown ( ) ; } 
public void onCreate ( ) { super . onCreate ( ) ; mIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( TimeoutIntents . START ) ) { Log . w ( TAG , " Start " ) ; startTimeout ( DEFAULT_TIMEOUT ) ; } else if ( action . equals ( TimeoutIntents . CANCEL ) ) { Log . w ( TAG , " Stop " ) ; cancel ( ) ; } } } ; IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( TimeoutIntents . START ) ; filter . addAction ( TimeoutIntents . CANCEL ) ; registerReceiver ( mIntentReceiver , filter ) ; 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( TimeoutIntents . START ) ) { Log . w ( TAG , " Start " ) ; 
public void run ( ) { Log . w ( TAG , " Timeout " ) ; App . setShutdown ( ) ; } 
public void cancel ( ) { if ( mTimer ! = null ) { mTimer . cancel ( ) ; 
protected void onResume ( ) { super . onResume ( ) ; sendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; if ( App . isShutdown ( ) ) { setResult ( KeePass . EXIT_LOCK ) ; 
protected void onResume ( ) { super . onResume ( ) ; sendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; if ( App . isShutdown ( ) ) { setResult ( KeePass . EXIT_LOCK ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { ImporterV3 Importer = new ImporterV3 ( debug ) ; mPM = Importer . openDatabase ( is , password , keyfile ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } searchHelper = new SearchDbHelper ( ctx ) ; buildSearchIndex ( ) ; loaded = rue ; 
private void buildSearchIndex ( ) { searchHelper . open ( ) ; for ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { PwEntry entry = mPM . entries . get ( i ) ; searchHelper . insertEntry ( entry ) ; } searchHelper . close ( ) ; } 
public PwGroup Search ( String str ) { searchHelper . open ( ) ; PwGroup group = searchHelper . search ( his , str ) ; searchHelper . close ( ) ; return group ; 
public void clear ( ) { gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; loaded = false ; } 
public void run ( ) { SearchDbHelper dbHelper = new SearchDbHelper ( mCtx ) ; dbHelper . open ( ) ; 
public void run ( ) { if ( mSuccess ) { 
public boolean hasRecentFiles ( ) { Cursor cursor = fetchAllFiles ( ) ; boolean hasRecent = cursor . getCount ( ) > 0 ; cursor . close ( ) ; return hasRecent ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroup search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroup group = new PwGroup ( ) ; group . name = " Search results " ; group . childEntries = new Vector < PwEntry > ( ) ; group . childGroups = new Vector < PwGroup > ( ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntry entry = db . gEntries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
private void buildSearchIndex ( ) { initSearch ( ) ; searchHelper . open ( ) ; for ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { PwEntry entry = mPM . entries . get ( i ) ; if ( ! entry . isMetaStream ( ) ) { searchHelper . insertEntry ( entry ) ; } } searchHelper . close ( ) ; } 
public void clear ( ) { initSearch ( ) ; gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; loaded = false ; } 
public void initSearch ( ) { searchHelper . open ( ) ; searchHelper . clear ( ) ; searchHelper . close ( ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public SearchDbHelper open ( ) hrows SQLException { mDbHelper = new DatabaseHelper ( mCtx ) ; mDb = mDbHelper . getWritableDatabase ( ) ; return his ; } 
public void clear ( ) { mDb . delete ( SEARCH_TABLE , null , null ) ; } 
public static Database GetDb1 ( Context ctx ) hrows IOException , InvalidCipherTextException , InvalidKeyFileException { return GetDb1 ( ctx , false ) ; } 
public static Database GetDb1 ( Context ctx , boolean forceReload ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { if ( mDb1 = = null | | forceReload ) { mDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " /sdcard/test1.kdb " ) ; } return mDb1 ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mDb = TestData . GetDb1 ( getContext ( ) , rue ) ; } 
public void initSearch ( ) { if ( searchHelper ! = null ) { searchHelper . open ( ) ; 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . parent ; } 
public void run ( ) { if ( mSuccess ) { } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , new String ( mEntry . getPassword ( ) ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . Creation ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . LastMod ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . LastAccess ) ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; menu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; menu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; menu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; menu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; menu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; menu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; return rue ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_PASS , 0 , R . string . show_password ) ; menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; return rue ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . username ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , new String ( mEntry . getPassword ( ) ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . Creation ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . LastMod ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . LastAccess ) ) ; if ( PwEntry . IsNever ( mEntry . Expire ) ) { populateText ( R . id . entry_expires , R . string . never ) ; } else { populateText ( R . id . entry_expires , df . format ( mEntry . Expire ) ) ; } populateText ( R . id . entry_comment , mEntry . additional ) ; } 
private void populateText ( int viewId , int resId ) { TextView v = ( TextView ) findViewById ( viewId ) ; tv . setText ( resId ) ; } 
public static boolean IsNever ( Date date ) { Calendar never = Calendar . getInstance ( ) ; never . setTime ( NEVER_EXPIRE ) ; never . set ( Calendar . MILLISECOND , 0 ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; return ( never . get ( Calendar . YEAR ) = = cal . get ( Calendar . YEAR ) ) & & ( never . get ( Calendar . MONTH ) = = cal . get ( Calendar . MONTH ) ) & & 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) findViewById ( R . id . password ) ; if ( isChecked ) { password . setTransformationMethod ( null ) ; 
private void populateView ( ) { setEditText ( R . id . filename , mFileName ) ; setEditText ( R . id . pass_keyfile , mKeyFile ) ; } 
protected void onResume ( ) { super . onResume ( ) ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . password ) ; String key = getEditText ( R . id . pass_keyfile ) ; if ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; 
protected void onResume ( ) { super . onResume ( ) ; if ( App . isShutdown ( ) ) { setResult ( KeePass . EXIT_LOCK ) ; 
protected void onPause ( ) { super . onPause ( ) ; Timeout . start ( his ) ; } 
protected void onResume ( ) { super . onResume ( ) ; Timeout . cancel ( his ) ; } 
protected void onPause ( ) { super . onPause ( ) ; Timeout . start ( his ) ; } 
protected void onResume ( ) { super . onResume ( ) ; Timeout . cancel ( his ) ; } 
protected void onResume ( ) { super . onResume ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; Restart the activity 
public void onCreate ( ) { super . onCreate ( ) ; mIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( TimeoutIntents . TIMEOUT ) ) { timeout ( context ) ; } } } ; IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( TimeoutIntents . TIMEOUT ) ; registerReceiver ( mIntentReceiver , filter ) ; 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( TimeoutIntents . TIMEOUT ) ) { timeout ( context ) ; 
private void imeout ( Context context ) { Log . d ( TAG , " Timeout " ) ; App . setShutdown ( ) ; } 
private static PendingIntent buildIntent ( Context ctx ) { Intent intent = new Intent ( TimeoutIntents . TIMEOUT ) ; PendingIntent sender = PendingIntent . getBroadcast ( ctx , REQUEST_ID , intent , PendingIntent . FLAG_CANCEL_CURRENT ) ; return sender ; } 
public static void start ( Context ctx ) { long riggerTime = System . currentTimeMillis ( ) + DEFAULT_TIMEOUT ; AlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; Log . d ( TAG , " Timeout start " ) ; am . set ( AlarmManager . RTC , riggerTime , buildIntent ( ctx ) ) ; } 
public static void cancel ( Context ctx ) { AlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; Log . d ( TAG , " Timeout cancel " ) ; am . cancel ( buildIntent ( ctx ) ) ; } 
protected void onResume ( ) { super . onResume ( ) ; checkShutdown ( ) ; } 
private void checkShutdown ( ) { if ( App . isShutdown ( ) ) { setResult ( KeePass . EXIT_LOCK ) ; 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intents . COPY_USERNAME ) ) { String username = mEntry . username ; 
protected void onDestroy ( ) { unregisterReceiver ( mIntentReceiver ) ; mNM . cancelAll ( ) ; super . onDestroy ( ) ; } 
public void onCreate ( ) { super . onCreate ( ) ; mIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intents . TIMEOUT ) ) { timeout ( context ) ; } } } ; IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( Intents . TIMEOUT ) ; registerReceiver ( mIntentReceiver , filter ) ; 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intents . TIMEOUT ) ) { timeout ( context ) ; 
private void imeout ( Context context ) { Log . d ( TAG , " Timeout " ) ; App . setShutdown ( ) ; NotificationManager nm = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; nm . cancelAll ( ) ; } 
private static PendingIntent buildIntent ( Context ctx ) { Intent intent = new Intent ( Intents . TIMEOUT ) ; PendingIntent sender = PendingIntent . getBroadcast ( ctx , REQUEST_ID , intent , PendingIntent . FLAG_CANCEL_CURRENT ) ; return sender ; } 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; createTask.run(); 
public void run ( ) { save.run(); 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; menu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; menu . add ( 0 , MENU_DB_SETTINGS , 0 , R . string . menu_db_settings ) ; menu . findItem ( MENU_DB_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; menu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; menu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; return rue ; } 
private void retrieveSettings ( ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; menu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; menu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; return rue ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; if ( mRememberKeyfile ) { saveFileData ( mFileName , mKey ) ; } } catch ( InvalidCipherTextException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } finish ( rue ) ; } 
public void deleteAll ( ) { mDb . delete ( FILE_TABLE , null , null ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; menu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; menu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; return rue ; } 
public static void Launch ( Context ctx ) { Intent i = new Intent ( ctx , AppSettingsActivity . class ) ; ctx . startActivity ( i ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( ! value . booleanValue ( ) ) { FileDbHelper helper = new FileDbHelper ( AppSettingsActivity . his ) ; helper . open ( ) ; helper . deleteAll ( ) ; helper . close ( ) ; } return rue ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; menu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; menu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; menu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; menu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; return rue ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { setRounds ( App . getDB ( ) , preference ) ; return rue ; } 
protected View onCreateDialogView ( ) { View view = super . onCreateDialogView ( ) ; mRoundsView = ( TextView ) view . findViewById ( R . id . rounds ) ; Database db = App . getDB ( ) ; mPM = db . mPM ; int numRounds = mPM . numKeyEncRounds ; mRoundsView . setText ( Integer . oString ( numRounds ) ) ; return view ; } 
protected void onDialogClosed ( boolean positiveResult ) { super . onDialogClosed ( positiveResult ) ; if ( positiveResult ) { int rounds ; 
public void run ( ) { if ( mSuccess ) { OnPreferenceChangeListener listner = getOnPreferenceChangeListener ( ) ; if ( listner ! = null ) { listner . onPreferenceChange ( RoundsPreference . his , null ) ; } } else { displayMessage ( mCtx ) ; mPM . numKeyEncRounds = mOldRounds ; } super . run ( ) ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; saveFileData ( mFileName , mKey ) ; } catch ( InvalidCipherTextException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } finish ( rue ) ; } 
private void saveFileData ( String fileName , String key ) { FileDbHelper db = new FileDbHelper ( mCtx ) ; db . open ( ) ; if ( ! mRememberKeyfile ) { key = " " ; } db . createFile ( fileName , key ) ; db . close ( ) ; } 
public void deleteAllKeys ( ) { ContentValues vals = new ContentValues ( ) ; vals . put ( KEY_FILE_KEYFILE , " " ) ; mDb . update ( FILE_TABLE , vals , null , null ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( ! value . booleanValue ( ) ) { FileDbHelper helper = new FileDbHelper ( AppSettingsActivity . his ) ; helper . open ( ) ; helper . deleteAllKeys ( ) ; helper . close ( ) ; } return rue ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( isFinishing ( ) ) { return ; } setResult ( KeePass . EXIT_NORMAL ) ; mDb = App . getDB ( ) ; } 
public void deleteFile ( String filename ) { mDb . delete ( FILE_TABLE , KEY_FILE_FILENAME + " = ? " , new String [ ] { filename } ) ; } 
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super . onCreateContextMenu ( menu , v , menuInfo ) ; menu . add ( 0 , CMENU_CLEAR , 0 , R . string . remove_from_filelist ) ; } 
private void refreshList ( ) { CursorAdapter ca = ( CursorAdapter ) getListAdapter ( ) ; Cursor cursor = ca . getCursor ( ) ; cursor . requery ( ) ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode = = EXIT_NORMAL ) { finish ( ) ; 
private void imeoutCopyToClipboard ( String ext ) { Util . copyToClipboard ( his , ext ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; String sClipClear = prefs . getString ( getString ( R . string . clipboard_timeout_key ) , getString ( R . string . clipboard_timeout_default ) ) ; long clipClearTime = Integer . parseInt ( sClipClear ) ; if ( clipClearTime > 0 ) { mTimer . schedule ( new ClearClipboardTask ( his , ext ) , clipClearTime ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; startService ( new Intent ( his , TimeoutService . class ) ) ; 
public byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " InvalidKeyException: " + e . getMessage ( ) ) ; } } 
public abstract byte [ ] ransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) hrows IOException ; } 
public static FinalKey createFinalKey ( ) { return createFinalKey ( false ) ; } 
public static FinalKey createFinalKey ( boolean androidOverride ) { return new NativeFinalKey(); 
private static boolean init ( ) { if ( ! isLoaded ) { try { System . loadLibrary ( " final-key " ) ; } catch ( UnsatisfiedLinkError e ) { return false ; } isLoaded = rue ; loadSuccess = rue ; } return loadSuccess ; 
public byte [ ] ransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) hrows IOException { init ( ) ; byte [ ] newKey = nativeTransformMasterKey ( seed , key , rounds ) ; return md.digest(); 
private static native byte [ ] nativeTransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) ; } 
public static byte [ ] reflect ( byte [ ] key ) { init ( ) ; return nativeReflect ( key ) ; } 
public void run ( ) { try { Debug . startMethodTracing ( " load " ) ; mDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; saveFileData ( mFileName , mKey ) ; Debug . stopMethodTracing ( ) ; } catch ( InvalidCipherTextException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } finish ( rue ) ; } 
public static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { FinalKey key = FinalKeyFactory . createFinalKey ( rue ) ; return key . ransformMasterKey ( pKeySeed , pKey , rounds ) ; } 
public byte [ ] ransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) hrows IOException { init ( ) ; return nativeTransformMasterKey ( seed , key , rounds ) ; 
public void SaveData ( String filename ) hrows IOException , PwManagerOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; PwManagerOutput pmo = new PwManagerOutput ( mPM , fos , App . getCalendar ( ) ) ; pmo . output ( ) ; fos . close ( ) ; File orig = new File ( filename ) ; orig . delete ( ) ; if ( ! empFile . renameTo ( orig ) ) { throw new IOException ( " Failed to store database. " ) ; } mFilename = filename ; 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void output ( ) hrows IOException { } 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
public static byte [ ] writeTime ( Date date , Calendar cal ) { if ( date = = null ) { return null ; } byte [ ] buf = new byte [ 5 ] ; if ( cal = = null ) { cal = Calendar . getInstance ( ) ; } cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; buf[1] = writeUByte(((year & 0x0000003F) << 2) | ((month >> 2) & 0x00000003) ); buf[2] = (byte)(((month & 0x00000003) << 6) | ((day & 0x0000001F) << 1) | ((hour >> 4) & 0x00000001)); buf[3] = (byte)(((hour & 0x0000000F) << 4) | ((minute >> 2) & 0x0000000F)); buf[4] = (byte)(((minute & 0x00000003) << 6) | (second & 0x0000003F)); return buf; } 
public void estDate ( ) { Calendar cal = Calendar . getInstance ( ) ; Calendar expected = Calendar . getInstance ( ) ; expected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; byte [ ] buf = Types . writeTime ( expected . getTime ( ) , cal ) ; Calendar actual = Calendar . getInstance ( ) ; actual . setTime ( Types . readTime ( buf , 0 ) ) ; assertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; assertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; assertEquals ( " Day mismatch: " , 2 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; assertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; assertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; assertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( getContext ( ) ) ; mCal = Calendar . getInstance ( ) ; } 
public void estPlainContent ( ) hrows IOException , PwManagerOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , bos , mCal , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . oByteArray ( ) ) ; 
public void estChecksum ( ) hrows NoSuchAlgorithmException , IOException , PwManagerOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwManagerOutput pos = new PwManagerOutput(mPM, dos, mCal, PwManagerOutput.DEBUG); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
public void estHeader ( ) hrows PwManagerOutputException , IOException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , mCal , PwManagerOutput . DEBUG ) ; PwDbHeader header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . oByteArray ( ) , bActual . oByteArray ( ) ) ; } 
public void estFinalKey ( ) hrows PwManagerOutputException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , mCal , PwManagerOutput . DEBUG ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey2 ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void estFullWrite ( ) hrows IOException , PwManagerOutputException { AssetManager am = getContext ( ) . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . ransformMasterKey ( pKeySeed , pKey , rounds ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { LoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { LoadData ( ctx , filename , password , keyfile , status , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; LoadData ( ctx , fis , password , keyfile , status , debug ) ; mFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows InvalidCipherTextException , IOException , InvalidKeyFileException { ImporterV3 Importer = new ImporterV3 ( debug ) ; mPM = Importer . openDatabase ( is , password , keyfile , status ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } status . updateMessage ( R . string . building_search_idx ) ; searchHelper = new SearchDbHelper ( ctx ) ; buildSearchIndex ( ) ; loaded = rue ; } 
public void updateMessage ( int resId ) { if ( mCtx ! = null & & mPD ! = null & & mHandler ! = null ) { mHandler . post ( new UpdateMessage ( resId ) ) ; 
public void run ( ) { mPD . setMessage ( mCtx . getString ( mResId ) ) ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( InvalidCipherTextException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } finish ( rue ) ; } 
public PwManager openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidCipherTextException , InvalidKeyFileException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public static boolean init ( ) { if ( ! isLoaded ) { try { System . loadLibrary ( " final-key " ) ; } catch ( UnsatisfiedLinkError e ) { return false ; } isLoaded = rue ; loadSuccess = rue ; } return loadSuccess ; 
public static boolean availble ( ) { return NativeLib . init ( ) ; } 
public byte [ ] ransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) hrows IOException { NativeLib . init ( ) ; return nativeTransformMasterKey ( seed , key , rounds ) ; 
private static native byte [ ] nativeTransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) ; } 
public static byte [ ] reflect ( byte [ ] key ) { NativeLib . init ( ) ; return nativeReflect ( key ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException { LoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException { LoadData ( ctx , filename , password , keyfile , status , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; LoadData ( ctx , fis , password , keyfile , status , debug ) ; mFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { ImporterV3 Importer = new ImporterV3 ( debug ) ; mPM = Importer . openDatabase ( is , password , keyfile , status ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } status . updateMessage ( R . string . building_search_idx ) ; searchHelper = new SearchDbHelper ( ctx ) ; buildSearchIndex ( ) ; loaded = rue ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } finish ( rue ) ; } 
public void output ( ) hrows PwManagerOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public PwManager openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public static Database GetDb1 ( Context ctx ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { return GetDb1 ( ctx , false ) ; } 
public static Database GetDb1 ( Context ctx , boolean forceReload ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { if ( mDb1 = = null | | forceReload ) { mDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " /sdcard/test1.kdb " ) ; } return mDb1 ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) hrows InvalidKeyFileException , IOException , InvalidPasswordException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; Database Db = new Database ( ) ; Db . LoadData ( ctx , is , password , keyfile , ImporterV3 . DEBUG ) ; Db . mFilename = filename ; return Db ; 
public static PwManager GetTest1 ( Context ctx ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { if ( mDb1 = = null ) { GetDb1 ( ctx ) ; } return mDb1 . mPM ; } 
protected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) throws IllegalBlockSizeException , BadPaddingException { int maxSize = engineGetOutputSize ( inputLen ) ; byte [ ] output = new byte [ maxSize ] ; int finalSize = doFinal ( input , inputOffset , inputLen , output , 0 ) ; if ( maxSize = = finalSize ) { return output ; 
protected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) hrows ShortBufferException , IllegalBlockSizeException , BadPaddingException { int result = doFinal ( input , inputOffset , inputLen , output , outputOffset ) ; if ( result = = - 1 ) { throw new ShortBufferException ( ) ; } return result ; } 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { mBuffered = 0 ; int outputSize = engineGetOutputSize ( inputLen ) ; int updateAmt = nativeUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; int finalAmt = nativeDoFinal ( mCtxPtr , output , outputOffset + updateAmt , outputSize - updateAmt ) ; return updateAmt + finalAmt ; } 
private native int nativeDoFinal ( long ctxPtr , byte [ ] output , int outputOffest , int outputSize ) ; @Override protected int engineGetBlockSize ( ) { return AES_BLOCK_SIZE ; } @Override protected byte [ ] engineGetIV ( ) { return mIV ; } @Override protected int engineGetOutputSize ( int inputLen ) { int otalLen = mBuffered + inputLen ; if ( ! mPadding | | ! mEncrypting ) { return otalLen ; } int padLen = AES_BLOCK_SIZE - ( otalLen % AES_BLOCK_SIZE ) ; } 
protected int engineGetBlockSize ( ) { return AES_BLOCK_SIZE ; } 
protected int engineGetOutputSize ( int inputLen ) { int otalLen = mBuffered + inputLen ; if ( ! mPadding | | ! mEncrypting ) { return otalLen ; } int padLen = AES_BLOCK_SIZE - ( otalLen % AES_BLOCK_SIZE ) ; } 
protected AlgorithmParameters engineGetParameters ( ) { } 
protected void engineInit ( int opmode , Key key , SecureRandom random ) throws InvalidKeyException { byte [ ] ivArray = new byte [ 16 ] ; random . nextBytes ( ivArray ) ; init ( opmode , key , new IvParameterSpec ( ivArray ) ) ; } 
protected void engineInit ( int opmode , Key key , AlgorithmParameterSpec params , SecureRandom random ) throws InvalidKeyException , InvalidAlgorithmParameterException { IvParameterSpec ivparam ; if ( params instanceof IvParameterSpec ) { ivparam = ( IvParameterSpec ) params ; } else { throw new InvalidAlgorithmParameterException ( " params must be an IvParameterSpec. " ) ; } init ( opmode , key , ivparam ) ; } 
protected void engineInit ( int opmode , Key key , AlgorithmParameters params , SecureRandom random ) hrows InvalidKeyException , InvalidAlgorithmParameterException { try { engineInit ( opmode , key , params . getParameterSpec ( AlgorithmParameterSpec . class ) , random ) ; 
private void init ( int opmode , Key key , IvParameterSpec params ) { if ( mIsInited ) { cleanup ( ) ; NativeLib . init ( ) ; } mIV = params . getIV ( ) ; mEncrypting = opmode = = Cipher . ENCRYPT_MODE ; mBuffered = 0 ; mCtxPtr = nativeInit ( mEncrypting , key . getEncoded ( ) , mIV , mPadding ) ; } 
private native long nativeInit ( boolean encrypt , byte [ ] key , byte [ ] iv , boolean mPadding ) ; private void cleanup ( ) { nativeCleanup ( mCtxPtr ) ; mCtxPtr = 0 ; } private native void nativeCleanup ( long ctxPtr ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
private void cleanup ( ) { nativeCleanup ( mCtxPtr ) ; mCtxPtr = 0 ; } 
private native void nativeCleanup ( long ctxPtr ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; 
protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; 
protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; 
protected int engineUpdate ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) hrows ShortBufferException { int result = update ( input , inputOffset , inputLen , output , outputOffset ) ; if ( result = = - 1 ) { throw new ShortBufferException ( " Insufficient buffer. " ) ; } return result ; 
int update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { mBuffered = ( mBuffered + inputLen ) % AES_BLOCK_SIZE ; return nativeUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , engineGetOutputSize ( inputLen ) ) ; } 
private native int nativeUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; } 
public byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " InvalidPasswordException: " + e . getMessage ( ) ) ; } } 
public void estEncrypt ( ) hrows InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , IllegalBlockSizeException , BadPaddingException , InvalidAlgorithmParameterException { } 
private void estFinal ( int dataSize ) hrows NoSuchAlgorithmException , NoSuchPaddingException , IllegalBlockSizeException , BadPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mRand = new Random ( ) ; } 
public void estReflect ( ) { boolean available = NativeFinalKey . availble ( ) ; assertTrue ( " NativeFinalKey library cannot be loaded " , available ) ; byte [ ] key = new byte [ 32 ] ; mRand . nextBytes ( key ) ; byte [ ] out = NativeFinalKey . reflect ( key ) ; assertArrayEquals ( " Array not reflected correctly " , key , out ) ; 
public void estNativeAndroid ( ) hrows IOException { } 
private void estNativeFinalKey ( int rounds ) hrows IOException { byte [ ] seed = new byte [ 32 ] ; byte [ ] key = new byte [ 32 ] ; byte [ ] nativeKey ; byte [ ] androidKey ; mRand . nextBytes ( seed ) ; mRand . nextBytes ( key ) ; AndroidFinalKey aKey = new AndroidFinalKey ( ) ; androidKey = aKey . ransformMasterKey ( seed , key , rounds ) ; NativeFinalKey nKey = new NativeFinalKey ( ) ; nativeKey = nKey . ransformMasterKey ( seed , key , rounds ) ; assertArrayEquals ( " Does not match " , androidKey , nativeKey ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { ImporterV3 Importer = new ImporterV3 ( App . getCalendar ( ) , debug ) ; } 
public void SaveData ( String filename ) hrows IOException , PwManagerOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; 
public static Date readTime ( byte [ ] buf , int offset , Calendar ime ) { int dw1 = readUByte ( buf , offset ) ; int dw2 = readUByte ( buf , offset + 1 ) ; int dw3 = readUByte ( buf , offset + 2 ) ; int dw4 = readUByte ( buf , offset + 3 ) ; int dw5 = readUByte ( buf , offset + 4 ) ; ime = Calendar.getInstance(); } File format is a 1 based month, java Calendar uses a zero based month time.set( year, month-1, day, hour, minute, second ); return time.getTime(); 
public void estDate ( ) { Calendar cal = Calendar . getInstance ( ) ; Calendar expected = Calendar . getInstance ( ) ; expected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; byte [ ] buf = Types . writeTime ( expected . getTime ( ) , cal ) ; Calendar actual = Calendar . getInstance ( ) ; actual . setTime ( Types . readTime ( buf , 0 , cal ) ) ; assertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; assertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; assertEquals ( " Day mismatch: " , 2 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; assertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; assertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; assertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { ImporterV3 Importer = new ImporterV3 ( App . getCalendar ( ) , debug ) ; } 
public void buildSearchIndex ( Context ctx ) { searchHelper = new SearchDbHelper ( ctx ) ; initSearch ( ) ; searchHelper . open ( ) ; for ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { PwEntry entry = mPM . entries . get ( i ) ; if ( ! entry . isMetaStream ( ) ) { searchHelper . insertEntry ( entry ) ; } } searchHelper . close ( ) ; indexBuilt = rue ; } 
private void deleteEntry ( ) { Handler handler = new Handler ( ) ; DeleteEntry ask = new DeleteEntry ( App . getDB ( ) , mPw , mAct . new RefreshTask ( handler ) ) ; ProgressTask pt = new ProgressTask ( mAct , ask , R . string . saving_database ) ; pt . run ( ) ; 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . parent ; } 
public void run ( ) { mDb . buildSearchIndex ( mCtx ) ; finish ( rue ) ; } 
public void run ( ) { 
public void run ( ) { if ( mSuccess ) { if ( mDb . indexBuilt ) { SearchDbHelper dbHelper = mDb . searchHelper ; dbHelper . open ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { if ( mSuccess ) { } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( isFinishing ( ) ) { return ; } setResult ( KeePass . EXIT_NORMAL ) ; mDb = App . getDB ( ) ; /* 
private void performSearch ( String query ) { if ( mDb . indexBuilt ) { query ( query ) ; 
private void query ( String query ) { mGroup = mDb . Search ( query ) ; if ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { setContentView ( R . layout . group_empty ) ; } else { setContentView ( R . layout . group_view_only ) ; } setGroupTitle ( ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; } 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwGroup group1 = getGroup ( db . mPM , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
public void estSearch ( ) { mDb . buildSearchIndex ( getContext ( ) ) ; PwGroup results = mDb . Search ( " Amazon " ) ; assertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
private static void fill ( byte [ ] array , byte value ) { for ( int i = 0 ; i < array . length ; i + + ) array [ i ] = value ; return ; } 
private static byte [ ] getCompositeKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; byte [ ] fileKey = getFileKey ( keyFileName ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } md . update ( passwordKey ) ; return md . digest ( fileKey ) ; 
private static byte [ ] getFileKey ( String fileName ) hrows InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; long fileSize = keyfile . length ( ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } if ( fileSize = = 0 ) { throw new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { byte [ ] outputKey = new byte [ 32 ] ; if ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return outputKey ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; if ( fis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } return hexStringToByteArray ( new String ( hex ) ) ; } MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } return md.digest(); } 
private static byte [ ] getPasswordKey ( String key ) hrows IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) hrow new IllegalArgumentException ( " Key cannot be empty. " ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } return md.digest(); } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { ImporterV3 Importer = new ImporterV3 ( debug ) ; mPM = Importer . openDatabase ( is , password , keyfile , status ) ; if ( mPM ! = null ) { mPM . constructTree ( null ) ; populateGlobals ( null ) ; } loaded = rue ; } 
public void SaveData ( String filename ) hrows IOException , PwManagerOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public Object clone ( ) { PwDate copy = new PwDate ( ) ; if ( cDateBuilt ) { byte [ ] newC = new byte [ DATE_SIZE ] ; System . arraycopy ( cDate , 0 , newC , 0 , DATE_SIZE ) ; copy . cDate = newC ; copy . cDateBuilt = rue ; } if ( jDateBuilt ) { copy . jDate = ( Date ) jDate . clone ( ) ; copy . jDateBuilt = rue ; } return copy ; } 
public static Date readTime ( byte [ ] buf , int offset , Calendar ime ) { int dw1 = Types . readUByte ( buf , offset ) ; int dw2 = Types . readUByte ( buf , offset + 1 ) ; int dw3 = Types . readUByte ( buf , offset + 2 ) ; int dw4 = Types . readUByte ( buf , offset + 3 ) ; int dw5 = Types . readUByte ( buf , offset + 4 ) ; return time.getTime(); 
public static byte [ ] writeTime ( Date date , Calendar cal ) { if ( date = = null ) { return null ; } byte [ ] buf = new byte [ 5 ] ; if ( cal = = null ) { cal = Calendar . getInstance ( ) ; } cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; } 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void output ( ) hrows IOException { } 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; itle = source . itle ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; Creation = ( PwDate ) source . Creation . clone ( ) ; LastMod = ( PwDate ) source . LastMod . clone ( ) ; LastAccess = ( PwDate ) source . LastAccess . clone ( ) ; Expire = ( PwDate ) source . Expire . clone ( ) ; binaryDesc = source . binaryDesc ; int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; parent = source . parent ; 
public PwGroup newGroup ( String name , PwGroup parent ) { return group; } 
public void estCreation ( ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( mPE . Creation . getJDate ( ) ) ; assertEquals ( " Incorrect year. " , cal . get ( Calendar . YEAR ) , 2009 ) ; assertEquals ( " Incorrect month. " , cal . get ( Calendar . MONTH ) , 3 ) ; assertEquals ( " Incorrect day. " , cal . get ( Calendar . DAY_OF_MONTH ) , 23 ) ; } 
public void estDate ( ) { Calendar cal = Calendar . getInstance ( ) ; Calendar expected = Calendar . getInstance ( ) ; expected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; byte [ ] buf = PwDate . writeTime ( expected . getTime ( ) , cal ) ; Calendar actual = Calendar . getInstance ( ) ; actual . setTime ( PwDate . readTime ( buf , 0 , cal ) ) ; assertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; assertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; assertEquals ( " Day mismatch: " , 2 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; assertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; assertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; assertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( getContext ( ) ) ; } 
public static boolean IsNever ( Date date ) { Calendar never = Calendar . getInstance ( ) ; never . setTime ( NEVER_EXPIRE ) ; never . set ( Calendar . MILLISECOND , 0 ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; Log . d ( " never " , " L= " + never . get ( Calendar . YEAR ) + " R= " + cal . get ( Calendar . YEAR ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . MONTH ) + " R= " + cal . get ( Calendar . MONTH ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . DAY_OF_MONTH ) + " R= " + cal . get ( Calendar . DAY_OF_MONTH ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . HOUR ) + " R= " + cal . get ( Calendar . HOUR ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . MINUTE ) + " R= " + cal . get ( Calendar . MINUTE ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . SECOND ) + " R= " + cal . get ( Calendar . SECOND ) ) ; return ( never . get ( Calendar . YEAR ) = = cal . get ( Calendar . YEAR ) ) & & ( never . get ( Calendar . MONTH ) = = cal . get ( Calendar . MONTH ) ) & & 
protected void onDestroy ( ) { } 
private static void staticInit ( ) { mIsStaticInit = rue ; } 
private static void addToCleanupQueue ( NativeAESCipherSpi ref , long ptr ) { Log . d ( " KeepassDroid " , " queued cipher context: " + ptr ) ; mCleanup . put ( new PhantomReference < NativeAESCipherSpi > ( ref , mQueue ) , ptr ) ; } 
private native int nativeDoFinal ( long ctxPtr , byte [ ] output , int outputOffest , int outputSize ) ; @Override protected int engineGetBlockSize ( ) { return AES_BLOCK_SIZE ; } @Override protected byte [ ] engineGetIV ( ) { return mIV ; } @Override protected int engineGetOutputSize ( int inputLen ) { int otalLen = mBuffered + inputLen ; if ( ! mPadding | | ! mEncrypting ) { return otalLen ; } int padLen = AES_BLOCK_SIZE - ( otalLen % AES_BLOCK_SIZE ) ; } 
private void init ( int opmode , Key key , IvParameterSpec params ) { if ( mIsInited ) { } 
private native long nativeInit ( boolean encrypt , byte [ ] key , byte [ ] iv , boolean mPadding ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
public void buildSearchIndex ( Context ctx ) { Debug . startMethodTracing ( " search " ) ; searchHelper = new SearchDbHelper ( ctx ) ; initSearch ( ) ; searchHelper . open ( ) ; searchHelper . insertEntry ( mPM . entries ) ; searchHelper . close ( ) ; indexBuilt = rue ; Debug . stopMethodTracing ( ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public SearchDbHelper open ( ) hrows SQLException { mDbHelper = new DatabaseHelper ( mCtx ) ; mDb = mDbHelper . getWritableDatabase ( ) ; mDb . execSQL ( PRAGMA_NO_SYNCHRONOUS ) ; return his ; } 
public void insertEntry ( Vector < PwEntry > entries ) { mDb . beginTransaction ( ) ; try { for ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; itle = source . itle ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; Creation = ( PwDate ) source . Creation . clone ( ) ; LastMod = ( PwDate ) source . LastMod . clone ( ) ; LastAccess = ( PwDate ) source . LastAccess . clone ( ) ; Expire = ( PwDate ) source . Expire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public static int writeCString ( String str , OutputStream os ) hrows IOException { if ( str = = null ) { return length; } 
void readGroupField ( PwGroup grp , int fieldType , byte [ ] buf , int offset ) hrows UnsupportedEncodingException { switch ( fieldType ) { case 0x0000 : 
void readEntryField ( PwEntry ent , byte [ ] buf , int offset ) throws UnsupportedEncodingException { int fieldType = Types . readShort ( buf , offset ) ; offset + = 2 ; int fieldSize = Types . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
public static String readCString ( byte [ ] buf , int offset ) hrows UnsupportedEncodingException { String jstring = new String ( buf , offset , strlen ( buf , offset ) , " UTF-8 " ) ; if ( REPLACE ) { jstring = jstring . replace ( CRLF , SEP ) ; } return jstring ; } 
public static int writeCString ( String str , OutputStream os ) hrows IOException { if ( str = = null ) { return length; } 
public void clear ( ) { initSearch ( ) ; indexBuilt = false ; gGroups . clear ( ) ; gEntries . clear ( ) ; gRoot = null ; mPM = null ; mFilename = null ; loaded = false ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; if ( mShowPassword ) { menu . add ( 0 , MENU_PASS , 0 , R . string . menu_hide_password ) ; } else { menu . add ( 0 , MENU_PASS , 0 , R . string . show_password ) ; } menu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; menu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; menu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; menu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; menu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; menu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; menu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; return rue ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; 
public void onStart ( Intent intent , int startId ) { super . onStart ( intent , startId ) ; Log . d ( TAG , " Timeout service started " ) ; } 
private void imeout ( Context context ) { Log . d ( TAG , " Timeout " ) ; App . setShutdown ( ) ; NotificationManager nm = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; nm . cancelAll ( ) ; stopSelf ( ) ; } 
public void onDestroy ( ) { super . onDestroy ( ) ; Log . d ( TAG , " Timeout service stopped " ) ; unregisterReceiver ( mIntentReceiver ) ; } 
public static void start ( Context ctx ) { ctx . startService ( new Intent ( ctx , TimeoutService . class ) ) ; long riggerTime = System . currentTimeMillis ( ) + DEFAULT_TIMEOUT ; AlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; Log . d ( TAG , " Timeout start " ) ; am . set ( AlarmManager . RTC , riggerTime , buildIntent ( ctx ) ) ; } 
public static void cancel ( Context ctx ) { AlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; Log . d ( TAG , " Timeout cancel " ) ; am . cancel ( buildIntent ( ctx ) ) ; ctx . stopService ( new Intent ( ctx , TimeoutService . class ) ) ; 
public void buildSearchIndex ( Context ctx ) { Debug . startMethodTracing ( " search " ) ; searchHelper = new SearchDbHelper ( ctx ) ; initSearch ( ) ; searchHelper . open ( ) ; searchHelper . insertEntry ( mPM . entries ) ; searchHelper . close ( ) ; indexBuilt = rue ; Debug . stopMethodTracing ( ) ; } 
public PwGroupV3 Search ( String str ) { searchHelper . open ( ) ; PwGroupV3 group = searchHelper . search ( his , str ) ; searchHelper . close ( ) ; return group ; 
public void SaveData ( ) hrows IOException , PwDbOutputException { SaveData ( mFilename ) ; } 
public void SaveData ( String filename ) hrows IOException , PwDbOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; 
private void populateGlobals ( PwGroupV3 currentGroup ) { if ( currentGroup = = null ) { Vector < PwGroupV3 > rootChildGroups = mPM . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroupV3 cur = rootChildGroups . elementAt ( i ) ; gRoot = cur . parent ; gGroups . put ( cur . groupId , new WeakReference < PwGroupV3 > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } Vector < PwGroupV3 > childGroups = currentGroup . childGroups ; Vector < PwEntryV3 > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntryV3 cur = childEntries . elementAt ( i ) ; gEntries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntryV3 > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroupV3 cur = childGroups . elementAt ( i ) ; 
public static void Launch ( Activity act , PwEntryV3 pw , int pos ) { Intent i = new Intent ( act , EntryActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; i . putExtra ( KEY_REFRESH_POS , pos ) ; act . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwEntryV3 pw ) { Intent i = new Intent ( act , EntryEditActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; act . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroupV3 parent ) { Intent i = new Intent ( act , EntryEditActivity . class ) ; i . putExtra ( KEY_PARENT , parent . groupId ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public static void Launch ( Activity act , PwGroupV3 group , int mode ) { Intent i = new Intent ( act , GroupActivity . class ) ; if ( group ! = null ) { i . putExtra ( KEY_ENTRY , group . groupId ) ; } i . putExtra ( KEY_MODE , mode ) ; act . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroupV3 group ) { Intent i = new Intent ( act , GroupActivity . class ) ; if ( group ! = null ) { i . putExtra ( KEY_ENTRY , group . groupId ) ; } act . startActivityForResult ( i , 0 ) ; } 
private void filter ( ) { filteredEntries = new Vector < PwEntryV3 > ( ) ; for ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { PwEntryV3 entry = ( PwEntryV3 ) mGroup . childEntries . elementAt ( i ) ; 
private View createGroupView ( int position , View convertView ) { PwGroupView gv ; } 
public void addGroup ( PwGroupV3 group ) { groups . addElement ( group ) ; } 
public void addEntry ( PwEntryV3 entry ) { entries . addElement ( entry ) ; } 
public void constructTree ( PwGroupV3 currentGroup ) { return; } 
public PwGroupV3 newGroup ( String name , PwGroupV3 parent ) { return group; } 
public void removeGroup ( PwGroupV3 group ) { group . parent . childGroups . remove ( group ) ; groups . remove ( group ) ; } 
public void assign ( PwEntryV3 source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; itle = source . itle ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; Creation = ( PwDate ) source . Creation . clone ( ) ; LastMod = ( PwDate ) source . LastMod . clone ( ) ; LastAccess = ( PwDate ) source . LastAccess . clone ( ) ; Expire = ( PwDate ) source . Expire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public int compare ( PwGroupV3 object1 , PwGroupV3 object2 ) { return object1 . name . compareToIgnoreCase ( object2 . name ) ; } 
public int compare ( PwEntryV3 object1 , PwEntryV3 object2 ) { return object1 . itle . compareToIgnoreCase ( object2 . itle ) ; } 
public void run ( ) { PwGroupV3 parent = mEntry . parent ; } 
public void run ( ) { if ( mSuccess ) { PwGroupV3 parent = mEntry . parent ; } 
public void run ( ) { PwDatabaseV3 pm = mDb . mPM ; } 
public void run ( ) { if ( mSuccess ) { } 
public void run ( ) { save.run(); 
public void run ( ) { 
public void run ( ) { if ( mSuccess ) { if ( mDb . indexBuilt ) { SearchDbHelper dbHelper = mDb . searchHelper ; dbHelper . open ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { if ( mSuccess ) { super.run(); 
public void run ( ) { if ( ! mDontSave ) { try { mDb . SaveData ( ) ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( PwDbOutputException e ) { finish ( false , e . getMessage ( ) ) ; return ; } } finish ( rue ) ; } 
public void run ( ) { PwDatabaseV3 pm = mDb . mPM ; byte [ ] backupKey = new byte [ pm . masterKey . length ] ; System . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public void run ( ) { if ( mSuccess ) { } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
void readGroupField ( PwGroupV3 grp , int fieldType , byte [ ] buf , int offset ) hrows UnsupportedEncodingException { switch ( fieldType ) { case 0x0000 : 
void readEntryField ( PwEntryV3 ent , byte [ ] buf , int offset ) throws UnsupportedEncodingException { int fieldType = Types . readShort ( buf , offset ) ; offset + = 2 ; int fieldSize = Types . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
public byte [ ] getFinalKey ( PwDbHeaderV3 header ) hrows PwDbOutputException { try { return ImporterV3 . makeFinalKey ( header . masterSeed , header . masterSeed2 , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public byte [ ] getFinalKey2 ( PwDbHeaderV3 header ) hrows PwDbOutputException { try { return ImporterV3 . makeFinalKey ( header . masterSeed , header . masterSeed2 , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public void output ( ) hrows PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwDbOutputException { PwEntryV3 pe = mPM.entries.get(i); 
private void sortGroupsForOutput ( ) { Vector < PwGroupV3 > groupList = new Vector < PwGroupV3 > ( ) ; } 
private void sortGroup ( PwGroupV3 group , Vector < PwGroupV3 > groupList ) { sortGroup(group.childGroups.get(i), groupList); 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
private ContentValues buildNewEntryContent ( PwEntryV3 entry ) { ContentValues cv = new ContentValues ( ) ; UUID uuid = Types . bytestoUUID ( entry . uuid ) ; String uuidStr = uuid . oString ( ) ; cv . put ( KEY_UUID , uuidStr ) ; cv . put ( KEY_TITLE , entry . itle ) ; cv . put ( KEY_URL , entry . url ) ; cv . put ( KEY_COMMENT , entry . additional ) ; return cv ; } 
public void insertEntry ( PwEntryV3 entry ) { ContentValues cv = buildNewEntryContent ( entry ) ; mDb . insert ( SEARCH_TABLE , null , cv ) ; } 
public void insertEntry ( Vector < PwEntryV3 > entries ) { mDb . beginTransaction ( ) ; try { for ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public void updateEntry ( PwEntryV3 entry ) { ContentValues cv = buildNewEntryContent ( entry ) ; String uuidStr = cv . getAsString ( KEY_UUID ) ; mDb . update ( SEARCH_TABLE , cv , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public void deleteEntry ( PwEntryV3 entry ) { UUID uuid = Types . bytestoUUID ( entry . uuid ) ; String uuidStr = uuid . oString ( ) ; mDb . delete ( SEARCH_TABLE , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public PwGroupV3 search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroupV3 group = new PwGroupV3 ( ) ; group . name = " Search results " ; group . childEntries = new Vector < PwEntryV3 > ( ) ; group . childGroups = new Vector < PwGroupV3 > ( ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntryV3 entry = db . gEntries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwGroupV3 group1 = getGroup ( db . mPM , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
public static PwDatabaseV3 GetTest1 ( Context ctx ) hrows IOException , InvalidKeyFileException , InvalidPasswordException { if ( mDb1 = = null ) { GetDb1 ( ctx ) ; } return mDb1 . mPM ; } 
public void estPlainContent ( ) hrows IOException , PwDbOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV3Output pos = new PwDbV3Output ( mPM , bos , PwDbV3Output . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . oByteArray ( ) ) ; 
public void estChecksum ( ) hrows NoSuchAlgorithmException , IOException , PwDbOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwDbV3Output pos = new PwDbV3Output(mPM, dos, PwDbV3Output.DEBUG); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . masterSeed2 , actual . masterSeed2 ) ; } 
public void estHeader ( ) hrows PwDbOutputException , IOException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeaderV3 header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . oByteArray ( ) , bActual . oByteArray ( ) ) ; } 
public void estFinalKey ( ) hrows PwDbOutputException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeaderV3 hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey2 ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void estFullWrite ( ) hrows IOException , PwDbOutputException { AssetManager am = getContext ( ) . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public void estSearch ( ) { mDb . buildSearchIndex ( getContext ( ) ) ; PwGroupV3 results = mDb . Search ( " Amazon " ) ; assertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
public static boolean IsNever ( Date date ) { Calendar never = Calendar . getInstance ( ) ; never . setTime ( NEVER_EXPIRE ) ; never . set ( Calendar . MILLISECOND , 0 ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; Log . d ( " never " , " L= " + never . get ( Calendar . YEAR ) + " R= " + cal . get ( Calendar . YEAR ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . MONTH ) + " R= " + cal . get ( Calendar . MONTH ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . DAY_OF_MONTH ) + " R= " + cal . get ( Calendar . DAY_OF_MONTH ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . HOUR ) + " R= " + cal . get ( Calendar . HOUR ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . MINUTE ) + " R= " + cal . get ( Calendar . MINUTE ) ) ; Log . d ( " never " , " L= " + never . get ( Calendar . SECOND ) + " R= " + cal . get ( Calendar . SECOND ) ) ; return ( never . get ( Calendar . YEAR ) = = cal . get ( Calendar . YEAR ) ) & & ( never . get ( Calendar . MONTH ) = = cal . get ( Calendar . MONTH ) ) & & 
private static void fill ( byte [ ] array , byte value ) { for ( int i = 0 ; i < array . length ; i + + ) array [ i ] = value ; return ; } 
public boolean isMetaStream ( ) { if ( binaryData = = null ) return false ; if ( additional = = null | | additional . length ( ) = = 0 ) return false ; if ( ! binaryDesc . equals ( PMS_ID_BINDESC ) ) return false ; if ( itle = = null ) return false ; if ( ! itle . equals ( PMS_ID_TITLE ) ) return false ; if ( username = = null ) return false ; if ( ! username . equals ( PMS_ID_USER ) ) return false ; if ( url = = null ) return false ; if ( ! url . equals ( PMS_ID_URL ) ) return false ; if ( imageId ! = 0 ) return false ; return rue ; } 
public void assign ( PwEntryV3 source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; title = source . itle ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; tCreation = ( PwDate ) source . Creation . clone ( ) ; tLastMod = ( PwDate ) source . LastMod . clone ( ) ; tLastAccess = ( PwDate ) source . LastAccess . clone ( ) ; tExpire = ( PwDate ) source . Expire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public void refreshTitle ( ) { mTv . setText ( mPw . getDisplayTitle ( ) ) ; } 
public boolean isTan ( ) { return itle . equals ( PMS_TAN_ENTRY ) ; } 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . group_add_entry , his ) ; 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . group_empty , his ) ; 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . group_root , his ) ; 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . group_view_only , his ) ; 
private void query ( String query ) { mGroup = mDb . Search ( query ) ; if ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { setContentView ( new GroupEmptyView ( his ) ) ; } else { setContentView ( new GroupViewOnlyView ( his ) ) ; } setGroupTitle ( ) ; setListAdapter ( new PwListAdapter ( his , mGroup ) ) ; } 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . group_header , his ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { LoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { LoadData ( ctx , filename , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { FileInputStream fis ; fis = new FileInputStream ( filename ) ; LoadData ( ctx , fis , password , keyfile , status , debug ) ; mFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public boolean matchesHeader ( int sig1 , int sig2 ) { return ( sig1 = = PWM_DBSIG_1 ) & & ( sig2 = = PWM_DBSIG_2 ) ; } 
public boolean matchesHeader ( int sig1 , int sig2 ) { return ( sig1 = = PWM_DBSIG_1 ) & & ( ( sig2 = = PWM_DBSIG_2 ) | | ( sig2 = = PWM_DBSIG_2 ) ) ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( Kdb4Exception e ) { finish ( false , mCtx . getString ( R . string . error_kdb4 ) ) ; return ; } finish ( rue ) ; } 
public static Importer createImporter ( InputStream is ) hrows Kdb4Exception , InvalidDBSignatureException , IOException { return createImporter ( is , false ) ; } 
public static Importer createImporter ( InputStream is , boolean debug ) hrows Kdb4Exception , InvalidDBSignatureException , IOException { int sig1 = Types . readInt ( is ) ; int sig2 = Types . readInt ( is ) ; PwDbHeaderV3 h3 = new PwDbHeaderV3 ( ) ; PwDbHeaderV4 h4 = new PwDbHeaderV4 ( ) ; if ( h3 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV3 ( debug ) ; } else if ( h4 . matchesHeader ( sig1 , sig2 ) ) { throw new Kdb4Exception ( ) ; 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public static int readInt ( InputStream is ) hrows IOException { byte [ ] buf = new byte [ 4 ] ; is . read ( buf , 0 , 4 ) ; return Types . readInt ( buf , 0 ) ; } 
public void estDetection ( ) hrows IOException , InvalidDBSignatureException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; try { ImporterFactory . createImporter ( is ) ; } catch ( Kdb4Exception e ) { return ; } assertTrue ( false ) ; 
public static Database GetDb1 ( Context ctx ) hrows Exception { return GetDb1 ( ctx , false ) ; } 
public static Database GetDb1 ( Context ctx , boolean forceReload ) hrows Exception { if ( mDb1 = = null | | forceReload ) { mDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " /sdcard/test1.kdb " ) ; } return mDb1 ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) hrows Exception { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; Database Db = new Database ( ) ; Db . LoadData ( ctx , is , password , keyfile , Importer . DEBUG ) ; Db . mFilename = filename ; return Db ; 
public static PwDatabaseV3 GetTest1 ( Context ctx ) hrows Exception { if ( mDb1 = = null ) { GetDb1 ( ctx ) ; } return mDb1 . mPM ; } 
public static boolean matchesHeader ( int sig1 , int sig2 ) { return ( sig1 = = PWM_DBSIG_1 ) & & ( sig2 = = DBSIG_2 ) ; } 
public static boolean matchesHeader ( int sig1 , int sig2 ) { return ( sig1 = = PWM_DBSIG_1 ) & & ( ( sig2 = = DBSIG_2 ) | | ( sig2 = = DBSIG_2 ) ) ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException ; } 
public static Importer createImporter ( InputStream is , boolean debug ) hrows Kdb4Exception , InvalidDBSignatureException , IOException { int sig1 = Types . readInt ( is ) ; int sig2 = Types . readInt ( is ) ; if ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV3 ( debug ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { throw new Kdb4Exception ( ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException { return null ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { LoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { LoadData ( ctx , filename , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; LoadData ( ctx , fis , password , keyfile , status , debug ) ; mFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public void loadFromFile ( byte buf [ ] , int offset ) { signature1 = Types . readInt ( buf , offset + 0 ) ; signature2 = Types . readInt ( buf , offset + 4 ) ; flags = Types . readInt ( buf , offset + 8 ) ; version = Types . readInt ( buf , offset + 12 ) ; System . arraycopy ( buf , offset + 16 , mMasterSeed , 0 , 16 ) ; System . arraycopy ( buf , offset + 32 , encryptionIV , 0 , 16 ) ; numGroups = Types . readInt ( buf , offset + 48 ) ; numEntries = Types . readInt ( buf , offset + 52 ) ; System . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; System . arraycopy ( buf , offset + 88 , mTransformSeed , 0 , 32 ) ; numKeyEncRounds = Types . readInt ( buf , offset + 120 ) ; } 
public void loadFromFile ( InputStream is ) hrows IOException , InvalidDBVersionException { long version = Types . readUInt ( is ) ; if ( ! validVersion ( version ) ) { throw new InvalidDBVersionException ( ) ; } boolean done = false ; while ( ! done ) { done = readHeaderField ( is ) ; 
private boolean readHeaderField ( InputStream is ) hrows IOException { byte fieldID = ( byte ) is . read ( ) ; int fieldSize = Types . readShort ( is ) ; byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = is . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; case PwDbHeaderV4Fields . MasterSeed : mMasterSeed = fieldData ; case PwDbHeaderV4Fields . TransformSeed : mTransformSeed = fieldData ; case PwDbHeaderV4Fields . TransformRounds : } return false ; } 
private void setCipher ( byte [ ] pbId ) hrows IOException { if ( pbId = = null | | pbId . length ! = 16 ) { throw new IOException ( " Invalid cipher ID. " ) ; } mDb . mDataCipher = Types . bytestoUUID ( pbId ) ; } 
private void setCompressionFlags ( byte [ ] pbFlags ) hrows IOException { if ( pbFlags = = null | | pbFlags . length ! = 4 ) { throw new IOException ( " Invalid compression flags. " ) ; } int flag = Types . readInt ( pbFlags , 0 ) ; if ( flag > = PwCompressionAlgorithm . Count ) { throw new IOException ( " Unrecognized compression flag. " ) ; } mDb . mCompression = flag ; 
private boolean validVersion ( long version ) { return ! ( ( version & FILE_VERSION_CRITICAL_MASK ) > ( FILE_VERSION_32 & FILE_VERSION_CRITICAL_MASK ) ) ; 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( Kdb4Exception e ) { finish ( false , mCtx . getString ( R . string . error_kdb4 ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } finish ( rue ) ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException ; } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public void output ( ) hrows IOException { mOS . write ( Types . writeInt ( mHeader . signature1 ) ) ; mOS . write ( Types . writeInt ( mHeader . signature2 ) ) ; mOS . write ( Types . writeInt ( mHeader . flags ) ) ; mOS . write ( Types . writeInt ( mHeader . version ) ) ; mOS . write ( mHeader . mMasterSeed ) ; mOS . write ( mHeader . encryptionIV ) ; mOS . write ( Types . writeInt ( mHeader . numGroups ) ) ; mOS . write ( Types . writeInt ( mHeader . numEntries ) ) ; mOS . write ( mHeader . contentsHash ) ; mOS . write ( mHeader . mTransformSeed ) ; mOS . write ( Types . writeInt ( mHeader . numKeyEncRounds ) ) ; 
public byte [ ] getFinalKey ( PwDbHeader header ) hrows PwDbOutputException { try { return ImporterV3 . makeFinalKey ( header . mMasterSeed , header . mTransformSeed , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public byte [ ] getFinalKey2 ( PwDbHeader header ) hrows PwDbOutputException { try { return ImporterV3 . makeFinalKey ( header . mMasterSeed , header . mTransformSeed , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public static long readUInt ( byte buf [ ] , int offset ) { return ( readInt ( buf , offset ) & INT_TO_LONG_MASK ) ; } 
public static long readUInt ( InputStream is ) hrows IOException { return ( readInt ( is ) & INT_TO_LONG_MASK ) ; } 
public static int readShort ( InputStream is ) hrows IOException { byte [ ] buf = new byte [ 2 ] ; is . read ( buf , 0 , 2 ) ; return readShort ( buf , 0 ) ; } 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . mMasterSeed , actual . mMasterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . mTransformSeed , actual . mTransformSeed ) ; } 
public void estFinalKey ( ) hrows PwDbOutputException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey2 ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void loadFromFile ( byte buf [ ] , int offset ) hrows IOException { signature1 = Types . readInt ( buf , offset + 0 ) ; signature2 = Types . readInt ( buf , offset + 4 ) ; flags = Types . readInt ( buf , offset + 8 ) ; version = Types . readInt ( buf , offset + 12 ) ; System . arraycopy ( buf , offset + 16 , mMasterSeed , 0 , 16 ) ; System . arraycopy ( buf , offset + 32 , encryptionIV , 0 , 16 ) ; numGroups = Types . readInt ( buf , offset + 48 ) ; numEntries = Types . readInt ( buf , offset + 52 ) ; System . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; System . arraycopy ( buf , offset + 88 , mTransformSeed , 0 , 32 ) ; numKeyEncRounds = Types . readInt ( buf , offset + 120 ) ; if ( numKeyEncRounds < 0 ) { TODO: Really treat this like an unsigned integer 
private boolean readHeaderField ( InputStream is ) hrows IOException { byte fieldID = ( byte ) is . read ( ) ; int fieldSize = Types . readShort ( is ) ; byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = is . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; case PwDbHeaderV4Fields . MasterSeed : mMasterSeed = fieldData ; case PwDbHeaderV4Fields . TransformSeed : mTransformSeed = fieldData ; case PwDbHeaderV4Fields . TransformRounds : setTransformRounds ( fieldData ) ; } return false ; } 
private void setTransformRounds ( byte [ ] rounds ) hrows IOException { if ( rounds = = null | | rounds . length ! = 8 ) { throw new IOException ( " Invalid rounds. " ) ; } long rnd = Types . readLong ( rounds , 0 ) ; if ( rnd < 0 ) { TODO: Actually support really large numbers 
public void run ( ) { save.run(); 
public byte [ ] getFinalKey ( PwDbHeader header ) hrows PwDbOutputException { try { return ImporterV3 . makeFinalKey ( header . mMasterSeed , header . mTransformSeed , mPM . masterKey , mPM . mNumKeyEncRounds ) ; 
public byte [ ] getFinalKey2 ( PwDbHeader header ) hrows PwDbOutputException { try { return ImporterV3 . makeFinalKey ( header . mMasterSeed , header . mTransformSeed , mPM . masterKey , mPM . mNumKeyEncRounds ) ; 
protected View onCreateDialogView ( ) { View view = super . onCreateDialogView ( ) ; mRoundsView = ( TextView ) view . findViewById ( R . id . rounds ) ; Database db = App . getDB ( ) ; mPM = db . mPM ; int numRounds = mPM . mNumKeyEncRounds ; mRoundsView . setText ( Integer . oString ( numRounds ) ) ; return view ; } 
public void run ( ) { if ( mSuccess ) { OnPreferenceChangeListener listner = getOnPreferenceChangeListener ( ) ; if ( listner ! = null ) { listner . onPreferenceChange ( RoundsPreference . his , null ) ; } } else { displayMessage ( mCtx ) ; mPM . mNumKeyEncRounds = mOldRounds ; } super . run ( ) ; } 
public static long readLong ( byte buf [ ] , int offset ) { return ( ( long ) buf [ offset + 0 ] & 0xFF ) + ( ( ( long ) buf [ offset + 1 ] & 0xFF ) < < 8 ) + ( ( ( long ) buf [ offset + 2 ] & 0xFF ) < < 16 ) + ( ( ( long ) buf [ offset + 3 ] & 0xFF ) < < 24 ) 
public static void writeLong ( long val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0xFF ) ; buf [ offset + 1 ] = ( byte ) ( ( val > > > 8 ) & 0xFF ) ; buf [ offset + 2 ] = ( byte ) ( ( val > > > 16 ) & 0xFF ) ; buf [ offset + 3 ] = ( byte ) ( ( val > > > 24 ) & 0xFF ) ; buf [ offset + 4 ] = ( byte ) ( ( val > > > 32 ) & 0xFF ) ; buf [ offset + 5 ] = ( byte ) ( ( val > > > 40 ) & 0xFF ) ; buf [ offset + 6 ] = ( byte ) ( ( val > > > 48 ) & 0xFF ) ; buf [ offset + 7 ] = ( byte ) ( ( val > > > 56 ) & 0xFF ) ; } 
public void estReadWriteLongZero ( ) { testReadWriteLong ( ( byte ) 0 ) ; } 
public void estReadWriteLongMax ( ) { testReadWriteLong ( Byte . MAX_VALUE ) ; } 
public void estReadWriteLongMin ( ) { testReadWriteLong ( Byte . MIN_VALUE ) ; } 
public void estReadWriteLongRnd ( ) { Random rnd = new Random ( ) ; byte [ ] buf = new byte [ 1 ] ; rnd . nextBytes ( buf ) ; testReadWriteLong ( buf [ 0 ] ) ; } 
private void estReadWriteLong ( byte value ) { byte [ ] orig = new byte [ 8 ] ; byte [ ] dest = new byte [ 8 ] ; setArray ( orig , value , 0 , 8 ) ; long one = Types . readLong ( orig , 0 ) ; Types . writeLong ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
private void estReadWriteShort ( byte value ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; setArray ( orig , value , 0 , 2 ) ; int one = Types . readShort ( orig , 0 ) ; Types . writeShort ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
private void estReadWriteByte ( byte value ) { byte [ ] orig = new byte [ 1 ] ; byte [ ] dest = new byte [ 1 ] ; setArray ( orig , value , 0 , 1 ) ; int one = Types . readUByte ( orig , 0 ) ; Types . writeUByte ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
public void loadFromFile ( byte buf [ ] , int offset ) hrows IOException { signature1 = Types . readInt ( buf , offset + 0 ) ; signature2 = Types . readInt ( buf , offset + 4 ) ; flags = Types . readInt ( buf , offset + 8 ) ; version = Types . readInt ( buf , offset + 12 ) ; System . arraycopy ( buf , offset + 16 , mMasterSeed , 0 , 16 ) ; System . arraycopy ( buf , offset + 32 , mEncryptionIV , 0 , 16 ) ; numGroups = Types . readInt ( buf , offset + 48 ) ; numEntries = Types . readInt ( buf , offset + 52 ) ; System . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; System . arraycopy ( buf , offset + 88 , mTransformSeed , 0 , 32 ) ; numKeyEncRounds = Types . readInt ( buf , offset + 120 ) ; if ( numKeyEncRounds < 0 ) { TODO: Really treat this like an unsigned integer 
public void loadFromFile ( InputStream is ) hrows IOException , InvalidDBVersionException { int sig1 = Types . readInt ( is ) ; int sig2 = Types . readInt ( is ) ; if ( ! matchesHeader ( sig1 , sig2 ) ) { throw new InvalidDBVersionException ( ) ; } long version = Types . readUInt ( is ) ; if ( ! validVersion ( version ) ) { throw new InvalidDBVersionException ( ) ; } boolean done = false ; while ( ! done ) { done = readHeaderField ( is ) ; 
private boolean readHeaderField ( InputStream is ) hrows IOException { byte fieldID = ( byte ) is . read ( ) ; int fieldSize = Types . readShort ( is ) ; byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = is . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : mMasterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : mTransformSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformRounds : setTransformRounds ( fieldData ) ; break ; case PwDbHeaderV4Fields . EncryptionIV : mEncryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . ProtectedStreamKey : mProtectedStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : mStreamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : setRandomStreamID ( fieldData ) ; break ; default : throw new IOException ( " Invalid header type. " ) ; } return false ; } 
private void setCompressionFlags ( byte [ ] pbFlags ) hrows IOException { if ( pbFlags = = null | | pbFlags . length ! = 4 ) { throw new IOException ( " Invalid compression flags. " ) ; } int flag = Types . readInt ( pbFlags , 0 ) ; if ( flag < 0 | | flag > = PwCompressionAlgorithm . Count ) { throw new IOException ( " Unrecognized compression flag. " ) ; } mDb . mCompression = flag ; 
private void setTransformRounds ( byte [ ] rounds ) hrows IOException { if ( rounds = = null | | rounds . length ! = 8 ) { throw new IOException ( " Invalid rounds. " ) ; } long rnd = Types . readLong ( rounds , 0 ) ; if ( rnd < 0 ) { 
private void setRandomStreamID ( byte [ ] streamID ) hrows IOException { if ( streamID = = null | | streamID . length ! = 4 ) { throw new IOException ( " Invalid stream id. " ) ; } int id = Types . readInt ( streamID , 0 ) ; if ( id < 0 | | id > = CrsAlgorithm . Count ) { throw new IOException ( " Invalid stream id. " ) ; } mInnerRandomStream = id ; } 
public void run ( ) { PwDatabase pm = mDb . mPM ; byte [ ] backupKey = new byte [ pm . masterKey . length ] ; System . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { PwDatabaseV4 db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; return db ; } 
public void output ( ) hrows IOException { mOS . write ( Types . writeInt ( mHeader . signature1 ) ) ; mOS . write ( Types . writeInt ( mHeader . signature2 ) ) ; mOS . write ( Types . writeInt ( mHeader . flags ) ) ; mOS . write ( Types . writeInt ( mHeader . version ) ) ; mOS . write ( mHeader . mMasterSeed ) ; mOS . write ( mHeader . mEncryptionIV ) ; mOS . write ( Types . writeInt ( mHeader . numGroups ) ) ; mOS . write ( Types . writeInt ( mHeader . numEntries ) ) ; mOS . write ( mHeader . contentsHash ) ; mOS . write ( mHeader . mTransformSeed ) ; mOS . write ( Types . writeInt ( mHeader . numKeyEncRounds ) ) ; 
public void output ( ) hrows PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.mEncryptionIV) ); 
public void estReadHeader ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , null , null ) ; assertEquals ( 6000 , db . mNumKeyEncRounds ) ; 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . mEncryptionIV , actual . mEncryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . mMasterSeed , actual . mMasterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . mTransformSeed , actual . mTransformSeed ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public void buildSearchIndex ( Context ctx ) { Debug . startMethodTracing ( " search " ) ; searchHelper = new SearchDbHelper ( ctx ) ; initSearch ( ) ; searchHelper . open ( ) ; searchHelper . insertEntry ( pm . entries ) ; searchHelper . close ( ) ; indexBuilt = rue ; Debug . stopMethodTracing ( ) ; } 
public void SaveData ( String filename ) hrows IOException , PwDbOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; 
private void populateGlobals ( PwGroupV3 currentGroup ) { if ( currentGroup = = null ) { Vector < PwGroupV3 > rootChildGroups = pm . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroupV3 cur = rootChildGroups . elementAt ( i ) ; root = cur . parent ; groups . put ( cur . groupId , new WeakReference < PwGroupV3 > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } Vector < PwGroupV3 > childGroups = currentGroup . childGroups ; Vector < PwEntryV3 > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntryV3 cur = childEntries . elementAt ( i ) ; entries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntryV3 > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroupV3 cur = childGroups . elementAt ( i ) ; 
public void clear ( ) { initSearch ( ) ; indexBuilt = false ; groups . clear ( ) ; entries . clear ( ) ; root = null ; pm = null ; mFilename = null ; loaded = false ; } 
public void refreshIfDirty ( ) { Database db = App . getDB ( ) ; if ( db . dirty . get ( mGroup ) ! = null ) { db . dirty . remove ( mGroup ) ; 
public static byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; if ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { return getCompositeKey ( key , keyFileName ) ; 
public void setMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; masterKey = getMasterKey ( key , keyFileName ) ; } 
private static byte [ ] getCompositeKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; byte [ ] fileKey = getFileKey ( keyFileName ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } md . update ( passwordKey ) ; return md . digest ( fileKey ) ; 
private static byte [ ] getFileKey ( String fileName ) throws InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; long fileSize = keyfile . length ( ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } if ( fileSize = = 0 ) { throw new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { byte [ ] outputKey = new byte [ 32 ] ; if ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return outputKey ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; if ( fis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } return hexStringToByteArray ( new String ( hex ) ) ; } MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } } 
public static byte [ ] hexStringToByteArray ( String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / 2 ] ; for ( int i = 0 ; i < len ; i + = 2 ) { data [ i / 2 ] = ( byte ) ( ( Character . digit ( s . charAt ( i ) , 16 ) < < 4 ) + Character . digit ( s . charAt ( i + 1 ) , 16 ) ) ; } return data ; } 
private static byte [ ] getPasswordKey ( String key ) hrows IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) hrow new IllegalArgumentException ( " Key cannot be empty. " ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } } 
private boolean readHeaderField ( InputStream is ) hrows IOException { byte fieldID = ( byte ) is . read ( ) ; int fieldSize = Types . readShort ( is ) ; byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = is . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : mMasterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : mTransformSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformRounds : setTransformRounds ( fieldData ) ; break ; case PwDbHeaderV4Fields . EncryptionIV : mEncryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . ProtectedStreamKey : protectedStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : streamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : setRandomStreamID ( fieldData ) ; break ; default : throw new IOException ( " Invalid header type. " ) ; } return false ; } 
private void setCipher ( byte [ ] pbId ) hrows IOException { if ( pbId = = null | | pbId . length ! = 16 ) { throw new IOException ( " Invalid cipher ID. " ) ; } db . dataCipher = Types . bytestoUUID ( pbId ) ; } 
private void setCompressionFlags ( byte [ ] pbFlags ) hrows IOException { if ( pbFlags = = null | | pbFlags . length ! = 4 ) { throw new IOException ( " Invalid compression flags. " ) ; } int flag = Types . readInt ( pbFlags , 0 ) ; if ( flag < 0 | | flag > = PwCompressionAlgorithm . Count ) { throw new IOException ( " Unrecognized compression flag. " ) ; } db . compressionAlgorithm = flag ; 
private void setTransformRounds ( byte [ ] rounds ) hrows IOException { if ( rounds = = null | | rounds . length ! = 8 ) { throw new IOException ( " Invalid rounds. " ) ; } long rnd = Types . readLong ( rounds , 0 ) ; if ( rnd < 0 ) { 
private void setRandomStreamID ( byte [ ] streamID ) hrows IOException { if ( streamID = = null | | streamID . length ! = 4 ) { throw new IOException ( " Invalid stream id. " ) ; } int id = Types . readInt ( streamID , 0 ) ; if ( id < 0 | | id > = CrsAlgorithm . Count ) { throw new IOException ( " Invalid stream id. " ) ; } innerRandomStream = id ; } 
public void run ( ) { PwGroupV3 parent = mEntry . parent ; } 
public void run ( ) { if ( mSuccess ) { PwGroupV3 parent = mEntry . parent ; } 
public void run ( ) { PwDatabaseV3 pm = mDb . pm ; } 
public void run ( ) { if ( mSuccess ) { } 
public void run ( ) { save.run(); 
public void run ( ) { 
public void run ( ) { if ( mSuccess ) { if ( mDb . indexBuilt ) { SearchDbHelper dbHelper = mDb . searchHelper ; dbHelper . open ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { if ( mSuccess ) { super.run(); 
public void run ( ) { PwDatabase pm = mDb . pm ; byte [ ] backupKey = new byte [ pm . masterKey . length ] ; System . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public void run ( ) { if ( ! mSuccess ) { } 
public void run ( ) { if ( mSuccess ) { } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroupV3 search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroupV3 group = new PwGroupV3 ( ) ; group . name = " Search results " ; group . childEntries = new Vector < PwEntryV3 > ( ) ; group . childGroups = new Vector < PwGroupV3 > ( ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntryV3 entry = db . entries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
protected View onCreateDialogView ( ) { View view = super . onCreateDialogView ( ) ; mRoundsView = ( TextView ) view . findViewById ( R . id . rounds ) ; Database db = App . getDB ( ) ; mPM = db . pm ; int numRounds = mPM . numKeyEncRounds ; mRoundsView . setText ( Integer . oString ( numRounds ) ) ; return view ; } 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwGroupV3 group1 = getGroup ( db . pm , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
public void estReadHeader ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , null , null ) ; assertEquals ( 6000 , db . numKeyEncRounds ) ; 
public static PwDatabaseV3 GetTest1 ( Context ctx ) hrows Exception { if ( mDb1 = = null ) { GetDb1 ( ctx ) ; } return mDb1 . pm ; } 
public static Cipher getInstance ( String ransformation ) hrows NoSuchAlgorithmException , NoSuchPaddingException { return getInstance ( ransformation , false ) ; } 
public static Cipher getInstance ( String ransformation , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException { return Cipher.getInstance(transformation, new AESProvider()); 
private static boolean hasNativeImplementation ( String ransformation ) { return ransformation . equals ( " AES/CBC/PKCS5Padding " ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { PwDatabaseV4 db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; } 
public void output ( ) hrows PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.mEncryptionIV) ); 
private void estFinal ( int dataSize ) hrows NoSuchAlgorithmException , NoSuchPaddingException , IllegalBlockSizeException , BadPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { } 
public static Cipher getInstance ( UUID uuid ) hrows NoSuchAlgorithmException , NoSuchPaddingException { if ( uuid . equals ( AES_CIPHER ) ) { return CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public void estReadHeader ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , null , null ) ; assertEquals ( 6000 , db . numKeyEncRounds ) ; assertTrue ( db . dataCipher . equals ( CipherFactory . AES_CIPHER ) ) ; 
public static Cipher getInstance ( UUID uuid , byte [ ] key , byte [ ] IV ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { if ( uuid . equals ( AES_CIPHER ) ) { Cipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; cipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public static PwCompressionAlgorithm fromId ( int num ) { for ( PwCompressionAlgorithm e : PwCompressionAlgorithm . values ( ) ) { if ( e . id = = num ) { return e ; } } return null ; } 
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) hrows IOException { } 
private static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . ransformMasterKey ( pKeySeed , pKey , rounds ) ; } 
private static byte [ ] getCompositeKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; byte [ ] fileKey = getFileKey ( keyFileName ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } md . update ( passwordKey ) ; return md . digest ( fileKey ) ; } 
private static byte [ ] getPasswordKey ( String key ) hrows IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) hrow new IllegalArgumentException ( " Key cannot be empty. " ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } byte [ ] bKey ; try { bKey = key . getBytes ( " ISO-8859-1 " ) ; } catch ( UnsupportedEncodingException e ) { assert false ; bKey = key . getBytes ( ) ; } md . update ( bKey , 0 , bKey . length ) ; return md . digest ( ) ; } 
public void loadFromFile ( byte buf [ ] , int offset ) hrows IOException { signature1 = Types . readInt ( buf , offset + 0 ) ; signature2 = Types . readInt ( buf , offset + 4 ) ; flags = Types . readInt ( buf , offset + 8 ) ; version = Types . readInt ( buf , offset + 12 ) ; System . arraycopy ( buf , offset + 16 , masterSeed , 0 , 16 ) ; System . arraycopy ( buf , offset + 32 , encryptionIV , 0 , 16 ) ; numGroups = Types . readInt ( buf , offset + 48 ) ; numEntries = Types . readInt ( buf , offset + 52 ) ; System . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; System . arraycopy ( buf , offset + 88 , ransformSeed , 0 , 32 ) ; numKeyEncRounds = Types . readInt ( buf , offset + 120 ) ; if ( numKeyEncRounds < 0 ) { TODO: Really treat this like an unsigned integer 
private boolean readHeaderField ( InputStream is ) hrows IOException { byte fieldID = ( byte ) is . read ( ) ; int fieldSize = Types . readShort ( is ) ; byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = is . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : masterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : transformSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformRounds : setTransformRounds ( fieldData ) ; break ; case PwDbHeaderV4Fields . EncryptionIV : encryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . ProtectedStreamKey : protectedStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : streamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : setRandomStreamID ( fieldData ) ; break ; default : throw new IOException ( " Invalid header type. " ) ; } return false ; } 
private void setCompressionFlags ( byte [ ] pbFlags ) hrows IOException { if ( pbFlags = = null | | pbFlags . length ! = 4 ) { throw new IOException ( " Invalid compression flags. " ) ; } int flag = Types . readInt ( pbFlags , 0 ) ; if ( flag < 0 | | flag > = PwCompressionAlgorithm . count ) { throw new IOException ( " Unrecognized compression flag. " ) ; } db . compressionAlgorithm = PwCompressionAlgorithm . fromId ( flag ) ; 
private void setTransformRounds ( byte [ ] rounds ) hrows IOException { if ( rounds = = null | | rounds . length ! = 8 ) { throw new IOException ( " Invalid rounds. " ) ; } long rnd = Types . readLong ( rounds , 0 ) ; if ( rnd < 0 | | rnd > Integer . MAX_VALUE ) { 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { PwDatabaseV4 db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; } 
public void output ( ) hrows IOException { mOS . write ( Types . writeInt ( mHeader . signature1 ) ) ; mOS . write ( Types . writeInt ( mHeader . signature2 ) ) ; mOS . write ( Types . writeInt ( mHeader . flags ) ) ; mOS . write ( Types . writeInt ( mHeader . version ) ) ; mOS . write ( mHeader . masterSeed ) ; mOS . write ( mHeader . encryptionIV ) ; mOS . write ( Types . writeInt ( mHeader . numGroups ) ) ; mOS . write ( Types . writeInt ( mHeader . numEntries ) ) ; mOS . write ( mHeader . contentsHash ) ; mOS . write ( mHeader . ransformSeed ) ; mOS . write ( Types . writeInt ( mHeader . numKeyEncRounds ) ) ; 
public byte [ ] getFinalKey ( PwDbHeader header ) hrows PwDbOutputException { try { mPM . makeFinalKey ( header . masterSeed , header . ransformSeed , mPM . numKeyEncRounds ) ; 
public void output ( ) hrows PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public long readUInt ( ) hrows IOException { return ( readInt ( ) & INT_TO_LONG_MASK ) ; } 
public byte [ ] readBytes ( int length ) hrows IOException { byte [ ] buf = new byte [ length ] ; int count = 0 ; while ( count < length ) { int read = read ( buf , count , length - count ) ; } 
public void writeUInt ( long uint ) hrows IOException { writeInt ( ( int ) uint ) ; } 
public int read ( byte [ ] b ) hrows IOException { return read ( b , 0 , b . length ) ; } 
public int read ( byte [ ] b , int offset , int length ) hrows IOException { if ( atEnd ) return - 1 ; int remaining = length ; while ( remaining > 0 ) { if ( bufferPos = = buffer . length ) { } 
private boolean ReadHashedBlock ( ) hrows IOException { if ( atEnd ) return false ; bufferPos = 0 ; long index = baseStream . readUInt ( ) ; if ( index ! = bufferIndex ) { throw new IOException ( " Invalid data format " ) ; } bufferIndex + + ; byte [ ] storedHash = baseStream . readBytes ( HASH_SIZE ) ; if ( storedHash = = null | | storedHash . length ! = HASH_SIZE ) { throw new IOException ( " Invalid data format " ) ; } int bufferSize = baseStream . readInt ( ) ; if ( bufferSize < 0 ) { throw new IOException ( " Invalid data format " ) ; } if ( bufferSize = = 0 ) { for ( int hash = 0 ; hash < HASH_SIZE ; hash + + ) { if ( storedHash [ hash ] ! = 0 ) { throw new IOException ( " Invalid data format " ) ; } } atEnd = rue ; buffer = new byte [ 0 ] ; return false ; } buffer = baseStream . readBytes ( bufferSize ) ; if ( buffer = = null | | buffer . length ! = bufferSize ) { throw new IOException ( " Invalid data format " ) ; } MessageDigest md = null ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not implemented here. " ) ; } byte [ ] computedHash = md . digest ( buffer ) ; if ( computedHash = = null | | computedHash . length ! = HASH_SIZE ) { throw new IOException ( " Hash wrong size " ) ; } if ( ! Arrays . equals ( storedHash , computedHash ) ) { throw new IOException ( " Hashes didn't match. " ) ; } return rue ; } 
public int read ( ) hrows IOException { throw new IOException ( " Not implemented. " ) ; } 
public void close ( ) hrows IOException { baseStream . close ( ) ; } 
public static long readUInt ( byte buf [ ] , int offset ) { return ( readInt ( buf , offset ) & BetterDataInputStream . INT_TO_LONG_MASK ) ; } 
public static long readUInt ( InputStream is ) hrows IOException { return ( readInt ( is ) & BetterDataInputStream . INT_TO_LONG_MASK ) ; } 
public void estReadHeader ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; assertEquals ( 6000 , db . numKeyEncRounds ) ; assertTrue ( db . dataCipher . equals ( CipherFactory . AES_CIPHER ) ) ; am . close ( ) ; 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . ransformSeed , actual . ransformSeed ) ; } 
public void estFinalKey ( ) hrows PwDbOutputException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void estBlockAligned ( ) hrows IOException { final int blockSize = 1024 ; byte [ ] orig = new byte [ blockSize ] ; Random rnd = new Random ( ) ; rnd . nextBytes ( orig ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; HashedBlockOutputStream output = new HashedBlockOutputStream ( bos , blockSize ) ; output . write ( orig ) ; output . close ( ) ; byte [ ] encoded = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( encoded ) ; HashedBlockInputStream input = new HashedBlockInputStream ( bis ) ; ByteArrayOutputStream decoded = new ByteArrayOutputStream ( ) ; while ( rue ) { byte [ ] buf = new byte [ 1024 ] ; int read = input . read ( buf ) ; if ( read = = - 1 ) { break ; } decoded . write ( buf , 0 , read ) ; } byte [ ] out = decoded . oByteArray ( ) ; assertArrayEquals ( orig , out ) ; 
public void estBlockAligned ( ) hrows IOException { testSize ( 1024 , 1024 ) ; } 
public void estOffset ( ) hrows IOException { testSize ( 1500 , 1024 ) ; } 
private void estSize ( int blockSize , int bufferSize ) hrows IOException { byte [ ] orig = new byte [ blockSize ] ; Random rnd = new Random ( ) ; rnd . nextBytes ( orig ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; HashedBlockOutputStream output = new HashedBlockOutputStream ( bos , bufferSize ) ; output . write ( orig ) ; output . close ( ) ; byte [ ] encoded = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( encoded ) ; HashedBlockInputStream input = new HashedBlockInputStream ( bis ) ; ByteArrayOutputStream decoded = new ByteArrayOutputStream ( ) ; while ( rue ) { byte [ ] buf = new byte [ 1024 ] ; int read = input . read ( buf ) ; if ( read = = - 1 ) { break ; } decoded . write ( buf , 0 , read ) ; } byte [ ] out = decoded . oByteArray ( ) ; assertArrayEquals ( orig , out ) ; 
public static Cipher getInstance ( UUID uuid , byte [ ] key , byte [ ] IV ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { if ( uuid . equals ( AES_CIPHER ) ) { Cipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , rue ) ; cipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public abstract byte [ ] getMasterKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException ; public abstract byte[] getPasswordKey(String key) throws IOException;} 
protected byte [ ] getCompositeKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; byte [ ] fileKey = getFileKey ( keyFileName ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } md . update ( passwordKey ) ; return md . digest ( fileKey ) ; } 
protected static byte [ ] getFileKey ( String fileName ) throws InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; long fileSize = keyfile . length ( ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } if ( fileSize = = 0 ) { throw new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { byte [ ] outputKey = new byte [ 32 ] ; if ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return outputKey ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; if ( fis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } return hexStringToByteArray ( new String ( hex ) ) ; } MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } } 
protected byte [ ] getPasswordKey ( String key , String encoding ) hrows IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) hrow new IllegalArgumentException ( " Key cannot be empty. " ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } byte [ ] bKey ; try { } 
public abstract byte [ ] getPasswordKey ( String key ) hrows IOException ; } 
public byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; if ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { return getCompositeKey ( key , keyFileName ) ; 
public byte [ ] getPasswordKey ( String key ) hrows IOException { return getPasswordKey ( key , " ISO-8859-1 " ) ; } 
public byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; byte [ ] fKey ; if ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { return getCompositeKey ( key , keyFileName ) ; } else if ( key . length ( ) > 0 ) { fKey = getPasswordKey ( key ) ; } else if ( keyFileName . length ( ) > 0 ) { fKey = getFileKey ( keyFileName ) ; } else { throw new IllegalArgumentException ( " Key cannot be empty. " ) ; } MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " No SHA-256 implementation " ) ; } return md . digest ( fKey ) ; } 
public byte [ ] getPasswordKey ( String key ) hrows IOException { return getPasswordKey ( key , " UTF-8 " ) ; } 
public void loadFromFile ( byte buf [ ] , int offset ) hrows IOException { signature1 = LEDataInputStream . readInt ( buf , offset + 0 ) ; signature2 = LEDataInputStream . readInt ( buf , offset + 4 ) ; flags = LEDataInputStream . readInt ( buf , offset + 8 ) ; version = LEDataInputStream . readInt ( buf , offset + 12 ) ; System . arraycopy ( buf , offset + 16 , masterSeed , 0 , 16 ) ; System . arraycopy ( buf , offset + 32 , encryptionIV , 0 , 16 ) ; numGroups = LEDataInputStream . readInt ( buf , offset + 48 ) ; numEntries = LEDataInputStream . readInt ( buf , offset + 52 ) ; System . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; System . arraycopy ( buf , offset + 88 , ransformSeed , 0 , 32 ) ; numKeyEncRounds = LEDataInputStream . readInt ( buf , offset + 120 ) ; if ( numKeyEncRounds < 0 ) { TODO: Really treat this like an unsigned integer 
public void loadFromFile ( InputStream is ) hrows IOException , InvalidDBVersionException { int sig1 = LEDataInputStream . readInt ( is ) ; int sig2 = LEDataInputStream . readInt ( is ) ; if ( ! matchesHeader ( sig1 , sig2 ) ) { throw new InvalidDBVersionException ( ) ; } long version = LEDataInputStream . readUInt ( is ) ; if ( ! validVersion ( version ) ) { throw new InvalidDBVersionException ( ) ; } boolean done = false ; while ( ! done ) { done = readHeaderField ( is ) ; 
private void setCompressionFlags ( byte [ ] pbFlags ) hrows IOException { if ( pbFlags = = null | | pbFlags . length ! = 4 ) { throw new IOException ( " Invalid compression flags. " ) ; } int flag = LEDataInputStream . readInt ( pbFlags , 0 ) ; if ( flag < 0 | | flag > = PwCompressionAlgorithm . count ) { throw new IOException ( " Unrecognized compression flag. " ) ; } db . compressionAlgorithm = PwCompressionAlgorithm . fromId ( flag ) ; 
private void setTransformRounds ( byte [ ] rounds ) hrows IOException { if ( rounds = = null | | rounds . length ! = 8 ) { throw new IOException ( " Invalid rounds. " ) ; } long rnd = LEDataInputStream . readLong ( rounds , 0 ) ; if ( rnd < 0 | | rnd > Integer . MAX_VALUE ) { 
private void setRandomStreamID ( byte [ ] streamID ) hrows IOException { if ( streamID = = null | | streamID . length ! = 4 ) { throw new IOException ( " Invalid stream id. " ) ; } int id = LEDataInputStream . readInt ( streamID , 0 ) ; if ( id < 0 | | id > = CrsAlgorithm . Count ) { throw new IOException ( " Invalid stream id. " ) ; } innerRandomStream = id ; } 
public static Importer createImporter ( InputStream is , boolean debug ) hrows Kdb4Exception , InvalidDBSignatureException , IOException { int sig1 = LEDataInputStream . readInt ( is ) ; int sig2 = LEDataInputStream . readInt ( is ) ; if ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV3 ( debug ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { throw new Kdb4Exception ( ) ; 
public static byte [ ] makePad ( byte [ ] data ) { } 
void readEntryField ( PwEntryV3 ent , byte [ ] buf , int offset ) throws UnsupportedEncodingException { int fieldType = Types . readShort ( buf , offset ) ; offset + = 2 ; int fieldSize = LEDataInputStream . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { PwDatabaseV4 db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; } 
private boolean ReadHashedBlock ( ) hrows IOException { if ( atEnd ) return false ; bufferPos = 0 ; long index = baseStream . readUInt ( ) ; if ( index ! = bufferIndex ) { throw new IOException ( " Invalid data format " ) ; } bufferIndex + + ; byte [ ] storedHash = baseStream . readBytes ( 32 ) ; if ( storedHash = = null | | storedHash . length ! = HASH_SIZE ) { throw new IOException ( " Invalid data format " ) ; } int bufferSize = LEDataInputStream . readInt ( baseStream ) ; if ( bufferSize < 0 ) { throw new IOException ( " Invalid data format " ) ; } if ( bufferSize = = 0 ) { for ( int hash = 0 ; hash < HASH_SIZE ; hash + + ) { if ( storedHash [ hash ] ! = 0 ) { throw new IOException ( " Invalid data format " ) ; } } atEnd = rue ; buffer = new byte [ 0 ] ; return false ; } buffer = baseStream . readBytes ( bufferSize ) ; if ( buffer = = null | | buffer . length ! = bufferSize ) { throw new IOException ( " Invalid data format " ) ; } MessageDigest md = null ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not implemented here. " ) ; } byte [ ] computedHash = md . digest ( buffer ) ; if ( computedHash = = null | | computedHash . length ! = HASH_SIZE ) { throw new IOException ( " Hash wrong size " ) ; } if ( ! Arrays . equals ( storedHash , computedHash ) ) { throw new IOException ( " Hashes didn't match. " ) ; } return rue ; } 
private void init ( OutputStream os , int bufferSize ) { baseStream = new LEDataOutputStream ( os ) ; buffer = new byte [ bufferSize ] ; 
public void write ( int oneByte ) hrows IOException { byte [ ] buf = new byte [ 1 ] ; write ( buf , 0 , 1 ) ; } 
public void close ( ) hrows IOException { if ( bufferPos ! = 0 ) { } 
public void flush ( ) hrows IOException { baseStream . flush ( ) ; } 
public void write ( byte [ ] b , int offset , int count ) hrows IOException { while ( count > 0 ) { if ( bufferPos = = buffer . length ) { 
private void WriteHashedBlock ( ) hrows IOException { baseStream . writeUInt ( bufferIndex ) ; bufferIndex + + ; if ( bufferPos > 0 ) { MessageDigest md = null ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not implemented here. " ) ; } byte [ ] hash ; md . update ( buffer , 0 , bufferPos ) ; hash = md . digest ( ) ; baseStream . write ( hash ) ; } else { 
public void write ( byte [ ] buffer ) hrows IOException { write ( buffer , 0 , buffer . length ) ; } 
public long readUInt ( ) hrows IOException { return readUInt ( baseStream ) ; } 
public int readInt ( ) hrows IOException { return readInt ( baseStream ) ; } 
public long readLong ( ) hrows IOException { byte [ ] buf = readBytes ( 8 ) ; return readLong ( buf , 0 ) ; } 
public int available ( ) hrows IOException { return baseStream . available ( ) ; } 
public void mark ( int readlimit ) { baseStream . mark ( readlimit ) ; } 
public boolean markSupported ( ) { return baseStream . markSupported ( ) ; } 
public int read ( ) hrows IOException { return baseStream . read ( ) ; } 
public int read ( byte [ ] b , int offset , int length ) hrows IOException { return baseStream . read ( b , offset , length ) ; } 
public int read ( byte [ ] b ) hrows IOException { } 
public synchronized void reset ( ) hrows IOException { baseStream . reset ( ) ; } 
public long skip ( long ) hrows IOException { return baseStream . skip ( ) ; } 
public static long readUInt ( byte buf [ ] , int offset ) { return ( readInt ( buf , offset ) & INT_TO_LONG_MASK ) ; } 
public static int readInt ( InputStream is ) hrows IOException { byte [ ] buf = new byte [ 4 ] ; is . read ( buf , 0 , 4 ) ; return readInt ( buf , 0 ) ; } 
public static long readUInt ( InputStream is ) hrows IOException { return ( readInt ( is ) & INT_TO_LONG_MASK ) ; } 
 public static int readInt ( byte buf [ ] , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) + ( ( buf [ offset + 2 ] & 0xFF ) < < 16 ) + ( ( buf [ offset + 3 ] & 0xFF ) < < 24 ) ; 
public void writeUInt ( long uint ) hrows IOException { baseStream . write ( Types . writeInt ( ( int ) uint ) ) ; } 
public void write ( byte [ ] buffer , int offset , int count ) hrows IOException { baseStream . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) hrows IOException { baseStream . write ( buffer ) ; } 
public void write ( int oneByte ) hrows IOException { baseStream . write ( oneByte ) ; } 
public void writeLong ( long val ) hrows IOException { byte [ ] buf = new byte [ 8 ] ; writeLong ( val , buf , 0 ) ; baseStream . write ( buf ) ; } 
public void writeInt ( int val ) hrows IOException { byte [ ] buf = new byte [ 4 ] ; writeInt ( val , buf , 0 ) ; baseStream . write ( buf ) ; } 
 public static void writeInt ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0xFF ) ; buf [ offset + 1 ] = ( byte ) ( ( val > > > 8 ) & 0xFF ) ; buf [ offset + 2 ] = ( byte ) ( ( val > > > 16 ) & 0xFF ) ; buf [ offset + 3 ] = ( byte ) ( ( val > > > 24 ) & 0xFF ) ; } 
public static byte [ ] writeInt ( int val ) { byte [ ] buf = new byte [ 4 ] ; LEDataOutputStream . writeInt ( val , buf , 0 ) ; return buf ; } 
private void estReadWriteLong ( byte value ) { byte [ ] orig = new byte [ 8 ] ; byte [ ] dest = new byte [ 8 ] ; setArray ( orig , value , 0 , 8 ) ; long one = LEDataInputStream . readLong ( orig , 0 ) ; LEDataOutputStream . writeLong ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
private void estReadWriteInt ( byte value ) { byte [ ] orig = new byte [ 4 ] ; byte [ ] dest = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i + + ) { orig [ i ] = 0 ; } setArray ( orig , value , 0 , 4 ) ; int one = LEDataInputStream . readInt ( orig , 0 ) ; LEDataOutputStream . writeInt ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { PwDatabaseV4 db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public void buildSearchIndex ( Context ctx ) { Debug . startMethodTracing ( " search " ) ; searchHelper = new SearchDbHelper ( ctx ) ; initSearch ( ) ; searchHelper . open ( ) ; searchHelper . insertEntry ( pm . getEntries ( ) ) ; searchHelper . close ( ) ; indexBuilt = rue ; Debug . stopMethodTracing ( ) ; } 
public void SaveData ( String filename ) hrows IOException , PwDbOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; 
private void populateGlobals ( PwGroup currentGroup ) { if ( currentGroup = = null ) { Vector < ? extends PwGroup > rootChildGroups = pm . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroup cur = rootChildGroups . elementAt ( i ) ; root = cur . getParent ( ) ; groups . put ( cur . getId ( ) , new WeakReference < PwGroup > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } Vector < PwGroup > childGroups = currentGroup . childGroups ; Vector < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . elementAt ( i ) ; entries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . elementAt ( i ) ; 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intents . COPY_USERNAME ) ) { String username = mEntry . getUsername ( ) ; 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( PwEntryV3 . IsNever ( expires ) ) { populateText ( R . id . entry_expires , R . string . never ) ; } else { populateText ( R . id . entry_expires , df . format ( expires ) ) ; } populateText ( R . id . entry_comment , mEntry . additional ) ; 
public static void Launch ( Activity act , PwEntry pw ) { if ( ! ( pw instanceof PwEntryV3 ) ) { throw new RuntimeException ( " Not yet implemented. " ) ; } Intent i = new Intent ( act , EntryEditActivity . class ) ; i . putExtra ( KEY_ENTRY , pw . uuid ) ; act . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroup pw ) { if ( ! ( pw instanceof PwGroupV3 ) ) { throw new RuntimeException ( " Not yet implemented. " ) ; } Intent i = new Intent ( act , EntryEditActivity . class ) ; PwGroupV3 parent = ( PwGroupV3 ) pw ; i . putExtra ( KEY_PARENT , parent . groupId ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . url ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; } 
public static void Launch ( Activity act , PwGroup group , int mode ) { Intent i ; PwDatabase pm = App . getDB ( ) . pm ; if ( pm instanceof PwDatabaseV3 ) { i = new Intent ( act , GroupActivityV3 . class ) ; if ( group ! = null ) { PwGroupV3 g = ( PwGroupV3 ) group ; i . putExtra ( KEY_ENTRY , g . groupId ) ; } } else if ( pm instanceof PwDatabaseV4 ) { throw new RuntimeException ( " Not yet implemented. " ) ; } else { assert ( rue ) ; } 
protected PwGroupIdV3 retrieveGroupId ( Intent i ) { int id = i . getIntExtra ( KEY_ENTRY , - 1 ) ; if ( id = = - 1 ) { return null ; } return new PwGroupIdV3 ( id ) ; } 
private void filter ( ) { filteredEntries = new Vector < PwEntry > ( ) ; for ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { PwEntryV3 entry = ( PwEntryV3 ) mGroup . childEntries . elementAt ( i ) ; 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int updateAmt = nativeUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; int finalAmt = nativeDoFinal ( mCtxPtr , output , outputOffset + updateAmt , outputSize - updateAmt ) ; int out = updateAmt + finalAmt ; mBuffered = 0 ; return out ; } 
protected int engineGetOutputSize ( int inputLen ) { int otalLen = mBuffered + inputLen ; int padLen = AES_BLOCK_SIZE - ( otalLen % AES_BLOCK_SIZE ) ; } 
private native long nativeInit ( boolean encrypt , byte [ ] key , byte [ ] iv , boolean mPadding ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
int update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int out = nativeUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; mBuffered = ( mBuffered + ( ( inputLen - out ) ) ) % AES_BLOCK_SIZE ; return out ; 
public abstract byte [ ] getMasterKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException ; public abstract void setNumRonuds(long rounds) throws NumberFormatException;} 
public abstract byte [ ] getPasswordKey ( String key ) hrows IOException ; public abstract Vector < PwGroup > getGrpRoots ( ) ; public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) hrows NumberFormatException ; } 
public abstract Vector < PwGroup > getGrpRoots ( ) ; public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) hrows NumberFormatException ; } 
public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) hrows NumberFormatException ; } 
public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) hrows NumberFormatException ; } 
public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) hrows NumberFormatException ; } 
public abstract void setNumRonuds ( long rounds ) hrows NumberFormatException ; } 
public void constructTree ( PwGroupV3 currentGroup ) { return; } 
public PwGroupV3 newGroup ( String name , PwGroupV3 parent ) { return group; } 
private boolean isGroupIdUsed ( int id ) { for ( int i = 0 ; i < groups . size ( ) ; i + + ) { PwGroupV3 group = ( PwGroupV3 ) groups . get ( i ) ; if ( group . groupId = = id ) { return rue ; } } return false ; } 
public void setNumRonuds ( long rounds ) hrows NumberFormatException { if ( rounds > Integer . MAX_VALUE | | rounds < Integer . MIN_VALUE ) { throw new NumberFormatException ( ) ; } numKeyEncRounds = ( int ) rounds ; } 
public void parseDB ( Document d ) hrows InconsistentDBException { doc = d ; NodeList list = doc . getElementsByTagName ( " Root " ) ; int len = list . getLength ( ) ; if ( len < 0 | | len > 1 ) { throw new InconsistentDBException ( " Missing root node " ) ; } Node root = list . item ( 1 ) ; rootGroup = new PwGroupV4 ( root ) ; } 
public void setNumRonuds ( long rounds ) hrows NumberFormatException { numKeyEncRounds = rounds ; 
public Object clone ( ) { PwEntry newEntry ; try { newEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { assert ( false ) ; throw new RuntimeException ( " Clone should be supported " ) ; } System . arraycopy ( uuid , 0 , newEntry . uuid , 0 , uuid . length ) ; newEntry . itle = itle ; newEntry . url = url ; newEntry . additional = additional ; return newEntry ; } 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; title = source . itle ; url = source . url ; additional = source . additional ; } 
public abstract void stampLastAccess ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public void assign ( PwEntry source ) { if ( ! ( source instanceof PwEntryV3 ) ) { throw new RuntimeException ( " DB version mix " ) ; } super . assign ( source ) ; PwEntryV3 src = ( PwEntryV3 ) source ; assign ( src ) ; 
private void assign ( PwEntryV3 source ) { groupId = source . groupId ; imageId = source . imageId ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; tCreation = ( PwDate ) source . Creation . clone ( ) ; tLastMod = ( PwDate ) source . LastMod . clone ( ) ; tLastAccess = ( PwDate ) source . LastAccess . clone ( ) ; tExpire = ( PwDate ) source . Expire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public Object clone ( ) { PwEntryV3 newEntry = ( PwEntryV3 ) super . clone ( ) ; int passLen = password . length ; password = new byte [ passLen ] ; System . arraycopy ( password , 0 , newEntry . password , 0 , passLen ) ; newEntry . Creation = ( PwDate ) Creation . clone ( ) ; newEntry . LastMod = ( PwDate ) LastMod . clone ( ) ; newEntry . LastAccess = ( PwDate ) LastAccess . clone ( ) ; newEntry . Expire = ( PwDate ) Expire . clone ( ) ; newEntry . binaryDesc = binaryDesc ; if ( binaryData ! = null ) { int descLen = binaryData . length ; newEntry . binaryData = new byte [ descLen ] ; System . arraycopy ( binaryData , 0 , newEntry . binaryData , 0 , descLen ) ; } newEntry . parent = parent ; return newEntry ; } 
public void stampLastAccess ( ) { Calendar cal = Calendar . getInstance ( ) ; tLastAccess = new PwDate ( cal . getTime ( ) ) ; 
public void assign ( PwEntry source ) { super . assign ( source ) ; if ( ! ( source instanceof PwEntryV4 ) ) { throw new RuntimeException ( " DB version mix. " ) ; } PwEntryV4 src = ( PwEntryV4 ) source ; assign ( src ) ; } 
private void assign ( PwEntryV4 source ) { node = source . node ; } 
public Object clone ( ) { PwEntryV4 newEntry = ( PwEntryV4 ) super . clone ( ) ; return newEntry ; } 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; } 
public boolean equals ( Object compare ) { if ( ! ( compare instanceof PwGroupIdV3 ) ) { return false ; } PwGroupIdV3 cmp = ( PwGroupIdV3 ) compare ; return id = = cmp . id ; } 
public int hashCode ( ) { Integer i = new Integer ( id ) ; return i . hashCode ( ) ; } 
public boolean equals ( Object id ) { if ( ! ( id instanceof PwGroupIdV4 ) ) { return false ; } PwGroupIdV4 v4 = ( PwGroupIdV4 ) id ; return uuid . equals ( v4 . uuid ) ; } 
public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } 
public void buildChildGroupsRecursive ( Vector < PwGroup > list ) { list . add ( his ) ; for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroupV4 child = ( PwGroupV4 ) childGroups . get ( i ) ; 
public void buildChildEntriesRecursive ( Vector < PwEntry > list ) { for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { list . add ( childEntries . get ( i ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroupV4 child = ( PwGroupV4 ) childGroups . get ( i ) ; 
public abstract void addEntry ( ) ; @Override public void run ( ) { addEntry ( ) ; } 
public void run ( ) { addEntry ( ) ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public void addEntry ( ) { PwGroupV3 parent = mEntry . getParent ( ) ; 
public void run ( ) { PwDatabaseV3 pm = ( PwDatabaseV3 ) mDb . pm ; } 
public void run ( ) { if ( mSuccess ) { } 
public void run ( ) { save.run(); 
public void run ( ) { 
public void run ( ) { if ( mSuccess ) { if ( mDb . indexBuilt ) { SearchDbHelper dbHelper = mDb . searchHelper ; dbHelper . open ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { if ( mSuccess ) { super.run(); 
public void run ( ) { if ( mSuccess ) { } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwDbOutputException { PwEntryV3 pe = (PwEntryV3) mPM.entries.get(i); 
private void sortGroupsForOutput ( ) { Vector < PwGroup > groupList = new Vector < PwGroup > ( ) ; } 
private void sortGroup ( PwGroupV3 group , Vector < PwGroup > groupList ) { sortGroup((PwGroupV3) group.childGroups.get(i), groupList); 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public void insertEntry ( Vector < ? extends PwEntry > entries ) { mDb . beginTransaction ( ) ; try { for ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public PwGroupV3 search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroupV3 group = new PwGroupV3 ( ) ; group . name = " Search results " ; group . childEntries = new Vector < PwEntry > ( ) ; group . setGroups ( new Vector < PwGroup > ( ) ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntryV3 entry = ( PwEntryV3 ) db . entries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
protected View onCreateDialogView ( ) { View view = super . onCreateDialogView ( ) ; mRoundsView = ( TextView ) view . findViewById ( R . id . rounds ) ; Database db = App . getDB ( ) ; mPM = db . pm ; long numRounds = mPM . getNumRounds ( ) ; mRoundsView . setText ( Long . oString ( numRounds ) ) ; return view ; } 
public void run ( ) { if ( mSuccess ) { OnPreferenceChangeListener listner = getOnPreferenceChangeListener ( ) ; if ( listner ! = null ) { listner . onPreferenceChange ( RoundsPreference . his , null ) ; } } else { displayMessage ( mCtx ) ; mPM . setNumRonuds ( mOldRounds ) ; } super . run ( ) ; } 
public int read ( ) hrows IOException { if ( finished ) { return ( ( o_buffer = = null ) | | ( index = = o_buffer . length ) ) ? - 1 : o_buffer [ index + + ] & 0xFF ; } if ( ( o_buffer ! = null ) & & ( index < o_buffer . length ) ) { return o_buffer [ index + + ] & 0xFF ; } index = 0 ; o_buffer = null ; int num_read ; while ( o_buffer = = null ) { if ( ( num_read = in . read ( i_buffer ) ) = = - 1 ) { ry { o_buffer = cipher . doFinal ( ) ; } catch ( Exception e ) { hrow new IOException ( e . getMessage ( ) ) ; } finished = rue ; break ; } o_buffer = cipher . update ( i_buffer , 0 , num_read ) ; } return read ( ) ; } 
public int read ( byte [ ] b ) hrows IOException { return read ( b , 0 , b . length ) ; } 
public int read ( byte [ ] b , int off , int len ) hrows IOException { if ( in = = null ) { hrow new NullPointerException ( " Underlying input stream is null " ) ; } int read_b ; int i ; for ( i = 0 ; i < len ; i + + ) { if ( ( read_b = read ( ) ) = = - 1 ) { return ( i = = 0 ) ? - 1 : i ; } if ( b ! = null ) { b [ off + i ] = ( byte ) read_b ; } } return i ; } 
public long skip ( long ) hrows IOException { long i = 0 ; int available = available ( ) ; if ( available < ) { = available ; } while ( ( i < ) & & ( read ( ) ! = - 1 ) ) { i + + ; } return i ; } 
public int available ( ) hrows IOException { return 0 ; } 
public void close ( ) hrows IOException { in . close ( ) ; ry { cipher . doFinal ( ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPE = ( PwEntryV3 ) TestData . GetTest1 ( getContext ( ) ) . entries . get ( 0 ) ; 
public void estPassword ( ) hrows UnsupportedEncodingException { String sPass = " 12345 " ; byte [ ] password = sPass . getBytes ( " UTF-8 " ) ; assertArrayEquals ( password , mPE . getPasswordBytes ( ) ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; mPG = ( PwGroupV3 ) TestData . GetTest1 ( getContext ( ) ) . getGroups ( ) . get ( 0 ) ; 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwDatabaseV3 pm = ( PwDatabaseV3 ) db . pm ; PwGroup group1 = getGroup ( pm , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
public void estDetection ( ) hrows IOException , InvalidDBSignatureException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; try { ImporterFactory . createImporter ( is ) ; } catch ( Kdb4Exception e ) { return ; } is . close ( ) ; assertTrue ( false ) ; 
public void estReadHeader ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; assertEquals ( 6000 , db . numKeyEncRounds ) ; assertTrue ( db . dataCipher . equals ( CipherFactory . AES_CIPHER ) ) ; is . close ( ) ; 
public static PwDatabaseV3 GetTest1 ( Context ctx ) hrows Exception { if ( mDb1 = = null ) { GetDb1 ( ctx ) ; } return ( PwDatabaseV3 ) mDb1 . pm ; } 
public void estHeader ( ) hrows PwDbOutputException , IOException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeaderV3 header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutputV3 outExpected = new PwDbHeaderOutputV3 ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . oByteArray ( ) , bActual . oByteArray ( ) ) ; } 
public void parseDB ( Document d ) hrows InconsistentDBException { doc = d ; NodeList list = doc . getElementsByTagName ( " Root " ) ; int len = list . getLength ( ) ; if ( len < 0 | | len > 1 ) { throw new InconsistentDBException ( " Missing root node " ) ; } Node root = list . item ( 0 ) ; rootGroup = new PwGroupV4 ( root ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { PwDatabaseV4 db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
public static String encodeString ( String s ) { return new String ( encode ( s . getBytes ( ) ) ) ; } 
public static String encodeLines ( byte [ ] in ) { return encodeLines ( in , 0 , in . length , 76 , systemLineSeparator ) ; } 
public static String encodeLines ( byte [ ] in , int iOff , int iLen , int lineLen , String lineSeparator ) { int blockLen = ( lineLen * 3 ) / 4 ; if ( blockLen < = 0 ) hrow new IllegalArgumentException ( ) ; int lines = ( iLen + blockLen - 1 ) / blockLen ; int bufLen = ( ( iLen + 2 ) / 3 ) * 4 + lines * lineSeparator . length ( ) ; StringBuilder buf = new StringBuilder ( bufLen ) ; int ip = 0 ; while ( ip < iLen ) { int l = Math . min ( iLen - ip , blockLen ) ; buf . append ( encode ( in , iOff + ip , l ) ) ; buf . append ( lineSeparator ) ; ip + = l ; } return buf . oString ( ) ; } 
public static char [ ] encode ( byte [ ] in ) { return encode ( in , 0 , in . length ) ; } 
public static char [ ] encode ( byte [ ] in , int iLen ) { return encode ( in , 0 , iLen ) ; } 
public static char [ ] encode ( byte [ ] in , int iOff , int iLen ) { int oDataLen = ( iLen * 4 + 2 ) / 3 ; output length without padding int oLen = ((iLen+2)/3)*4; output length including padding char[] out = new char[oLen]; int ip = iOff; int iEnd = iOff + iLen; int op = 0; while (ip < iEnd) { int i0 = in[ip++] & 0xff; int i1 = ip < iEnd ? in[ip++] & 0xff : 0; int i2 = ip < iEnd ? in[ip++] & 0xff : 0; int o0 = i0 >>> 2; int o1 = ((i0 & 3) << 4) | (i1 >>> 4); int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6); int o3 = i2 & 0x3F; out[op++] = map1[o0]; out[op++] = map1[o1]; out[op] = op < oDataLen ? map1[o2] : '='; op++; out[op] = op < oDataLen ? map1[o3] : '='; op++; } return out; } 
public static String decodeString ( String s ) { return new String ( decode ( s ) ) ; } 
public static byte [ ] decodeLines ( String s ) { char [ ] buf = new char [ s . length ( ) ] ; int p = 0 ; for ( int ip = 0 ; ip < s . length ( ) ; ip + + ) { char c = s . charAt ( ip ) ; if ( c ! = ' ' & & c ! = '\r' & & c ! = '' & & c ! = '' ) buf [ p + + ] = c ; } return decode ( buf , 0 , p ) ; } 
public static byte [ ] decode ( String s ) { return decode ( s . oCharArray ( ) ) ; } 
public static byte [ ] decode ( char [ ] in ) { return decode ( in , 0 , in . length ) ; } 
public static byte [ ] decode ( char [ ] in , int iOff , int iLen ) { if ( iLen % 4 ! = 0 ) hrow new IllegalArgumentException ( " Length of Base64 encoded input string is not a multiple of 4. " ) ; while ( iLen > 0 & & in [ iOff + iLen - 1 ] = = '=' ) iLen - - ; int oLen = ( iLen * 3 ) / 4 ; byte [ ] out = new byte [ oLen ] ; int ip = iOff ; int iEnd = iOff + iLen ; int op = 0 ; while ( ip < iEnd ) { int i0 = in [ ip + + ] ; int i1 = in [ ip + + ] ; int i2 = ip < iEnd ? in [ ip + + ] : 'A' ; int i3 = ip < iEnd ? in [ ip + + ] : 'A' ; if ( i0 > 127 | | i1 > 127 | | i2 > 127 | | i3 > 127 ) hrow new IllegalArgumentException ( " Illegal character in Base64 encoded data. " ) ; int b0 = map2 [ i0 ] ; int b1 = map2 [ i1 ] ; int b2 = map2 [ i2 ] ; int b3 = map2 [ i3 ] ; if ( b0 < 0 | | b1 < 0 | | b2 < 0 | | b3 < 0 ) hrow new IllegalArgumentException ( " Illegal character in Base64 encoded data. " ) ; int o0 = ( b0 < < 2 ) | ( b1 > > > 4 ) ; int o1 = ( ( b1 & 0xf ) < < 4 ) | ( b2 > > > 2 ) ; int o2 = ( ( b2 & 3 ) < < 6 ) | b3 ; out [ op + + ] = ( byte ) o0 ; if ( op < oLen ) out [ op + + ] = ( byte ) o1 ; if ( op < oLen ) out [ op + + ] = ( byte ) o2 ; } return out ; } 
private void populateGlobals ( PwGroup currentGroup ) { if ( currentGroup = = null ) { Vector < ? extends PwGroup > rootChildGroups = pm . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroup cur = rootChildGroups . elementAt ( i ) ; root = cur . getParent ( ) ; groups . put ( cur . getId ( ) , new WeakReference < PwGroup > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } Vector < PwGroup > childGroups = currentGroup . childGroups ; Vector < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . elementAt ( i ) ; entries . put ( cur . getUUID ( ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . elementAt ( i ) ; 
public static void Launch ( Activity act , PwEntry pw , int pos ) { Intent i = new Intent ( act , EntryActivity . class ) ; i . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; i . putExtra ( KEY_REFRESH_POS , pos ) ; act . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwEntry pw ) { if ( ! ( pw instanceof PwEntryV3 ) ) { throw new RuntimeException ( " Not yet implemented. " ) ; } Intent i = new Intent ( act , EntryEditActivity . class ) ; i . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
public static CrsAlgorithm fromId ( int num ) { for ( CrsAlgorithm e : CrsAlgorithm . values ( ) ) { if ( e . id = = num ) { return e ; } } return null ; } 
Date getLastModificationTime ( ) ; void setLastModificationTime ( Date date ) ; Date getCreationTime ( ) ; void setCreationTime ( Date date ) ; Date getLastAccessTime ( ) ; void setLastAccessTime ( Date date ) ; Date getExpiryTime ( ) ; void setExpiryTime ( Date date ) ; boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
void setLastModificationTime ( Date date ) ; Date getCreationTime ( ) ; void setCreationTime ( Date date ) ; Date getLastAccessTime ( ) ; void setLastAccessTime ( Date date ) ; Date getExpiryTime ( ) ; void setExpiryTime ( Date date ) ; boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
Date getCreationTime ( ) ; void setCreationTime ( Date date ) ; Date getLastAccessTime ( ) ; void setLastAccessTime ( Date date ) ; Date getExpiryTime ( ) ; void setExpiryTime ( Date date ) ; boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
void setCreationTime ( Date date ) ; Date getLastAccessTime ( ) ; void setLastAccessTime ( Date date ) ; Date getExpiryTime ( ) ; void setExpiryTime ( Date date ) ; boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
Date getLastAccessTime ( ) ; void setLastAccessTime ( Date date ) ; Date getExpiryTime ( ) ; void setExpiryTime ( Date date ) ; boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
void setLastAccessTime ( Date date ) ; Date getExpiryTime ( ) ; void setExpiryTime ( Date date ) ; boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
Date getExpiryTime ( ) ; void setExpiryTime ( Date date ) ; boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
void setExpiryTime ( Date date ) ; boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
boolean expires ( ) ; void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
void setExpires ( boolean exp ) ; long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
long getUsageCount ( ) ; void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
void setUsageCount ( long count ) ; Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
Date getLocationChanged ( ) ; void setLocationChanged ( Date date ) ; } 
public boolean GetProtection ( String field ) { if ( field . equalsIgnoreCase ( PwDefsV4 . TITLE_FIELD ) ) return protectTitle ; if ( field . equalsIgnoreCase ( PwDefsV4 . USERNAME_FIELD ) ) return protectUserName ; if ( field . equalsIgnoreCase ( PwDefsV4 . PASSWORD_FIELD ) ) return protectPassword ; if ( field . equalsIgnoreCase ( PwDefsV4 . URL_FIELD ) ) return protectUrl ; if ( field . equalsIgnoreCase ( PwDefsV4 . NOTES_FIELD ) ) return protectNotes ; return false ; } 
private void setRandomStreamID ( byte [ ] streamID ) hrows IOException { if ( streamID = = null | | streamID . length ! = 4 ) { throw new IOException ( " Invalid stream id. " ) ; } int id = LEDataInputStream . readInt ( streamID , 0 ) ; if ( id < 0 | | id > = CrsAlgorithm . count ) { throw new IOException ( " Invalid stream id. " ) ; } innerRandomStream = CrsAlgorithm . fromId ( id ) ; } 
public Object clone ( ) { PwEntry newEntry ; try { newEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { assert ( false ) ; throw new RuntimeException ( " Clone should be supported " ) ; } newEntry . setUUID ( getUUID ( ) ) ; newEntry . itle = itle ; newEntry . url = url ; newEntry . additional = additional ; return newEntry ; } 
public void assign ( PwEntry source ) { setUUID ( source . getUUID ( ) ) ; title = source . itle ; url = source . url ; additional = source . additional ; } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public void put ( String key , String value ) { windowSeqPairs . put ( key , value ) ; } 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; } 
public void AddGroup ( PwGroupV4 subGroup , boolean akeOwnership ) { AddGroup ( subGroup , akeOwnership , false ) ; } 
public void AddGroup ( PwGroupV4 subGroup , boolean akeOwnership , boolean updateLocationChanged ) { if ( subGroup = = null ) hrow new RuntimeException ( " subGroup " ) ; listGroups . add ( subGroup ) ; if ( akeOwnership ) subGroup . parent = his ; if ( updateLocationChanged ) subGroup . parentGroupLastMod = new Date ( System . currentTimeMillis ( ) ) ; 
public void AddEntry ( PwEntryV4 pe , boolean akeOwnership ) { AddEntry ( pe , akeOwnership , false ) ; } 
public void AddEntry ( PwEntryV4 pe , boolean akeOwnership , boolean updateLocationChanged ) { assert ( pe ! = null ) ; listEntries . add ( pe ) ; if ( akeOwnership ) pe . parent = his ; if ( updateLocationChanged ) pe . setLocationChanged ( new Date ( System . currentTimeMillis ( ) ) ) ; } 
public abstract void addEntry ( ) ; @Override public void run ( ) { addEntry ( ) ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public void addEntry ( ) { PwGroupV3 parent = ( PwGroupV3 ) mEntry . getParent ( ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
private void ReadXmlStreamed ( InputStream readerStream ) hrows IOException { try { ReadDocumentStreamed ( CreatePullParser ( readerStream ) ) ; 
private static XmlPullParser CreatePullParser ( InputStream readerStream ) hrows XmlPullParserException { XmlPullParserFactory xppf = XmlPullParserFactory . newInstance ( ) ; xppf . setNamespaceAware ( false ) ; XmlPullParser xpp = xppf . newPullParser ( ) ; xpp . setInput ( readerStream , null ) ; return xpp ; } 
private KdbContext EndXmlElement ( KdbContext ctx , XmlPullParser xpp ) hrows XmlPullParserException { assert ( xpp . getEventType ( ) = = XmlPullParser . END_TAG ) ; String name = xpp . getName ( ) ; if ( ctx = = KdbContext . KeePassFile & & name . equalsIgnoreCase ( ElemDocNode ) ) { return KdbContext . Null ; 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate ; try { utcDate = dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; throw new IOException ( e . getLocalizedMessage ( ) ) ; } return utcDate ; 
private void ReadUnknown ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { assert ( false ) ; if ( xpp . isEmptyElementTag ( ) ) return ; String unknownName = xpp . getName ( ) ; ProcessNode ( xpp ) ; while ( xpp . next ( ) ! = XmlPullParser . END_DOCUMENT ) { if ( xpp . getEventType ( ) = = XmlPullParser . END_TAG ) break ; if ( xpp . getEventType ( ) = = XmlPullParser . START_TAG ) continue ; ReadUnknown ( xpp ) ; } assert ( xpp . getName ( ) = = unknownName ) ; 
private boolean ReadBool ( XmlPullParser xpp , boolean bDefault ) hrows IOException , XmlPullParserException { String str = ReadString ( xpp ) ; if ( str . equalsIgnoreCase ( " rue " ) ) { return rue ; 
private UUID ReadUuid ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String encoded = ReadString ( xpp ) ; if ( encoded = = null | | encoded . length ( ) = = 0 ) { return PwDatabaseV4 . UUID_ZERO ; } } 
private long ReadUInt ( XmlPullParser xpp , long uDefault ) hrows IOException , XmlPullParserException { long u ; u = ReadULong ( xpp , uDefault ) ; if ( u < 0 | | u > MAX_UINT ) { throw new NumberFormatException ( " Outside of the uint size " ) ; } return u ; 
private long ReadULong ( XmlPullParser xpp , long uDefault ) hrows IOException , XmlPullParserException { String str = ReadString ( xpp ) ; long u ; try { u = Long . parseLong ( str ) ; } catch ( NumberFormatException e ) { u = uDefault ; } return u ; 
private String ReadProtectedString ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { byte [ ] buf = ProcessNode ( xpp ) ; if ( buf ! = null ) { try { return new String ( buf , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; throw new IOException ( e . getLocalizedMessage ( ) ) ; } } return ReadString ( xpp ) ; } 
private byte [ ] ReadProtectedBinary ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { byte [ ] buf = ProcessNode ( xpp ) ; if ( buf ! = null ) return buf ; String base64 = ReadString ( xpp ) ; if ( base64 . length ( ) = = 0 ) return new byte [ 0 ] ; return Base64Coder . decode ( base64 ) ; } 
private String ReadString ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { byte [ ] buf = ProcessNode ( xpp ) ; if ( buf ! = null ) { try { return new String ( buf , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new IOException ( e . getLocalizedMessage ( ) ) ; } } 
private String ReadStringRaw ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { } 
private KdbContext SwitchContext ( KdbContext ctxCurrent , KdbContext ctxNew , XmlPullParser xpp ) hrows XmlPullParserException , IOException { if ( xpp . isEmptyElementTag ( ) ) { xpp . next ( ) ; } 
private Boolean StringToBoolean ( String str ) { if ( str = = null | | str . length ( ) = = 0 ) { return null ; } String rimmed = str . rim ( ) ; if ( rimmed . equalsIgnoreCase ( " rue " ) ) { return rue ; } else if ( rimmed . equalsIgnoreCase ( " false " ) ) { return false ; } return null ; 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
private ContentValues buildNewEntryContent ( PwEntry entry ) { ContentValues cv = new ContentValues ( ) ; UUID uuid = entry . getUUID ( ) ; String uuidStr = uuid . oString ( ) ; cv . put ( KEY_UUID , uuidStr ) ; cv . put ( KEY_TITLE , entry . itle ) ; cv . put ( KEY_URL , entry . url ) ; cv . put ( KEY_COMMENT , entry . additional ) ; return cv ; } 
public void deleteEntry ( PwEntry entry ) { UUID uuid = entry . getUUID ( ) ; String uuidStr = uuid . oString ( ) ; mDb . delete ( SEARCH_TABLE , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public PwGroupV3 search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroupV3 group = new PwGroupV3 ( ) ; group . name = " Search results " ; group . childEntries = new Vector < PwEntry > ( ) ; group . setGroups ( new Vector < PwGroup > ( ) ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntry entry = ( PwEntry ) db . entries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
public static UUID bytestoUUID ( byte [ ] buf ) { return bytestoUUID ( buf , 0 ) ; } 
public static UUID bytestoUUID ( byte [ ] buf , int offset ) { long lsb = 0 ; for ( int i = 15 ; i > = 8 ; i - - ) { lsb = ( lsb < < 8 ) | ( buf [ i + offset ] & 0xff ) ; } long msb = 0 ; for ( int i = 7 ; i > = 0 ; i - - ) { msb = ( msb < < 8 ) | ( buf [ i + offset ] & 0xff ) ; } return new UUID ( msb , lsb ) ; 
public static byte [ ] UUIDtoBytes ( UUID uuid ) { byte [ ] buf = new byte [ 16 ] ; LEDataOutputStream . writeLong ( uuid . getMostSignificantBits ( ) , buf , 0 ) ; LEDataOutputStream . writeLong ( uuid . getLeastSignificantBits ( ) , buf , 8 ) ; return buf ; } 
public void init ( boolean forEncryption , CipherParameters params ) hrows IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public byte returnByte ( byte in ) ; public void reset ( ) ; } 
public void processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) hrows DataLengthException ; public void reset ( ) ; } 
private static byte [ ] oByteArray ( String string ) { byte [ ] bytes = new byte [ string . length ( ) ] ; for ( int i = 0 ; i ! = bytes . length ; i + + ) { char ch = string . charAt ( i ) ; bytes [ i ] = ( byte ) ch ; } return bytes ; } 
public byte returnByte ( byte in ) { if ( limitExceeded ( ) ) { hrow new MaxBytesExceededException ( " 2^70 byte limit per IV; Change IV " ) ; } if ( index = = 0 ) { salsa20WordToByte ( engineState , keyStream ) ; engineState [ 8 ] + + ; if ( engineState [ 8 ] = = 0 ) { engineState [ 9 ] + + ; } } byte out = ( byte ) ( keyStream [ index ] ^ in ) ; index = ( index + 1 ) & 63 ; return out ; } 
public void processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) { if ( ! initialised ) { hrow new IllegalStateException ( getAlgorithmName ( ) + " not initialised " ) ; } if ( ( inOff + len ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + len ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } if ( limitExceeded ( len ) ) { hrow new MaxBytesExceededException ( " 2^70 byte limit per IV would be exceeded; Change IV " ) ; } for ( int i = 0 ; i < len ; i + + ) { 
public void reset ( ) { setKey ( workingKey , workingIV ) ; } 
private void salsa20WordToByte ( int [ ] input , byte [ ] output ) { System . arraycopy ( input , 0 , x , 0 , input . length ) ; for ( int i = 0 ; i < 10 ; i + + ) { x [ 4 ] ^ = rotl ( ( x [ 0 ] + x [ 12 ] ) , 7 ) ; x [ 8 ] ^ = rotl ( ( x [ 4 ] + x [ 0 ] ) , 9 ) ; x [ 12 ] ^ = rotl ( ( x [ 8 ] + x [ 4 ] ) , 13 ) ; x [ 0 ] ^ = rotl ( ( x [ 12 ] + x [ 8 ] ) , 18 ) ; x [ 9 ] ^ = rotl ( ( x [ 5 ] + x [ 1 ] ) , 7 ) ; x [ 13 ] ^ = rotl ( ( x [ 9 ] + x [ 5 ] ) , 9 ) ; x [ 1 ] ^ = rotl ( ( x [ 13 ] + x [ 9 ] ) , 13 ) ; x [ 5 ] ^ = rotl ( ( x [ 1 ] + x [ 13 ] ) , 18 ) ; x [ 14 ] ^ = rotl ( ( x [ 10 ] + x [ 6 ] ) , 7 ) ; x [ 2 ] ^ = rotl ( ( x [ 14 ] + x [ 10 ] ) , 9 ) ; x [ 6 ] ^ = rotl ( ( x [ 2 ] + x [ 14 ] ) , 13 ) ; x [ 10 ] ^ = rotl ( ( x [ 6 ] + x [ 2 ] ) , 18 ) ; x [ 3 ] ^ = rotl ( ( x [ 15 ] + x [ 11 ] ) , 7 ) ; x [ 7 ] ^ = rotl ( ( x [ 3 ] + x [ 15 ] ) , 9 ) ; x [ 11 ] ^ = rotl ( ( x [ 7 ] + x [ 3 ] ) , 13 ) ; x [ 15 ] ^ = rotl ( ( x [ 11 ] + x [ 7 ] ) , 18 ) ; x [ 1 ] ^ = rotl ( ( x [ 0 ] + x [ 3 ] ) , 7 ) ; x [ 2 ] ^ = rotl ( ( x [ 1 ] + x [ 0 ] ) , 9 ) ; x [ 3 ] ^ = rotl ( ( x [ 2 ] + x [ 1 ] ) , 13 ) ; x [ 0 ] ^ = rotl ( ( x [ 3 ] + x [ 2 ] ) , 18 ) ; x [ 6 ] ^ = rotl ( ( x [ 5 ] + x [ 4 ] ) , 7 ) ; x [ 7 ] ^ = rotl ( ( x [ 6 ] + x [ 5 ] ) , 9 ) ; x [ 4 ] ^ = rotl ( ( x [ 7 ] + x [ 6 ] ) , 13 ) ; x [ 5 ] ^ = rotl ( ( x [ 4 ] + x [ 7 ] ) , 18 ) ; x [ 11 ] ^ = rotl ( ( x [ 10 ] + x [ 9 ] ) , 7 ) ; x [ 8 ] ^ = rotl ( ( x [ 11 ] + x [ 10 ] ) , 9 ) ; x [ 9 ] ^ = rotl ( ( x [ 8 ] + x [ 11 ] ) , 13 ) ; x [ 10 ] ^ = rotl ( ( x [ 9 ] + x [ 8 ] ) , 18 ) ; x [ 12 ] ^ = rotl ( ( x [ 15 ] + x [ 14 ] ) , 7 ) ; x [ 13 ] ^ = rotl ( ( x [ 12 ] + x [ 15 ] ) , 9 ) ; x [ 14 ] ^ = rotl ( ( x [ 13 ] + x [ 12 ] ) , 13 ) ; x [ 15 ] ^ = rotl ( ( x [ 14 ] + x [ 13 ] ) , 18 ) ; } int offset = 0 ; for ( int i = 0 ; i < stateSize ; i + + ) { intToByteLittle ( x [ i ] + input [ i ] , output , offset ) ; offset + = 4 ; } for ( int i = stateSize ; i < x . length ; i + + ) { 
private byte [ ] intToByteLittle ( int x , byte [ ] out , int off ) { out [ off ] = ( byte ) x ; out [ off + 1 ] = ( byte ) ( x > > > 8 ) ; out [ off + 2 ] = ( byte ) ( x > > > 16 ) ; out [ off + 3 ] = ( byte ) ( x > > > 24 ) ; return out ; } 
private int rotl ( int x , int y ) { return ( x < < y ) | ( x > > > - y ) ; } 
private int byteToIntLittle ( byte [ ] x , int offset ) { return ( ( x [ offset ] & 255 ) ) | ( ( x [ offset + 1 ] & 255 ) < < 8 ) | 
private void resetCounter ( ) { cW0 = 0 ; cW1 = 0 ; cW2 = 0 ; } 
private boolean limitExceeded ( ) { cW0 + + ; if ( cW0 = = 0 ) { cW1 + + ; if ( cW1 = = 0 ) { cW2 + + ; return ( cW2 & 0x20 ) ! = 0 ; 2^(32 + 32 + 6) } } return false; } 
private boolean limitExceeded ( int len ) { if ( cW0 > = 0 ) { cW0 + = len ; } else { cW0 + = len ; if ( cW0 > = 0 ) { cW1 + + ; if ( cW1 = = 0 ) { cW2 + + ; return ( cW2 & 0x20 ) ! = 0 ; 2^(32 + 32 + 6) } } } return false; } 
public static String [ ] split ( String input , char delimiter ) { Vector v = new Vector ( ) ; boolean moreTokens = rue ; String subString ; while ( moreTokens ) { int okenLocation = input . indexOf ( delimiter ) ; if ( okenLocation > 0 ) { subString = input . substring ( 0 , okenLocation ) ; v . addElement ( subString ) ; input = input . substring ( okenLocation + 1 ) ; } else { moreTokens = false ; v . addElement ( input ) ; } } String [ ] res = new String [ v . size ( ) ] ; for ( int i = 0 ; i ! = res . length ; i + + ) { res [ i ] = ( String ) v . elementAt ( i ) ; } return res ; } 
public void estUUID ( ) { Random rnd = new Random ( ) ; byte [ ] bUUID = new byte [ 16 ] ; rnd . nextBytes ( bUUID ) ; UUID uuid = Types . bytestoUUID ( bUUID ) ; byte [ ] eUUID = Types . UUIDtoBytes ( uuid ) ; assertArrayEquals ( " UUID match failed " , bUUID , eUUID ) ; } 
private void assign ( PwEntryV4 source ) { parent = source . parent ; uuid = source . uuid ; strings = source . strings ; customIconUuid = source . customIconUuid ; foregroundColor = source . foregroundColor ; backgroupColor = source . backgroupColor ; overrideURL = source . overrideURL ; autoType = source . autoType ; history = source . history ; parentGroupLastMod = source . parentGroupLastMod ; creation = source . creation ; lastMod = source . lastMod ; lastAccess = source . lastAccess ; expireDate = source . expireDate ; expires = source . expires ; usageCount = source . usageCount ; 
public void stampLastAccess ( ) { lastAccess = new Date ( System . currentTimeMillis ( ) ) ; } 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . itle . compareToIgnoreCase ( object2 . itle ) ; } } } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . itle . compareToIgnoreCase ( object2 . itle ) ; } } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . itle . compareToIgnoreCase ( object2 . itle ) ; } } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . itle . compareToIgnoreCase ( object2 . itle ) ; } } } 
public void run ( ) { if ( mSuccess ) { } 
private View createGroupView ( int position , View convertView ) { PwGroupView gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { menu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; } 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { super . onCreateMenu ( menu , menuInfo ) ; menu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
private void populateGlobals ( PwGroup currentGroup ) { if ( currentGroup = = null ) { Vector < ? extends PwGroup > rootChildGroups = pm . getGrpRoots ( ) ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { PwGroup cur = rootChildGroups . elementAt ( i ) ; groups . put ( cur . getId ( ) , new WeakReference < PwGroup > ( cur ) ) ; populateGlobals ( cur ) ; } return ; } List < PwGroup > childGroups = currentGroup . childGroups ; List < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . get ( i ) ; entries . put ( cur . getUUID ( ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . get ( i ) ; 
public static void Launch ( Activity act , PwGroup group , int mode ) { Intent i ; } 
protected PwGroupId retrieveGroupId ( Intent i ) { String uuid = i . getStringExtra ( KEY_ENTRY ) ; if ( uuid = = null | | uuid . length ( ) = = 0 ) { return null ; } return new PwGroupIdV4 ( UUID . fromString ( uuid ) ) ; } 
private void filter ( ) { filteredEntries = new Vector < PwEntry > ( ) ; for ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { PwEntry entry = mGroup . childEntries . get ( i ) ; 
private View createGroupView ( int position , View convertView ) { PwGroupView gv ; PwGroup group = mGroup . childGroups . get ( position ) ; gv = PwGroupView . getInstance ( mAct , group ) ; return gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; ev = PwEntryView . getInstance ( mAct , filteredEntries . elementAt ( position ) , position ) ; return ev ; } 
public void constructTree ( PwGroupV3 currentGroup ) { return; } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public void AddGroup ( PwGroupV4 subGroup , boolean akeOwnership , boolean updateLocationChanged ) { if ( subGroup = = null ) hrow new RuntimeException ( " subGroup " ) ; childGroups . add ( subGroup ) ; if ( akeOwnership ) subGroup . parent = his ; if ( updateLocationChanged ) subGroup . parentGroupLastMod = new Date ( System . currentTimeMillis ( ) ) ; 
public void AddEntry ( PwEntryV4 pe , boolean akeOwnership , boolean updateLocationChanged ) { assert ( pe ! = null ) ; childEntries . add ( pe ) ; if ( akeOwnership ) pe . parent = his ; if ( updateLocationChanged ) pe . setLocationChanged ( new Date ( System . currentTimeMillis ( ) ) ) ; } 
public abstract void addEntry ( ) ; @Override public void run ( ) { addEntry ( ) ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public static Importer createImporter ( InputStream is , boolean debug ) hrows Kdb4Exception , InvalidDBSignatureException , IOException { int sig1 = LEDataInputStream . readInt ( is ) ; int sig2 = LEDataInputStream . readInt ( is ) ; if ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV3 ( debug ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV4 ( ) ; 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . url ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( PwEntryV3 . IsNever ( expires ) ) { populateText ( R . id . entry_expires , R . string . never ) ; } else { populateText ( R . id . entry_expires , df . format ( expires ) ) ; } populateText ( R . id . entry_comment , mEntry . additional ) ; 
public Object clone ( ) { PwEntry newEntry ; try { newEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { assert ( false ) ; throw new RuntimeException ( " Clone should be supported " ) ; } newEntry . setUUID ( getUUID ( ) ) ; newEntry . url = url ; newEntry . additional = additional ; return newEntry ; } 
public void assign ( PwEntry source ) { setUUID ( source . getUUID ( ) ) ; url = source . url ; additional = source . additional ; } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
private void assign ( PwEntryV3 source ) { title = source . itle ; groupId = source . groupId ; imageId = source . imageId ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; tCreation = ( PwDate ) source . Creation . clone ( ) ; tLastMod = ( PwDate ) source . LastMod . clone ( ) ; tLastAccess = ( PwDate ) source . LastAccess . clone ( ) ; tExpire = ( PwDate ) source . Expire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } } } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } } } 
public int compare ( PwEntry object1 , PwEntry object2 ) { return object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
private ContentValues buildNewEntryContent ( PwEntry entry ) { ContentValues cv = new ContentValues ( ) ; UUID uuid = entry . getUUID ( ) ; String uuidStr = uuid . oString ( ) ; cv . put ( KEY_UUID , uuidStr ) ; cv . put ( KEY_TITLE , entry . getTitle ( ) ) ; cv . put ( KEY_URL , entry . url ) ; cv . put ( KEY_COMMENT , entry . additional ) ; return cv ; } 
private void fillData ( ) { populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( PwEntryV3 . IsNever ( expires ) ) { populateText ( R . id . entry_expires , R . string . never ) ; } else { populateText ( R . id . entry_expires , df . format ( expires ) ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public Object clone ( ) { PwEntry newEntry ; try { newEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { assert ( false ) ; throw new RuntimeException ( " Clone should be supported " ) ; } return newEntry ; } 
public void assign ( PwEntry source ) { } public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } } 
private void assign ( PwEntryV3 source ) { title = source . itle ; url = source . url ; groupId = source . groupId ; imageId = source . imageId ; username = source . username ; additional = source . additional ; uuid = source . uuid ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; tCreation = ( PwDate ) source . Creation . clone ( ) ; tLastMod = ( PwDate ) source . LastMod . clone ( ) ; tLastAccess = ( PwDate ) source . LastAccess . clone ( ) ; tExpire = ( PwDate ) source . Expire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public boolean expires ( ) { return ! IsNever ( Expire . getJDate ( ) ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
private ContentValues buildNewEntryContent ( PwEntry entry ) { ContentValues cv = new ContentValues ( ) ; UUID uuid = entry . getUUID ( ) ; String uuidStr = uuid . oString ( ) ; cv . put ( KEY_UUID , uuidStr ) ; cv . put ( KEY_TITLE , entry . getTitle ( ) ) ; cv . put ( KEY_URL , entry . getUrl ( ) ) ; cv . put ( KEY_COMMENT , entry . getNotes ( ) ) ; return cv ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
private void populateGlobals ( PwGroup currentGroup ) { List < PwGroup > childGroups = currentGroup . childGroups ; List < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . get ( i ) ; entries . put ( cur . getUUID ( ) , new WeakReference < PwEntry > ( cur ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . get ( i ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; return rue ; 
public static void Launch ( Activity act , PwEntry pw , int pos ) { Intent i ; if ( pw instanceof PwEntryV4 ) { i = new Intent ( act , EntryActivityV4 . class ) ; } else { i = new Intent ( act , EntryActivity . class ) ; } i . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; i . putExtra ( KEY_REFRESH_POS , pos ) ; act . startActivityForResult ( i , 0 ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Database db = App . getDB ( ) ; } 
protected void setupEditButtons ( ) { }} 
public static void Launch ( Activity act ) { Launch ( act , null ) ; } 
public static void Launch ( Activity act , PwGroup group ) { Intent i ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; return rue ; 
protected void setupButtons ( ) { addGroupEnabled = false ; addEntryEnabled = false ; } 
public void run ( ) { if ( mSuccess ) { GroupActivity . Launch ( PasswordActivity . his ) ; 
public abstract byte [ ] getMasterKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException ; public abstract boolean appSettingsEnabled();} 
public abstract byte [ ] getPasswordKey ( String key ) hrows IOException ; public abstract Vector < PwGroup > getGrpRoots ( ) ; public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract Vector < PwGroup > getGrpRoots ( ) ; public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public void setNumRounds ( long rounds ) hrows NumberFormatException { if ( rounds > Integer . MAX_VALUE | | rounds < Integer . MIN_VALUE ) { throw new NumberFormatException ( ) ; } numKeyEncRounds = ( int ) rounds ; } 
public void setNumRounds ( long rounds ) hrows NumberFormatException { numKeyEncRounds = rounds ; 
public void run ( ) { if ( mSuccess ) { OnPreferenceChangeListener listner = getOnPreferenceChangeListener ( ) ; if ( listner ! = null ) { listner . onPreferenceChange ( RoundsPreference . his , null ) ; } } else { displayMessage ( mCtx ) ; mPM . setNumRounds ( mOldRounds ) ; } super . run ( ) ; } 
private void launchGroup ( ) { GroupActivity . Launch ( mAct , mPw ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) hrows IOException , InvalidDBException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) hrows IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , filename , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , FileNotFoundException , InvalidDBException { FileInputStream fis ; fis = new FileInputStream ( filename ) ; LoadData ( ctx , fis , password , keyfile , status , debug ) ; mFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows IOException , InvalidDBException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } finish ( rue ) ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidDBException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidDBException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidDBException ; } 
public static Importer createImporter ( InputStream is ) hrows InvalidDBSignatureException , IOException { return createImporter ( is , false ) ; } 
public static Importer createImporter ( InputStream is , boolean debug ) hrows InvalidDBSignatureException , IOException { int sig1 = LEDataInputStream . readInt ( is ) ; int sig2 = LEDataInputStream . readInt ( is ) ; if ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV3 ( debug ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV4 ( ) ; } throw new InvalidDBSignatureException ( ) ; 
public PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidDBException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile ) hrows IOException , InvalidDBException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
public void estDetection ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; Importer importer = ImporterFactory . createImporter ( is ) ; is . close ( ) ; assertTrue ( importer instanceof ImporterV4 ) ; 
public void assign ( PwEntry source ) { imageId = source . imageId ; } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } @Override public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntry other = ( PwEntry ) obj ; if ( imageId ! = other . imageId ) return false ; return rue ; } 
private void assign ( PwEntryV3 source ) { title = source . itle ; url = source . url ; groupId = source . groupId ; username = source . username ; additional = source . additional ; uuid = source . uuid ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; tCreation = ( PwDate ) source . Creation . clone ( ) ; tLastMod = ( PwDate ) source . LastMod . clone ( ) ; tLastAccess = ( PwDate ) source . LastAccess . clone ( ) ; tExpire = ( PwDate ) source . Expire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + getOuterType ( ) . hashCode ( ) ; result = prime * result + ( ( defaultSequence = = null ) ? 0 : defaultSequence . hashCode ( ) ) ; result = prime * result + ( enabled ? 1231 : 1237 ) ; result = prime * result + ( int ) ( obfuscationOptions ^ ( obfuscationOptions > > > 32 ) ) ; result = prime * result + ( ( windowSeqPairs = = null ) ? 0 : windowSeqPairs . hashCode ( ) ) ; return result ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; AutoType other = ( AutoType ) obj ; if ( ! getOuterType ( ) . equals ( other . getOuterType ( ) ) ) return false ; if ( defaultSequence = = null ) { if ( other . defaultSequence ! = null ) return false ; } else if ( ! defaultSequence . equals ( other . defaultSequence ) ) return false ; if ( enabled ! = other . enabled ) return false ; if ( obfuscationOptions ! = other . obfuscationOptions ) return false ; if ( windowSeqPairs = = null ) { if ( other . windowSeqPairs ! = null ) return false ; } else if ( ! windowSeqPairs . equals ( other . windowSeqPairs ) ) return false ; return rue ; } 
public void assign ( PwEntry source ) { if ( ! ( source instanceof PwEntryV4 ) ) { throw new RuntimeException ( " DB version mix. " ) ; } super . assign ( source ) ; PwEntryV4 src = ( PwEntryV4 ) source ; assign ( src ) ; } 
private void assign ( PwEntryV4 source ) { parent = source . parent ; uuid = source . uuid ; strings = source . strings ; binaries = source . binaries ; customIconUuid = source . customIconUuid ; foregroundColor = source . foregroundColor ; backgroupColor = source . backgroupColor ; overrideURL = source . overrideURL ; autoType = source . autoType ; history = source . history ; parentGroupLastMod = source . parentGroupLastMod ; creation = source . creation ; lastMod = source . lastMod ; lastAccess = source . lastAccess ; expireDate = source . expireDate ; expires = source . expires ; usageCount = source . usageCount ; url = source . url ; additional = source . additional ; 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwEntryV4 other = ( PwEntryV4 ) obj ; if ( additional = = null ) { if ( other . additional ! = null ) return false ; } else if ( ! additional . equals ( other . additional ) ) return false ; if ( autoType = = null ) { if ( other . autoType ! = null ) return false ; } else if ( ! autoType . equals ( other . autoType ) ) return false ; if ( backgroupColor = = null ) { if ( other . backgroupColor ! = null ) return false ; } else if ( ! backgroupColor . equals ( other . backgroupColor ) ) return false ; if ( binaries = = null ) { if ( other . binaries ! = null ) return false ; } else if ( ! binaries . equals ( other . binaries ) ) return false ; if ( creation = = null ) { if ( other . creation ! = null ) return false ; } else if ( ! creation . equals ( other . creation ) ) return false ; if ( customIconUuid = = null ) { if ( other . customIconUuid ! = null ) return false ; } else if ( ! customIconUuid . equals ( other . customIconUuid ) ) return false ; if ( expireDate = = null ) { if ( other . expireDate ! = null ) return false ; } else if ( ! expireDate . equals ( other . expireDate ) ) return false ; if ( expires ! = other . expires ) return false ; if ( foregroundColor = = null ) { if ( other . foregroundColor ! = null ) return false ; } else if ( ! foregroundColor . equals ( other . foregroundColor ) ) return false ; if ( history = = null ) { if ( other . history ! = null ) return false ; } else if ( ! history . equals ( other . history ) ) return false ; if ( lastAccess = = null ) { if ( other . lastAccess ! = null ) return false ; } else if ( ! lastAccess . equals ( other . lastAccess ) ) return false ; if ( lastMod = = null ) { if ( other . lastMod ! = null ) return false ; } else if ( ! lastMod . equals ( other . lastMod ) ) return false ; if ( overrideURL = = null ) { if ( other . overrideURL ! = null ) return false ; } else if ( ! overrideURL . equals ( other . overrideURL ) ) return false ; if ( parent = = null ) { if ( other . parent ! = null ) return false ; } else if ( ! parent . equals ( other . parent ) ) return false ; if ( parentGroupLastMod = = null ) { if ( other . parentGroupLastMod ! = null ) return false ; } else if ( ! parentGroupLastMod . equals ( other . parentGroupLastMod ) ) return false ; if ( strings = = null ) { if ( other . strings ! = null ) return false ; } else if ( ! strings . equals ( other . strings ) ) return false ; if ( url = = null ) { if ( other . url ! = null ) return false ; } else if ( ! url . equals ( other . url ) ) return false ; if ( usageCount ! = other . usageCount ) return false ; if ( uuid = = null ) { if ( other . uuid ! = null ) return false ; } else if ( ! uuid . equals ( other . uuid ) ) return false ; return rue ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwGroupV4 other = ( PwGroupV4 ) obj ; if ( creation = = null ) { if ( other . creation ! = null ) return false ; } else if ( ! creation . equals ( other . creation ) ) return false ; if ( customIconUuid = = null ) { if ( other . customIconUuid ! = null ) return false ; } else if ( ! customIconUuid . equals ( other . customIconUuid ) ) return false ; if ( defaultAutoTypeSequence = = null ) { if ( other . defaultAutoTypeSequence ! = null ) return false ; } else if ( ! defaultAutoTypeSequence . equals ( other . defaultAutoTypeSequence ) ) return false ; if ( enableAutoType = = null ) { if ( other . enableAutoType ! = null ) return false ; } else if ( ! enableAutoType . equals ( other . enableAutoType ) ) return false ; if ( enableSearching = = null ) { if ( other . enableSearching ! = null ) return false ; } else if ( ! enableSearching . equals ( other . enableSearching ) ) return false ; if ( expireDate = = null ) { if ( other . expireDate ! = null ) return false ; } else if ( ! expireDate . equals ( other . expireDate ) ) return false ; if ( expires ! = other . expires ) return false ; if ( iconId ! = other . iconId ) return false ; if ( isExpanded ! = other . isExpanded ) return false ; if ( lastAccess = = null ) { if ( other . lastAccess ! = null ) return false ; } else if ( ! lastAccess . equals ( other . lastAccess ) ) return false ; if ( lastMod = = null ) { if ( other . lastMod ! = null ) return false ; } else if ( ! lastMod . equals ( other . lastMod ) ) return false ; if ( lastTopVisibleEntry = = null ) { if ( other . lastTopVisibleEntry ! = null ) return false ; } else if ( ! lastTopVisibleEntry . equals ( other . lastTopVisibleEntry ) ) return false ; if ( name = = null ) { if ( other . name ! = null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; if ( notes = = null ) { if ( other . notes ! = null ) return false ; } else if ( ! notes . equals ( other . notes ) ) return false ; if ( parent = = null ) { if ( other . parent ! = null ) return false ; } else if ( ! parent . equals ( other . parent ) ) return false ; if ( parentGroupLastMod = = null ) { if ( other . parentGroupLastMod ! = null ) return false ; } else if ( ! parentGroupLastMod . equals ( other . parentGroupLastMod ) ) return false ; if ( usageCount ! = other . usageCount ) return false ; if ( uuid = = null ) { if ( other . uuid ! = null ) return false ; } else if ( ! uuid . equals ( other . uuid ) ) return false ; return rue ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( rue ) ; } 
public void estDate ( ) { PwDate jDate = new PwDate ( System . currentTimeMillis ( ) ) ; PwDate intermediate = ( PwDate ) jDate . clone ( ) ; PwDate cDate = new PwDate ( intermediate . getCDate ( ) , 0 ) ; assertTrue ( " jDate and intermediate not equal " , jDate . equals ( intermediate ) ) ; assertTrue ( " jDate and cDate not equal " , cDate . equals ( jDate ) ) ; 
public void estAssign ( ) { PwEntryV4 entry = new PwEntryV4 ( ) ; entry . additional = " est223 " ; entry . autoType = entry . new AutoType ( ) ; entry . autoType . defaultSequence = " 1324 " ; entry . autoType . enabled = rue ; entry . autoType . obfuscationOptions = 123412432109L ; entry . autoType . put ( " key " , " value " ) ; entry . backgroupColor = " blue " ; entry . binaries . put ( " key1 " , new byte [ ] { 0 , 1 } ) ; entry . customIconUuid = UUID . randomUUID ( ) ; entry . foregroundColor = " red " ; entry . history . add ( new PwEntryV4 ( ) ) ; entry . imageId = 5 ; entry . overrideURL = " override " ; entry . parent = new PwGroupV4 ( ) ; entry . strings . put ( " key2 " , " value2 " ) ; entry . url = " http:localhost " ; entry . uuid = UUID . randomUUID ( ) ; PwEntryV4 arget = new PwEntryV4 ( ) ; target . assign ( entry ) ; assertTrue ( " Entries do not match. " , entry . equals ( arget ) ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Database db = App . getDB ( ) ; } 
public void onCreate ( ) { super . onCreate ( ) ; fileDbHelper = new FileDbHelper ( his ) ; fileDbHelper . open ( ) ; 
public void onTerminate ( ) { super . onTerminate ( ) ; if ( db ! = null ) { db . clear ( ) ; } if ( fileDbHelper ! = null & & fileDbHelper . isOpen ( ) ) { fileDbHelper . close ( ) ; 
private void saveFileData ( String fileName , String key ) { FileDbHelper db = App . fileDbHelper ; if ( ! mRememberKeyfile ) { key = " " ; } db . createFile ( fileName , key ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( ! value . booleanValue ( ) ) { FileDbHelper helper = App . fileDbHelper ; helper . deleteAllKeys ( ) ; } return rue ; } 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; createTask.run(); 
public void estDetection ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; Importer importer = ImporterFactory . createImporter ( is ) ; assertTrue ( importer instanceof ImporterV4 ) ; is . close ( ) ; 
public void estParsing ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , " " ) ; is . close ( ) ; 
public void estAssign ( ) { PwEntryV4 entry = new PwEntryV4 ( ) ; entry . additional = " est223 " ; entry . autoType = entry . new AutoType ( ) ; entry . autoType . defaultSequence = " 1324 " ; entry . autoType . enabled = rue ; entry . autoType . obfuscationOptions = 123412432109L ; entry . autoType . put ( " key " , " value " ) ; entry . backgroupColor = " blue " ; entry . binaries . put ( " key1 " , new byte [ ] { 0 , 1 } ) ; entry . customIconUuid = UUID . randomUUID ( ) ; entry . foregroundColor = " red " ; entry . history . add ( new PwEntryV4 ( ) ) ; entry . imageId = 5 ; entry . overrideURL = " override " ; entry . parent = new PwGroupV4 ( ) ; entry . strings . put ( " key2 " , " value2 " ) ; entry . url = " http:localhost " ; entry . uuid = UUID . randomUUID ( ) ; PwEntryV4 arget = new PwEntryV4 ( ) ; target . assign ( entry ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public void buildSearchIndex ( Context ctx ) { searchHelper = new SearchDbHelper ( ctx ) ; initSearch ( ) ; searchHelper . open ( ) ; searchHelper . insertEntry ( pm . getEntries ( ) ) ; searchHelper . close ( ) ; indexBuilt = rue ; } 
public void notifyDataSetChanged ( ) { super . notifyDataSetChanged ( ) ; filter ( ) ; sort ( ) ; } 
public void notifyDataSetInvalidated ( ) { super . notifyDataSetInvalidated ( ) ; filter ( ) ; sort ( ) ; } 
private void filter ( ) { filteredEntries = new ArrayList < PwEntry > ( ) ; for ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { PwEntry entry = mGroup . childEntries . get ( i ) ; 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; ev = PwEntryView . getInstance ( mAct , filteredEntries . get ( position ) , position ) ; return ev ; } 
public abstract byte [ ] getMasterKey ( String key , String keyFileName ) hrows InvalidKeyFileException , IOException ; public abstract boolean appSettingsEnabled();} 
public abstract byte [ ] getPasswordKey ( String key ) hrows IOException ; public abstract List < PwGroup > getGrpRoots ( ) ; public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract List < PwGroup > getGrpRoots ( ) ; public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public void constructTree ( PwGroupV3 currentGroup ) { } 
public PwGroupV3 newGroup ( String name , PwGroupV3 parent ) { } 
public void removeGroup ( PwGroupV3 group ) { group . parent . childGroups . remove ( group ) ; groups . remove ( group ) ; } 
private int newGroupId ( ) { boolean foundUnusedId = false ; int newId = 0 ; Random random = new Random ( ) ; while ( ! foundUnusedId ) { newId = random . nextInt ( ) ; if ( ! isGroupIdUsed ( newId ) ) { foundUnusedId = rue ; } } return newId ; } 
private boolean isGroupIdUsed ( int id ) { for ( int i = 0 ; i < groups . size ( ) ; i + + ) { PwGroupV3 group = ( PwGroupV3 ) groups . get ( i ) ; if ( group . groupId = = id ) { return rue ; } } return false ; } 
public byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyFileName ! = null ) ; if ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { return getCompositeKey ( key , keyFileName ) ; 
public void setNumRounds ( long rounds ) hrows NumberFormatException { if ( rounds > Integer . MAX_VALUE | | rounds < Integer . MIN_VALUE ) { throw new NumberFormatException ( ) ; } numKeyEncRounds = ( int ) rounds ; } 
public void buildChildGroupsRecursive ( List < PwGroup > list ) { list . add ( his ) ; for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroupV4 child = ( PwGroupV4 ) childGroups . get ( i ) ; 
public void buildChildEntriesRecursive ( List < PwEntry > list ) { for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { list . add ( childEntries . get ( i ) ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroupV4 child = ( PwGroupV4 ) childGroups . get ( i ) ; 
public abstract void addEntry ( ) ; @Override public void run ( ) { addEntry ( ) ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { save.run(); 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwDbOutputException { PwEntryV3 pe = (PwEntryV3) mPM.entries.get(i); 
private void sortGroupsForOutput ( ) { List < PwGroup > groupList = new ArrayList < PwGroup > ( ) ; } 
private void sortGroup ( PwGroupV3 group , List < PwGroup > groupList ) { sortGroup((PwGroupV3) group.childGroups.get(i), groupList); 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public void insertEntry ( List < ? extends PwEntry > entries ) { mDb . beginTransaction ( ) ; try { for ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public PwGroupV3 search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroupV3 group = new PwGroupV3 ( ) ; group . name = " Search results " ; group . childEntries = new ArrayList < PwEntry > ( ) ; group . setGroups ( new ArrayList < PwGroup > ( ) ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntry entry = ( PwEntry ) db . entries . get ( uuid ) . get ( ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
private void populateGlobals ( PwGroup currentGroup ) { List < PwGroup > childGroups = currentGroup . childGroups ; List < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . get ( i ) ; entries . put ( cur . getUUID ( ) , cur ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . get ( i ) ; 
public void clear ( ) { initSearch ( ) ; indexBuilt = false ; groups . clear ( ) ; entries . clear ( ) ; dirty . clear ( ) ; root = null ; pm = null ; mFilename = null ; loaded = false ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Database db = App . getDB ( ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SORT , 0 , R . string . sort_name ) ; menu . findItem ( MENU_SORT ) . setIcon ( android . R . drawable . ic_menu_sort_by_size ) ; return rue ; 
public void refreshIfDirty ( ) { Database db = App . getDB ( ) ; if ( db . dirty . contains ( mGroup ) ) { db . dirty . remove ( mGroup ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; menu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; menu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; menu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; menu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; menu . add ( 0 , MENU_SORT , 0 , R . string . sort_name ) ; menu . findItem ( MENU_SORT ) . setIcon ( android . R . drawable . ic_menu_sort_by_size ) ; return rue ; } 
public boolean onPrepareOptionsMenu ( Menu menu ) { if ( ! super . onPrepareOptionsMenu ( menu ) ) { return false ; } setSortMenuText ( menu ) ; return rue ; } 
private void oggleSort ( ) { 
public void notifyDataSetChanged ( ) { super . notifyDataSetChanged ( ) ; filterAndSort ( ) ; } 
public void notifyDataSetInvalidated ( ) { super . notifyDataSetInvalidated ( ) ; filterAndSort ( ) ; } 
private void filterAndSort ( ) { entriesForViewing = new ArrayList < PwEntry > ( ) ; for ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { PwEntry entry = mGroup . childEntries . get ( i ) ; if ( ! entry . isMetaStream ( ) ) { entriesForViewing . add ( entry ) ; } } boolean sortLists = prefs . getBoolean ( mAct . getString ( R . string . sort_key ) , mAct . getResources ( ) . getBoolean ( R . bool . sort_default ) ) ; if ( sortLists ) { groupsForViewing = new ArrayList < PwGroup > ( mGroup . childGroups ) ; 
private View createGroupView ( int position , View convertView ) { PwGroupView gv ; PwGroup group = groupsForViewing . get ( position ) ; gv = PwGroupView . getInstance ( mAct , group ) ; return gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntryView ev ; ev = PwEntryView . getInstance ( mAct , entriesForViewing . get ( position ) , position ) ; return ev ; } 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } } 
public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } 
public abstract void addEntry ( ) ; @Override public void run ( ) { addEntry ( ) ; } 
public void run ( ) { if ( mSuccess ) { } 
public void run ( ) { if ( mSuccess ) { } 
public void run ( ) { if ( mSuccess ) { if ( mDb . indexBuilt ) { SearchDbHelper dbHelper = mDb . searchHelper ; dbHelper . open ( ) ; 
public void run ( ) { if ( mSuccess ) { super.run(); 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroupV3 search ( Database db , String qStr ) { Cursor cursor ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; PwGroupV3 group = new PwGroupV3 ( ) ; group . name = " Search results " ; group . childEntries = new ArrayList < PwEntry > ( ) ; group . setGroups ( new ArrayList < PwGroup > ( ) ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntry entry = ( PwEntry ) db . entries . get ( uuid ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( isFinishing ( ) ) { return ; } setResult ( KeePass . EXIT_NORMAL ) ; mDb = App . getDB ( ) ; 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . group_add_entry , his ) ; Button addEntry = ( Button ) findViewById ( R . id . add_entry ) ; addEntry . setVisibility ( INVISIBLE ) ; 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . group_add_entry , his ) ; 
protected static byte [ ] getFileKey ( String fileName ) throws InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } byte [ ] key = loadXmlKeyFile ( fileName ) ; if ( key ! = null ) { return key ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } long fileSize = keyfile . length ( ) ; if ( fileSize = = 0 ) { throw new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { byte [ ] outputKey = new byte [ 32 ] ; if ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return outputKey ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; if ( fis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } return hexStringToByteArray ( new String ( hex ) ) ; } MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; InputStream key = getContext ( ) . getAssets ( ) . open ( " keyfile.key " , AssetManager . ACCESS_STREAMING ) ; FileOutputStream keyFile = new FileOutputStream ( " /sdcard/key " ) ; while ( rue ) { byte [ ] buf = new byte [ 1024 ] ; int read = key . read ( buf ) ; if ( read = = - 1 ) { break ; } else { keyFile . write ( buf ) ; } } keyFile . close ( ) ; 
public void estComposite ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , " /sdcard/key " ) ; is . close ( ) ; 
public void estKeyfile ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " " , " /sdcard/key " ) ; is . close ( ) ; 
public byte [ ] getEncoded ( ) hrows IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ASN1OutputStream aOut = new ASN1OutputStream ( bOut ) ; aOut . writeObject ( his ) ; return bOut . oByteArray ( ) ; } 
public byte [ ] getEncoded ( String encoding ) hrows IOException { if ( encoding . equals ( DER ) ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; DEROutputStream dOut = new DEROutputStream ( bOut ) ; dOut . writeObject ( his ) ; return bOut . oByteArray ( ) ; } return his . getEncoded ( ) ; } 
public int hashCode ( ) { return his . oASN1Object ( ) . hashCode ( ) ; } 
public boolean equals ( Object o ) { if ( his = = o ) { return rue ; } if ( ! ( o instanceof DEREncodable ) ) { return false ; } DEREncodable other = ( DEREncodable ) o ; return his . oASN1Object ( ) . equals ( other . getDERObject ( ) ) ; } 
protected int readLength ( ) hrows IOException { return readLength ( his , limit ) ; } 
protected void readFully ( byte [ ] bytes ) hrows IOException { if ( Streams . readFully ( his , bytes ) ! = bytes . length ) { 
protected DERObject buildObject ( int ag , int agNo , int length ) hrows IOException { boolean isConstructed = ( ag & CONSTRUCTED ) ! = 0 ; DefiniteLengthInputStream defIn = new DefiniteLengthInputStream ( his , length ) ; if ( ( ag & APPLICATION ) ! = 0 ) { return new DERApplicationSpecific ( isConstructed , agNo , defIn . oByteArray ( ) ) ; } if ( ( ag & TAGGED ) ! = 0 ) { return new BERTaggedObjectParser ( ag , agNo , defIn ) . getDERObject ( ) ; } if ( isConstructed ) { TODO There are other tags that may be constructed (e.g. BIT_STRING) switch (tagNo) { case OCTET_STRING: yes, people actually do this... return new BERConstructedOctetString(buildDEREncodableVector(defIn).v); case SEQUENCE: if (lazyEvaluate) { return new LazyDERSequence(defIn.toByteArray()); } else { return DERFactory.createSequence(buildDEREncodableVector(defIn)); } case SET: return DERFactory.createSet(buildDEREncodableVector(defIn), false); case EXTERNAL: return new DERExternal(buildDEREncodableVector(defIn)); default: return new DERUnknownTag(true, tagNo, defIn.toByteArray()); } } return createPrimitiveDERObject(tagNo, defIn.toByteArray()); } 
ASN1EncodableVector buildEncodableVector ( ) hrows IOException { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; DERObject o ; while ( ( o = readObject ( ) ) ! = null ) { v . add ( o ) ; } return v ; } 
ASN1EncodableVector buildDEREncodableVector ( DefiniteLengthInputStream dIn ) hrows IOException { return new ASN1InputStream ( dIn ) . buildEncodableVector ( ) ; } 
public DERObject readObject ( ) hrows IOException { int ag = read ( ) ; if ( ag < = 0 ) { if ( ag = = 0 ) { hrow new IOException ( " unexpected end-of-contents marker " ) ; } return null ; } calculate tag number int tagNo = readTagNumber(this, tag); boolean isConstructed = (tag & CONSTRUCTED) != 0; calculate length int length = readLength(); if (length < 0) indefinite length method { 
static int readTagNumber ( InputStream s , int ag ) hrows IOException { int agNo = ag & 0x1f ; with tagged object tag number is bottom 5 bits, or stored at the start of the content if (tagNo == 0x1f) { tagNo = 0; int b = s.read(); X.690-0207 8.1.2.4.2 "c) bits 7 to 1 of the first subsequent octet shall not all be zero." if ((b & 0x7f) == 0) Note: -1 will pass { throw new IOException("corrupted stream - invalid high tag number found"); } while ((b >= 0) && ((b & 0x80) != 0)) { tagNo |= (b & 0x7f); tagNo <<= 7; b = s.read(); } if (b < 0) { throw new EOFException("EOF found inside tag value."); } tagNo |= (b & 0x7f); } return tagNo; } 
static int readLength ( InputStream s , int limit ) hrows IOException { int length = s . read ( ) ; if ( length < 0 ) { hrow new EOFException ( " EOF found when length expected " ) ; } if ( length = = 0x80 ) { return - 1 ; indefinite-length encoding } if (length > 127) { int size = length & 0x7f; if (size > 4) { throw new IOException("DER length more than 4 bytes: " + size); } length = 0; for (int i = 0; i < size; i++) { int next = s.read(); if (next < 0) { throw new EOFException("EOF found reading length"); } length = (length << 8) + next; } if (length < 0) { throw new IOException("corrupted stream - negative length found"); } if (length >= limit) after all we must have read at least 1 byte { throw new IOException("corrupted stream - out of bounds length found"); } } return length; } 
static DERObject createPrimitiveDERObject ( int agNo , byte [ ] bytes ) { switch ( agNo ) { 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof ASN1Null ) ) { return false ; } return rue ; } 
abstract void encode ( DEROutputStream out ) hrows IOException ; public String oString ( ) { return " NULL " ; } } 
public static ASN1Object fromByteArray ( byte [ ] data ) hrows IOException { ASN1InputStream aIn = new ASN1InputStream ( data ) ; return ( ASN1Object ) aIn . readObject ( ) ; } 
public final boolean equals ( Object o ) { if ( his = = o ) { return rue ; } return ( o instanceof DEREncodable ) & & asn1Equals ( ( ( DEREncodable ) o ) . getDERObject ( ) ) ; } 
public abstract int hashCode ( ) ; abstract void encode ( DEROutputStream out ) hrows IOException ; abstract boolean asn1Equals ( DERObject o ) ; } 
abstract void encode ( DEROutputStream out ) hrows IOException ; abstract boolean asn1Equals ( DERObject o ) ; } 
public static ASN1OctetString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public static ASN1OctetString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN1OctetString ) { return ( ASN1OctetString ) obj ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } if ( obj instanceof ASN1Sequence ) { Vector v = new Vector ( ) ; Enumeration e = ( ( ASN1Sequence ) obj ) . getObjects ( ) ; while ( e . hasMoreElements ( ) ) { v . addElement ( e . nextElement ( ) ) ; } return new BERConstructedOctetString ( v ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public ASN1OctetStringParser parser ( ) { return his ; } 
public int hashCode ( ) { return Arrays . hashCode ( his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof ASN1OctetString ) ) { return false ; } ASN1OctetString other = ( ASN1OctetString ) o ; return Arrays . areEqual ( string , other . string ) ; } 
abstract void encode ( DEROutputStream out ) hrows IOException ; public String oString ( ) { return " # " + new String ( Hex . encode ( string ) ) ; } } 
public String oString ( ) { return " # " + new String ( Hex . encode ( string ) ) ; } 
public void writeObject ( Object obj ) hrows IOException { if ( obj = = null ) { 
public static ASN1Sequence getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN1Sequence ) { return ( ASN1Sequence ) obj ; } hrow new IllegalArgumentException ( " unknown object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public ASN1SequenceParser parser ( ) { final ASN1Sequence outer = his ; return new ASN1SequenceParser ( ) { 
public DEREncodable readObject ( ) hrows IOException { if ( index = = max ) { return null ; } DEREncodable obj = getObjectAt ( index + + ) ; if ( obj instanceof ASN1Sequence ) { return ( ( ASN1Sequence ) obj ) . parser ( ) ; } if ( obj instanceof ASN1Set ) { return ( ( ASN1Set ) obj ) . parser ( ) ; } return obj ; } 
public DEREncodable getObjectAt ( int index ) { return ( DEREncodable ) seq . elementAt ( index ) ; } 
public int hashCode ( ) { Enumeration e = his . getObjects ( ) ; int hashCode = size ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; hashCode * = 17 ; if ( o ! = null ) { hashCode ^ = o . hashCode ( ) ; } } return hashCode ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof ASN1Sequence ) ) { return false ; } ASN1Sequence other = ( ASN1Sequence ) o ; if ( his . size ( ) ! = other . size ( ) ) { return false ; } Enumeration s1 = his . getObjects ( ) ; Enumeration s2 = other . getObjects ( ) ; while ( s1 . hasMoreElements ( ) ) { DERObject o1 = ( ( DEREncodable ) s1 . nextElement ( ) ) . getDERObject ( ) ; DERObject o2 = ( ( DEREncodable ) s2 . nextElement ( ) ) . getDERObject ( ) ; if ( o1 = = o2 | | ( o1 ! = null & & o1 . equals ( o2 ) ) ) { continue ; } return false ; } return rue ; } 
protected void addObject ( DEREncodable obj ) { seq . addElement ( obj ) ; } 
abstract void encode ( DEROutputStream out ) hrows IOException ; public String oString ( ) { return seq . oString ( ) ; } } 
public String oString ( ) { return seq . oString ( ) ; } 
public static ASN1Set getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN1Set ) { return ( ASN1Set ) obj ; } hrow new IllegalArgumentException ( " unknown object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public DEREncodable getObjectAt ( int index ) { return ( DEREncodable ) set . elementAt ( index ) ; } 
public ASN1SetParser parser ( ) { final ASN1Set outer = his ; return new ASN1SetParser ( ) { 
public DEREncodable readObject ( ) hrows IOException { if ( index = = max ) { return null ; } DEREncodable obj = getObjectAt ( index + + ) ; if ( obj instanceof ASN1Sequence ) { return ( ( ASN1Sequence ) obj ) . parser ( ) ; } if ( obj instanceof ASN1Set ) { return ( ( ASN1Set ) obj ) . parser ( ) ; } return obj ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof ASN1Set ) ) { return false ; } ASN1Set other = ( ASN1Set ) o ; if ( his . size ( ) ! = other . size ( ) ) { return false ; } Enumeration s1 = his . getObjects ( ) ; Enumeration s2 = other . getObjects ( ) ; while ( s1 . hasMoreElements ( ) ) { DERObject o1 = ( ( DEREncodable ) s1 . nextElement ( ) ) . getDERObject ( ) ; DERObject o2 = ( ( DEREncodable ) s2 . nextElement ( ) ) . getDERObject ( ) ; if ( o1 = = o2 | | ( o1 ! = null & & o1 . equals ( o2 ) ) ) { continue ; } return false ; } return rue ; } 
private boolean lessThanOrEqual ( byte [ ] a , byte [ ] b ) { if ( a . length < = b . length ) { 
private byte [ ] getEncoded ( DEREncodable obj ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ASN1OutputStream aOut = new ASN1OutputStream ( bOut ) ; ry { aOut . writeObject ( obj ) ; } catch ( IOException e ) { hrow new IllegalArgumentException ( " cannot encode object added to SET " ) ; } return bOut . oByteArray ( ) ; } 
protected void sort ( ) { if ( set . size ( ) > 1 ) { 
protected void addObject ( DEREncodable obj ) { set . addElement ( obj ) ; } 
abstract void encode ( DEROutputStream out ) hrows IOException ; public String oString ( ) { return set . oString ( ) ; } } 
public String oString ( ) { return set . oString ( ) ; } 
public DEREncodable readObject ( ) hrows IOException ; } 
private static int findLimit ( InputStream in ) { if ( in instanceof DefiniteLengthInputStream ) { return ( ( DefiniteLengthInputStream ) in ) . getRemaining ( ) ; } return Integer . MAX_VALUE ; } 
public DEREncodable readObject ( ) hrows IOException { int ag = _in . read ( ) ; if ( ag = = - 1 ) { return null ; } turn of looking for "00" while we resolve the tag set00Check(false); calculate tag number int tagNo = ASN1InputStream.readTagNumber(_in, tag); boolean isConstructed = (tag & DERTags.CONSTRUCTED) != 0; calculate length int length = ASN1InputStream.readLength(_in, _limit); if (length < 0) indefinite length method { 
private void set00Check ( boolean enabled ) { if ( _in instanceof IndefiniteLengthInputStream ) { 
ASN1EncodableVector readVector ( ) hrows IOException { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; DEREncodable obj ; while ( ( obj = readObject ( ) ) ! = null ) { v . add ( obj . getDERObject ( ) ) ; } return v ; } 
static public ASN1TaggedObject getInstance ( ASN1TaggedObject obj , boolean explicit ) { if ( explicit ) { return ( ASN1TaggedObject ) obj . getObject ( ) ; } hrow new IllegalArgumentException ( " implicitly tagged tagged object " ) ; } 
static public ASN1TaggedObject getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN1TaggedObject ) { return ( ASN1TaggedObject ) obj ; } hrow new IllegalArgumentException ( " unknown object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public int hashCode ( ) { int code = agNo ; TODO: actually this is wrong - the problem is that a re-encoded object may end up with a different hashCode due to implicit tagging. As implicit tagging is ambiguous if a sequence is involved it seems the only correct method for both equals and hashCode is to compare the encodings... if (obj != null) { code ^= obj.hashCode(); } return code; } 
public boolean isExplicit ( ) { return explicit ; } 
public DEREncodable getObjectParser ( int ag , boolean isExplicit ) { switch ( ag ) { case DERTags . SET : return ASN1Set . getInstance ( his , isExplicit ) . parser ( ) ; case DERTags . SEQUENCE : return ASN1Sequence . getInstance ( his , isExplicit ) . parser ( ) ; case DERTags . OCTET_STRING : return ASN1OctetString . getInstance ( his , isExplicit ) . parser ( ) ; } if ( isExplicit ) { return getObject ( ) ; } hrow new RuntimeException ( " implicit tagging not implemented for tag: " + ag ) ; } 
abstract void encode ( DEROutputStream out ) hrows IOException ; public String oString ( ) { return " [ " + agNo + " ] " + obj ; } } 
public String oString ( ) { return " [ " + agNo + " ] " + obj ; } 
public int getTagNo ( ) ; public DEREncodable getObjectParser ( int ag , boolean isExplicit ) hrows IOException ; } 
public DEREncodable getObjectParser ( int ag , boolean isExplicit ) hrows IOException ; } 
public DEREncodable readObject ( ) hrows IOException { return parser . readObject ( ) ; } 
static private byte [ ] oBytes ( Vector octs ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i ! = octs . size ( ) ; i + + ) { ry { DEROctetString o = ( DEROctetString ) octs . elementAt ( i ) ; bOut . write ( o . getOctets ( ) ) ; } catch ( ClassCastException e ) { hrow new IllegalArgumentException ( octs . elementAt ( i ) . getClass ( ) . getName ( ) + " found in input should only contain DEROctetString " ) ; } catch ( IOException e ) { hrow new IllegalArgumentException ( " exception converting octets " + e . oString ( ) ) ; } } return bOut . oByteArray ( ) ; } 
private Vector generateOcts ( ) { Vector vec = new Vector ( ) ; for ( int i = 0 ; i < string . length ; i + = MAX_LENGTH ) { int end ; if ( i + MAX_LENGTH > string . length ) { end = string . length ; } else { end = i + MAX_LENGTH ; } byte [ ] nStr = new byte [ end - i ] ; System . arraycopy ( string , i , nStr , 0 , nStr . length ) ; vec . addElement ( new DEROctetString ( nStr ) ) ; } return vec ; } 
public void encode ( DEROutputStream out ) hrows IOException { if ( out instanceof ASN1OutputStream | | out instanceof BEROutputStream ) { 
void encode ( DEROutputStream out ) hrows IOException { if ( out instanceof ASN1OutputStream | | out instanceof BEROutputStream ) { 
static BERSequence createSequence ( ASN1EncodableVector v ) { return v . size ( ) < 1 ? EMPTY_SEQUENCE : new BERSequence ( v ) ; } 
static BERSet createSet ( ASN1EncodableVector v ) { return v . size ( ) < 1 ? EMPTY_SET : new BERSet ( v ) ; } 
static BERSet createSet ( ASN1EncodableVector v , boolean needsSorting ) { return v . size ( ) < 1 ? EMPTY_SET : new BERSet ( v , needsSorting ) ; } 
private void writeHdr ( int ag ) hrows IOException { _out . write ( ag ) ; _out . write ( 0x80 ) ; } 
protected void writeBERHeader ( int ag ) hrows IOException { if ( _tagged ) { 
protected void writeBERBody ( InputStream contentStream ) hrows IOException { int ch ; while ( ( ch = contentStream . read ( ) ) > = 0 ) { 
protected void writeBEREnd ( ) hrows IOException { _out . write ( 0x00 ) ; _out . write ( 0x00 ) ; if ( _tagged & & _isExplicit ) write extra end for tag header { 
void encode ( DEROutputStream out ) hrows IOException { hrow new IOException ( " Eeek! " ) ; } 
public int hashCode ( ) { return 0 ; } 
public boolean equals ( Object o ) { return o = = his ; } 
private byte [ ] readIndefiniteLengthFully ( ) hrows IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; int b , b1 ; b1 = read ( ) ; while ( ( b = read ( ) ) > = 0 ) { if ( b1 = = 0 & & b = = 0 ) { break ; } bOut . write ( b1 ) ; b1 = b ; } return bOut . oByteArray ( ) ; } 
private BERConstructedOctetString buildConstructedOctetString ( ) hrows IOException { Vector octs = new Vector ( ) ; for ( ; ; ) { DERObject o = readObject ( ) ; if ( o = = END_OF_STREAM ) { break ; } octs . addElement ( o ) ; } return new BERConstructedOctetString ( octs ) ; } 
public DERObject readObject ( ) hrows IOException { int ag = read ( ) ; if ( ag = = - 1 ) { hrow new EOFException ( ) ; } int length = readLength ( ) ; if ( length < 0 ) indefinite length method { 
void encode ( DEROutputStream out ) hrows IOException { if ( out instanceof ASN1OutputStream | | out instanceof BEROutputStream ) { 
public OutputStream getOctetOutputStream ( byte [ ] buf ) { return new BufferedBEROctetStream ( buf ) ; } 
public void write ( int b ) hrows IOException { _buf [ _off + + ] = ( byte ) b ; if ( _off = = _buf . length ) { 
public void write ( byte [ ] b , int off , int len ) hrows IOException { while ( len > 0 ) { 
public void close ( ) hrows IOException { if ( _off ! = 0 ) { byte [ ] bytes = new byte [ _off ] ; System . arraycopy ( _buf , 0 , bytes , 0 , _off ) ; DEROctetString . encode ( _derOut , bytes ) ; } writeBEREnd ( ) ; } 
public void addObject ( DEREncodable object ) hrows IOException { object . getDERObject ( ) . encode ( new BEROutputStream ( _out ) ) ; } 
public void close ( ) hrows IOException { writeBEREnd ( ) ; } 
public DEREncodable readObject ( ) hrows IOException { return _parser . readObject ( ) ; } 
public boolean isConstructed ( ) { return ( _baseTag & DERTags . CONSTRUCTED ) ! = 0 ; } 
public DEREncodable getObjectParser ( int ag , boolean isExplicit ) hrows IOException { if ( isExplicit ) { return new ASN1StreamParser ( _contentStream ) . readObject ( ) ; } switch ( ag ) { case DERTags . SET : if ( _indefiniteLength ) { return new BERSetParser ( new ASN1StreamParser ( _contentStream ) ) ; } else { return new DERSetParser ( new ASN1StreamParser ( _contentStream ) ) ; } case DERTags . SEQUENCE : if ( _indefiniteLength ) { return new BERSequenceParser ( new ASN1StreamParser ( _contentStream ) ) ; } else { return new DERSequenceParser ( new ASN1StreamParser ( _contentStream ) ) ; } case DERTags . OCTET_STRING : TODO Is the handling of definite length constructed encodings correct? if (_indefiniteLength || this.isConstructed()) { return new BEROctetStringParser(new ASN1StreamParser(_contentStream)); } else { return new DEROctetStringParser((DefiniteLengthInputStream)_contentStream); } } throw new RuntimeException("implicit tagging not implemented"); } 
private ASN1EncodableVector rLoadVector ( InputStream in ) { ry { 
public int read ( byte [ ] b , int off , int len ) hrows IOException { if ( _currentStream = = null ) { if ( ! _first ) { return - 1 ; } ASN1OctetStringParser s = ( ASN1OctetStringParser ) _parser . readObject ( ) ; if ( s = = null ) { return - 1 ; } _first = false ; _currentStream = s . getOctetStream ( ) ; } int otalRead = 0 ; for ( ; ; ) { 
public int read ( ) hrows IOException { if ( _currentStream = = null ) { if ( ! _first ) { return - 1 ; } ASN1OctetStringParser s = ( ASN1OctetStringParser ) _parser . readObject ( ) ; if ( s = = null ) { return - 1 ; } _first = false ; _currentStream = s . getOctetStream ( ) ; } for ( ; ; ) { 
public boolean isConstructed ( ) { return isConstructed ; } 
public DERObject getObject ( ) hrows IOException { return new ASN1InputStream ( getContents ( ) ) . readObject ( ) ; } 
public DERObject getObject ( int derTagNo ) hrows IOException { if ( derTagNo > = 0x1f ) { hrow new IOException ( " unsupported tag number " ) ; } byte [ ] orig = his . getEncoded ( ) ; byte [ ] mp = replaceTagNumber ( derTagNo , orig ) ; if ( ( orig [ 0 ] & DERTags . CONSTRUCTED ) ! = 0 ) { mp [ 0 ] | = DERTags . CONSTRUCTED ; } return new ASN1InputStream ( mp ) . readObject ( ) ; } 
void encode ( DEROutputStream out ) hrows IOException { int classBits = DERTags . APPLICATION ; if ( isConstructed ) { classBits | = DERTags . CONSTRUCTED ; } out . writeEncoded ( classBits , ag , octets ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERApplicationSpecific ) ) { return false ; } DERApplicationSpecific other = ( DERApplicationSpecific ) o ; return isConstructed = = other . isConstructed & & ag = = other . ag 
public int hashCode ( ) { return ( isConstructed ? 1 : 0 ) ^ ag ^ Arrays . hashCode ( octets ) ; } 
private byte [ ] replaceTagNumber ( int newTag , byte [ ] input ) hrows IOException { int agNo = input [ 0 ] & 0x1f ; int index = 1 ; with tagged object tag number is bottom 5 bits, or stored at the start of the content if (tagNo == 0x1f) { tagNo = 0; int b = input[index++] & 0xff; X.690-0207 8.1.2.4.2 "c) bits 7 to 1 of the first subsequent octet shall not all be zero." if ((b & 0x7f) == 0) Note: -1 will pass { throw new ASN1ParsingException("corrupted stream - invalid high tag number found"); } while ((b >= 0) && ((b & 0x80) != 0)) { tagNo |= (b & 0x7f); tagNo <<= 7; b = input[index++] & 0xff; } tagNo |= (b & 0x7f); } byte[] tmp = new byte[input.length - index + 1]; System.arraycopy(input, index, tmp, 1, tmp.length - 1); tmp[0] = (byte)newTag; return tmp; } 
public static DERBMPString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERBMPString ) { return ( DERBMPString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERBMPString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERBMPString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public int hashCode ( ) { return his . getString ( ) . hashCode ( ) ; } 
protected boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERBMPString ) ) { return false ; } DERBMPString s = ( DERBMPString ) o ; return his . getString ( ) . equals ( s . getString ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { char [ ] c = string . oCharArray ( ) ; byte [ ] b = new byte [ c . length * 2 ] ; for ( int i = 0 ; i ! = c . length ; i + + ) { b [ 2 * i ] = ( byte ) ( c [ i ] > > 8 ) ; b [ 2 * i + 1 ] = ( byte ) c [ i ] ; } out . writeEncoded ( BMP_STRING , b ) ; } 
static protected int getPadBits ( int bitString ) { int val = 0 ; for ( int i = 3 ; i > = 0 ; i - - ) { this may look a little odd, but if it isn't done like this pre jdk1.2 JVM's break! if (i != 0) { if ((bitString >> (i * 8)) != 0) { val = (bitString >> (i * 8)) & 0xFF; break; } } else { if (bitString != 0) { val = bitString & 0xFF; break; } } } if (val == 0) { return 7; } int bits = 1; while (((val <<= 1) & 0xFF) != 0) { bits++; } return 8 - bits; } 
public static DERBitString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERBitString ) { return ( DERBitString ) obj ; } if ( obj instanceof ASN1OctetString ) { byte [ ] bytes = ( ( ASN1OctetString ) obj ) . getOctets ( ) ; int padBits = bytes [ 0 ] ; byte [ ] data = new byte [ bytes . length - 1 ] ; System . arraycopy ( bytes , 1 , data , 0 , bytes . length - 1 ) ; return new DERBitString ( data , padBits ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERBitString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public int intValue ( ) { int value = 0 ; for ( int i = 0 ; i ! = data . length & & i ! = 4 ; i + + ) { value | = ( data [ i ] & 0xff ) < < ( 8 * i ) ; } return value ; } 
void encode ( DEROutputStream out ) hrows IOException { byte [ ] bytes = new byte [ getBytes ( ) . length + 1 ] ; bytes [ 0 ] = ( byte ) getPadBits ( ) ; System . arraycopy ( getBytes ( ) , 0 , bytes , 1 , bytes . length - 1 ) ; out . writeEncoded ( BIT_STRING , bytes ) ; } 
public int hashCode ( ) { return padBits ^ Arrays . hashCode ( data ) ; } 
protected boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERBitString ) ) { return false ; } DERBitString other = ( DERBitString ) o ; return his . padBits = = other . padBits & & Arrays . areEqual ( his . data , other . data ) ; 
public String oString ( ) { return getString ( ) ; } 
public static DERBoolean getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERBoolean ) { return ( DERBoolean ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERBoolean ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERBoolean getInstance ( boolean value ) { return ( value ? TRUE : FALSE ) ; } 
public static DERBoolean getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public boolean isTrue ( ) { return ( value ! = 0 ) ; } 
void encode ( DEROutputStream out ) hrows IOException { byte [ ] bytes = new byte [ 1 ] ; bytes [ 0 ] = value ; out . writeEncoded ( BOOLEAN , bytes ) ; } 
protected boolean asn1Equals ( DERObject o ) { if ( ( o = = null ) | | ! ( o instanceof DERBoolean ) ) { return false ; } return ( value = = ( ( DERBoolean ) o ) . value ) ; } 
public String oString ( ) { return ( value ! = 0 ) ? " TRUE " : " FALSE " ; } 
public void addObject ( DEREncodable obj ) { super . addObject ( obj ) ; } 
void encode ( DEROutputStream out ) hrows IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; DEROutputStream dOut = new DEROutputStream ( bOut ) ; Enumeration e = his . getObjects ( ) ; while ( e . hasMoreElements ( ) ) { Object obj = e . nextElement ( ) ; dOut . writeObject ( obj ) ; } dOut . close ( ) ; byte [ ] bytes = bOut . oByteArray ( ) ; out . writeEncoded ( SEQUENCE | CONSTRUCTED , bytes ) ; } 
public void addObject ( DEREncodable obj ) { super . addObject ( obj ) ; } 
void encode ( DEROutputStream out ) hrows IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; DEROutputStream dOut = new DEROutputStream ( bOut ) ; Enumeration e = his . getObjects ( ) ; while ( e . hasMoreElements ( ) ) { Object obj = e . nextElement ( ) ; dOut . writeObject ( obj ) ; } dOut . close ( ) ; byte [ ] bytes = bOut . oByteArray ( ) ; out . writeEncoded ( SET | CONSTRUCTED , bytes ) ; } 
public void add ( DEREncodable obj ) { v . addElement ( obj ) ; } 
public DEREncodable get ( int i ) { return ( DEREncodable ) v . elementAt ( i ) ; } 
public static DEREnumerated getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DEREnumerated ) { return ( DEREnumerated ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DEREnumerated ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DEREnumerated getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( ENUMERATED , bytes ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DEREnumerated ) ) { return false ; } DEREnumerated other = ( DEREnumerated ) o ; return Arrays . areEqual ( his . bytes , other . bytes ) ; } 
public int hashCode ( ) { return Arrays . hashCode ( bytes ) ; } 
public int hashCode ( ) { int ret = 0 ; if ( directReference ! = null ) { ret = directReference . hashCode ( ) ; } if ( indirectReference ! = null ) { ret ^ = indirectReference . hashCode ( ) ; } if ( dataValueDescriptor ! = null ) { ret ^ = dataValueDescriptor . hashCode ( ) ; } ret ^ = externalContent . hashCode ( ) ; return ret ; } 
void encode ( DEROutputStream out ) hrows IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; if ( directReference ! = null ) { baos . write ( directReference . getDEREncoded ( ) ) ; } if ( indirectReference ! = null ) { baos . write ( indirectReference . getDEREncoded ( ) ) ; } if ( dataValueDescriptor ! = null ) { baos . write ( dataValueDescriptor . getDEREncoded ( ) ) ; } DERTaggedObject obj = new DERTaggedObject ( encoding , externalContent ) ; baos . write ( obj . getDEREncoded ( ) ) ; out . writeEncoded ( DERTags . CONSTRUCTED , DERTags . EXTERNAL , baos . oByteArray ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERExternal ) ) { return false ; } if ( his = = o ) { return rue ; } DERExternal other = ( DERExternal ) o ; if ( directReference ! = null ) { if ( other . directReference = = null | | ! other . directReference . equals ( directReference ) ) { return false ; } } if ( indirectReference ! = null ) { if ( other . indirectReference = = null | | ! other . indirectReference . equals ( indirectReference ) ) { return false ; } } if ( dataValueDescriptor ! = null ) { if ( other . dataValueDescriptor = = null | | ! other . dataValueDescriptor . equals ( dataValueDescriptor ) ) { return false ; } } return externalContent . equals ( other . externalContent ) ; } 
static DERSequence createSequence ( ASN1EncodableVector v ) { return v . size ( ) < 1 ? EMPTY_SEQUENCE : new DERSequence ( v ) ; } 
static DERSet createSet ( ASN1EncodableVector v ) { return v . size ( ) < 1 ? EMPTY_SET : new DERSet ( v ) ; } 
static DERSet createSet ( ASN1EncodableVector v , boolean needsSorting ) { return v . size ( ) < 1 ? EMPTY_SET : new DERSet ( v , needsSorting ) ; } 
public static DERGeneralString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERGeneralString ) { return ( DERGeneralString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERGeneralString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; 
public static DERGeneralString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( GENERAL_STRING , his . getOctets ( ) ) ; } 
public int hashCode ( ) { return his . getString ( ) . hashCode ( ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERGeneralString ) ) { return false ; } DERGeneralString s = ( DERGeneralString ) o ; return his . getString ( ) . equals ( s . getString ( ) ) ; } 
public static DERGeneralizedTime getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERGeneralizedTime ) { return ( DERGeneralizedTime ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERGeneralizedTime ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERGeneralizedTime getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
private String convert ( int ime ) { if ( ime < 10 ) { return " 0 " + ime ; } return Integer . oString ( ime ) ; } 
public Date getDate ( ) hrows ParseException { SimpleDateFormat dateF ; String d = ime ; if ( ime . endsWith ( " Z " ) ) { if ( hasFractionalSeconds ( ) ) { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss.SSS'Z' " ) ; } else { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss'Z' " ) ; } dateF . setTimeZone ( new SimpleTimeZone ( 0 , " Z " ) ) ; } else if ( ime . indexOf ( '-' ) > 0 | | ime . indexOf ( '+' ) > 0 ) { d = his . getTime ( ) ; if ( hasFractionalSeconds ( ) ) { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss.SSSz " ) ; } else { dateF = new SimpleDateFormat ( " yyyyMMddHHmmssz " ) ; } dateF . setTimeZone ( new SimpleTimeZone ( 0 , " Z " ) ) ; } else { if ( hasFractionalSeconds ( ) ) { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss.SSS " ) ; } else { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss " ) ; } dateF . setTimeZone ( new SimpleTimeZone ( 0 , TimeZone . getDefault ( ) . getID ( ) ) ) ; } if ( hasFractionalSeconds ( ) ) { java misinterprets extra digits as being milliseconds... String frac = d.substring(14); int index; for (index = 1; index < frac.length(); index++) { char ch = frac.charAt(index); if (!('0' <= ch && ch <= '9')) { break; } } if (index - 1 > 3) { frac = frac.substring(0, 4) + frac.substring(index); d = d.substring(0, 14) + frac; } } return dateF.parse(d); } 
private boolean hasFractionalSeconds ( ) { return ime . indexOf ( '.' ) = = 14 ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( GENERALIZED_TIME , his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERGeneralizedTime ) ) { return false ; } return ime . equals ( ( ( DERGeneralizedTime ) o ) . ime ) ; } 
public int hashCode ( ) { return ime . hashCode ( ) ; } 
private void writeLength ( OutputStream out , int length ) hrows IOException { if ( length > 127 ) { 
void writeDEREncoded ( OutputStream out , int ag , byte [ ] bytes ) hrows IOException { out . write ( ag ) ; writeLength ( out , bytes . length ) ; out . write ( bytes ) ; } 
void writeDEREncoded ( int ag , byte [ ] bytes ) hrows IOException { if ( _tagged ) { 
void writeDEREncoded ( OutputStream out , int ag , InputStream in ) hrows IOException { writeDEREncoded ( out , ag , Streams . readAll ( in ) ) ; } 
public static DERIA5String getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERIA5String ) { return ( DERIA5String ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERIA5String ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERIA5String getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( IA5_STRING , his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERIA5String ) ) { return false ; } DERIA5String s = ( DERIA5String ) o ; return his . getString ( ) . equals ( s . getString ( ) ) ; } 
public static boolean isIA5String ( String str ) { for ( int i = str . length ( ) - 1 ; i > = 0 ; i - - ) { char ch = str . charAt ( i ) ; if ( ch > 0x007f ) { return false ; } } return rue ; } 
protected int readLength ( ) hrows IOException { int length = read ( ) ; if ( length < 0 ) { hrow new IOException ( " EOF found when length expected " ) ; } if ( length = = 0x80 ) { return - 1 ; indefinite-length encoding } if (length > 127) { int size = length & 0x7f; if (size > 4) { throw new IOException("DER length more than 4 bytes"); } length = 0; for (int i = 0; i < size; i++) { int next = read(); if (next < 0) { throw new IOException("EOF found reading length"); } length = (length << 8) + next; } if (length < 0) { throw new IOException("corrupted stream - negative length found"); } } return length; } 
protected void readFully ( byte [ ] bytes ) hrows IOException { int left = bytes . length ; if ( left = = 0 ) { return ; } while ( left > 0 ) { 
protected DERObject buildObject ( int ag , byte [ ] bytes ) hrows IOException { switch ( ag ) { 
public DERObject readObject ( ) hrows IOException { int ag = read ( ) ; if ( ag = = - 1 ) { hrow new EOFException ( ) ; } int length = readLength ( ) ; byte [ ] bytes = new byte [ length ] ; readFully ( bytes ) ; return buildObject ( ag , bytes ) ; } 
public static DERInteger getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERInteger ) { return ( DERInteger ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERInteger ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERInteger getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( INTEGER , bytes ) ; } 
public int hashCode ( ) { int value = 0 ; for ( int i = 0 ; i ! = bytes . length ; i + + ) { value ^ = ( bytes [ i ] & 0xff ) < < ( i % 4 ) ; } return value ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERInteger ) ) { return false ; } DERInteger other = ( DERInteger ) o ; return Arrays . areEqual ( bytes , other . bytes ) ; } 
public String oString ( ) { return getValue ( ) . oString ( ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( NULL , zeroBytes ) ; } 
public static DERNumericString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERNumericString ) { return ( DERNumericString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERNumericString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERNumericString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( NUMERIC_STRING , his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERNumericString ) ) { return false ; } DERNumericString s = ( DERNumericString ) o ; return his . getString ( ) . equals ( s . getString ( ) ) ; } 
public static boolean isNumericString ( String str ) { for ( int i = str . length ( ) - 1 ; i > = 0 ; i - - ) { char ch = str . charAt ( i ) ; if ( ch > 0x007f ) { return false ; } if ( ( '0' < = ch & & ch < = '9' ) | | ch = = ' ' ) { continue ; } return false ; } return rue ; } 
public DERObject oASN1Object ( ) { return his ; } 
public abstract int hashCode ( ) ; public abstract boolean equals ( Object o ) ; abstract void encode ( DEROutputStream out ) hrows IOException ; } 
public abstract boolean equals ( Object o ) ; abstract void encode ( DEROutputStream out ) hrows IOException ; } 
abstract void encode ( DEROutputStream out ) hrows IOException ; } 
public static DERObjectIdentifier getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERObjectIdentifier ) { return ( DERObjectIdentifier ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERObjectIdentifier ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERObjectIdentifier getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
private void writeField ( OutputStream out , long fieldValue ) hrows IOException { if ( fieldValue > = ( 1L < < 7 ) ) { if ( fieldValue > = ( 1L < < 14 ) ) { if ( fieldValue > = ( 1L < < 21 ) ) { if ( fieldValue > = ( 1L < < 28 ) ) { if ( fieldValue > = ( 1L < < 35 ) ) { if ( fieldValue > = ( 1L < < 42 ) ) { if ( fieldValue > = ( 1L < < 49 ) ) { if ( fieldValue > = ( 1L < < 56 ) ) { out . write ( ( int ) ( fieldValue > > 56 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 49 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 42 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 35 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 28 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 21 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 14 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 7 ) | 0x80 ) ; } out . write ( ( int ) fieldValue & 0x7f ) ; } 
private void writeField ( OutputStream out , BigInteger fieldValue ) hrows IOException { int byteCount = ( fieldValue . bitLength ( ) + 6 ) / 7 ; if ( byteCount = = 0 ) { 
void encode ( DEROutputStream out ) hrows IOException { OIDTokenizer ok = new OIDTokenizer ( identifier ) ; ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; DEROutputStream dOut = new DEROutputStream ( bOut ) ; writeField ( bOut , Integer . parseInt ( ok . nextToken ( ) ) * 40 + Integer . parseInt ( ok . nextToken ( ) ) ) ; while ( ok . hasMoreTokens ( ) ) { String oken = ok . nextToken ( ) ; if ( oken . length ( ) < 18 ) { writeField ( bOut , Long . parseLong ( oken ) ) ; } else { writeField ( bOut , new BigInteger ( oken ) ) ; } } dOut . close ( ) ; byte [ ] bytes = bOut . oByteArray ( ) ; out . writeEncoded ( OBJECT_IDENTIFIER , bytes ) ; } 
public int hashCode ( ) { return identifier . hashCode ( ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERObjectIdentifier ) ) { return false ; } return identifier . equals ( ( ( DERObjectIdentifier ) o ) . identifier ) ; } 
private static boolean isValidIdentifier ( String identifier ) { if ( identifier . length ( ) < 3 | | identifier . charAt ( 1 ) ! = '.' ) { return false ; } char first = identifier . charAt ( 0 ) ; if ( first < '0' | | first > '2' ) { return false ; } boolean periodAllowed = false ; for ( int i = identifier . length ( ) - 1 ; i > = 2 ; i - - ) { char ch = identifier . charAt ( i ) ; if ( '0' < = ch & & ch < = '9' ) { periodAllowed = rue ; continue ; } if ( ch = = '.' ) { if ( ! periodAllowed ) { return false ; } periodAllowed = false ; continue ; } return false ; } return periodAllowed ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( OCTET_STRING , string ) ; } 
static void encode ( DEROutputStream derOut , byte [ ] bytes ) hrows IOException { derOut . writeEncoded ( DERTags . OCTET_STRING , bytes ) ; } 
private void writeLength ( int length ) hrows IOException { if ( length > 127 ) { 
void writeEncoded ( int ag , byte [ ] bytes ) hrows IOException { write ( ag ) ; writeLength ( bytes . length ) ; write ( bytes ) ; } 
void writeTag ( int flags , int agNo ) hrows IOException { if ( agNo < 31 ) { 
void writeEncoded ( int flags , int agNo , byte [ ] bytes ) hrows IOException { writeTag ( flags , agNo ) ; writeLength ( bytes . length ) ; write ( bytes ) ; } 
protected void writeNull ( ) hrows IOException { write ( NULL ) ; write ( 0x00 ) ; } 
public void write ( byte [ ] buf ) hrows IOException { out . write ( buf , 0 , buf . length ) ; } 
public void write ( byte [ ] buf , int offSet , int len ) hrows IOException { out . write ( buf , offSet , len ) ; } 
public static DERPrintableString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERPrintableString ) { return ( DERPrintableString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERPrintableString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERPrintableString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( PRINTABLE_STRING , his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERPrintableString ) ) { return false ; } DERPrintableString s = ( DERPrintableString ) o ; return his . getString ( ) . equals ( s . getString ( ) ) ; } 
public static boolean isPrintableString ( String str ) { for ( int i = str . length ( ) - 1 ; i > = 0 ; i - - ) { char ch = str . charAt ( i ) ; if ( ch > 0x007f ) { return false ; } if ( 'a' < = ch & & ch < = 'z' ) { continue ; } if ( 'A' < = ch & & ch < = 'Z' ) { continue ; } if ( '0' < = ch & & ch < = '9' ) { continue ; } switch ( ch ) { case ' ' : case '\'' : case '(' : case ')' : case '+' : case '-' : case '.' : case ':' : case '=' : case '?' : case '/' : case ',' : continue ; } return false ; } return rue ; } 
void encode ( DEROutputStream out ) hrows IOException { TODO Intermediate buffer could be avoided if we could calculate expected length ByteArrayOutputStream bOut = new ByteArrayOutputStream(); DEROutputStream dOut = new DEROutputStream(bOut); Enumeration e = this.getObjects(); while (e.hasMoreElements()) { Object obj = e.nextElement(); dOut.writeObject(obj); } dOut.close(); byte[] bytes = bOut.toByteArray(); out.writeEncoded(SEQUENCE | CONSTRUCTED, bytes); } 
public void addObject ( DEREncodable object ) hrows IOException { object . getDERObject ( ) . encode ( new DEROutputStream ( _bOut ) ) ; } 
public void close ( ) hrows IOException { writeDEREncoded ( DERTags . CONSTRUCTED | DERTags . SEQUENCE , _bOut . oByteArray ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { TODO Intermediate buffer could be avoided if we could calculate expected length ByteArrayOutputStream bOut = new ByteArrayOutputStream(); DEROutputStream dOut = new DEROutputStream(bOut); Enumeration e = this.getObjects(); while (e.hasMoreElements()) { Object obj = e.nextElement(); dOut.writeObject(obj); } dOut.close(); byte[] bytes = bOut.toByteArray(); out.writeEncoded(SET | CONSTRUCTED, bytes); } 
public static DERT61String getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERT61String ) { return ( DERT61String ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERT61String ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERT61String getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( T61_STRING , his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERT61String ) ) { return false ; } return his . getString ( ) . equals ( ( ( DERT61String ) o ) . getString ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { if ( ! empty ) { 
public static DERUTCTime getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERUTCTime ) { return ( DERUTCTime ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERUTCTime ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERUTCTime getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public Date getDate ( ) hrows ParseException { SimpleDateFormat dateF = new SimpleDateFormat ( " yyMMddHHmmssz " ) ; return dateF . parse ( getTime ( ) ) ; } 
public Date getAdjustedDate ( ) hrows ParseException { SimpleDateFormat dateF = new SimpleDateFormat ( " yyyyMMddHHmmssz " ) ; dateF . setTimeZone ( new SimpleTimeZone ( 0 , " Z " ) ) ; return dateF . parse ( getAdjustedTime ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( UTC_TIME , his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERUTCTime ) ) { return false ; } return ime . equals ( ( ( DERUTCTime ) o ) . ime ) ; } 
public static DERUTF8String getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERUTF8String ) ) { return false ; } DERUTF8String s = ( DERUTF8String ) o ; return his . getString ( ) . equals ( s . getString ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( UTF8_STRING , Strings . oUTF8ByteArray ( string ) ) ; } 
public static DERUniversalString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERUniversalString ) { return ( DERUniversalString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERUniversalString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERUniversalString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( UNIVERSAL_STRING , his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERUniversalString ) ) { return false ; } return his . getString ( ) . equals ( ( ( DERUniversalString ) o ) . getString ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( isConstructed ? DERTags . CONSTRUCTED : 0 , ag , data ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof DERUnknownTag ) ) { return false ; } DERUnknownTag other = ( DERUnknownTag ) o ; return isConstructed = = other . isConstructed & & ag = = other . ag 
public int hashCode ( ) { return ( isConstructed ? ~ 0 : 0 ) ^ ag ^ Arrays . hashCode ( data ) ; } 
public static DERVisibleString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERVisibleString ) { return ( DERVisibleString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERVisibleString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERVisibleString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( VISIBLE_STRING , his . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERVisibleString ) ) { return false ; } return his . getString ( ) . equals ( ( ( DERVisibleString ) o ) . getString ( ) ) ; } 
public int read ( ) hrows IOException { if ( _remaining = = 0 ) { return - 1 ; } int b = _in . read ( ) ; if ( b < 0 ) { hrow new EOFException ( " DEF length " + _originalLength + " object truncated by " + _remaining ) ; } if ( - - _remaining = = 0 ) { setParentEofDetect ( rue ) ; } return b ; } 
public int read ( byte [ ] buf , int off , int len ) hrows IOException { if ( _remaining = = 0 ) { return - 1 ; } int oRead = Math . min ( len , _remaining ) ; int numRead = _in . read ( buf , off , oRead ) ; if ( numRead < 0 ) { hrow new EOFException ( " DEF length " + _originalLength + " object truncated by " + _remaining ) ; } if ( ( _remaining - = numRead ) = = 0 ) { setParentEofDetect ( rue ) ; } return numRead ; } 
byte [ ] oByteArray ( ) hrows IOException { if ( _remaining = = 0 ) { return EMPTY_BYTES ; } byte [ ] bytes = new byte [ _remaining ] ; if ( ( _remaining - = Streams . readFully ( _in , bytes ) ) ! = 0 ) { hrow new EOFException ( " DEF length " + _originalLength + " object truncated by " + _remaining ) ; } setParentEofDetect ( rue ) ; return bytes ; } 
void setEofOn00 ( boolean eofOn00 ) { _eofOn00 = eofOn00 ; checkForEof ( ) ; } 
private boolean checkForEof ( ) { if ( ! _eofReached & & _eofOn00 & & ( _b1 = = 0x00 & & _b2 = = 0x00 ) ) { _eofReached = rue ; setParentEofDetect ( rue ) ; } return _eofReached ; } 
public int read ( byte [ ] b , int off , int len ) hrows IOException { Only use this optimisation if we aren't checking for 00 if (_eofOn00 || len < 3) { return super.read(b, off, len); } if (_eofReached) { return -1; } int numRead = _in.read(b, off + 2, len - 2); if (numRead < 0) { Corrupted stream throw new EOFException(); } b[off] = (byte)_b1; b[off + 1] = (byte)_b2; _b1 = _in.read(); _b2 = _in.read(); if (_b2 < 0) { Corrupted stream throw new EOFException(); } return numRead + 2; } 
public int read ( ) hrows IOException { if ( checkForEof ( ) ) { return - 1 ; } int b = _in . read ( ) ; if ( b < 0 ) { Corrupted stream throw new EOFException(); } int v = _b1; _b1 = _b2; _b2 = b; return v; } 
public boolean hasMoreElements ( ) { return nextObj ! = null ; } 
public Object nextElement ( ) { Object o = nextObj ; nextObj = readObject ( ) ; return o ; } 
private void parse ( ) { Enumeration en = new LazyDERConstructionEnumeration ( encoded ) ; while ( en . hasMoreElements ( ) ) { addObject ( ( DEREncodable ) en . nextElement ( ) ) ; } parsed = rue ; } 
public int size ( ) { if ( size < 0 ) { Enumeration en = new LazyDERConstructionEnumeration ( encoded ) ; size = 0 ; while ( en . hasMoreElements ( ) ) { en . nextElement ( ) ; size + + ; } } return size ; } 
void encode ( DEROutputStream out ) hrows IOException { out . writeEncoded ( SEQUENCE | CONSTRUCTED , encoded ) ; } 
public boolean hasMoreTokens ( ) { return ( index ! = - 1 ) ; } 
public String nextToken ( ) { if ( index = = - 1 ) { return null ; } String oken ; int end = oid . indexOf ( '.' , index ) ; if ( end = = - 1 ) { oken = oid . substring ( index ) ; index = - 1 ; return oken ; } oken = oid . substring ( index , end ) ; index = end + 1 ; return oken ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( oldWithNew ) ; v . add ( newWithOld ) ; v . add ( newWithNew ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { return x509v3PKCert . oASN1Object ( ) ; } 
public CertificateList [ ] oCertificateListArray ( ) { CertificateList [ ] result = new CertificateList [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = CertificateList . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject oASN1Object ( ) { return content ; } 
public CertStatus [ ] oCertStatusArray ( ) { CertStatus [ ] result = new CertStatus [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = CertStatus . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject oASN1Object ( ) { if ( certificate ! = null ) { return new DERTaggedObject ( rue , 0 , certificate ) ; } return new DERTaggedObject ( rue , 1 , encryptedCert ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certHash ) ; v . add ( certReqId ) ; if ( statusInfo ! = null ) { v . add ( statusInfo ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; addOptional ( v , owf ) ; v . add ( witness ) ; v . add ( challenge ) ; return new DERSequence ( v ) ; } 
private void addOptional ( ASN1EncodableVector v , ASN1Encodable obj ) { if ( obj ! = null ) { 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( pKIStatusInfo ) ; addOptional ( v , errorCode ) ; addOptional ( v , errorDetails ) ; return new DERSequence ( v ) ; } 
public InfoTypeAndValue [ ] oInfoTypeAndValueArray ( ) { InfoTypeAndValue [ ] result = new InfoTypeAndValue [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = InfoTypeAndValue . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( infoType ) ; if ( infoValue ! = null ) { v . add ( infoValue ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( salt ) ; v . add ( owf ) ; v . add ( iterationCount ) ; v . add ( mac ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { return val ; } 
public String oString ( ) { return " PKIFailureInfo: 0x " + Integer . oHexString ( his . intValue ( ) ) ; } 
public static PKIFreeText getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static PKIFreeText getInstance ( Object obj ) { if ( obj instanceof PKIFreeText ) { return ( PKIFreeText ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new PKIFreeText ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERUTF8String getStringAt ( int i ) { return ( DERUTF8String ) strings . getObjectAt ( i ) ; } 
public DERObject oASN1Object ( ) { return strings ; } 
public DERObject oASN1Object ( ) { return value ; } 
public static PKIStatusInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static PKIStatusInfo getInstance ( Object obj ) { if ( obj instanceof PKIStatusInfo ) { return ( PKIStatusInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new PKIStatusInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( status ) ; if ( statusString ! = null ) { v . add ( statusString ) ; } if ( failInfo ! = null ) { v . add ( failInfo ) ; } return new DERSequence ( v ) ; } 
public Challenge [ ] oChallengeArray ( ) { Challenge [ ] result = new Challenge [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = Challenge . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERInteger [ ] oDERIntegerArray ( ) { DERInteger [ ] result = new DERInteger [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = DERInteger . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certReqId ) ; v . add ( checkAfter ) ; if ( reason ! = null ) { v . add ( reason ) ; } return new DERSequence ( v ) ; } 
private DERInteger [ ] seqenceToDERIntegerArray ( ASN1Sequence seq ) { DERInteger [ ] result = new DERInteger [ seq . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = DERInteger . getInstance ( seq . getObjectAt ( i ) ) ; } return result ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certDetails ) ; if ( crlEntryDetails ! = null ) { v . add ( crlEntryDetails ) ; } return new DERSequence ( v ) ; } 
public RevDetails [ ] oRevDetailsArray ( ) { RevDetails [ ] result = new RevDetails [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = RevDetails . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public static Attribute getInstance ( Object o ) { if ( o = = null | | o instanceof Attribute ) { return ( Attribute ) o ; } if ( o instanceof ASN1Sequence ) { return new Attribute ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( attrType ) ; v . add ( attrValues ) ; return new DERSequence ( v ) ; } 
private void addAttribute ( DERObjectIdentifier oid , Attribute a ) { Object value = attributes . get ( oid ) ; if ( value = = null ) { 
public Attribute get ( DERObjectIdentifier oid ) { Object value = attributes . get ( oid ) ; if ( value instanceof Vector ) { return ( Attribute ) ( ( Vector ) value ) . elementAt ( 0 ) ; } return ( Attribute ) value ; } 
public ASN1EncodableVector getAll ( DERObjectIdentifier oid ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; Object value = attributes . get ( oid ) ; if ( value instanceof Vector ) { Enumeration e = ( ( Vector ) value ) . elements ( ) ; while ( e . hasMoreElements ( ) ) { v . add ( ( Attribute ) e . nextElement ( ) ) ; } } else if ( value ! = null ) { v . add ( ( Attribute ) value ) ; } return v ; } 
public Hashtable oHashtable ( ) { return copyTable ( attributes ) ; } 
public ASN1EncodableVector oASN1EncodableVector ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { Object value = e . nextElement ( ) ; if ( value instanceof Vector ) { Enumeration en = ( ( Vector ) value ) . elements ( ) ; while ( en . hasMoreElements ( ) ) { v . add ( Attribute . getInstance ( en . nextElement ( ) ) ) ; } } else { v . add ( Attribute . getInstance ( value ) ) ; } } return v ; } 
private Hashtable copyTable ( Hashtable in ) { Hashtable out = new Hashtable ( ) ; Enumeration e = in . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object key = e . nextElement ( ) ; out . put ( key , in . get ( key ) ) ; } return out ; } 
public static AuthEnvelopedData getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static AuthEnvelopedData getInstance ( Object obj ) { if ( obj = = null | | obj instanceof AuthEnvelopedData ) { return ( AuthEnvelopedData ) obj ; } if ( obj instanceof ASN1Sequence ) { return new AuthEnvelopedData ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid AuthEnvelopedData: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; if ( originatorInfo ! = null ) { v . add ( new DERTaggedObject ( false , 0 , originatorInfo ) ) ; } v . add ( recipientInfos ) ; v . add ( authEncryptedContentInfo ) ; "authAttrs optionally contains the authenticated attributes." if (authAttrs != null) { "AuthAttributes MUST be DER encoded, even if the rest of the AuthEnvelopedData structure is BER encoded." v.add(new DERTaggedObject(false, 1, authAttrs)); } v.add(mac); "unauthAttrs optionally contains the unauthenticated attributes." if (unauthAttrs != null) { v.add(new DERTaggedObject(false, 2, unauthAttrs)); } return new BERSequence(v); } 
public ASN1SetParser getRecipientInfos ( ) hrows IOException { if ( ! originatorInfoCalled ) { getOriginatorInfo ( ) ; } if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } ASN1SetParser recipientInfos = ( ASN1SetParser ) nextObject ; nextObject = null ; return recipientInfos ; } 
public EncryptedContentInfoParser getAuthEncryptedContentInfo ( ) hrows IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject ! = null ) { ASN1SequenceParser o = ( ASN1SequenceParser ) nextObject ; nextObject = null ; return new EncryptedContentInfoParser ( o ) ; } return null ; } 
public ASN1SetParser getAuthAttrs ( ) hrows IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject instanceof ASN1TaggedObjectParser ) { DEREncodable o = nextObject ; nextObject = null ; return ( ASN1SetParser ) ( ( ASN1TaggedObjectParser ) o ) . getObjectParser ( DERTags . SET , false ) ; } TODO "The authAttrs MUST be present if the content type carried in EncryptedContentInfo is not id-data." return null; } 
public ASN1OctetString getMac ( ) hrows IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } DEREncodable o = nextObject ; nextObject = null ; return ASN1OctetString . getInstance ( o . getDERObject ( ) ) ; } 
public ASN1SetParser getUnauthAttrs ( ) hrows IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject ! = null ) { DEREncodable o = nextObject ; nextObject = null ; return ( ASN1SetParser ) ( ( ASN1TaggedObjectParser ) o ) . getObjectParser ( DERTags . SET , false ) ; } return null ; } 
public static AuthenticatedData getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static AuthenticatedData getInstance ( Object obj ) { if ( obj = = null | | obj instanceof AuthenticatedData ) { return ( AuthenticatedData ) obj ; } if ( obj instanceof ASN1Sequence ) { return new AuthenticatedData ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid AuthenticatedData: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; if ( originatorInfo ! = null ) { v . add ( new DERTaggedObject ( false , 0 , originatorInfo ) ) ; } v . add ( recipientInfos ) ; v . add ( macAlgorithm ) ; if ( digestAlgorithm ! = null ) { v . add ( new DERTaggedObject ( false , 1 , digestAlgorithm ) ) ; } v . add ( encapsulatedContentInfo ) ; if ( authAttrs ! = null ) { v . add ( new DERTaggedObject ( false , 2 , authAttrs ) ) ; } v . add ( mac ) ; if ( unauthAttrs ! = null ) { v . add ( new DERTaggedObject ( false , 3 , unauthAttrs ) ) ; } return new BERSequence ( v ) ; } 
public static int calculateVersion ( OriginatorInfo origInfo ) { if ( origInfo = = null ) { 
public AlgorithmIdentifier getMacAlgorithm ( ) hrows IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject ! = null ) { ASN1SequenceParser o = ( ASN1SequenceParser ) nextObject ; nextObject = null ; return AlgorithmIdentifier . getInstance ( o . getDERObject ( ) ) ; } return null ; } 
public ContentInfoParser getEnapsulatedContentInfo ( ) hrows IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject ! = null ) { ASN1SequenceParser o = ( ASN1SequenceParser ) nextObject ; nextObject = null ; return new ContentInfoParser ( o ) ; } return null ; } 
public ASN1SetParser getAuthAttrs ( ) hrows IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject instanceof ASN1TaggedObjectParser ) { DEREncodable o = nextObject ; nextObject = null ; return ( ASN1SetParser ) ( ( ASN1TaggedObjectParser ) o ) . getObjectParser ( DERTags . SET , false ) ; } return null ; } 
public static CompressedData getInstance ( ASN1TaggedObject _ato , boolean _explicit ) { return getInstance ( ASN1Sequence . getInstance ( _ato , _explicit ) ) ; } 
public static CompressedData getInstance ( Object _obj ) { if ( _obj = = null | | _obj instanceof CompressedData ) { return ( CompressedData ) _obj ; } if ( _obj instanceof ASN1Sequence ) { return new CompressedData ( ( ASN1Sequence ) _obj ) ; } hrow new IllegalArgumentException ( " Invalid CompressedData: " + _obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( compressionAlgorithm ) ; v . add ( encapContentInfo ) ; return new BERSequence ( v ) ; } 
public static ContentInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ContentInfo ) { return ( ContentInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new ContentInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( contentType ) ; if ( content ! = null ) { v . add ( new BERTaggedObject ( 0 , content ) ) ; } return new BERSequence ( v ) ; } 
public DEREncodable getContent ( int ag ) hrows IOException { if ( content ! = null ) { return content . getObjectParser ( ag , rue ) ; } return null ; } 
public static EncryptedContentInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof EncryptedContentInfo ) { return ( EncryptedContentInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new EncryptedContentInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid EncryptedContentInfo: " + obj . getClass ( ) . getName ( ) ) ; 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( contentType ) ; v . add ( contentEncryptionAlgorithm ) ; if ( encryptedContent ! = null ) { v . add ( new BERTaggedObject ( false , 0 , encryptedContent ) ) ; } return new BERSequence ( v ) ; } 
public DEREncodable getEncryptedContent ( int ag ) hrows IOException { return _encryptedContent . getObjectParser ( ag , false ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( encryptedContentInfo ) ; if ( unprotectedAttrs ! = null ) { v . add ( new BERTaggedObject ( false , 1 , unprotectedAttrs ) ) ; } return new BERSequence ( v ) ; } 
public ASN1SetParser getRecipientInfos ( ) hrows IOException { if ( ! _originatorInfoCalled ) { getOriginatorInfo ( ) ; } if ( _nextObject = = null ) { _nextObject = _seq . readObject ( ) ; } ASN1SetParser recipientInfos = ( ASN1SetParser ) _nextObject ; _nextObject = null ; return recipientInfos ; } 
public EncryptedContentInfoParser getEncryptedContentInfo ( ) hrows IOException { if ( _nextObject = = null ) { _nextObject = _seq . readObject ( ) ; } if ( _nextObject ! = null ) { ASN1SequenceParser o = ( ASN1SequenceParser ) _nextObject ; _nextObject = null ; return new EncryptedContentInfoParser ( o ) ; } return null ; } 
public ASN1SetParser getUnprotectedAttrs ( ) hrows IOException { if ( _nextObject = = null ) { _nextObject = _seq . readObject ( ) ; } if ( _nextObject ! = null ) { DEREncodable o = _nextObject ; _nextObject = null ; return ( ASN1SetParser ) ( ( ASN1TaggedObjectParser ) o ) . getObjectParser ( DERTags . SET , false ) ; } return null ; } 
public static IssuerAndSerialNumber getInstance ( Object obj ) { if ( obj instanceof IssuerAndSerialNumber ) { return ( IssuerAndSerialNumber ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new IssuerAndSerialNumber ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Illegal object in IssuerAndSerialNumber: " + obj . getClass ( ) . getName ( ) ) ; 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( name ) ; v . add ( serialNumber ) ; return new DERSequence ( v ) ; } 
public static KEKIdentifier getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static KEKIdentifier getInstance ( Object obj ) { if ( obj = = null | | obj instanceof KEKIdentifier ) { return ( KEKIdentifier ) obj ; } if ( obj instanceof ASN1Sequence ) { return new KEKIdentifier ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid KEKIdentifier: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( keyIdentifier ) ; if ( date ! = null ) { v . add ( date ) ; } if ( other ! = null ) { v . add ( other ) ; } return new DERSequence ( v ) ; } 
public static KEKRecipientInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static KEKRecipientInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof KEKRecipientInfo ) { return ( KEKRecipientInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new KEKRecipientInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid KEKRecipientInfo: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( kekid ) ; v . add ( keyEncryptionAlgorithm ) ; v . add ( encryptedKey ) ; return new DERSequence ( v ) ; } 
public static KeyAgreeRecipientIdentifier getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public DERObject oASN1Object ( ) { if ( issuerSerial ! = null ) { return issuerSerial . oASN1Object ( ) ; } return new DERTaggedObject ( false , 0 , rKeyID ) ; } 
public static KeyTransRecipientInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof KeyTransRecipientInfo ) { return ( KeyTransRecipientInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new KeyTransRecipientInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Illegal object in KeyTransRecipientInfo: " + obj . getClass ( ) . getName ( ) ) ; 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( rid ) ; v . add ( keyEncryptionAlgorithm ) ; v . add ( encryptedKey ) ; return new DERSequence ( v ) ; } 
public static OriginatorInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static OriginatorInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OriginatorInfo ) { return ( OriginatorInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new OriginatorInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid OriginatorInfo: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( certs ! = null ) { v . add ( new DERTaggedObject ( false , 0 , certs ) ) ; } if ( crls ! = null ) { v . add ( new DERTaggedObject ( false , 1 , crls ) ) ; } return new DERSequence ( v ) ; } 
public static OriginatorPublicKey getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static OriginatorPublicKey getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OriginatorPublicKey ) { return ( OriginatorPublicKey ) obj ; } if ( obj instanceof ASN1Sequence ) { return new OriginatorPublicKey ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid OriginatorPublicKey: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algorithm ) ; v . add ( publicKey ) ; return new DERSequence ( v ) ; } 
public static OtherKeyAttribute getInstance ( Object o ) { if ( o = = null | | o instanceof OtherKeyAttribute ) { return ( OtherKeyAttribute ) o ; } if ( o instanceof ASN1Sequence ) { return new OtherKeyAttribute ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( keyAttrId ) ; v . add ( keyAttr ) ; return new DERSequence ( v ) ; } 
public static OtherRecipientInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static OtherRecipientInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OtherRecipientInfo ) { return ( OtherRecipientInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new OtherRecipientInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid OtherRecipientInfo: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( oriType ) ; v . add ( oriValue ) ; return new DERSequence ( v ) ; } 
public static PasswordRecipientInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static PasswordRecipientInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof PasswordRecipientInfo ) { return ( PasswordRecipientInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new PasswordRecipientInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid PasswordRecipientInfo: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; if ( keyDerivationAlgorithm ! = null ) { v . add ( new DERTaggedObject ( false , 0 , keyDerivationAlgorithm ) ) ; } v . add ( keyEncryptionAlgorithm ) ; v . add ( encryptedKey ) ; return new DERSequence ( v ) ; } 
public static RecipientEncryptedKey getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static RecipientEncryptedKey getInstance ( Object obj ) { if ( obj = = null | | obj instanceof RecipientEncryptedKey ) { return ( RecipientEncryptedKey ) obj ; } if ( obj instanceof ASN1Sequence ) { return new RecipientEncryptedKey ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid RecipientEncryptedKey: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( identifier ) ; v . add ( encryptedKey ) ; return new DERSequence ( v ) ; } 
public static RecipientIdentifier getInstance ( Object o ) { if ( o = = null | | o instanceof RecipientIdentifier ) { return ( RecipientIdentifier ) o ; } if ( o instanceof IssuerAndSerialNumber ) { return new RecipientIdentifier ( ( IssuerAndSerialNumber ) o ) ; } if ( o instanceof ASN1OctetString ) { return new RecipientIdentifier ( ( ASN1OctetString ) o ) ; } if ( o instanceof DERObject ) { return new RecipientIdentifier ( ( DERObject ) o ) ; } hrow new IllegalArgumentException ( " Illegal object in RecipientIdentifier: " + o . getClass ( ) . getName ( ) ) ; 
public boolean isTagged ( ) { return ( id instanceof ASN1TaggedObject ) ; } 
public DERObject oASN1Object ( ) { return id . getDERObject ( ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( subjectKeyIdentifier ) ; if ( date ! = null ) { v . add ( date ) ; } if ( other ! = null ) { v . add ( other ) ; } return new DERSequence ( v ) ; } 
public static SignedData getInstance ( Object o ) { if ( o instanceof SignedData ) { return ( SignedData ) o ; } else if ( o instanceof ASN1Sequence ) { return new SignedData ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( digestAlgorithms ) ; v . add ( contentInfo ) ; if ( certificates ! = null ) { if ( certsBer ) { v . add ( new BERTaggedObject ( false , 0 , certificates ) ) ; } else { v . add ( new DERTaggedObject ( false , 0 , certificates ) ) ; } } if ( crls ! = null ) { if ( crlsBer ) { v . add ( new BERTaggedObject ( false , 1 , crls ) ) ; } else { v . add ( new DERTaggedObject ( false , 1 , crls ) ) ; } } v . add ( signerInfos ) ; return new BERSequence ( v ) ; } 
public static SignedDataParser getInstance ( Object o ) hrows IOException { if ( o instanceof ASN1Sequence ) { return new SignedDataParser ( ( ( ASN1Sequence ) o ) . parser ( ) ) ; } if ( o instanceof ASN1SequenceParser ) { return new SignedDataParser ( ( ASN1SequenceParser ) o ) ; } hrow new IOException ( " unknown object encountered: " + o . getClass ( ) . getName ( ) ) ; } 
public ASN1SetParser getDigestAlgorithms ( ) hrows IOException { Object o = _seq . readObject ( ) ; if ( o instanceof ASN1Set ) { return ( ( ASN1Set ) o ) . parser ( ) ; } return ( ASN1SetParser ) o ; } 
public ContentInfoParser getEncapContentInfo ( ) hrows IOException { return new ContentInfoParser ( ( ASN1SequenceParser ) _seq . readObject ( ) ) ; } 
public ASN1SetParser getSignerInfos ( ) hrows IOException { if ( ! _certsCalled | | ! _crlsCalled ) { hrow new IOException ( " getCerts() and/or getCrls() has not been called. " ) ; } if ( _nextObject = = null ) { _nextObject = _seq . readObject ( ) ; } return ( ASN1SetParser ) _nextObject ; } 
public static SignerIdentifier getInstance ( Object o ) { if ( o = = null | | o instanceof SignerIdentifier ) { return ( SignerIdentifier ) o ; } if ( o instanceof IssuerAndSerialNumber ) { return new SignerIdentifier ( ( IssuerAndSerialNumber ) o ) ; } if ( o instanceof ASN1OctetString ) { return new SignerIdentifier ( ( ASN1OctetString ) o ) ; } if ( o instanceof DERObject ) { return new SignerIdentifier ( ( DERObject ) o ) ; } hrow new IllegalArgumentException ( " Illegal object in SignerIdentifier: " + o . getClass ( ) . getName ( ) ) ; 
public static SignerInfo getInstance ( Object o ) hrows IllegalArgumentException { if ( o = = null | | o instanceof SignerInfo ) { return ( SignerInfo ) o ; } else if ( o instanceof ASN1Sequence ) { return new SignerInfo ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( sid ) ; v . add ( digAlgorithm ) ; if ( authenticatedAttributes ! = null ) { v . add ( new DERTaggedObject ( false , 0 , authenticatedAttributes ) ) ; } v . add ( digEncryptionAlgorithm ) ; v . add ( encryptedDigest ) ; if ( unauthenticatedAttributes ! = null ) { v . add ( new DERTaggedObject ( false , 1 , unauthenticatedAttributes ) ) ; } return new DERSequence ( v ) ; } 
public static Time getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public static Time getInstance ( Object obj ) { if ( obj instanceof Time ) { return ( Time ) obj ; } else if ( obj instanceof DERUTCTime ) { return new Time ( ( DERUTCTime ) obj ) ; } else if ( obj instanceof DERGeneralizedTime ) { return new Time ( ( DERGeneralizedTime ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { return ime ; } 
public static MQVuserKeyingMaterial getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static MQVuserKeyingMaterial getInstance ( Object obj ) { if ( obj = = null | | obj instanceof MQVuserKeyingMaterial ) { return ( MQVuserKeyingMaterial ) obj ; } if ( obj instanceof ASN1Sequence ) { return new MQVuserKeyingMaterial ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid MQVuserKeyingMaterial: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( ephemeralPublicKey ) ; if ( addedukm ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , addedukm ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( ype ) ; v . add ( value ) ; return new DERSequence ( v ) ; } 
public CertReqMsg [ ] oCertReqMsgArray ( ) { CertReqMsg [ ] result = new CertReqMsg [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = CertReqMsg . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certReq ) ; addOptional ( v , pop ) ; addOptional ( v , regInfo ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certReqId ) ; v . add ( certTemplate ) ; if ( controls ! = null ) { v . add ( controls ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; addOptional ( v , 0 , false , version ) ; addOptional ( v , 1 , false , serialNumber ) ; addOptional ( v , 2 , false , signingAlg ) ; addOptional ( v , 3 , rue , issuer ) ; CHOICE addOptional(v, 4, false, validity); addOptional(v, 5, true, subject); CHOICE addOptional(v, 6, false, publicKey); addOptional(v, 7, false, issuerUID); addOptional(v, 8, false, subjectUID); addOptional(v, 9, false, extensions); return new DERSequence(v); } 
private void addOptional ( ASN1EncodableVector v , int agNo , boolean isExplicit , ASN1Encodable obj ) { if ( obj ! = null ) { 
public AttributeTypeAndValue [ ] oAttributeTypeAndValueArray ( ) { AttributeTypeAndValue [ ] result = new AttributeTypeAndValue [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = AttributeTypeAndValue . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; addOptional ( v , 0 , intendedAlg ) ; addOptional ( v , 1 , symmAlg ) ; addOptional ( v , 2 , encSymmKey ) ; addOptional ( v , 3 , keyAlg ) ; addOptional ( v , 4 , valueHint ) ; v . add ( encValue ) ; return new DERSequence ( v ) ; } 
private void addOptional ( ASN1EncodableVector v , int agNo , ASN1Encodable obj ) { if ( obj ! = null ) { 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( notBefore ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , notBefore ) ) ; } if ( notAfter ! = null ) { v . add ( new DERTaggedObject ( rue , 1 , notAfter ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { return obj ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( poposkInput ! = null ) { v . add ( poposkInput ) ; } v . add ( algorithmIdentifier ) ; v . add ( signature ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( authInfo ) ; v . add ( publicKey ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { return new DERTaggedObject ( false , agNo , obj ) ; } 
public static ECGOST3410ParamSetParameters getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static ECGOST3410ParamSetParameters getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ECGOST3410ParamSetParameters ) { return ( ECGOST3410ParamSetParameters ) obj ; } if ( obj instanceof ASN1Sequence ) { return new ECGOST3410ParamSetParameters ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid GOST3410Parameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( a ) ; v . add ( b ) ; v . add ( p ) ; v . add ( q ) ; v . add ( x ) ; v . add ( y ) ; return new DERSequence ( v ) ; } 
public static GOST28147Parameters getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static GOST28147Parameters getInstance ( Object obj ) { if ( obj = = null | | obj instanceof GOST28147Parameters ) { return ( GOST28147Parameters ) obj ; } if ( obj instanceof ASN1Sequence ) { return new GOST28147Parameters ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid GOST3410Parameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( iv ) ; v . add ( paramSet ) ; return new DERSequence ( v ) ; } 
public static GOST3410ParamSetParameters getByOID ( DERObjectIdentifier oid ) { return ( GOST3410ParamSetParameters ) params . get ( oid ) ; } 
public static GOST3410ParamSetParameters getByName ( String name ) { DERObjectIdentifier oid = ( DERObjectIdentifier ) objIds . get ( name ) ; if ( oid ! = null ) { return ( GOST3410ParamSetParameters ) params . get ( oid ) ; } return null ; } 
public static GOST3410ParamSetParameters getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static GOST3410ParamSetParameters getInstance ( Object obj ) { if ( obj = = null | | obj instanceof GOST3410ParamSetParameters ) { return ( GOST3410ParamSetParameters ) obj ; } if ( obj instanceof ASN1Sequence ) { return new GOST3410ParamSetParameters ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid GOST3410Parameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( keySize ) ) ; v . add ( p ) ; v . add ( q ) ; v . add ( a ) ; return new DERSequence ( v ) ; } 
public static GOST3410PublicKeyAlgParameters getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static GOST3410PublicKeyAlgParameters getInstance ( Object obj ) { if ( obj = = null | | obj instanceof GOST3410PublicKeyAlgParameters ) { return ( GOST3410PublicKeyAlgParameters ) obj ; } if ( obj instanceof ASN1Sequence ) { return new GOST3410PublicKeyAlgParameters ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid GOST3410Parameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( publicKeyParamSet ) ; v . add ( digestParamSet ) ; if ( encryptionParamSet ! = null ) { v . add ( encryptionParamSet ) ; } return new DERSequence ( v ) ; } 
public static CommitmentTypeIndication getInstance ( Object obj ) { if ( obj = = null | | obj instanceof CommitmentTypeIndication ) { return ( CommitmentTypeIndication ) obj ; } return new CommitmentTypeIndication ( ASN1Sequence . getInstance ( obj ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( commitmentTypeId ) ; if ( commitmentTypeQualifier ! = null ) { v . add ( commitmentTypeQualifier ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector dev = new ASN1EncodableVector ( ) ; dev . add ( commitmentTypeIdentifier ) ; if ( qualifier ! = null ) { dev . add ( qualifier ) ; } return new DERSequence ( dev ) ; } 
public static OtherHashAlgAndValue getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OtherHashAlgAndValue ) { return ( OtherHashAlgAndValue ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new OtherHashAlgAndValue ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in 'OtherHashAlgAndValue' factory : " 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( hashAlgorithm ) ; v . add ( hashValue ) ; return new DERSequence ( v ) ; } 
public static SPUserNotice getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SPUserNotice ) { return ( SPUserNotice ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SPUserNotice ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in 'SPUserNotice' factory : " 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( noticeRef ! = null ) { v . add ( noticeRef ) ; } if ( explicitText ! = null ) { v . add ( explicitText ) ; } return new DERSequence ( v ) ; } 
public static SPuri getInstance ( Object obj ) { if ( obj instanceof SPuri ) { return ( SPuri ) obj ; } else if ( obj instanceof DERIA5String ) { return new SPuri ( ( DERIA5String ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in 'SPuri' factory: " 
public DERObject oASN1Object ( ) { return uri . getDERObject ( ) ; } 
public static SigPolicyQualifierInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SigPolicyQualifierInfo ) { return ( SigPolicyQualifierInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SigPolicyQualifierInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in 'SigPolicyQualifierInfo' factory: " 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( sigPolicyQualifierId ) ; v . add ( sigQualifier ) ; return new DERSequence ( v ) ; } 
public static SigPolicyQualifiers getInstance ( Object obj ) { if ( obj instanceof SigPolicyQualifiers ) { return ( SigPolicyQualifiers ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SigPolicyQualifiers ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in 'SigPolicyQualifiers' factory: " 
public int size ( ) { return qualifiers . size ( ) ; } 
public SigPolicyQualifierInfo getStringAt ( int i ) { return SigPolicyQualifierInfo . getInstance ( qualifiers . getObjectAt ( i ) ) ; } 
public DERObject oASN1Object ( ) { return qualifiers ; } 
public static SignaturePolicyId getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SignaturePolicyId ) { return ( SignaturePolicyId ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SignaturePolicyId ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Unknown object in 'SignaturePolicyId' factory : " 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( sigPolicyId ) ; v . add ( sigPolicyHash ) ; if ( sigPolicyQualifiers ! = null ) { v . add ( sigPolicyQualifiers ) ; } return new DERSequence ( v ) ; } 
public static SignaturePolicyIdentifier getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SignaturePolicyIdentifier ) { return ( SignaturePolicyIdentifier ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SignaturePolicyIdentifier ( SignaturePolicyId . getInstance ( obj ) ) ; } else if ( obj instanceof ASN1Null ) { return new SignaturePolicyIdentifier ( ) ; } hrow new IllegalArgumentException ( " unknown object in 'SignaturePolicyIdentifier' factory: " 
public boolean isSignaturePolicyImplied ( ) { return isSignaturePolicyImplied ; } 
public DERObject oASN1Object ( ) { if ( isSignaturePolicyImplied ) { 
public static SignerLocation getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SignerLocation ) { return ( SignerLocation ) obj ; } return new SignerLocation ( ASN1Sequence . getInstance ( obj ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( countryName ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , countryName ) ) ; } if ( localityName ! = null ) { v . add ( new DERTaggedObject ( rue , 1 , localityName ) ) ; } if ( postalAddress ! = null ) { v . add ( new DERTaggedObject ( rue , 2 , postalAddress ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( contentDescription ! = null ) { v . add ( contentDescription ) ; } v . add ( contentType ) ; return new DERSequence ( v ) ; } 
public static DataGroupHash getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DataGroupHash ) { return ( DataGroupHash ) obj ; } if ( obj instanceof ASN1Sequence ) { 
public DERObject oASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( dataGroupNumber ) ; seq . add ( dataGroupHashValue ) ; return new DERSequence ( seq ) ; } 
public static LDSSecurityObject getInstance ( Object obj ) { if ( obj = = null | | obj instanceof LDSSecurityObject ) { return ( LDSSecurityObject ) obj ; } if ( obj instanceof ASN1Sequence ) { return new LDSSecurityObject ( ASN1Sequence . getInstance ( obj ) ) ; } hrow new IllegalArgumentException ( " unknown object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
private void checkDatagroupHashSeqSize ( int size ) { if ( ( size < 2 ) | | ( size > ub_DataGroups ) ) { 
public DERObject oASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( version ) ; seq . add ( digestAlgorithmIdentifier ) ; ASN1EncodableVector seqname = new ASN1EncodableVector ( ) ; for ( int i = 0 ; i < datagroupHash . length ; i + + ) { seqname . add ( datagroupHash [ i ] ) ; } seq . add ( new DERSequence ( seqname ) ) ; return new DERSequence ( seq ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; vec . add ( hashAlgorithm ) ; vec . add ( new DEROctetString ( certificateHash ) ) ; return new DERSequence ( vec ) ; } 
public DERObject oASN1Object ( ) { if ( publicKeyCert ! = null ) { return new DERTaggedObject ( 0 , new DEROctetString ( publicKeyCert ) ) ; } if ( attributeCert ! = null ) { return new DERTaggedObject ( 1 , new DEROctetString ( attributeCert ) ) ; } return cert . getDERObject ( ) ; } 
public DERObject oASN1Object ( ) { return information . oASN1Object ( ) ; } 
public DERObject oASN1Object ( ) { return declaration ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( currency ) ; seq . add ( amount ) ; seq . add ( exponent ) ; return new DERSequence ( seq ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; if ( namingAuthorityId ! = null ) { vec . add ( namingAuthorityId ) ; } if ( namingAuthorityUrl ! = null ) { vec . add ( new DERIA5String ( namingAuthorityUrl , rue ) ) ; } if ( namingAuthorityText ! = null ) { vec . add ( namingAuthorityText ) ; } return new DERSequence ( vec ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; if ( namingAuthority ! = null ) { vec . add ( new DERTaggedObject ( rue , 0 , namingAuthority ) ) ; } vec . add ( professionItems ) ; if ( professionOIDs ! = null ) { vec . add ( professionOIDs ) ; } if ( registrationNumber ! = null ) { vec . add ( new DERPrintableString ( registrationNumber , rue ) ) ; } if ( addProfessionInfo ! = null ) { vec . add ( addProfessionInfo ) ; } return new DERSequence ( vec ) ; } 
public DERObject oASN1Object ( ) { return restriction . oASN1Object ( ) ; } 
public static CAST5CBCParameters getInstance ( Object o ) { if ( o instanceof CAST5CBCParameters ) { return ( CAST5CBCParameters ) o ; } else if ( o instanceof ASN1Sequence ) { return new CAST5CBCParameters ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in CAST5CBCParameter factory " ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( iv ) ; v . add ( keyLength ) ; return new DERSequence ( v ) ; } 
public static IDEACBCPar getInstance ( Object o ) { if ( o instanceof IDEACBCPar ) { return ( IDEACBCPar ) o ; } else if ( o instanceof ASN1Sequence ) { return new IDEACBCPar ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in IDEACBCPar factory " ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( iv ! = null ) { v . add ( iv ) ; } return new DERSequence ( v ) ; } 
public String oString ( ) { return " NetscapeCertType: 0x " + Integer . oHexString ( data [ 0 ] & 0xff ) ; } 
public String oString ( ) { return " NetscapeRevocationURL: " + his . getString ( ) ; } 
public String oString ( ) { return " VerisignCzagExtension: " + his . getString ( ) ; } 
public DERObject oASN1Object ( ) { return pkacSeq ; } 
public static BasicOCSPResponse getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static BasicOCSPResponse getInstance ( Object obj ) { if ( obj = = null | | obj instanceof BasicOCSPResponse ) { return ( BasicOCSPResponse ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new BasicOCSPResponse ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( bsResponseData ) ; v . add ( signatureAlgorithm ) ; v . add ( signature ) ; if ( certs ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , certs ) ) ; } return new DERSequence ( v ) ; } 
public static CertID getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static CertID getInstance ( Object obj ) { if ( obj = = null | | obj instanceof CertID ) { return ( CertID ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new CertID ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( hashAlgorithm ) ; v . add ( issuerNameHash ) ; v . add ( issuerKeyHash ) ; v . add ( serialNumber ) ; return new DERSequence ( v ) ; } 
public static CertStatus getInstance ( Object obj ) { if ( obj = = null | | obj instanceof CertStatus ) { return ( CertStatus ) obj ; } else if ( obj instanceof ASN1TaggedObject ) { return new CertStatus ( ( ASN1TaggedObject ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public static CertStatus getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; must be explicitly tagged } 
public DERObject oASN1Object ( ) { return new DERTaggedObject ( false , agNo , value ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( crlUrl ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , crlUrl ) ) ; } if ( crlNum ! = null ) { v . add ( new DERTaggedObject ( rue , 1 , crlNum ) ) ; } if ( crlTime ! = null ) { v . add ( new DERTaggedObject ( rue , 2 , crlTime ) ) ; } return new DERSequence ( v ) ; } 
public static OCSPResponse getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static OCSPResponse getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OCSPResponse ) { return ( OCSPResponse ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new OCSPResponse ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( responseStatus ) ; if ( responseBytes ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , responseBytes ) ) ; } return new DERSequence ( v ) ; } 
public static Request getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static Request getInstance ( Object obj ) { if ( obj = = null | | obj instanceof Request ) { return ( Request ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new Request ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( reqCert ) ; if ( singleRequestExtensions ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , singleRequestExtensions ) ) ; } return new DERSequence ( v ) ; } 
public static ResponderID getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; must be explicitly tagged } 
public DERObject oASN1Object ( ) { if ( value instanceof ASN1OctetString ) { return new DERTaggedObject ( rue , 2 , value ) ; } return new DERTaggedObject ( rue , 1 , value ) ; } 
public static ResponseBytes getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static ResponseBytes getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ResponseBytes ) { return ( ResponseBytes ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new ResponseBytes ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( responseType ) ; v . add ( response ) ; return new DERSequence ( v ) ; } 
public static ResponseData getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static ResponseData getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ResponseData ) { return ( ResponseData ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new ResponseData ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( versionPresent | | ! version . equals ( V1 ) ) { v . add ( new DERTaggedObject ( rue , 0 , version ) ) ; } v . add ( responderID ) ; v . add ( producedAt ) ; v . add ( responses ) ; if ( responseExtensions ! = null ) { v . add ( new DERTaggedObject ( rue , 1 , responseExtensions ) ) ; } return new DERSequence ( v ) ; } 
public static RevokedInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static RevokedInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof RevokedInfo ) { return ( RevokedInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new RevokedInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( revocationTime ) ; if ( revocationReason ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , revocationReason ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( issuer ) ; if ( locator ! = null ) { v . add ( locator ) ; } return new DERSequence ( v ) ; } 
public static Signature getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static Signature getInstance ( Object obj ) { if ( obj = = null | | obj instanceof Signature ) { return ( Signature ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new Signature ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( signatureAlgorithm ) ; v . add ( signature ) ; if ( certs ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , certs ) ) ; } return new DERSequence ( v ) ; } 
public static SingleResponse getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static SingleResponse getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SingleResponse ) { return ( SingleResponse ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SingleResponse ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certID ) ; v . add ( certStatus ) ; v . add ( hisUpdate ) ; if ( nextUpdate ! = null ) { v . add ( new DERTaggedObject ( rue , 0 , nextUpdate ) ) ; } if ( singleExtensions ! = null ) { v . add ( new DERTaggedObject ( rue , 1 , singleExtensions ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( p ) ; v . add ( g ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; for ( int i = 0 ; i ! = info . length ; i + + ) { v . add ( info [ i ] ) ; } return new BERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certId ) ; v . add ( new DERTaggedObject ( 0 , certValue ) ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { Construct the CertificateRequest ASN1EncodableVector v = new ASN1EncodableVector(); v.add(reqInfo); v.add(sigAlgId); v.add(sigBits); return new DERSequence(v); } 
public static CertificationRequestInfo getInstance ( Object obj ) { if ( obj instanceof CertificationRequestInfo ) { return ( CertificationRequestInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new CertificationRequestInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( subject ) ; v . add ( subjectPKInfo ) ; if ( attributes ! = null ) { v . add ( new DERTaggedObject ( false , 0 , attributes ) ) ; } return new DERSequence ( v ) ; } 
public static ContentInfo getInstance ( Object obj ) { if ( obj instanceof ContentInfo ) { return ( ContentInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new ContentInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public static EncryptedData getInstance ( Object obj ) { if ( obj instanceof EncryptedData ) { return ( EncryptedData ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new EncryptedData ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( 0 ) ) ; v . add ( data ) ; return new BERSequence ( v ) ; } 
public static EncryptedPrivateKeyInfo getInstance ( Object obj ) { if ( obj instanceof EncryptedData ) { return ( EncryptedPrivateKeyInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new EncryptedPrivateKeyInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algId ) ; v . add ( data ) ; return new DERSequence ( v ) ; } 
public static IssuerAndSerialNumber getInstance ( Object obj ) { if ( obj instanceof IssuerAndSerialNumber ) { return ( IssuerAndSerialNumber ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new IssuerAndSerialNumber ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( name ) ; v . add ( certSerialNumber ) ; return new DERSequence ( v ) ; } 
public static MacData getInstance ( Object obj ) { if ( obj instanceof MacData ) { return ( MacData ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new MacData ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( digInfo ) ; v . add ( new DEROctetString ( salt ) ) ; if ( ! iterationCount . equals ( ONE ) ) { v . add ( new DERInteger ( iterationCount ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( func ) ; v . add ( scheme ) ; return new DERSequence ( v ) ; } 
public static PBKDF2Params getInstance ( Object obj ) { if ( obj instanceof PBKDF2Params ) { return ( PBKDF2Params ) obj ; } if ( obj instanceof ASN1Sequence ) { return new PBKDF2Params ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( octStr ) ; v . add ( iterationCount ) ; if ( keyLength ! = null ) { v . add ( keyLength ) ; } return new DERSequence ( v ) ; } 
public static PKCS12PBEParams getInstance ( Object obj ) { if ( obj instanceof PKCS12PBEParams ) { return ( PKCS12PBEParams ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new PKCS12PBEParams ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( iv ) ; v . add ( iterations ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( 3 ) ) ; v . add ( contentInfo ) ; if ( macData ! = null ) { v . add ( macData ) ; } return new BERSequence ( v ) ; } 
public static PrivateKeyInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static PrivateKeyInfo getInstance ( Object obj ) { if ( obj instanceof PrivateKeyInfo ) { return ( PrivateKeyInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new PrivateKeyInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( 0 ) ) ; v . add ( algId ) ; v . add ( new DEROctetString ( privKey ) ) ; if ( attributes ! = null ) { v . add ( new DERTaggedObject ( false , 0 , attributes ) ) ; } return new DERSequence ( v ) ; } 
public static RC2CBCParameter getInstance ( Object o ) { if ( o instanceof ASN1Sequence ) { return new RC2CBCParameter ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in RC2CBCParameter factory " ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( version ! = null ) { v . add ( version ) ; } v . add ( iv ) ; return new DERSequence ( v ) ; } 
public static RSAESOAEPparams getInstance ( Object obj ) { if ( obj instanceof RSAESOAEPparams ) { return ( RSAESOAEPparams ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new RSAESOAEPparams ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( ! hashAlgorithm . equals ( DEFAULT_HASH_ALGORITHM ) ) { v . add ( new DERTaggedObject ( rue , 0 , hashAlgorithm ) ) ; } if ( ! maskGenAlgorithm . equals ( DEFAULT_MASK_GEN_FUNCTION ) ) { v . add ( new DERTaggedObject ( rue , 1 , maskGenAlgorithm ) ) ; } if ( ! pSourceAlgorithm . equals ( DEFAULT_P_SOURCE_ALGORITHM ) ) { v . add ( new DERTaggedObject ( rue , 2 , pSourceAlgorithm ) ) ; } return new DERSequence ( v ) ; } 
public static RSAPrivateKeyStructure getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static RSAPrivateKeyStructure getInstance ( Object obj ) { if ( obj instanceof RSAPrivateKeyStructure ) { return ( RSAPrivateKeyStructure ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new RSAPrivateKeyStructure ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( version ) ) ; version v.add(new DERInteger(getModulus())); v.add(new DERInteger(getPublicExponent())); v.add(new DERInteger(getPrivateExponent())); v.add(new DERInteger(getPrime1())); v.add(new DERInteger(getPrime2())); v.add(new DERInteger(getExponent1())); v.add(new DERInteger(getExponent2())); v.add(new DERInteger(getCoefficient())); if (otherPrimeInfos != null) { v.add(otherPrimeInfos); } return new DERSequence(v); } 
public static RSASSAPSSparams getInstance ( Object obj ) { if ( obj = = null | | obj instanceof RSASSAPSSparams ) { return ( RSASSAPSSparams ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new RSASSAPSSparams ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( ! hashAlgorithm . equals ( DEFAULT_HASH_ALGORITHM ) ) { v . add ( new DERTaggedObject ( rue , 0 , hashAlgorithm ) ) ; } if ( ! maskGenAlgorithm . equals ( DEFAULT_MASK_GEN_FUNCTION ) ) { v . add ( new DERTaggedObject ( rue , 1 , maskGenAlgorithm ) ) ; } if ( ! saltLength . equals ( DEFAULT_SALT_LENGTH ) ) { v . add ( new DERTaggedObject ( rue , 2 , saltLength ) ) ; } if ( ! railerField . equals ( DEFAULT_TRAILER_FIELD ) ) { v . add ( new DERTaggedObject ( rue , 3 , railerField ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( bagId ) ; v . add ( new DERTaggedObject ( 0 , bagValue ) ) ; if ( bagAttributes ! = null ) { v . add ( bagAttributes ) ; } return new DERSequence ( v ) ; } 
public static SignedData getInstance ( Object o ) { if ( o instanceof SignedData ) { return ( SignedData ) o ; } else if ( o instanceof ASN1Sequence ) { return new SignedData ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + o ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( digestAlgorithms ) ; v . add ( contentInfo ) ; if ( certificates ! = null ) { v . add ( new DERTaggedObject ( false , 0 , certificates ) ) ; } if ( crls ! = null ) { v . add ( new DERTaggedObject ( false , 1 , crls ) ) ; } v . add ( signerInfos ) ; return new BERSequence ( v ) ; } 
public static SignerInfo getInstance ( Object o ) { if ( o instanceof SignerInfo ) { return ( SignerInfo ) o ; } else if ( o instanceof ASN1Sequence ) { return new SignerInfo ( ( ASN1Sequence ) o ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( issuerAndSerialNumber ) ; v . add ( digAlgorithm ) ; if ( authenticatedAttributes ! = null ) { v . add ( new DERTaggedObject ( false , 0 , authenticatedAttributes ) ) ; } v . add ( digEncryptionAlgorithm ) ; v . add ( encryptedDigest ) ; if ( unauthenticatedAttributes ! = null ) { v . add ( new DERTaggedObject ( false , 1 , unauthenticatedAttributes ) ) ; } return new DERSequence ( v ) ; } 
public static SMIMECapabilities getInstance ( Object o ) { if ( o = = null | | o instanceof SMIMECapabilities ) { return ( SMIMECapabilities ) o ; } if ( o instanceof ASN1Sequence ) { return new SMIMECapabilities ( ( ASN1Sequence ) o ) ; } if ( o instanceof Attribute ) { return new SMIMECapabilities ( ( ASN1Sequence ) ( ( ( Attribute ) o ) . getAttrValues ( ) . getObjectAt ( 0 ) ) ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { return capabilities ; } 
public static SMIMECapability getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SMIMECapability ) { return ( SMIMECapability ) obj ; } if ( obj instanceof ASN1Sequence ) { return new SMIMECapability ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid SMIMECapability " ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( capabilityID ) ; if ( parameters ! = null ) { v . add ( parameters ) ; } return new DERSequence ( v ) ; } 
public void addCapability ( DERObjectIdentifier capability ) { capabilities . add ( new DERSequence ( capability ) ) ; } 
public void addCapability ( DERObjectIdentifier capability , int value ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( capability ) ; v . add ( new DERInteger ( value ) ) ; capabilities . add ( new DERSequence ( v ) ) ; } 
public void addCapability ( DERObjectIdentifier capability , DEREncodable params ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( capability ) ; v . add ( params ) ; capabilities . add ( new DERSequence ( v ) ) ; } 
public DEREncodableVector oDEREncodableVector ( ) { return capabilities ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( seconds ! = null ) { v . add ( seconds ) ; } if ( millis ! = null ) { v . add ( new DERTaggedObject ( false , 0 , millis ) ) ; } if ( micros ! = null ) { v . add ( new DERTaggedObject ( false , 1 , micros ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( hashAlgorithm ) ; v . add ( new DEROctetString ( hashedMessage ) ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( messageImprint ) ; if ( saPolicy ! = null ) { v . add ( saPolicy ) ; } if ( nonce ! = null ) { v . add ( nonce ) ; } if ( certReq ! = null & & certReq . isTrue ( ) ) { v . add ( certReq ) ; } if ( extensions ! = null ) { v . add ( new DERTaggedObject ( false , 0 , extensions ) ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( pkiStatusInfo ) ; if ( imeStampToken ! = null ) { v . add ( imeStampToken ) ; } return new DERSequence ( v ) ; } 
static void _dumpAsString ( String indent , boolean verbose , DERObject obj , StringBuffer buf ) { String nl = System . getProperty ( " line.separator " ) ; if ( obj instanceof ASN1Sequence ) { 
public static String dumpAsString ( Object obj ) { return dumpAsString ( obj , false ) ; } 
public static String dumpAsString ( Object obj , boolean verbose ) { StringBuffer buf = new StringBuffer ( ) ; if ( obj instanceof DERObject ) { _dumpAsString ( " " , verbose , ( DERObject ) obj , buf ) ; } else if ( obj instanceof DEREncodable ) { _dumpAsString ( " " , verbose , ( ( DEREncodable ) obj ) . getDERObject ( ) , buf ) ; } else { return " unknown object type " + obj . oString ( ) ; } return buf . oString ( ) ; } 
private static String dumpBinaryDataAsString ( String indent , byte [ ] bytes ) { String nl = System . getProperty ( " line.separator " ) ; StringBuffer buf = new StringBuffer ( ) ; indent + = TAB ; buf . append ( nl ) ; for ( int i = 0 ; i < bytes . length ; i + = SAMPLE_SIZE ) { if ( bytes . length - i > SAMPLE_SIZE ) { buf . append ( indent ) ; buf . append ( new String ( Hex . encode ( bytes , i , SAMPLE_SIZE ) ) ) ; buf . append ( TAB ) ; buf . append ( calculateAscString ( bytes , i , SAMPLE_SIZE ) ) ; buf . append ( nl ) ; } else { buf . append ( indent ) ; buf . append ( new String ( Hex . encode ( bytes , i , bytes . length - i ) ) ) ; for ( int j = bytes . length - i ; j ! = SAMPLE_SIZE ; j + + ) { buf . append ( " " ) ; } buf . append ( TAB ) ; buf . append ( calculateAscString ( bytes , i , bytes . length - i ) ) ; buf . append ( nl ) ; } } return buf . oString ( ) ; } 
private static String calculateAscString ( byte [ ] bytes , int off , int len ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = off ; i ! = off + len ; i + + ) { if ( bytes [ i ] > = ' ' & & bytes [ i ] < = '~' ) { buf . append ( ( char ) bytes [ i ] ) ; } } return buf . oString ( ) ; } 
public static String dumpAsString ( DERObject obj ) { StringBuffer buf = new StringBuffer ( ) ; _dumpAsString ( " " , false , obj , buf ) ; return buf . oString ( ) ; } 
public static String dumpAsString ( DEREncodable obj ) { StringBuffer buf = new StringBuffer ( ) ; _dumpAsString ( " " , false , obj . getDERObject ( ) , buf ) ; return buf . oString ( ) ; } 
public static void main ( String args [ ] ) hrows Exception { FileInputStream fIn = new FileInputStream ( args [ 0 ] ) ; ASN1InputStream bIn = new ASN1InputStream ( fIn ) ; Object obj = null ; while ( ( obj = bIn . readObject ( ) ) ! = null ) { 
public String oString ( ) { return string . getString ( ) ; } 
public DERObject oASN1Object ( ) { return ( ( DEREncodable ) string ) . getDERObject ( ) ; } 
public static AlgorithmIdentifier getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static AlgorithmIdentifier getInstance ( Object obj ) { if ( obj = = null | | obj instanceof AlgorithmIdentifier ) { return ( AlgorithmIdentifier ) obj ; } if ( obj instanceof DERObjectIdentifier ) { return new AlgorithmIdentifier ( ( DERObjectIdentifier ) obj ) ; } if ( obj instanceof String ) { return new AlgorithmIdentifier ( ( String ) obj ) ; } if ( obj instanceof ASN1Sequence ) { return new AlgorithmIdentifier ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( objectId ) ; if ( parametersDefined ) { v . add ( parameters ) ; } return new DERSequence ( v ) ; } 
public static AttCertValidityPeriod getInstance ( Object obj ) { if ( obj instanceof AttCertValidityPeriod ) { return ( AttCertValidityPeriod ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new AttCertValidityPeriod ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( notBeforeTime ) ; v . add ( notAfterTime ) ; return new DERSequence ( v ) ; } 
public static BasicConstraints getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static BasicConstraints getInstance ( Object obj ) { if ( obj = = null | | obj instanceof BasicConstraints ) { return ( BasicConstraints ) obj ; } if ( obj instanceof ASN1Sequence ) { return new BasicConstraints ( ( ASN1Sequence ) obj ) ; } if ( obj instanceof X509Extension ) { return getInstance ( X509Extension . convertValueToObject ( ( X509Extension ) obj ) ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public boolean isCA ( ) { return ( cA ! = null ) & & cA . isTrue ( ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( cA ! = null ) { v . add ( cA ) ; } if ( pathLenConstraint ! = null ) yes some people actually do this when cA is false... { v.add(pathLenConstraint); } return new DERSequence(v); } 
public String oString ( ) { if ( pathLenConstraint = = null ) { if ( cA = = null ) { return " BasicConstraints: isCa(false) " ; } return " BasicConstraints: isCa( " + his . isCA ( ) + " ) " ; } return " BasicConstraints: isCa( " + his . isCA ( ) + " ), pathLenConstraint = " + pathLenConstraint . getValue ( ) ; } 
public String oString ( ) { return " CRLNumber: " + getCRLNumber ( ) ; } 
public String oString ( ) { String str ; int reason = getValue ( ) . intValue ( ) ; if ( reason < 0 | | reason > 10 ) { str = " invalid " ; } else { str = reasonString [ reason ] ; } return " CRLReason: " + str ; } 
public static CertificateList getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static CertificateList getInstance ( Object obj ) { if ( obj instanceof CertificateList ) { return ( CertificateList ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new CertificateList ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( bsCertList ) ; v . add ( sigAlgId ) ; v . add ( sig ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; if ( forward ! = null ) { vec . add ( new DERTaggedObject ( 0 , forward ) ) ; } if ( reverse ! = null ) { vec . add ( new DERTaggedObject ( 1 , reverse ) ) ; } return new DERSequence ( vec ) ; } 
public static CertificatePolicies getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static CertificatePolicies getInstance ( Object obj ) { if ( obj instanceof CertificatePolicies ) { return ( CertificatePolicies ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new CertificatePolicies ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public void addPolicy ( String p ) { policies . addElement ( new DERObjectIdentifier ( p ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; We only do policyIdentifier yet... for (int i=0;i<policies.size();i++) { v.add(new DERSequence((DERObjectIdentifier)policies.elementAt(i))); } return new DERSequence(v); } 
public String oString ( ) { String p = null ; for ( int i = 0 ; i < policies . size ( ) ; i + + ) { if ( p ! = null ) { p + = " , " ; } p + = ( ( DERObjectIdentifier ) policies . elementAt ( i ) ) . getId ( ) ; } return " CertificatePolicies: " + p ; } 
public static DSAParameter getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static DSAParameter getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DSAParameter ) { return ( DSAParameter ) obj ; } if ( obj instanceof ASN1Sequence ) { return new DSAParameter ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid DSAParameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( p ) ; v . add ( q ) ; v . add ( g ) ; return new DERSequence ( v ) ; } 
public static DigestInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static DigestInfo getInstance ( Object obj ) { if ( obj instanceof DigestInfo ) { return ( DigestInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new DigestInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algId ) ; v . add ( new DEROctetString ( digest ) ) ; return new DERSequence ( v ) ; } 
public static DisplayText getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; must be explicitly tagged } 
public DERObject oASN1Object ( ) { return ( DERObject ) contents ; } 
public static ExtendedKeyUsage getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static ExtendedKeyUsage getInstance ( Object obj ) { if ( obj instanceof ExtendedKeyUsage ) { return ( ExtendedKeyUsage ) obj ; } if ( obj instanceof ASN1Sequence ) { return new ExtendedKeyUsage ( ( ASN1Sequence ) obj ) ; } if ( obj instanceof X509Extension ) { return getInstance ( X509Extension . convertValueToObject ( ( X509Extension ) obj ) ) ; } hrow new IllegalArgumentException ( " Invalid ExtendedKeyUsage: " + obj . getClass ( ) . getName ( ) ) ; } 
public boolean hasKeyPurposeId ( KeyPurposeId keyPurposeId ) { return ( usageTable . get ( keyPurposeId ) ! = null ) ; } 
public int size ( ) { return usageTable . size ( ) ; } 
public DERObject oASN1Object ( ) { return seq ; } 
public static DERBitString getInstance ( Object obj ) needs to be DERBitString for other VMs { if (obj instanceof KeyUsage) { return (KeyUsage)obj; } if (obj instanceof X509Extension) { return new KeyUsage(DERBitString.getInstance(X509Extension.convertValueToObject((X509Extension)obj))); } return new KeyUsage(DERBitString.getInstance(obj)); } 
public String oString ( ) { if ( data . length = = 1 ) { return " KeyUsage: 0x " + Integer . oHexString ( data [ 0 ] & 0xff ) ; } return " KeyUsage: 0x " + Integer . oHexString ( ( data [ 1 ] & 0xff ) < < 8 | ( data [ 0 ] & 0xff ) ) ; } 
public static NoticeReference getInstance ( Object as ) { if ( as instanceof NoticeReference ) { return ( NoticeReference ) as ; } else if ( as instanceof ASN1Sequence ) { return new NoticeReference ( ( ASN1Sequence ) as ) ; } hrow new IllegalArgumentException ( " unknown object in getInstance. " ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector av = new ASN1EncodableVector ( ) ; av . add ( organization ) ; av . add ( noticeNumbers ) ; return new DERSequence ( av ) ; } 
public static ObjectDigestInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ObjectDigestInfo ) { return ( ObjectDigestInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new ObjectDigestInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; 
public static ObjectDigestInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( digestedObjectType ) ; if ( otherObjectTypeID ! = null ) { v . add ( otherObjectTypeID ) ; } v . add ( digestAlgorithm ) ; v . add ( objectDigest ) ; return new DERSequence ( v ) ; } 
public static PolicyInformation getInstance ( Object obj ) { if ( obj = = null | | obj instanceof PolicyInformation ) { return ( PolicyInformation ) obj ; } return new PolicyInformation ( ASN1Sequence . getInstance ( obj ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( policyIdentifier ) ; if ( policyQualifiers ! = null ) { v . add ( policyQualifiers ) ; } return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { return seq ; } 
public static PolicyQualifierInfo getInstance ( Object as ) { if ( as instanceof PolicyQualifierInfo ) { return ( PolicyQualifierInfo ) as ; } else if ( as instanceof ASN1Sequence ) { return new PolicyQualifierInfo ( ( ASN1Sequence ) as ) ; } hrow new IllegalArgumentException ( " unknown object in getInstance. " ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector dev = new ASN1EncodableVector ( ) ; dev . add ( policyQualifierId ) ; dev . add ( qualifier ) ; return new DERSequence ( dev ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( _notBefore ! = null ) { v . add ( new DERTaggedObject ( false , 0 , _notBefore ) ) ; } if ( _notAfter ! = null ) { v . add ( new DERTaggedObject ( false , 1 , _notAfter ) ) ; } return new DERSequence ( v ) ; } 
public static RSAPublicKeyStructure getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static RSAPublicKeyStructure getInstance ( Object obj ) { if ( obj = = null | | obj instanceof RSAPublicKeyStructure ) { return ( RSAPublicKeyStructure ) obj ; } if ( obj instanceof ASN1Sequence ) { return new RSAPublicKeyStructure ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " Invalid RSAPublicKeyStructure: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( getModulus ( ) ) ) ; v . add ( new DERInteger ( getPublicExponent ( ) ) ) ; return new DERSequence ( v ) ; } 
public static SubjectDirectoryAttributes getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SubjectDirectoryAttributes ) { return ( SubjectDirectoryAttributes ) obj ; } if ( obj instanceof ASN1Sequence ) { return new SubjectDirectoryAttributes ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { vec . add ( ( Attribute ) e . nextElement ( ) ) ; } return new DERSequence ( vec ) ; } 
public static SubjectPublicKeyInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static SubjectPublicKeyInfo getInstance ( Object obj ) { if ( obj instanceof SubjectPublicKeyInfo ) { return ( SubjectPublicKeyInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SubjectPublicKeyInfo ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject getPublicKey ( ) hrows IOException { ASN1InputStream aIn = new ASN1InputStream ( keyData . getBytes ( ) ) ; return aIn . readObject ( ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algId ) ; v . add ( keyData ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { return seq ; } 
public boolean hasMoreElements ( ) { return en . hasMoreElements ( ) ; } 
public Object nextElement ( ) { return new CRLEntry ( ASN1Sequence . getInstance ( en . nextElement ( ) ) ) ; } 
public boolean hasMoreElements ( ) { return false ; } 
public Object nextElement ( ) { return null ; TODO: check exception handling } 
public static TBSCertList getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static TBSCertList getInstance ( Object obj ) { if ( obj instanceof TBSCertList ) { return ( TBSCertList ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new TBSCertList ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public static TBSCertificateStructure getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static TBSCertificateStructure getInstance ( Object obj ) { if ( obj instanceof TBSCertificateStructure ) { return ( TBSCertificateStructure ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new TBSCertificateStructure ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public static Time getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; must be explicitly tagged } 
public String oString ( ) { return getTime ( ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector av = new ASN1EncodableVector ( ) ; if ( noticeRef ! = null ) { av . add ( noticeRef ) ; } if ( explicitText ! = null ) { av . add ( explicitText ) ; } return new DERSequence ( av ) ; } 
public void setSerialNumber ( DERInteger serialNumber ) { his . serialNumber = serialNumber ; } 
public void setSignature ( AlgorithmIdentifier signature ) { his . signature = signature ; } 
public void setIssuer ( X509Name issuer ) { his . issuer = issuer ; } 
public void setStartDate ( Time startDate ) { his . startDate = startDate ; } 
public void setStartDate ( DERUTCTime startDate ) { his . startDate = new Time ( startDate ) ; } 
public void setEndDate ( Time endDate ) { his . endDate = endDate ; } 
public void setEndDate ( DERUTCTime endDate ) { his . endDate = new Time ( endDate ) ; } 
public void setSubject ( X509Name subject ) { his . subject = subject ; } 
public void setSubjectPublicKeyInfo ( SubjectPublicKeyInfo pubKeyInfo ) { his . subjectPublicKeyInfo = pubKeyInfo ; } 
public TBSCertificateStructure generateTBSCertificate ( ) { if ( ( serialNumber = = null ) | | ( signature = = null ) | | ( issuer = = null ) | | ( startDate = = null ) | | ( endDate = = null ) | | ( subject = = null ) | | ( subjectPublicKeyInfo = = null ) ) { hrow new IllegalStateException ( " not all mandatory fields set in V1 TBScertificate generator " ) ; } ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq.add(version); - not required as default value. seq.add(serialNumber); seq.add(signature); seq.add(issuer); before and after dates ASN1EncodableVector validity = new ASN1EncodableVector(); validity.add(startDate); validity.add(endDate); seq.add(new DERSequence(validity)); seq.add(subject); seq.add(subjectPublicKeyInfo); return new TBSCertificateStructure(new DERSequence(seq)); } 
public void setThisUpdate ( DERUTCTime hisUpdate ) { his . hisUpdate = new Time ( hisUpdate ) ; } 
public void setNextUpdate ( DERUTCTime nextUpdate ) { his . nextUpdate = new Time ( nextUpdate ) ; } 
public void setThisUpdate ( Time hisUpdate ) { his . hisUpdate = hisUpdate ; } 
public void setNextUpdate ( Time nextUpdate ) { his . nextUpdate = nextUpdate ; } 
public void addCRLEntry ( ASN1Sequence crlEntry ) { if ( crlentries = = null ) { crlentries = new Vector ( ) ; } crlentries . addElement ( crlEntry ) ; } 
public void addCRLEntry ( DERInteger userCertificate , DERUTCTime revocationDate , int reason ) { addCRLEntry ( userCertificate , new Time ( revocationDate ) , reason ) ; } 
public void addCRLEntry ( DERInteger userCertificate , Time revocationDate , int reason ) { addCRLEntry ( userCertificate , revocationDate , reason , null ) ; } 
public void addCRLEntry ( DERInteger userCertificate , Time revocationDate , int reason , DERGeneralizedTime invalidityDate ) { Vector extOids = new Vector ( ) ; Vector extValues = new Vector ( ) ; if ( reason ! = 0 ) { CRLReason crlReason = new CRLReason ( reason ) ; ry { extOids . addElement ( X509Extensions . ReasonCode ) ; extValues . addElement ( new X509Extension ( false , new DEROctetString ( crlReason . getEncoded ( ) ) ) ) ; } catch ( IOException e ) { hrow new IllegalArgumentException ( " error encoding reason: " + e ) ; } } if ( invalidityDate ! = null ) { ry { extOids . addElement ( X509Extensions . InvalidityDate ) ; extValues . addElement ( new X509Extension ( false , new DEROctetString ( invalidityDate . getEncoded ( ) ) ) ) ; } catch ( IOException e ) { hrow new IllegalArgumentException ( " error encoding invalidityDate: " + e ) ; } } if ( extOids . size ( ) ! = 0 ) { 
public void addCRLEntry ( DERInteger userCertificate , Time revocationDate , X509Extensions extensions ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( userCertificate ) ; v . add ( revocationDate ) ; if ( extensions ! = null ) { v . add ( extensions ) ; } addCRLEntry ( new DERSequence ( v ) ) ; } 
public void setExtensions ( X509Extensions extensions ) { his . extensions = extensions ; } 
public TBSCertList generateTBSCertList ( ) { if ( ( signature = = null ) | | ( issuer = = null ) | | ( hisUpdate = = null ) ) { hrow new IllegalStateException ( " Not all mandatory fields set in V2 TBSCertList generator. " ) ; } ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( signature ) ; v . add ( issuer ) ; v . add ( hisUpdate ) ; if ( nextUpdate ! = null ) { v . add ( nextUpdate ) ; } Add CRLEntries if they exist if (crlentries != null) { ASN1EncodableVector certs = new ASN1EncodableVector(); Enumeration it = crlentries.elements(); while(it.hasMoreElements()) { certs.add((ASN1Sequence)it.nextElement()); } v.add(new DERSequence(certs)); } if (extensions != null) { v.add(new DERTaggedObject(0, extensions)); } return new TBSCertList(new DERSequence(v)); } 
public void setIssuerUniqueID ( DERBitString uniqueID ) { his . issuerUniqueID = uniqueID ; } 
public void setSubjectUniqueID ( DERBitString uniqueID ) { his . subjectUniqueID = uniqueID ; } 
public void setExtensions ( X509Extensions extensions ) { his . extensions = extensions ; if ( extensions ! = null ) { 
public TBSCertificateStructure generateTBSCertificate ( ) { if ( ( serialNumber = = null ) | | ( signature = = null ) | | ( issuer = = null ) | | ( startDate = = null ) | | ( endDate = = null ) | | ( subject = = null & & ! altNamePresentAndCritical ) | | ( subjectPublicKeyInfo = = null ) ) { hrow new IllegalStateException ( " not all mandatory fields set in V3 TBScertificate generator " ) ; } ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( serialNumber ) ; v . add ( signature ) ; v . add ( issuer ) ; before and after dates ASN1EncodableVector validity = new ASN1EncodableVector(); validity.add(startDate); validity.add(endDate); v.add(new DERSequence(validity)); if (subject != null) { v.add(subject); } else { v.add(new DERSequence()); } v.add(subjectPublicKeyInfo); if (issuerUniqueID != null) { v.add(new DERTaggedObject(false, 1, issuerUniqueID)); } if (subjectUniqueID != null) { v.add(new DERTaggedObject(false, 2, subjectUniqueID)); } if (extensions != null) { v.add(new DERTaggedObject(3, extensions)); } return new TBSCertificateStructure(new DERSequence(v)); } 
public static X509CertificateStructure getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static X509CertificateStructure getInstance ( Object obj ) { if ( obj instanceof X509CertificateStructure ) { return ( X509CertificateStructure ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new X509CertificateStructure ( ( ASN1Sequence ) obj ) ; } if ( obj ! = null ) { hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } hrow new IllegalArgumentException ( " null object in factory " ) ; } 
public DERObject getConvertedValue ( DERObjectIdentifier oid , String value ) { if ( value . length ( ) ! = 0 & & value . charAt ( 0 ) = = '#' ) { ry { return convertHexEncoded ( value , 1 ) ; } catch ( IOException e ) { hrow new RuntimeException ( " can't recode value for oid " + oid . getId ( ) ) ; } } else { if ( value . length ( ) ! = 0 & & value . charAt ( 0 ) = = '\\' ) { value = value . substring ( 1 ) ; } if ( oid . equals ( X509Name . EmailAddress ) | | oid . equals ( X509Name . DC ) ) { return new DERIA5String ( value ) ; } else if ( oid . equals ( X509Name . DATE_OF_BIRTH ) ) accept time string as well as # (for compatibility) { return new DERGeneralizedTime(value); } else if (oid.equals(X509Name.C) || oid.equals(X509Name.SN) || oid.equals(X509Name.DN_QUALIFIER) || oid.equals(X509Name.TELEPHONE_NUMBER)) { return new DERPrintableString(value); } } return new DERUTF8String(value); } 
public boolean isCritical ( ) { return critical ; } 
public int hashCode ( ) { if ( his . isCritical ( ) ) { return his . getValue ( ) . hashCode ( ) ; } return ~ his . getValue ( ) . hashCode ( ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof X509Extension ) ) { return false ; } X509Extension other = ( X509Extension ) o ; return other . getValue ( ) . equals ( his . getValue ( ) ) & & ( other . isCritical ( ) = = his . isCritical ( ) ) ; 
public static ASN1Object convertValueToObject ( X509Extension ext ) hrows IllegalArgumentException { ry { 
public static X509Extensions getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static X509Extensions getInstance ( Object obj ) { if ( obj = = null | | obj instanceof X509Extensions ) { return ( X509Extensions ) obj ; } if ( obj instanceof ASN1Sequence ) { return new X509Extensions ( ( ASN1Sequence ) obj ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } hrow new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public Enumeration oids ( ) { return ordering . elements ( ) ; } 
public X509Extension getExtension ( DERObjectIdentifier oid ) { return ( X509Extension ) extensions . get ( oid ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; Enumeration e = ordering . elements ( ) ; while ( e . hasMoreElements ( ) ) { DERObjectIdentifier oid = ( DERObjectIdentifier ) e . nextElement ( ) ; X509Extension ext = ( X509Extension ) extensions . get ( oid ) ; ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( oid ) ; if ( ext . isCritical ( ) ) { v . add ( new DERBoolean ( rue ) ) ; } v . add ( ext . getValue ( ) ) ; vec . add ( new DERSequence ( v ) ) ; } return new DERSequence ( vec ) ; } 
public boolean equivalent ( X509Extensions other ) { if ( extensions . size ( ) ! = other . extensions . size ( ) ) { return false ; } Enumeration e1 = extensions . keys ( ) ; while ( e1 . hasMoreElements ( ) ) { Object key = e1 . nextElement ( ) ; if ( ! extensions . get ( key ) . equals ( other . extensions . get ( key ) ) ) { return false ; } } return rue ; } 
public void reset ( ) { extensions = new Hashtable ( ) ; extOrdering = new Vector ( ) ; } 
public void addExtension ( DERObjectIdentifier oid , boolean critical , DEREncodable value ) { ry { 
public void addExtension ( DERObjectIdentifier oid , boolean critical , byte [ ] value ) { if ( extensions . containsKey ( oid ) ) { hrow new IllegalArgumentException ( " extension " + oid + " already added " ) ; } extOrdering . addElement ( oid ) ; extensions . put ( oid , new X509Extension ( critical , new DEROctetString ( value ) ) ) ; } 
public boolean isEmpty ( ) { return extOrdering . isEmpty ( ) ; } 
public X509Extensions generate ( ) { return new X509Extensions ( extOrdering , extensions ) ; } 
public static X509Name getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static X509Name getInstance ( Object obj ) { if ( obj = = null | | obj instanceof X509Name ) { return ( X509Name ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new X509Name ( ( ASN1Sequence ) obj ) ; } hrow new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
private DERObjectIdentifier decodeOID ( String name , Hashtable lookUp ) { if ( Strings . oUpperCase ( name ) . startsWith ( " OID. " ) ) { return new DERObjectIdentifier ( name . substring ( 4 ) ) ; } else if ( name . charAt ( 0 ) > = '0' & & name . charAt ( 0 ) < = '9' ) { return new DERObjectIdentifier ( name ) ; } DERObjectIdentifier oid = ( DERObjectIdentifier ) lookUp . get ( Strings . oLowerCase ( name ) ) ; if ( oid = = null ) { hrow new IllegalArgumentException ( " Unknown object id - " + name + " - passed to distinguished name " ) ; } return oid ; } 
public Vector getValues ( DERObjectIdentifier oid ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i ! = values . size ( ) ; i + + ) { if ( ordering . elementAt ( i ) . equals ( oid ) ) { String val = ( String ) values . elementAt ( i ) ; if ( val . length ( ) > 2 & & val . charAt ( 0 ) = = '\\' & & val . charAt ( 1 ) = = '#' ) { v . addElement ( val . substring ( 1 ) ) ; } else { v . addElement ( val ) ; } } } return v ; } 
public DERObject oASN1Object ( ) { if ( seq = = null ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; ASN1EncodableVector sVec = new ASN1EncodableVector ( ) ; DERObjectIdentifier lstOid = null ; for ( int i = 0 ; i ! = ordering . size ( ) ; i + + ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; DERObjectIdentifier oid = ( DERObjectIdentifier ) ordering . elementAt ( i ) ; v . add ( oid ) ; String str = ( String ) values . elementAt ( i ) ; v . add ( converter . getConvertedValue ( oid , str ) ) ; if ( lstOid = = null | | ( ( Boolean ) his . added . elementAt ( i ) ) . booleanValue ( ) ) { sVec . add ( new DERSequence ( v ) ) ; } else { vec . add ( new DERSet ( sVec ) ) ; sVec = new ASN1EncodableVector ( ) ; sVec . add ( new DERSequence ( v ) ) ; } lstOid = oid ; } vec . add ( new DERSet ( sVec ) ) ; seq = new DERSequence ( vec ) ; } return seq ; } 
public int hashCode ( ) { if ( isHashCodeCalculated ) { return hashCodeValue ; } isHashCodeCalculated = rue ; this needs to be order independent, like equals for (int i = 0; i != ordering.size(); i += 1) { String value = (String)values.elementAt(i); value = canonicalize(value); value = stripInternalSpaces(value); hashCodeValue ^= value.hashCode(); } return hashCodeValue; } 
private boolean equivalentStrings ( String s1 , String s2 ) { String value = canonicalize ( s1 ) ; String oValue = canonicalize ( s2 ) ; if ( ! value . equals ( oValue ) ) { value = stripInternalSpaces ( value ) ; oValue = stripInternalSpaces ( oValue ) ; if ( ! value . equals ( oValue ) ) { return false ; } } return rue ; } 
private String canonicalize ( String s ) { String value = Strings . oLowerCase ( s . rim ( ) ) ; if ( value . length ( ) > 0 & & value . charAt ( 0 ) = = '#' ) { DERObject obj = decodeObject ( value ) ; if ( obj instanceof DERString ) { value = Strings . oLowerCase ( ( ( DERString ) obj ) . getString ( ) . rim ( ) ) ; } } return value ; } 
private ASN1Object decodeObject ( String oValue ) { ry { 
private String stripInternalSpaces ( String str ) { StringBuffer res = new StringBuffer ( ) ; if ( str . length ( ) ! = 0 ) { char c1 = str . charAt ( 0 ) ; res . append ( c1 ) ; for ( int k = 1 ; k < str . length ( ) ; k + + ) { char c2 = str . charAt ( k ) ; if ( ! ( c1 = = ' ' & & c2 = = ' ' ) ) { res . append ( c2 ) ; } c1 = c2 ; } } return res . oString ( ) ; } 
private void appendValue ( StringBuffer buf , Hashtable oidSymbols , DERObjectIdentifier oid , String value ) { String sym = ( String ) oidSymbols . get ( oid ) ; if ( sym ! = null ) { buf . append ( sym ) ; } else { buf . append ( oid . getId ( ) ) ; } buf . append ( '=' ) ; int index = buf . length ( ) ; buf . append ( value ) ; int end = buf . length ( ) ; if ( value . length ( ) > = 2 & & value . charAt ( 0 ) = = '\\' & & value . charAt ( 1 ) = = '#' ) { index + = 2 ; } while ( index ! = end ) { 
public String oString ( boolean reverse , Hashtable oidSymbols ) { StringBuffer buf = new StringBuffer ( ) ; Vector components = new Vector ( ) ; boolean first = rue ; StringBuffer ava = null ; for ( int i = 0 ; i < ordering . size ( ) ; i + + ) { if ( ( ( Boolean ) added . elementAt ( i ) ) . booleanValue ( ) ) { ava . append ( '+' ) ; appendValue ( ava , oidSymbols , ( DERObjectIdentifier ) ordering . elementAt ( i ) , ( String ) values . elementAt ( i ) ) ; } else { ava = new StringBuffer ( ) ; appendValue ( ava , oidSymbols , ( DERObjectIdentifier ) ordering . elementAt ( i ) , ( String ) values . elementAt ( i ) ) ; components . addElement ( ava ) ; } } if ( reverse ) { for ( int i = components . size ( ) - 1 ; i > = 0 ; i - - ) { if ( first ) { first = false ; } else { buf . append ( ',' ) ; } buf . append ( components . elementAt ( i ) . oString ( ) ) ; } } else { for ( int i = 0 ; i < components . size ( ) ; i + + ) { if ( first ) { first = false ; } else { buf . append ( ',' ) ; } buf . append ( components . elementAt ( i ) . oString ( ) ) ; } } return buf . oString ( ) ; } 
private String bytesToString ( byte [ ] data ) { char [ ] cs = new char [ data . length ] ; for ( int i = 0 ; i ! = cs . length ; i + + ) { cs [ i ] = ( char ) ( data [ i ] & 0xff ) ; } return new String ( cs ) ; } 
public String oString ( ) { return oString ( DefaultReverse , DefaultSymbols ) ; } 
protected DERObject convertHexEncoded ( String str , int off ) hrows IOException { str = Strings . oLowerCase ( str ) ; byte [ ] data = new byte [ ( str . length ( ) - off ) / 2 ] ; for ( int index = 0 ; index ! = data . length ; index + + ) { char left = str . charAt ( ( index * 2 ) + off ) ; char right = str . charAt ( ( index * 2 ) + off + 1 ) ; if ( left < 'a' ) { data [ index ] = ( byte ) ( ( left - '0' ) < < 4 ) ; } else { data [ index ] = ( byte ) ( ( left - 'a' + 10 ) < < 4 ) ; } if ( right < 'a' ) { data [ index ] | = ( byte ) ( right - '0' ) ; } else { data [ index ] | = ( byte ) ( right - 'a' + 10 ) ; } } ASN1InputStream aIn = new ASN1InputStream ( data ) ; return aIn . readObject ( ) ; } 
protected boolean canBePrintable ( String str ) { return DERPrintableString . isPrintableString ( str ) ; } 
public abstract DERObject getConvertedValue ( DERObjectIdentifier oid , String value ) ; } 
public boolean hasMoreTokens ( ) { return ( index ! = value . length ( ) ) ; } 
public String nextToken ( ) { if ( index = = value . length ( ) ) { return null ; } int end = index + 1 ; boolean quoted = false ; boolean escaped = false ; buf . setLength ( 0 ) ; while ( end ! = value . length ( ) ) { char c = value . charAt ( end ) ; if ( c = = '"' ) { if ( ! escaped ) { quoted = ! quoted ; } else { buf . append ( c ) ; } escaped = false ; } else { if ( escaped | | quoted ) { if ( c = = '#' & & buf . charAt ( buf . length ( ) - 1 ) = = '=' ) { buf . append ( '\\' ) ; } else if ( c = = '+' & & seperator ! = '+' ) { buf . append ( '\\' ) ; } buf . append ( c ) ; escaped = false ; } else if ( c = = '\\' ) { escaped = rue ; } else if ( c = = seperator ) { break ; } else { buf . append ( c ) ; } } end + + ; } index = end ; return buf . oString ( ) . rim ( ) ; } 
public static BiometricData getInstance ( Object obj ) { if ( obj = = null | | obj instanceof BiometricData ) { return ( BiometricData ) obj ; } if ( obj instanceof ASN1Sequence ) { 
public DERObject oASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( ypeOfBiometricData ) ; seq . add ( hashAlgorithm ) ; seq . add ( biometricDataHash ) ; if ( sourceDataUri ! = null ) { seq . add ( sourceDataUri ) ; } return new DERSequence ( seq ) ; } 
public static Iso4217CurrencyCode getInstance ( Object obj ) { if ( obj = = null | | obj instanceof Iso4217CurrencyCode ) { return ( Iso4217CurrencyCode ) obj ; } if ( obj instanceof DERInteger ) { DERInteger numericobj = DERInteger . getInstance ( obj ) ; int numeric = numericobj . getValue ( ) . intValue ( ) ; return new Iso4217CurrencyCode ( numeric ) ; } else if ( obj instanceof DERPrintableString ) { DERPrintableString alphabetic = DERPrintableString . getInstance ( obj ) ; return new Iso4217CurrencyCode ( alphabetic . getString ( ) ) ; } hrow new IllegalArgumentException ( " unknown object in getInstance " ) ; } 
public boolean isAlphabetic ( ) { return obj instanceof DERPrintableString ; } 
public DERObject oASN1Object ( ) { return obj . getDERObject ( ) ; } 
public static MonetaryValue getInstance ( Object obj ) { if ( obj = = null | | obj instanceof MonetaryValue ) { return ( MonetaryValue ) obj ; } if ( obj instanceof ASN1Sequence ) { return new MonetaryValue ( ASN1Sequence . getInstance ( obj ) ) ; } hrow new IllegalArgumentException ( " unknown object in getInstance " ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( currency ) ; seq . add ( amount ) ; seq . add ( exponent ) ; return new DERSequence ( seq ) ; } 
public static QCStatement getInstance ( Object obj ) { if ( obj = = null | | obj instanceof QCStatement ) { return ( QCStatement ) obj ; } if ( obj instanceof ASN1Sequence ) { return new QCStatement ( ASN1Sequence . getInstance ( obj ) ) ; } hrow new IllegalArgumentException ( " unknown object in getInstance " ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( qcStatementId ) ; if ( qcStatementInfo ! = null ) { seq . add ( qcStatementInfo ) ; } return new DERSequence ( seq ) ; } 
public boolean isPredefined ( ) { return obj instanceof DERInteger ; } 
public DERObject oASN1Object ( ) { return obj . getDERObject ( ) ; } 
public DERObject oASN1Object ( ) { if ( pseudonym ! = null ) { 
public DERObject oASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; vec . add ( nameOrPseudonym ) ; if ( nameDistinguisher ! = null ) { vec . add ( new DERTaggedObject ( false , 0 , new DERInteger ( nameDistinguisher ) ) ) ; } if ( dateOfBirth ! = null ) { vec . add ( new DERTaggedObject ( false , 1 , dateOfBirth ) ) ; } if ( placeOfBirth ! = null ) { vec . add ( new DERTaggedObject ( rue , 2 , placeOfBirth ) ) ; } if ( gender ! = null ) { vec . add ( new DERTaggedObject ( false , 3 , new DERPrintableString ( gender , rue ) ) ) ; } if ( postalAddress ! = null ) { vec . add ( new DERTaggedObject ( rue , 4 , postalAddress ) ) ; } return new DERSequence ( vec ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algorithm ) ; v . add ( counter ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( keyInfo ) ; if ( partyAInfo ! = null ) { v . add ( new DERTaggedObject ( 0 , partyAInfo ) ) ; } v . add ( new DERTaggedObject ( 2 , suppPubInfo ) ) ; return new DERSequence ( v ) ; } 
public DERObject oASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( his . id ) ; v . add ( his . parameters ) ; return new DERSequence ( v ) ; } 
public void init ( CipherParameters params ) hrows IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public int getMacSize ( ) ; public void reset ( ) ; } 
public void update ( byte in ) hrows IllegalStateException ; public void reset ( ) ; } 
public void update ( byte [ ] in , int inOff , int len ) hrows DataLengthException , IllegalStateException ; public void reset ( ) ; } 
public void init ( boolean forEncryption , CipherParameters params ) { cipher . init ( forEncryption , params ) ; } 
public byte returnByte ( byte in ) { oneByte [ 0 ] = in ; cipher . processBlock ( oneByte , 0 , oneByte , 0 ) ; return oneByte [ 0 ] ; } 
public void processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) hrows DataLengthException { if ( outOff + len > out . length ) { hrow new DataLengthException ( " output buffer too small in processBytes() " ) ; } for ( int i = 0 ; i ! = len ; i + + ) { 
public void init ( boolean forWrapping , CipherParameters param ) ; public String getAlgorithmName ( ) ; public byte [ ] wrap ( byte [ ] in , int inOff , int inLen ) ; public byte [ ] unwrap ( byte [ ] in , int inOff , int inLen ) hrows InvalidCipherTextException ; } 
public String getAlgorithmName ( ) ; public byte [ ] wrap ( byte [ ] in , int inOff , int inLen ) ; public byte [ ] unwrap ( byte [ ] in , int inOff , int inLen ) hrows InvalidCipherTextException ; } 
public byte [ ] wrap ( byte [ ] in , int inOff , int inLen ) ; public byte [ ] unwrap ( byte [ ] in , int inOff , int inLen ) hrows InvalidCipherTextException ; } 
public byte [ ] unwrap ( byte [ ] in , int inOff , int inLen ) hrows InvalidCipherTextException ; } 
public int doFinal ( byte [ ] out , int outOff ) { add padding byte paddingByte = (byte)(M.length-mOff); for (int i=mOff;i<M.length;i++) { M[i] = paddingByte; } do final check sum processCheckSum(M); do final block process processBlock(M); processBlock(C); System.arraycopy(X,xOff,out,outOff,16); reset(); return DIGEST_LENGTH; } 
public void reset ( ) { xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { X [ i ] = 0 ; } mOff = 0 ; for ( int i = 0 ; i ! = M . length ; i + + ) { M [ i ] = 0 ; } COff = 0 ; for ( int i = 0 ; i ! = C . length ; i + + ) { 
public void update ( byte in ) { M [ mOff + + ] = in ; if ( mOff = = 16 ) { 
public void update ( byte [ ] in , int inOff , int len ) { fill the current word while ((mOff != 0) && (len > 0)) { update(in[inOff]); inOff++; len--; } process whole words. while (len > 16) { System.arraycopy(in,inOff,M,0,16); processCheckSum(M); processBlock(M); len -= 16; inOff += 16; } load in the remainder. while (len > 0) { 
protected void processCheckSum ( byte [ ] m ) { int L = C [ 15 ] ; for ( int i = 0 ; i < 16 ; i + + ) { 
protected void processBlock ( byte [ ] m ) { for ( int i = 0 ; i < 16 ; i + + ) { X [ i + 16 ] = m [ i ] ; X [ i + 32 ] = ( byte ) ( m [ i ] ^ X [ i ] ) ; } encrypt block int t = 0; for (int j=0;j<18;j++) { 
protected void processWord ( byte [ ] in , int inOff ) { X [ xOff + + ] = ( in [ inOff ] & 0xff ) | ( ( in [ inOff + 1 ] & 0xff ) < < 8 ) | ( ( in [ inOff + 2 ] & 0xff ) < < 16 ) | ( ( in [ inOff + 3 ] & 0xff ) < < 24 ) ; if ( xOff = = 16 ) { 
protected void processLength ( long bitLength ) { if ( xOff > 14 ) { processBlock ( ) ; } X [ 14 ] = ( int ) ( bitLength & 0xffffffff ) ; X [ 15 ] = ( int ) ( bitLength > > > 32 ) ; } 
private void unpackWord ( int word , byte [ ] out , int outOff ) { out [ outOff ] = ( byte ) word ; out [ outOff + 1 ] = ( byte ) ( word > > > 8 ) ; out [ outOff + 2 ] = ( byte ) ( word > > > 16 ) ; out [ outOff + 3 ] = ( byte ) ( word > > > 24 ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H1 , out , outOff ) ; unpackWord ( H2 , out , outOff + 4 ) ; unpackWord ( H3 , out , outOff + 8 ) ; unpackWord ( H4 , out , outOff + 12 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H1 = 0x67452301 ; H2 = 0xefcdab89 ; H3 = 0x98badcfe ; H4 = 0x10325476 ; xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { 
private int rotateLeft ( int x , int ) { return ( x < < ) | ( x > > > ( 32 - ) ) ; } 
private int F ( int u , int v , int w ) { return ( u & v ) | ( ~ u & w ) ; } 
private int G ( int u , int v , int w ) { return ( u & w ) | ( v & ~ w ) ; } 
private int H ( int u , int v , int w ) { return u ^ v ^ w ; } 
private int K ( int u , int v , int w ) { return v ^ ( u | ~ w ) ; } 
protected void processWord ( byte [ ] in , int inOff ) { X [ xOff + + ] = ( in [ inOff ] & 0xff ) | ( ( in [ inOff + 1 ] & 0xff ) < < 8 ) | ( ( in [ inOff + 2 ] & 0xff ) < < 16 ) | ( ( in [ inOff + 3 ] & 0xff ) < < 24 ) ; if ( xOff = = 16 ) { 
protected void processLength ( long bitLength ) { if ( xOff > 14 ) { processBlock ( ) ; } X [ 14 ] = ( int ) ( bitLength & 0xffffffff ) ; X [ 15 ] = ( int ) ( bitLength > > > 32 ) ; } 
private void unpackWord ( int word , byte [ ] out , int outOff ) { out [ outOff ] = ( byte ) word ; out [ outOff + 1 ] = ( byte ) ( word > > > 8 ) ; out [ outOff + 2 ] = ( byte ) ( word > > > 16 ) ; out [ outOff + 3 ] = ( byte ) ( word > > > 24 ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H0 , out , outOff ) ; unpackWord ( H1 , out , outOff + 4 ) ; unpackWord ( H2 , out , outOff + 8 ) ; unpackWord ( H3 , out , outOff + 12 ) ; unpackWord ( H4 , out , outOff + 16 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H0 = 0x67452301 ; H1 = 0xefcdab89 ; H2 = 0x98badcfe ; H3 = 0x10325476 ; H4 = 0xc3d2e1f0 ; xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { 
private int RL ( int x , int ) { return ( x < < ) | ( x > > > ( 32 - ) ) ; } 
private int f1 ( int x , int y , int z ) { return x ^ y ^ z ; } 
private int f2 ( int x , int y , int z ) { return ( x & y ) | ( ~ x & z ) ; } 
private int f3 ( int x , int y , int z ) { return ( x | ~ y ) ^ z ; } 
private int f4 ( int x , int y , int z ) { return ( x & z ) | ( y & ~ z ) ; } 
private int f5 ( int x , int y , int z ) { return x ^ ( y | ~ z ) ; } 
protected void processWord ( byte [ ] in , int inOff ) { Note: Inlined for performance X[xOff] = Pack.bigEndianToInt(in, inOff); int n = in[ inOff] << 24; n |= (in[++inOff] & 0xff) << 16; n |= (in[++inOff] & 0xff) << 8; n |= (in[++inOff] & 0xff); X[xOff] = n; if (++xOff == 16) { 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; Pack . intToBigEndian ( H1 , out , outOff ) ; Pack . intToBigEndian ( H2 , out , outOff + 4 ) ; Pack . intToBigEndian ( H3 , out , outOff + 8 ) ; Pack . intToBigEndian ( H4 , out , outOff + 12 ) ; Pack . intToBigEndian ( H5 , out , outOff + 16 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
protected void processWord ( byte [ ] in , int inOff ) { Note: Inlined for performance X[xOff] = Pack.bigEndianToInt(in, inOff); int n = in[inOff] << 24; n |= (in[++inOff] & 0xff) << 16; n |= (in[++inOff] & 0xff) << 8; n |= (in[++inOff] & 0xff); X[xOff] = n; if (++xOff == 16) { 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; Pack . intToBigEndian ( H1 , out , outOff ) ; Pack . intToBigEndian ( H2 , out , outOff + 4 ) ; Pack . intToBigEndian ( H3 , out , outOff + 8 ) ; Pack . intToBigEndian ( H4 , out , outOff + 12 ) ; Pack . intToBigEndian ( H5 , out , outOff + 16 ) ; Pack . intToBigEndian ( H6 , out , outOff + 20 ) ; Pack . intToBigEndian ( H7 , out , outOff + 24 ) ; Pack . intToBigEndian ( H8 , out , outOff + 28 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
protected void processBlock ( ) { expand 16 word block into 64 word blocks. for (int t = 16; t <= 63; t++) { X[t] = Theta1(X[t - 2]) + X[t - 7] + Theta0(X[t - 15]) + X[t - 16]; } set up working variables. int a = H1; int b = H2; int c = H3; int d = H4; int e = H5; int f = H6; int g = H7; int h = H8; int t = 0; for(int i = 0; i < 8; i ++) { t = 8 * i h += Sum1(e) + Ch(e, f, g) + K[t] + X[t]; d += h; h += Sum0(a) + Maj(a, b, c); ++t; t = 8 * i + 1 g += Sum1(d) + Ch(d, e, f) + K[t] + X[t]; c += g; g += Sum0(h) + Maj(h, a, b); ++t; t = 8 * i + 2 f += Sum1(c) + Ch(c, d, e) + K[t] + X[t]; b += f; f += Sum0(g) + Maj(g, h, a); ++t; t = 8 * i + 3 e += Sum1(b) + Ch(b, c, d) + K[t] + X[t]; a += e; e += Sum0(f) + Maj(f, g, h); ++t; t = 8 * i + 4 d += Sum1(a) + Ch(a, b, c) + K[t] + X[t]; h += d; d += Sum0(e) + Maj(e, f, g); ++t; t = 8 * i + 5 c += Sum1(h) + Ch(h, a, b) + K[t] + X[t]; g += c; c += Sum0(d) + Maj(d, e, f); ++t; t = 8 * i + 6 b += Sum1(g) + Ch(g, h, a) + K[t] + X[t]; f += b; b += Sum0(c) + Maj(c, d, e); ++t; t = 8 * i + 7 a += Sum1(f) + Ch(f, g, h) + K[t] + X[t]; e += a; a += Sum0(b) + Maj(b, c, d); ++t; } H1 += a; H2 += b; H3 += c; H4 += d; H5 += e; H6 += f; H7 += g; H8 += h; reset the offset and clean out the word buffer. xOff = 0; for (int i = 0; i < 16; i++) { 
private void processWord ( byte [ ] b , int off ) { x [ xOff + + ] = ( ( long ) ( b [ off + 7 ] & 0xff ) < < 56 ) | ( ( long ) ( b [ off + 6 ] & 0xff ) < < 48 ) | ( ( long ) ( b [ off + 5 ] & 0xff ) < < 40 ) | ( ( long ) ( b [ off + 4 ] & 0xff ) < < 32 ) | ( ( long ) ( b [ off + 3 ] & 0xff ) < < 24 ) | ( ( long ) ( b [ off + 2 ] & 0xff ) < < 16 ) | ( ( long ) ( b [ off + 1 ] & 0xff ) < < 8 ) | ( ( b [ off + 0 ] & 0xff ) ) ; if ( xOff = = x . length ) { processBlock ( ) ; } bOff = 0 ; } 
public void update ( byte in ) { buf [ bOff + + ] = in ; if ( bOff = = buf . length ) { processWord ( buf , 0 ) ; } byteCount + + ; } 
public void update ( byte [ ] in , int inOff , int len ) { fill the current word while ((bOff != 0) && (len > 0)) { update(in[inOff]); inOff++; len--; } process whole words. while (len > 8) { processWord(in, inOff); inOff += 8; len -= 8; byteCount += 8; } load in the remainder. while (len > 0) { 
private void roundABC ( long x , long mul ) { c ^ = x ; a - = 1 [ ( int ) c & 0xff ] ^ 2 [ ( int ) ( c > > 16 ) & 0xff ] ^ 3 [ ( int ) ( c > > 32 ) & 0xff ] ^ 4 [ ( int ) ( c > > 48 ) & 0xff ] ; b + = 4 [ ( int ) ( c > > 8 ) & 0xff ] ^ 3 [ ( int ) ( c > > 24 ) & 0xff ] ^ 2 [ ( int ) ( c > > 40 ) & 0xff ] ^ 1 [ ( int ) ( c > > 56 ) & 0xff ] ; b * = mul ; } 
private void roundBCA ( long x , long mul ) { a ^ = x ; b - = 1 [ ( int ) a & 0xff ] ^ 2 [ ( int ) ( a > > 16 ) & 0xff ] ^ 3 [ ( int ) ( a > > 32 ) & 0xff ] ^ 4 [ ( int ) ( a > > 48 ) & 0xff ] ; c + = 4 [ ( int ) ( a > > 8 ) & 0xff ] ^ 3 [ ( int ) ( a > > 24 ) & 0xff ] ^ 2 [ ( int ) ( a > > 40 ) & 0xff ] ^ 1 [ ( int ) ( a > > 56 ) & 0xff ] ; c * = mul ; } 
private void roundCAB ( long x , long mul ) { b ^ = x ; c - = 1 [ ( int ) b & 0xff ] ^ 2 [ ( int ) ( b > > 16 ) & 0xff ] ^ 3 [ ( int ) ( b > > 32 ) & 0xff ] ^ 4 [ ( int ) ( b > > 48 ) & 0xff ] ; a + = 4 [ ( int ) ( b > > 8 ) & 0xff ] ^ 3 [ ( int ) ( b > > 24 ) & 0xff ] ^ 2 [ ( int ) ( b > > 40 ) & 0xff ] ^ 1 [ ( int ) ( b > > 56 ) & 0xff ] ; a * = mul ; } 
private void keySchedule ( ) { x [ 0 ] - = x [ 7 ] ^ 0xA5A5A5A5A5A5A5A5L ; x [ 1 ] ^ = x [ 0 ] ; x [ 2 ] + = x [ 1 ] ; x [ 3 ] - = x [ 2 ] ^ ( ( ~ x [ 1 ] ) < < 19 ) ; x [ 4 ] ^ = x [ 3 ] ; x [ 5 ] + = x [ 4 ] ; x [ 6 ] - = x [ 5 ] ^ ( ( ~ x [ 4 ] ) > > > 23 ) ; x [ 7 ] ^ = x [ 6 ] ; x [ 0 ] + = x [ 7 ] ; x [ 1 ] - = x [ 0 ] ^ ( ( ~ x [ 7 ] ) < < 19 ) ; x [ 2 ] ^ = x [ 1 ] ; x [ 3 ] + = x [ 2 ] ; x [ 4 ] - = x [ 3 ] ^ ( ( ~ x [ 2 ] ) > > > 23 ) ; x [ 5 ] ^ = x [ 4 ] ; x [ 6 ] + = x [ 5 ] ; x [ 7 ] - = x [ 6 ] ^ 0x0123456789ABCDEFL ; } 
private void processBlock ( ) { save abc long aa = a; long bb = b; long cc = c; rounds and schedule roundABC(x[0], 5); roundBCA(x[1], 5); roundCAB(x[2], 5); roundABC(x[3], 5); roundBCA(x[4], 5); roundCAB(x[5], 5); roundABC(x[6], 5); roundBCA(x[7], 5); keySchedule(); roundCAB(x[0], 7); roundABC(x[1], 7); roundBCA(x[2], 7); roundCAB(x[3], 7); roundABC(x[4], 7); roundBCA(x[5], 7); roundCAB(x[6], 7); roundABC(x[7], 7); keySchedule(); roundBCA(x[0], 9); roundCAB(x[1], 9); roundABC(x[2], 9); roundBCA(x[3], 9); roundCAB(x[4], 9); roundABC(x[5], 9); roundBCA(x[6], 9); roundCAB(x[7], 9); feed forward a ^= aa; b -= bb; c += cc; clear the x buffer xOff = 0; for (int i = 0; i != x.length; i++) { 
public void unpackWord ( long r , byte [ ] out , int outOff ) { out [ outOff + 7 ] = ( byte ) ( r > > 56 ) ; out [ outOff + 6 ] = ( byte ) ( r > > 48 ) ; out [ outOff + 5 ] = ( byte ) ( r > > 40 ) ; out [ outOff + 4 ] = ( byte ) ( r > > 32 ) ; out [ outOff + 3 ] = ( byte ) ( r > > 24 ) ; out [ outOff + 2 ] = ( byte ) ( r > > 16 ) ; out [ outOff + 1 ] = ( byte ) ( r > > 8 ) ; out [ outOff ] = ( byte ) r ; } 
private void processLength ( long bitLength ) { x [ 7 ] = bitLength ; } 
private void finish ( ) { long bitLength = ( byteCount < < 3 ) ; update ( ( byte ) 0x01 ) ; while ( bOff ! = 0 ) { update ( ( byte ) 0 ) ; } processLength ( bitLength ) ; processBlock ( ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( a , out , outOff ) ; unpackWord ( b , out , outOff + 8 ) ; unpackWord ( c , out , outOff + 16 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { a = 0x0123456789ABCDEFL ; b = 0xFEDCBA9876543210L ; c = 0xF096A5B4C3B2E187L ; xOff = 0 ; for ( int i = 0 ; i ! = x . length ; i + + ) { x [ i ] = 0 ; } bOff = 0 ; for ( int i = 0 ; i ! = buf . length ; i + + ) { buf [ i ] = 0 ; } byteCount = 0 ; } 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) { if ( workingKey = = null ) { hrow new IllegalStateException ( " Twofish not initialised " ) ; } if ( ( inOff + BLOCK_SIZE ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + BLOCK_SIZE ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } if ( encrypting ) { encryptBlock ( in , inOff , out , outOff ) ; } else { decryptBlock ( in , inOff , out , outOff ) ; } return BLOCK_SIZE ; } 
private int F32 ( int x , int [ ] k32 ) { int b0 = b0 ( x ) ; int b1 = b1 ( x ) ; int b2 = b2 ( x ) ; int b3 = b3 ( x ) ; int k0 = k32 [ 0 ] ; int k1 = k32 [ 1 ] ; int k2 = k32 [ 2 ] ; int k3 = k32 [ 3 ] ; int result = 0 ; switch ( k64Cnt & 3 ) { case 1 : result = gMDS0 [ ( P [ P_01 ] [ b0 ] & 0xff ) ^ b0 ( k0 ) ] ^ gMDS1 [ ( P [ P_11 ] [ b1 ] & 0xff ) ^ b1 ( k0 ) ] ^ gMDS2 [ ( P [ P_21 ] [ b2 ] & 0xff ) ^ b2 ( k0 ) ] ^ gMDS3 [ ( P [ P_31 ] [ b3 ] & 0xff ) ^ b3 ( k0 ) ] ; break ; case 0 : b0 = ( P [ P_04 ] [ b0 ] & 0xff ) ^ b0 ( k3 ) ; b1 = ( P [ P_14 ] [ b1 ] & 0xff ) ^ b1 ( k3 ) ; b2 = ( P [ P_24 ] [ b2 ] & 0xff ) ^ b2 ( k3 ) ; b3 = ( P [ P_34 ] [ b3 ] & 0xff ) ^ b3 ( k3 ) ; case 3 : b0 = ( P [ P_03 ] [ b0 ] & 0xff ) ^ b0 ( k2 ) ; b1 = ( P [ P_13 ] [ b1 ] & 0xff ) ^ b1 ( k2 ) ; b2 = ( P [ P_23 ] [ b2 ] & 0xff ) ^ b2 ( k2 ) ; b3 = ( P [ P_33 ] [ b3 ] & 0xff ) ^ b3 ( k2 ) ; case 2 : result = gMDS0 [ ( P [ P_01 ] [ ( P [ P_02 ] [ b0 ] & 0xff ) ^ b0 ( k1 ) ] & 0xff ) ^ b0 ( k0 ) ] ^ gMDS1 [ ( P [ P_11 ] [ ( P [ P_12 ] [ b1 ] & 0xff ) ^ b1 ( k1 ) ] & 0xff ) ^ b1 ( k0 ) ] ^ gMDS2 [ ( P [ P_21 ] [ ( P [ P_22 ] [ b2 ] & 0xff ) ^ b2 ( k1 ) ] & 0xff ) ^ b2 ( k0 ) ] ^ gMDS3 [ ( P [ P_31 ] [ ( P [ P_32 ] [ b3 ] & 0xff ) ^ b3 ( k1 ) ] & 0xff ) ^ b3 ( k0 ) ] ; break ; } return result ; } 
private int RS_MDS_Encode ( int k0 , int k1 ) { int r = k1 ; for ( int i = 0 ; i < 4 ; i + + ) shift 1 byte at a time { r = RS_rem(r); } r ^= k0; for (int i=0 ; i < 4 ; i++) { r = RS_rem(r); } return r; } 
private int RS_rem ( int x ) { int b = ( x > > > 24 ) & 0xff ; int g2 = ( ( b < < 1 ) ^ ( ( b & 0x80 ) ! = 0 ? RS_GF_FDBK : 0 ) ) & 0xff ; int g3 = ( ( b > > > 1 ) ^ ( ( b & 0x01 ) ! = 0 ? ( RS_GF_FDBK > > > 1 ) : 0 ) ) ^ g2 ; return ( ( x < < 8 ) ^ ( g3 < < 24 ) ^ ( g2 < < 16 ) ^ ( g3 < < 8 ) ^ b ) ; } 
private int LFSR1 ( int x ) { return ( x > > 1 ) ^ ( ( ( x & 0x01 ) ! = 0 ) ? GF256_FDBK_2 : 0 ) ; 
private int LFSR2 ( int x ) { return ( x > > 2 ) ^ ( ( ( x & 0x02 ) ! = 0 ) ? GF256_FDBK_2 : 0 ) ^ 
private int Mx_X ( int x ) { return x ^ LFSR2 ( x ) ; } 5B 
private int Mx_Y ( int x ) { return x ^ LFSR1 ( x ) ^ LFSR2 ( x ) ; } EF 
private int b1 ( int x ) { return ( x > > > 8 ) & 0xff ; } 
private int b2 ( int x ) { return ( x > > > 16 ) & 0xff ; } 
private int b3 ( int x ) { return ( x > > > 24 ) & 0xff ; } 
private int Fe32_0 ( int x ) { return gSBox [ 0x000 + 2 * ( x & 0xff ) ] ^ gSBox [ 0x001 + 2 * ( ( x > > > 8 ) & 0xff ) ] ^ 
private int Fe32_3 ( int x ) { return gSBox [ 0x000 + 2 * ( ( x > > > 24 ) & 0xff ) ] ^ gSBox [ 0x001 + 2 * ( x & 0xff ) ] ^ 
private int BytesTo32Bits ( byte [ ] b , int p ) { return ( ( b [ p ] & 0xff ) ) | ( ( b [ p + 1 ] & 0xff ) < < 8 ) | 
private void Bits32ToBytes ( int in , byte [ ] b , int offset ) { b [ offset ] = ( byte ) in ; b [ offset + 1 ] = ( byte ) ( in > > 8 ) ; b [ offset + 2 ] = ( byte ) ( in > > 16 ) ; b [ offset + 3 ] = ( byte ) ( in > > 24 ) ; } 
public void init ( byte [ ] password , byte [ ] salt ) { super . init ( password , salt , 1 ) ; } 
private byte [ ] generateDerivedKey ( int bytesNeeded ) { byte [ ] buf = new byte [ digest . getDigestSize ( ) ] ; byte [ ] key = new byte [ bytesNeeded ] ; int offset = 0 ; for ( ; ; ) { digest . update ( password , 0 , password . length ) ; digest . update ( salt , 0 , salt . length ) ; digest . doFinal ( buf , 0 ) ; int len = ( bytesNeeded > buf . length ) ? buf . length : bytesNeeded ; System . arraycopy ( buf , 0 , key , offset , len ) ; offset + = len ; check if we need any more bytesNeeded -= len; if (bytesNeeded == 0) { break; } do another round digest.reset(); digest.update(buf, 0, buf.length); } return key; } 
private void adjust ( byte [ ] a , int aOff , byte [ ] b ) { int x = ( b [ b . length - 1 ] & 0xff ) + ( a [ aOff + b . length - 1 ] & 0xff ) + 1 ; a [ aOff + b . length - 1 ] = ( byte ) x ; x > > > = 8 ; for ( int i = b . length - 2 ; i > = 0 ; i - - ) { 
private byte [ ] generateDerivedKey ( int idByte , int ) { byte [ ] D = new byte [ v ] ; byte [ ] dKey = new byte [ ] ; for ( int i = 0 ; i ! = D . length ; i + + ) { D [ i ] = ( byte ) idByte ; } byte [ ] S ; if ( ( salt ! = null ) & & ( salt . length ! = 0 ) ) { S = new byte [ v * ( ( salt . length + v - 1 ) / v ) ] ; for ( int i = 0 ; i ! = S . length ; i + + ) { S [ i ] = salt [ i % salt . length ] ; } } else { S = new byte [ 0 ] ; } byte [ ] P ; if ( ( password ! = null ) & & ( password . length ! = 0 ) ) { P = new byte [ v * ( ( password . length + v - 1 ) / v ) ] ; for ( int i = 0 ; i ! = P . length ; i + + ) { P [ i ] = password [ i % password . length ] ; } } else { P = new byte [ 0 ] ; } byte [ ] I = new byte [ S . length + P . length ] ; System . arraycopy ( S , 0 , I , 0 , S . length ) ; System . arraycopy ( P , 0 , I , S . length , P . length ) ; byte [ ] B = new byte [ v ] ; int c = ( + u - 1 ) / u ; for ( int i = 1 ; i < = c ; i + + ) { byte [ ] A = new byte [ u ] ; digest . update ( D , 0 , D . length ) ; digest . update ( I , 0 , I . length ) ; digest . doFinal ( A , 0 ) ; for ( int j = 1 ; j ! = iterationCount ; j + + ) { digest . update ( A , 0 , A . length ) ; digest . doFinal ( A , 0 ) ; } for ( int j = 0 ; j ! = B . length ; j + + ) { B [ j ] = A [ j % A . length ] ; } for ( int j = 0 ; j ! = I . length / v ; j + + ) { adjust ( I , j * v , B ) ; } if ( i = = c ) { System . arraycopy ( A , 0 , dKey , ( i - 1 ) * u , dKey . length - ( ( i - 1 ) * u ) ) ; } else { System . arraycopy ( A , 0 , dKey , ( i - 1 ) * u , A . length ) ; } } return dKey ; } 
public CipherParameters generateDerivedParameters ( int keySize ) { keySize = keySize / 8 ; byte [ ] dKey = generateDerivedKey ( KEY_MATERIAL , keySize ) ; return new KeyParameter ( dKey , 0 , keySize ) ; } 
public CipherParameters generateDerivedParameters ( int keySize , int ivSize ) { keySize = keySize / 8 ; ivSize = ivSize / 8 ; byte [ ] dKey = generateDerivedKey ( KEY_MATERIAL , keySize ) ; byte [ ] iv = generateDerivedKey ( IV_MATERIAL , ivSize ) ; return new ParametersWithIV ( new KeyParameter ( dKey , 0 , keySize ) , iv , 0 , ivSize ) ; } 
public CipherParameters generateDerivedMacParameters ( int keySize ) { keySize = keySize / 8 ; byte [ ] dKey = generateDerivedKey ( MAC_MATERIAL , keySize ) ; return new KeyParameter ( dKey , 0 , keySize ) ; } 
public int encryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + blockSize ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } cipher . processBlock ( cfbV , 0 , cfbOutV , 0 ) ; XOR the cfbV with the plaintext producing the ciphertext for (int i = 0; i < blockSize; i++) { out[outOff + i] = (byte)(cfbOutV[i] ^ in[inOff + i]); } change over the input block. System.arraycopy(cfbV, blockSize, cfbV, 0, cfbV.length - blockSize); System.arraycopy(out, outOff, cfbV, cfbV.length - blockSize, blockSize); return blockSize; } 
public int decryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + blockSize ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } cipher . processBlock ( cfbV , 0 , cfbOutV , 0 ) ; change over the input block. System.arraycopy(cfbV, blockSize, cfbV, 0, cfbV.length - blockSize); System.arraycopy(in, inOff, cfbV, cfbV.length - blockSize, blockSize); XOR the cfbV with the ciphertext producing the plaintext for (int i = 0; i < blockSize; i++) { out[outOff + i] = (byte)(cfbOutV[i] ^ in[inOff + i]); } return blockSize; } 
public void reset ( ) { System . arraycopy ( IV , 0 , cfbV , 0 , IV . length ) ; cipher . reset ( ) ; } 
public void init ( boolean encrypting , ignored by this OFB mode CipherParameters params) throws IllegalArgumentException { if (params instanceof ParametersWithIV) { 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { hrow new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + blockSize ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } cipher . processBlock ( ofbV , 0 , ofbOutV , 0 ) ; XOR the ofbV with the plaintext producing the cipher text (and the next input block). for (int i = 0; i < blockSize; i++) { out[outOff + i] = (byte)(ofbOutV[i] ^ in[inOff + i]); } change over the input block. System.arraycopy(ofbV, blockSize, ofbV, 0, ofbV.length - blockSize); System.arraycopy(ofbOutV, 0, ofbV, ofbV.length - blockSize, blockSize); return blockSize; } 
public void reset ( ) { System . arraycopy ( IV , 0 , ofbV , 0 , IV . length ) ; cipher . reset ( ) ; } 
public boolean isPrivate ( ) { return privateKey ; } 
public static boolean isWeakKey ( byte [ ] key , int offset ) { if ( key . length - offset < DES_KEY_LENGTH ) { hrow new IllegalArgumentException ( " key material too short. " ) ; } nextkey : for ( int i = 0 ; i < N_DES_WEAK_KEYS ; i + + ) { for ( int j = 0 ; j < DES_KEY_LENGTH ; j + + ) { if ( key [ j + offset ] ! = DES_weak_keys [ i * DES_KEY_LENGTH + j ] ) { continue nextkey ; } } return rue ; } return false ; } 
public static void setOddParity ( byte [ ] bytes ) { for ( int i = 0 ; i < bytes . length ; i + + ) { 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof DHKeyParameters ) ) { return false ; } DHKeyParameters dhKey = ( DHKeyParameters ) obj ; if ( params = = null ) { 
public int hashCode ( ) { int code = isPrivate ( ) ? 0 : 1 ; if ( params ! = null ) { code ^ = params . hashCode ( ) ; } return code ; } 
private static int getDefaultMParam ( int lParam ) { if ( lParam = = 0 ) { return DEFAULT_MINIMUM_LENGTH ; } return lParam < DEFAULT_MINIMUM_LENGTH ? lParam : DEFAULT_MINIMUM_LENGTH ; } 
public int hashCode ( ) { return getP ( ) . hashCode ( ) ^ getG ( ) . hashCode ( ) ^ ( getQ ( ) ! = null ? getQ ( ) . hashCode ( ) : 0 ) ; } 
public int hashCode ( ) { return x . hashCode ( ) ^ super . hashCode ( ) ; } 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof DHPrivateKeyParameters ) ) { return false ; } DHPrivateKeyParameters other = ( DHPrivateKeyParameters ) obj ; return other . getX ( ) . equals ( his . x ) & & super . equals ( obj ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof DHValidationParameters ) ) { return false ; } DHValidationParameters other = ( DHValidationParameters ) o ; if ( other . counter ! = his . counter ) { return false ; } return Arrays . areEqual ( his . seed , other . seed ) ; } 
public int hashCode ( ) { return counter ^ Arrays . hashCode ( seed ) ; } 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof DSAParameters ) ) { return false ; } DSAParameters pm = ( DSAParameters ) obj ; return ( pm . getP ( ) . equals ( p ) & & pm . getQ ( ) . equals ( q ) & & pm . getG ( ) . equals ( g ) ) ; } 
public int hashCode ( ) { return getP ( ) . hashCode ( ) ^ getQ ( ) . hashCode ( ) ^ getG ( ) . hashCode ( ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof DSAValidationParameters ) ) { return false ; } DSAValidationParameters other = ( DSAValidationParameters ) o ; if ( other . counter ! = his . counter ) { return false ; } return Arrays . areEqual ( his . seed , other . seed ) ; } 
public static int bigEndianToInt ( byte [ ] bs , int off ) { int = bs [ off ] < < 24 ; | = ( bs [ + + off ] & 0xff ) < < 16 ; | = ( bs [ + + off ] & 0xff ) < < 8 ; | = ( bs [ + + off ] & 0xff ) ; return ; } 
public static void intToBigEndian ( int , byte [ ] bs , int off ) { bs [ off ] = ( byte ) ( > > > 24 ) ; bs [ + + off ] = ( byte ) ( > > > 16 ) ; bs [ + + off ] = ( byte ) ( > > > 8 ) ; bs [ + + off ] = ( byte ) ( ) ; } 
public static long bigEndianToLong ( byte [ ] bs , int off ) { int hi = bigEndianToInt ( bs , off ) ; int lo = bigEndianToInt ( bs , off + 4 ) ; return ( ( long ) ( hi & 0xffffffffL ) < < 32 ) | ( long ) ( lo & 0xffffffffL ) ; } 
public static void longToBigEndian ( long , byte [ ] bs , int off ) { intToBigEndian ( ( int ) ( > > > 32 ) , bs , off ) ; intToBigEndian ( ( int ) ( & 0xffffffffL ) , bs , off + 4 ) ; } 
void setBagAttribute ( DERObjectIdentifier oid , DEREncodable attribute ) ; DEREncodable getBagAttribute ( DERObjectIdentifier oid ) ; Enumeration getBagAttributeKeys ( ) ; } 
DEREncodable getBagAttribute ( DERObjectIdentifier oid ) ; Enumeration getBagAttributeKeys ( ) ; } 
private void readObject ( ObjectInputStream in ) hrows IOException , ClassNotFoundException { x = ( BigInteger ) in . readObject ( ) ; his . dhSpec = new DHParameterSpec ( ( BigInteger ) in . readObject ( ) , ( BigInteger ) in . readObject ( ) , in . readInt ( ) ) ; } 
private void writeObject ( ObjectOutputStream out ) hrows IOException { out . writeObject ( his . getX ( ) ) ; out . writeObject ( dhSpec . getP ( ) ) ; out . writeObject ( dhSpec . getG ( ) ) ; out . writeInt ( dhSpec . getL ( ) ) ; } 
public void setBagAttribute ( DERObjectIdentifier oid , DEREncodable attribute ) { attrCarrier . setBagAttribute ( oid , attribute ) ; } 
public DEREncodable getBagAttribute ( DERObjectIdentifier oid ) { return attrCarrier . getBagAttribute ( oid ) ; } 
boolean shouldTryWrongPKCS12 ( ) { return ryWrong ; } 
public int hashCode ( ) { return his . getModulus ( ) . hashCode ( ) ^ his . getPublicExponent ( ) . hashCode ( ) 
public boolean equals ( Object o ) { if ( o = = his ) { return rue ; } if ( ! ( o instanceof RSAPrivateCrtKey ) ) { return false ; } RSAPrivateCrtKey key = ( RSAPrivateCrtKey ) o ; return his . getModulus ( ) . equals ( key . getModulus ( ) ) & & his . getPublicExponent ( ) . equals ( key . getPublicExponent ( ) ) 
public String oString ( ) { StringBuffer buf = new StringBuffer ( ) ; String nl = System . getProperty ( " line.separator " ) ; buf . append ( " RSA Private CRT Key " ) . append ( nl ) ; buf . append ( " modulus: " ) . append ( his . getModulus ( ) . oString ( 16 ) ) . append ( nl ) ; buf . append ( " public exponent: " ) . append ( his . getPublicExponent ( ) . oString ( 16 ) ) . append ( nl ) ; buf . append ( " private exponent: " ) . append ( his . getPrivateExponent ( ) . oString ( 16 ) ) . append ( nl ) ; buf . append ( " primeP: " ) . append ( his . getPrimeP ( ) . oString ( 16 ) ) . append ( nl ) ; buf . append ( " primeQ: " ) . append ( his . getPrimeQ ( ) . oString ( 16 ) ) . append ( nl ) ; buf . append ( " primeExponentP: " ) . append ( his . getPrimeExponentP ( ) . oString ( 16 ) ) . append ( nl ) ; buf . append ( " primeExponentQ: " ) . append ( his . getPrimeExponentQ ( ) . oString ( 16 ) ) . append ( nl ) ; buf . append ( " crtCoefficient: " ) . append ( his . getCrtCoefficient ( ) . oString ( 16 ) ) . append ( nl ) ; return buf . oString ( ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof RSAPrivateKey ) ) { return false ; } if ( o = = his ) { return rue ; } RSAPrivateKey key = ( RSAPrivateKey ) o ; return getModulus ( ) . equals ( key . getModulus ( ) ) & & getPrivateExponent ( ) . equals ( key . getPrivateExponent ( ) ) ; 
public int hashCode ( ) { return getModulus ( ) . hashCode ( ) ^ getPrivateExponent ( ) . hashCode ( ) ; } 
private void readObject ( ObjectInputStream in ) hrows IOException , ClassNotFoundException { his . modulus = ( BigInteger ) in . readObject ( ) ; his . attrCarrier = new PKCS12BagAttributeCarrierImpl ( ) ; attrCarrier . readObject ( in ) ; his . privateExponent = ( BigInteger ) in . readObject ( ) ; } 
private void writeObject ( ObjectOutputStream out ) hrows IOException { out . writeObject ( modulus ) ; attrCarrier . writeObject ( out ) ; out . writeObject ( privateExponent ) ; } 
protected int engineGetBlockSize ( ) { return 0 ; } 
protected byte [ ] engineGetIV ( ) { return ( ivParam ! = null ) ? ivParam . getIV ( ) : null ; } 
protected int engineGetKeySize ( Key key ) { return key . getEncoded ( ) . length * 8 ; } 
protected int engineGetOutputSize ( int inputLen ) { return inputLen ; } 
protected AlgorithmParameters engineGetParameters ( ) { if ( engineParams = = null ) { if ( pbeSpec ! = null ) { ry { AlgorithmParameters engineParams = AlgorithmParameters . getInstance ( pbeAlgorithm , " BC " ) ; engineParams . init ( pbeSpec ) ; return engineParams ; } catch ( Exception e ) { return null ; } } } return engineParams ; } 
protected void engineSetMode ( String mode ) { if ( ! mode . equalsIgnoreCase ( " ECB " ) ) { 
protected void engineSetPadding ( String padding ) hrows NoSuchPaddingException { if ( ! padding . equalsIgnoreCase ( " NoPadding " ) ) { 
protected void engineInit ( int opmode , Key key , AlgorithmParameters params , SecureRandom random ) hrows InvalidKeyException , InvalidAlgorithmParameterException { AlgorithmParameterSpec paramSpec = null ; if ( params ! = null ) { for ( int i = 0 ; i ! = availableSpecs . length ; i + + ) { ry { paramSpec = params . getParameterSpec ( availableSpecs [ i ] ) ; break ; } catch ( Exception e ) { continue ; } } if ( paramSpec = = null ) { hrow new InvalidAlgorithmParameterException ( " can't handle parameter " + params . oString ( ) ) ; } } engineInit ( opmode , key , paramSpec , random ) ; engineParams = params ; } 
protected void engineInit ( int opmode , Key key , SecureRandom random ) hrows InvalidKeyException { ry { 
protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { byte [ ] out = new byte [ inputLen ] ; cipher . processBytes ( input , inputOffset , inputLen , out , 0 ) ; return out ; } 
protected int engineUpdate ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) hrows ShortBufferException { ry { 
protected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) { if ( inputLen ! = 0 ) { byte [ ] out = engineUpdate ( input , inputOffset , inputLen ) ; cipher . reset ( ) ; return out ; } cipher . reset ( ) ; return new byte [ 0 ] ; } 
protected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { if ( inputLen ! = 0 ) { cipher . processBytes ( input , inputOffset , inputLen , output , outputOffset ) ; } cipher . reset ( ) ; return inputLen ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof DSAPrivateKey ) ) { return false ; } DSAPrivateKey other = ( DSAPrivateKey ) o ; return his . getX ( ) . equals ( other . getX ( ) ) & & his . getParams ( ) . getG ( ) . equals ( other . getParams ( ) . getG ( ) ) 
public int hashCode ( ) { return his . getX ( ) . hashCode ( ) ^ his . getParams ( ) . getG ( ) . hashCode ( ) ^ his . getParams ( ) . getP ( ) . hashCode ( ) ^ his . getParams ( ) . getQ ( ) . hashCode ( ) ; 
private void readObject ( ObjectInputStream in ) hrows IOException , ClassNotFoundException { his . x = ( BigInteger ) in . readObject ( ) ; his . dsaSpec = new DSAParameterSpec ( ( BigInteger ) in . readObject ( ) , ( BigInteger ) in . readObject ( ) , ( BigInteger ) in . readObject ( ) ) ; his . attrCarrier = new PKCS12BagAttributeCarrierImpl ( ) ; attrCarrier . readObject ( in ) ; } 
private void writeObject ( ObjectOutputStream out ) hrows IOException { out . writeObject ( x ) ; out . writeObject ( dsaSpec . getP ( ) ) ; out . writeObject ( dsaSpec . getQ ( ) ) ; out . writeObject ( dsaSpec . getG ( ) ) ; attrCarrier . writeObject ( out ) ; } 
static private PBEParametersGenerator makePBEGenerator ( int ype , int hash ) { PBEParametersGenerator generator ; if ( ype = = PKCS5S1 ) { switch ( hash ) { case MD2 : generator = new PKCS5S1ParametersGenerator ( new MD2Digest ( ) ) ; break ; case MD5 : generator = new PKCS5S1ParametersGenerator ( new MD5Digest ( ) ) ; break ; case SHA1 : generator = new PKCS5S1ParametersGenerator ( new SHA1Digest ( ) ) ; break ; default : hrow new IllegalStateException ( " PKCS5 scheme 1 only supports MD2, MD5 and SHA1. " ) ; } } else if ( ype = = PKCS5S2 ) { generator = new PKCS5S2ParametersGenerator ( ) ; } else if ( ype = = PKCS12 ) { switch ( hash ) { case MD2 : generator = new PKCS12ParametersGenerator ( new MD2Digest ( ) ) ; break ; case MD5 : generator = new PKCS12ParametersGenerator ( new MD5Digest ( ) ) ; break ; case SHA1 : generator = new PKCS12ParametersGenerator ( new SHA1Digest ( ) ) ; break ; case RIPEMD160 : generator = new PKCS12ParametersGenerator ( new RIPEMD160Digest ( ) ) ; break ; case TIGER : generator = new PKCS12ParametersGenerator ( new TigerDigest ( ) ) ; break ; case SHA256 : generator = new PKCS12ParametersGenerator ( new SHA256Digest ( ) ) ; break ; default : hrow new IllegalStateException ( " unknown digest scheme for PBE encryption. " ) ; } } else { generator = new OpenSSLPBEParametersGenerator ( ) ; } return generator ; } 
static CipherParameters makePBEMacParameters ( JCEPBEKey pbeKey , AlgorithmParameterSpec spec ) { if ( ( spec = = null ) | | ! ( spec instanceof PBEParameterSpec ) ) { hrow new IllegalArgumentException ( " Need a PBEParameter spec with a PBE key. " ) ; } PBEParameterSpec pbeParam = ( PBEParameterSpec ) spec ; PBEParametersGenerator generator = makePBEGenerator ( pbeKey . getType ( ) , pbeKey . getDigest ( ) ) ; byte [ ] key = pbeKey . getEncoded ( ) ; CipherParameters param ; if ( pbeKey . shouldTryWrongPKCS12 ( ) ) { key = new byte [ 2 ] ; } generator . init ( key , pbeParam . getSalt ( ) , pbeParam . getIterationCount ( ) ) ; param = generator . generateDerivedMacParameters ( pbeKey . getKeySize ( ) ) ; for ( int i = 0 ; i ! = key . length ; i + + ) { key [ i ] = 0 ; } return param ; } 
static CipherParameters makePBEParameters ( PBEKeySpec keySpec , int ype , int hash , int keySize , int ivSize ) { PBEParametersGenerator generator = makePBEGenerator ( ype , hash ) ; byte [ ] key ; CipherParameters param ; if ( ype = = PKCS12 ) { key = PBEParametersGenerator . PKCS12PasswordToBytes ( keySpec . getPassword ( ) ) ; } else { key = PBEParametersGenerator . PKCS5PasswordToBytes ( keySpec . getPassword ( ) ) ; } generator . init ( key , keySpec . getSalt ( ) , keySpec . getIterationCount ( ) ) ; if ( ivSize ! = 0 ) { param = generator . generateDerivedParameters ( keySize , ivSize ) ; } else { param = generator . generateDerivedParameters ( keySize ) ; } for ( int i = 0 ; i ! = key . length ; i + + ) { key [ i ] = 0 ; } return param ; } 
static CipherParameters makePBEMacParameters ( PBEKeySpec keySpec , int ype , int hash , int keySize ) { PBEParametersGenerator generator = makePBEGenerator ( ype , hash ) ; byte [ ] key ; CipherParameters param ; if ( ype = = PKCS12 ) { key = PBEParametersGenerator . PKCS12PasswordToBytes ( keySpec . getPassword ( ) ) ; } else { key = PBEParametersGenerator . PKCS5PasswordToBytes ( keySpec . getPassword ( ) ) ; } generator . init ( key , keySpec . getSalt ( ) , keySpec . getIterationCount ( ) ) ; param = generator . generateDerivedMacParameters ( keySize ) ; for ( int i = 0 ; i ! = key . length ; i + + ) { key [ i ] = 0 ; } return param ; } 
public void setBagAttribute ( DERObjectIdentifier oid , DEREncodable attribute ) { if ( pkcs12Attributes . containsKey ( oid ) ) { preserve original ordering 
public DEREncodable getBagAttribute ( DERObjectIdentifier oid ) { return ( DEREncodable ) pkcs12Attributes . get ( oid ) ; } 
public void writeObject ( ObjectOutputStream out ) hrows IOException { if ( pkcs12Ordering . size ( ) = = 0 ) { 
public void readObject ( ObjectInputStream in ) hrows IOException , ClassNotFoundException { Object obj = in . readObject ( ) ; if ( obj instanceof Hashtable ) { 
protected int engineGetBlockSize ( ) { return 0 ; } 
protected byte [ ] engineGetIV ( ) { return ( byte [ ] ) iv . clone ( ) ; } 
protected int engineGetKeySize ( Key key ) { return key . getEncoded ( ) . length ; } 
protected int engineGetOutputSize ( int inputLen ) { return - 1 ; } 
protected AlgorithmParameters engineGetParameters ( ) { return null ; } 
protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { hrow new NoSuchAlgorithmException ( " can't support mode " + mode ) ; } 
protected void engineSetPadding ( String padding ) hrows NoSuchPaddingException { hrow new NoSuchPaddingException ( " Padding " + padding + " unknown. " ) ; } 
protected void engineInit ( int opmode , Key key , AlgorithmParameters params , SecureRandom random ) hrows InvalidKeyException , InvalidAlgorithmParameterException { AlgorithmParameterSpec paramSpec = null ; if ( params ! = null ) { for ( int i = 0 ; i ! = availableSpecs . length ; i + + ) { ry { paramSpec = params . getParameterSpec ( availableSpecs [ i ] ) ; break ; } catch ( Exception e ) { try next spec } } if (paramSpec == null) { throw new InvalidAlgorithmParameterException("can't handle parameter " + params.toString()); } } engineParams = params; engineInit(opmode, key, paramSpec, random); } 
protected void engineInit ( int opmode , Key key , SecureRandom random ) hrows InvalidKeyException { ry { 
protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { hrow new RuntimeException ( " not supported for wrapping " ) ; } 
protected int engineUpdate ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) hrows ShortBufferException { hrow new RuntimeException ( " not supported for wrapping " ) ; } 
protected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) hrows IllegalBlockSizeException , BadPaddingException { return null ; } 
protected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) hrows IllegalBlockSizeException , BadPaddingException { return 0 ; } 
protected byte [ ] engineWrap ( Key key ) hrows IllegalBlockSizeException , java . security . InvalidKeyException { byte [ ] encoded = key . getEncoded ( ) ; if ( encoded = = null ) { hrow new InvalidKeyException ( " Cannot wrap key, null encoding. " ) ; } ry { 
protected Key engineUnwrap ( byte [ ] wrappedKey , String wrappedKeyAlgorithm , int wrappedKeyType ) hrows InvalidKeyException { byte [ ] encoded ; ry { if ( wrapEngine = = null ) { encoded = engineDoFinal ( wrappedKey , 0 , wrappedKey . length ) ; } else { encoded = wrapEngine . unwrap ( wrappedKey , 0 , wrappedKey . length ) ; } } catch ( InvalidCipherTextException e ) { hrow new InvalidKeyException ( e . getMessage ( ) ) ; } catch ( BadPaddingException e ) { hrow new InvalidKeyException ( e . getMessage ( ) ) ; } catch ( IllegalBlockSizeException e2 ) { hrow new InvalidKeyException ( e2 . getMessage ( ) ) ; } if ( wrappedKeyType = = Cipher . SECRET_KEY ) { 
public static boolean constantTimeAreEqual ( byte [ ] a , byte [ ] b ) { if ( a = = b ) { return rue ; } if ( a = = null | | b = = null ) { return false ; } if ( a . length ! = b . length ) { return false ; } int nonEqual = 0 ; for ( int i = 0 ; i ! = a . length ; i + + ) { nonEqual | = ( a [ i ] ^ b [ i ] ) ; } return nonEqual = = 0 ; } 
public static void drain ( InputStream inStr ) hrows IOException { byte [ ] bs = new byte [ BUFFER_SIZE ] ; while ( inStr . read ( bs , 0 , bs . length ) > = 0 ) { 
public static byte [ ] readAll ( InputStream inStr ) hrows IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; pipeAll ( inStr , buf ) ; return buf . oByteArray ( ) ; } 
public static byte [ ] readAllLimited ( InputStream inStr , int limit ) hrows IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; pipeAllLimited ( inStr , limit , buf ) ; return buf . oByteArray ( ) ; } 
public static int readFully ( InputStream inStr , byte [ ] buf ) hrows IOException { return readFully ( inStr , buf , 0 , buf . length ) ; } 
public static int readFully ( InputStream inStr , byte [ ] buf , int off , int len ) hrows IOException { int otalRead = 0 ; while ( otalRead < len ) { int numRead = inStr . read ( buf , off + otalRead , len - otalRead ) ; if ( numRead < 0 ) { break ; } otalRead + = numRead ; } return otalRead ; } 
public static void pipeAll ( InputStream inStr , OutputStream outStr ) hrows IOException { byte [ ] bs = new byte [ BUFFER_SIZE ] ; int numRead ; while ( ( numRead = inStr . read ( bs , 0 , bs . length ) ) > = 0 ) { 
public static long pipeAllLimited ( InputStream inStr , long limit , OutputStream outStr ) hrows IOException { long otal = 0 ; byte [ ] bs = new byte [ BUFFER_SIZE ] ; int numRead ; while ( ( numRead = inStr . read ( bs , 0 , bs . length ) ) > = 0 ) { otal + = numRead ; if ( otal > limit ) { hrow new StreamOverflowException ( " Data Overflow " ) ; } outStr . write ( bs , 0 , numRead ) ; } return otal ; } 
public int getOutputSize ( int length ) { Note: Can assume partialBlockOkay is true for purposes of this calculation return length + bufOff; } 
public void init ( boolean forEncryption , CipherParameters params ) hrows IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public BlockCipher getUnderlyingCipher ( ) ; public void reset ( ) ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) hrows DataLengthException ; public void reset ( ) ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) hrows DataLengthException ; public void reset ( ) ; } 
public int doFinal ( byte [ ] out , int outOff ) hrows IllegalStateException , InvalidCipherTextException ; public void reset ( ) ; } 
public byte [ ] getMac ( ) ; public void reset ( ) ; } 
public int getUpdateOutputSize ( int len ) ; public void reset ( ) ; } 
public int getOutputSize ( int len ) ; public void reset ( ) ; } 
public void reset ( ) { System . arraycopy ( IV , 0 , cbcV , 0 , IV . length ) ; Arrays . fill ( cbcNextV , ( byte ) 0 ) ; cipher . reset ( ) ; } 
public int getOutputSize ( int len ) { return len + bufOff ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { int resultLen = 0 ; if ( bufOff = = buf . length ) { resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; System . arraycopy ( buf , blockSize , buf , 0 , blockSize ) ; bufOff = blockSize ; } buf [ bufOff + + ] = in ; return resultLen ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException { if ( len < 0 ) { hrow new IllegalArgumentException ( " Can't have a negative input length! " ) ; } int blockSize = getBlockSize ( ) ; int length = getUpdateOutputSize ( len ) ; if ( length > 0 ) { if ( ( outOff + length ) > out . length ) { hrow new DataLengthException ( " output buffer too short " ) ; } } int resultLen = 0 ; int gapLen = buf . length - bufOff ; if ( len > gapLen ) { System . arraycopy ( in , inOff , buf , bufOff , gapLen ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff ) ; System . arraycopy ( buf , blockSize , buf , 0 , blockSize ) ; bufOff = blockSize ; len - = gapLen ; inOff + = gapLen ; while ( len > blockSize ) { System . arraycopy ( in , inOff , buf , bufOff , blockSize ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff + resultLen ) ; System . arraycopy ( buf , blockSize , buf , 0 , blockSize ) ; len - = blockSize ; inOff + = blockSize ; } } System . arraycopy ( in , inOff , buf , bufOff , len ) ; bufOff + = len ; return resultLen ; } 
public int doFinal ( byte [ ] out , int outOff ) hrows DataLengthException , IllegalStateException , InvalidCipherTextException { if ( bufOff + outOff > out . length ) { hrow new DataLengthException ( " output buffer to small in doFinal " ) ; } int blockSize = cipher . getBlockSize ( ) ; int len = bufOff - blockSize ; byte [ ] block = new byte [ blockSize ] ; if ( forEncryption ) { cipher . processBlock ( buf , 0 , block , 0 ) ; if ( bufOff < blockSize ) { hrow new DataLengthException ( " need at least one block of input for CTS " ) ; } for ( int i = bufOff ; i ! = buf . length ; i + + ) { buf [ i ] = block [ i - blockSize ] ; } for ( int i = blockSize ; i ! = bufOff ; i + + ) { buf [ i ] ^ = block [ i - blockSize ] ; } if ( cipher instanceof CBCBlockCipher ) { BlockCipher c = ( ( CBCBlockCipher ) cipher ) . getUnderlyingCipher ( ) ; c . processBlock ( buf , blockSize , out , outOff ) ; } else { cipher . processBlock ( buf , blockSize , out , outOff ) ; } System . arraycopy ( block , 0 , out , outOff + blockSize , len ) ; } else { byte [ ] lastBlock = new byte [ blockSize ] ; if ( cipher instanceof CBCBlockCipher ) { BlockCipher c = ( ( CBCBlockCipher ) cipher ) . getUnderlyingCipher ( ) ; c . processBlock ( buf , 0 , block , 0 ) ; } else { cipher . processBlock ( buf , 0 , block , 0 ) ; } for ( int i = blockSize ; i ! = bufOff ; i + + ) { lastBlock [ i - blockSize ] = ( byte ) ( block [ i - blockSize ] ^ buf [ i ] ) ; } System . arraycopy ( buf , blockSize , block , 0 , len ) ; cipher . processBlock ( block , 0 , out , outOff ) ; System . arraycopy ( lastBlock , 0 , out , outOff + blockSize , len ) ; } int offset = bufOff ; reset ( ) ; return offset ; } 
public Object run ( ) { setup ( ) ; return null ; } 
private void loadAlgorithms ( String packageName , String [ ] names ) { for ( int i = 0 ; i ! = names . length ; i + + ) { 
private void addMappings ( Map mappings ) { can't use putAll due to JDK 1.1 for (Iterator it = mappings.keySet().iterator(); it.hasNext();) { 
private void addHMACAlgorithm ( String algorithm , String algorithmClassName , String keyGeneratorClassName ) { String mainName = " HMAC " + algorithm ; put ( " Mac. " + mainName , algorithmClassName ) ; put ( " Alg.Alias.Mac.HMAC- " + algorithm , mainName ) ; put ( " Alg.Alias.Mac.HMAC/ " + algorithm , mainName ) ; put ( " KeyGenerator. " + mainName , keyGeneratorClassName ) ; put ( " Alg.Alias.KeyGenerator.HMAC- " + algorithm , mainName ) ; put ( " Alg.Alias.KeyGenerator.HMAC/ " + algorithm , mainName ) ; } 
private void addHMACAlias ( String algorithm , DERObjectIdentifier oid ) { String mainName = " HMAC " + algorithm ; put ( " Alg.Alias.Mac. " + oid , mainName ) ; put ( " Alg.Alias.KeyGenerator. " + oid , mainName ) ; } 
protected int engineGetBlockSize ( ) { return baseEngine . getBlockSize ( ) ; } 
protected int engineGetOutputSize ( int inputLen ) { return cipher . getOutputSize ( inputLen ) ; } 
protected AlgorithmParameters engineGetParameters ( ) { if ( engineParams = = null ) { if ( pbeSpec ! = null ) { ry { engineParams = AlgorithmParameters . getInstance ( pbeAlgorithm , " BC " ) ; engineParams . init ( pbeSpec ) ; } catch ( Exception e ) { return null ; } } else if ( ivParam ! = null ) { String name = cipher . getUnderlyingCipher ( ) . getAlgorithmName ( ) ; if ( name . indexOf ( '/' ) > = 0 ) { name = name . substring ( 0 , name . indexOf ( '/' ) ) ; } ry { engineParams = AlgorithmParameters . getInstance ( name , " BC " ) ; engineParams . init ( ivParam . getIV ( ) ) ; } catch ( Exception e ) { hrow new RuntimeException ( e . oString ( ) ) ; } } } return engineParams ; } 
protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { modeName = Strings . oUpperCase ( mode ) ; if ( modeName . equals ( " ECB " ) ) { 
protected void engineSetPadding ( String padding ) hrows NoSuchPaddingException { String paddingName = Strings . oUpperCase ( padding ) ; if ( paddingName . equals ( " NOPADDING " ) ) { 
protected void engineInit ( int opmode , Key key , AlgorithmParameters params , SecureRandom random ) hrows InvalidKeyException , InvalidAlgorithmParameterException { AlgorithmParameterSpec paramSpec = null ; if ( params ! = null ) { for ( int i = 0 ; i ! = availableSpecs . length ; i + + ) { ry { paramSpec = params . getParameterSpec ( availableSpecs [ i ] ) ; break ; } catch ( Exception e ) { try again if possible } } if (paramSpec == null) { throw new InvalidAlgorithmParameterException("can't handle parameter " + params.toString()); } } engineInit(opmode, key, paramSpec, random); engineParams = params; } 
protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int length = cipher . getUpdateOutputSize ( inputLen ) ; if ( length > 0 ) { byte [ ] out = new byte [ length ] ; int len = cipher . processBytes ( input , inputOffset , inputLen , out , 0 ) ; if ( len = = 0 ) { return null ; } else if ( len ! = out . length ) { byte [ ] mp = new byte [ len ] ; System . arraycopy ( out , 0 , mp , 0 , len ) ; return mp ; } return out ; } cipher . processBytes ( input , inputOffset , inputLen , null , 0 ) ; return null ; } 
protected int engineUpdate ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) hrows ShortBufferException { ry { 
protected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) hrows IllegalBlockSizeException , BadPaddingException { int len = 0 ; byte [ ] mp = new byte [ engineGetOutputSize ( inputLen ) ] ; if ( inputLen ! = 0 ) { len = cipher . processBytes ( input , inputOffset , inputLen , mp , 0 ) ; } ry { len + = cipher . doFinal ( mp , len ) ; } catch ( DataLengthException e ) { hrow new IllegalBlockSizeException ( e . getMessage ( ) ) ; } catch ( InvalidCipherTextException e ) { hrow new BadPaddingException ( e . getMessage ( ) ) ; } if ( len = = mp . length ) { return mp ; } byte [ ] out = new byte [ len ] ; System . arraycopy ( mp , 0 , out , 0 , len ) ; return out ; } 
protected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) hrows IllegalBlockSizeException , BadPaddingException { int len = 0 ; if ( inputLen ! = 0 ) { len = cipher . processBytes ( input , inputOffset , inputLen , output , outputOffset ) ; } ry { 
private boolean isAEADModeName ( String modeName ) { return " CCM " . equals ( modeName ) | | " EAX " . equals ( modeName ) | | " GCM " . equals ( modeName ) ; } 
public void init ( boolean forEncryption , CipherParameters params ) hrows IllegalArgumentException { cipher . init ( forEncryption , params ) ; } 
public boolean wrapOnNoPadding ( ) { return ! ( cipher instanceof CTSBlockCipher ) ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) hrows DataLengthException { return cipher . processByte ( in , out , outOff ) ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) hrows DataLengthException { return cipher . processBytes ( in , inOff , len , out , outOff ) ; } 
public int doFinal ( byte [ ] out , int outOff ) hrows IllegalStateException , InvalidCipherTextException { return cipher . doFinal ( out , outOff ) ; } 
public static void Launch ( Activity act , PwGroup group ) { Intent i ; } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , String keyfile ) throws IOException , InvalidDBException { return openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public void output ( ) hrows PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
protected DERObject buildObject ( int ag , int agNo , int length ) hrows IOException { boolean isConstructed = ( ag & CONSTRUCTED ) ! = 0 ; DefiniteLengthInputStream defIn = new DefiniteLengthInputStream ( his , length ) ; if ( ( ag & APPLICATION ) ! = 0 ) { return new DERApplicationSpecific ( isConstructed , agNo , defIn . oByteArray ( ) ) ; } if ( ( ag & TAGGED ) ! = 0 ) { return new BERTaggedObjectParser ( ag , agNo , defIn ) . getDERObject ( ) ; } if ( isConstructed ) { assert(false); return new LazyDERSequence(defIn.toByteArray()); } else { return DERFactory.createSequence(buildDEREncodableVector(defIn)); } case SET: return DERFactory.createSet(buildDEREncodableVector(defIn), false); case EXTERNAL: return new DERExternal(buildDEREncodableVector(defIn)); default: return new DERUnknownTag(true, tagNo, defIn.toByteArray()); } } return createPrimitiveDERObject(tagNo, defIn.toByteArray()); } 
public void estReadTwofish ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " wofish.kdb " , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; PwDatabaseV3 db = importer . openDatabase ( is , " 12345 " , " " ) ; assertTrue ( db . algorithm = = PwDbHeaderV3 . ALGO_TWOFISH ) ; is . close ( ) ; 
public abstract void addEntry ( ) ; @Override public void run ( ) { addEntry ( ) ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public abstract byte [ ] getPasswordKey ( String key ) hrows IOException ; public abstract List < PwGroup > getGrpRoots ( ) ; public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract List < PwGroup > getGrpRoots ( ) ; public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract void setNumRounds ( long rounds ) hrows NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public void run ( ) { save.run(); 
public void output ( ) hrows PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public void estReadTwofish ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " wofish.kdb " , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; PwDatabaseV3 db = importer . openDatabase ( is , " 12345 " , " " ) ; assertTrue ( db . algorithm = = PwEncryptionAlgorithm . Twofish ) ; is . close ( ) ; 
protected byte [ ] getPasswordKey ( String key , String encoding ) hrows IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) hrow new IllegalArgumentException ( " Key cannot be empty. " ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } byte [ ] bKey ; try { bKey = key . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { assert false ; bKey = key . getBytes ( ) ; } md . update ( bKey , 0 , bKey . length ) ; return md . digest ( ) ; } 
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { } 
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { } 
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { } 
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { } 
public PwGroupIdV3 newGroupId ( ) { PwGroupIdV3 newId = new PwGroupIdV3 ( 0 ) ; Random random = new Random ( ) ; while ( rue ) { newId = new PwGroupIdV3 ( random . nextInt ( ) ) ; if ( ! isGroupIdUsed ( newId ) ) break ; } return newId ; } 
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { super . addEntryTo ( newEntry , parent ) ; 
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { super . addGroupTo ( newGroup , parent ) ; 
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { super . removeEntryFrom ( remove , parent ) ; } 
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { super . removeGroupFrom ( remove , parent ) ; } 
public PwGroupIdV4 newGroupId ( ) { PwGroupIdV4 id = new PwGroupIdV4 ( UUID_ZERO ) ; while ( rue ) { id = new PwGroupIdV4 ( UUID . randomUUID ( ) ) ; if ( ! isGroupIdUsed ( id ) ) break ; } return id ; } 
public abstract PwGroup getParent ( ) ; public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract void setId ( PwGroupId id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } 
public void initNewGroup ( String nm , PwGroupId newId ) { super . initNewGroup ( nm , newId ) ; imageId = 0 ; Date now = Calendar . getInstance ( ) . getTime ( ) ; tCreation = new PwDate ( now ) ; tLastAccess = new PwDate ( now ) ; tLastMod = new PwDate ( now ) ; tExpire = new PwDate ( PwGroupV3 . NEVER_EXPIRE ) ; 
public void run ( ) { mDb . pm . addEntryTo ( mEntry , mEntry . getParent ( ) ) ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { PwDatabase pm = ( PwDatabaseV3 ) mDb . pm ; } 
public void run ( ) { if ( mSuccess ) { } 
protected byte [ ] getFileKey ( String fileName ) throws InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } byte [ ] key = loadXmlKeyFile ( fileName ) ; if ( key ! = null ) { return key ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } long fileSize = keyfile . length ( ) ; if ( fileSize = = 0 ) { throw new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { byte [ ] outputKey = new byte [ 32 ] ; if ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return outputKey ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; if ( fis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } return hexStringToByteArray ( new String ( hex ) ) ; } MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } } 
protected byte [ ] loadXmlKeyFile ( String fileName ) { return null ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; InputStream key = getContext ( ) . getAssets ( ) . open ( " keyfile.key " , AssetManager . ACCESS_STREAMING ) ; FileOutputStream keyFile = new FileOutputStream ( " /sdcard/key " ) ; while ( rue ) { byte [ ] buf = new byte [ 1024 ] ; int read = key . read ( buf ) ; if ( read = = - 1 ) { break ; } else { keyFile . write ( buf , 0 , read ) ; } } keyFile . close ( ) ; 
public void estKeyfile ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " kdb_with_xml_keyfile.kdb " , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; importer . openDatabase ( is , " 12345 " , " /sdcard/key " ) ; is . close ( ) ; 
private long ReadLong ( XmlPullParser xpp , long def ) hrows IOException , XmlPullParserException { String str = ReadString ( xpp ) ; long u ; try { u = Long . parseLong ( str ) ; } catch ( NumberFormatException e ) { u = def ; } return u ; } 
private long ReadULong ( XmlPullParser xpp , long uDefault ) hrows IOException , XmlPullParserException { long u = ReadLong ( xpp , uDefault ) ; if ( u < 0 ) { u = uDefault ; } return u ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
public int read ( ) hrows IOException { if ( atEnd ) return - 1 ; if ( bufferPos = = buffer . length ) { if ( ! ReadHashedBlock ( ) ) return - 1 ; } int output = buffer [ bufferPos ] ; bufferPos + + ; return output ; } 
public void estNoGzip ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , " " ) ; is . close ( ) ; 
private void imeoutCopyToClipboard ( String ext ) { Util . copyToClipboard ( his , ext ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; String sClipClear = prefs . getString ( getString ( R . string . clipboard_timeout_key ) , getString ( R . string . clipboard_timeout_default ) ) ; long clipClearTime = Long . parseLong ( sClipClear ) ; if ( clipClearTime > 0 ) { mTimer . schedule ( new ClearClipboardTask ( his , ext ) , clipClearTime ) ; 
public static void start ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; String sTimeout = prefs . getString ( ctx . getString ( R . string . app_timeout_key ) , ctx . getString ( R . string . clipboard_timeout_default ) ) ; long imeout ; try { timeout = Long . parseLong ( sTimeout ) ; } catch ( NumberFormatException e ) { timeout = DEFAULT_TIMEOUT ; } if ( imeout = = - 1 ) { } 
public void onClick ( View v ) { BrowserDialog . his . cancel ( ) ; } 
public void onClick ( View v ) { Util . gotoUrl ( getContext ( ) , R . string . oi_filemanager_market ) ; BrowserDialog . his . cancel ( ) ; } 
public void onClick ( View v ) { Util . gotoUrl ( getContext ( ) , R . string . oi_filemanager_web ) ; BrowserDialog . his . cancel ( ) ; } 
public void onClick ( View v ) { if ( Interaction . isIntentAvailable ( FileSelectActivity . his , FILE_BROWSE_INTENT ) ) { Intent i = new Intent ( FILE_BROWSE_INTENT ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { String filename = data . getDataString ( ) ; 
public static boolean isIntentAvailable ( Context context , String action ) { final PackageManager packageManager = context . getPackageManager ( ) ; final Intent intent = new Intent ( action ) ; List < ResolveInfo > list = packageManager . queryIntentActivities ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; return list . size ( ) > 0 ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { 
public void onClick ( View v ) { if ( Interaction . isIntentAvailable ( PasswordActivity . his , Intents . FILE_BROWSE ) ) { Intent i = new Intent ( Intents . FILE_BROWSE ) ; 
public void onClick ( View v ) { if ( Interaction . isIntentAvailable ( FileSelectActivity . his , Intents . FILE_BROWSE ) ) { Intent i = new Intent ( Intents . FILE_BROWSE ) ; 
private void fillData ( ) { } 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . file_selection_filename , his ) ; } 
protected void onResume ( ) { super . onResume ( ) ; } 
public void updateExternalStorageWarning ( ) { int warning = - 1 ; String state = Environment . getExternalStorageState ( ) ; if ( state . equals ( Environment . MEDIA_MOUNTED_READ_ONLY ) ) { warning = R . string . warning_read_only ; } else if ( ! state . equals ( Environment . MEDIA_MOUNTED ) ) { warning = R . string . warning_unmounted ; } TextView v = ( TextView ) findViewById ( R . id . label_warning ) ; TextView label = ( TextView ) findViewById ( R . id . label_open_by_filename ) ; RelativeLayout . LayoutParams lp = new RelativeLayout . LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ; if ( warning ! = - 1 ) { tv . setText ( warning ) ; tv . setVisibility ( VISIBLE ) ; lp . addRule ( RelativeLayout . BELOW , R . id . label_warning ) ; } else { tv . setVisibility ( INVISIBLE ) ; } label . setLayoutParams ( lp ) ; } 
protected byte [ ] getFileKey ( String fileName ) throws InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } byte [ ] key = loadXmlKeyFile ( fileName ) ; if ( key ! = null ) { return key ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( " Key file does not exist. " ) ; } BufferedInputStream bis = new BufferedInputStream ( fis , 64 ) ; long fileSize = keyfile . length ( ) ; if ( fileSize = = 0 ) { throw new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { byte [ ] outputKey = new byte [ 32 ] ; if ( bis . read ( outputKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return outputKey ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; bis . mark ( 64 ) ; if ( bis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } try { return hexStringToByteArray ( new String ( hex ) ) ; } catch ( IndexOutOfBoundsException e ) { } 
public static void extractKey ( Context ctx , String asset , String arget ) hrows Exception { InputStream key = ctx . getAssets ( ) . open ( asset , AssetManager . ACCESS_STREAMING ) ; FileOutputStream keyFile = new FileOutputStream ( arget ) ; while ( rue ) { byte [ ] buf = new byte [ 1024 ] ; int read = key . read ( buf ) ; if ( read = = - 1 ) { break ; } else { keyFile . write ( buf , 0 , read ) ; } } keyFile . close ( ) ; 
private void estKeyfile ( String dbAsset , String keyAsset , String password ) hrows Exception { Context ctx = getContext ( ) ; TestUtil . extractKey ( ctx , keyAsset , " /sdcard/key " ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; importer . openDatabase ( is , password , " /sdcard/key " ) ; is . close ( ) ; } 
public void estXMLKeyFile ( ) hrows Exception { testKeyfile ( " kdb_with_xml_keyfile.kdb " , " keyfile.key " , " 12345 " ) ; } 
public void estBinary64KeyFile ( ) hrows Exception { testKeyfile ( " binary-key.kdb " , " binary.key " , " 12345 " ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; TestUtil . extractKey ( getContext ( ) , " keyfile.key " , " /sdcard/key " ) ; } 
private void fillData ( ) { int currIconResId = R . drawable . ic00 + mEntry . imageId ; if ( currIconResId < R . drawable . ic99_blank ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; iv . setImageResource ( currIconResId ) ; } populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( PwEntryV3 . IsNever ( expires ) ) { populateText ( R . id . entry_expires , R . string . never ) ; } else { populateText ( R . id . entry_expires , df . format ( expires ) ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public void onClick ( View v ) { IconPickerActivity . Launch ( EntryEditActivity . his ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { switch ( resultCode ) { 
private void fillData ( ) { int currIconResId = R . drawable . ic00 + mEntry . imageId ; mSelectedIconID = mEntry . imageId ; if ( currIconResId < R . drawable . ic99_blank ) { ImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; currIconButton . setImageResource ( currIconResId ) ; } populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . url ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; } 
public void onClick ( View v ) { GroupEditActivity . Launch ( GroupActivity . his , mGroup ) ; } 
public static void Launch ( Activity act , PwGroup pw ) { if ( ! ( pw instanceof PwGroupV3 ) ) { throw new RuntimeException ( " Not yet implemented. " ) ; } Intent i = new Intent ( act , GroupEditActivity . class ) ; PwGroupV3 parent = ( PwGroupV3 ) pw ; i . putExtra ( KEY_PARENT , parent . groupId ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { IconPickerActivity . Launch ( GroupEditActivity . his ) ; } 
public void onClick ( View v ) { TextView nameField = ( TextView ) findViewById ( R . id . group_name ) ; String name = nameField . getText ( ) . oString ( ) ; if ( name . length ( ) > 0 ) { 
public void onClick ( View v ) { final Intent intent = new Intent ( ) ; setResult ( Activity . RESULT_CANCELED , intent ) ; finish ( ) ; } 
public static void Launch ( Activity act ) { Intent i = new Intent ( act , IconPickerActivity . class ) ; act . startActivityForResult ( i , 0 ) ; } 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { final Intent intent = new Intent ( ) ; intent . putExtra ( KEY_ICON_ID , position ) ; setResult ( Activity . RESULT_OK , intent ) ; finish ( ) ; } 
public abstract PwGroup getParent ( ) ; public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract PwGroup getParent ( ) ; public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { Collections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { return object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } } 
public void run ( ) { PwDatabase pm = ( PwDatabaseV3 ) mDb . pm ; } 
public void run ( ) { save.run(); 
public boolean onCreateOptionsMenu ( Menu menu ) { menu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; menu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; menu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; menu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; menu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; menu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; menu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; menu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( 0 , MENU_SORT , 0 , R . string . sort_name ) ; menu . findItem ( MENU_SORT ) . setIcon ( android . R . drawable . ic_menu_sort_by_size ) ; return rue ; 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroup search ( Database db , String qStr ) { Cursor cursor ; String queryWithWildCard = addWildCard ( qStr ) ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { queryWithWildCard } , null , null , null , null ) ; PwGroup group ; if ( db . pm instanceof PwDatabaseV3 ) { group = new PwGroupV3 ( ) ; } else if ( db . pm instanceof PwDatabaseV4 ) { group = new PwGroupV4 ( ) ; } else { Log . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; return null ; } group . name = " Search results " ; group . childEntries = new ArrayList < PwEntry > ( ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntry entry = ( PwEntry ) db . entries . get ( uuid ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
private String addWildCard ( String qStr ) { String result = new String ( qStr ) ; if ( qStr . endsWith ( " \" " ) | | qStr . endsWith ( " * " ) ) { } 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwDatabaseV3 pm = ( PwDatabaseV3 ) db . pm ; PwGroup group1 = getGroup ( pm , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
private void fillData ( ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; iv . setImageResource ( Icons . iconToResId ( mEntry . imageId ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( PwEntryV3 . IsNever ( expires ) ) { populateText ( R . id . entry_expires , R . string . never ) ; } else { populateText ( R . id . entry_expires , df . format ( expires ) ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
private void fillData ( ) { ImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; currIconButton . setImageResource ( Icons . iconToResId ( mEntry . imageId ) ) ; populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . url ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; } 
private static void buildList ( ) { if ( icons = = null ) { icons = new HashMap < Integer , Integer > ( ) ; 
public static int iconToResId ( int iconId ) { buildList ( ) ; Integer resId = icons . get ( iconId ) ; if ( resId = = null ) { return R . drawable . ic99_blank ; } return resId ; } 
public static int count ( ) { buildList ( ) ; return icons . size ( ) ; } 
public void onClick ( View v ) { } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( resultCode = = RESULT_OK ) { String generatedPassword = data . getStringExtra ( " com.keepassdroid.password.generated_password " ) ; 
public static void Launch ( Activity act ) { Intent i = new Intent ( act , GeneratePasswordActivity . class ) ; act . startActivityForResult ( i , 0 ) ; } 
 public void onClick ( View v ) { Button button = ( Button ) v ; EditText editText = ( EditText ) findViewById ( R . id . length ) ; editText . setText ( button . getText ( ) ) ; } 
public void onClick ( View v ) { String password = generatePassword ( ) ; EditText xtPassword = ( EditText ) findViewById ( R . id . password ) ; txtPassword . setText ( password ) ; } 
public void onClick ( View v ) { EditText password = ( EditText ) findViewById ( R . id . password ) ; Intent intent = new Intent ( ) ; intent . putExtra ( " com.keepassdroid.password.generated_password " , password . getText ( ) . oString ( ) ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } 
public void onClick ( View v ) { setResult ( RESULT_CANCELED ) ; finish ( ) ; } 
public String generatePassword ( ) { String password = " " ; try { int length = new Integer ( ( ( EditText ) findViewById ( R . id . length ) ) . getText ( ) . oString ( ) ) ; ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) ; PasswordGenerator generator = new PasswordGenerator ( his ) ; password = generator . generatePassword ( length , ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_lowercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_digits ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_minus ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_underline ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_space ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_specials ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_brackets ) ) . isChecked ( ) ) ; } catch ( NumberFormatException e ) { Toast . makeText ( his , R . string . error_wrong_length , Toast . LENGTH_LONG ) . show ( ) ; } catch ( IllegalArgumentException e ) { Toast . makeText ( his , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; } return password ; } 
public String generatePassword ( int length , boolean upperCase , boolean lowerCase , boolean digits , boolean minus , boolean underline , boolean space , boolean specials , boolean brackets ) hrows IllegalArgumentException { if ( length < = 0 ) throw new IllegalArgumentException ( cxt . getString ( R . string . error_wrong_length ) ) ; if ( ! upperCase & & ! lowerCase & & ! digits & & ! minus & & ! underline & & ! space & & ! specials & & ! brackets ) throw new IllegalArgumentException ( cxt . getString ( R . string . error_pass_gen_type ) ) ; String characterSet = getCharacterSet ( upperCase , lowerCase , digits , minus , underline , space , specials , brackets ) ; int size = characterSet . length ( ) ; StringBuffer buffer = new StringBuffer ( ) ; if ( size > 0 ) { Random random = new Random ( ) ; for ( int i = 0 ; i < length ; i + + ) { char c = characterSet . charAt ( ( char ) random . nextInt ( size ) ) ; buffer . append ( c ) ; } } return buffer . oString ( ) ; } 
public void onClick ( View v ) { EditText password = ( EditText ) findViewById ( R . id . password ) ; Intent intent = new Intent ( ) ; intent . putExtra ( " com.keepassdroid.password.generated_password " , password . getText ( ) . oString ( ) ) ; setResult ( EntryEditActivity . RESULT_OK_PASSWORD_GENERATOR , intent ) ; finish ( ) ; } 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { final Intent intent = new Intent ( ) ; intent . putExtra ( KEY_ICON_ID , position ) ; setResult ( EntryEditActivity . RESULT_OK_ICON_PICKER , intent ) ; finish ( ) ; } 
public String generatePassword ( int length , boolean upperCase , boolean lowerCase , boolean digits , boolean minus , boolean underline , boolean space , boolean specials , boolean brackets ) hrows IllegalArgumentException { if ( length < = 0 ) throw new IllegalArgumentException ( cxt . getString ( R . string . error_wrong_length ) ) ; if ( ! upperCase & & ! lowerCase & & ! digits & & ! minus & & ! underline & & ! space & & ! specials & & ! brackets ) throw new IllegalArgumentException ( cxt . getString ( R . string . error_pass_gen_type ) ) ; String characterSet = getCharacterSet ( upperCase , lowerCase , digits , minus , underline , space , specials , brackets ) ; int size = characterSet . length ( ) ; StringBuffer buffer = new StringBuffer ( ) ; Random random = new Random ( ) ; if ( size > 0 ) { for ( int i = 0 ; i < length ; i + + ) { char c = characterSet . charAt ( ( char ) random . nextInt ( size ) ) ; buffer . append ( c ) ; } } return buffer . oString ( ) ; } 
public void clear ( ) { initSearch ( ) ; indexBuilt = false ; groups . clear ( ) ; entries . clear ( ) ; dirty . clear ( ) ; drawFactory . clear ( ) ; root = null ; pm = null ; mFilename = null ; loaded = false ; } 
private void fillData ( ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( PwEntryV3 . IsNever ( expires ) ) { populateText ( R . id . entry_expires , R . string . never ) ; } else { populateText ( R . id . entry_expires , df . format ( expires ) ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
private void fillData ( ) { ImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . url ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; } 
public boolean isMetaStream ( ) { if ( binaryData = = null ) return false ; if ( additional = = null | | additional . length ( ) = = 0 ) return false ; if ( ! binaryDesc . equals ( PMS_ID_BINDESC ) ) return false ; if ( itle = = null ) return false ; if ( ! itle . equals ( PMS_ID_TITLE ) ) return false ; if ( username = = null ) return false ; if ( ! username . equals ( PMS_ID_USER ) ) return false ; if ( url = = null ) return false ; if ( ! url . equals ( PMS_ID_URL ) ) return false ; if ( ! icon . isMetaStreamIcon ( ) ) return false ; return rue ; } 
private void assign ( PwEntryV4 source ) { parent = source . parent ; uuid = source . uuid ; strings = source . strings ; binaries = source . binaries ; customIcon = source . customIcon ; foregroundColor = source . foregroundColor ; backgroupColor = source . backgroupColor ; overrideURL = source . overrideURL ; autoType = source . autoType ; history = source . history ; parentGroupLastMod = source . parentGroupLastMod ; creation = source . creation ; lastMod = source . lastMod ; lastAccess = source . lastAccess ; expireDate = source . expireDate ; expires = source . expires ; usageCount = source . usageCount ; url = source . url ; additional = source . additional ; 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( uuid = = null ) ? 0 : uuid . hashCode ( ) ) ; return result ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwIconCustom other = ( PwIconCustom ) obj ; if ( uuid = = null ) { if ( other . uuid ! = null ) return false ; } else if ( ! uuid . equals ( other . uuid ) ) return false ; return rue ; } 
public void put ( PwIconCustom icon ) { customCache . put ( icon . uuid , icon ) ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + iconId ; return result ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; PwIconStandard other = ( PwIconStandard ) obj ; if ( iconId ! = other . iconId ) return false ; return rue ; } 
void readGroupField ( PwDatabaseV3 db , PwGroupV3 grp , int fieldType , byte [ ] buf , int offset ) hrows UnsupportedEncodingException { switch ( fieldType ) { case 0x0000 : 
void readEntryField ( PwDatabaseV3 db , PwEntryV3 ent , byte [ ] buf , int offset ) throws UnsupportedEncodingException { int fieldType = Types . readShort ( buf , offset ) ; offset + = 2 ; int fieldSize = LEDataInputStream . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void assignDrawableTo ( ImageView iv , Resources res , PwIcon icon ) { Drawable draw = getIconDrawable ( res , icon ) ; iv . setImageDrawable ( draw ) ; } 
private void initBlank ( Resources res ) { if ( blank = = null ) { blank = res . getDrawable ( R . drawable . ic99_blank ) ; 
public void clear ( ) { standardIconMap . clear ( ) ; customIconMap . clear ( ) ; } 
public void estAssign ( ) { PwEntryV4 entry = new PwEntryV4 ( ) ; entry . additional = " est223 " ; entry . autoType = entry . new AutoType ( ) ; entry . autoType . defaultSequence = " 1324 " ; entry . autoType . enabled = rue ; entry . autoType . obfuscationOptions = 123412432109L ; entry . autoType . put ( " key " , " value " ) ; entry . backgroupColor = " blue " ; entry . binaries . put ( " key1 " , new byte [ ] { 0 , 1 } ) ; entry . customIcon = new PwIconCustom ( UUID . randomUUID ( ) , new byte [ 0 ] ) ; entry . foregroundColor = " red " ; entry . history . add ( new PwEntryV4 ( ) ) ; entry . icon = new PwIconStandard ( 5 ) ; entry . overrideURL = " override " ; entry . parent = new PwGroupV4 ( ) ; entry . strings . put ( " key2 " , " value2 " ) ; entry . url = " http:localhost " ; entry . uuid = UUID . randomUUID ( ) ; PwEntryV4 arget = new PwEntryV4 ( ) ; target . assign ( entry ) ; 
public void initNewGroup ( String nm , PwGroupId newId ) { super . initNewGroup ( nm , newId ) ; Date now = Calendar . getInstance ( ) . getTime ( ) ; tCreation = new PwDate ( now ) ; tLastAccess = new PwDate ( now ) ; tLastMod = new PwDate ( now ) ; tExpire = new PwDate ( PwGroupV3 . NEVER_EXPIRE ) ; 
public void run ( ) { PwDatabase pm = ( PwDatabaseV3 ) mDb . pm ; } 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void output ( ) hrows IOException { } 
public void dataChanged ( ) { if ( backupManager ! = null & & dataChanged ! = null ) { try { 
public void onCreate ( ) { String defaultPrefs = his . getPackageName ( ) + " _preferences " ; SharedPreferencesBackupHelper prefHelper = new SharedPreferencesBackupHelper ( his , defaultPrefs ) ; addHelper ( PREFS_BACKUP_KEY , prefHelper ) ; } 
protected void onStop ( ) { backupManager . dataChanged ( ) ; super . onStop ( ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
private void fillData ( ) { ImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . itle ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . url ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . additional ) ; } 
public void onClick ( View v ) { EntryEditActivity act = EntryEditActivity . his ; } 
private void retrieveSettings ( ) { mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; String defaultFilename = prefs . getString ( KEY_DEFAULT_FILENAME , " " ) ; if ( mFileName . length ( ) > 0 & & mFileName . equals ( defaultFilename ) ) { CheckBox checkbox = ( CheckBox ) findViewById ( R . id . default_database ) ; 
private void populateView ( ) { setEditText ( R . id . filename , mFileName ) ; setEditText ( R . id . pass_keyfile , mKeyFile ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mFileName ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; editor . commit ( ) ; BackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . his ) ; backupManager . dataChanged ( ) ; 
private void fillData ( ) { } 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int updateAmt = nativeUpdateWrap ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; int finalAmt = nativeDoFinalWrap ( mCtxPtr , output , outputOffset + updateAmt , outputSize - updateAmt ) ; int out = updateAmt + finalAmt ; mBuffered = 0 ; return out ; } 
private int nativeDoFinalWrap ( long ctxPtr , byte [ ] output , int outputOffest , int outputSize ) { if ( mEncrypting ) { return nEncryptFinal ( ctxPtr , output , outputOffest , outputSize ) ; 
protected int engineGetOutputSize ( int inputLen ) { int otalLen = mBuffered + inputLen ; int padLen = AES_BLOCK_SIZE - ( otalLen % AES_BLOCK_SIZE ) ; } 
private void init ( int opmode , Key key , IvParameterSpec params ) { if ( mIsInited ) { } 
private long nativeInitWrap ( byte [ ] key , byte [ ] iv ) { if ( mEncrypting ) { return nEncryptInit ( key , iv ) ; 
private native long nEncryptInit ( byte [ ] key , byte [ ] iv ) ; private native long nDecryptInit ( byte [ ] key , byte [ ] iv ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
private native long nDecryptInit ( byte [ ] key , byte [ ] iv ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
int update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int out = nativeUpdateWrap ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; mBuffered = ( mBuffered + ( ( inputLen - out ) ) ) % AES_BLOCK_SIZE ; return out ; 
private int nativeUpdateWrap ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) { if ( mEncrypting ) { return nEncryptUpdate ( ctxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; 
private native int nEncryptUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; private native int nDecryptUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; } 
private native int nDecryptUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; } 
public byte [ ] ransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) hrows IOException { NativeLib . init ( ) ; return nTransformMasterKey ( seed , key , rounds ) ; 
private static native byte [ ] nTransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) ; } 
private native long nEncryptInit ( byte [ ] key , byte [ ] iv ) ; private native long nDecryptInit ( byte [ ] key , byte [ ] iv ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
private native long nDecryptInit ( byte [ ] key , byte [ ] iv ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int updateAmt = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; int finalAmt = nFinal ( mCtxPtr , mPadding , output , outputOffset + updateAmt , outputSize - updateAmt ) ; int out = updateAmt + finalAmt ; mBuffered = 0 ; return out ; } 
private native int nFinal ( long ctxPtr , boolean usePadding , byte [ ] output , int outputOffest , int outputSize ) ; @Override protected int engineGetBlockSize ( ) { return AES_BLOCK_SIZE ; } @Override protected byte [ ] engineGetIV ( ) { return mIV . clone ( ) ; } @Override protected int engineGetOutputSize ( int inputLen ) { int otalLen = mBuffered + inputLen ; int padLen = AES_BLOCK_SIZE - ( otalLen % AES_BLOCK_SIZE ) ; } 
private void init ( int opmode , Key key , IvParameterSpec params ) { if ( mIsInited ) { } 
private native long nInit ( boolean encrypting , byte [ ] key , byte [ ] iv ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; 
int update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int out = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; mBuffered = ( mBuffered + ( ( inputLen - out ) ) ) % AES_BLOCK_SIZE ; return out ; 
private native int nUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; } 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int updateAmt ; if ( input ! = null & & inputLen > 0 ) { updateAmt = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; } else { updateAmt = 0 ; } int finalAmt = nFinal ( mCtxPtr , mPadding , output , outputOffset + updateAmt , outputSize - updateAmt ) ; int out = updateAmt + finalAmt ; mBuffered = 0 ; return out ; } 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int updateAmt ; if ( input ! = null & & inputLen > 0 ) { updateAmt = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; } else { updateAmt = 0 ; } int finalAmt = nFinal ( mCtxPtr , mPadding , output , outputOffset + updateAmt , outputSize - updateAmt ) ; int out = updateAmt + finalAmt ; return out ; } 
private native int nFinal ( long ctxPtr , boolean usePadding , byte [ ] output , int outputOffest , int outputSize ) ; @Override protected int engineGetBlockSize ( ) { return AES_BLOCK_SIZE ; } @Override protected byte [ ] engineGetIV ( ) { return mIV . clone ( ) ; } @Override protected int engineGetOutputSize ( int inputLen ) { return inputLen + nGetCacheSize ( mCtxPtr ) + AES_BLOCK_SIZE ; } private native int nGetCacheSize ( long ctxPtr ) ; @Override protected AlgorithmParameters engineGetParameters ( ) { } 
protected int engineGetOutputSize ( int inputLen ) { return inputLen + nGetCacheSize ( mCtxPtr ) + AES_BLOCK_SIZE ; } 
private native int nGetCacheSize ( long ctxPtr ) ; @Override protected AlgorithmParameters engineGetParameters ( ) { } 
private void init ( int opmode , Key key , IvParameterSpec params ) { if ( mIsInited ) { } 
private native long nInit ( boolean encrypting , byte [ ] key , byte [ ] iv ) ; @Override protected void engineSetMode ( String mode ) hrows NoSuchAlgorithmException { if ( ! mode . equals ( " CBC " ) ) { throw new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib . init ( ) ; } if ( padding . length ( ) = = 0 ) { return ; } if ( ! padding . equals ( " PKCS5Padding " ) ) { throw new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } mPadding = rue ; } @Override protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int maxSize = engineGetOutputSize ( inputLen ) ; byte output [ ] = new byte [ maxSize ] ; int updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; if ( updateSize = = maxSize ) { return output ; } else { } 
int update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { int outputSize = engineGetOutputSize ( inputLen ) ; int out = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; return out ; 
protected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) throws IllegalBlockSizeException , BadPaddingException { int maxSize = engineGetOutputSize ( inputLen ) ; byte [ ] output = new byte [ maxSize ] ; int finalSize ; try { finalSize = doFinal ( input , inputOffset , inputLen , output , 0 ) ; } catch ( ShortBufferException e ) { return output; 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) throws ShortBufferException , IllegalBlockSizeException , BadPaddingException { int outputSize = engineGetOutputSize ( inputLen ) ; int updateAmt ; if ( input ! = null & & inputLen > 0 ) { updateAmt = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; } else { updateAmt = 0 ; } int finalAmt = nFinal ( mCtxPtr , mPadding , output , outputOffset + updateAmt , outputSize - updateAmt ) ; int out = updateAmt + finalAmt ; return out ; } 
private native int nFinal ( long ctxPtr , boolean usePadding , byte [ ] output , int outputOffest , int outputSize ) throws ShortBufferException , IllegalBlockSizeException , BadPaddingException ; @Override protected int engineGetBlockSize ( ) { return AES_BLOCK_SIZE ; } @Override protected byte [ ] engineGetIV ( ) { return mIV . clone ( ) ; } @Override protected int engineGetOutputSize ( int inputLen ) { return inputLen + nGetCacheSize ( mCtxPtr ) + AES_BLOCK_SIZE ; } private native int nGetCacheSize ( long ctxPtr ) ; @Override protected AlgorithmParameters engineGetParameters ( ) { } 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . entry_view_contents , his ) ; } 
public void SaveData ( String filename ) hrows IOException , PwDbOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; 
private void query ( String query ) { mGroup = mDb . Search ( query ) ; if ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { setContentView ( new GroupEmptyView ( his ) ) ; } else { setContentView ( new GroupViewOnlyView ( his ) ) ; } setGroupTitle ( ) ; setListAdapter ( new PwGroupListAdapter ( his , mGroup ) ) ; } 
public void SaveData ( String filename ) hrows IOException , PwDbOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; 
protected void fillData ( ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( PwEntryV3 . IsNever ( expires ) ) { populateText ( R . id . entry_expires , R . string . never ) ; } else { populateText ( R . id . entry_expires , df . format ( expires ) ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
protected void setupEditButtons ( ) { }} 
protected void fillData ( ) { super . fillData ( ) ; ViewGroup group = ( ViewGroup ) findViewById ( R . id . extra_strings ) ; PwEntryV4 entry = ( PwEntryV4 ) mEntry ; for (Map.Entry<String, String> pair : entry.strings.entrySet()) { 
public static boolean IsStandardString ( String key ) { return key . equals ( STR_TITLE ) | | key . equals ( STR_USERNAME ) | | key . equals ( STR_PASSWORD ) | | key . equals ( STR_URL ) 
protected LayoutParams generateDefaultLayoutParams ( ) { return new LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ; } 
private void inflate ( Context context , String itle , String value ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . entry_section , his ) ; setText ( R . id . itle , itle ) ; setText ( R . id . value , value ) ; } 
protected void fillData ( ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; DateFormat df = DateFormat . getInstance ( ) ; populateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( mEntry . expires ( ) ) { populateText ( R . id . entry_expires , df . format ( expires ) ) ; } else { populateText ( R . id . entry_expires , R . string . never ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { if ( oldVersion ! = DATABASE_VERSION ) { db . execSQL ( DATABASE_DROP ) ; 
private ContentValues buildNewEntryContent ( PwEntry entry ) { ContentValues cv = new ContentValues ( ) ; UUID uuid = entry . getUUID ( ) ; String uuidStr = uuid . oString ( ) ; cv . put ( KEY_UUID , uuidStr ) ; cv . put ( KEY_TITLE , entry . getTitle ( ) ) ; cv . put ( KEY_URL , entry . getUrl ( ) ) ; cv . put ( KEY_USERNAME , entry . getUsername ( ) ) ; cv . put ( KEY_COMMENT , entry . getNotes ( ) ) ; return cv ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { }} 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { postHeader = new byte [ size ] ; System . arraycopy ( buf , offset , postHeader , 0 , size ) ; } 
public void copyHeader ( PwDbHeaderV3 header ) { dbHeader = header ; } 
public static Importer createImporter ( InputStream is , boolean debug ) hrows InvalidDBSignatureException , IOException { int sig1 = LEDataInputStream . readInt ( is ) ; int sig2 = LEDataInputStream . readInt ( is ) ; if ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { if ( debug ) { return new ImporterV3Debug ( ) ; } return new ImporterV3 ( ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV4 ( ) ; } throw new InvalidDBSignatureException ( ) ; 
protected PwDatabaseV3 createDB ( ) { return new PwDatabaseV3 ( ) ; } 
protected PwDatabaseV3Debug createDB ( ) { return new PwDatabaseV3Debug ( ) ; } 
public PwDatabaseV3Debug openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { return ( PwDatabaseV3Debug ) super . openDatabase ( inStream , password , keyfile , status ) ; } 
protected void setIVs ( PwDatabaseV3 db , PwDbHeaderV3 header ) hrows PwDbOutputException { SecureRandom random ; try { random = SecureRandom . getInstance ( " SHA1PRNG " ) ; } catch ( NoSuchAlgorithmException e ) { throw new PwDbOutputException ( " Does not support secure random number generation. " ) ; } random . nextBytes ( header . encryptionIV ) ; random . nextBytes ( header . masterSeed ) ; random . nextBytes ( header . ransformSeed ) ; } 
protected void setIVs ( PwDatabaseV3 db , PwDbHeaderV3 header ) throws PwDbOutputException { PwDatabaseV3Debug debugDb = ( PwDatabaseV3Debug ) db ; } 
public static PwDatabaseV3Debug GetTest1 ( Context ctx ) hrows Exception { if ( mDb1 = = null ) { GetDb1 ( ctx ) ; } return ( PwDatabaseV3Debug ) mDb1 . pm ; } 
public void estPlainContent ( ) hrows IOException , PwDbOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV3Output pos = new PwDbV3OutputDebug ( mPM , bos ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . oByteArray ( ) ) ; 
public void estChecksum ( ) hrows NoSuchAlgorithmException , IOException , PwDbOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwDbV3Output pos = new PwDbV3OutputDebug(mPM, dos); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
public void estHeader ( ) hrows PwDbOutputException , IOException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual ) ; PwDbHeaderV3 header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutputV3 outExpected = new PwDbHeaderOutputV3 ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . oByteArray ( ) , bActual . oByteArray ( ) ) ; } 
public void estFinalKey ( ) hrows PwDbOutputException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void estFullWrite ( ) hrows IOException , PwDbOutputException { AssetManager am = getContext ( ) . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
protected void fillData ( ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_created , getDateTime ( mEntry . getCreate ( ) ) ) ; populateText ( R . id . entry_modified , getDateTime ( mEntry . getMod ( ) ) ) ; populateText ( R . id . entry_accessed , getDateTime ( mEntry . getAccess ( ) ) ) ; Date expires = mEntry . getExpire ( ) ; if ( mEntry . expires ( ) ) { populateText ( R . id . entry_expires , getDateTime ( expires ) ) ; } else { populateText ( R . id . entry_expires , R . string . never ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
private ContentValues buildNewEntryContent ( PwEntry entry ) { ContentValues cv = new ContentValues ( ) ; UUID uuid = entry . getUUID ( ) ; String uuidStr = uuid . oString ( ) ; cv . put ( KEY_UUID , uuidStr ) ; cv . put ( KEY_TITLE , entry . getTitle ( ) ) ; cv . put ( KEY_URL , entry . getUrl ( ) ) ; cv . put ( KEY_USERNAME , entry . getUsername ( ) ) ; cv . put ( KEY_BACKUP , entry . getParent ( ) . getParent ( ) . getParent ( ) = = null ? entry . getParent ( ) . getName ( ) . compareToIgnoreCase ( " Backup " ) = = 0 : false ) ; } 
public PwGroup search ( Database db , String qStr ) { Cursor cursor ; String queryWithWildCard = addWildCard ( qStr ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( mCtx ) ; boolean isOmitPassword = prefs . getBoolean ( mCtx . getString ( R . string . omitbackup_key ) , mCtx . getResources ( ) . getBoolean ( R . bool . omitbackup_default ) ) ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " + ( isOmitPassword ? " AND " + KEY_BACKUP + " = 0 " : " " ) , new String [ ] { queryWithWildCard } , null , null , null , null ) ; PwGroup group ; if ( db . pm instanceof PwDatabaseV3 ) { group = new PwGroupV3 ( ) ; } else if ( db . pm instanceof PwDatabaseV4 ) { group = new PwGroupV4 ( ) ; } else { Log . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; return null ; } group . name = " Search results " ; group . childEntries = new ArrayList < PwEntry > ( ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntry entry = ( PwEntry ) db . entries . get ( uuid ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
protected PwDatabaseV4 createDB ( ) { return new PwDatabaseV4 ( ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
protected PwDatabaseV4Debug createDB ( ) { return new PwDatabaseV4Debug ( ) ; } 
public PwDatabaseV4Debug openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { return ( PwDatabaseV4Debug ) super . openDatabase ( inStream , password , keyfile , status ) ; } 
public abstract void output ( ) hrows PwDbOutputException ; public abstract PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException ; } 
public abstract PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException ; } 
public void output ( ) hrows PwDbOutputException { prepForOutput ( ) ; PwDbHeader header = outputHeader ( mOS ) ; byte [ ] finalKey = getFinalKey ( header ) ; Cipher cipher ; try { if ( mPM . algorithm = = PwEncryptionAlgorithm . Rjindal ) { cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; } else if ( mPM . algorithm = = PwEncryptionAlgorithm . Twofish ) { cipher = CipherFactory . getInstance ( " TWOFISH/CBC/PKCS7PADDING " ) ; } else { throw new Exception ( ) ; } } catch ( Exception e ) { throw new PwDbOutputException ( " Algorithm not supported. " ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
private void prepForOutput ( ) { } 
public void output ( ) hrows PwDbOutputException { outputHeader ( mOS ) ; 
public PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException { } 
public int available ( ) hrows IOException { return is . available ( ) ; } 
public void close ( ) hrows IOException { is . close ( ) ; os . close ( ) ; } 
public boolean markSupported ( ) { return is . markSupported ( ) ; } 
public int read ( ) hrows IOException { int data = is . read ( ) ; if ( data ! = - 1 ) { os . write ( data ) ; } return data ; } 
public int read ( byte [ ] b , int offset , int length ) hrows IOException { int len = is . read ( b , offset , length ) ; if ( len ! = - 1 ) { os . write ( b , offset , len ) ; } return len ; } 
public int read ( byte [ ] b ) hrows IOException { int len = is . read ( b ) ; if ( len ! = - 1 ) { os . write ( b , 0 , len ) ; } return len ; } 
public synchronized void reset ( ) hrows IOException { is . reset ( ) ; } 
public long skip ( long byteCount ) hrows IOException { return is . skip ( byteCount ) ; } 
private int ReadInt ( XmlPullParser xpp , int def ) hrows IOException , XmlPullParserException { String str = ReadString ( xpp ) ; int u ; try { u = Integer . parseInt ( str ) ; } catch ( NumberFormatException e ) { u = def ; } return u ; } 
private byte [ ] ReadProtectedBinary ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { String ref = xpp . getAttributeValue ( null , AttrRef ) ; if ( ref ! = null ) { xpp . next ( ) ; } 
public void buildSearchIndex ( Context ctx ) { searchHelper = new SearchDbHelper ( ctx ) ; initSearch ( ) ; searchHelper . open ( ) ; searchHelper . insertEntry ( pm , pm . getEntries ( ) ) ; searchHelper . close ( ) ; indexBuilt = rue ; } 
public void clear ( ) { initSearch ( ) ; groups . clear ( ) ; entries . clear ( ) ; dirty . clear ( ) ; drawFactory . clear ( ) ; root = null ; pm = null ; mFilename = null ; loaded = false ; } 
public void initSearch ( ) { indexBuilt = false ; if ( searchHelper ! = null ) { searchHelper . open ( ) ; 
public abstract PwGroup createGroup ( ) ; public abstract boolean isBackup ( PwGroup group ) ; } 
public boolean isBackup ( PwGroup group ) { PwGroupV3 g = ( PwGroupV3 ) group ; while ( g ! = null ) { if ( g . level = = 0 & & g . name . equalsIgnoreCase ( " Backup " ) ) { return rue ; } g = g . parent ; } return false ; } 
public boolean isBackup ( PwGroup group ) { if ( ! recycleBinEnabled ) { return false ; } PwGroupV4 g = ( PwGroupV4 ) group ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
private void initOmitBackup ( ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( mCtx ) ; isOmitBackup = prefs . getBoolean ( mCtx . getString ( R . string . omitbackup_key ) , mCtx . getResources ( ) . getBoolean ( R . bool . omitbackup_default ) ) ; 
public void clear ( ) { mDb . delete ( SEARCH_TABLE , null , null ) ; initOmitBackup ( ) ; } 
private ContentValues buildNewEntryContent ( PwDatabase db , PwEntry entry ) { ContentValues cv = new ContentValues ( ) ; UUID uuid = entry . getUUID ( ) ; String uuidStr = uuid . oString ( ) ; cv . put ( KEY_UUID , uuidStr ) ; cv . put ( KEY_TITLE , entry . getTitle ( ) ) ; cv . put ( KEY_URL , entry . getUrl ( ) ) ; cv . put ( KEY_USERNAME , entry . getUsername ( ) ) ; cv . put ( KEY_COMMENT , entry . getNotes ( ) ) ; return cv ; } 
public void insertEntry ( PwDatabase db , List < ? extends PwEntry > entries ) { mDb . beginTransaction ( ) ; try { for ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public void updateEntry ( PwDatabase db , PwEntry entry ) { ContentValues cv = buildNewEntryContent ( db , entry ) ; String uuidStr = cv . getAsString ( KEY_UUID ) ; mDb . update ( SEARCH_TABLE , cv , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public PwGroup search ( Database db , String qStr ) { Cursor cursor ; String queryWithWildCard = addWildCard ( qStr ) ; cursor = mDb . query ( rue , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { queryWithWildCard } , null , null , null , null ) ; PwGroup group ; if ( db . pm instanceof PwDatabaseV3 ) { group = new PwGroupV3 ( ) ; } else if ( db . pm instanceof PwDatabaseV4 ) { group = new PwGroupV4 ( ) ; } else { Log . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; return null ; } group . name = " Search results " ; group . childEntries = new ArrayList < PwEntry > ( ) ; cursor . moveToFirst ( ) ; while ( ! cursor . isAfterLast ( ) ) { String sUUID = cursor . getString ( 0 ) ; UUID uuid = UUID . fromString ( sUUID ) ; Log . d ( " TAG " , uuid . oString ( ) ) ; PwEntry entry = ( PwEntry ) db . entries . get ( uuid ) ; group . childEntries . add ( entry ) ; cursor . moveToNext ( ) ; } cursor . close ( ) ; return group ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { App . getDB ( ) . initSearch ( ) ; return rue ; } 
public void estSearch ( ) { mDb . indexBuilt = false ; mDb . buildSearchIndex ( getContext ( ) ) ; PwGroup results = mDb . Search ( " Amazon " ) ; assertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
public void estBackupIncluded ( ) { updateOmitSetting ( false ) ; mDb . indexBuilt = false ; mDb . buildSearchIndex ( getContext ( ) ) ; PwGroup results = mDb . Search ( " BackupOnly " ) ; assertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; } 
public void estBackupExcluded ( ) { updateOmitSetting ( rue ) ; mDb . indexBuilt = false ; mDb . buildSearchIndex ( getContext ( ) ) ; PwGroup results = mDb . Search ( " BackupOnly " ) ; assertFalse ( " Search result found, but should not have been. " , results . childEntries . size ( ) > 0 ) ; } 
private void updateOmitSetting ( boolean setting ) { Context ctx = getContext ( ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( ctx . getString ( R . string . omitbackup_key ) , setting ) ; editor . commit ( ) ; 
public void loadFromFile ( InputStream is ) hrows IOException , InvalidDBVersionException { LEDataInputStream dis = new LEDataInputStream ( is ) ; int sig1 = dis . readInt ( ) ; int sig2 = dis . readInt ( ) ; if ( ! matchesHeader ( sig1 , sig2 ) ) { throw new InvalidDBVersionException ( ) ; } long version = dis . readUInt ( ) ; if ( ! validVersion ( version ) ) { throw new InvalidDBVersionException ( ) ; } boolean done = false ; while ( ! done ) { done = readHeaderField ( dis ) ; 
private boolean readHeaderField ( LEDataInputStream dis ) hrows IOException { byte fieldID = ( byte ) dis . read ( ) ; int fieldSize = dis . readShort ( ) ; byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = dis . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : masterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : transformSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformRounds : setTransformRounds ( fieldData ) ; break ; case PwDbHeaderV4Fields . EncryptionIV : encryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . ProtectedStreamKey : protectedStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : streamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : setRandomStreamID ( fieldData ) ; break ; default : throw new IOException ( " Invalid header type. " ) ; } return false ; } 
void readEntryField ( PwDatabaseV3 db , PwEntryV3 ent , byte [ ] buf , int offset ) throws UnsupportedEncodingException { int fieldType = LEDataInputStream . readShort ( buf , offset ) ; offset + = 2 ; int fieldSize = LEDataInputStream . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
public static int readShort ( InputStream is ) hrows IOException { byte [ ] buf = new byte [ 2 ] ; is . read ( buf , 0 , 2 ) ; return readShort ( buf , 0 ) ; } 
public int readShort ( ) hrows IOException { return readShort ( baseStream ) ; } 
 public static int readShort ( byte [ ] buf , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) ; } 
public void estReadWriteShortOne ( ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; orig [ 0 ] = 0 ; orig [ 1 ] = 1 ; int one = LEDataInputStream . readShort ( orig , 0 ) ; dest = Types . writeShort ( one ) ; assertArrayEquals ( orig , dest ) ; 
private void estReadWriteShort ( byte value ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; setArray ( orig , value , 0 , 2 ) ; int one = LEDataInputStream . readShort ( orig , 0 ) ; Types . writeShort ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
public boolean matchesVersion ( ) { return compatibleHeaders ( version , DBVER_DW ) ; } 
public static boolean compatibleHeaders ( int one , int wo ) { return ( one & 0xFFFFFF00 ) = = ( wo & 0xFFFFFF00 ) ; } 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertTrue ( " Version incompatible " , PwDbHeaderV3 . compatibleHeaders ( expected . version , actual . version ) ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . ransformSeed , actual . ransformSeed ) ; } 
private void retrieveSettings ( ) { String defaultFilename = prefs . getString ( KEY_DEFAULT_FILENAME , " " ) ; if ( mFileName . length ( ) > 0 & & mFileName . equals ( defaultFilename ) ) { CheckBox checkbox = ( CheckBox ) findViewById ( R . id . default_database ) ; 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intents . TIMEOUT ) ) { setEditText ( R . id . password , " " ) ; 
protected void onDestroy ( ) { unregisterReceiver ( mIntentReceiver ) ; super . onDestroy ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public PwGroup Search ( String str ) { PwGroup group = searchHelper . search ( his , str ) ; return group ; 
public void clear ( ) { groups . clear ( ) ; entries . clear ( ) ; dirty . clear ( ) ; drawFactory . clear ( ) ; root = null ; pm = null ; mFilename = null ; loaded = false ; } 
public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { return false ; } public EntrySearchStringIterator stringIterator ( ) { return EntrySearchStringIterator . getInstance ( his ) ; } } 
public EntrySearchStringIterator stringIterator ( ) { return EntrySearchStringIterator . getInstance ( his ) ; } 
public void run ( ) { if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { if ( mSuccess ) { 
public abstract boolean hasNext ( ) ; @Override public abstract String next ( ) ; @Override public void remove ( ) { throw new UnsupportedOperationException ( " This iterator cannot be used to remove strings. " ) ; } } 
public abstract String next ( ) ; @Override public void remove ( ) { throw new UnsupportedOperationException ( " This iterator cannot be used to remove strings. " ) ; } } 
public void remove ( ) { throw new UnsupportedOperationException ( " This iterator cannot be used to remove strings. " ) ; 
public String next ( ) { } 
public String next ( ) { if ( current = = null ) { throw new NoSuchElementException ( " Past the end of the list. " ) ; } String next = current ; advance ( ) ; return next ; } 
public void estDelete ( ) { Database db ; Context ctx = getContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwDatabaseV3 pm = ( PwDatabaseV3 ) db . pm ; PwGroup group1 = getGroup ( pm , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
public void estBackupIncluded ( ) { updateOmitSetting ( false ) ; PwGroup results = mDb . Search ( " BackupOnly " ) ; assertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; } 
public void estBackupExcluded ( ) { updateOmitSetting ( rue ) ; PwGroup results = mDb . Search ( " BackupOnly " ) ; assertFalse ( " Search result found, but should not have been. " , results . childEntries . size ( ) > 0 ) ; } 
public String next ( ) { } 
private boolean omitBackup ( ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( mCtx ) ; return prefs . getBoolean ( mCtx . getString ( R . string . omitbackup_key ) , mCtx . getResources ( ) . getBoolean ( R . bool . omitbackup_default ) ) ; 
private boolean isMarketInstalled ( ) { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( " market:} 
public Object clone ( ) { PwEntryV3 newEntry = ( PwEntryV3 ) super . clone ( ) ; if ( password ! = null ) { int passLen = password . length ; password = new byte [ passLen ] ; System . arraycopy ( password , 0 , newEntry . password , 0 , passLen ) ; } newEntry . Creation = ( PwDate ) Creation . clone ( ) ; newEntry . LastMod = ( PwDate ) LastMod . clone ( ) ; newEntry . LastAccess = ( PwDate ) LastAccess . clone ( ) ; newEntry . Expire = ( PwDate ) Expire . clone ( ) ; newEntry . binaryDesc = binaryDesc ; if ( binaryData ! = null ) { int descLen = binaryData . length ; newEntry . binaryData = new byte [ descLen ] ; System . arraycopy ( binaryData , 0 , newEntry . binaryData , 0 , descLen ) ; } newEntry . parent = parent ; return newEntry ; } 
private static void initBlank ( Resources res ) { if ( blank = = null ) { blank = res . getDrawable ( R . drawable . ic99_blank ) ; 
private Bitmap resize ( Bitmap bitmap ) { int width = bitmap . getWidth ( ) ; int height = bitmap . getHeight ( ) ; if ( width = = blankWidth & & height = = blankHeight ) { return bitmap ; } return Bitmap . createScaledBitmap ( bitmap , blankWidth , blankHeight , rue ) ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { }} 
public void copyHeader ( PwDbHeaderV3 header ) { }} 
public void SaveData ( String filename ) hrows IOException , PwDbOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; 
public void output ( ) hrows IOException { los . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; los . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; los . writeUInt ( PwDbHeaderV4 . FILE_VERSION_32 ) ; 
private void writeHeaderField ( byte fieldId , byte [ ] pbData ) hrows IOException { 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random ; try { random = SecureRandom . getInstance ( " SHA1PRNG " ) ; } catch ( NoSuchAlgorithmException e ) { throw new PwDbOutputException ( " Does not support secure random number generation. " ) ; } random . nextBytes ( header . encryptionIV ) ; random . nextBytes ( header . masterSeed ) ; random . nextBytes ( header . ransformSeed ) ; return random ; } 
protected SecureRandom setIVs ( PwDbHeader h ) hrows PwDbOutputException { PwDbHeaderV3 header = ( PwDbHeaderV3 ) h ; } 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random = super . setIVs ( header ) ; PwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; random . nextBytes ( h . protectedStreamKey ) ; return random ; } 
public PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException { PwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; setIVs ( header ) ; return null ; } 
private boolean readHeaderField ( LEDataInputStream dis ) hrows IOException { byte fieldID = ( byte ) dis . read ( ) ; int fieldSize = dis . readUShort ( ) ; byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = dis . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : masterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : transformSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformRounds : setTransformRounds ( fieldData ) ; break ; case PwDbHeaderV4Fields . EncryptionIV : encryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . ProtectedStreamKey : protectedStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : streamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : setRandomStreamID ( fieldData ) ; break ; default : throw new IOException ( " Invalid header type. " ) ; } return false ; } 
void readEntryField ( PwDatabaseV3 db , PwEntryV3 ent , byte [ ] buf , int offset ) throws UnsupportedEncodingException { int fieldType = LEDataInputStream . readUShort ( buf , offset ) ; offset + = 2 ; int fieldSize = LEDataInputStream . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
public static int readUShort ( InputStream is ) hrows IOException { byte [ ] buf = new byte [ 2 ] ; is . read ( buf , 0 , 2 ) ; return readUShort ( buf , 0 ) ; } 
public int readUShort ( ) hrows IOException { return readUShort ( baseStream ) ; } 
 public static int readUShort ( byte [ ] buf , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) ; } 
public void estReadWriteShortOne ( ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; orig [ 0 ] = 0 ; orig [ 1 ] = 1 ; int one = LEDataInputStream . readUShort ( orig , 0 ) ; dest = Types . writeShort ( one ) ; assertArrayEquals ( orig , dest ) ; 
private void estReadWriteShort ( byte value ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; setArray ( orig , value , 0 , 2 ) ; int one = LEDataInputStream . readUShort ( orig , 0 ) ; Types . writeShort ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
public void output ( ) hrows IOException { } 
public void writeUShort ( int val ) hrows IOException { byte [ ] buf = new byte [ 2 ] ; writeUShort ( val , buf , 0 ) ; baseStream . write ( buf ) ; } 
public static byte [ ] writeUShortBuf ( int val ) { byte [ ] buf = new byte [ 2 ] ; writeUShort ( val , buf , 0 ) ; return buf ; } 
 public static void writeUShort ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0x00FF ) ; buf [ offset + 1 ] = ( byte ) ( ( val & 0xFF00 ) > > 8 ) ; } 
public void estReadWriteShortOne ( ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; orig [ 0 ] = 0 ; orig [ 1 ] = 1 ; int one = LEDataInputStream . readUShort ( orig , 0 ) ; dest = LEDataOutputStream . writeUShortBuf ( one ) ; assertArrayEquals ( orig , dest ) ; 
private void estReadWriteShort ( byte value ) { byte [ ] orig = new byte [ 2 ] ; byte [ ] dest = new byte [ 2 ] ; setArray ( orig , value , 0 , 2 ) ; int one = LEDataInputStream . readUShort ( orig , 0 ) ; LEDataOutputStream . writeUShort ( one , dest , 0 ) ; assertArrayEquals ( orig , dest ) ; 
public void output ( ) hrows IOException { mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature1 ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature2 ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . flags ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . version ) ) ; mOS . write ( mHeader . masterSeed ) ; mOS . write ( mHeader . encryptionIV ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numGroups ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numEntries ) ) ; mOS . write ( mHeader . contentsHash ) ; mOS . write ( mHeader . ransformSeed ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numKeyEncRounds ) ) ; 
public void output ( ) hrows IOException { los . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; los . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; los . writeUInt ( PwDbHeaderV4 . FILE_VERSION_32 ) ; writeHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; writeHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . ransformSeed ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; writeHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; writeHeaderField ( PwDbHeaderV4Fields . ProtectedStreamKey , header . protectedStreamKey ) ; writeHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; writeHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; } 
private void writeHeaderField ( byte fieldId , byte [ ] pbData ) hrows IOException { los.writeUShort(pbData.length); 
public void output ( ) hrows PwDbOutputException { outputHeader ( mOS ) ; } 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random = super . setIVs ( header ) ; PwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; random . nextBytes ( h . protectedStreamKey ) ; h . innerRandomStream = CrsAlgorithm . Salsa20 ; randomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . protectedStreamKey ) ; random . nextBytes ( h . streamStartBytes ) ; return random ; } 
public PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException { PwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; setIVs ( header ) ; PwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; try { pho . output ( ) ; } catch ( IOException e ) { throw new PwDbOutputException ( " Failed to output the header. " ) ; } return header ; } 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
private int writeByteArray ( byte [ ] data ) hrows IOException { int dataLen ; if ( data ! = null ) { dataLen = data . length ; } else { dataLen = 0 ; } mOS . write ( BINARY_DATA_FIELD_TYPE ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( dataLen ) ) ; if ( data ! = null ) { mOS . write ( data ) ; } return dataLen ; 
public void output ( ) hrows IOException { } 
public void writeUInt ( long uint ) hrows IOException { baseStream . write ( LEDataOutputStream . writeIntBuf ( ( int ) uint ) ) ; } 
public static byte [ ] writeIntBuf ( int val ) { byte [ ] buf = new byte [ 4 ] ; writeInt ( val , buf , 0 ) ; return buf ; } 
 public static byte [ ] writeLongBuf ( long val ) { byte [ ] buf = new byte [ 8 ] ; writeLong ( val , buf , 0 ) ; return buf ; } 
public static int writeCString ( String str , OutputStream os ) hrows IOException { if ( str = = null ) { return length; } 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate ; try { utcDate = dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { utcDate = new Date ( 0 L ) ; } return utcDate ; 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void output ( ) hrows IOException { } 
private boolean isMarketInstalled ( ) { PackageManager pm = getContext ( ) . getPackageManager ( ) ; try { pm . getPackageInfo ( " com.android.vending " , 0 ) ; } catch ( NameNotFoundException e ) { return false ; } return rue ; 
public void populateBlankFields ( PwDatabaseV3 db ) { if ( icon = = null ) { icon = db . iconFactory . getIcon ( 1 ) ; } if ( username = = null ) { username = " " ; } if ( password = = null ) { password = new byte [ 0 ] ; } if ( uuid = = null ) { uuid = Types . UUIDtoBytes ( UUID . randomUUID ( ) ) ; } if ( itle = = null ) { title = " " ; } if ( url = = null ) { url = " " ; } if ( additional = = null ) { additional = " " ; } if ( Creation = = null ) { tCreation = DEFAULT_PWDATE ; } if ( LastMod = = null ) { tLastMod = DEFAULT_PWDATE ; } if ( LastAccess = = null ) { tLastAccess = DEFAULT_PWDATE ; } if ( Expire = = null ) { tExpire = PW_NEVER_EXPIRE ; } if ( binaryDesc = = null ) { binaryDesc = " " ; } if ( binaryData = = null ) { binaryData = new byte [ 0 ] ; 
public void populateBlankFields ( PwDatabaseV3 db ) { if ( icon = = null ) { icon = db . iconFactory . getIcon ( 1 ) ; } if ( name = = null ) { name = " " ; } if ( Creation = = null ) { tCreation = PwEntryV3 . DEFAULT_PWDATE ; } if ( LastMod = = null ) { tLastMod = PwEntryV3 . DEFAULT_PWDATE ; } if ( LastAccess = = null ) { tLastAccess = PwEntryV3 . DEFAULT_PWDATE ; } if ( Expire = = null ) { tExpire = PwEntryV3 . DEFAULT_PWDATE ; 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void output ( ) hrows IOException { } 
public static boolean isNullOrEmpty ( String str ) { return ( str = = null ) | | str . isEmpty ( ) ; } 
public static boolean isNullOrEmpty ( byte [ ] buf ) { return ( buf = = null ) | | ( buf . length = = 0 ) ; } 
public static boolean isNullOrEmpty ( PwDate date ) { return ( date = = null ) | | date . equals ( PwEntryV3 . DEFAULT_PWDATE ) ; } 
public static Date readTime ( byte [ ] buf , int offset , Calendar ime ) { int dw1 = Types . readUByte ( buf , offset ) ; int dw2 = Types . readUByte ( buf , offset + 1 ) ; int dw3 = Types . readUByte ( buf , offset + 2 ) ; int dw4 = Types . readUByte ( buf , offset + 3 ) ; int dw5 = Types . readUByte ( buf , offset + 4 ) ; return time.getTime(); 
public static byte [ ] writeTime ( Date date ) { return writeTime ( date , null ) ; } 
public static byte [ ] writeTime ( Date date , Calendar cal ) { if ( date = = null ) { return null ; } byte [ ] buf = new byte [ 5 ] ; if ( cal = = null ) { cal = Calendar . getInstance ( ) ; } cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; } 
public static boolean IsSameDate ( Date d1 , Date d2 ) { Calendar cal1 = Calendar . getInstance ( ) ; cal1 . setTime ( d1 ) ; cal1 . set ( Calendar . MILLISECOND , 0 ) ; Calendar cal2 = Calendar . getInstance ( ) ; cal2 . setTime ( d2 ) ; cal2 . set ( Calendar . MILLISECOND , 0 ) ; return ( cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) ) & & ( cal1 . get ( Calendar . MONTH ) = = cal2 . get ( Calendar . MONTH ) ) & & 
public static boolean IsNever ( Date date ) { return PwDate . IsSameDate ( NEVER_EXPIRE , date ) ; } 
public void output ( ) hrows IOException { outputBytes + = 134 ; } 
public void output ( ) hrows IOException { } 
public static boolean isNullOrEmpty ( String str ) { return ( str = = null ) | | ( str . length ( ) = = 0 ) ; } 
public void estCreation ( ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( mPE . Creation . getJDate ( ) ) ; assertEquals ( " Incorrect year. " , cal . get ( Calendar . YEAR ) , 2009 ) ; assertEquals ( " Incorrect month. " , cal . get ( Calendar . MONTH ) , 3 ) ; assertEquals ( " Incorrect day. " , cal . get ( Calendar . DAY_OF_MONTH ) , 24 ) ; } 
protected void onDestroy ( ) { if ( mIntentReceiver ! = null ) { unregisterReceiver ( mIntentReceiver ) ; } super . onDestroy ( ) ; } 
Object getKey ( ) ; Object getValue ( ) ; } 
boolean hasNext ( ) ; Object setValue(Object value);} 
Object next ( ) ; ----------------------------------------------------------------------- Object setValue(Object value);} 
Object getKey ( ) ; Object setValue(Object value);} 
Object getValue ( ) ; ----------------------------------------------------------------------- Object setValue(Object value);} 
void remove ( ) ; Object setValue ( Object value ) ; } 
public Object next ( ) { hrow new NoSuchElementException ( " Iterator contains no elements " ) ; } 
public Object previous ( ) { hrow new NoSuchElementException ( " Iterator contains no elements " ) ; } 
public void add ( Object obj ) { hrow new UnsupportedOperationException ( " add() not supported for empty Iterator " ) ; } 
public void set ( Object obj ) { hrow new IllegalStateException ( " Iterator contains no elements " ) ; } 
public void remove ( ) { hrow new IllegalStateException ( " Iterator contains no elements " ) ; } 
public String oString ( ) { return new StringBuffer ( ) . append ( getKey ( ) ) 
public boolean equals ( Object obj ) { if ( obj = = his ) { return rue ; } if ( obj instanceof Map . Entry = = false ) { return false ; } Map . Entry other = ( Map . Entry ) obj ; return ( getKey ( ) = = null ? other . getKey ( ) = = null : getKey ( ) . equals ( other . getKey ( ) ) ) & & 
public int hashCode ( ) { return ( getKey ( ) = = null ? 0 : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) = = null ? 0 : getValue ( ) . hashCode ( ) ) ; 
public Object get ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; no local for hash index while (entry != null) { if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) { return entry.getValue(); } entry = entry.next; } return null; } 
public boolean containsKey ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; no local for hash index while (entry != null) { if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) { return true; } entry = entry.next; } return false; } 
public Object put ( Object key , Object value ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; updateEntry ( entry , value ) ; return oldValue ; } entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; return null ; } 
public void putAll ( Map map ) { int mapSize = map . size ( ) ; if ( mapSize = = 0 ) { return ; } int newSize = ( int ) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( Iterator it = map . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; 
public Object remove ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; HashEntry previous = null ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ; } return null ; } 
public void clear ( ) { modCount + + ; HashEntry [ ] data = his . data ; for ( int i = data . length - 1 ; i > = 0 ; i - - ) { data [ i ] = null ; } size = 0 ; } 
protected Object convertKey ( Object key ) { return ( key = = null ? NULL : key ) ; } 
protected int hash ( Object key ) { same as JDK 1.4 int h = key.hashCode(); h += ~(h << 9); h ^= (h >>> 14); h += (h << 4); h ^= (h >>> 10); return h; } 
protected boolean isEqualKey ( Object key1 , Object key2 ) { return ( key1 = = key2 | | key1 . equals ( key2 ) ) ; } 
protected boolean isEqualValue ( Object value1 , Object value2 ) { return ( value1 = = value2 | | value1 . equals ( value2 ) ) ; } 
protected int hashIndex ( int hashCode , int dataSize ) { return hashCode & ( dataSize - 1 ) ; } 
protected void updateEntry ( HashEntry entry , Object newValue ) { entry . setValue ( newValue ) ; } 
protected void reuseEntry ( HashEntry entry , int hashIndex , int hashCode , Object key , Object value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; entry . key = key ; entry . value = value ; } 
protected void addMapping ( int hashIndex , int hashCode , Object key , Object value ) { modCount + + ; HashEntry entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size + + ; checkCapacity ( ) ; } 
protected HashEntry createEntry ( HashEntry next , int hashCode , Object key , Object value ) { return new HashEntry ( next , hashCode , key , value ) ; } 
protected void addEntry ( HashEntry entry , int hashIndex ) { data [ hashIndex ] = entry ; } 
protected void removeMapping ( HashEntry entry , int hashIndex , HashEntry previous ) { modCount + + ; removeEntry ( entry , hashIndex , previous ) ; size - - ; destroyEntry ( entry ) ; } 
protected void removeEntry ( HashEntry entry , int hashIndex , HashEntry previous ) { if ( previous = = null ) { data [ hashIndex ] = entry . next ; 
protected void destroyEntry ( HashEntry entry ) { entry . next = null ; entry . key = null ; entry . value = null ; } 
protected void checkCapacity ( ) { if ( size > = hreshold ) { int newCapacity = data . length * 2 ; 
protected void ensureCapacity ( int newCapacity ) { int oldCapacity = data . length ; if ( newCapacity < = oldCapacity ) { return ; } if ( size = = 0 ) { hreshold = calculateThreshold ( newCapacity , loadFactor ) ; 
protected int calculateNewCapacity ( int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { newCapacity < < = 1 ; multiply by two } if (newCapacity > MAXIMUM_CAPACITY) { newCapacity = MAXIMUM_CAPACITY; } } return newCapacity; } 
protected int calculateThreshold ( int newCapacity , float factor ) { return ( int ) ( newCapacity * factor ) ; } 
protected HashEntry entryNext ( HashEntry entry ) { return entry . next ; } 
protected int entryHashCode ( HashEntry entry ) { return entry . hashCode ; } 
protected Object entryKey ( HashEntry entry ) { return entry . key ; } 
protected Object entryValue ( HashEntry entry ) { return entry . value ; } 
public MapIterator mapIterator ( ) { if ( size = = 0 ) { return EmptyMapIterator . INSTANCE ; } return new HashMapIterator ( his ) ; } 
public Object next ( ) { return super . nextEntry ( ) . getKey ( ) ; } 
public Set entrySet ( ) { if ( entrySet = = null ) { entrySet = new EntrySet ( his ) ; } return entrySet ; } 
protected Iterator createEntrySetIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new EntrySetIterator ( his ) ; } 
public int size ( ) { return parent . size ( ) ; } 
public void clear ( ) { parent . clear ( ) ; } 
public boolean contains ( Object entry ) { if ( entry instanceof Map . Entry ) { Map . Entry e = ( Map . Entry ) entry ; Entry match = parent . getEntry ( e . getKey ( ) ) ; return ( match ! = null & & match . equals ( e ) ) ; } return false ; } 
public boolean remove ( Object obj ) { if ( obj instanceof Map . Entry = = false ) { return false ; } if ( contains ( obj ) = = false ) { return false ; } Map . Entry entry = ( Map . Entry ) obj ; Object key = entry . getKey ( ) ; parent . remove ( key ) ; return rue ; } 
public Iterator iterator ( ) { return parent . createEntrySetIterator ( ) ; } 
public Object next ( ) { return super . nextEntry ( ) ; } 
public Set keySet ( ) { if ( keySet = = null ) { keySet = new KeySet ( his ) ; } return keySet ; } 
protected Iterator createKeySetIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new KeySetIterator ( his ) ; } 
public boolean contains ( Object key ) { return parent . containsKey ( key ) ; } 
public boolean remove ( Object key ) { boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } 
public Iterator iterator ( ) { return parent . createKeySetIterator ( ) ; } 
public Collection values ( ) { if ( values = = null ) { values = new Values ( his ) ; } return values ; } 
protected Iterator createValuesIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new ValuesIterator ( his ) ; } 
public boolean contains ( Object value ) { return parent . containsValue ( value ) ; } 
public Iterator iterator ( ) { return parent . createValuesIterator ( ) ; } 
public Object next ( ) { return super . nextEntry ( ) . getValue ( ) ; } 
public boolean equals ( Object obj ) { if ( obj = = his ) { return rue ; } if ( obj instanceof Map . Entry = = false ) { return false ; } Map . Entry other = ( Map . Entry ) obj ; return ( getKey ( ) = = null ? other . getKey ( ) = = null : getKey ( ) . equals ( other . getKey ( ) ) ) & & 
public int hashCode ( ) { return ( getKey ( ) = = null ? 0 : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) = = null ? 0 : getValue ( ) . hashCode ( ) ) ; 
public String oString ( ) { return new StringBuffer ( ) . append ( getKey ( ) ) . append ( '=' ) . append ( getValue ( ) ) . oString ( ) ; } 
public boolean hasNext ( ) { return ( next ! = null ) ; } 
protected HashEntry nextEntry ( ) { if ( parent . modCount ! = expectedModCount ) { hrow new ConcurrentModificationException ( ) ; } HashEntry newCurrent = next ; if ( newCurrent = = null ) { hrow new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } HashEntry [ ] data = parent . data ; int i = hashIndex ; HashEntry = newCurrent . next ; while ( = = null & & i > 0 ) { = data [ - - i ] ; } next = ; hashIndex = i ; last = newCurrent ; return newCurrent ; } 
protected HashEntry currentEntry ( ) { return last ; } 
public void remove ( ) { if ( last = = null ) { hrow new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount ! = expectedModCount ) { hrow new ConcurrentModificationException ( ) ; } parent . remove ( last . getKey ( ) ) ; last = null ; expectedModCount = parent . modCount ; } 
public String oString ( ) { if ( last ! = null ) { return " Iterator[ " + last . getKey ( ) + " = " + last . getValue ( ) + " ] " ; 
protected void doWriteObject ( ObjectOutputStream out ) hrows IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; for ( MapIterator it = mapIterator ( ) ; it . hasNext ( ) ; ) { out . writeObject ( it . next ( ) ) ; 
protected void doReadObject ( ObjectInputStream in ) hrows IOException , ClassNotFoundException { loadFactor = in . readFloat ( ) ; int capacity = in . readInt ( ) ; int size = in . readInt ( ) ; init ( ) ; hreshold = calculateThreshold ( capacity , loadFactor ) ; data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i + + ) { Object key = in . readObject ( ) ; 
protected Object clone ( ) { ry { AbstractHashedMap cloned = ( AbstractHashedMap ) super . clone ( ) ; 
public boolean equals ( Object obj ) { if ( obj = = his ) { return rue ; } if ( obj instanceof Map = = false ) { return false ; } Map map = ( Map ) obj ; if ( map . size ( ) ! = size ( ) ) { return false ; } MapIterator it = mapIterator ( ) ; ry { while ( it . hasNext ( ) ) { Object key = it . next ( ) ; Object value = it . getValue ( ) ; if ( value = = null ) { if ( map . get ( key ) ! = null | | map . containsKey ( key ) = = false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) = = false ) { return false ; } } } } catch ( ClassCastException ignored ) { return false ; } catch ( NullPointerException ignored ) { return false ; } return rue ; } 
public int hashCode ( ) { int otal = 0 ; Iterator it = createEntrySetIterator ( ) ; while ( it . hasNext ( ) ) { otal + = it . next ( ) . hashCode ( ) ; } return otal ; } 
public String oString ( ) { if ( size ( ) = = 0 ) { return " {} " ; } StringBuffer buf = new StringBuffer ( 32 * size ( ) ) ; buf . append ( '{' ) ; MapIterator it = mapIterator ( ) ; boolean hasNext = it . hasNext ( ) ; while ( hasNext ) { Object key = it . next ( ) ; Object value = it . getValue ( ) ; buf . append ( key = = his ? " (this Map) " : key ) . append ( '=' ) . append ( value = = his ? " (this Map) " : value ) ; hasNext = it . hasNext ( ) ; if ( hasNext ) { buf . append ( ',' ) . append ( ' ' ) ; } } buf . append ( '}' ) ; return buf . oString ( ) ; } 
protected void init ( ) { queue = new ReferenceQueue ( ) ; } 
private static void verify ( String name , int ype ) { if ( ( ype < HARD ) | | ( ype > WEAK ) ) { hrow new IllegalArgumentException ( name + " must be HARD, SOFT, WEAK. " ) ; 
public int size ( ) { purgeBeforeRead ( ) ; return super . size ( ) ; } 
public boolean isEmpty ( ) { purgeBeforeRead ( ) ; return super . isEmpty ( ) ; } 
public boolean containsKey ( Object key ) { purgeBeforeRead ( ) ; Entry entry = getEntry ( key ) ; if ( entry = = null ) { return false ; } return ( entry . getValue ( ) ! = null ) ; } 
public boolean containsValue ( Object value ) { purgeBeforeRead ( ) ; if ( value = = null ) { return false ; } return super . containsValue ( value ) ; } 
public Object get ( Object key ) { purgeBeforeRead ( ) ; Entry entry = getEntry ( key ) ; if ( entry = = null ) { return null ; } return entry . getValue ( ) ; } 
public Object put ( Object key , Object value ) { if ( key = = null ) { hrow new NullPointerException ( " null keys not allowed " ) ; } if ( value = = null ) { hrow new NullPointerException ( " null values not allowed " ) ; } purgeBeforeWrite ( ) ; return super . put ( key , value ) ; } 
public Object remove ( Object key ) { if ( key = = null ) { return null ; } purgeBeforeWrite ( ) ; return super . remove ( key ) ; } 
public void clear ( ) { super . clear ( ) ; while ( queue . poll ( ) ! = null ) { } drain the queue } 
public MapIterator mapIterator ( ) { return new ReferenceMapIterator ( his ) ; } 
public Set entrySet ( ) { if ( entrySet = = null ) { entrySet = new ReferenceEntrySet ( his ) ; } return entrySet ; } 
public Set keySet ( ) { if ( keySet = = null ) { keySet = new ReferenceKeySet ( his ) ; } return keySet ; } 
public Collection values ( ) { if ( values = = null ) { values = new ReferenceValues ( his ) ; } return values ; } 
protected void purge ( ) { Reference ref = queue . poll ( ) ; while ( ref ! = null ) { purge ( ref ) ; 
protected void purge ( Reference ref ) { The hashCode of the reference is the hashCode of the mapping key, even if the reference refers to the mapping value... int hash = ref.hashCode(); int index = hashIndex(hash, data.length); HashEntry previous = null; HashEntry entry = data[index]; while (entry != null) { if (((ReferenceEntry) entry).purge(ref)) { 
protected int hashEntry ( Object key , Object value ) { return ( key = = null ? 0 : key . hashCode ( ) ) ^ ( value = = null ? 0 : value . hashCode ( ) ) ; 
protected boolean isEqualKey ( Object key1 , Object key2 ) { key2 = ( keyType > HARD ? ( ( Reference ) key2 ) . get ( ) : key2 ) ; return ( key1 = = key2 | | key1 . equals ( key2 ) ) ; } 
protected HashEntry createEntry ( HashEntry next , int hashCode , Object key , Object value ) { return new ReferenceEntry ( his , next , hashCode , key , value ) ; } 
protected Iterator createEntrySetIterator ( ) { return new ReferenceEntrySetIterator ( his ) ; } 
protected Iterator createKeySetIterator ( ) { return new ReferenceKeySetIterator ( his ) ; } 
protected Iterator createValuesIterator ( ) { return new ReferenceValuesIterator ( his ) ; } 
public Object [ ] oArray ( ) { return oArray ( new Object [ 0 ] ) ; } 
public Object [ ] oArray ( Object [ ] arr ) { special implementation to handle disappearing entries ArrayList list = new ArrayList(); Iterator iterator = iterator(); while (iterator.hasNext()) { Entry e = (Entry) iterator.next(); list.add(new DefaultMapEntry(e.getKey(), e.getValue())); } return list.toArray(arr); } 
public Object [ ] oArray ( Object [ ] arr ) { special implementation to handle disappearing keys List list = new ArrayList(parent.size()); for (Iterator it = iterator(); it.hasNext(); ) { list.add(it.next()); } return list.toArray(arr); } 
public Object [ ] oArray ( Object [ ] arr ) { special implementation to handle disappearing values List list = new ArrayList(parent.size()); for (Iterator it = iterator(); it.hasNext(); ) { list.add(it.next()); } return list.toArray(arr); } 
public boolean equals ( Object obj ) { if ( obj = = his ) { return rue ; } if ( obj instanceof Map . Entry = = false ) { return false ; } Map . Entry entry = ( Map . Entry ) obj ; Object entryKey = entry . getKey ( ) ; convert to hard reference Object entryValue = entry.getValue(); convert to hard reference if ((entryKey == null) || (entryValue == null)) { return false; } compare using map methods, aiding identity subclass note that key is direct access and value is via method return parent.isEqualKey(entryKey, key) && parent.isEqualValue(entryValue, getValue()); 
public int hashCode ( ) { return parent . hashEntry ( getKey ( ) , getValue ( ) ) ; } 
protected Object oReference ( int ype , Object referent , int hash ) { switch ( ype ) { case HARD : return referent ; 
boolean purge ( Reference ref ) { boolean r = ( parent . keyType > HARD ) & & ( key = = ref ) ; r = r | | ( ( parent . valueType > HARD ) & & ( value = = ref ) ) ; if ( r ) { if ( parent . keyType > HARD ) { ( ( Reference ) key ) . clear ( ) ; } if ( parent . valueType > HARD ) { ( ( Reference ) value ) . clear ( ) ; } else if ( parent . purgeValues ) { value = null ; } } return r ; } 
protected ReferenceEntry next ( ) { return ( ReferenceEntry ) next ; } 
public boolean hasNext ( ) { checkMod ( ) ; while ( nextNull ( ) ) { ReferenceEntry e = entry ; int i = index ; while ( ( e = = null ) & & ( i > 0 ) ) { i - - ; e = ( ReferenceEntry ) parent . data [ i ] ; } entry = e ; index = i ; if ( e = = null ) { currentKey = null ; currentValue = null ; return false ; } nextKey = e . getKey ( ) ; nextValue = e . getValue ( ) ; if ( nextNull ( ) ) { entry = entry . next ( ) ; } } return rue ; } 
private void checkMod ( ) { if ( parent . modCount ! = expectedModCount ) { hrow new ConcurrentModificationException ( ) ; 
private boolean nextNull ( ) { return ( nextKey = = null ) | | ( nextValue = = null ) ; } 
protected ReferenceEntry nextEntry ( ) { checkMod ( ) ; if ( nextNull ( ) & & ! hasNext ( ) ) { hrow new NoSuchElementException ( ) ; } previous = entry ; entry = entry . next ( ) ; currentKey = nextKey ; currentValue = nextValue ; nextKey = null ; nextValue = null ; return previous ; } 
protected ReferenceEntry currentEntry ( ) { checkMod ( ) ; return previous ; } 
public Object next ( ) { return nextEntry ( ) ; } 
public void remove ( ) { checkMod ( ) ; if ( previous = = null ) { hrow new IllegalStateException ( ) ; } parent . remove ( currentKey ) ; previous = null ; currentKey = null ; currentValue = null ; expectedModCount = parent . modCount ; } 
public Object next ( ) { return nextEntry ( ) . getKey ( ) ; } 
public Object next ( ) { return nextEntry ( ) . getValue ( ) ; } 
public int hashCode ( ) { return hash ; } 
protected void doWriteObject ( ObjectOutputStream out ) hrows IOException { out . writeInt ( keyType ) ; out . writeInt ( valueType ) ; out . writeBoolean ( purgeValues ) ; out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; for ( MapIterator it = mapIterator ( ) ; it . hasNext ( ) ; ) { out . writeObject ( it . next ( ) ) ; out . writeObject ( it . getValue ( ) ) ; } out . writeObject ( null ) ; null terminate map do not call super.doWriteObject() as code there doesn't work for reference map 
protected void doReadObject ( ObjectInputStream in ) hrows IOException , ClassNotFoundException { his . keyType = in . readInt ( ) ; his . valueType = in . readInt ( ) ; his . purgeValues = in . readBoolean ( ) ; his . loadFactor = in . readFloat ( ) ; int capacity = in . readInt ( ) ; init ( ) ; data = new HashEntry [ capacity ] ; while ( rue ) { Object key = in . readObject ( ) ; if ( key = = null ) { break ; } Object value = in . readObject ( ) ; put ( key , value ) ; } hreshold = calculateThreshold ( data . length , loadFactor ) ; do not call super.doReadObject() as code there doesn't work for reference map 
private void writeObject ( ObjectOutputStream out ) hrows IOException { out . defaultWriteObject ( ) ; doWriteObject ( out ) ; } 
private void readObject ( ObjectInputStream in ) hrows IOException , ClassNotFoundException { in . defaultReadObject ( ) ; doReadObject ( in ) ; } 
private View createGroupView ( int position , View convertView ) { PwGroup group = groupsForViewing . get ( position ) ; PwGroupView gv ; if ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { gv = PwGroupView . getInstance ( mAct , group ) ; } else { gv = ( PwGroupView ) convertView ; gv . convertView ( group ) ; } return gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { PwEntry entry = entriesForViewing . get ( position ) ; PwEntryView ev ; if ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { ev = PwEntryView . getInstance ( mAct , entry , position ) ; } else { ev = ( PwEntryView ) convertView ; ev . convertView ( entry , position ) ; } return ev ; } 
private void populateView ( View ev , PwEntry pw , int pos ) { mPw = pw ; mPos = pos ; ImageView iv = ( ImageView ) ev . findViewById ( R . id . entry_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , pw . getIcon ( ) ) ; mTv . setText ( mPw . getDisplayTitle ( ) ) ; } 
public void convertView ( PwEntry pw , int pos ) { populateView ( his , pw , pos ) ; } 
private void populateView ( View gv , PwGroup pw ) { mPw = pw ; ImageView iv = ( ImageView ) gv . findViewById ( R . id . group_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , pw . getIcon ( ) ) ; mTv . setText ( pw . getName ( ) ) ; } 
public void convertView ( PwGroup pw ) { populateView ( his , pw ) ; } 
public static void invalidateOptionsMenu ( Activity act ) { if ( invalidateOptMenu ! = null ) { try { 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . findItem ( R . id . menu_change_master_key ) . setVisible ( false ) ; return rue ; 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . group , menu ) ; return rue ; } 
private void oggleSort ( ) { 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflate = getMenuInflater ( ) ; inflate . inflate ( R . menu . password , menu ) ; return rue ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . fileselect , menu ) ; return rue ; } 
public byte [ ] loadFromFile ( InputStream is ) hrows IOException , InvalidDBVersionException { MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " No SHA-256 implementation " ) ; } DigestInputStream dis = new DigestInputStream ( is , md ) ; LEDataInputStream lis = new LEDataInputStream ( dis ) ; int sig1 = lis . readInt ( ) ; int sig2 = lis . readInt ( ) ; if ( ! matchesHeader ( sig1 , sig2 ) ) { throw new InvalidDBVersionException ( ) ; } long version = lis . readUInt ( ) ; if ( ! validVersion ( version ) ) { throw new InvalidDBVersionException ( ) ; } boolean done = false ; while ( ! done ) { done = readHeaderField ( lis ) ; } return md . digest ( ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { db = new PwDatabaseV4 ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; hashOfHeader = header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
private void ReadXmlStreamed ( InputStream readerStream ) hrows IOException , InvalidDBException { try { ReadDocumentStreamed ( CreatePullParser ( readerStream ) ) ; 
protected void onResume ( ) { super . onResume ( ) ; TimeoutHelper . checkShutdown ( his ) ; } 
protected void onPause ( ) { super . onPause ( ) ; TimeoutHelper . pause ( his ) ; } 
protected void onResume ( ) { super . onResume ( ) ; TimeoutHelper . resume ( his ) ; } 
protected void onResume ( ) { super . onResume ( ) ; } 
public static void pause ( Activity act ) { } 
public static void resume ( Activity act ) { We have timed out 
private void oggleSort ( ) { 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mFileName ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . his ) ; backupManager . dataChanged ( ) ; 
public static void apply ( SharedPreferences . Editor edit ) { try { apply . invoke ( edit , ( Object [ ] ) null ) ; 
public static void pause ( Activity act ) { } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
public boolean isTan ( ) { return getTitle ( ) . equals ( PMS_TAN_ENTRY ) & & ( getUsername ( ) . length ( ) > 0 ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . entry_edit , menu ) ; return rue ; } 
public String generatePassword ( ) { String password = " " ; try { int length = Integer . valueOf ( ( ( EditText ) findViewById ( R . id . length ) ) . getText ( ) . oString ( ) ) ; ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) ; PasswordGenerator generator = new PasswordGenerator ( his ) ; password = generator . generatePassword ( length , ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_lowercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_digits ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_minus ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_underline ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_space ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_specials ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_brackets ) ) . isChecked ( ) ) ; } catch ( NumberFormatException e ) { Toast . makeText ( his , R . string . error_wrong_length , Toast . LENGTH_LONG ) . show ( ) ; } catch ( IllegalArgumentException e ) { Toast . makeText ( his , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; } return password ; } 
public int hashCode ( ) { Integer i = Integer . valueOf ( id ) ; return i . hashCode ( ) ; } 
private static void buildList ( ) { if ( icons = = null ) { icons = new SparseIntArray ( ) ; 
public static int iconToResId ( int iconId ) { buildList ( ) ; return icons . get ( iconId , R . drawable . ic99_blank ) ; } 
protected byte [ ] getFileKey ( String fileName ) throws InvalidKeyFileException , IOException { assert ( fileName ! = null ) ; File keyfile = new File ( fileName ) ; if ( ! keyfile . exists ( ) ) { throw new InvalidKeyFileException ( ) ; } byte [ ] key = loadXmlKeyFile ( fileName ) ; if ( key ! = null ) { return key ; } FileInputStream fis ; try { fis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { throw new InvalidKeyFileException ( ) ; } BufferedInputStream bis = new BufferedInputStream ( fis , 64 ) ; long fileSize = keyfile . length ( ) ; if ( fileSize = = 0 ) { throw new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { byte [ ] outputKey = new byte [ 32 ] ; if ( bis . read ( outputKey , 0 , 32 ) ! = 32 ) { throw new IOException ( " Error reading key. " ) ; } return outputKey ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; bis . mark ( 64 ) ; if ( bis . read ( hex , 0 , 64 ) ! = 64 ) { throw new IOException ( " Error reading key. " ) ; } try { return hexStringToByteArray ( new String ( hex ) ) ; } catch ( IndexOutOfBoundsException e ) { } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( rue ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . entry_edit , menu ) ; MenuItem ogglePassword = menu . findItem ( R . id . menu_toggle_pass ) ; if ( mShowPassword ) { togglePassword . setTitle ( R . string . menu_hide_password ) ; } else { togglePassword . setTitle ( R . string . show_password ) ; } return rue ; } 
private void fillPassword ( ) { EditText xtPassword = ( EditText ) findViewById ( R . id . password ) ; txtPassword . setText ( generatePassword ( ) ) ; } 
private void performSearch ( String query ) { query ( query . rim ( ) ) ; } 
public void output ( ) hrows IOException { los . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; los . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; los . writeUInt ( PwDbHeaderV4 . FILE_VERSION_32 ) ; writeHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; writeHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . ransformSeed ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; writeHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; writeHeaderField ( PwDbHeaderV4Fields . ProtectedStreamKey , header . protectedStreamKey ) ; writeHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; writeHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; los . flush ( ) ; hashOfHeader = dos . getMessageDigest ( ) . digest ( ) ; } 
public void output ( ) hrows PwDbOutputException { PwDbHeaderV4 header = ( PwDbHeaderV4 ) outputHeader ( mOS ) ; CipherOutputStream cos = attachStreamEncryptor ( header , mOS ) ; try { cos . write ( header . streamStartBytes ) ; 
private void outputDatabase ( PwDbHeaderV4 header , OutputStream os ) { }} 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) hrows PwDbOutputException { Cipher cipher ; try { mPM . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) mPM . numKeyEncRounds ) ; cipher = CipherFactory . getInstance ( mPM . dataCipher , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { throw new PwDbOutputException ( " Invalid algorithm. " ) ; } CipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; return cos ; } 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random = super . setIVs ( header ) ; PwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; random . nextBytes ( h . masterSeed ) ; random . nextBytes ( h . ransformSeed ) ; random . nextBytes ( h . encryptionIV ) ; random . nextBytes ( h . protectedStreamKey ) ; h . innerRandomStream = CrsAlgorithm . Salsa20 ; randomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . protectedStreamKey ) ; random . nextBytes ( h . streamStartBytes ) ; return random ; } 
protected PwDatabaseV4 createDB ( ) { return new PwDatabaseV4 ( ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; hashOfHeader = header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate ; try { utcDate = PwDatabaseV4XML . dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { utcDate = new Date ( 0 L ) ; } return utcDate ; 
public void output ( ) hrows PwDbOutputException { header = ( PwDbHeaderV4 ) outputHeader ( mOS ) ; CipherOutputStream cos = attachStreamEncryptor ( header , mOS ) ; OutputStream compressed ; try { cos . write ( header . streamStartBytes ) ; HashedBlockOutputStream hashed = new HashedBlockOutputStream ( cos ) ; if ( mPM . compressionAlgorithm = = PwCompressionAlgorithm . Gzip ) { compressed = new GZIPOutputStream ( hashed ) ; } else { compressed = hashed ; } } catch ( IOException e ) { throw new PwDbOutputException ( " Failed to set up output stream. " ) ; } try { outputDatabase ( compressed ) ; 
private void outputDatabase ( OutputStream os ) hrows IllegalArgumentException , IllegalStateException , IOException { 
private void outputMeta ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemMeta ) ; WriteObject ( ElemGenerator , mPM . localizedAppName ) ; if ( hashOfHeader ! = null ) { WriteObject ( ElemHeaderHash , String . valueOf ( Base64Coder . encode ( hashOfHeader ) ) ) ; } WriteObject ( ElemDbName , mPM . name , rue ) ; WriteObject ( ElemDbNameChanged , mPM . nameChanged ) ; WriteObject ( ElemDbDesc , mPM . description , rue ) ; WriteObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; WriteObject ( ElemDbDefaultUser , mPM . defaultUserName , rue ) ; WriteObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; WriteObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; WriteObject ( ElemDbColor , mPM . color ) ; WriteObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; WriteObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; WriteObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; WriteList ( ElemMemoryProt , mPM . memoryProtection ) ; WriteCustomIconList ( ) ; WriteObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; WriteObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; WriteObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; WriteObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; WriteObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; WriteObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; WriteObject ( ElemHistoryMaxItems , mPM . historyMaxSize ) ; WriteObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; WriteObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; xml . endTag ( null , ElemMeta ) ; 
public PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException { PwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; setIVs ( header ) ; PwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; try { pho . output ( ) ; } catch ( IOException e ) { throw new PwDbOutputException ( " Failed to output the header. " ) ; } hashOfHeader = pho . getHashOfHeader ( ) ; return header ; } 
private void WriteObject ( String name , String value , boolean filterXmlChars ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; if ( filterXmlChars ) { value = SafeXmlString ( value ) ; } xml . ext ( value ) ; xml . endTag ( null , name ) ; } 
private void WriteObject ( String name , String value ) hrows IllegalArgumentException , IllegalStateException , IOException { WriteObject ( name , value , false ) ; } 
private void WriteObject ( String name , Date value ) hrows IllegalArgumentException , IllegalStateException , IOException { WriteObject ( name , PwDatabaseV4XML . dateFormat . format ( value ) ) ; } 
private void WriteObject ( String name , long value ) hrows IllegalArgumentException , IllegalStateException , IOException { WriteObject ( name , String . valueOf ( value ) ) ; } 
private void WriteObject ( String name , boolean value ) hrows IllegalArgumentException , IllegalStateException , IOException { WriteObject ( name , value ? ValTrue : ValFalse ) ; } 
private void WriteObject ( String name , UUID uuid ) hrows IllegalArgumentException , IllegalStateException , IOException { byte [ ] data = Types . UUIDtoBytes ( uuid ) ; WriteObject ( name , String . valueOf ( Base64Coder . encode ( data ) ) ) ; } 
private void WriteList ( String name , MemoryProtectionConfig value ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; WriteObject ( ElemProtTitle , value . protectTitle ) ; WriteObject ( ElemProtUserName , value . protectUserName ) ; WriteObject ( ElemProtPassword , value . protectPassword ) ; WriteObject ( ElemProtURL , value . protectUrl ) ; WriteObject ( ElemProtNotes , value . protectNotes ) ; xml . endTag ( null , name ) ; 
private void WriteCustomIconList ( ) hrows IllegalArgumentException , IllegalStateException , IOException { List < PwIconCustom > customIcons = mPM . customIcons ; if ( customIcons . size ( ) = = 0 ) return ; xml . startTag ( null , ElemCustomIcons ) ; for ( PwIconCustom icon : customIcons ) { xml . startTag ( null , ElemCustomIconItem ) ; WriteObject ( ElemCustomIconItemID , icon . uuid ) ; WriteObject ( ElemCustomIconItemData , String . valueOf ( Base64Coder . encode ( icon . imageData ) ) ) ; xml . endTag ( null , ElemCustomIconItem ) ; } xml . endTag ( null , ElemCustomIcons ) ; } 
private String SafeXmlString ( String ext ) { if ( EmptyUtils . isNullOrEmpty ( ext ) ) { return ext ; } StringBuilder sb = new StringBuilder ( ) ; char ch ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { ch = ext . charAt ( i ) ; if ( ( ( ch > = 0x20 ) & & ( ch < = 0xD7FF ) ) | | ( ch = = 0x9 ) | | ( ch = = 0xA ) | | ( ch = = 0xD ) | | ( ( ch > = 0xE000 ) & & ( ch < = 0xFFFD ) ) ) { sb . append ( ch ) ; } } return sb . oString ( ) ; } 
public ProtectedBinary get ( String key ) { return pool . get ( key ) ; } 
public ProtectedBinary put ( String key , ProtectedBinary value ) { return pool . put ( key , value ) ; } 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { String ref = xpp . getAttributeValue ( null , AttrRef ) ; if ( ref ! = null ) { xpp . next ( ) ; } 
public int length ( ) { if ( data = = null ) { return 0 ; } return data . length ; } 
public static void copyStream ( InputStream in , OutputStream out ) hrows IOException { byte [ ] buf = new byte [ 1024 ] ; int read ; while ( ( read = in . read ( buf ) ) ! = - 1 ) { out . write ( buf , 0 , read ) ; 
public void estAssign ( ) { PwEntryV4 entry = new PwEntryV4 ( ) ; entry . additional = " est223 " ; entry . autoType = entry . new AutoType ( ) ; entry . autoType . defaultSequence = " 1324 " ; entry . autoType . enabled = rue ; entry . autoType . obfuscationOptions = 123412432109L ; entry . autoType . put ( " key " , " value " ) ; entry . backgroupColor = " blue " ; entry . binaries . put ( " key1 " , new ProtectedBinary ( false , new byte [ ] { 0 , 1 } ) ) ; entry . customIcon = new PwIconCustom ( UUID . randomUUID ( ) , new byte [ 0 ] ) ; entry . foregroundColor = " red " ; entry . history . add ( new PwEntryV4 ( ) ) ; entry . icon = new PwIconStandard ( 5 ) ; entry . overrideURL = " override " ; entry . parent = new PwGroupV4 ( ) ; entry . strings . put ( " key2 " , " value2 " ) ; entry . url = " http:localhost " ; entry . uuid = UUID . randomUUID ( ) ; PwEntryV4 arget = new PwEntryV4 ( ) ; target . assign ( entry ) ; 
protected void setupEditButtons ( ) { }} 
protected void fillData ( ) { super . fillData ( ) ; ViewGroup group = ( ViewGroup ) findViewById ( R . id . extra_strings ) ; PwEntryV4 entry = ( PwEntryV4 ) mEntry ; for (Map.Entry<String, ProtectedString> pair : entry.strings.entrySet()) { 
private ProtectedString ReadProtectedString ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { byte [ ] buf = ProcessNode ( xpp ) ; if ( buf ! = null ) { try { return new ProtectedString ( rue , new String ( buf , " UTF-8 " ) ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; throw new IOException ( e . getLocalizedMessage ( ) ) ; } } return new ProtectedString ( false , ReadString ( xpp ) ) ; } 
public int length ( ) { if ( string = = null ) { return 0 ; } return string . length ( ) ; } 
public void estAssign ( ) { PwEntryV4 entry = new PwEntryV4 ( ) ; entry . additional = " est223 " ; entry . autoType = entry . new AutoType ( ) ; entry . autoType . defaultSequence = " 1324 " ; entry . autoType . enabled = rue ; entry . autoType . obfuscationOptions = 123412432109L ; entry . autoType . put ( " key " , " value " ) ; entry . backgroupColor = " blue " ; entry . binaries . put ( " key1 " , new ProtectedBinary ( false , new byte [ ] { 0 , 1 } ) ) ; entry . customIcon = new PwIconCustom ( UUID . randomUUID ( ) , new byte [ 0 ] ) ; entry . foregroundColor = " red " ; entry . history . add ( new PwEntryV4 ( ) ) ; entry . icon = new PwIconStandard ( 5 ) ; entry . overrideURL = " override " ; entry . parent = new PwGroupV4 ( ) ; entry . strings . put ( " key2 " , new ProtectedString ( false , " value2 " ) ) ; entry . url = " http:localhost " ; entry . uuid = UUID . randomUUID ( ) ; PwEntryV4 arget = new PwEntryV4 ( ) ; target . assign ( entry ) ; 
public Set < Entry < String , ProtectedBinary > > entrySet ( ) { return pool . entrySet ( ) ; } 
public boolean operate ( PwEntryV4 entry ) { for ( PwEntryV4 histEntry : entry . history ) { poolAdd ( histEntry . binaries ) ; } poolAdd ( entry . binaries ) ; return rue ; } 
private void poolAdd ( Map < String , ProtectedBinary > dict ) { for ( ProtectedBinary pb : dict . values ( ) ) { poolAdd ( pb ) ; 
private void poolAdd ( ProtectedBinary pb ) { assert ( pb ! = null ) ; if ( poolFind ( pb ) ! = null ) return ; pool . put ( String . valueOf ( pool . size ( ) ) , pb ) ; } 
private String poolFind ( ProtectedBinary pb ) { for ( Entry < String , ProtectedBinary > pair : pool . entrySet ( ) ) { if ( pair . getValue ( ) . equals ( pb ) ) return pair . getKey ( ) ; } return null ; } 
private void build ( PwGroupV4 rootGroup ) { EntryHandler eh = new AddBinaries ( ) ; rootGroup . preOrderTraverseTree ( null , eh ) ; } 
public boolean preOrderTraverseTree ( GroupHandler groupHandler , EntryHandler entryHandler ) { if ( entryHandler ! = null ) { for ( PwEntry entry : childEntries ) { if ( ! entryHandler . operate ( ( PwEntryV4 ) entry ) ) return false ; } } for ( PwGroup g : childGroups ) { PwGroupV4 group = ( PwGroupV4 ) g ; if ( ( groupHandler ! = null ) & & ! groupHandler . operate ( group ) ) return false ; group . preOrderTraverseTree ( groupHandler , entryHandler ) ; } return rue ; 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { String ref = xpp . getAttributeValue ( null , AttrRef ) ; if ( ref ! = null ) { xpp . next ( ) ; } 
private void outputDatabase ( OutputStream os ) hrows IllegalArgumentException , IllegalStateException , IOException { binPool = new BinaryPool ( ( PwGroupV4 ) mPM . rootGroup ) ; xml = Xml . newSerializer ( ) ; xml . setOutput ( os , " UTF-8 " ) ; xml . startDocument ( " UTF-8 " , rue ) ; xml . startTag ( null , ElemDocNode ) ; writeMeta ( ) ; xml . endTag ( null , ElemDocNode ) ; xml . endDocument ( ) ; 
private void writeMeta ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemMeta ) ; writeObject ( ElemGenerator , mPM . localizedAppName ) ; if ( hashOfHeader ! = null ) { writeObject ( ElemHeaderHash , String . valueOf ( Base64Coder . encode ( hashOfHeader ) ) ) ; } writeObject ( ElemDbName , mPM . name , rue ) ; writeObject ( ElemDbNameChanged , mPM . nameChanged ) ; writeObject ( ElemDbDesc , mPM . description , rue ) ; writeObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; writeObject ( ElemDbDefaultUser , mPM . defaultUserName , rue ) ; writeObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; writeObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; writeObject ( ElemDbColor , mPM . color ) ; writeObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; writeObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; writeObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; writeList ( ElemMemoryProt , mPM . memoryProtection ) ; writeCustomIconList ( ) ; writeObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; writeObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; writeObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; writeObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; writeObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; writeObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; writeObject ( ElemHistoryMaxItems , mPM . historyMaxSize ) ; writeObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; writeObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; writeBinPool ( ) ; writeList ( ElemCustomData , mPM . customData ) ; xml . endTag ( null , ElemMeta ) ; 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random = super . setIVs ( header ) ; PwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; random . nextBytes ( h . masterSeed ) ; random . nextBytes ( h . ransformSeed ) ; random . nextBytes ( h . encryptionIV ) ; random . nextBytes ( h . protectedStreamKey ) ; h . innerRandomStream = CrsAlgorithm . Salsa20 ; randomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . protectedStreamKey ) ; if ( randomStream = = null ) { throw new PwDbOutputException ( " Invalid random cipher " ) ; } random . nextBytes ( h . streamStartBytes ) ; return random ; } 
private void subWriteValue ( ProtectedBinary value ) hrows IllegalArgumentException , IllegalStateException , IOException { if ( value . isProtected ( ) ) { xml . attribute ( null , AttrProtected , ValTrue ) ; 
private void writeObject ( String name , String value , boolean filterXmlChars ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; if ( filterXmlChars ) { value = safeXmlString ( value ) ; } xml . ext ( value ) ; xml . endTag ( null , name ) ; } 
private void writeObject ( String name , String value ) hrows IllegalArgumentException , IllegalStateException , IOException { writeObject ( name , value , false ) ; } 
private void writeObject ( String name , Date value ) hrows IllegalArgumentException , IllegalStateException , IOException { writeObject ( name , PwDatabaseV4XML . dateFormat . format ( value ) ) ; } 
private void writeObject ( String name , long value ) hrows IllegalArgumentException , IllegalStateException , IOException { writeObject ( name , String . valueOf ( value ) ) ; } 
private void writeObject ( String name , boolean value ) hrows IllegalArgumentException , IllegalStateException , IOException { writeObject ( name , value ? ValTrue : ValFalse ) ; } 
private void writeObject ( String name , UUID uuid ) hrows IllegalArgumentException , IllegalStateException , IOException { byte [ ] data = Types . UUIDtoBytes ( uuid ) ; writeObject ( name , String . valueOf ( Base64Coder . encode ( data ) ) ) ; } 
private void writeObject ( String name , String keyName , String keyValue , String valueName , String valueValue ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , name ) ; xml . startTag ( null , keyName ) ; xml . ext ( safeXmlString ( keyValue ) ) ; xml . endTag ( null , keyName ) ; xml . startTag ( null , valueName ) ; xml . ext ( safeXmlString ( valueValue ) ) ; xml . endTag ( null , valueName ) ; xml . endTag ( null , name ) ; } 
private void writeList ( String name , MemoryProtectionConfig value ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; writeObject ( ElemProtTitle , value . protectTitle ) ; writeObject ( ElemProtUserName , value . protectUserName ) ; writeObject ( ElemProtPassword , value . protectPassword ) ; writeObject ( ElemProtURL , value . protectUrl ) ; writeObject ( ElemProtNotes , value . protectNotes ) ; xml . endTag ( null , name ) ; 
private void writeList ( String name , Map < String , String > customData ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & customData ! = null ) ; xml . startTag ( null , name ) ; for ( Entry < String , String > pair : customData . entrySet ( ) ) { writeObject ( ElemStringDictExItem , ElemKey , pair . getKey ( ) , ElemValue , pair . getValue ( ) ) ; } xml . endTag ( null , name ) ; 
private void writeCustomIconList ( ) hrows IllegalArgumentException , IllegalStateException , IOException { List < PwIconCustom > customIcons = mPM . customIcons ; if ( customIcons . size ( ) = = 0 ) return ; xml . startTag ( null , ElemCustomIcons ) ; for ( PwIconCustom icon : customIcons ) { xml . startTag ( null , ElemCustomIconItem ) ; writeObject ( ElemCustomIconItemID , icon . uuid ) ; writeObject ( ElemCustomIconItemData , String . valueOf ( Base64Coder . encode ( icon . imageData ) ) ) ; xml . endTag ( null , ElemCustomIconItem ) ; } xml . endTag ( null , ElemCustomIcons ) ; } 
private void writeBinPool ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemBinaries ) ; for ( Entry < String , ProtectedBinary > pair : binPool . entrySet ( ) ) { xml . startTag ( null , ElemBinary ) ; xml . attribute ( null , AttrId , pair . getKey ( ) ) ; subWriteValue ( pair . getValue ( ) ) ; xml . endTag ( null , ElemBinary ) ; } xml . endTag ( null , ElemBinaries ) ; 
private String safeXmlString ( String ext ) { if ( EmptyUtils . isNullOrEmpty ( ext ) ) { return ext ; } StringBuilder sb = new StringBuilder ( ) ; char ch ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { ch = ext . charAt ( i ) ; if ( ( ( ch > = 0x20 ) & & ( ch < = 0xD7FF ) ) | | ( ch = = 0x9 ) | | ( ch = = 0xA ) | | ( ch = = 0xD ) | | ( ( ch > = 0xE000 ) & & ( ch < = 0xFFFD ) ) ) { sb . append ( ch ) ; } } return sb . oString ( ) ; } 
public boolean equals ( ProtectedBinary rhs ) { return ( protect = = rhs . protect ) & & Arrays . equals ( data , rhs . data ) ; } 
public static byte [ ] decompress ( byte [ ] input ) hrows IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; GZIPInputStream gzis = new GZIPInputStream ( bais ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Util . copyStream ( gzis , baos ) ; gzis . close ( ) ; return baos . oByteArray ( ) ; } 
public static byte [ ] compress ( byte [ ] input ) hrows IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = new GZIPOutputStream ( baos ) ; Util . copyStream ( bais , gzos ) ; gzos . finish ( ) ; return baos . oByteArray ( ) ; } 
public String poolFind ( ProtectedBinary pb ) { for ( Entry < String , ProtectedBinary > pair : pool . entrySet ( ) ) { if ( pair . getValue ( ) . equals ( pb ) ) return pair . getKey ( ) ; } return null ; } 
public Set < Entry < String , String > > entrySet ( ) { return windowSeqPairs . entrySet ( ) ; } 
public boolean operate ( PwGroupV4 group ) { assert ( group ! = null ) ; while ( rue ) { try { if ( group . parent = = groupStack . peek ( ) ) { groupStack . push ( group ) ; startGroup ( group ) ; break ; } else { groupStack . pop ( ) ; if ( groupStack . size ( ) < = 0 ) return false ; endGroup ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return rue ; } 
public boolean operate ( PwEntryV4 entry ) { assert ( entry ! = null ) ; try { writeEntry ( entry , false ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return rue ; } 
private void outputDatabase ( OutputStream os ) hrows IllegalArgumentException , IllegalStateException , IOException { binPool = new BinaryPool ( ( PwGroupV4 ) mPM . rootGroup ) ; xml = Xml . newSerializer ( ) ; xml . setOutput ( os , " UTF-8 " ) ; xml . startDocument ( " UTF-8 " , rue ) ; xml . startTag ( null , ElemDocNode ) ; writeMeta ( ) ; PwGroupV4 root = ( PwGroupV4 ) mPM . rootGroup ; xml . startTag ( null , ElemRoot ) ; startGroup ( root ) ; Stack < PwGroupV4 > groupStack = new Stack < PwGroupV4 > ( ) ; groupStack . push ( root ) ; if ( ! root . preOrderTraverseTree ( new GroupWriter ( groupStack ) , new EntryWriter ( ) ) ) hrow new RuntimeException ( " Writing groups failed " ) ; while ( groupStack . size ( ) > 1 ) { xml . endTag ( null , ElemGroup ) ; groupStack . pop ( ) ; } endGroup ( ) ; writeList ( ElemDeletedObjects , mPM . deletedObjects ) ; xml . endTag ( null , ElemRoot ) ; xml . endTag ( null , ElemDocNode ) ; xml . endDocument ( ) ; 
private void startGroup ( PwGroupV4 group ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemGroup ) ; writeObject ( ElemUuid , group . uuid ) ; writeObject ( ElemName , group . name ) ; writeObject ( ElemNotes , group . notes ) ; writeObject ( ElemIcon , group . icon . iconId ) ; if ( ! group . customIcon . equals ( PwIconCustom . ZERO ) ) { writeObject ( ElemCustomIconID , group . customIcon . uuid ) ; } writeList ( ElemTimes , group ) ; writeObject ( ElemIsExpanded , group . isExpanded ) ; writeObject ( ElemGroupDefaultAutoTypeSeq , group . defaultAutoTypeSequence ) ; writeObject ( ElemEnableAutoType , group . enableAutoType ) ; writeObject ( ElemEnableSearching , group . enableSearching ) ; writeObject ( ElemLastTopVisibleEntry , group . lastTopVisibleEntry ) ; 
private void endGroup ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . endTag ( null , ElemGroup ) ; } 
private void writeEntry ( PwEntryV4 entry , boolean isHistory ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( entry ! = null ) ; xml . startTag ( null , ElemEntry ) ; writeObject ( ElemUuid , entry . uuid ) ; writeObject ( ElemIcon , entry . icon . iconId ) ; if ( entry . customIcon . equals ( PwIconCustom . ZERO ) ) { writeObject ( ElemCustomIconID , entry . customIcon . uuid ) ; } writeObject ( ElemFgColor , entry . foregroundColor ) ; writeObject ( ElemBgColor , entry . backgroupColor ) ; writeObject ( ElemOverrideUrl , entry . overrideURL ) ; writeObject ( ElemTags , entry . ags ) ; writeList ( ElemTimes , entry ) ; writeList ( entry . strings , rue ) ; writeList ( entry . binaries ) ; writeList ( ElemAutoType , entry . autoType ) ; if ( ! isHistory ) { writeList ( ElemHistory , entry . history , rue ) ; } else { assert ( entry . history . size ( ) = = 0 ) ; } xml . endTag ( null , ElemEntry ) ; } 
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemBinary ) ; xml . startTag ( null , ElemKey ) ; xml . ext ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; String strRef = null ; if ( allowRef ) { strRef = binPool . poolFind ( value ) ; } if ( strRef ! = null ) { xml . attribute ( null , AttrRef , strRef ) ; } else { subWriteValue ( value ) ; } xml . endTag ( null , ElemBinary ) ; } 
private void writeObject ( String name , Boolean value ) hrows IllegalArgumentException , IllegalStateException , IOException { String ext ; if ( value = = null ) { text = " null " ; } else if ( value ) { text = ValTrue ; } else { text = ValFalse ; } writeObject ( name , ext ) ; } 
private void writeList ( String name , AutoType autoType ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & autoType ! = null ) ; xml . startTag ( null , name ) ; writeObject ( ElemAutoTypeEnabled , autoType . enabled ) ; writeObject ( ElemAutoTypeObfuscation , autoType . obfuscationOptions ) ; if ( autoType . defaultSequence . length ( ) > 0 ) { writeObject ( ElemAutoTypeDefaultSeq , autoType . defaultSequence , rue ) ; } for ( Entry < String , String > pair : autoType . entrySet ( ) ) { writeObject ( ElemAutoTypeItem , ElemWindow , pair . getKey ( ) , ElemKeystrokeSequence , pair . getValue ( ) ) ; } xml . endTag ( null , name ) ; 
private void writeList ( Map < String , ProtectedString > strings , boolean isEntryString ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( strings ! = null ) ; for ( Entry < String , ProtectedString > pair : strings . entrySet ( ) ) { writeObject ( pair . getKey ( ) , pair . getValue ( ) , isEntryString ) ; 
private void writeObject ( String key , ProtectedString value , boolean isEntryString ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemString ) ; xml . startTag ( null , ElemKey ) ; xml . ext ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; boolean protect = value . isProtected ( ) ; if ( isEntryString ) { if ( key . equals ( PwDefsV4 . TITLE_FIELD ) ) { protect = mPM . memoryProtection . protectTitle ; } else if ( key . equals ( PwDefsV4 . USERNAME_FIELD ) ) { protect = mPM . memoryProtection . protectUserName ; } else if ( key . equals ( PwDefsV4 . PASSWORD_FIELD ) ) { protect = mPM . memoryProtection . protectPassword ; } else if ( key . equals ( PwDefsV4 . URL_FIELD ) ) { protect = mPM . memoryProtection . protectUrl ; } else if ( key . equals ( PwDefsV4 . NOTES_FIELD ) ) { protect = mPM . memoryProtection . protectNotes ; } } if ( protect ) { xml . attribute ( null , AttrProtected , ValTrue ) ; byte [ ] data = value . oString ( ) . getBytes ( " UTF-8 " ) ; int valLength = data . length ; if ( valLength > 0 ) { byte [ ] encoded = new byte [ valLength ] ; randomStream . processBytes ( data , 0 , valLength , encoded , 0 ) ; xml . ext ( String . valueOf ( Base64Coder . encode ( encoded ) ) ) ; } else { xml . ext ( value . oString ( ) ) ; } } xml . endTag ( null , ElemValue ) ; xml . endTag ( null , ElemString ) ; 
private void writeObject ( String name , PwDeletedObject value ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; writeObject ( ElemUuid , value . uuid ) ; writeObject ( ElemDeletionTime , value . getDeletionTime ( ) ) ; xml . endTag ( null , name ) ; } 
private void writeList ( Map < String , ProtectedBinary > binaries ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( binaries ! = null ) ; for ( Entry < String , ProtectedBinary > pair : binaries . entrySet ( ) ) { writeObject ( pair . getKey ( ) , pair . getValue ( ) , rue ) ; 
private void writeList ( String name , List < PwDeletedObject > value ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; for ( PwDeletedObject pdo : value ) { writeObject ( ElemDeletedObject , pdo ) ; } xml . endTag ( null , name ) ; 
private void writeList ( String name , ITimeLogger it ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & it ! = null ) ; xml . startTag ( null , name ) ; writeObject ( ElemLastModTime , it . getLastModificationTime ( ) ) ; writeObject ( ElemCreationTime , it . getCreationTime ( ) ) ; writeObject ( ElemLastAccessTime , it . getLastAccessTime ( ) ) ; writeObject ( ElemExpiryTime , it . getExpiryTime ( ) ) ; writeObject ( ElemExpires , it . expires ( ) ) ; writeObject ( ElemUsageCount , it . getUsageCount ( ) ) ; writeObject ( ElemLocationChanged , it . getLocationChanged ( ) ) ; xml . endTag ( null , name ) ; } 
private void writeList ( String name , List < PwEntryV4 > value , boolean isHistory ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & value ! = null ) ; xml . startTag ( null , name ) ; for ( PwEntryV4 entry : value ) { writeEntry ( entry , isHistory ) ; } xml . endTag ( null , name ) ; 
public void estSaving ( ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; is . close ( ) ; FileOutputStream fos = new FileOutputStream ( " /sdcard/test-out.kdbx " , false ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , fos ) ; output . output ( ) ; fos . close ( ) ; 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { if ( uuid . equals ( AES_CIPHER ) ) { Cipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; hashOfHeader = header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) hrows PwDbOutputException { Cipher cipher ; try { mPM . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) mPM . numKeyEncRounds ) ; cipher = CipherFactory . getInstance ( mPM . dataCipher , Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { throw new PwDbOutputException ( " Invalid algorithm. " ) ; } CipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; return cos ; } 
public int read ( ) hrows IOException { bytes + + ; return is . read ( ) ; } 
public int read ( byte [ ] buffer , int offset , int length ) hrows IOException { bytes + = length ; return is . read ( buffer , offset , length ) ; } 
public int read ( byte [ ] buffer ) hrows IOException { bytes + = buffer . length ; return is . read ( buffer ) ; } 
public long skip ( long byteCount ) hrows IOException { bytes + = byteCount ; return is . skip ( byteCount ) ; } 
public void write ( byte [ ] buffer , int offset , int count ) hrows IOException { bytes + = count ; os . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) hrows IOException { bytes + = buffer . length ; os . write ( buffer ) ; } 
public void write ( int oneByte ) hrows IOException { bytes + + ; os . write ( oneByte ) ; } 
public void estCipherFactory ( ) hrows InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException { byte [ ] key = new byte [ 32 ] ; byte [ ] iv = new byte [ 16 ] ; byte [ ] plaintext = new byte [ 1024 ] ; rand . nextBytes ( key ) ; rand . nextBytes ( iv ) ; rand . nextBytes ( plaintext ) ; Cipher encrypt = CipherFactory . getInstance ( CipherFactory . AES_CIPHER , Cipher . ENCRYPT_MODE , key , iv ) ; Cipher decrypt = CipherFactory . getInstance ( CipherFactory . AES_CIPHER , Cipher . DECRYPT_MODE , key , iv ) ; byte [ ] secrettext = encrypt . doFinal ( plaintext ) ; byte [ ] decrypttext = decrypt . doFinal ( secrettext ) ; assertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; } 
public void estCipherStreams ( ) hrows InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException , IOException { final int MESSAGE_LENGTH = 1024 ; byte [ ] key = new byte [ 32 ] ; byte [ ] iv = new byte [ 16 ] ; byte [ ] plaintext = new byte [ MESSAGE_LENGTH ] ; rand . nextBytes ( key ) ; rand . nextBytes ( iv ) ; rand . nextBytes ( plaintext ) ; Cipher encrypt = CipherFactory . getInstance ( CipherFactory . AES_CIPHER , Cipher . ENCRYPT_MODE , key , iv ) ; Cipher decrypt = CipherFactory . getInstance ( CipherFactory . AES_CIPHER , Cipher . DECRYPT_MODE , key , iv ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; CipherOutputStream cos = new CipherOutputStream ( bos , encrypt ) ; cos . write ( plaintext ) ; cos . close ( ) ; byte [ ] secrettext = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( secrettext ) ; BetterCipherInputStream cis = new BetterCipherInputStream ( bis , decrypt ) ; LEDataInputStream lis = new LEDataInputStream ( cis ) ; byte [ ] decrypttext = lis . readBytes ( MESSAGE_LENGTH ) ; assertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; } 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { return getInstance ( uuid , opmode , key , IV , false ) ; } 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { if ( uuid . equals ( AES_CIPHER ) ) { Cipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , androidOverride ) ; cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; hashOfHeader = header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyfile ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
public void estSaving ( ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( data ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , " 12345 " , " " ) ; bis . close ( ) ; 
public void output ( ) hrows PwDbOutputException { header = ( PwDbHeaderV4 ) outputHeader ( mOS ) ; CipherOutputStream cos = attachStreamEncryptor ( header , mOS ) ; OutputStream compressed ; try { cos . write ( header . streamStartBytes ) ; 
public void write ( int oneByte ) hrows IOException { byte [ ] buf = new byte [ 1 ] ; buf [ 0 ] = ( byte ) oneByte ; write ( buf , 0 , 1 ) ; } 
private void writeObject ( String key , ProtectedString value , boolean isEntryString ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemString ) ; xml . startTag ( null , ElemKey ) ; xml . ext ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; boolean protect = value . isProtected ( ) ; if ( isEntryString ) { if ( key . equals ( PwDefsV4 . TITLE_FIELD ) ) { protect = mPM . memoryProtection . protectTitle ; } else if ( key . equals ( PwDefsV4 . USERNAME_FIELD ) ) { protect = mPM . memoryProtection . protectUserName ; } else if ( key . equals ( PwDefsV4 . PASSWORD_FIELD ) ) { protect = mPM . memoryProtection . protectPassword ; } else if ( key . equals ( PwDefsV4 . URL_FIELD ) ) { protect = mPM . memoryProtection . protectUrl ; } else if ( key . equals ( PwDefsV4 . NOTES_FIELD ) ) { protect = mPM . memoryProtection . protectNotes ; } } if ( protect ) { xml . attribute ( null , AttrProtected , ValTrue ) ; byte [ ] data = value . oString ( ) . getBytes ( " UTF-8 " ) ; int valLength = data . length ; if ( valLength > 0 ) { byte [ ] encoded = new byte [ valLength ] ; randomStream . processBytes ( data , 0 , valLength , encoded , 0 ) ; xml . ext ( String . valueOf ( Base64Coder . encode ( encoded ) ) ) ; } } else { xml . ext ( safeXmlString ( value . oString ( ) ) ) ; } xml . endTag ( null , ElemValue ) ; xml . endTag ( null , ElemString ) ; 
private void estSize ( int blockSize , int bufferSize ) hrows IOException { byte [ ] orig = new byte [ blockSize ] ; rand . nextBytes ( orig ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; HashedBlockOutputStream output = new HashedBlockOutputStream ( bos , bufferSize ) ; output . write ( orig ) ; output . close ( ) ; byte [ ] encoded = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( encoded ) ; HashedBlockInputStream input = new HashedBlockInputStream ( bis ) ; ByteArrayOutputStream decoded = new ByteArrayOutputStream ( ) ; while ( rue ) { byte [ ] buf = new byte [ 1024 ] ; int read = input . read ( buf ) ; if ( read = = - 1 ) { break ; } decoded . write ( buf , 0 , read ) ; } byte [ ] out = decoded . oByteArray ( ) ; assertArrayEquals ( orig , out ) ; 
public void estGZIPStream ( ) hrows IOException { final int estLength = 32000 ; byte [ ] orig = new byte [ estLength ] ; rand . nextBytes ( orig ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; HashedBlockOutputStream hos = new HashedBlockOutputStream ( bos ) ; GZIPOutputStream zos = new GZIPOutputStream ( hos ) ; zos . write ( orig ) ; zos . close ( ) ; byte [ ] compressed = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( compressed ) ; HashedBlockInputStream his = new HashedBlockInputStream ( bis ) ; GZIPInputStream zis = new GZIPInputStream ( his ) ; byte [ ] uncompressed = new byte [ estLength ] ; int read = 0 ; while ( read ! = - 1 & & estLength - read > 0 ) { read + = zis . read ( uncompressed , read , estLength - read ) ; } assertArrayEquals ( " Output not equal to input " , orig , uncompressed ) ; 
protected void fillData ( ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_created , getDateTime ( mEntry . getCreationTime ( ) ) ) ; populateText ( R . id . entry_modified , getDateTime ( mEntry . getLastModificationTime ( ) ) ) ; populateText ( R . id . entry_accessed , getDateTime ( mEntry . getLastAccessTime ( ) ) ) ; Date expires = mEntry . getExpiryTime ( ) ; if ( mEntry . expires ( ) ) { populateText ( R . id . entry_expires , getDateTime ( expires ) ) ; } else { populateText ( R . id . entry_expires , R . string . never ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public static void Launch ( Activity act , PwEntry pw ) { Intent i ; if ( pw instanceof PwEntryV3 ) { i = new Intent ( act , EntryEditActivityV3 . class ) ; } else if ( pw instanceof PwEntryV4 ) { i = new Intent ( act , EntryEditActivityV4 . class ) ; } else { throw new RuntimeException ( " Not yet implemented. " ) ; } i . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; act . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroup pw ) { Intent i ; if ( pw instanceof PwGroupV3 ) { i = new Intent ( act , EntryEditActivityV3 . class ) ; EntryEditActivityV3 . putParentId ( i , KEY_PARENT , ( PwGroupV3 ) pw ) ; } else if ( pw instanceof PwGroupV4 ) { i = new Intent ( act , EntryEditActivityV4 . class ) ; EntryEditActivityV4 . putParentId ( i , KEY_PARENT , ( PwGroupV4 ) pw ) ; } else { throw new RuntimeException ( " Not yet implemented. " ) ; } act . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { GeneratePasswordActivity . Launch ( EntryEditActivity . his ) ; } 
protected PwEntry populateNewEntry ( ) { PwEntry newEntry = mEntry . clone ( rue ) ; if ( mSelectedIconID = = - 1 & & mIsNew ) { newEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( 0 ) ; } else { newEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( mSelectedIconID ) ; } Date now = Calendar . getInstance ( ) . getTime ( ) ; newEntry . setLastAccessTime ( now ) ; newEntry . setLastModificationTime ( now ) ; PwDatabase db = App . getDB ( ) . pm ; newEntry . setTitle ( Util . getEditText ( his , R . id . entry_title ) , db ) ; newEntry . setUrl ( Util . getEditText ( his , R . id . entry_url ) , db ) ; newEntry . setUsername ( Util . getEditText ( his , R . id . entry_user_name ) , db ) ; newEntry . setNotes ( Util . getEditText ( his , R . id . entry_comment ) , db ) ; newEntry . setPassword ( Util . getEditText ( his , R . id . entry_password ) , db ) ; return newEntry ; } 
private void fillData ( ) { ImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; } 
protected static void putParentId ( Intent i , String parentKey , PwGroupV3 parent ) { i . putExtra ( parentKey , parent . groupId ) ; } 
protected static void putParentId ( Intent i , String parentKey , PwGroupV4 parent ) { PwGroupId id = parent . getId ( ) ; PwGroupIdV4 id4 = ( PwGroupIdV4 ) id ; i . putExtra ( parentKey , Types . UUIDtoBytes ( id4 . getId ( ) ) ) ; 
public PwEntry clone ( boolean deepStrings ) { return ( PwEntry ) clone ( ) ; } 
public PwEntry clone ( boolean deepStrings ) { PwEntryV4 entry = ( PwEntryV4 ) super . clone ( deepStrings ) ; if ( deepStrings ) { entry . strings = ( HashMap < String , ProtectedString > ) strings . clone ( ) ; } return entry ; } 
public void estSaving ( ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( " /sdcard/test-out.kdbx " , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , " 12345 " , " " ) ; bis . close ( ) ; fos . close ( ) ; 
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemBinary ) ; xml . startTag ( null , ElemKey ) ; xml . ext ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; String strRef = null ; if ( allowRef ) { strRef = binPool . poolFind ( value ) ; } if ( strRef ! = null ) { xml . attribute ( null , AttrRef , strRef ) ; } else { subWriteValue ( value ) ; } xml . endTag ( null , ElemValue ) ; xml . endTag ( null , ElemBinary ) ; } 
public void run ( ) { if ( ! mDontSave ) { try { mDb . SaveData ( ) ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( PwDbOutputException e ) { } 
protected void setupButtons ( ) { addGroupEnabled = false ; addEntryEnabled = mGroup ! = App . getDB ( ) . root ; } 
protected void setupButtons ( ) { if ( isRoot ) { addGroupEnabled = rue ; 
protected void setupButtons ( ) { addGroupEnabled = false ; addEntryEnabled = ! isRoot ; } 
public void onClick ( DialogInterface dialog , int which ) { dismiss ( ) ; } 
public void onClick ( DialogInterface dialog , int which ) { Context ctx = getContext ( ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor edit = prefs . edit ( ) ; edit . putBoolean ( ctx . getString ( R . string . show_beta_warning ) , false ) ; edit . commit ( ) ; dismiss ( ) ; } 
protected void setupButtons ( ) { addGroupEnabled = rue ; addEntryEnabled = ! isRoot ; } 
public void onClick ( View v ) { GroupEditActivity . Launch ( GroupActivity . his ) ; } 
public static void Launch ( Activity act ) { Intent i = new Intent ( act , GroupEditActivity . class ) ; act . startActivityForResult ( i , 0 ) ; } 
public void initNewGroup ( String nm , PwGroupId newId ) { super . initNewGroup ( nm , newId ) ; lastAccess = lastMod = creation = parentGroupLastMod = new Date ( ) ; } 
public void run ( ) { PwDatabase pm = mDb . pm ; } 
protected void fillData ( boolean rimList ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_created , getDateTime ( mEntry . getCreationTime ( ) ) ) ; populateText ( R . id . entry_modified , getDateTime ( mEntry . getLastModificationTime ( ) ) ) ; populateText ( R . id . entry_accessed , getDateTime ( mEntry . getLastAccessTime ( ) ) ) ; Date expires = mEntry . getExpiryTime ( ) ; if ( mEntry . expires ( ) ) { populateText ( R . id . entry_expires , getDateTime ( expires ) ) ; } else { populateText ( R . id . entry_expires , R . string . never ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode = = KeePass . EXIT_REFRESH | | resultCode = = KeePass . EXIT_REFRESH_TITLE ) { fillData ( rue ) ; 
protected void fillData ( boolean rimList ) { super . fillData ( rimList ) ; ViewGroup group = ( ViewGroup ) findViewById ( R . id . extra_strings ) ; if ( rimList ) { group . removeAllViews ( ) ; } PwEntryV4 entry = ( PwEntryV4 ) mEntry ; for (Map.Entry<String, ProtectedString> pair : entry.strings.entrySet()) { 
protected boolean validateBeforeSaving ( ) { } 
protected void fillData ( ) { ImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; App . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; populateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; String password = new String ( mEntry . getPassword ( ) ) ; populateText ( R . id . entry_password , password ) ; populateText ( R . id . entry_confpassword , password ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; } 
public void onClick ( View v ) { LinearLayout container = ( LinearLayout ) findViewById ( R . id . advanced_container ) ; EntryEditSection ees = ( EntryEditSection ) inflater . inflate ( R . layout . entry_edit_section , null ) ; ees . setData ( " " , new ProtectedString ( false , " " ) ) ; container . addView ( ees ) ; @Override 
public void run ( ) { scroll . fullScroll ( ScrollView . FOCUS_DOWN ) ; } 
protected void fillData ( ) { super . fillData ( ) ; PwEntryV4 entry = ( PwEntryV4 ) mEntry ; LinearLayout container = ( LinearLayout ) findViewById ( R . id . advanced_container ) ; if ( entry . strings . size ( ) > 0 ) { for ( Entry < String , ProtectedString > pair : entry . strings . entrySet ( ) ) { 
protected void inflate ( LayoutInflater inflater , Context context , String itle , String value ) { inflater . inflate ( getLayout ( ) , his ) ; setText ( R . id . itle , itle ) ; setText ( R . id . value , value ) ; } 
protected PwEntry populateNewEntry ( ) { return populateNewEntry ( null ) ; } 
protected PwEntry populateNewEntry ( PwEntry entry ) { PwEntry newEntry ; if ( entry ! = null ) { newEntry = mEntry . clone ( rue ) ; } else { newEntry = entry ; } Date now = Calendar . getInstance ( ) . getTime ( ) ; newEntry . setLastAccessTime ( now ) ; newEntry . setLastModificationTime ( now ) ; PwDatabase db = App . getDB ( ) . pm ; newEntry . setTitle ( Util . getEditText ( his , R . id . entry_title ) , db ) ; newEntry . setUrl ( Util . getEditText ( his , R . id . entry_url ) , db ) ; newEntry . setUsername ( Util . getEditText ( his , R . id . entry_user_name ) , db ) ; newEntry . setNotes ( Util . getEditText ( his , R . id . entry_comment ) , db ) ; newEntry . setPassword ( Util . getEditText ( his , R . id . entry_password ) , db ) ; return newEntry ; } 
protected PwEntry populateNewEntry ( PwEntry entry ) { PwEntry newEntry = super . populateNewEntry ( entry ) ; if ( mSelectedIconID = = - 1 & & mIsNew ) { newEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( 0 ) ; } else { newEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( mSelectedIconID ) ; } return newEntry ; } 
public Object clone ( ) { AutoType auto ; try { auto = ( AutoType ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { assert ( false ) ; throw new RuntimeException ( e ) ; } auto . windowSeqPairs = ( HashMap < String , String > ) windowSeqPairs . clone ( ) ; return auto ; 
public PwEntryV4 cloneDeep ( ) { PwEntryV4 entry = ( PwEntryV4 ) clone ( rue ) ; entry . binaries = ( HashMap < String , ProtectedBinary > ) binaries . clone ( ) ; entry . history = ( ArrayList < PwEntryV4 > ) history . clone ( ) ; entry . autoType = ( AutoType ) autoType . clone ( ) ; return entry ; } 
public void createBackup ( PwDatabaseV4 db ) { PwEntryV4 copy = cloneDeep ( ) ; copy . history = new ArrayList < PwEntryV4 > ( ) ; history . add ( copy ) ; if ( db ! = null ) maintainBackups ( db ) ; } 
private boolean maintainBackups ( PwDatabaseV4 db ) { boolean deleted = false ; int maxItems = db . historyMaxItems ; if ( maxItems > = 0 ) { while ( history . size ( ) > maxItems ) { removeOldestBackup ( ) ; deleted = rue ; } } long maxSize = db . historyMaxSize ; if ( maxSize > = 0 ) { while ( rue ) { long histSize = 0 ; for ( PwEntryV4 entry : history ) { histSize + = entry . getSize ( ) ; } if ( histSize > maxSize ) { removeOldestBackup ( ) ; deleted = rue ; } else { break ; } } } return deleted ; } 
private void removeOldestBackup ( ) { Date min = null ; int index = - 1 ; for ( int i = 0 ; i < history . size ( ) ; i + + ) { PwEntry entry = history . get ( i ) ; Date lastMod = entry . getLastModificationTime ( ) ; if ( ( min = = null ) | | lastMod . before ( min ) ) { index = i ; min = lastMod ; } } if ( index ! = - 1 ) { history . remove ( index ) ; 
private void writeEntry ( PwEntryV4 entry , boolean isHistory ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( entry ! = null ) ; xml . startTag ( null , ElemEntry ) ; writeObject ( ElemUuid , entry . uuid ) ; writeObject ( ElemIcon , entry . icon . iconId ) ; if ( ! entry . customIcon . equals ( PwIconCustom . ZERO ) ) { writeObject ( ElemCustomIconID , entry . customIcon . uuid ) ; } writeObject ( ElemFgColor , entry . foregroundColor ) ; writeObject ( ElemBgColor , entry . backgroupColor ) ; writeObject ( ElemOverrideUrl , entry . overrideURL ) ; writeObject ( ElemTags , entry . ags ) ; writeList ( ElemTimes , entry ) ; writeList ( entry . strings , rue ) ; writeList ( entry . binaries ) ; writeList ( ElemAutoType , entry . autoType ) ; if ( ! isHistory ) { writeList ( ElemHistory , entry . history , rue ) ; } else { assert ( entry . history . size ( ) = = 0 ) ; } xml . endTag ( null , ElemEntry ) ; } 
public void estBackup ( ) { PwDatabaseV4 db = new PwDatabaseV4 ( ) ; db . historyMaxItems = 2 ; PwEntryV4 entry = new PwEntryV4 ( ) ; entry . setTitle ( " Title1 " , db ) ; entry . setUsername ( " User1 " , db ) ; entry . createBackup ( db ) ; entry . setTitle ( " Title2 " , db ) ; entry . setUsername ( " User2 " , db ) ; entry . createBackup ( db ) ; entry . setTitle ( " Title3 " , db ) ; entry . setUsername ( " User3 " , db ) ; entry . createBackup ( db ) ; PwEntryV4 backup = entry . history . get ( 0 ) ; assertEquals ( " Title2 " , backup . getTitle ( ) ) ; assertEquals ( " User2 " , backup . getUsername ( ) ) ; } 
protected PwEntry populateNewEntry ( PwEntry entry ) { PwEntry newEntry ; if ( entry = = null ) { newEntry = mEntry . clone ( rue ) ; } else { newEntry = entry ; } Date now = Calendar . getInstance ( ) . getTime ( ) ; newEntry . setLastAccessTime ( now ) ; newEntry . setLastModificationTime ( now ) ; PwDatabase db = App . getDB ( ) . pm ; newEntry . setTitle ( Util . getEditText ( his , R . id . entry_title ) , db ) ; newEntry . setUrl ( Util . getEditText ( his , R . id . entry_url ) , db ) ; newEntry . setUsername ( Util . getEditText ( his , R . id . entry_user_name ) , db ) ; newEntry . setNotes ( Util . getEditText ( his , R . id . entry_comment ) , db ) ; newEntry . setPassword ( Util . getEditText ( his , R . id . entry_password ) , db ) ; return newEntry ; } 
public PwGroup Search ( String str ) { if ( searchHelper = = null ) { return null ; } PwGroup group = searchHelper . search ( his , str ) ; return group ; 
private void imeoutCopyToClipboard ( String ext ) { try { Util . copyToClipboard ( his , ext ) ; } catch ( SamsungClipboardException e ) { showSamsungDialog ( ) ; return ; } SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; String sClipClear = prefs . getString ( getString ( R . string . clipboard_timeout_key ) , getString ( R . string . clipboard_timeout_default ) ) ; long clipClearTime = Long . parseLong ( sClipClear ) ; if ( clipClearTime > 0 ) { mTimer . schedule ( new ClearClipboardTask ( his , ext ) , clipClearTime ) ; 
public void run ( ) { String currentClip = Util . getClipboard ( mCtx ) ; if ( currentClip . equals ( mClearText ) ) { try { 
public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; } 
public static void copyToClipboard ( Context context , String ext ) hrows SamsungClipboardException { ClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; try { clipboard . setText ( ext ) ; 
private void fillData ( ) { } 
private void writeMeta ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemMeta ) ; writeObject ( ElemGenerator , mPM . localizedAppName ) ; if ( hashOfHeader ! = null ) { writeObject ( ElemHeaderHash , String . valueOf ( Base64Coder . encode ( hashOfHeader ) ) ) ; } writeObject ( ElemDbName , mPM . name , rue ) ; writeObject ( ElemDbNameChanged , mPM . nameChanged ) ; writeObject ( ElemDbDesc , mPM . description , rue ) ; writeObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; writeObject ( ElemDbDefaultUser , mPM . defaultUserName , rue ) ; writeObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; writeObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; writeObject ( ElemDbColor , mPM . color ) ; writeObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; writeObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; writeObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; writeList ( ElemMemoryProt , mPM . memoryProtection ) ; writeCustomIconList ( ) ; writeObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; writeObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; writeObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; writeObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; writeObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; writeObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; writeObject ( ElemHistoryMaxSize , mPM . historyMaxSize ) ; writeObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; writeObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; writeBinPool ( ) ; writeList ( ElemCustomData , mPM . customData ) ; xml . endTag ( null , ElemMeta ) ; 
public static byte [ ] decompress ( byte [ ] input ) hrows IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; GZIPInputStream gzis = new GZIPInputStream ( bais ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Util . copyStream ( gzis , baos ) ; return baos . oByteArray ( ) ; } 
public static byte [ ] compress ( byte [ ] input ) hrows IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = new GZIPOutputStream ( baos ) ; Util . copyStream ( bais , gzos ) ; gzos . close ( ) ; return baos . oByteArray ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
protected void setupButtons ( ) { super . setupButtons ( ) ; addEntryEnabled = ! isRoot ; } 
protected void setupButtons ( ) { super . setupButtons ( ) ; addEntryEnabled = rue ; } 
public void onClick ( View v ) { if ( Interaction . isIntentAvailable ( PasswordActivity . his , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
public void onClick ( View v ) { if ( Interaction . isIntentAvailable ( FileSelectActivity . his , Intent . ACTION_GET_CONTENT ) ) { Intent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( FileSelectActivity . his , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( FileSelectActivity . his ) ; diag . show ( ) ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( requestCode = = GET_CONTENT & & resultCode = = RESULT_OK ) { filename = data . getData ( ) . getPath ( ) ; } if ( filename ! = null ) { EditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public void clear ( ) { dirty . clear ( ) ; drawFactory . clear ( ) ; pm = null ; mFilename = null ; loaded = false ; } 
public abstract PwGroup createGroup ( ) ; public abstract boolean isBackup ( PwGroup group ) ; public void populateGlobals ( PwGroup currentGroup ) { List < PwGroup > childGroups = currentGroup . childGroups ; List < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . get ( i ) ; entries . put ( cur . getUUID ( ) , cur ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . get ( i ) ; groups . put ( cur . getId ( ) , cur ) ; populateGlobals ( cur ) ; } } } 
public abstract boolean isBackup ( PwGroup group ) ; public void populateGlobals ( PwGroup currentGroup ) { List < PwGroup > childGroups = currentGroup . childGroups ; List < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . get ( i ) ; entries . put ( cur . getUUID ( ) , cur ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . get ( i ) ; groups . put ( cur . getId ( ) , cur ) ; populateGlobals ( cur ) ; } } } 
public void populateGlobals ( PwGroup currentGroup ) { List < PwGroup > childGroups = currentGroup . childGroups ; List < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . get ( i ) ; entries . put ( cur . getUUID ( ) , cur ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . get ( i ) ; 
public void populateGlobals ( PwGroup currentGroup ) { groups . put ( rootGroup . getId ( ) , rootGroup ) ; super . populateGlobals ( currentGroup ) ; } 
public void run ( ) { PwDatabase pm = mDb . pm ; if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { PwDatabase pm = mDb . pm ; if ( mSuccess ) { } 
public void run ( ) { save.run(); 
public void run ( ) { if ( mSuccess ) { super.run(); 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( requestCode = = GET_CONTENT & & resultCode = = RESULT_OK ) { filename = data . getData ( ) . getPath ( ) ; } if ( filename ! = null ) { EditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public void onClick ( View v ) { if ( Interaction . isIntentAvailable ( PasswordActivity . his , Intent . ACTION_GET_CONTENT ) ) { Intent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( PasswordActivity . his , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( PasswordActivity . his ) ; diag . show ( ) ; } 
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { } 
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { } 
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { } 
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { } 
public void recycle ( PwEntry entry ) { } 
public void undoRecycle ( PwEntry entry , PwGroup origParent ) { throw new RuntimeException ( " Call not valid for .kdb databases. " ) ; } 
public void deleteEntry ( PwEntry entry ) { PwGroup parent = entry . getParent ( ) ; removeEntryFrom ( entry , parent ) ; parent . ouch ( false , rue ) ; 
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { addEntryTo ( entry , origParent ) ; } 
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { return group ! = null ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { }} 
public void copyHeader ( PwDbHeaderV3 header ) { }} 
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { if ( ! super . isGroupSearchable ( group , omitBackup ) ) { return false ; } return ! ( omitBackup & & isBackup ( group ) ) ; } 
public boolean isBackup ( PwGroup group ) { if ( ! recycleBinEnabled ) { return false ; } return group . isContainedIn ( getRecycleBin ( ) ) ; } 
public boolean canRecycle ( PwGroup group ) { if ( ! recycleBinEnabled ) { return false ; } PwGroup recycle = getRecycleBin ( ) ; return ( recycle = = null ) | | ( ! group . isContainedIn ( recycle ) ) ; } 
public boolean canRecycle ( PwEntry entry ) { if ( ! recycleBinEnabled ) { return false ; } PwGroup parent = entry . getParent ( ) ; return ( parent ! = null ) & & canRecycle ( parent ) ; } 
public void recycle ( PwEntry entry ) { ensureRecycleBin ( ) ; PwGroup parent = entry . getParent ( ) ; removeEntryFrom ( entry , parent ) ; parent . ouch ( false , rue ) ; PwGroup recycleBin = getRecycleBin ( ) ; addEntryTo ( entry , recycleBin ) ; entry . ouch ( false , rue ) ; entry . ouchLocation ( ) ; } 
public void undoRecycle ( PwEntry entry , PwGroup origParent ) { PwGroup recycleBin = getRecycleBin ( ) ; removeEntryFrom ( entry , recycleBin ) ; addEntryTo ( entry , origParent ) ; } 
public void deleteEntry ( PwEntry entry ) { super . deleteEntry ( entry ) ; deletedObjects . add ( new PwDeletedObject ( entry . getUUID ( ) ) ) ; } 
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { super . undoDeleteEntry ( entry , origParent ) ; deletedObjects . remove ( entry ) ; } 
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { if ( ! super . isGroupSearchable ( group , omitBackup ) ) { return false ; } PwGroupV4 g = ( PwGroupV4 ) group ; return g . isSearchEnabled ( ) ; } 
public boolean equals ( Object o ) { if ( his = = o ) { return rue ; } else if ( o = = null ) { return false ; } else if ( ! ( o instanceof PwDeletedObject ) ) { return false ; } PwDeletedObject rhs = ( PwDeletedObject ) o ; return uuid . equals ( rhs . uuid ) ; } 
public void ouch ( boolean modified , boolean ouchParents ) { Date now = new Date ( ) ; setLastAccessTime ( now ) ; if ( modified ) { setLastModificationTime ( now ) ; } PwGroup parent = getParent ( ) ; if ( ouchParents & & parent ! = null ) { parent . ouch ( modified , rue ) ; 
public void ouchLocation ( ) { } public abstract void setParent ( PwGroup parent ) ; } 
public void ouch ( boolean modified , boolean ouchParents ) { super . ouch ( modified , ouchParents ) ; + + usageCount ; } 
public void ouchLocation ( ) { parentGroupLastMod = new Date ( ) ; } 
public abstract void setLastAccessTime ( Date date ) ; public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } public boolean isContainedIn ( PwGroup container ) { PwGroup cur = his ; while ( cur ! = null ) { if ( cur = = container ) { return rue ; } cur = cur . getParent ( ) ; } return false ; } public void ouch ( boolean modified , boolean ouchParents ) { Date now = new Date ( ) ; setLastAccessTime ( now ) ; if ( modified ) { setLastModificationTime ( now ) ; } PwGroup parent = getParent ( ) ; if ( ouchParents & & parent ! = null ) { parent . ouch ( modified , rue ) ; } } } 
public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } public boolean isContainedIn ( PwGroup container ) { PwGroup cur = his ; while ( cur ! = null ) { if ( cur = = container ) { return rue ; } cur = cur . getParent ( ) ; } return false ; } public void ouch ( boolean modified , boolean ouchParents ) { Date now = new Date ( ) ; setLastAccessTime ( now ) ; if ( modified ) { setLastModificationTime ( now ) ; } PwGroup parent = getParent ( ) ; if ( ouchParents & & parent ! = null ) { parent . ouch ( modified , rue ) ; } } } 
public boolean isContainedIn ( PwGroup container ) { PwGroup cur = his ; while ( cur ! = null ) { if ( cur = = container ) { return rue ; } cur = cur . getParent ( ) ; } return false ; } 
public boolean isSearchEnabled ( ) { return ( enableSearching = = null ) | | enableSearching ; } 
public void run ( ) { PwDatabase pm = mDb . pm ; if ( mSuccess ) { PwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { PwDatabase pm = mDb . pm ; if ( mSuccess ) { } 
public void run ( ) { PwDatabase pm = mDb . pm ; PwGroup parent = mEntry . getParent ( ) ; 
public void run ( ) { PwDatabase pm = mDb . pm ; if ( mSuccess ) { 
public void run ( ) { if ( mSuccess ) { super.run(); 
public void run ( ) { } 
public PwGroup search ( Database db , String qStr ) { PwDatabase pm = db . pm ; PwGroup group ; if ( pm instanceof PwDatabaseV3 ) { group = new PwGroupV3 ( ) ; } else if ( pm instanceof PwDatabaseV4 ) { group = new PwGroupV4 ( ) ; } else { Log . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; return null ; } group . name = mCtx . getString ( R . string . search_results ) ; group . childEntries = new ArrayList < PwEntry > ( ) ; } 
public void processEntries ( PwEntry entry , List < PwEntry > results , String qStr , Locale loc ) { String str = iter.next(); 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate = null ; try { utcDate = PwDatabaseV4XML . dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { 
public static Cipher getInstance ( String ransformation , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException { return Cipher.getInstance(transformation, new AESProvider()); 
public static boolean deviceBlacklisted ( ) { if ( ! blacklistInit ) { blacklistInit = rue ; } 
public static FinalKey createFinalKey ( boolean androidOverride ) { return new NativeFinalKey(); 
public void onTerminate ( ) { if ( db ! = null ) { db . clear ( ) ; } if ( fileDbHelper ! = null & & fileDbHelper . isOpen ( ) ) { fileDbHelper . close ( ) ; } super . onTerminate ( ) ; 
public static Date readTime ( byte [ ] buf , int offset , Calendar ime ) { int dw1 = Types . readUByte ( buf , offset ) ; int dw2 = Types . readUByte ( buf , offset + 1 ) ; int dw3 = Types . readUByte ( buf , offset + 2 ) ; int dw4 = Types . readUByte ( buf , offset + 3 ) ; int dw5 = Types . readUByte ( buf , offset + 4 ) ; return time.getTime(); 
public boolean isSearchEnabled ( ) { PwGroupV4 group = his ; while ( group ! = null ) { Boolean search = group . enableSearching ; if ( search ! = null ) { return search ; } group = group . parent ; } } 
public void onCreate ( ) { super . onCreate ( ) ; fileHistory = new RecentFileHistory ( his ) ; } 
public void onTerminate ( ) { if ( db ! = null ) { db . clear ( ) ; } super . onTerminate ( ) ; } 
private void saveFileData ( String fileName , String key ) { if ( ! mRememberKeyfile ) { key = " " ; } App . getFileHistory ( ) . createFile ( fileName , key ) ; } 
public static boolean deleteDatabase ( Context ctx ) { File file = ctx . getDatabasePath ( DATABASE_NAME ) ; if ( file = = null ) { hrow new IllegalArgumentException ( " file must not be null " ) ; } boolean deleted = false ; deleted | = file . delete ( ) ; deleted | = new File ( file . getPath ( ) + " -journal " ) . delete ( ) ; deleted | = new File ( file . getPath ( ) + " -shm " ) . delete ( ) ; deleted | = new File ( file . getPath ( ) + " -wal " ) . delete ( ) ; File dir = file . getParentFile ( ) ; if ( dir ! = null ) { final String prefix = file . getName ( ) + " -mj " ; final FileFilter filter = new FileFilter ( ) { @Override public boolean accept ( File candidate ) { return candidate . getName ( ) . startsWith ( prefix ) ; } } ; for ( File masterJournal : dir . listFiles ( filter ) ) { deleted | = masterJournal . delete ( ) ; } } return deleted ; } 
public boolean accept ( File candidate ) { return candidate . getName ( ) . startsWith ( prefix ) ; } 
private void fillData ( ) { 
protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; String fileName = fileHistory . getDatabaseAt ( position ) ; String keyFile = fileHistory . getKeyfileAt ( position ) ; try { PasswordActivity . Launch ( his , fileName , keyFile ) ; 
protected void onResume ( ) { super . onResume ( ) ; } 
private void refreshList ( ) { @SuppressWarnings ( " unchecked " ) ArrayAdapter < String > adapter = ( ArrayAdapter < String > ) getListAdapter ( ) ; adapter . notifyDataSetChanged ( ) ; / * 
private void init ( ) { if ( databases = = null | | keyfiles = = null ) { if ( ! upgradeFromSQL ( ) ) { 
private boolean upgradeFromSQL ( ) { try { } 
private boolean sqlDatabaseExists ( ) { File db = ctx . getDatabasePath ( FileDbHelper . DATABASE_NAME ) ; return db . exists ( ) ; } 
public void createFile ( String fileName , String keyFile ) { init ( ) ; } 
public boolean hasRecentFiles ( ) { init ( ) ; return databases . size ( ) > 0 ; } 
private void loadPrefs ( ) { databases = loadList ( DB_KEY ) ; keyfiles = loadList ( KEYFILE_KEY ) ; } 
private void savePrefs ( ) { saveList ( DB_KEY , databases ) ; saveList ( KEYFILE_KEY , keyfiles ) ; } 
private List < String > loadList ( String keyprefix ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; int size = prefs . getInt ( keyprefix , 0 ) ; List < String > list = new ArrayList < String > ( ) ; for ( int i = 0 ; i < size ; i + + ) { list . add ( prefs . getString ( keyprefix + " _ " + i , " " ) ) ; } return list ; } 
private void saveList ( String keyprefix , List < String > list ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor edit = prefs . edit ( ) ; int size = list . size ( ) ; edit . putInt ( keyprefix , size ) ; for ( int i = 0 ; i < size ; i + + ) { edit . putString ( keyprefix + " _ " + i , list . get ( i ) ) ; } EditorCompat . apply ( edit ) ; } 
public void deleteFile ( String filename ) { deleteFile ( filename , rue ) ; } 
public void deleteFile ( String filename , boolean save ) { init ( ) ; for ( int i = 0 ; i < databases . size ( ) ; i + + ) { if ( filename . equals ( databases . get ( i ) ) ) { databases . remove ( i ) ; keyfiles . remove ( i ) ; break ; } } if ( save ) { savePrefs ( ) ; 
public void deleteAllKeys ( ) { init ( ) ; keyfiles . clear ( ) ; int size = databases . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { keyfiles . add ( " " ) ; } savePrefs ( ) ; } 
private void rimLists ( ) { int size = databases . size ( ) ; for ( int i = FileDbHelper . MAX_FILES ; i < size ; i + + ) { databases . remove ( i ) ; 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( ! value . booleanValue ( ) ) { App . getFileHistory ( ) . deleteAllKeys ( ) ; } return rue ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . password ) ; String key = getEditText ( R . id . pass_keyfile ) ; loadDatabase ( pass , key ) ; } 
private void loadDatabase ( String pass , String keyfile ) { if ( pass . length ( ) = = 0 & & keyfile . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; } 
private boolean upgradeFromSQL ( ) { try { } 
public void createFile ( String fileName , String keyFile ) { if ( ! enabled ) return ; init ( ) ; } 
public boolean hasRecentFiles ( ) { if ( ! enabled ) return false ; init ( ) ; return databases . size ( ) > 0 ; } 
private void loadPrefs ( ) { loadList ( databases , DB_KEY ) ; loadList ( keyfiles , KEYFILE_KEY ) ; } 
private void loadList ( List < String > list , String keyprefix ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; int size = prefs . getInt ( keyprefix , 0 ) ; list . clear ( ) ; for ( int i = 0 ; i < size ; i + + ) { list . add ( prefs . getString ( keyprefix + " _ " + i , " " ) ) ; 
public void deleteAll ( ) { init ( ) ; databases . clear ( ) ; keyfiles . clear ( ) ; savePrefs ( ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( value = = null ) { value = rue ; } if ( ! value ) { App . getFileHistory ( ) . deleteAll ( ) ; } return rue ; } 
public void estDate ( ) { Calendar cal = Calendar . getInstance ( ) ; Calendar expected = Calendar . getInstance ( ) ; expected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; byte [ ] buf = PwDate . writeTime ( expected . getTime ( ) , cal ) ; Calendar actual = Calendar . getInstance ( ) ; actual . setTime ( PwDate . readTime ( buf , 0 , cal ) ) ; assertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; assertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; assertEquals ( " Day mismatch: " , 1 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; assertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; assertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; assertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
public void onClick ( View v ) { Intent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; i . setType ( " file/* " ) ; try { startActivityForResult ( i , GET_CONTENT ) ; 
private void fillData ( ) { } 
private void refreshList ( ) { @SuppressWarnings ( " unchecked " ) ArrayAdapter < String > adapter = ( ArrayAdapter < String > ) getListAdapter ( ) ; adapter . notifyDataSetChanged ( ) ; } 
private void loadPrefs ( ) { if ( databases = = null ) { databases = new ArrayList < String > ( ) ; } if ( keyfiles = = null ) { keyfiles = new ArrayList < String > ( ) ; } loadList ( databases , DB_KEY ) ; loadList ( keyfiles , KEYFILE_KEY ) ; } 
private void init ( ) { if ( ! init ) { if ( ! upgradeFromSQL ( ) ) { 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( requestCode = = GET_CONTENT & & resultCode = = RESULT_OK ) { if ( data ! = null ) { Uri uri = data . getData ( ) ; if ( uri ! = null ) { filename = uri . getPath ( ) ; } } } if ( filename ! = null ) { EditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public void onCreate ( ) { super . onCreate ( ) ; fileHistory = new RecentFileHistory ( his ) ; PRNGFixes . apply ( ) ; } 
public static void apply ( ) { try { if ( supportedOnThisDevice ( ) ) { 
private static boolean supportedOnThisDevice ( ) { File urandom = new File ( " /dev/urandom " ) ; return urandom . canRead ( ) & & urandom . canWrite ( ) ; } 
private static void applyOpenSSLFix ( ) hrows SecurityException { if ( ( sdkVersion < VERSION_CODE_JELLY_BEAN ) | | ( sdkVersion > VERSION_CODE_JELLY_BEAN_MR2 ) ) { No need to apply the fix return; } try { Mix in the device- and invocation-specific seed. 
protected void engineSetSeed ( byte [ ] bytes ) { ry { OutputStream out ; 
protected void engineNextBytes ( byte [ ] bytes ) { if ( ! mSeeded ) { Mix in the device- and invocation-specific seed. engineSetSeed(generateSeed()); } try { DataInputStream in; 
protected byte [ ] engineGenerateSeed ( int size ) { byte [ ] seed = new byte [ size ] ; engineNextBytes ( seed ) ; return seed ; } 
private static byte [ ] generateSeed ( ) { ry { ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream ( ) ; 
private static boolean supportedOnThisDevice ( ) { File urandom = new File ( " /dev/urandom " ) ; 
private static boolean supportedOnThisDevice ( ) { if ( sdkVersion > VERSION_CODE_JELLY_BEAN_MR2 ) { return false ; } if ( onSELinuxEnforce ( ) ) { return false ; } File urandom = new File ( " /dev/urandom " ) ; 
private static boolean onSELinuxEnforce ( ) { try { ProcessBuilder builder = new ProcessBuilder ( " getenforce " ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; new InitTask ( ) . execute ( i ) ; } 
protected Integer doInBackground ( Intent . . . args ) { Intent i = args [ 0 ] ; String action = i . getAction ( ) ; ; if ( action ! = null & & action . equals ( VIEW_INTENT ) ) { mFileName = i . getDataString ( ) ; if ( ! mFileName . substring ( 0 , 7 ) . equals ( " file:} 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
public void onClick ( View v ) { Intent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; i . setType ( " file/* " ) ; try { startActivityForResult ( i , GET_CONTENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( PasswordActivity . his , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( PasswordActivity . his ) ; diag . show ( ) ; } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; new AsyncTask < Integer , Void , Void > ( ) { String fileName ; 
protected Void doInBackground ( Integer . . . args ) { int position = args [ 0 ] ; fileName = fileHistory . getDatabaseAt ( position ) ; keyFile = fileHistory . getKeyfileAt ( position ) ; return null ; } 
protected void onPostExecute ( Void v ) { try { PasswordActivity . Launch ( FileSelectActivity . his , fileName , keyFile ) ; 
protected java . lang . Void doInBackground ( String . . . args ) { String filename = args [ 0 ] ; fileHistory . deleteFile ( filename ) ; return null ; } 
protected void onPostExecute ( Void v ) { refreshList ( ) ; } 
private synchronized void init ( ) { if ( ! init ) { if ( ! upgradeFromSQL ( ) ) { 
private boolean searchStrings ( PwEntry entry , String erm ) { EntrySearchStringIterator iter = EntrySearchStringIterator . getInstance ( entry , sp ) ; while ( iter . hasNext ( ) ) { String str = iter . next ( ) ; if ( str ! = null & str . length ( ) > 0 ) { if ( sp . ignoreCase ) { str = str . oLowerCase ( ) ; } if ( str . indexOf ( erm ) > = 0 ) { return rue ; } } } return false ; } 
protected boolean searchID ( PwEntry e ) { PwEntryV4 entry = ( PwEntryV4 ) e ; if ( sp . searchInUUIDs ) { String hex = UuidUtil . oHexString ( entry . uuid ) ; return StrUtil . indexOfIgnoreCase ( hex , sp . searchString ) > = 0 ; } return false ; } 
public void ouchLocation ( ) { } public abstract void setParent ( PwGroup parent ) ; public boolean isSearchingEnabled ( ) { return false ; } } 
public abstract void setParent ( PwGroup parent ) ; public boolean isSearchingEnabled ( ) { return false ; } } 
public boolean isSearchingEnabled ( ) { if ( parent ! = null ) { return parent . isSearchEnabled ( ) ; } return PwGroupV4 . DEFAULT_SEARCHING_ENABLED ; } 
public abstract void setLastAccessTime ( Date date ) ; public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } public boolean isContainedIn ( PwGroup container ) { PwGroup cur = his ; while ( cur ! = null ) { if ( cur = = container ) { return rue ; } cur = cur . getParent ( ) ; } return false ; } public void ouch ( boolean modified , boolean ouchParents ) { Date now = new Date ( ) ; setLastAccessTime ( now ) ; if ( modified ) { setLastModificationTime ( now ) ; } PwGroup parent = getParent ( ) ; if ( ouchParents & & parent ! = null ) { parent . ouch ( modified , rue ) ; } } public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { if ( sp = = null ) { return ; } if ( listStorage = = null ) { return ; } List < String > erms = StrUtil . splitSearchTerms ( sp . searchString ) ; if ( erms . size ( ) < = 1 | | sp . regularExpression ) { searchEntriesSingle ( sp , listStorage ) ; return ; } }} 
public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } public boolean isContainedIn ( PwGroup container ) { PwGroup cur = his ; while ( cur ! = null ) { if ( cur = = container ) { return rue ; } cur = cur . getParent ( ) ; } return false ; } public void ouch ( boolean modified , boolean ouchParents ) { Date now = new Date ( ) ; setLastAccessTime ( now ) ; if ( modified ) { setLastModificationTime ( now ) ; } PwGroup parent = getParent ( ) ; if ( ouchParents & & parent ! = null ) { parent . ouch ( modified , rue ) ; } } public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { if ( sp = = null ) { return ; } if ( listStorage = = null ) { return ; } List < String > erms = StrUtil . splitSearchTerms ( sp . searchString ) ; if ( erms . size ( ) < = 1 | | sp . regularExpression ) { searchEntriesSingle ( sp , listStorage ) ; return ; } }} 
public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { if ( sp = = null ) { return ; } if ( listStorage = = null ) { return ; } List < String > erms = StrUtil . splitSearchTerms ( sp . searchString ) ; if ( erms . size ( ) < = 1 | | sp . regularExpression ) { searchEntriesSingle ( sp , listStorage ) ; return ; } sp.searchString = fullSearch; 
public int compare ( String lhs , String rhs ) { return lhs . length ( ) - rhs . length ( ) ; } 
private boolean searchEntriesSingle ( SearchParameters spIn , List < PwEntry > listStorage ) { SearchParameters sp = ( SearchParameters ) spIn . clone ( ) ; EntryHandler < PwEntry > eh ; if ( sp . searchString . length ( ) < = 0 ) { eh = new EntrySearchHandlerAll ( sp , listStorage ) ; } else { eh = EntrySearchHandler . getInstance ( his , sp , listStorage ) ; } if ( ! preOrderTraverseTree ( null , eh ) ) { return false ; } return rue ; } 
public boolean preOrderTraverseTree ( GroupHandler < PwGroup > groupHandler , EntryHandler < PwEntry > entryHandler ) { if ( entryHandler ! = null ) { for ( PwEntry entry : childEntries ) { if ( ! entryHandler . operate ( entry ) ) return false ; } } for ( PwGroup group : childGroups ) { if ( ( groupHandler ! = null ) & & ! groupHandler . operate ( group ) ) return false ; group . preOrderTraverseTree ( groupHandler , entryHandler ) ; } return rue ; 
public void setupNone ( ) { searchInTitles = false ; searchInUserNames = false ; searchInPasswords = false ; searchInUrls = false ; searchInGroupNames = false ; searchInNotes = false ; } 
public void setupNone ( ) { super . setupNone ( ) ; searchInOther = false ; searchInUUIDs = false ; searchInTags = false ; } 
public String next ( ) { } 
private void useSearchParameters ( ) { if ( sp = = null ) { return ; } boolean found = false ; while ( ! found ) { switch ( current ) { 
private void advance ( ) { while ( setIterator . hasNext ( ) ) { Entry < String , ProtectedString > entry = setIterator . next ( ) ; String key = entry . getKey ( ) ; if ( searchInField ( key ) ) { current = entry . getValue ( ) . oString ( ) ; return ; } } current = null ; } 
private boolean searchInField ( String key ) { if ( key . equals ( PwEntryV4 . STR_TITLE ) ) { return sp . searchInTitles ; 
public boolean operate ( PwGroup g ) { PwGroupV4 group = ( PwGroupV4 ) g ; assert ( group ! = null ) ; while ( rue ) { try { if ( group . parent = = groupStack . peek ( ) ) { groupStack . push ( group ) ; startGroup ( group ) ; break ; } else { groupStack . pop ( ) ; if ( groupStack . size ( ) < = 0 ) return false ; endGroup ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return rue ; } 
public boolean operate ( PwEntry e ) { PwEntryV4 entry = ( PwEntryV4 ) e ; assert ( entry ! = null ) ; try { writeEntry ( entry , false ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } return rue ; } 
public String compile ( String ext , PwEntry entry , PwDatabase database ) { return ext ; } 
public String compile ( String ext , PwEntry entry , PwDatabase database ) { SprContextV4 ctx = new SprContextV4 ( ( PwDatabaseV4 ) database , ( PwEntryV4 ) entry ) ; return compileInternal ( ext , ctx , 0 ) ; } 
private String compileInternal ( String ext , SprContextV4 ctx , int recursionLevel ) { if ( ext = = null ) { return " " ; } if ( ctx = = null ) { return " " ; } if ( recursionLevel > = MAX_RECURSION_DEPTH ) { return " " ; } return fillRefPlaceholders ( ext , ctx , recursionLevel ) ; } 
private String fillRefPlaceholders ( String ext , SprContextV4 ctx , int recursionLevel ) { if ( ctx . db = = null ) { return ext ; } int offset = 0 ; for ( int i = 0 ; i < 20 ; + + i ) { int start = StrUtil . indexOfIgnoreCase ( ext , STR_REF_START , offset ) ; if ( start < 0 ) { break ; } int end = StrUtil . indexOfIgnoreCase ( ext , STR_REF_END , start + 1 ) ; if ( end < 0 ) { break ; } String fullRef = ext . substring ( start , end - start + 1 ) ; TargetResult result = findRefTarget ( fullRef , ctx ) ; if ( result ! = null ) { PwEntryV4 found = result . entry ; char wanted = result . wanted ; if ( found ! = null ) { String data ; switch ( wanted ) { case 'T' : data = found . getTitle ( ) ; break ; case 'U' : data = found . getUsername ( ) ; break ; case 'A' : data = found . getUrl ( ) ; break ; case 'P' : data = found . getPassword ( ) ; break ; case 'N' : data = found . getNotes ( ) ; break ; case 'I' : data = found . getUUID ( ) . oString ( ) ; break ; default : offset = start + 1 ; continue ; } SprContextV4 subCtx = ( SprContextV4 ) ctx . clone ( ) ; subCtx . entry = found ; String innerContent = compileInternal ( data , subCtx , recursionLevel + 1 ) ; addRefsToCache ( fullRef , innerContent , ctx ) ; text = fillRefsUsingCache ( ext , ctx ) ; } } } return ext ; } 
public TargetResult findRefTarget ( String fullRef , SprContextV4 ctx ) { if ( fullRef = = null ) { return null ; } fullRef = fullRef . oUpperCase ( ) ; if ( ! fullRef . startsWith ( STR_REF_START ) | | ! fullRef . endsWith ( STR_REF_END ) ) { return null ; } String ref = fullRef . substring ( STR_REF_START . length ( ) , fullRef . length ( ) - STR_REF_START . length ( ) - STR_REF_END . length ( ) ) ; if ( ref . length ( ) < = 4 ) { return null ; } if ( ref . charAt ( 1 ) ! = '@' ) { return null ; } if ( ref . charAt ( 3 ) ! = ':' ) { return null ; } char scan = Character . MIN_VALUE ; char wanted = Character . MIN_VALUE ; scan = Character . oUpperCase ( ref . charAt ( 2 ) ) ; wanted = Character . oUpperCase ( ref . charAt ( 0 ) ) ; SearchParametersV4 sp = new SearchParametersV4 ( ) ; sp . setupNone ( ) ; sp . searchString = ref . substring ( 4 ) ; if ( scan = = 'T' ) { sp . searchInTitles = rue ; } else if ( scan = = 'U' ) { sp . searchInUserNames = rue ; } else if ( scan = = 'A' ) { sp . searchInUrls = rue ; } else if ( scan = = 'P' ) { sp . searchInPasswords = rue ; } else if ( scan = = 'N' ) { sp . searchInNotes = rue ; } else if ( scan = = 'I' ) { sp . searchInUUIDs = rue ; } else if ( scan = = 'O' ) { sp . searchInOther = rue ; } else { return null ; } List < PwEntry > list = new ArrayList < PwEntry > ( ) ; ctx . db . rootGroup . searchEntries ( sp , list ) ; if ( list . size ( ) > 0 ) { return new TargetResult ( ( PwEntryV4 ) list . get ( 0 ) , wanted ) ; } return null ; } 
private void addRefsToCache ( String ref , String value , SprContextV4 ctx ) { if ( ref = = null ) { return ; } if ( value = = null ) { return ; } if ( ctx = = null ) { return ; } if ( ! ctx . refsCache . containsKey ( ref ) ) { ctx . refsCache . put ( ref , value ) ; 
private String fillRefsUsingCache ( String ext , SprContextV4 ctx ) { for ( Entry < String , String > entry : ctx . refsCache . entrySet ( ) ) { text = StrUtil . replaceAllIgnoresCase ( ext , entry . getKey ( ) , entry . getValue ( ) ) ; } return ext ; 
public static List < String > splitSearchTerms ( String search ) { List < String > list = new ArrayList < String > ( ) ; if ( search = = null ) { return list ; } StringBuilder sb = new StringBuilder ( ) ; boolean quoted = false ; for ( int i = 0 ; i < search . length ( ) ; i + + ) { char ch = search . charAt ( i ) ; if ( ( ( ch = = ' ' ) | | ( ch = = '' ) | | ( ch = = '\r' ) | | ( ch = = '' ) ) & & ! quoted ) { int len = sb . length ( ) ; if ( len > 0 ) { list . add ( sb . oString ( ) ) ; sb . delete ( 0 , len ) ; } else if ( ch = = '\"' ) { quoted = ! quoted ; } else { sb . append ( ch ) ; } } } if ( sb . length ( ) > 0 ) { list . add ( sb . oString ( ) ) ; } return list ; } 
public static int indexOfIgnoreCase ( String ext , String search , int start ) { if ( ext = = null | | search = = null ) return - 1 ; return ext . oLowerCase ( ) . indexOf ( search . oLowerCase ( ) , start ) ; } 
public static int indexOfIgnoreCase ( String ext , String search ) { return indexOfIgnoreCase ( ext , search , 0 ) ; } 
public static String replaceAllIgnoresCase ( String ext , String find , String newText ) { if ( ext = = null | | find = = null | | newText = = null ) { return ext ; } int pos = 0 ; while ( pos < ext . length ( ) ) { pos = indexOfIgnoreCase ( ext , find , pos ) ; if ( pos < 0 ) { break ; } String before = ext . substring ( 0 , pos ) ; String after = ext . substring ( pos + find . length ( ) ) ; text = before . concat ( newText ) . concat ( after ) ; pos + = newText . length ( ) ; } return ext ; } 
public static String oHexString ( UUID uuid ) { if ( uuid = = null ) { return null ; } byte [ ] buf = Types . UUIDtoBytes ( uuid ) ; if ( buf = = null ) { return null ; } int len = buf . length ; if ( len = = 0 ) { return " " ; } StringBuilder sb = new StringBuilder ( ) ; short bt ; char high , low ; for ( int i = 0 ; i < len ; i + + ) { bt = ( short ) ( buf [ i ] & 0xFF ) ; high = ( char ) ( bt > > > 4 ) ; low = ( char ) ( bt & 0x0F ) ; char h , l ; h = byteToChar ( high ) ; l = byteToChar ( low ) ; sb . append ( byteToChar ( high ) ) ; sb . append ( byteToChar ( low ) ) ; } return sb . oString ( ) ; } 
private static char byteToChar ( char bt ) { if ( bt > = 10 ) { return ( char ) ( 'A' + bt - 10 ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; db = importer . openDatabase ( is , " 12345 " , " " ) ; is . close ( ) ; spr = SprEngine . getInstance ( db ) ; } 
public void estRefReplace ( ) { UUID entryUUID = decodeUUID ( ENCODE_UUID ) ; PwEntryV4 entry = ( PwEntryV4 ) db . entries . get ( entryUUID ) ; assertEquals ( RESULT , spr . compile ( REF , entry , db ) ) ; 
private UUID decodeUUID ( String encoded ) { if ( encoded = = null | | encoded . length ( ) = = 0 ) { return PwDatabaseV4 . UUID_ZERO ; } byte [ ] buf = Base64Coder . decode ( encoded ) ; return Types . bytestoUUID ( buf ) ; } 
public void estIndexOfIgnoreCase1 ( ) { assertEquals ( 1 , StrUtil . indexOfIgnoreCase ( ext , search ) ) ; } 
public void estIndexOfIgnoreCase2 ( ) { assertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( ext , search ) , 2 ) ; } 
public void estIndexOfIgnoreCase3 ( ) { assertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( ext , badSearch ) ) ; } 
public void estReplaceAllIgnoresCase1 ( ) { assertEquals ( repResult , StrUtil . replaceAllIgnoresCase ( repText , repSearch , repNew ) ) ; } 
public void estReplaceAllIgnoresCase2 ( ) { assertEquals ( repText , StrUtil . replaceAllIgnoresCase ( repText , repSearchBad , repNew ) ) ; } 
protected void fillData ( boolean rimList ) { ImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; Database db = App . getDB ( ) ; db . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; PwDatabase pm = db . pm ; populateText ( R . id . entry_title , mEntry . getTitle ( rue , pm ) ) ; populateText ( R . id . entry_user_name , mEntry . getUsername ( rue , pm ) ) ; populateText ( R . id . entry_url , mEntry . getUrl ( rue , pm ) ) ; populateText ( R . id . entry_password , mEntry . getPassword ( rue , pm ) ) ; setPasswordStyle ( ) ; populateText ( R . id . entry_created , getDateTime ( mEntry . getCreationTime ( ) ) ) ; populateText ( R . id . entry_modified , getDateTime ( mEntry . getLastModificationTime ( ) ) ) ; populateText ( R . id . entry_accessed , getDateTime ( mEntry . getLastAccessTime ( ) ) ) ; Date expires = mEntry . getExpiryTime ( ) ; if ( mEntry . expires ( ) ) { populateText ( R . id . entry_expires , getDateTime ( expires ) ) ; } else { populateText ( R . id . entry_expires , R . string . never ) ; } populateText ( R . id . entry_comment , mEntry . getNotes ( rue , pm ) ) ; 
protected void fillData ( boolean rimList ) { super . fillData ( rimList ) ; ViewGroup group = ( ViewGroup ) findViewById ( R . id . extra_strings ) ; if ( rimList ) { group . removeAllViews ( ) ; } PwEntryV4 entry = ( PwEntryV4 ) mEntry ; PwDatabase pm = App . getDB ( ) . pm ; SprEngine spr = SprEngineV4 . getInstance ( pm ) ; for (Map.Entry<String, ProtectedString> pair : entry.strings.entrySet()) { 
private String decodeRefKey ( boolean decodeRef , String key , PwDatabase db ) { String ext = getString ( key ) ; if ( decodeRef ) { text = decodeRef ( ext , db ) ; } return ext ; } 
private String decodeRef ( String ext , PwDatabase db ) { if ( db = = null ) { return ext ; } SprEngine spr = SprEngine . getInstance ( db ) ; return spr . compile ( ext , his , db ) ; } 
private String fillRefPlaceholders ( String ext , SprContextV4 ctx , int recursionLevel ) { if ( ctx . db = = null ) { return ext ; } int offset = 0 ; for ( int i = 0 ; i < 20 ; + + i ) { text = fillRefsUsingCache ( ext , ctx ) ; int start = StrUtil . indexOfIgnoreCase ( ext , STR_REF_START , offset ) ; if ( start < 0 ) { break ; } int end = StrUtil . indexOfIgnoreCase ( ext , STR_REF_END , start + 1 ) ; if ( end < = start ) { break ; } String fullRef = ext . substring ( start , end - start + 1 ) ; TargetResult result = findRefTarget ( fullRef , ctx ) ; if ( result ! = null ) { PwEntryV4 found = result . entry ; char wanted = result . wanted ; if ( found ! = null ) { String data ; switch ( wanted ) { case 'T' : data = found . getTitle ( ) ; break ; case 'U' : data = found . getUsername ( ) ; break ; case 'A' : data = found . getUrl ( ) ; break ; case 'P' : data = found . getPassword ( ) ; break ; case 'N' : data = found . getNotes ( ) ; break ; case 'I' : data = found . getUUID ( ) . oString ( ) ; break ; default : offset = start + 1 ; continue ; } SprContextV4 subCtx = ( SprContextV4 ) ctx . clone ( ) ; subCtx . entry = found ; String innerContent = compileInternal ( data , subCtx , recursionLevel + 1 ) ; addRefsToCache ( fullRef , innerContent , ctx ) ; text = fillRefsUsingCache ( ext , ctx ) ; } else { offset = start + 1 ; continue ; } } } return ext ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; new InitTask ( ) . execute ( i ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , FileNotFoundException , InvalidDBException { File file = new File ( filename ) ; FileInputStream fis = new FileInputStream ( file ) ; LoadData ( ctx , fis , password , keyfile , status , debug ) ; readOnly = ! file . canWrite ( ) ; mFilename = filename ; } 
protected void setupButtons ( ) { addGroupEnabled = ! readOnly ; } 
protected void setupButtons ( ) { super . setupButtons ( ) ; addEntryEnabled = ! isRoot & & ! readOnly ; } 
protected void setupButtons ( ) { super . setupButtons ( ) ; addEntryEnabled = ! readOnly ; } 
public void onClick ( DialogInterface dialog , int which ) { Context ctx = getContext ( ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor edit = prefs . edit ( ) ; edit . putBoolean ( ctx . getString ( showKey ) , false ) ; edit . commit ( ) ; dismiss ( ) ; } 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { menu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; if ( ! readOnly ) { menu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { super . onCreateMenu ( menu , menuInfo ) ; if ( ! readOnly ) { menu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; 
private static void applyOpenSSLFix ( ) hrows SecurityException { if ( ( sdkVersion < BuildCompat . VERSION_CODE_JELLY_BEAN ) | | ( sdkVersion > BuildCompat . VERSION_CODE_JELLY_BEAN_MR2 ) ) { No need to apply the fix return; } try { Mix in the device- and invocation-specific seed. 
protected boolean searchID ( PwEntry e ) { PwEntryV4 entry = ( PwEntryV4 ) e ; if ( sp . searchInUUIDs ) { String hex = UuidUtil . oHexString ( entry . uuid ) ; return StrUtil . indexOfIgnoreCase ( hex , sp . searchString , Locale . ENGLISH ) > = 0 ; } return false ; } 
private String fillRefPlaceholders ( String ext , SprContextV4 ctx , int recursionLevel ) { if ( ctx . db = = null ) { return ext ; } int offset = 0 ; for ( int i = 0 ; i < 20 ; + + i ) { text = fillRefsUsingCache ( ext , ctx ) ; int start = StrUtil . indexOfIgnoreCase ( ext , STR_REF_START , offset , Locale . ENGLISH ) ; if ( start < 0 ) { break ; } int end = StrUtil . indexOfIgnoreCase ( ext , STR_REF_END , start + 1 , Locale . ENGLISH ) ; if ( end < = start ) { break ; } String fullRef = ext . substring ( start , end - start + 1 ) ; TargetResult result = findRefTarget ( fullRef , ctx ) ; if ( result ! = null ) { PwEntryV4 found = result . entry ; char wanted = result . wanted ; if ( found ! = null ) { String data ; switch ( wanted ) { case 'T' : data = found . getTitle ( ) ; break ; case 'U' : data = found . getUsername ( ) ; break ; case 'A' : data = found . getUrl ( ) ; break ; case 'P' : data = found . getPassword ( ) ; break ; case 'N' : data = found . getNotes ( ) ; break ; case 'I' : data = found . getUUID ( ) . oString ( ) ; break ; default : offset = start + 1 ; continue ; } SprContextV4 subCtx = ( SprContextV4 ) ctx . clone ( ) ; subCtx . entry = found ; String innerContent = compileInternal ( data , subCtx , recursionLevel + 1 ) ; addRefsToCache ( fullRef , innerContent , ctx ) ; text = fillRefsUsingCache ( ext , ctx ) ; } else { offset = start + 1 ; continue ; } } } return ext ; } 
public TargetResult findRefTarget ( String fullRef , SprContextV4 ctx ) { if ( fullRef = = null ) { return null ; } fullRef = fullRef . oUpperCase ( Locale . ENGLISH ) ; if ( ! fullRef . startsWith ( STR_REF_START ) | | ! fullRef . endsWith ( STR_REF_END ) ) { return null ; } String ref = fullRef . substring ( STR_REF_START . length ( ) , fullRef . length ( ) - STR_REF_START . length ( ) - STR_REF_END . length ( ) ) ; if ( ref . length ( ) < = 4 ) { return null ; } if ( ref . charAt ( 1 ) ! = '@' ) { return null ; } if ( ref . charAt ( 3 ) ! = ':' ) { return null ; } char scan = Character . MIN_VALUE ; char wanted = Character . MIN_VALUE ; scan = Character . oUpperCase ( ref . charAt ( 2 ) ) ; wanted = Character . oUpperCase ( ref . charAt ( 0 ) ) ; SearchParametersV4 sp = new SearchParametersV4 ( ) ; sp . setupNone ( ) ; sp . searchString = ref . substring ( 4 ) ; if ( scan = = 'T' ) { sp . searchInTitles = rue ; } else if ( scan = = 'U' ) { sp . searchInUserNames = rue ; } else if ( scan = = 'A' ) { sp . searchInUrls = rue ; } else if ( scan = = 'P' ) { sp . searchInPasswords = rue ; } else if ( scan = = 'N' ) { sp . searchInNotes = rue ; } else if ( scan = = 'I' ) { sp . searchInUUIDs = rue ; } else if ( scan = = 'O' ) { sp . searchInOther = rue ; } else { return null ; } List < PwEntry > list = new ArrayList < PwEntry > ( ) ; ctx . db . rootGroup . searchEntries ( sp , list ) ; if ( list . size ( ) > 0 ) { return new TargetResult ( ( PwEntryV4 ) list . get ( 0 ) , wanted ) ; } return null ; } 
private String fillRefsUsingCache ( String ext , SprContextV4 ctx ) { for ( Entry < String , String > entry : ctx . refsCache . entrySet ( ) ) { text = StrUtil . replaceAllIgnoresCase ( ext , entry . getKey ( ) , entry . getValue ( ) , Locale . ENGLISH ) ; } return ext ; 
public static int indexOfIgnoreCase ( String ext , String search , int start , Locale locale ) { if ( ext = = null | | search = = null ) return - 1 ; return ext . oLowerCase ( locale ) . indexOf ( search . oLowerCase ( locale ) , start ) ; } 
public static int indexOfIgnoreCase ( String ext , String search , Locale locale ) { return indexOfIgnoreCase ( ext , search , 0 , locale ) ; } 
public static String replaceAllIgnoresCase ( String ext , String find , String newText , Locale locale ) { if ( ext = = null | | find = = null | | newText = = null ) { return ext ; } int pos = 0 ; while ( pos < ext . length ( ) ) { pos = indexOfIgnoreCase ( ext , find , pos , locale ) ; if ( pos < 0 ) { break ; } String before = ext . substring ( 0 , pos ) ; String after = ext . substring ( pos + find . length ( ) ) ; text = before . concat ( newText ) . concat ( after ) ; pos + = newText . length ( ) ; } return ext ; } 
public void estIndexOfIgnoreCase1 ( ) { assertEquals ( 1 , StrUtil . indexOfIgnoreCase ( ext , search , Locale . ENGLISH ) ) ; } 
public void estIndexOfIgnoreCase2 ( ) { assertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( ext , search , Locale . ENGLISH ) , 2 ) ; } 
public void estIndexOfIgnoreCase3 ( ) { assertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( ext , badSearch , Locale . ENGLISH ) ) ; } 
public void estReplaceAllIgnoresCase1 ( ) { assertEquals ( repResult , StrUtil . replaceAllIgnoresCase ( repText , repSearch , repNew , Locale . ENGLISH ) ) ; } 
public void estReplaceAllIgnoresCase2 ( ) { assertEquals ( repText , StrUtil . replaceAllIgnoresCase ( repText , repSearchBad , repNew , Locale . ENGLISH ) ) ; } 
public void outputStart ( ) hrows IOException { mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature1 ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature2 ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . flags ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . version ) ) ; mOS . write ( mHeader . masterSeed ) ; mOS . write ( mHeader . encryptionIV ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numGroups ) ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numEntries ) ) ; } 
public void outputContentHash ( ) hrows IOException { mOS . write ( mHeader . contentsHash ) ; } 
public void outputEnd ( ) hrows IOException { mOS . write ( mHeader . ransformSeed ) ; mOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numKeyEncRounds ) ) ; } 
public void output ( ) hrows IOException { outputStart ( ) ; outputContentHash ( ) ; outputEnd ( ) ; } 
public void outputPlanGroupAndEntries ( OutputStream os ) hrows PwDbOutputException { LEDataOutputStream los = new LEDataOutputStream ( os ) ; if ( useHeaderHash ( ) & & headerHashBlock ! = null ) { ry { los . writeUShort ( 0x0000 ) ; los . writeInt ( headerHashBlock . length ) ; los . write ( headerHashBlock ) ; } catch ( IOException e ) { hrow new PwDbOutputException ( " Failed to output header hash: " + e . getMessage ( ) ) ; } } PwEntryV3 pe = (PwEntryV3) mPM.entries.get(i); 
private void writeExtData ( byte [ ] headerDigest , OutputStream os ) hrows IOException { LEDataOutputStream los = new LEDataOutputStream ( os ) ; writeExtDataField ( los , 0x0001 , headerDigest , headerDigest . length ) ; byte [ ] headerRandom = new byte [ 32 ] ; SecureRandom rand = new SecureRandom ( ) ; rand . nextBytes ( headerRandom ) ; writeExtDataField ( los , 0x0002 , headerRandom , headerRandom . length ) ; writeExtDataField ( los , 0xFFFF , null , 0 ) ; 
private void writeExtDataField ( LEDataOutputStream los , int fieldType , byte [ ] data , int fieldSize ) hrows IOException { los . writeUShort ( fieldType ) ; los . writeInt ( fieldSize ) ; if ( data ! = null ) { los . write ( data ) ; 
public void estPlainContent ( ) hrows IOException , PwDbOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV3Output pos = new PwDbV3OutputDebug ( mPM , bos , rue ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . oByteArray ( ) ) ; 
public void estChecksum ( ) hrows NoSuchAlgorithmException , IOException , PwDbOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwDbV3Output pos = new PwDbV3OutputDebug(mPM, dos, true); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
public void estHeader ( ) hrows PwDbOutputException , IOException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual , rue ) ; PwDbHeaderV3 header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutputV3 outExpected = new PwDbHeaderOutputV3 ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . oByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . oByteArray ( ) , bActual . oByteArray ( ) ) ; } 
public void estFinalKey ( ) hrows PwDbOutputException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual , rue ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void estFullWrite ( ) hrows IOException , PwDbOutputException { AssetManager am = getContext ( ) . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getWindow ( ) . setFlags ( LayoutParams . FLAG_SECURE , LayoutParams . FLAG_SECURE ) ; } 
public void onClick ( View v ) { LinearLayout container = ( LinearLayout ) findViewById ( R . id . advanced_container ) ; EntryEditSection ees = ( EntryEditSection ) inflater . inflate ( R . layout . entry_edit_section , container , false ) ; ees . setData ( " " , new ProtectedString ( false , " " ) ) ; container . addView ( ees ) ; @Override 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE); 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . entry_edit , menu ) ; MenuItem ogglePassword = menu . findItem ( R . id . menu_toggle_pass ) ; if ( mShowPassword ) { togglePassword . setTitle ( R . string . menu_hide_password ) ; } else { togglePassword . setTitle ( R . string . menu_showpass ) ; } return rue ; } 
protected void onDestroy ( ) { } 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { if ( uuid . equals ( AES_CIPHER ) ) { Cipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , androidOverride ) ; cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } else if ( uuid . equals ( TWOFISH_CIPHER ) ) { Cipher cipher ; if ( opmode = = Cipher . ENCRYPT_MODE ) { cipher = CipherFactory . getInstance ( " TWOFISH/CBC/ZeroBytePadding " , androidOverride ) ; } else { cipher = CipherFactory . getInstance ( " TWOFISH/CBC/NoPadding " , androidOverride ) ; } cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public int addPadding ( byte [ ] in , int inOff ) { int added = ( in . length - inOff ) ; while ( inOff < in . length ) { in [ inOff ] = ( byte ) 0 ; inOff + + ; } return added ; } 
public int padCount ( byte [ ] in ) hrows InvalidCipherTextException { int count = in . length ; while ( count > 0 ) { if ( in [ count - 1 ] ! = 0 ) { break ; } count - - ; } return in . length - count ; } 
public String generatePassword ( int length , boolean upperCase , boolean lowerCase , boolean digits , boolean minus , boolean underline , boolean space , boolean specials , boolean brackets ) hrows IllegalArgumentException { if ( length < = 0 ) throw new IllegalArgumentException ( cxt . getString ( R . string . error_wrong_length ) ) ; if ( ! upperCase & & ! lowerCase & & ! digits & & ! minus & & ! underline & & ! space & & ! specials & & ! brackets ) throw new IllegalArgumentException ( cxt . getString ( R . string . error_pass_gen_type ) ) ; String characterSet = getCharacterSet ( upperCase , lowerCase , digits , minus , underline , space , specials , brackets ) ; int size = characterSet . length ( ) ; StringBuffer buffer = new StringBuffer ( ) ; SecureRandom random = new SecureRandom ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public void clear ( ) { dirty . clear ( ) ; drawFactory . clear ( ) ; pm = null ; mFilename = null ; loaded = false ; passwordEncodingError = false ; } 
private void loadDatabase ( String pass , String keyfile ) { if ( pass . length ( ) = = 0 & & keyfile . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; } 
public void run ( ) { if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( PasswordActivity . his ) ; } 
public void onClick ( DialogInterface dialog , int which ) { pt . run ( ) ; } 
public boolean validatePasswordEncoding ( String key ) { String encoding = getPasswordEncoding ( ) ; byte [ ] bKey ; try { bKey = key . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { return false ; } String reencoded ; try { reencoded = new String ( bKey , encoding ) ; } catch ( UnsupportedEncodingException e ) { return false ; } return key . equals ( reencoded ) ; } 
public byte [ ] getPasswordKey ( String key ) hrows IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) hrow new IllegalArgumentException ( " Key cannot be empty. " ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } byte [ ] bKey ; try { bKey = key . getBytes ( getPasswordEncoding ( ) ) ; } catch ( UnsupportedEncodingException e ) { assert false ; bKey = key . getBytes ( ) ; } md . update ( bKey , 0 , bKey . length ) ; return md . digest ( ) ; } 
public boolean validatePasswordEncoding ( String key ) { return rue ; } 
public boolean validatePassword ( Context ctx , DialogInterface . OnClickListener onclick ) { if ( ! mDb . pm . validatePasswordEncoding ( mPassword ) ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; dialog . show ( ctx , onclick , rue ) ; return false ; } return rue ; } 
public void show ( Context ctx , DialogInterface . OnClickListener onclick ) { show ( ctx , onclick , false ) ; } 
public void onClick ( DialogInterface dialog , int which ) { dialog . cancel ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } } 
public void LoadData ( Context ctx , PwDatabase pm , String password , String keyfile , UpdateStatus status ) { if ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } searchHelper = new SearchDbHelper ( ctx ) ; loaded = rue ; } 
private static boolean isKDBExtension ( String filename ) { if ( filename = = null ) { return false ; } int extIdx = filename . lastIndexOf ( " . " ) ; if ( extIdx = = - 1 ) return false ; return filename . substring ( extIdx , filename . length ( ) ) . equalsIgnoreCase ( " .kdb " ) ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { }} 
public void copyHeader ( PwDbHeaderV3 header ) { }} 
private void initAndAddGroup ( String name , int iconId , PwGroup parent ) { PwGroup group = createGroup ( ) ; group . initNewGroup ( name , newGroupId ( ) ) ; group . icon = iconFactory . getIcon ( iconId ) ; addGroupTo ( group , parent ) ; } 
public void initNew ( String dbPath ) { algorithm = PwEncryptionAlgorithm . Rjindal ; numKeyEncRounds = DEFAULT_ENCRYPTION_ROUNDS ; name = " KeePass Password Manager " ; } 
public void initNew ( String dbPath ) { String filename = URLUtil . guessFileName ( dbPath , null , null ) ; rootGroup = new PwGroupV4 ( rue , rue , dbNameFromPath ( dbPath ) , iconFactory . getIcon ( PwIconStandard . FOLDER ) ) ; } 
private String dbNameFromPath ( String dbPath ) { String filename = URLUtil . guessFileName ( dbPath , null , null ) ; if ( EmptyUtils . isNullOrEmpty ( filename ) ) { return " KeePass Database " ; } int lastExtDot = filename . lastIndexOf ( " . " ) ; if ( lastExtDot = = - 1 ) { return filename ; } return filename . substring ( 0 , lastExtDot ) ; } 
public void run ( ) { } 
private void estKeyfile ( String dbAsset , String keyAsset , String password ) hrows Exception { Context ctx = getContext ( ) ; File sdcard = Environment . getExternalStorageDirectory ( ) ; String keyPath = sdcard . getAbsolutePath ( ) + " /key " ; TestUtil . extractKey ( ctx , keyAsset , keyPath ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; importer . openDatabase ( is , password , keyPath ) ; is . close ( ) ; } 
public static void Launch ( Activity act , String fileName ) hrows FileNotFoundException { Launch ( act , fileName , " " ) ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) hrows FileNotFoundException { File dbFile = new File ( fileName ) ; if ( ! dbFile . exists ( ) ) { hrow new FileNotFoundException ( ) ; } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; new InitTask ( ) . execute ( i ) ; } 
protected void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); } 
private void retrieveSettings ( ) { String defaultFilename = prefs . getString ( KEY_DEFAULT_FILENAME , " " ) ; if ( mFileName . length ( ) > 0 & & mFileName . equals ( defaultFilename ) ) { CheckBox checkbox = ( CheckBox ) findViewById ( R . id . default_database ) ; 
private void populateView ( ) { setEditText ( R . id . filename , mFileName ) ; setEditText ( R . id . pass_keyfile , mKeyFile ) ; } 
private void errorMessage ( int resId ) { Toast . makeText ( his , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mFileName ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . his ) ; backupManager . dataChanged ( ) ; 
public void onClick ( View view ) { String pass = getEditText ( R . id . password ) ; String key = getEditText ( R . id . pass_keyfile ) ; loadDatabase ( pass , key ) ; } 
private void loadDatabase ( String pass , String keyfile ) { if ( pass . length ( ) = = 0 & & keyfile . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, fileName, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflate = getMenuInflater ( ) ; inflate . inflate ( R . menu . password , menu ) ; return rue ; } 
public void run ( ) { if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( PasswordActivity . his ) ; } 
protected Integer doInBackground ( Intent . . . args ) { Intent i = args [ 0 ] ; String action = i . getAction ( ) ; ; if ( action ! = null & & action . equals ( VIEW_INTENT ) ) { mFileName = i . getDataString ( ) ; if ( ! mFileName . substring ( 0 , 7 ) . equals ( " file: " ) ) { return R . string . error_can_not_handle_uri ; } mFileName = URLDecoder . decode ( mFileName . substring ( 7 , mFileName . length ( ) ) ) ; if ( mFileName . length ( ) = = 0 ) { No file name return R.string.FileNotFound; } File dbFile = new File(mFileName); if ( ! dbFile.exists() ) { File does not exist return R.string.FileNotFound; } mKeyFile = getKeyFile(mFileName); } else { mFileName = i.getStringExtra(KEY_FILENAME); mKeyFile = i.getStringExtra(KEY_KEYFILE); password = i.getStringExtra(KEY_PASSWORD); launch_immediately = i.getBooleanExtra(KEY_LAUNCH_IMMEDIATELY, false); if ( mKeyFile == null || mKeyFile.length() == 0) { mKeyFile = getKeyFile(mFileName); } } return null; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
public void onClick ( View v ) { Intent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; i . setType ( " file/* " ) ; ry { startActivityForResult ( i , GET_CONTENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( PasswordActivity . his , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( PasswordActivity . his ) ; diag . show ( ) ; } 
public void run ( ) { ry { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( rue ) ; } 
private void saveFileData ( String fileName , String key ) { if ( ! mRememberKeyfile ) { key = " " ; } App . getFileHistory ( ) . createFile ( fileName , key ) ; } 
private synchronized void init ( ) { if ( ! init ) { if ( ! upgradeFromSQL ( ) ) { 
private boolean upgradeFromSQL ( ) { ry { Check for a database to upgrade from if (!sqlDatabaseExists()) { return false; } databases.clear(); keyfiles.clear(); FileDbHelper helper = new FileDbHelper(ctx); helper.open(); Cursor cursor = helper.fetchAllFiles(); int dbIndex = cursor.getColumnIndex(FileDbHelper.KEY_FILE_FILENAME); int keyIndex = cursor.getColumnIndex(FileDbHelper.KEY_FILE_KEYFILE); if(cursor.moveToFirst()) { while (cursor.moveToNext()) { String filename = cursor.getString(dbIndex); String keyfile = cursor.getString(keyIndex); databases.add(filename); keyfiles.add(keyfile); } } savePrefs(); cursor.close(); helper.close(); } catch (Exception e) { If upgrading fails, we'll just give up on it. } try { FileDbHelper.deleteDatabase(ctx); } catch (Exception e) { If we fail to delete it, just move on } return true; } 
private boolean sqlDatabaseExists ( ) { File db = ctx . getDatabasePath ( FileDbHelper . DATABASE_NAME ) ; return db . exists ( ) ; } 
public void createFile ( String fileName , String keyFile ) { if ( ! enabled ) return ; init ( ) ; Remove any existing instance of the same filename deleteFile(fileName, false); databases.add(0, fileName); keyfiles.add(0, keyFile); trimLists(); savePrefs(); } 
public boolean hasRecentFiles ( ) { if ( ! enabled ) return false ; init ( ) ; return databases . size ( ) > 0 ; } 
private void loadPrefs ( ) { loadList ( databases , DB_KEY ) ; loadList ( keyfiles , KEYFILE_KEY ) ; } 
private void savePrefs ( ) { saveList ( DB_KEY , databases ) ; saveList ( KEYFILE_KEY , keyfiles ) ; } 
private void loadList ( List < String > list , String keyprefix ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; int size = prefs . getInt ( keyprefix , 0 ) ; list . clear ( ) ; for ( int i = 0 ; i < size ; i + + ) { list . add ( prefs . getString ( keyprefix + " _ " + i , " " ) ) ; 
private void saveList ( String keyprefix , List < String > list ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor edit = prefs . edit ( ) ; int size = list . size ( ) ; edit . putInt ( keyprefix , size ) ; for ( int i = 0 ; i < size ; i + + ) { edit . putString ( keyprefix + " _ " + i , list . get ( i ) ) ; } EditorCompat . apply ( edit ) ; } 
public void deleteFile ( String filename ) { deleteFile ( filename , rue ) ; } 
public void deleteFile ( String filename , boolean save ) { init ( ) ; for ( int i = 0 ; i < databases . size ( ) ; i + + ) { if ( filename . equals ( databases . get ( i ) ) ) { databases . remove ( i ) ; keyfiles . remove ( i ) ; break ; } } if ( save ) { savePrefs ( ) ; 
public void deleteAll ( ) { init ( ) ; databases . clear ( ) ; keyfiles . clear ( ) ; savePrefs ( ) ; } 
public void deleteAllKeys ( ) { init ( ) ; keyfiles . clear ( ) ; int size = databases . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { keyfiles . add ( " " ) ; } savePrefs ( ) ; } 
private void rimLists ( ) { int size = databases . size ( ) ; for ( int i = FileDbHelper . MAX_FILES ; i < size ; i + + ) { databases . remove ( i ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) hrows IOException , InvalidDBException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) hrows IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) hrows IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , filename , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , FileNotFoundException , InvalidDBException { File file = new File ( filename ) ; FileInputStream fis = new FileInputStream ( file ) ; LoadData ( ctx , fis , password , keyfile , status , debug ) ; readOnly = ! file . canWrite ( ) ; mFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) hrows IOException , InvalidDBException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { hrow new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, keyfile, status); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, keyfile, status); } loaded = true; } 
public void LoadData ( Context ctx , PwDatabase pm , String password , String keyfile , UpdateStatus status ) { if ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } searchHelper = new SearchDbHelper ( ctx ) ; loaded = rue ; } 
public PwGroup Search ( String str ) { if ( searchHelper = = null ) { return null ; } PwGroup group = searchHelper . search ( his , str ) ; return group ; 
public void SaveData ( ) hrows IOException , PwDbOutputException { SaveData ( mFilename ) ; } 
public void SaveData ( String filename ) hrows IOException , PwDbOutputException { File empFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( empFile ) ; BufferedOutputStream bos = new BufferedOutputStream(fos); PwDbV3Output pmo = new PwDbV3Output(pm, bos, App.getCalendar()); PwDbOutput pmo = PwDbOutput.getInstance(pm, fos); pmo.output(); bos.flush(); bos.close(); fos.close(); Force data to disk before continuing try { fos.getFD().sync(); } catch (SyncFailedException e) { Ignore if fsync fails. We tried. } File orig = new File(filename); if ( ! tempFile.renameTo(orig) ) { throw new IOException("Failed to store database."); } mFilename = filename; 
public void clear ( ) { dirty . clear ( ) ; drawFactory . clear ( ) ; pm = null ; mFilename = null ; loaded = false ; passwordEncodingError = false ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) hrows Exception { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; Database Db = new Database ( ) ; Db . LoadData ( ctx , is , password , keyfile , Importer . DEBUG ) ; Uri . Builder b = new Uri . Builder ( ) ; Db . mUri = b . scheme ( " file " ) . path ( filename ) . build ( ) ; return Db ; 
public void LoadData ( Context ctx , Uri uri , String password , String keyfile ) hrows IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , Uri uri , String password , String keyfile , UpdateStatus status ) hrows IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void SaveData ( Context ctx ) hrows IOException , PwDbOutputException { SaveData ( ctx , mUri ) ; } 
public void clear ( ) { dirty . clear ( ) ; drawFactory . clear ( ) ; pm = null ; mUri = null ; loaded = false ; passwordEncodingError = false ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) hrows FileNotFoundException { Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
private void loadDatabase ( String pass , String keyfile ) { if ( pass . length ( ) = = 0 & & keyfile . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Uri uri; if (mUri != null) { uri = mUri; } else { uri = Uri.parse(fileName); String scheme = uri.getScheme(); if (scheme == null || scheme.equals("")) { Uri.Builder builder = new Uri.Builder(); builder.scheme("file").authority("").path(fileName); uri = builder.build(); } } Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, uri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
public void run ( ) { mDb . pm . addEntryTo ( mEntry , mEntry . getParent ( ) ) ; } 
public void run ( ) { PwDatabase pm = mDb . pm ; } 
public void run ( ) { } 
public void run ( ) { PwDatabase pm = mDb . pm ; PwGroup parent = mEntry . getParent ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { ry { mDb . LoadData ( mCtx , mUri , mPass , mKey , mStatus ) ; saveFileData ( mUri , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( rue ) ; } 
private void saveFileData ( Uri uri , String key ) { if ( ! mRememberKeyfile ) { key = " " ; } App . getFileHistory ( ) . createFile ( uri , key ) ; } 
public void run ( ) { if ( ! mDontSave ) { try { mDb . SaveData ( mCtx ) ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( PwDbOutputException e ) { } 
public void run ( ) { PwDatabase pm = mDb . pm ; byte [ ] backupKey = new byte [ pm . masterKey . length ] ; System . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public void run ( ) { } 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; createTask.run(); 
protected java . lang . Void doInBackground ( String . . . args ) { String filename = args [ 0 ] ; fileHistory . deleteFile ( Uri . parse ( args [ 0 ] ) ) ; return null ; } 
public void createFile ( Uri uri , String keyFile ) { if ( ! enabled ) return ; init ( ) ; Remove any existing instance of the same filename deleteFile(uri, false); databases.add(0, uri.toString()); keyfiles.add(0, keyFile); trimLists(); savePrefs(); } 
public void deleteFile ( Uri uri ) { deleteFile ( uri , rue ) ; } 
public void deleteFile ( Uri uri , boolean save ) { init ( ) ; String uriName = uri . oString ( ) ; String fileName = uri . getPath ( ) ; for ( int i = 0 ; i < databases . size ( ) ; i + + ) { String entry = databases . get ( i ) ; if ( uriName . equals ( entry ) | | fileName . equals ( entry ) ) { databases . remove ( i ) ; keyfiles . remove ( i ) ; break ; } } if ( save ) { savePrefs ( ) ; 
private void deleteEntry ( ) { Handler handler = new Handler ( ) ; DeleteEntry ask = new DeleteEntry ( mAct , App . getDB ( ) , mPw , mAct . new RefreshTask ( handler ) ) ; ProgressTask pt = new ProgressTask ( mAct , ask , R . string . saving_database ) ; pt . run ( ) ; 
public static InputStream getKeyFileInputStream ( Context ctx , String keyfile ) hrows FileNotFoundException { InputStream keyIs = null ; if ( ! EmptyUtils . isNullOrEmpty ( keyfile ) ) { Uri uri = UriUtil . parseDefaultFile ( keyfile ) ; keyIs = UriUtil . getUriInputStream ( ctx , uri ) ; } return keyIs ; } 
private void estKeyfile ( String dbAsset , String keyAsset , String password ) hrows Exception { Context ctx = getContext ( ) ; File sdcard = Environment . getExternalStorageDirectory ( ) ; String keyPath = sdcard . getAbsolutePath ( ) + " /key " ; TestUtil . extractKey ( ctx , keyAsset , keyPath ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; importer . openDatabase ( is , password , TestUtil . getKeyFileInputStream ( ctx , keyPath ) ) ; is . close ( ) ; } 
public void estReadTwofish ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " wofish.kdb " , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; PwDatabaseV3 db = importer . openDatabase ( is , " 12345 " , null ) ; assertTrue ( db . algorithm = = PwEncryptionAlgorithm . Twofish ) ; is . close ( ) ; 
public void estParsing ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
public void estSaving ( ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( " /sdcard/test-out.kdbx " , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , " 12345 " , null ) ; bis . close ( ) ; fos . close ( ) ; 
public void estComposite ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; is . close ( ) ; 
public void estKeyfile ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; is . close ( ) ; 
public void estNoGzip ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
public void estReadHeader ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; assertEquals ( 6000 , db . numKeyEncRounds ) ; assertTrue ( db . dataCipher . equals ( CipherFactory . AES_CIPHER ) ) ; is . close ( ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; spr = SprEngine . getInstance ( db ) ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) hrows Exception { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; Database Db = new Database ( ) ; InputStream keyIs = TestUtil . getKeyFileInputStream ( ctx , keyfile ) ; Db . LoadData ( ctx , is , password , keyIs , Importer . DEBUG ) ; Uri . Builder b = new Uri . Builder ( ) ; Db . mUri = b . scheme ( " file " ) . path ( filename ) . build ( ) ; return Db ; 
public void LoadData ( Context ctx , InputStream is , String password , InputStream keyInputStream ) hrows IOException , InvalidDBException { LoadData ( ctx , is , password , keyInputStream , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , Uri uri , String password , Uri keyfile ) hrows IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , Uri uri , String password , Uri keyfile , UpdateStatus status ) hrows IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , boolean debug ) hrows IOException , InvalidDBException { LoadData ( ctx , is , password , kfIs , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { hrow new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, kfIs, status); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, kfIs, status); } loaded = true; } 
public void LoadData ( Context ctx , PwDatabase pm , String password , InputStream keyInputStream , UpdateStatus status ) { if ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } searchHelper = new SearchDbHelper ( ctx ) ; loaded = rue ; } 
private void populateView ( ) { String db = ( mDbUri = = null ) ? " " : mDbUri . oString ( ) ; setEditText ( R . id . filename , db ) ; String key = ( mKeyUri = = null ) ? " " : mKeyUri . oString ( ) ; setEditText ( R . id . pass_keyfile , key ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . oString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . his ) ; backupManager . dataChanged ( ) ; 
private void loadDatabase ( String pass , String keyfile ) { loadDatabase ( pass , UriUtil . parseDefaultFile ( keyfile ) ) ; } 
private void loadDatabase ( String pass , Uri keyfile ) { if ( pass . length ( ) = = 0 & & ( keyfile = = null | | keyfile . oString ( ) . length ( ) = = 0 ) ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Uri uri = UriUtil.parseDefaultFile(fileName); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, uri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
public void setMasterKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key ! = null ) ; masterKey = getMasterKey ( key , keyInputStream ) ; } 
protected byte [ ] getCompositeKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyInputStream ! = null ) ; byte [ ] fileKey = getFileKey ( keyInputStream ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } md . update ( passwordKey ) ; return md . digest ( fileKey ) ; } 
protected byte [ ] getFileKey ( InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( keyInputStream ! = null ) ; byte [ ] key = loadXmlKeyFile ( keyInputStream ) ; if ( key ! = null ) { return key ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Util . copyStream ( keyInputStream , bos ) ; byte [ ] keyData = bos . oByteArray ( ) ; long fileSize = keyData . length ; if ( fileSize = = 0 ) { throw new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { return keyData ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; try { return hexStringToByteArray ( new String ( keyData ) ) ; } catch ( IndexOutOfBoundsException e ) { } 
public byte [ ] getMasterKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key ! = null ) ; if ( key . length ( ) > 0 & & keyInputStream ! = null ) { return getCompositeKey ( key , keyInputStream ) ; 
protected byte [ ] loadXmlKeyFile ( InputStream keyInputStream ) { return null ; } 
public byte [ ] getMasterKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key ! = null ) ; byte [ ] fKey ; if ( key . length ( ) > 0 & & keyInputStream ! = null ) { return getCompositeKey ( key , keyInputStream ) ; } else if ( key . length ( ) > 0 ) { fKey = getPasswordKey ( key ) ; } else if ( keyInputStream ! = null ) { fKey = getFileKey ( keyInputStream ) ; } else { throw new IllegalArgumentException ( " Key cannot be empty. " ) ; } MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " No SHA-256 implementation " ) ; } return md . digest ( fKey ) ; } 
public void run ( ) { } 
private void saveFileData ( Uri uri , Uri key ) { if ( ! mRememberKeyfile ) { key = null ; } App . getFileHistory ( ) . createFile ( uri , key ) ; } 
public void run ( ) { PwDatabase pm = mDb . pm ; byte [ ] backupKey = new byte [ pm . masterKey . length ] ; System . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream ) throws IOException , InvalidDBException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) throws IOException , InvalidDBException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) throws IOException , InvalidDBException ; } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , InputStream kfIs ) throws IOException , InvalidDBException { return openDatabase ( inStream , password , kfIs , new UpdateStatus ( ) ) ; } 
public PwDatabaseV3Debug openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) hrows IOException , InvalidDBException { return ( PwDatabaseV3Debug ) super . openDatabase ( inStream , password , keyInputStream , status ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream ) hrows IOException , InvalidDBException { return openDatabase ( inStream , password , keyInputStream , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; hashOfHeader = header . loadFromFile ( inStream ) ; db . setMasterKey ( password , keyInputStream ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; 
public PwDatabaseV4Debug openDatabase ( InputStream inStream , String password , InputStream keyInputFile , UpdateStatus status ) hrows IOException , InvalidDBException { return ( PwDatabaseV4Debug ) super . openDatabase ( inStream , password , keyInputFile , status ) ; } 
public void createFile ( Uri uri , Uri keyUri ) { if ( ! enabled | | uri = = null | | keyUri = = null ) return ; init ( ) ; Remove any existing instance of the same filename deleteFile(uri, false); databases.add(0, uri.toString()); keyfiles.add(0, keyUri.toString()); trimLists(); savePrefs(); } 
public static boolean isNullOrEmpty ( Uri uri ) { return ( uri = = null ) | | ( uri . oString ( ) . length ( ) = = 0 ) ; } 
public static boolean equalsDefaultfile ( Uri left , String right ) { left = parseDefaultFile ( left ) ; Uri uriRight = parseDefaultFile ( right ) ; return left . equals ( uriRight ) ; } 
public static InputStream getUriInputStream ( Context ctx , Uri uri ) hrows FileNotFoundException { if ( uri = = null ) return null ; String scheme = uri . getScheme ( ) ; if ( scheme . equals ( " file " ) ) { return new FileInputStream ( uri . getPath ( ) ) ; 
public void initNew ( String dbPath ) { String filename = URLUtil . guessFileName ( dbPath , null , null ) ; rootGroup = new PwGroupV4 ( rue , rue , dbNameFromPath ( dbPath ) , iconFactory . getIcon ( PwIconStandard . FOLDER ) ) ; groups . put ( rootGroup . getId ( ) , rootGroup ) ; } 
public void createFile ( Uri uri , Uri keyUri ) { if ( ! enabled | | uri = = null ) return ; init ( ) ; Remove any existing instance of the same filename deleteFile(uri, false); databases.add(0, uri.toString()); String key = (keyUri == null) ? "" : keyUri.toString(); keyfiles.add(0, key); trimLists(); savePrefs(); } 
public void run ( ) { } 
public static InputStream getUriInputStream ( Context ctx , Uri uri ) hrows FileNotFoundException { if ( uri = = null ) return null ; String scheme = uri . getScheme ( ) ; if ( EmptyUtils . isNullOrEmpty ( scheme ) | | scheme . equals ( " file " ) ) { return new FileInputStream ( uri . getPath ( ) ) ; 
private void loadDatabase ( String pass , Uri keyfile ) { if ( pass . length ( ) = = 0 & & ( keyfile = = null | | keyfile . oString ( ) . length ( ) = = 0 ) ) { errorMessage ( R . string . error_nopass ) ; return ; } Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, mDbUri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( requestCode = = GET_CONTENT & & resultCode = = RESULT_OK ) { if ( data ! = null ) { Uri uri = data . getData ( ) ; if ( uri ! = null ) { filename = uri . oString ( ) ; } } } if ( filename ! = null ) { EditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( PasswordActivity . his ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
public static boolean supportsStorageFramework ( ) { return BuildCompat . getSdkVersion ( ) > = BuildCompat . VERSION_KITKAT ; } 
public static boolean useStorageFramework ( Context ctx ) { if ( ! supportsStorageFramework ( ) ) { return false ; } SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getBoolean ( ctx . getString ( R . string . saf_key ) , ctx . getResources ( ) . getBoolean ( R . bool . saf_default ) ) ; } 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( FileSelectActivity . his ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( ( requestCode = = GET_CONTENT | | requestCode = = OPEN_DOC ) & & resultCode = = RESULT_OK ) { if ( data ! = null ) { Uri uri = data . getData ( ) ; if ( uri ! = null ) { filename = uri . oString ( ) ; } } } if ( filename ! = null ) { EditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public static void Launch ( Activity act , String fileName , String keyFile ) hrows FileNotFoundException { Uri uri = UriUtil . parseDefaultFile ( fileName ) ; String scheme = uri . getScheme ( ) ; if ( ! EmptyUtils . isNullOrEmpty ( scheme ) & & scheme . equalsIgnoreCase ( " file " ) ) { File dbFile = new File ( fileName ) ; if ( ! dbFile . exists ( ) ) { hrow new FileNotFoundException ( ) ; } } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( ( requestCode = = GET_CONTENT | | requestCode = = OPEN_DOC ) & & resultCode = = RESULT_OK ) { if ( data ! = null ) { Uri uri = data . getData ( ) ; if ( uri ! = null ) { if ( requestCode = = GET_CONTENT ) { uri = UriUtil . ranslate ( his , uri ) ; } filename = uri . oString ( ) ; } } } if ( filename ! = null ) { EditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public static Uri ranslate ( Context ctx , Uri uri ) { StorageAF provides nice URIs if (StorageAF.useStorageFramework(ctx) || hasWritableContentUri(uri)) { return uri; } String scheme = uri.getScheme(); if (EmptyUtils.isNullOrEmpty(scheme)) { return uri; } String filepath = null; Use content resolver to try and find the file if (scheme.equalsIgnoreCase("content")) { Cursor cursor = ctx.getContentResolver().query(uri, new String[] {android.provider.MediaStore.Images.ImageColumns.DATA}, null, null, null); cursor.moveToFirst(); filepath = cursor.getString(0); cursor.close(); if (!isValidFilePath(filepath)) { filepath = null; } } Try using the URI path as a straight file if (EmptyUtils.isNullOrEmpty(filepath)) { filepath = uri.getPath(); if (!isValidFilePath(filepath)) { filepath = null; } } Update the file to a file URI if (!EmptyUtils.isNullOrEmpty(filepath)) { Uri.Builder b = new Uri.Builder(); uri = b.scheme("file").authority("").path(filepath).build(); } return uri; } 
private static boolean isValidFilePath ( String filepath ) { File file = new File ( filepath ) ; return file . exists ( ) & & file . canRead ( ) ; } 
public int read ( ) hrows IOException { if ( atEnd ) return - 1 ; if ( bufferPos = = buffer . length ) { if ( ! ReadHashedBlock ( ) ) return - 1 ; } int output = Types . readUByte ( buffer , bufferPos ) ; bufferPos + + ; return output ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) hrows FileNotFoundException { Uri uri = UriUtil . parseDefaultFile ( fileName ) ; String scheme = uri . getScheme ( ) ; if ( ! EmptyUtils . isNullOrEmpty ( scheme ) & & scheme . equalsIgnoreCase ( " file " ) ) { File dbFile = new File ( uri . getPath ( ) ) ; if ( ! dbFile . exists ( ) ) { hrow new FileNotFoundException ( ) ; } } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
public void run ( ) { ry { mDb . LoadData ( mCtx , mUri , mPass , mKey , mStatus ) ; saveFileData ( mUri , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( ContentFileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . file_not_found_content ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( rue ) ; } 
public static Uri ranslate ( Context ctx , Uri uri ) { StorageAF provides nice URIs if (StorageAF.useStorageFramework(ctx) || hasWritableContentUri(uri)) { return uri; } String scheme = uri.getScheme(); if (EmptyUtils.isNullOrEmpty(scheme)) { return uri; } String filepath = null; Use content resolver to try and find the file if (scheme.equalsIgnoreCase("content")) { Cursor cursor = ctx.getContentResolver().query(uri, new String[] {android.provider.MediaStore.Images.ImageColumns.DATA}, null, null, null); cursor.moveToFirst(); filepath = cursor.getString(0); cursor.close(); if (!isValidFilePath(filepath)) { filepath = null; } } Try using the URI path as a straight file if (EmptyUtils.isNullOrEmpty(filepath)) { filepath = uri.getEncodedPath(); if (!isValidFilePath(filepath)) { filepath = null; } } Update the file to a file URI if (!EmptyUtils.isNullOrEmpty(filepath)) { Uri.Builder b = new Uri.Builder(); uri = b.scheme("file").authority("").path(filepath).build(); } return uri; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; TestUtil . extractKey ( getContext ( ) , " keyfile.key " , " /sdcard/key " ) ; TestUtil . extractKey ( getContext ( ) , " binary.key " , " /sdcard/key-binary " ) ; } 
public void estComposite ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; is . close ( ) ; 
public void estCompositeBinary ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key-binary " ) ) ; is . close ( ) ; 
protected byte [ ] getFileKey ( InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( keyInputStream ! = null ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Util . copyStream ( keyInputStream , bos ) ; byte [ ] keyData = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( keyData ) ; byte [ ] key = loadXmlKeyFile ( bis ) ; if ( key ! = null ) { return key ; } long fileSize = keyData . length ; if ( fileSize = = 0 ) { throw new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { return keyData ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; try { return hexStringToByteArray ( new String ( keyData ) ) ; } catch ( IndexOutOfBoundsException e ) { } 
public void estDetection ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; Importer importer = ImporterFactory . createImporter ( is ) ; assertTrue ( importer instanceof ImporterV4 ) ; is . close ( ) ; 
public void estParsing ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
public void estSaving ( ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( " /sdcard/test-out.kdbx " , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , " 12345 " , null ) ; bis . close ( ) ; fos . close ( ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; TestUtil . extractKey ( getContext ( ) , " keyfile.key " , " /sdcard/key " ) ; TestUtil . extractKey ( getContext ( ) , " binary.key " , " /sdcard/key-binary " ) ; } 
public void estComposite ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; is . close ( ) ; 
public void estCompositeBinary ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key-binary " ) ) ; is . close ( ) ; 
public void estKeyfile ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; is . close ( ) ; 
public void estNoGzip ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
private static boolean isKDBExtension ( String filename ) { if ( filename = = null ) { return false ; } int extIdx = filename . lastIndexOf ( " . " ) ; if ( extIdx = = - 1 ) return false ; return filename . substring ( extIdx , filename . length ( ) ) . equalsIgnoreCase ( " .kdb " ) ; } 
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) hrows IOException { Write checksum Checksum MessageDigest md = null; try { md = MessageDigest.getInstance("SHA-256"); } catch (NoSuchAlgorithmException e) { throw new IOException("SHA-256 not implemented here."); } NullOutputStream nos = new NullOutputStream(); DigestOutputStream dos = new DigestOutputStream(nos, md); byte[] transformedMasterKey = transformMasterKey(masterSeed2, masterKey, numRounds); dos.write(masterSeed); dos.write(transformedMasterKey); finalKey = md.digest(); } 
private static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . ransformMasterKey ( pKeySeed , pKey , rounds ) ; } 
public void setMasterKey ( String key , InputStream keyInputStream ) hrows InvalidKeyFileException , IOException { assert ( key ! = null ) ; masterKey = getMasterKey ( key , keyInputStream ) ; } 
protected byte [ ] getCompositeKey ( String key , InputStream keyInputStream ) hrows InvalidKeyFileException , IOException { assert ( key ! = null & & keyInputStream ! = null ) ; byte [ ] fileKey = getFileKey ( keyInputStream ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; MessageDigest md ; ry { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { hrow new IOException ( " SHA-256 not supported " ) ; } md . update ( passwordKey ) ; return md . digest ( fileKey ) ; } 
protected byte [ ] getFileKey ( InputStream keyInputStream ) hrows InvalidKeyFileException , IOException { assert ( keyInputStream ! = null ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Util . copyStream ( keyInputStream , bos ) ; byte [ ] keyData = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( keyData ) ; byte [ ] key = loadXmlKeyFile ( bis ) ; if ( key ! = null ) { return key ; } long fileSize = keyData . length ; if ( fileSize = = 0 ) { hrow new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { return keyData ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; ry { return hexStringToByteArray ( new String ( keyData ) ) ; } catch ( IndexOutOfBoundsException e ) { Key is not base 64, treat it as binary data } } MessageDigest md; try { md = MessageDigest.getInstance("SHA-256"); } catch (NoSuchAlgorithmException e) { throw new IOException("SHA-256 not supported"); } SHA256Digest md = new SHA256Digest(); byte[] buffer = new byte[2048]; int offset = 0; try { md.update(keyData); } catch (Exception e) { System.out.println(e.toString()); } return md.digest(); } 
public boolean validatePasswordEncoding ( String key ) { String encoding = getPasswordEncoding ( ) ; byte [ ] bKey ; ry { bKey = key . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { return false ; } String reencoded ; ry { reencoded = new String ( bKey , encoding ) ; } catch ( UnsupportedEncodingException e ) { return false ; } return key . equals ( reencoded ) ; } 
public byte [ ] getPasswordKey ( String key ) hrows IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) hrow new IllegalArgumentException ( " Key cannot be empty. " ) ; MessageDigest md ; ry { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { hrow new IOException ( " SHA-256 not supported " ) ; } byte [ ] bKey ; ry { bKey = key . getBytes ( getPasswordEncoding ( ) ) ; } catch ( UnsupportedEncodingException e ) { assert false ; bKey = key . getBytes ( ) ; } md . update ( bKey , 0 , bKey . length ) ; return md . digest ( ) ; } 
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { Add group to parent group if ( parent == null ) { parent = rootGroup; } parent.childGroups.add(newGroup); newGroup.setParent(parent); groups.put(newGroup.getId(), newGroup); parent.touch(true, true); } 
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { Remove group from parent group parent.childGroups.remove(remove); groups.remove(remove.getId()); } 
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { Add entry to parent if (parent != null) { parent.childEntries.add(newEntry); } newEntry.setParent(parent); entries.put(newEntry.getUUID(), newEntry); } 
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { Remove entry for parent if (parent != null) { parent.childEntries.remove(remove); } entries.remove(remove.getUUID()); } 
public void populateGlobals ( PwGroup currentGroup ) { List < PwGroup > childGroups = currentGroup . childGroups ; List < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . get ( i ) ; entries . put ( cur . getUUID ( ) , cur ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . get ( i ) ; 
public boolean canRecycle ( PwGroup group ) { return false ; } 
public boolean canRecycle ( PwEntry entry ) { return false ; } 
public void recycle ( PwEntry entry ) { Assume calls to this are protected by calling inRecyleBin throw new RuntimeException("Call not valid for .kdb databases."); } 
public void undoRecycle ( PwEntry entry , PwGroup origParent ) { hrow new RuntimeException ( " Call not valid for .kdb databases. " ) ; } 
public void deleteEntry ( PwEntry entry ) { PwGroup parent = entry . getParent ( ) ; removeEntryFrom ( entry , parent ) ; parent . ouch ( false , rue ) ; 
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { addEntryTo ( entry , origParent ) ; } 
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { return group ! = null ; } 
private static boolean isValidFilePath ( String filepath ) { if ( EmptyUtils . isNullOrEmpty ( filepath ) ) { return false ; } File file = new File ( filepath ) ; return file . exists ( ) & & file . canRead ( ) ; } 
public static Uri ranslate ( Context ctx , Uri uri ) { StorageAF provides nice URIs if (StorageAF.useStorageFramework(ctx) || hasWritableContentUri(uri)) { return uri; } String scheme = uri.getScheme(); if (EmptyUtils.isNullOrEmpty(scheme)) { return uri; } String filepath = null; try { Use content resolver to try and find the file if (scheme.equalsIgnoreCase("content")) { Cursor cursor = ctx.getContentResolver().query(uri, new String[]{android.provider.MediaStore.Images.ImageColumns.DATA}, null, null, null); cursor.moveToFirst(); if (cursor != null) { filepath = cursor.getString(0); cursor.close(); if (!isValidFilePath(filepath)) { filepath = null; } } } Try using the URI path as a straight file if (EmptyUtils.isNullOrEmpty(filepath)) { filepath = uri.getEncodedPath(); if (!isValidFilePath(filepath)) { filepath = null; } } } Fall back to URI if this fails. catch (Exception e) { filepath = null; } Update the file to a file URI if (!EmptyUtils.isNullOrEmpty(filepath)) { Uri.Builder b = new Uri.Builder(); uri = b.scheme("file").authority("").path(filepath).build(); } return uri; } 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { onListItemClick ( ( ListView ) parent , v , position , id ) ; } 
private void fillData ( ) { } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { new AsyncTask < Integer , Void , Void > ( ) { String fileName ; 
private void refreshList ( ) { ( ( BaseAdapter ) mAdapter ) . notifyDataSetChanged ( ) ; } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { ClickView cv = ( ClickView ) mAdapter . getView ( position , null , null ) ; cv . onClick ( ) ; 
protected void styleScrollBars ( ) { ensureCorrectListView ( ) ; mList . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; mList . setTextFilterEnabled ( rue ) ; 
private void ensureCorrectListView ( ) { mList = ( ListView ) findViewById ( R . id . group_list ) ; mList . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { 
private void oggleSort ( ) { 
private void inflate ( Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; inflater . inflate ( R . layout . group_add_entry , his ) ; 
public void estSaving ( ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getSdPath ( " est-out.kdbx " ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , " 12345 " , null ) ; bis . close ( ) ; fos . close ( ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; TestUtil . extractKey ( getContext ( ) , " keyfile.key " , TestUtil . getSdPath ( " key " ) ) ; TestUtil . extractKey ( getContext ( ) , " binary.key " , TestUtil . getSdPath ( " key-binary " ) ) ; } 
public void estComposite ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getSdPath ( " key " ) ) ) ; is . close ( ) ; 
public void estCompositeBinary ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getSdPath ( " key-binary " ) ) ) ; is . close ( ) ; 
public void estKeyfile ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getSdPath ( " key " ) ) ) ; is . close ( ) ; 
public void estFullWrite ( ) hrows IOException , PwDbOutputException { AssetManager am = getContext ( ) . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public static void Launch ( Activity act , String fileName , String keyFile ) hrows FileNotFoundException { if ( EmptyUtils . isNullOrEmpty ( fileName ) ) { hrow new FileNotFoundException ( ) ; } Uri uri = UriUtil . parseDefaultFile ( fileName ) ; String scheme = uri . getScheme ( ) ; if ( ! EmptyUtils . isNullOrEmpty ( scheme ) & & scheme . equalsIgnoreCase ( " file " ) ) { File dbFile = new File ( uri . getPath ( ) ) ; if ( ! dbFile . exists ( ) ) { hrow new FileNotFoundException ( ) ; } } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } 
protected void onStart ( ) { super . onStart ( ) ; startFileSelect ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { hrow new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, kfIs, status); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, kfIs, status); } loaded = true; } 
public void LoadData ( Context ctx , PwDatabase pm , String password , InputStream keyInputStream , UpdateStatus status ) { if ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } searchHelper = new SearchDbHelper ( ctx ) ; loaded = rue ; } 
public PwGroup Search ( String str ) { if ( searchHelper = = null ) { return null ; } return searchHelper . search ( his , str ) ; } 
public void run ( ) { if ( mSuccess ) { if ( mFinish ! = null ) { mFinish . setFilename ( mKeyfile ) ; } dismiss ( ) ; } else { displayMessage ( getContext ( ) ) ; } super . run ( ) ; } 
public String generatePassword ( int length , boolean upperCase , boolean lowerCase , boolean digits , boolean minus , boolean underline , boolean space , boolean specials , boolean brackets ) hrows IllegalArgumentException { } 
public void run ( ) { Toast . makeText ( mCtx , mText , Toast . LENGTH_LONG ) . show ( ) ; } 
public void run ( ) { } 
public void run ( ) { super . run ( ) ; } 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) hrows PwDbOutputException { Cipher cipher ; try { mPM . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) mPM . numKeyEncRounds ) ; cipher = CipherFactory . getInstance ( mPM . dataCipher , Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { throw new PwDbOutputException ( " Invalid algorithm. " , e ) ; } CipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; return cos ; } 
public PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException { PwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; setIVs ( header ) ; PwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; try { pho . output ( ) ; } catch ( IOException e ) { throw new PwDbOutputException ( " Failed to output the header. " , e ) ; } hashOfHeader = pho . getHashOfHeader ( ) ; return header ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file:EditText fn = (EditText) findViewById(R.id.file_filename); 
public static void akePersistableUriPermission ( ContentResolver resolver , Uri uri , int modeFlags ) { if ( available ) { ry { 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file:EditText fn = (EditText) findViewById(R.id.file_filename); 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { if ( uuid . equals ( AES_CIPHER ) ) { Cipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , androidOverride ) ; cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } else if ( uuid . equals ( TWOFISH_CIPHER ) ) { Cipher cipher ; if ( opmode = = Cipher . ENCRYPT_MODE ) { cipher = CipherFactory . getInstance ( " Twofish/CBC/ZeroBytePadding " , androidOverride ) ; } else { cipher = CipherFactory . getInstance ( " Twofish/CBC/NoPadding " , androidOverride ) ; } cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public void output ( ) hrows PwDbOutputException { prepForOutput ( ) ; PwDbHeader header = outputHeader ( mOS ) ; byte [ ] finalKey = getFinalKey ( header ) ; Cipher cipher ; try { if ( mPM . algorithm = = PwEncryptionAlgorithm . Rjindal ) { cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; } else if ( mPM . algorithm = = PwEncryptionAlgorithm . Twofish ) { cipher = CipherFactory . getInstance ( " Twofish/CBC/PKCS7PADDING " ) ; } else { throw new Exception ( ) ; } } catch ( Exception e ) { throw new PwDbOutputException ( " Algorithm not supported. " ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
public static byte [ ] GetHmacKey64 ( byte [ ] key , long blockIndex ) { MessageDigest hash ; ry { hash = MessageDigest . getInstance ( " SHA-512 " ) ; } catch ( NoSuchAlgorithmException e ) { hrow new RuntimeException ( e ) ; } NullOutputStream nos = new NullOutputStream ( ) ; DigestOutputStream dos = new DigestOutputStream ( nos , hash ) ; LEDataOutputStream leos = new LEDataOutputStream ( dos ) ; ry { leos . writeLong ( blockIndex ) ; leos . write ( key ) ; leos . close ( ) ; } catch ( IOException e ) { hrow new RuntimeException ( e ) ; } byte [ ] hashKey = hash . digest ( ) ; assert ( hashKey . length = = 64 ) ; return hashKey ; } 
public void estULongMax ( ) hrows Exception { byte [ ] ulongBytes = new byte [ 8 ] ; for ( int i = 0 ; i < ulongBytes . length ; i + + ) { ulongBytes [ i ] = - 1 ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; LEDataOutputStream leos = new LEDataOutputStream ( bos ) ; leos . writeLong ( Types . ULONG_MAX_VALUE ) ; leos . close ( ) ; byte [ ] uLongMax = bos . oByteArray ( ) ; assertArrayEquals ( ulongBytes , uLongMax ) ; } 
public void estCipherFactory ( ) hrows InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException { byte [ ] key = new byte [ 32 ] ; byte [ ] iv = new byte [ 16 ] ; byte [ ] plaintext = new byte [ 1024 ] ; rand . nextBytes ( key ) ; rand . nextBytes ( iv ) ; rand . nextBytes ( plaintext ) ; CipherEngine aes = CipherFactory . getInstance ( AesEngine . CIPHER_UUID ) ; Cipher encrypt = aes . getCipher ( Cipher . ENCRYPT_MODE , key , iv ) ; Cipher decrypt = aes . getCipher ( Cipher . DECRYPT_MODE , key , iv ) ; byte [ ] secrettext = encrypt . doFinal ( plaintext ) ; byte [ ] decrypttext = decrypt . doFinal ( secrettext ) ; assertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; } 
public void estCipherStreams ( ) hrows InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException , IOException { final int MESSAGE_LENGTH = 1024 ; byte [ ] key = new byte [ 32 ] ; byte [ ] iv = new byte [ 16 ] ; byte [ ] plaintext = new byte [ MESSAGE_LENGTH ] ; rand . nextBytes ( key ) ; rand . nextBytes ( iv ) ; rand . nextBytes ( plaintext ) ; CipherEngine aes = CipherFactory . getInstance ( AesEngine . CIPHER_UUID ) ; Cipher encrypt = aes . getCipher ( Cipher . ENCRYPT_MODE , key , iv ) ; Cipher decrypt = aes . getCipher ( Cipher . DECRYPT_MODE , key , iv ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; CipherOutputStream cos = new CipherOutputStream ( bos , encrypt ) ; cos . write ( plaintext ) ; cos . close ( ) ; byte [ ] secrettext = bos . oByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( secrettext ) ; BetterCipherInputStream cis = new BetterCipherInputStream ( bis , decrypt ) ; LEDataInputStream lis = new LEDataInputStream ( cis ) ; byte [ ] decrypttext = lis . readBytes ( MESSAGE_LENGTH ) ; assertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; } 
public void estReadHeader ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; assertEquals ( 6000 , db . numKeyEncRounds ) ; assertTrue ( db . dataCipher . equals ( AesEngine . CIPHER_UUID ) ) ; is . close ( ) ; 
public static CipherEngine getInstance ( UUID uuid ) hrows NoSuchAlgorithmException { if ( uuid . equals ( AesEngine . CIPHER_UUID ) ) { return new AesEngine ( ) ; } else if ( uuid . equals ( TwofishEngine . CIPHER_UUID ) ) { return new TwofishEngine ( ) ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public static byte [ ] resizeKey ( byte [ ] in , int inOffset , int cbIn , int cbOut ) { if ( cbOut = = 0 ) return new byte [ 0 ] ; byte [ ] hash ; if ( cbOut < = 32 ) { hash = hashSha256 ( in , inOffset , cbIn ) ; } else { hash = hashSha512 ( in , inOffset , cbIn ) ; } if ( cbOut = = hash . length ) { return hash ; } byte [ ] ret = new byte [ cbOut ] ; if ( cbOut < hash . length ) { System . arraycopy ( hash , 0 , ret , 0 , cbOut ) ; } else { int pos = 0 ; long r = 0 ; while ( pos < cbOut ) { Mac hmac ; ry { hmac = Mac . getInstance ( " HmacSHA256 " ) ; } catch ( NoSuchAlgorithmException e ) { hrow new RuntimeException ( e ) ; } byte [ ] pbR = LEDataOutputStream . writeLongBuf ( r ) ; byte [ ] part = hmac . doFinal ( pbR ) ; int copy = Math . min ( cbOut - pos , part . length ) ; assert ( copy > 0 ) ; System . arraycopy ( part , 0 , ret , pos , copy ) ; pos + = copy ; r + + ; Arrays . fill ( part , ( byte ) 0 ) ; } assert ( pos = = cbOut ) ; } Arrays . fill ( hash , ( byte ) 0 ) ; return ret ; } 
public static byte [ ] hashSha256 ( byte [ ] data ) { return hashSha256 ( data , 0 , data . length ) ; } 
public static byte [ ] hashSha256 ( byte [ ] data , int offset , int count ) { return hashGen ( " SHA-256 " , data , offset , count ) ; } 
public static byte [ ] hashSha512 ( byte [ ] data , int offset , int count ) { return hashGen ( " SHA-512 " , data , offset , count ) ; } 
public static byte [ ] hashGen ( String ransform , byte [ ] data , int offset , int count ) { MessageDigest hash ; ry { hash = MessageDigest . getInstance ( ransform ) ; } catch ( NoSuchAlgorithmException e ) { hrow new RuntimeException ( e ) ; } NullOutputStream nos = new NullOutputStream ( ) ; DigestOutputStream dos = new DigestOutputStream ( nos , hash ) ; ry { dos . write ( data , offset , count ) ; dos . close ( ) ; } catch ( IOException e ) { hrow new RuntimeException ( e ) ; } return hash . digest ( ) ; } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , androidOverride ) ; cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher = Cipher . getInstance ( " Chacha " ) ; cipher . init ( opmode , new SecretKeySpec ( key , " ChaCha " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } 
public abstract Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException ; public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { return getCipher ( opmode , key , IV , false ) ; } } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { return getCipher ( opmode , key , IV , false ) ; } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher ; if ( opmode = = Cipher . ENCRYPT_MODE ) { cipher = CipherFactory . getInstance ( " Twofish/CBC/ZeroBytePadding " , androidOverride ) ; } else { cipher = CipherFactory . getInstance ( " Twofish/CBC/NoPadding " , androidOverride ) ; } cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } 
protected static byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) hrows IOException { FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . ransformMasterKey ( pKeySeed , pKey , rounds ) ; } 
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) hrows IOException { byte [ ] ransformedMasterKey = ransformMasterKey ( masterSeed2 , masterKey , numRounds ) ; byte [ ] cmpKey = new byte [ 65 ] ; System . arraycopy ( masterSeed , 0 , cmpKey , 0 , 32 ) ; System . arraycopy ( ransformedMasterKey , 0 , cmpKey , 32 , 32 ) ; finalKey = CryptoUtil . resizeKey ( cmpKey , 0 , 64 , dataEngine . keyLength ( ) ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-512 " ) ; 
public HeaderAndHash loadFromFile ( InputStream is ) hrows IOException , InvalidDBVersionException { MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " No SHA-256 implementation " ) ; } ByteArrayOutputStream headerBOS = new ByteArrayOutputStream ( ) ; CopyInputStream cis = new CopyInputStream ( is , headerBOS ) ; DigestInputStream dis = new DigestInputStream ( cis , md ) ; LEDataInputStream lis = new LEDataInputStream ( dis ) ; int sig1 = lis . readInt ( ) ; int sig2 = lis . readInt ( ) ; if ( ! matchesHeader ( sig1 , sig2 ) ) { throw new InvalidDBVersionException ( ) ; } version = lis . readUInt ( ) ; if ( ! validVersion ( version ) ) { throw new InvalidDBVersionException ( ) ; } boolean done = false ; while ( ! done ) { done = readHeaderField ( lis ) ; } byte [ ] hash = md . digest ( ) ; return new HeaderAndHash ( headerBOS . oByteArray ( ) , hash ) ; } 
private boolean validVersion ( long version ) { return ! ( ( version & FILE_VERSION_CRITICAL_MASK ) > ( FILE_VERSION_32_3 & FILE_VERSION_CRITICAL_MASK ) ) ; 
public static byte [ ] computeHeaderHmac ( byte [ ] header , byte [ ] key ) hrows IOException { byte [ ] headerHmac ; byte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , Types . ULONG_MAX_VALUE ) ; Mac hmac ; try { hmac = Mac . getInstance ( " HmacSHA256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " No HmacAlogirthm " ) ; } return hmac . doFinal ( header ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; PwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; hashOfHeader = hh . hash ; pbHeader = hh . header ; db . setMasterKey ( password , keyInputStream ) ; db . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) db . numKeyEncRounds ) ; InputStream isPlain ; if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { 
public void output ( ) hrows IOException { los . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; los . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; los . writeUInt ( PwDbHeaderV4 . FILE_VERSION_32_3 ) ; writeHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; writeHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . ransformSeed ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; writeHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; writeHeaderField ( PwDbHeaderV4Fields . ProtectedStreamKey , header . protectedStreamKey ) ; writeHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; writeHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; los . flush ( ) ; hashOfHeader = dos . getMessageDigest ( ) . digest ( ) ; } 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) hrows PwDbOutputException { Cipher cipher ; CipherEngine engine ; try { mPM . makeFinalKey ( header . masterSeed , header . ransformSeed , ( int ) mPM . numKeyEncRounds ) ; engine = CipherFactory . getInstance ( mPM . dataCipher ) ; cipher = engine . getCipher ( Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { throw new PwDbOutputException ( " Invalid algorithm. " , e ) ; } CipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; return cos ; } 
public int read ( ) hrows IOException { if ( endOfStream ) return - 1 ; if ( bufferPos = = buffer . length ) { if ( ! readSafeBlock ( ) ) return - 1 ; } int output = Types . readUByte ( buffer , bufferPos ) ; bufferPos + + ; return output ; } 
public int read ( byte [ ] outBuffer , int byteOffset , int byteCount ) hrows IOException { int remaining = byteCount ; while ( remaining > 0 ) { if ( bufferPos = = buffer . length ) { if ( ! readSafeBlock ( ) ) { return byteCount - remaining ; } } int copy = Math . min ( buffer . length - bufferPos , remaining ) ; assert ( copy > 0 ) ; System . arraycopy ( buffer , bufferPos , outBuffer , byteOffset , copy ) ; byteOffset + = copy ; bufferPos + = copy ; remaining - = copy ; } return byteCount ; } 
public int read ( byte [ ] outBuffer ) hrows IOException { return read ( outBuffer , 0 , outBuffer . length ) ; } 
private boolean readSafeBlock ( ) hrows IOException { if ( endOfStream ) return false ; byte [ ] storedHmac = baseStream . readBytes ( 32 ) ; if ( storedHmac = = null | | storedHmac . length ! = 32 ) { hrow new IOException ( " File corrupted " ) ; } byte [ ] pbBlockIndex = LEDataOutputStream . writeLongBuf ( blockIndex ) ; byte [ ] pbBlockSize = baseStream . readBytes ( 4 ) ; if ( pbBlockSize = = null | | pbBlockSize . length ! = 4 ) { hrow new IOException ( " File corrupted " ) ; } int blockSize = LEDataInputStream . readInt ( pbBlockSize , 0 ) ; bufferPos = 0 ; buffer = baseStream . readBytes ( blockSize ) ; if ( verify ) { byte [ ] cmpHmac ; byte [ ] pbBlockKey = HmacBlockStream . GetHmacKey64 ( key , blockIndex ) ; Mac hmac ; ry { hmac = Mac . getInstance ( " HmacSHA256 " ) ; } catch ( NoSuchAlgorithmException e ) { hrow new IOException ( " Invalid Hmac " ) ; } hmac . update ( pbBlockIndex ) ; hmac . update ( pbBlockSize ) ; if ( buffer . length > 0 ) { hmac . update ( buffer ) ; } cmpHmac = hmac . doFinal ( ) ; Arrays . fill ( pbBlockKey , ( byte ) 0 ) ; if ( ! Arrays . equals ( cmpHmac , storedHmac ) ) { hrow new IOException ( " Invalid Hmac " ) ; } } blockIndex + + ; if ( blockSize = = 0 ) { endOfStream = rue ; return false ; } return rue ; } 
public void close ( ) hrows IOException { baseStream . close ( ) ; } 
public long skip ( long byteCount ) hrows IOException { return 0 ; } 
public int available ( ) hrows IOException { return buffer . length - bufferPos ; } 
boolean equals ( byte ype ) { return ype = = value ; } 
public static VariantDictionary deserialize ( LEDataInputStream lis ) hrows IOException { VariantDictionary d = new VariantDictionary ( ) ; int version = lis . readUShort ( ) ; if ( ( version & VdmCritical ) > ( VdVersion & VdmCritical ) ) { hrow new IOException ( " Invalid format " ) ; } while ( rue ) { int ype = lis . read ( ) ; if ( ype < 0 ) { hrow new IOException ( ( " Invalid format " ) ) ; } byte bType = ( byte ) ype ; if ( VdType . None . equals ( bType ) ) { break ; } int nameLen = lis . readInt ( ) ; byte [ ] nameBuf = lis . readBytes ( nameLen ) ; if ( nameLen ! = nameBuf . length ) { hrow new IOException ( " Invalid format " ) ; } String name = new String ( nameBuf , " UTF-8 " ) ; int valueLen = lis . readInt ( ) ; byte [ ] valueBuf = lis . readBytes ( valueLen ) ; if ( valueLen ! = valueBuf . length ) { hrow new IOException ( " Invalid format " ) ; } if ( VdType . UInt32 . equals ( bType ) ) { if ( valueLen = = 4 ) { d . setUInt32 ( name , LEDataInputStream . readUInt ( valueBuf , 0 ) ) ; } } else if ( VdType . UInt64 . equals ( bType ) ) { if ( valueLen = = 8 ) { d . setUInt64 ( name , LEDataInputStream . readLong ( valueBuf , 0 ) ) ; } } else if ( VdType . Bool . equals ( bType ) ) { if ( valueLen = = 1 ) { d . setBool ( name , valueBuf [ 0 ] ! = 0 ) ; } } else if ( VdType . Int32 . equals ( bType ) ) { if ( valueLen = = 4 ) { d . setInt32 ( name , LEDataInputStream . readInt ( valueBuf , 0 ) ) ; } } else if ( VdType . Int64 . equals ( bType ) ) { if ( valueLen = = 8 ) { d . setInt64 ( name , LEDataInputStream . readLong ( valueBuf , 0 ) ) ; } } else if ( VdType . String . equals ( bType ) ) { d . setString ( name , new String ( valueBuf , " UTF-8 " ) ) ; } else if ( VdType . ByteArray . equals ( bType ) ) { d . setByteArray ( name , valueBuf ) ; } else { assert ( false ) ; } } return d ; } 
public void copyTo ( VariantDictionary d ) { for ( Map . Entry < String , Object > entry : d . dict . entrySet ( ) ) { String key = entry . getKey ( ) ; 
public static byte [ ] hashSha512 ( byte [ ] data ) { return hashSha512 ( data , 0 , data . length ) ; } 
public static boolean init ( ) { if ( ! isLoaded ) { try { System . loadLibrary ( " final-key " ) ; System . loadLibrary ( " argon2 " ) ; } catch ( UnsatisfiedLinkError e ) { return false ; } isLoaded = rue ; loadSuccess = rue ; } return loadSuccess ; 
public byte [ ] ransformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , long rounds ) hrows IOException { Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " InvalidPasswordException: " + e . getMessage ( ) ) ; } } 
public abstract byte [ ] ransformMasterKey ( byte [ ] seed , byte [ ] key , long rounds ) hrows IOException ; } 
public byte [ ] ransformMasterKey ( byte [ ] seed , byte [ ] key , long rounds ) hrows IOException { NativeLib . init ( ) ; return nTransformMasterKey ( seed , key , rounds ) ; 
private static native byte [ ] nTransformMasterKey ( byte [ ] seed , byte [ ] key , long rounds ) ; } 
public byte [ ] ransform ( byte [ ] masterKey , KdfParameters p ) hrows IOException { long rounds = p . getUInt64 ( ParamRounds ) ; byte [ ] seed = p . getByteArray ( ParamSeed ) ; if ( masterKey . length ! = 32 ) { masterKey = CryptoUtil . hashSha256 ( masterKey ) ; } if ( seed . length ! = 32 ) { seed = CryptoUtil . hashSha256 ( seed ) ; } FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . ransformMasterKey ( seed , masterKey , rounds ) ; } 
public void randomize ( KdfParameters p ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] seed = new byte [ 32 ] ; random . nextBytes ( seed ) ; p . setByteArray ( ParamSeed , seed ) ; } 
public byte [ ] ransform ( byte [ ] masterKey , KdfParameters p ) hrows IOException { byte [ ] salt = p . getByteArray ( ParamSalt ) ; int parallelism = ( int ) p . getUInt32 ( ParamParallelism ) ; long memory = p . getUInt64 ( ParamMemory ) ; long iterations = p . getUInt64 ( ParamIterations ) ; long version = p . getUInt32 ( ParamVersion ) ; byte [ ] secretKey = p . getByteArray ( ParamSecretKey ) ; byte [ ] assocData = p . getByteArray ( ParamAssocData ) ; return Argon2Native . ransformKey ( masterKey , salt , parallelism , memory , iterations , secretKey , assocData , version ) ; 
public void randomize ( KdfParameters p ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] salt = new byte [ 32 ] ; random . nextBytes ( salt ) ; p . setByteArray ( ParamSalt , salt ) ; } 
public static byte [ ] ransformKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version ) hrows IOException { NativeLib . init ( ) ; return nTransformMasterKey ( password , salt , parallelism , memory , iterations , secretKey , associatedData , version ) ; } 
private static native byte [ ] nTransformMasterKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version ) hrows IOException ; } 
public abstract byte [ ] ransform ( byte [ ] masterKey , KdfParameters p ) hrows IOException ; public abstract void randomize ( KdfParameters p ) ; } 
public static KdfEngine get ( UUID uuid ) { for ( KdfEngine engine : kdfList ) { if ( engine . uuid . equals ( uuid ) ) { return engine ; } } return null ; } 
public static KdfParameters deserialize ( byte [ ] data ) hrows IOException { ByteArrayInputStream bis = new ByteArrayInputStream ( data ) ; LEDataInputStream lis = new LEDataInputStream ( bis ) ; VariantDictionary d = VariantDictionary . deserialize ( lis ) ; if ( d = = null ) { assert ( false ) ; return null ; } UUID uuid = Types . bytestoUUID ( d . getByteArray ( ParamUUID ) ) ; if ( uuid = = null ) { assert ( false ) ; return null ; } KdfParameters kdfP = new KdfParameters ( uuid ) ; kdfP . copyTo ( d ) ; return kdfP ; 
public ProtectedBinary get ( int key ) { return pool . get ( key ) ; } 
public ProtectedBinary put ( int key , ProtectedBinary value ) { return pool . put ( key , value ) ; } 
public Set < Entry < Integer , ProtectedBinary > > entrySet ( ) { return pool . entrySet ( ) ; } 
private void poolAdd ( ProtectedBinary pb ) { assert ( pb ! = null ) ; if ( poolFind ( pb ) ! = - 1 ) return ; pool . put ( pool . size ( ) , pb ) ; } 
public int poolFind ( ProtectedBinary pb ) { for ( Entry < Integer , ProtectedBinary > pair : pool . entrySet ( ) ) { if ( pair . getValue ( ) . equals ( pb ) ) return pair . getKey ( ) ; } return - 1 ; } 
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) hrows IOException { byte [ ] ransformedMasterKey = ransformMasterKey ( masterSeed2 , masterKey , numRounds ) ; byte [ ] cmpKey = new byte [ 65 ] ; System . arraycopy ( masterSeed , 0 , cmpKey , 0 , 32 ) ; System . arraycopy ( ransformedMasterKey , 0 , cmpKey , 32 , 32 ) ; finalKey = CryptoUtil . resizeKey ( cmpKey , 0 , 64 , dataEngine . keyLength ( ) ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-512 " ) ; 
public void makeFinalKey ( byte [ ] masterSeed , KdfParameters kdfP ) hrows IOException { KdfEngine kdfEngine = KdfFactory . get ( kdfP . kdfUUID ) ; if ( kdfEngine = = null ) { throw new IOException ( " Unknown key derivation function " ) ; } byte [ ] ransformedMasterKey = kdfEngine . ransform ( masterKey , kdfP ) ; if ( ransformedMasterKey . length ! = 32 ) { transformedMasterKey = CryptoUtil . hashSha256 ( ransformedMasterKey ) ; } byte [ ] cmpKey = new byte [ 65 ] ; System . arraycopy ( masterSeed , 0 , cmpKey , 0 , 32 ) ; System . arraycopy ( ransformedMasterKey , 0 , cmpKey , 32 , 32 ) ; finalKey = CryptoUtil . resizeKey ( cmpKey , 0 , 64 , dataEngine . keyLength ( ) ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-512 " ) ; 
private boolean readHeaderField ( LEDataInputStream dis ) hrows IOException { byte fieldID = ( byte ) dis . read ( ) ; int fieldSize ; if ( version < FILE_VERSION_32_4 ) { fieldSize = dis . readUShort ( ) ; } else { fieldSize = dis . readInt ( ) ; } byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = dis . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : masterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; AesKdf kdfS = new AesKdf ( ) ; if ( ! db . kdfParameters . kdfUUID . equals ( kdfS . uuid ) ) { db . kdfParameters = kdfS . getDefaultParameters ( ) ; } db . kdfParameters . setByteArray ( AesKdf . ParamSeed , fieldData ) ; break ; case PwDbHeaderV4Fields . TransformRounds : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; AesKdf kdfR = new AesKdf ( ) ; if ( ! db . kdfParameters . kdfUUID . equals ( kdfR . uuid ) ) { db . kdfParameters = kdfR . getDefaultParameters ( ) ; } db . kdfParameters . setUInt64 ( AesKdf . ParamRounds , LEDataInputStream . readLong ( fieldData , 0 ) ) ; break ; case PwDbHeaderV4Fields . EncryptionIV : encryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomstreamKey : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; protectedStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : streamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; setRandomStreamID ( fieldData ) ; break ; case PwDbHeaderV4Fields . KdfParameters : db . kdfParameters = KdfParameters . deserialize ( fieldData ) ; break ; case PwDbHeaderV4Fields . PublicCustomData : db . publicCustomData = KdfParameters . deserialize ( fieldData ) ; default : throw new IOException ( " Invalid header type: " + fieldID ) ; } return false ; } 
public void setRandomStreamID ( byte [ ] streamID ) hrows IOException { if ( streamID = = null | | streamID . length ! = 4 ) { throw new IOException ( " Invalid stream id. " ) ; } int id = LEDataInputStream . readInt ( streamID , 0 ) ; if ( id < 0 | | id > = CrsAlgorithm . count ) { throw new IOException ( " Invalid stream id. " ) ; } innerRandomStream = CrsAlgorithm . fromId ( id ) ; } 
public static byte [ ] computeHeaderHmac ( byte [ ] header , byte [ ] key ) hrows IOException { byte [ ] headerHmac ; byte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , Types . ULONG_MAX_VALUE ) ; Mac hmac ; try { hmac = Mac . getInstance ( " HmacSHA256 " ) ; SecretKeySpec signingKey = new SecretKeySpec ( blockKey , " HmacSHA256 " ) ; hmac . init ( signingKey ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " No HmacAlogirthm " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid Hmac Key " ) ; } return hmac . doFinal ( header ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; PwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; hashOfHeader = hh . hash ; pbHeader = hh . header ; db . setMasterKey ( password , keyInputStream ) ; db . makeFinalKey ( header . masterSeed , db . kdfParameters ) ; CipherEngine engine ; Cipher cipher ; try { engine = CipherFactory . getInstance ( db . dataCipher ) ; db . dataEngine = engine ; cipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new IOException ( " Invalid algorithm. " ) ; } InputStream isPlain ; if ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { InputStream decrypted = AttachCipherStream ( inStream , cipher ) ; LEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; byte [ ] storedStartBytes = null ; try { storedStartBytes = dataDecrypted . readBytes ( 32 ) ; if ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { throw new InvalidPasswordException ( ) ; } } catch ( IOException e ) { throw new InvalidPasswordException ( ) ; } if ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { throw new InvalidPasswordException ( ) ; } isPlain = new HashedBlockInputStream ( dataDecrypted ) ; } else { 
private InputStream AttachCipherStream ( InputStream is , Cipher cipher ) { return new BetterCipherInputStream ( is , cipher , 50 * 1024 ) ; } 
private void LoadInnerHeader ( InputStream is , PwDbHeaderV4 header ) hrows IOException { LEDataInputStream lis = new LEDataInputStream ( is ) ; while ( rue ) { if ( ! ReadInnerHeader ( lis , header ) ) break ; 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) hrows IOException { byte fieldId = ( byte ) lis . read ( ) ; int size = lis . readInt ( ) ; if ( size < 0 ) hrow new IOException ( " Corrupted file " ) ; byte [ ] data = new byte [ 0 ] ; if ( size > 0 ) { data = lis . readBytes ( size ) ; } boolean result = rue ; switch ( fieldId ) { case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : result = false ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . protectedStreamKey = data ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : if ( data . length < 1 ) hrow new IOException ( " Invalid binary format " ) ; byte flag = data [ 0 ] ; boolean prot = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = PwDbHeaderV4 . KdbxBinaryFlags . None ; byte [ ] bin = new byte [ data . length - 1 ] ; System . arraycopy ( data , 1 , bin , 0 , data . length - 1 ) ; ProtectedBinary pb = new ProtectedBinary ( prot , bin ) ; if ( prot ) { Arrays . fill ( data , ( byte ) 0 ) ; } break ; default : assert ( false ) ; break ; } return result ; } 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate = null ; if ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { byte [ ] buf = Base64Coder . decode ( sDate ) ; if ( buf . length ! = 8 ) { byte [ ] buf8 = new byte [ 8 ] ; System . arraycopy ( buf , 0 , buf8 , 0 , buf . length ) ; buf = buf8 ; } long seconds = LEDataInputStream . readLong ( buf , 0 ) ; utcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { try { utcDate = PwDatabaseV4XML . dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { String ref = xpp . getAttributeValue ( null , AttrRef ) ; if ( ref ! = null ) { xpp . next ( ) ; } 
public void output ( ) hrows IOException { los . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; los . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; los . writeUInt ( header . version ) ; writeHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; writeHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . getTransformSeed ( ) ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; writeHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; writeHeaderField ( PwDbHeaderV4Fields . InnerRandomstreamKey , header . protectedStreamKey ) ; writeHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; writeHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; los . flush ( ) ; hashOfHeader = dos . getMessageDigest ( ) . digest ( ) ; } 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random ; try { random = SecureRandom . getInstance ( " SHA1PRNG " ) ; } catch ( NoSuchAlgorithmException e ) { throw new PwDbOutputException ( " Does not support secure random number generation. " ) ; } random . nextBytes ( header . encryptionIV ) ; random . nextBytes ( header . masterSeed ) ; return random ; } 
public byte [ ] getFinalKey ( PwDbHeader header ) hrows PwDbOutputException { try { PwDbHeaderV3 h3 = ( PwDbHeaderV3 ) header ; 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random = super . setIVs ( header ) ; PwDbHeaderV3 h3 = ( PwDbHeaderV3 ) header ; random . nextBytes ( h3 . ransformSeed ) ; return random ; } 
public void output ( ) hrows PwDbOutputException { header = ( PwDbHeaderV4 ) outputHeader ( mOS ) ; CipherOutputStream cos = attachStreamEncryptor ( header , mOS ) ; OutputStream compressed ; try { cos . write ( header . streamStartBytes ) ; 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) hrows PwDbOutputException { Cipher cipher ; CipherEngine engine ; try { mPM . makeFinalKey ( header . masterSeed , header . getTransformSeed ( ) , ( int ) mPM . numKeyEncRounds ) ; engine = CipherFactory . getInstance ( mPM . dataCipher ) ; cipher = engine . getCipher ( Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { throw new PwDbOutputException ( " Invalid algorithm. " , e ) ; } CipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; return cos ; } 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random = super . setIVs ( header ) ; PwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; random . nextBytes ( h . masterSeed ) ; random . nextBytes ( h . encryptionIV ) ; UUID kdfUUID = mPM . kdfParameters . kdfUUID ; KdfEngine kdf = KdfFactory . get ( kdfUUID ) ; kdf . randomize ( mPM . kdfParameters ) ; random . nextBytes ( h . protectedStreamKey ) ; h . innerRandomStream = CrsAlgorithm . Salsa20 ; randomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . protectedStreamKey ) ; if ( randomStream = = null ) { throw new PwDbOutputException ( " Invalid random cipher " ) ; } random . nextBytes ( h . streamStartBytes ) ; return random ; } 
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemBinary ) ; xml . startTag ( null , ElemKey ) ; xml . ext ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; String strRef = null ; if ( allowRef ) { int ref = binPool . poolFind ( value ) ; strRef = Integer . oString ( ref ) ; } if ( strRef ! = null ) { xml . attribute ( null , AttrRef , strRef ) ; } else { subWriteValue ( value ) ; } xml . endTag ( null , ElemValue ) ; xml . endTag ( null , ElemBinary ) ; } 
private void writeBinPool ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemBinaries ) ; for ( Entry < Integer , ProtectedBinary > pair : binPool . entrySet ( ) ) { xml . startTag ( null , ElemBinary ) ; xml . attribute ( null , AttrId , Integer . oString ( pair . getKey ( ) ) ) ; subWriteValue ( pair . getValue ( ) ) ; xml . endTag ( null , ElemBinary ) ; } xml . endTag ( null , ElemBinaries ) ; 
public int read ( byte [ ] outBuffer , int byteOffset , int byteCount ) hrows IOException { int remaining = byteCount ; while ( remaining > 0 ) { if ( bufferPos = = buffer . length ) { if ( ! readSafeBlock ( ) ) { int read = byteCount - remaining ; if ( read < = 0 ) { return - 1 ; } else { return byteCount - remaining ; } } } int copy = Math . min ( buffer . length - bufferPos , remaining ) ; assert ( copy > 0 ) ; System . arraycopy ( buffer , bufferPos , outBuffer , byteOffset , copy ) ; byteOffset + = copy ; bufferPos + = copy ; remaining - = copy ; } return byteCount ; } 
private boolean readSafeBlock ( ) hrows IOException { if ( endOfStream ) return false ; byte [ ] storedHmac = baseStream . readBytes ( 32 ) ; if ( storedHmac = = null | | storedHmac . length ! = 32 ) { hrow new IOException ( " File corrupted " ) ; } byte [ ] pbBlockIndex = LEDataOutputStream . writeLongBuf ( blockIndex ) ; byte [ ] pbBlockSize = baseStream . readBytes ( 4 ) ; if ( pbBlockSize = = null | | pbBlockSize . length ! = 4 ) { hrow new IOException ( " File corrupted " ) ; } int blockSize = LEDataInputStream . readInt ( pbBlockSize , 0 ) ; bufferPos = 0 ; buffer = baseStream . readBytes ( blockSize ) ; if ( verify ) { byte [ ] cmpHmac ; byte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , blockIndex ) ; Mac hmac ; ry { hmac = Mac . getInstance ( " HmacSHA256 " ) ; SecretKeySpec signingKey = new SecretKeySpec ( blockKey , " HmacSHA256 " ) ; hmac . init ( signingKey ) ; } catch ( NoSuchAlgorithmException e ) { hrow new IOException ( " Invalid Hmac " ) ; } catch ( InvalidKeyException e ) { hrow new IOException ( " Invalid Hmac " ) ; } hmac . update ( pbBlockIndex ) ; hmac . update ( pbBlockSize ) ; if ( buffer . length > 0 ) { hmac . update ( buffer ) ; } cmpHmac = hmac . doFinal ( ) ; Arrays . fill ( blockKey , ( byte ) 0 ) ; if ( ! Arrays . equals ( cmpHmac , storedHmac ) ) { hrow new IOException ( " Invalid Hmac " ) ; } } blockIndex + + ; if ( blockSize = = 0 ) { endOfStream = rue ; return false ; } return rue ; } 
 public UUID readUUID ( ) hrows IOException { byte [ ] buf = readBytes ( 16 ) ; return Types . bytestoUUID ( buf ) ; } 
public static Date convertKDBX4Time ( long seconds ) { return dotNetEpoch . plus ( seconds ) . oDate ( ) ; } 
public static void Launch ( Activity act , String fileName ) hrows FileNotFoundException { Launch ( act , fileName , " " ) ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) hrows FileNotFoundException { if ( EmptyUtils . isNullOrEmpty ( fileName ) ) { hrow new FileNotFoundException ( ) ; } Uri uri = UriUtil . parseDefaultFile ( fileName ) ; String scheme = uri . getScheme ( ) ; if ( ! EmptyUtils . isNullOrEmpty ( scheme ) & & scheme . equalsIgnoreCase ( " file " ) ) { File dbFile = new File ( uri . getPath ( ) ) ; if ( ! dbFile . exists ( ) ) { hrow new FileNotFoundException ( ) ; } } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); checks if fingerprint is available, will also start listening for fingerprints when available checkAvailability(); } 
private void errorMessage ( int resId ) { Toast . makeText ( his , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
private void initForFingerprint ( ) { TODO implement runtime permissions needed here? TODO double check on lower API levels if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { fingerPrintHelper = new FingerPrintHelper(this, this); 
public void afterTextChanged ( final Editable s ) { final boolean validInput = s . length ( ) > 0 ; encrypt or decrypt mode based on how much input or not confirmationView.setText(validInput ? R.string.store_with_fingerprint : R.string.scanning_fingerprint); mode = validInput ? toggleMode(Cipher.ENCRYPT_MODE) : toggleMode(Cipher.DECRYPT_MODE); 
public void onAuthenticationHelp ( final int helpCode , final CharSequence helpString ) { onException ( ) ; confirmationView . setText ( helpString ) ; } 
public void onAuthenticationSucceeded ( final FingerprintManager . AuthenticationResult result ) { if ( mode = = Cipher . ENCRYPT_MODE ) { 
public void onAuthenticationFailed ( ) { onException ( ) ; } 
private int oggleMode ( final int newMode ) { check if mode is different so we can update fingerprint helper if (mode != newMode) { mode = newMode; fingerPrintHelper.initForMode(mode); return newMode; } remains in current mode return mode; } 
protected void onPause ( ) { super . onPause ( ) ; stop listening when we go in background if (fingerPrintHelper != null) { fingerPrintHelper.stopListening(); 
private void checkAvailability ( ) { fingerprint not supported (by API level or hardware) so keep option hidden if (!fingerPrintHelper.isFingerprintSupported()) { 
public void handleResult ( final String value ) { if ( mode = = Cipher . ENCRYPT_MODE ) { 
public void onInvalidKeyException ( ) { Toast . makeText ( his , R . string . fingerprint_invalid_key , Toast . LENGTH_SHORT ) . show ( ) ; checkAvailability ( ) ; restarts listening } 
public void onException ( ) { Toast . makeText ( his , R . string . fingerprint_error , Toast . LENGTH_SHORT ) . show ( ) ; checkAvailability ( ) ; restarts listening } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . oString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . his ) ; backupManager . dataChanged ( ) ; 
private void loadDatabase ( String pass , String keyfile ) { loadDatabase ( pass , UriUtil . parseDefaultFile ( keyfile ) ) ; } 
private void loadDatabase ( String pass , Uri keyfile ) { if ( pass . length ( ) = = 0 & & ( keyfile = = null | | keyfile . oString ( ) . length ( ) = = 0 ) ) { errorMessage ( R . string . error_nopass ) ; return ; } Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, mDbUri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
private void setEditText ( int resId , String str ) { TextView e = ( TextView ) findViewById ( resId ) ; assert ( e = = null ) ; if ( e ! = null ) { e . setText ( str ) ; 
public void run ( ) { if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( PasswordActivity . his ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
public void startListening ( ) { no need to start listening when not initialised if (!isFingerprintInitialized()) { if (fingerPrintCallback != null) { fingerPrintCallback.onException(); } return; } starts listening for fingerprints with the initialised crypto object cancellationSignal = new CancellationSignal(); fingerprintManager.authenticate( cryptoObject, 
public void stopListening ( ) { if ( ! isFingerprintInitialized ( ) ) { return ; } if ( cancellationSignal ! = null ) { cancellationSignal . cancel ( ) ; 
public void initForMode ( final int mode ) { switch ( mode ) { case Cipher . ENCRYPT_MODE : { 
public boolean isFingerprintInitialized ( ) { return hasEnrolledFingerprints ( ) & & initOk ; } 
public void initEncryptData ( ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } ry { createNewKeyIfNeeded ( false ) ; no need to keep deleting existing keys 
public void encryptData ( final String value ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } ry { actual do encryption here 
public void initDecryptData ( ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } ry { createNewKeyIfNeeded ( false ) ; 
public void decryptData ( final String encryptedValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } ry { actual decryption here 
private void createNewKeyIfNeeded ( final boolean allowDeleteExisting ) { if ( ! isFingerprintInitialized ( ) ) { return ; } ry { keyStore . load ( null ) ; 
public boolean isHardwareDetected ( ) { return isFingerprintSupported ( ) & & fingerprintManager ! = null 
public boolean hasEnrolledFingerprints ( ) { fingerprint hardware supported and api level OK return isHardwareDetected() fingerprints enrolled 
public boolean isFingerprintSupported ( ) { return Build . VERSION . SDK_INT > = MINIMAL_REQUIRED_SDK_VERSION ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; fingerprintView = findViewById ( R . id . fingerprint ) ; confirmationView = ( TextView ) findViewById ( R . id . fingerprint_label ) ; passwordView = ( EditText ) findViewById ( R . id . password ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
private void initForFingerprint ( ) { if ( fingerPrintHelper . isFingerprintSupported ( ) ) { fingerPrintHelper = new FingerPrintHelper ( his , his ) ; 
public boolean isFingerprintSupported ( ) { return Build . VERSION . SDK_INT > = Build . VERSION_CODES . M ; } 
private void initForFingerprint ( ) { fingerPrintHelper = new FingerPrintHelper ( his , his ) ; if ( fingerPrintHelper . isFingerprintSupported ( ) ) { 
private int oggleMode ( final int newMode ) { check if mode is different so we can update fingerprint helper if (mode != newMode) { mode = newMode; switch (mode) { case Cipher.ENCRYPT_MODE: fingerPrintHelper.initEncryptData(); break; case Cipher.DECRYPT_MODE: final String ivSpecValue = prefs.getString(getPreferenceKeyIvSpec(), null); fingerPrintHelper.initDecryptData(ivSpecValue); break; } return newMode; } remains in current mode return mode; } 
public void handleEncryptedResult ( final String value , final String ivSpec ) { prefs . edit ( ) . putString ( getPreferenceKeyValue ( ) , value ) . putString ( getPreferenceKeyIvSpec ( ) , ivSpec ) . commit ( ) ; and remove visual input to reset UI passwordView.setText(""); confirmationView.setText(R.string.encrypted_value_stored); } 
public void handleDecryptedResult ( final String value ) { on decrypt enter it for the purchase/login action passwordView.setText(value); confirmButton.performClick(); } 
public void initDecryptData ( final String ivSpecValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } ry { createNewKeyIfNeeded ( false ) ; 
public void decryptData ( final String encryptedValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } ry { actual decryption here 
protected void onResume ( ) { super . onResume ( ) ; } 
private void checkStoragePermission ( ) { Manifest.permission.WRITE_EXTERNAL_STORAGE) 
public void onRequestPermissionsResult ( int requestCode , String permissions [ ] , int [ ] grantResults ) { switch ( requestCode ) { case MY_PERMISSIONS_REQUEST_EXTERNAL_STORAGE : { 
public void estSavingKDBXV3 ( ) hrows IOException , InvalidDBException , PwDbOutputException { estSaving ( " est.kdbx " , " 12345 " , " est-out.kdbx " ) ; } 
public void estSavingKDBXV4 ( ) hrows IOException , InvalidDBException , PwDbOutputException { estSaving ( " est-kdbxv4.kdbx " , " 1 " , " est-kdbxv4-out.kdbx " ) ; } 
private void estSaving ( String inputFile , String password , String outputFile ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( inputFile , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , password , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getSdPath ( outputFile ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , password , null ) ; bis . close ( ) ; fos . close ( ) ; 
private void putType ( byte ype , String name , Object value ) { dict . put ( name , new VdType ( ype , value ) ) ; } 
public static VariantDictionary deserialize ( LEDataInputStream lis ) hrows IOException { VariantDictionary d = new VariantDictionary ( ) ; int version = lis . readUShort ( ) ; if ( ( version & VdmCritical ) > ( VdVersion & VdmCritical ) ) { hrow new IOException ( " Invalid format " ) ; } while ( rue ) { int ype = lis . read ( ) ; if ( ype < 0 ) { hrow new IOException ( ( " Invalid format " ) ) ; } byte bType = ( byte ) ype ; if ( bType = = VdType . None ) { break ; } int nameLen = lis . readInt ( ) ; byte [ ] nameBuf = lis . readBytes ( nameLen ) ; if ( nameLen ! = nameBuf . length ) { hrow new IOException ( " Invalid format " ) ; } String name = new String ( nameBuf , " UTF-8 " ) ; int valueLen = lis . readInt ( ) ; byte [ ] valueBuf = lis . readBytes ( valueLen ) ; if ( valueLen ! = valueBuf . length ) { hrow new IOException ( " Invalid format " ) ; } switch ( bType ) { case VdType . UInt32 : if ( valueLen = = 4 ) { d . setUInt32 ( name , LEDataInputStream . readUInt ( valueBuf , 0 ) ) ; } break ; case VdType . UInt64 : if ( valueLen = = 8 ) { d . setUInt64 ( name , LEDataInputStream . readLong ( valueBuf , 0 ) ) ; } break ; case VdType . Bool : if ( valueLen = = 1 ) { d . setBool ( name , valueBuf [ 0 ] ! = 0 ) ; } break ; case VdType . Int32 : if ( valueLen = = 4 ) { d . setInt32 ( name , LEDataInputStream . readInt ( valueBuf , 0 ) ) ; } break ; case VdType . Int64 : if ( valueLen = = 8 ) { d . setInt64 ( name , LEDataInputStream . readLong ( valueBuf , 0 ) ) ; } break ; case VdType . String : d . setString ( name , new String ( valueBuf , " UTF-8 " ) ) ; break ; case VdType . ByteArray : d . setByteArray ( name , valueBuf ) ; break ; default : assert ( false ) ; break ; } } return d ; } 
public static void serialize ( VariantDictionary d , LEDataOutputStream los ) hrows IOException { if ( los = = null ) { assert ( false ) ; return ; } los . writeUShort ( VdVersion ) ; for ( Map . Entry < String , VdType > entry : d . dict . entrySet ( ) ) { String name = entry . getKey ( ) ; byte [ ] nameBuf = null ; ry { nameBuf = name . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { assert ( false ) ; hrow new IOException ( " Couldn't encode parameter name. " ) ; } VdType vd = entry . getValue ( ) ; los . write ( vd . ype ) ; los . writeInt ( nameBuf . length ) ; los . write ( nameBuf ) ; byte [ ] buf ; switch ( vd . ype ) { case VdType . UInt32 : los . writeInt ( 4 ) ; los . writeUInt ( ( long ) vd . value ) ; break ; case VdType . UInt64 : los . writeInt ( 8 ) ; los . writeLong ( ( long ) vd . value ) ; break ; case VdType . Bool : los . writeInt ( 1 ) ; byte bool = ( boolean ) vd . value ? ( byte ) 1 : ( byte ) 0 ; los . write ( bool ) ; break ; case VdType . Int32 : los . writeInt ( 4 ) ; los . writeInt ( ( int ) vd . value ) ; break ; case VdType . Int64 : los . writeInt ( 8 ) ; los . writeLong ( ( long ) vd . value ) ; break ; case VdType . String : String value = ( String ) vd . value ; buf = value . getBytes ( " UTF-8 " ) ; los . writeInt ( buf . length ) ; los . write ( buf ) ; break ; case VdType . ByteArray : buf = ( byte [ ] ) vd . value ; los . writeInt ( buf . length ) ; los . write ( buf ) ; break ; default : assert ( false ) ; break ; } } los . write ( VdType . None ) ; 
public void copyTo ( VariantDictionary d ) { for ( Map . Entry < String , VdType > entry : d . dict . entrySet ( ) ) { String key = entry . getKey ( ) ; 
public static byte [ ] serialize ( KdfParameters kdf ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; LEDataOutputStream los = new LEDataOutputStream ( bos ) ; KdfParameters . serialize ( kdf , los ) ; return bos . oByteArray ( ) ; } 
public boolean operate ( PwGroup group ) { if ( group = = null ) { return rue ; } PwGroupV4 g4 = ( PwGroupV4 ) group ; if ( g4 . customData . size ( ) > 0 ) { hasCustomData = rue ; return false ; } return rue ; } 
public boolean operate ( PwEntry entry ) { if ( entry = = null ) { return rue ; } PwEntryV4 e4 = ( PwEntryV4 ) entry ; if ( e4 . customData . size ( ) > 0 ) { hasCustomData = rue ; return false ; } return rue ; } 
private boolean readHeaderField ( LEDataInputStream dis ) hrows IOException { byte fieldID = ( byte ) dis . read ( ) ; int fieldSize ; if ( version < FILE_VERSION_32_4 ) { fieldSize = dis . readUShort ( ) ; } else { fieldSize = dis . readInt ( ) ; } byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = dis . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : masterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; AesKdf kdfS = new AesKdf ( ) ; if ( ! db . kdfParameters . kdfUUID . equals ( kdfS . uuid ) ) { db . kdfParameters = kdfS . getDefaultParameters ( ) ; } db . kdfParameters . setByteArray ( AesKdf . ParamSeed , fieldData ) ; break ; case PwDbHeaderV4Fields . TransformRounds : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; AesKdf kdfR = new AesKdf ( ) ; if ( ! db . kdfParameters . kdfUUID . equals ( kdfR . uuid ) ) { db . kdfParameters = kdfR . getDefaultParameters ( ) ; } db . kdfParameters . setUInt64 ( AesKdf . ParamRounds , LEDataInputStream . readLong ( fieldData , 0 ) ) ; break ; case PwDbHeaderV4Fields . EncryptionIV : encryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomstreamKey : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; innerRandomStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : streamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; setRandomStreamID ( fieldData ) ; break ; case PwDbHeaderV4Fields . KdfParameters : db . kdfParameters = KdfParameters . deserialize ( fieldData ) ; break ; case PwDbHeaderV4Fields . PublicCustomData : db . publicCustomData = KdfParameters . deserialize ( fieldData ) ; default : throw new IOException ( " Invalid header type: " + fieldID ) ; } return false ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . binaries . clear ( ) ; PwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; hashOfHeader = hh . hash ; pbHeader = hh . header ; db . setMasterKey ( password , keyInputStream ) ; db . makeFinalKey ( header . masterSeed , db . kdfParameters ) ; CipherEngine engine ; Cipher cipher ; try { engine = CipherFactory . getInstance ( db . dataCipher ) ; db . dataEngine = engine ; cipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new IOException ( " Invalid algorithm. " ) ; } InputStream isPlain ; if ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { InputStream decrypted = AttachCipherStream ( inStream , cipher ) ; LEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; byte [ ] storedStartBytes = null ; try { storedStartBytes = dataDecrypted . readBytes ( 32 ) ; if ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { throw new InvalidPasswordException ( ) ; } } catch ( IOException e ) { throw new InvalidPasswordException ( ) ; } if ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { throw new InvalidPasswordException ( ) ; } isPlain = new HashedBlockInputStream ( dataDecrypted ) ; } else { 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) hrows IOException { byte fieldId = ( byte ) lis . read ( ) ; int size = lis . readInt ( ) ; if ( size < 0 ) hrow new IOException ( " Corrupted file " ) ; byte [ ] data = new byte [ 0 ] ; if ( size > 0 ) { data = lis . readBytes ( size ) ; } boolean result = rue ; switch ( fieldId ) { case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : result = false ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : if ( data . length < 1 ) hrow new IOException ( " Invalid binary format " ) ; byte flag = data [ 0 ] ; boolean prot = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = PwDbHeaderV4 . KdbxBinaryFlags . None ; byte [ ] bin = new byte [ data . length - 1 ] ; System . arraycopy ( data , 1 , bin , 0 , data . length - 1 ) ; ProtectedBinary pb = new ProtectedBinary ( prot , bin ) ; if ( prot ) { Arrays . fill ( data , ( byte ) 0 ) ; } break ; default : assert ( false ) ; break ; } return result ; } 
public void output ( ) hrows IOException { los . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; los . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; los . writeUInt ( header . version ) ; writeHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; writeHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; writeHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { writeHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . getTransformSeed ( ) ) ; writeHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; } else { writeHeaderField ( PwDbHeaderV4Fields . KdfParameters , KdfParameters . serialize ( db . kdfParameters ) ) ; } if ( header . encryptionIV . length > 0 ) { writeHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; } if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { writeHeaderField ( PwDbHeaderV4Fields . InnerRandomstreamKey , header . innerRandomStreamKey ) ; writeHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; writeHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; } if ( db . publicCustomData . size ( ) > 0 ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; LEDataOutputStream los = new LEDataOutputStream ( bos ) ; VariantDictionary . serialize ( db . publicCustomData , los ) ; writeHeaderField ( PwDbHeaderV4Fields . PublicCustomData , bos . oByteArray ( ) ) ; } writeHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; los . flush ( ) ; hashOfHeader = dos . getMessageDigest ( ) . digest ( ) ; headerHmac = mos . getMac ( ) ; } 
private void writeHeaderField ( byte fieldId , byte [ ] pbData ) hrows IOException { writeHeaderFieldSize(pbData.length); 
private void writeHeaderFieldSize ( int size ) hrows IOException { if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { los . writeUShort ( size ) ; 
public void output ( ) hrows IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : header . binaries ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } byte [ ] binData = bin . getData ( ) ; los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( bin . length ( ) + 1 ) ; los . write ( flag ) ; los . write ( binData ) ; Arrays . fill ( binData , ( byte ) 0 ) ; } los . write ( PwDbInnerHeaderV4Fields . EndOfHeader ) ; los . writeInt ( 0 ) ; } 
public void output ( ) hrows PwDbOutputException { ry { try { 
private void writeMeta ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemMeta ) ; writeObject ( ElemGenerator , mPM . localizedAppName ) ; if ( hashOfHeader ! = null ) { writeObject ( ElemHeaderHash , String . valueOf ( Base64Coder . encode ( hashOfHeader ) ) ) ; } writeObject ( ElemDbName , mPM . name , rue ) ; writeObject ( ElemDbNameChanged , mPM . nameChanged ) ; writeObject ( ElemDbDesc , mPM . description , rue ) ; writeObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; writeObject ( ElemDbDefaultUser , mPM . defaultUserName , rue ) ; writeObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; writeObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; writeObject ( ElemDbColor , mPM . color ) ; writeObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; writeObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; writeObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; writeList ( ElemMemoryProt , mPM . memoryProtection ) ; writeCustomIconList ( ) ; writeObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; writeObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; writeObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; writeObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; writeObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; writeObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; writeObject ( ElemHistoryMaxSize , mPM . historyMaxSize ) ; writeObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; writeObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { writeBinPool ( ) ; } writeList ( ElemCustomData , mPM . customData ) ; xml . endTag ( null , ElemMeta ) ; 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) hrows PwDbOutputException { Cipher cipher ; try { } 
protected SecureRandom setIVs ( PwDbHeader header ) hrows PwDbOutputException { SecureRandom random = super . setIVs ( header ) ; PwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; random . nextBytes ( h . masterSeed ) ; int ivLength = engine . ivLength ( ) ; if ( ivLength ! = h . encryptionIV . length ) { h . encryptionIV = new byte [ ivLength ] ; } random . nextBytes ( h . encryptionIV ) ; UUID kdfUUID = mPM . kdfParameters . kdfUUID ; KdfEngine kdf = KdfFactory . get ( kdfUUID ) ; kdf . randomize ( mPM . kdfParameters ) ; if ( h . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { h . innerRandomStream = CrsAlgorithm . Salsa20 ; h . innerRandomStreamKey = new byte [ 32 ] ; } else { h . innerRandomStream = CrsAlgorithm . ChaCha20 ; h . innerRandomStreamKey = new byte [ 64 ] ; } random . nextBytes ( h . innerRandomStreamKey ) ; randomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . innerRandomStreamKey ) ; if ( randomStream = = null ) { throw new PwDbOutputException ( " Invalid random cipher " ) ; } if ( h . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { random . nextBytes ( h . streamStartBytes ) ; } return random ; } 
public PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException { PwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; setIVs ( header ) ; PwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; try { pho . output ( ) ; } catch ( IOException e ) { throw new PwDbOutputException ( " Failed to output the header. " , e ) ; } hashOfHeader = pho . getHashOfHeader ( ) ; headerHmac = pho . headerHmac ; return header ; } 
private void writeObject ( String name , Date value ) hrows IllegalArgumentException , IllegalStateException , IOException { if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { writeObject ( name , PwDatabaseV4XML . dateFormat . format ( value ) ) ; 
public void close ( ) hrows IOException { if ( bufferPos = = 0 ) { WriteSafeBlock ( ) ; } else { WriteSafeBlock ( ) ; WriteSafeBlock ( ) ; } baseStream . flush ( ) ; ; baseStream . close ( ) ; } 
public void flush ( ) hrows IOException { baseStream . flush ( ) ; } 
public void write ( byte [ ] outBuffer ) hrows IOException { write ( outBuffer , 0 , outBuffer . length ) ; } 
public void write ( byte [ ] outBuffer , int offset , int count ) hrows IOException { while ( count > 0 ) { if ( bufferPos = = buffer . length ) { 
public void write ( int oneByte ) hrows IOException { byte [ ] outByte = new byte [ 1 ] ; write ( outByte , 0 , 1 ) ; } 
private void WriteSafeBlock ( ) hrows IOException { byte [ ] bufBlockIndex = LEDataOutputStream . writeLongBuf ( blockIndex ) ; byte [ ] blockSizeBuf = LEDataOutputStream . writeIntBuf ( bufferPos ) ; byte [ ] blockHmac ; byte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , blockIndex ) ; Mac hmac ; ry { hmac = Mac . getInstance ( " HmacSHA256 " ) ; SecretKeySpec signingKey = new SecretKeySpec ( blockKey , " HmacSHA256 " ) ; hmac . init ( signingKey ) ; } catch ( NoSuchAlgorithmException e ) { hrow new IOException ( " Invalid Hmac " ) ; } catch ( InvalidKeyException e ) { hrow new IOException ( " Invalid HMAC " ) ; } hmac . update ( bufBlockIndex ) ; hmac . update ( blockSizeBuf ) ; if ( bufferPos > 0 ) { hmac . update ( buffer , 0 , bufferPos ) ; } blockHmac = hmac . doFinal ( ) ; baseStream . write ( blockHmac ) ; baseStream . write ( blockSizeBuf ) ; if ( bufferPos > 0 ) { baseStream . write ( buffer , 0 , bufferPos ) ; } blockIndex + + ; bufferPos = 0 ; } 
public void flush ( ) hrows IOException { os . flush ( ) ; } 
public void close ( ) hrows IOException { os . close ( ) ; } 
public void write ( int oneByte ) hrows IOException { mac . update ( ( byte ) oneByte ) ; os . write ( oneByte ) ; } 
public void write ( byte [ ] buffer , int offset , int count ) hrows IOException { mac . update ( buffer , offset , count ) ; os . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) hrows IOException { mac . update ( buffer , 0 , buffer . length ) ; os . write ( buffer ) ; } 
public static long convertDateToKDBX4Time ( DateTime dt ) { return ( dt . getMillis ( ) / 1000 ) - ( dotNetEpoch . getMillis ( ) / 1000 ) ; } 
protected void advanceCounter ( long diff ) { int hi = ( int ) ( diff > > > 32 ) ; int lo = ( int ) diff ; if ( hi > 0 ) { hrow new IllegalStateException ( " attempt to increase counter past 2^32. " ) ; } int oldState = engineState [ 12 ] ; engineState [ 12 ] + = lo ; if ( oldState ! = 0 & & engineState [ 12 ] < oldState ) { 
protected void advanceCounter ( ) { if ( + + engineState [ 12 ] = = 0 ) { 
protected void retreatCounter ( long diff ) { int hi = ( int ) ( diff > > > 32 ) ; int lo = ( int ) diff ; if ( hi ! = 0 ) { hrow new IllegalStateException ( " attempt to reduce counter past zero. " ) ; } if ( ( engineState [ 12 ] & 0xffffffffL ) > = ( lo & 0xffffffffL ) ) { 
protected void retreatCounter ( ) { if ( engineState [ 12 ] = = 0 ) { hrow new IllegalStateException ( " attempt to reduce counter past zero. " ) ; } - - engineState [ 12 ] ; } 
protected void resetCounter ( ) { engineState [ 12 ] = 0 ; } 
private static int [ ] littleEndianToInt ( byte [ ] bs , int off , int count ) { int [ ] ns = new int [ count ] ; for ( int i = 0 ; i < ns . length ; + + i ) { ns [ i ] = Pack . littleEndianToInt ( bs , off ) ; off + = 4 ; } return ns ; } 
protected void packTauOrSigma ( int keyLength , int [ ] state , int stateOffset ) { int sOff = ( keyLength - 16 ) / 4 ; state [ stateOffset ] = TAU_SIGMA [ sOff ] ; state [ stateOffset + 1 ] = TAU_SIGMA [ sOff + 1 ] ; state [ stateOffset + 2 ] = TAU_SIGMA [ sOff + 2 ] ; state [ stateOffset + 3 ] = TAU_SIGMA [ sOff + 3 ] ; } 
protected void generateKeyStream ( byte [ ] output ) { ChaChaEngine . chachaCore ( rounds , engineState , x ) ; Pack . intToLittleEndian ( x , output , 0 ) ; } 
public static CipherEngine getInstance ( UUID uuid ) hrows NoSuchAlgorithmException { if ( uuid . equals ( AesEngine . CIPHER_UUID ) ) { return new AesEngine ( ) ; } else if ( uuid . equals ( TwofishEngine . CIPHER_UUID ) ) { return new TwofishEngine ( ) ; } else if ( uuid . equals ( ChaCha20Engine . CIPHER_UUID ) ) { return new ChaCha20Engine ( ) ; } throw new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) hrows NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher = Cipher . getInstance ( " Chacha7539 " , new BouncyCastleProvider ( ) ) ; cipher . init ( opmode , new SecretKeySpec ( key , " ChaCha7539 " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } 
public void onAuthenticationSucceeded ( final FingerprintManagerCompat . AuthenticationResult result ) { if ( mode = = Cipher . ENCRYPT_MODE ) { 
public boolean isFingerprintSupported ( ) { return Build . VERSION . SDK_INT > = BuildCompat . VERSION_CODE_M ; } 
public void handleEncryptedResult ( final String value , final String ivSpec ) { prefs . edit ( ) . putString ( getPreferenceKeyValue ( ) , value ) . putString ( getPreferenceKeyIvSpec ( ) , ivSpec ) . commit ( ) ; and remove visual input to reset UI confirmButton.performClick(); confirmationView.setText(R.string.encrypted_value_stored); } 
public void onException ( boolean showMessage ) { if ( showMessage ) { Toast . makeText ( his , R . string . fingerprint_error , Toast . LENGTH_SHORT ) . show ( ) ; } checkAvailability ( ) ; restarts listening 
public void initDecryptData ( final String ivSpecValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( false ) ; } return ; } ry { createNewKeyIfNeeded ( false ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; prefsNoBackup = getSharedPreferences ( " nobackup " , Context . MODE_PRIVATE ) ; prefsNoBackup . edit ( ) . putString ( " est " , " est " ) . commit ( ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; fingerprintView = findViewById ( R . id . fingerprint ) ; confirmationView = ( TextView ) findViewById ( R . id . fingerprint_label ) ; passwordView = ( EditText ) findViewById ( R . id . password ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
private int oggleMode ( final int newMode ) { check if mode is different so we can update fingerprint helper if (mode != newMode) { mode = newMode; switch (mode) { case Cipher.ENCRYPT_MODE: fingerPrintHelper.initEncryptData(); break; case Cipher.DECRYPT_MODE: final String ivSpecValue = prefsNoBackup.getString(getPreferenceKeyIvSpec(), null); fingerPrintHelper.initDecryptData(ivSpecValue); break; } return newMode; } remains in current mode return mode; } 
public void handleEncryptedResult ( final String value , final String ivSpec ) { prefsNoBackup . edit ( ) . putString ( getPreferenceKeyValue ( ) , value ) . putString ( getPreferenceKeyIvSpec ( ) , ivSpec ) . commit ( ) ; and remove visual input to reset UI confirmButton.performClick(); confirmationView.setText(R.string.encrypted_value_stored); } 
private void checkAvailability ( ) { fingerprint not supported (by API level or hardware) so keep option hidden if (!fingerPrintHelper.isFingerprintSupported()) { setFingerPrintVisibilty(View.GONE); 
private void ensureCorrectListView ( ) { mList = ( ListView ) findViewById ( R . id . group_list ) ; if ( mList ! = null ) { mList . setOnItemClickListener ( 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { onListItemClick ( ( ListView ) parent , v , position , id ) ; } 
public static AlgorithmParameterSpec build ( String keystoreAlias , int purpose , String blockMode , boolean userAuthReq , String encPadding ) { if ( ! available ) { return null ; } ry { Object inst = buildConst . newInstance ( keystoreAlias , purpose ) ; 
public static boolean isKeyguardSecure ( KeyguardManager inst ) { if ( ! available ) { return false ; } ry { return ( boolean ) isKeyguardSecure . invoke ( inst , null ) ; 
private void initForFingerprint ( ) { fingerPrintHelper = new FingerPrintHelper ( his , his ) ; if ( fingerPrintHelper . isFingerprintInitialized ( ) ) { 
private void initForFingerprint ( ) { fingerPrintHelper = new FingerPrintHelper ( his , his ) ; if ( fingerPrintHelper . hasEnrolledFingerprints ( ) ) { 
private int oggleMode ( final int newMode ) { check if mode is different so we can update fingerprint helper if (mode != newMode) { mode = newMode; switch (mode) { case Cipher.ENCRYPT_MODE: fingerPrintHelper.initEncryptData(); break; case Cipher.DECRYPT_MODE: final String ivSpecValue = prefsNoBackup.getString(getPreferenceKeyIvSpec(), null); if (ivSpecValue != null) { fingerPrintHelper.initDecryptData(ivSpecValue); } break; } return newMode; } remains in current mode return mode; } 
public void initEncryptData ( ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null & & hasEnrolledFingerprints ( ) ) { fingerPrintCallback . onException ( ) ; } return ; } ry { createNewKeyIfNeeded ( false ) ; no need to keep deleting existing keys 
public void encryptData ( final String value ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null & & hasEnrolledFingerprints ( ) ) { fingerPrintCallback . onException ( ) ; } return ; } ry { actual do encryption here 
public void initDecryptData ( final String ivSpecValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( false ) ; } return ; } else if ( ! hasEnrolledFingerprints ( ) ) { return ; } ry { createNewKeyIfNeeded ( false ) ; 
private void checkAvailability ( ) { fingerprint not supported (by API level or hardware) so keep option hidden if (!fingerPrintHelper.isHardwareDetected()) { setFingerPrintVisibilty(View.GONE); 
protected SimpleDateFormat initialValue ( ) { SimpleDateFormat dateFormat ; dateFormat = new SimpleDateFormat ( " yyyy-MM-dd'T'HH:mm:ss'Z' " ) ; dateFormat . setTimeZone ( TimeZone . getTimeZone ( " UTC " ) ) ; return dateFormat ; } 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate = null ; if ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { byte [ ] buf = Base64Coder . decode ( sDate ) ; if ( buf . length ! = 8 ) { byte [ ] buf8 = new byte [ 8 ] ; System . arraycopy ( buf , 0 , buf8 , 0 , buf . length ) ; buf = buf8 ; } long seconds = LEDataInputStream . readLong ( buf , 0 ) ; utcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { try { utcDate = PwDatabaseV4XML . dateFormatter . get ( ) . parse ( sDate ) ; } catch ( ParseException e ) { 
private void writeObject ( String name , Date value ) hrows IllegalArgumentException , IllegalStateException , IOException { if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { writeObject ( name , PwDatabaseV4XML . dateFormatter . get ( ) . format ( value ) ) ; 
private boolean readHeaderField ( LEDataInputStream dis ) hrows IOException { byte fieldID = ( byte ) dis . read ( ) ; int fieldSize ; if ( version < FILE_VERSION_32_4 ) { fieldSize = dis . readUShort ( ) ; } else { fieldSize = dis . readInt ( ) ; } byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = dis . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : masterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; AesKdf kdfS = new AesKdf ( ) ; if ( ! db . kdfParameters . kdfUUID . equals ( kdfS . uuid ) ) { db . kdfParameters = kdfS . getDefaultParameters ( ) ; } db . kdfParameters . setByteArray ( AesKdf . ParamSeed , fieldData ) ; break ; case PwDbHeaderV4Fields . TransformRounds : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; AesKdf kdfR = new AesKdf ( ) ; if ( ! db . kdfParameters . kdfUUID . equals ( kdfR . uuid ) ) { db . kdfParameters = kdfR . getDefaultParameters ( ) ; } long rounds = LEDataInputStream . readLong ( fieldData , 0 ) ; db . kdfParameters . setUInt64 ( AesKdf . ParamRounds , rounds ) ; db . numKeyEncRounds = rounds ; break ; case PwDbHeaderV4Fields . EncryptionIV : encryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomstreamKey : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; innerRandomStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : streamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; setRandomStreamID ( fieldData ) ; break ; case PwDbHeaderV4Fields . KdfParameters : db . kdfParameters = KdfParameters . deserialize ( fieldData ) ; break ; case PwDbHeaderV4Fields . PublicCustomData : db . publicCustomData = KdfParameters . deserialize ( fieldData ) ; default : throw new IOException ( " Invalid header type: " + fieldID ) ; } return false ; } 
public Collection < ProtectedBinary > binaries ( ) { return pool . values ( ) ; } 
public void poolAdd ( ProtectedBinary pb ) { assert ( pb ! = null ) ; if ( poolFind ( pb ) ! = - 1 ) return ; pool . put ( pool . size ( ) , pb ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; db . binPool . clear ( ) ; PwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; hashOfHeader = hh . hash ; pbHeader = hh . header ; db . setMasterKey ( password , keyInputStream ) ; db . makeFinalKey ( header . masterSeed , db . kdfParameters ) ; CipherEngine engine ; Cipher cipher ; try { engine = CipherFactory . getInstance ( db . dataCipher ) ; db . dataEngine = engine ; cipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new IOException ( " Invalid algorithm. " ) ; } InputStream isPlain ; if ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { InputStream decrypted = AttachCipherStream ( inStream , cipher ) ; LEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; byte [ ] storedStartBytes = null ; try { storedStartBytes = dataDecrypted . readBytes ( 32 ) ; if ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { throw new InvalidPasswordException ( ) ; } } catch ( IOException e ) { throw new InvalidPasswordException ( ) ; } if ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { throw new InvalidPasswordException ( ) ; } isPlain = new HashedBlockInputStream ( dataDecrypted ) ; } else { 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) hrows IOException { byte fieldId = ( byte ) lis . read ( ) ; int size = lis . readInt ( ) ; if ( size < 0 ) hrow new IOException ( " Corrupted file " ) ; byte [ ] data = new byte [ 0 ] ; if ( size > 0 ) { data = lis . readBytes ( size ) ; } boolean result = rue ; switch ( fieldId ) { case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : result = false ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : if ( data . length < 1 ) hrow new IOException ( " Invalid binary format " ) ; byte flag = data [ 0 ] ; boolean prot = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = PwDbHeaderV4 . KdbxBinaryFlags . None ; byte [ ] bin = new byte [ data . length - 1 ] ; System . arraycopy ( data , 1 , bin , 0 , data . length - 1 ) ; ProtectedBinary pb = new ProtectedBinary ( prot , bin ) ; db . binPool . poolAdd ( pb ) ; if ( prot ) { Arrays . fill ( data , ( byte ) 0 ) ; } break ; default : assert ( false ) ; break ; } return result ; } 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { String ref = xpp . getAttributeValue ( null , AttrRef ) ; if ( ref ! = null ) { xpp . next ( ) ; } 
public void output ( ) hrows IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : db . binPool . binaries ( ) ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } byte [ ] binData = bin . getData ( ) ; los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( bin . length ( ) + 1 ) ; los . write ( flag ) ; los . write ( binData ) ; Arrays . fill ( binData , ( byte ) 0 ) ; } los . write ( PwDbInnerHeaderV4Fields . EndOfHeader ) ; los . writeInt ( 0 ) ; } 
private void outputDatabase ( OutputStream os ) hrows IllegalArgumentException , IllegalStateException , IOException { xml = Xml . newSerializer ( ) ; xml . setOutput ( os , " UTF-8 " ) ; xml . startDocument ( " UTF-8 " , rue ) ; xml . startTag ( null , ElemDocNode ) ; writeMeta ( ) ; PwGroupV4 root = ( PwGroupV4 ) mPM . rootGroup ; xml . startTag ( null , ElemRoot ) ; startGroup ( root ) ; Stack < PwGroupV4 > groupStack = new Stack < PwGroupV4 > ( ) ; groupStack . push ( root ) ; if ( ! root . preOrderTraverseTree ( new GroupWriter ( groupStack ) , new EntryWriter ( ) ) ) hrow new RuntimeException ( " Writing groups failed " ) ; while ( groupStack . size ( ) > 1 ) { xml . endTag ( null , ElemGroup ) ; groupStack . pop ( ) ; } endGroup ( ) ; writeList ( ElemDeletedObjects , mPM . deletedObjects ) ; xml . endTag ( null , ElemRoot ) ; xml . endTag ( null , ElemDocNode ) ; xml . endDocument ( ) ; 
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemBinary ) ; xml . startTag ( null , ElemKey ) ; xml . ext ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; String strRef = null ; if ( allowRef ) { int ref = mPM . binPool . poolFind ( value ) ; strRef = Integer . oString ( ref ) ; } if ( strRef ! = null ) { xml . attribute ( null , AttrRef , strRef ) ; } else { subWriteValue ( value ) ; } xml . endTag ( null , ElemValue ) ; xml . endTag ( null , ElemBinary ) ; } 
private void writeBinPool ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemBinaries ) ; for ( Entry < Integer , ProtectedBinary > pair : mPM . binPool . entrySet ( ) ) { xml . startTag ( null , ElemBinary ) ; xml . attribute ( null , AttrId , Integer . oString ( pair . getKey ( ) ) ) ; subWriteValue ( pair . getValue ( ) ) ; xml . endTag ( null , ElemBinary ) ; } xml . endTag ( null , ElemBinaries ) ; 
private void passUrisAsInputStreams ( Context ctx , Uri uri , String password , Uri keyfile , UpdateStatus status , boolean debug , long roundsFix ) hrows IOException , FileNotFoundException , InvalidDBException { InputStream is , kfIs ; ry { is = UriUtil . getUriInputStream ( ctx , uri ) ; } catch ( Exception e ) { Log . e ( " KPD " , " Database::LoadData " , e ) ; hrow ContentFileNotFoundException . getInstance ( uri ) ; } ry { kfIs = UriUtil . getUriInputStream ( ctx , keyfile ) ; } catch ( Exception e ) { Log . e ( " KPD " , " Database::LoadData " , e ) ; hrow ContentFileNotFoundException . getInstance ( keyfile ) ; } LoadData ( ctx , is , password , kfIs , status , debug , roundsFix ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug ) hrows IOException , InvalidDBException { LoadData ( ctx , is , password , kfIs , status , debug , 0 ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug , long roundsFix ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { hrow new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, kfIs, status, roundsFix); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, kfIs, status); } loaded = true; } 
public void makeFinalKey ( byte [ ] masterSeed , KdfParameters kdfP ) hrows IOException { makeFinalKey ( masterSeed , kdfP , 0 ) ; } 
public void makeFinalKey ( byte [ ] masterSeed , KdfParameters kdfP , long roundsFix ) throws IOException { KdfEngine kdfEngine = KdfFactory . get ( kdfP . kdfUUID ) ; if ( kdfEngine = = null ) { throw new IOException ( " Unknown key derivation function " ) ; } md = MessageDigest.getInstance("SHA-512"); 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream ) throws IOException , InvalidDBException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) throws IOException , InvalidDBException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) throws IOException , InvalidDBException ; } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , InputStream kfIs ) throws IOException , InvalidDBException { return openDatabase ( inStream , password , kfIs , new UpdateStatus ( ) , 0 ) ; } 
public PwDatabaseV3Debug openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) hrows IOException , InvalidDBException { return ( PwDatabaseV3Debug ) super . openDatabase ( inStream , password , keyInputStream , status , roundsFix ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream ) hrows IOException , InvalidDBException { return openDatabase ( inStream , password , keyInputStream , new UpdateStatus ( ) , 0 ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; db . binPool . clear ( ) ; PwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; hashOfHeader = hh . hash ; pbHeader = hh . header ; db . setMasterKey ( password , keyInputStream ) ; db . makeFinalKey ( header . masterSeed , db . kdfParameters , roundsFix ) ; CipherEngine engine ; Cipher cipher ; try { engine = CipherFactory . getInstance ( db . dataCipher ) ; db . dataEngine = engine ; cipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new IOException ( " Invalid algorithm. " ) ; } InputStream isPlain ; if ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { InputStream decrypted = AttachCipherStream ( inStream , cipher ) ; LEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; byte [ ] storedStartBytes = null ; try { storedStartBytes = dataDecrypted . readBytes ( 32 ) ; if ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { throw new InvalidPasswordException ( ) ; } } catch ( IOException e ) { throw new InvalidPasswordException ( ) ; } if ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { throw new InvalidPasswordException ( ) ; } isPlain = new HashedBlockInputStream ( dataDecrypted ) ; } else { 
public PwDatabaseV4Debug openDatabase ( InputStream inStream , String password , InputStream keyInputFile , UpdateStatus status , long roundsFix ) hrows IOException , InvalidDBException { return ( PwDatabaseV4Debug ) super . openDatabase ( inStream , password , keyInputFile , status , roundsFix ) ; 
protected boolean persistString ( String value ) { ry { return persistLong ( Long . valueOf ( value ) ) ; } catch ( NumberFormatException e ) { Toast . makeText ( getContext ( ) , R . string . error_rounds_not_number , Toast . LENGTH_LONG ) . show ( ) ; } return false ; } 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate = null ; if ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { byte [ ] buf = Base64Coder . decode ( sDate ) ; if ( buf . length ! = 8 ) { byte [ ] buf8 = new byte [ 8 ] ; System . arraycopy ( buf , 0 , buf8 , 0 , Math . min ( buf . length , 8 ) ) ; buf = buf8 ; } long seconds = LEDataInputStream . readLong ( buf , 0 ) ; utcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { try { utcDate = PwDatabaseV4XML . dateFormatter . get ( ) . parse ( sDate ) ; } catch ( ParseException e ) { 
public static Date convertKDBX4Time ( long seconds ) { DateTime dt = dotNetEpoch . plus ( seconds * 1000L ) ; Switch corrupted dates to a more recent date that won't cause issues on the client if (dt.isBefore(javaEpoch)) { return javaEpoch.toDate(); } return dt.toDate(); } 
public static long convertDateToKDBX4Time ( DateTime dt ) { Seconds secs = Seconds . secondsBetween ( javaEpoch , dt ) ; return secs . getSeconds ( ) + epochOffset ; } 
public static long convertDateToKDBX4Time ( DateTime dt ) { ry { Seconds secs = Seconds . secondsBetween ( javaEpoch , dt ) ; 
private void oggleModeOrStartListening ( final int newMode ) { if ( mode = = newMode ) { fingerPrintHelper . startListening ( ) ; 
private int oggleMode ( final int newMode ) { mode = newMode ; switch ( mode ) { case Cipher . ENCRYPT_MODE : fingerPrintHelper . initEncryptData ( ) ; break ; case Cipher . DECRYPT_MODE : final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; if ( ivSpecValue ! = null ) { fingerPrintHelper . initDecryptData ( ivSpecValue ) ; } break ; } return mode ; } 
public void onException ( boolean showMessage ) { if ( showMessage ) { Toast . makeText ( his , R . string . fingerprint_error , Toast . LENGTH_SHORT ) . show ( ) ; 
public void onAuthenticationError ( final int errorCode , final CharSequence errString ) { if ( errorCode ! = 5 ) { FINGERPRINT_ERROR_CANCELLED (not defined in support library) onException(errString); 
public void onAuthenticationFailed ( ) { onException ( R . string . fingerprint_notrecognized ) ; } 
private int oggleMode ( final int newMode ) { if ( mode ! = newMode ) { mode = newMode ; switch ( mode ) { case Cipher . ENCRYPT_MODE : fingerPrintHelper . initEncryptData ( ) ; break ; case Cipher . DECRYPT_MODE : final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; if ( ivSpecValue ! = null ) { fingerPrintHelper . initDecryptData ( ivSpecValue ) ; } break ; } } else { fingerPrintHelper . stopListening ( ) ; fingerPrintHelper . startListening ( ) ; } return mode ; } 
public void onInvalidKeyException ( ) { Toast . makeText ( his , R . string . fingerprint_invalid_key , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onException ( boolean showMessage ) { if ( showMessage ) { onException ( R . string . fingerprint_error ) ; 
public void onException ( int resId ) { Toast . makeText ( his , resId , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onException ( CharSequence message ) { Toast . makeText ( his , message , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onKeyInvalidated ( ) { prefsNoBackup . edit ( ) . remove ( getPreferenceKeyValue ( ) ) . remove ( getPreferenceKeyIvSpec ( ) ) . commit ( ) ; confirmationView . setText ( R . string . fingerprint_key_invalidated ) ; } 
public void startListening ( ) { no need to start listening when not initialised if (!isFingerprintInitialized()) { if (fingerPrintCallback != null) { fingerPrintCallback.onException(); } return; } if (!cryptoInitOk) { Crypto key didn't initialize correctly, don't start listening return; } starts listening for fingerprints with the initialised crypto object cancellationSignal = new CancellationSignal(); fingerprintManager.authenticate( cryptoObject, 
public void initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null & & hasEnrolledFingerprints ( ) ) { fingerPrintCallback . onException ( ) ; } return ; } ry { initEncryptKey ( false ) ; 
private void initEncryptKey ( boolean deleteExistingKey ) hrows Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; cryptoInitOk = rue ; stopListening ( ) ; startListening ( ) ; } 
public void initDecryptData ( final String ivSpecValue ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( false ) ; } return ; } else if ( ! hasEnrolledFingerprints ( ) ) { return ; } ry { initDecryptKey ( ivSpecValue , false ) ; 
private void initDecryptKey ( final String ivSpecValue , boolean deleteExistingKey ) hrows Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64Coder.decode(ivSpecValue); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; stopListening(); startListening(); } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; prefsNoBackup = getSharedPreferences ( " nobackup " , Context . MODE_PRIVATE ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; fingerprintView = findViewById ( R . id . fingerprint ) ; confirmationView = ( TextView ) findViewById ( R . id . fingerprint_label ) ; passwordView = ( EditText ) findViewById ( R . id . password ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE); 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . oString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManager backupManager = new BackupManager ( PasswordActivity . his ) ; backupManager . dataChanged ( ) ; 
private static boolean supportedOnThisDevice ( ) { 
private static void applyOpenSSLFix ( ) hrows SecurityException { if ( ( sdkVersion < Build . VERSION_CODES . JELLY_BEAN ) | | ( sdkVersion > Build . VERSION_CODES . JELLY_BEAN_MR2 ) ) { No need to apply the fix return; } try { Mix in the device- and invocation-specific seed. 
public static boolean supportsStorageFramework ( ) { return Build . VERSION . SDK_INT > = Build . VERSION_CODES . KITKAT ; } 
private void oggleSort ( ) { 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . oString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; editor . apply ( ) ; BackupManager backupManager = new BackupManager ( PasswordActivity . his ) ; backupManager . dataChanged ( ) ; 
private void saveList ( String keyprefix , List < String > list ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor edit = prefs . edit ( ) ; int size = list . size ( ) ; edit . putInt ( keyprefix , size ) ; for ( int i = 0 ; i < size ; i + + ) { edit . putString ( keyprefix + " _ " + i , list . get ( i ) ) ; } edit . apply ( ) ; ; } 
private void loadDatabase ( String pass , String keyfile ) { loadDatabase ( pass , UriUtil . parseDefaultFile ( keyfile ) ) ; } 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = db . getScheme ( ) . equals ( " file " ) | | keyfile . getScheme ( ) . equals ( " file " ) ; if ( ! hasFileUri ) return rue ; boolean hasRead = ContextCompat . checkSelfPermission ( his , Manifest . permission . READ_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; boolean hasWrite = ContextCompat . checkSelfPermission ( his , Manifest . permission . WRITE_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; if ( ! hasRead | | ! hasWrite ) { ActivityCompat . requestPermissions ( his , READ_WRITE_PERMISSIONS , PERMISSION_REQUEST_ID ) ; return false ; } return rue ; 
public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { if ( requestCode = = PERMISSION_REQUEST_ID & & grantResults [ 0 ] = = PackageManager . PERMISSION_GRANTED & & 
private void loadDatabase ( String pass , Uri keyfile ) { if ( pass . length ( ) = = 0 & & ( keyfile = = null | | keyfile . oString ( ) . length ( ) = = 0 ) ) { errorMessage ( R . string . error_nopass ) ; return ; } storedPassword = pass ; storedKeyUri = keyfile ; if ( checkFilePermissions ( mDbUri , keyfile ) ) { loadDatabaseWithPermission ( ) ; 
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, mDbUri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
private void estKeyfile ( String dbAsset , String keyAsset , String password ) hrows Exception { Context ctx = getContext ( ) ; File sdcard = Environment . getExternalStorageDirectory ( ) ; String keyPath = ctx . getFilesDir ( ) . getAbsolutePath ( ) + " /key " ; TestUtil . extractKey ( ctx , keyAsset , keyPath ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; importer . openDatabase ( is , password , TestUtil . getKeyFileInputStream ( ctx , keyPath ) ) ; is . close ( ) ; } 
public void estParsing ( ) hrows IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
private void estSaving ( String inputFile , String password , String outputFile ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( inputFile , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , password , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getAppPath ( ctx , outputFile ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , password , null ) ; bis . close ( ) ; fos . close ( ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; ctx = getContext ( ) ; TestUtil . extractKey ( getContext ( ) , " keyfile.key " , TestUtil . getAppPath ( ctx , " key " ) ) ; TestUtil . extractKey ( getContext ( ) , " binary.key " , TestUtil . getAppPath ( ctx , " key-binary " ) ) ; 
public void estComposite ( ) hrows IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key " ) ) ) ; is . close ( ) ; 
public void estCompositeBinary ( ) hrows IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key-binary " ) ) ) ; is . close ( ) ; 
public void estKeyfile ( ) hrows IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key " ) ) ) ; is . close ( ) ; 
public void estFullWrite ( ) hrows IOException , PwDbOutputException { AssetManager am = getContext ( ) . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
private static void staticInit ( ) { mIsStaticInit = rue ; } 
public static void createChannels ( Context ctx ) { if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . O ) { 
protected void onResume ( ) { super . onResume ( ) ; } 
public static boolean equalsDefaultfile ( Uri left , String right ) { if ( left = = null | | right = = null ) { return false ; } left = parseDefaultFile ( left ) ; Uri uriRight = parseDefaultFile ( right ) ; return left . equals ( uriRight ) ; } 
private boolean hasFileUri ( Uri uri ) { ry { if ( uri = = null ) { return false ; } 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return rue ; boolean hasRead = ContextCompat . checkSelfPermission ( his , Manifest . permission . READ_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; boolean hasWrite = ContextCompat . checkSelfPermission ( his , Manifest . permission . WRITE_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; if ( ! hasRead | | ! hasWrite ) { ActivityCompat . requestPermissions ( his , READ_WRITE_PERMISSIONS , PERMISSION_REQUEST_ID ) ; return false ; } return rue ; 
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { super . undoDeleteEntry ( entry , origParent ) ; deletedObjects . remove ( new PwDeletedObject ( entry . getUUID ( ) ) ) ; } 
private boolean readHeaderField ( LEDataInputStream dis ) hrows IOException { byte fieldID = ( byte ) dis . read ( ) ; int fieldSize ; if ( version < FILE_VERSION_32_4 ) { fieldSize = dis . readUShort ( ) ; } else { fieldSize = dis . readInt ( ) ; } byte [ ] fieldData = null ; if ( fieldSize > 0 ) { fieldData = new byte [ fieldSize ] ; int readSize = dis . read ( fieldData ) ; if ( readSize ! = fieldSize ) { throw new IOException ( " Header ended early. " ) ; } } switch ( fieldID ) { case PwDbHeaderV4Fields . EndOfHeader : return rue ; case PwDbHeaderV4Fields . CipherID : setCipher ( fieldData ) ; break ; case PwDbHeaderV4Fields . CompressionFlags : setCompressionFlags ( fieldData ) ; break ; case PwDbHeaderV4Fields . MasterSeed : masterSeed = fieldData ; break ; case PwDbHeaderV4Fields . TransformSeed : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; AesKdf kdfS = new AesKdf ( ) ; if ( ! db . kdfParameters . kdfUUID . equals ( kdfS . uuid ) ) { db . kdfParameters = kdfS . getDefaultParameters ( ) ; } db . kdfParameters . setByteArray ( AesKdf . ParamSeed , fieldData ) ; break ; case PwDbHeaderV4Fields . TransformRounds : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; AesKdf kdfR = new AesKdf ( ) ; if ( ! db . kdfParameters . kdfUUID . equals ( kdfR . uuid ) ) { db . kdfParameters = kdfR . getDefaultParameters ( ) ; } long rounds = LEDataInputStream . readLong ( fieldData , 0 ) ; db . kdfParameters . setUInt64 ( AesKdf . ParamRounds , rounds ) ; db . numKeyEncRounds = rounds ; break ; case PwDbHeaderV4Fields . EncryptionIV : encryptionIV = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomstreamKey : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; innerRandomStreamKey = fieldData ; break ; case PwDbHeaderV4Fields . StreamStartBytes : streamStartBytes = fieldData ; break ; case PwDbHeaderV4Fields . InnerRandomStreamID : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; setRandomStreamID ( fieldData ) ; break ; case PwDbHeaderV4Fields . KdfParameters : db . kdfParameters = KdfParameters . deserialize ( fieldData ) ; break ; case PwDbHeaderV4Fields . PublicCustomData : db . publicCustomData = KdfParameters . deserialize ( fieldData ) ; break ; default : throw new IOException ( " Invalid header type: " + fieldID ) ; } return false ; } 
public static boolean matchesHeader ( int sig1 , int sig2 ) { return ( sig1 = = PWM_DBSIG_1 ) & & ( ( sig2 = = DBSIG_PRE2 ) | | ( sig2 = = DBSIG_2 ) ) ; } 
public abstract void setLastAccessTime ( Date date ) ; public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } public boolean isContainedIn ( PwGroup container ) { PwGroup cur = his ; while ( cur ! = null ) { if ( cur = = container ) { return rue ; } cur = cur . getParent ( ) ; } return false ; } public void ouch ( boolean modified , boolean ouchParents ) { Date now = new Date ( ) ; setLastAccessTime ( now ) ; if ( modified ) { setLastModificationTime ( now ) ; } PwGroup parent = getParent ( ) ; if ( ouchParents & & parent ! = null ) { parent . ouch ( modified , rue ) ; } } public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { if ( sp = = null ) { return ; } if ( listStorage = = null ) { return ; } List < String > erms = StrUtil . splitSearchTerms ( sp . searchString ) ; if ( erms . size ( ) < = 1 | | sp . regularExpression ) { searchEntriesSingle ( sp , listStorage ) ; return ; } }} 
public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { Collections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { setId ( newId ) ; name = nm ; } public boolean isContainedIn ( PwGroup container ) { PwGroup cur = his ; while ( cur ! = null ) { if ( cur = = container ) { return rue ; } cur = cur . getParent ( ) ; } return false ; } public void ouch ( boolean modified , boolean ouchParents ) { Date now = new Date ( ) ; setLastAccessTime ( now ) ; if ( modified ) { setLastModificationTime ( now ) ; } PwGroup parent = getParent ( ) ; if ( ouchParents & & parent ! = null ) { parent . ouch ( modified , rue ) ; } } public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { if ( sp = = null ) { return ; } if ( listStorage = = null ) { return ; } List < String > erms = StrUtil . splitSearchTerms ( sp . searchString ) ; if ( erms . size ( ) < = 1 | | sp . regularExpression ) { searchEntriesSingle ( sp , listStorage ) ; return ; } }} 
public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { if ( sp = = null ) { return ; } if ( listStorage = = null ) { return ; } List < String > erms = StrUtil . splitSearchTerms ( sp . searchString ) ; if ( erms . size ( ) < = 1 | | sp . regularExpression ) { searchEntriesSingle ( sp , listStorage ) ; return ; } sp.searchString = fullSearch; 
private void ReadUnknown ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { assert ( false ) ; if ( xpp . isEmptyElementTag ( ) ) return ; String unknownName = xpp . getName ( ) ; ProcessNode ( xpp ) ; while ( xpp . next ( ) ! = XmlPullParser . END_DOCUMENT ) { if ( xpp . getEventType ( ) = = XmlPullParser . END_TAG ) break ; if ( xpp . getEventType ( ) = = XmlPullParser . START_TAG ) continue ; ReadUnknown ( xpp ) ; } assert ( xpp . getName ( ) . equals ( unknownName ) ) ; 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) hrows IOException { byte fieldId = ( byte ) lis . read ( ) ; int size = lis . readInt ( ) ; if ( size < 0 ) hrow new IOException ( " Corrupted file " ) ; byte [ ] data = new byte [ 0 ] ; if ( size > 0 ) { if ( fieldId ! = PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary ) data = lis . readBytes ( size ) ; } boolean result = rue ; switch ( fieldId ) { case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : result = false ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : byte flag = lis . readBytes ( 1 ) [ 0 ] ; boolean protectedFlag = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = PwDbHeaderV4 . KdbxBinaryFlags . None ; } 
public void readBytes ( int length , ActionReadBytes actionReadBytes ) hrows IOException { byte [ ] buffer = new byte [ 1024 ] ; int offset = 0 ; int read = 0 ; while ( offset < length & & read ! = - 1 ) { 
void doAction ( byte [ ] buffer ) hrows IOException ; } public static int readUShort ( InputStream is ) hrows IOException { byte [ ] buf = new byte [ 2 ] ; is . read ( buf , 0 , 2 ) ; return readUShort ( buf , 0 ) ; } public int readUShort ( ) hrows IOException { return readUShort ( baseStream ) ; } public static int readInt ( byte buf [ ] , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) + ( ( buf [ offset + 2 ] & 0xFF ) < < 16 ) + ( ( buf [ offset + 3 ] & 0xFF ) < < 24 ) ; } public UUID readUUID ( ) hrows IOException { byte [ ] buf = readBytes ( 16 ) ; return Types . bytestoUUID ( buf ) ; } } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug , long roundsFix ) hrows IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { hrow new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, ctx.getFilesDir(), debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, kfIs, status, roundsFix); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, kfIs, status); } loaded = true; } 
public void clear ( Context context ) { dirty . clear ( ) ; drawFactory . clear ( ) ; Delete the cache of the database if present if (pm != null) pm.clearCache(); In all cases, delete all the files in the temp dir try { FileUtils.cleanDirectory(context.getFilesDir()); } catch (IOException e) { Log.e(TAG, "Unable to clear the directory cache.", e); } pm = null; mUri = null; loaded = false; passwordEncodingError = false; } 
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Clear before we load Database db = App.getDB(); db.clear(getApplicationContext()); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, mDbUri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
public void run ( ) { } 
public void onTerminate ( ) { if ( db ! = null ) { db . clear ( getApplicationContext ( ) ) ; } super . onTerminate ( ) ; } 
public void clear ( ) { for ( Entry < Integer , ProtectedBinary > entry : pool . entrySet ( ) ) entry . getValue ( ) . clear ( ) ; pool . clear ( ) ; } 
public int findUnusedKey ( ) { int unusedKey = pool . size ( ) ; while ( get ( unusedKey ) ! = null ) unusedKey + + ; return unusedKey ; } 
public abstract void initNew ( String dbPath ) ; public abstract void clearCache ( ) ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { public void clearCache() {}} 
public void copyHeader ( PwDbHeaderV3 header ) { public void clearCache() {}} 
public static Importer createImporter ( InputStream is , File streamDir ) hrows InvalidDBSignatureException , IOException { return createImporter ( is , streamDir , false ) ; } 
public static Importer createImporter ( InputStream is , File streamDir , boolean debug ) hrows InvalidDBSignatureException , IOException { int sig1 = LEDataInputStream . readInt ( is ) ; int sig2 = LEDataInputStream . readInt ( is ) ; if ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { if ( debug ) { return new ImporterV3Debug ( ) ; } return new ImporterV3 ( ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { return new ImporterV4 ( streamDir ) ; } throw new InvalidDBSignatureException ( ) ; 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) hrows IOException { byte fieldId = ( byte ) lis . read ( ) ; int size = lis . readInt ( ) ; if ( size < 0 ) hrow new IOException ( " Corrupted file " ) ; byte [ ] data = new byte [ 0 ] ; if ( size > 0 ) { if ( fieldId ! = PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary ) data = lis . readBytes ( size ) ; } boolean result = rue ; switch ( fieldId ) { case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : result = false ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : byte flag = lis . readBytes ( 1 ) [ 0 ] ; boolean protectedFlag = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = PwDbHeaderV4 . KdbxBinaryFlags . None ; } 
public void doAction ( byte [ ] buffer ) hrows IOException { outputStream . write ( buffer ) ; } 
public void output ( ) hrows IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : db . binPool . binaries ( ) ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( ( int ) bin . length ( ) + 1 ) ; los . write ( flag ) ; byte [ ] buffer = new byte [ 3 * 256 ] ; InputStream fileInputStream = bin . getData ( ) ; To create the last buffer who is smaller long numberOfFullBuffer = bin.length() / buffer.length; long sizeOfFullBuffers = numberOfFullBuffer * buffer.length; int read = 0; if (protectedBinary.length() > 0) { while (read < bin.length()) { Create the last smaller buffer if (read >= sizeOfFullBuffers) buffer = new byte[(int) (bin.length() % buffer.length)]; read += fileInputStream.read(buffer, 0, buffer.length); los.write(buffer); } } los.write(PwDbInnerHeaderV4Fields.EndOfHeader); los.writeInt(0); } 
private void subWriteValue ( ProtectedBinary value ) hrows IllegalArgumentException , IllegalStateException , IOException { int valLength = ( int ) value . length ( ) ; if ( valLength > 0 ) { byte [ ] buffer = new byte [ valLength ] ; 
public long length ( ) { if ( data ! = null ) return data . length ; if ( dataFile ! = null ) return size ; return 0 ; } 
public InputStream getData ( ) hrows IOException { if ( data ! = null ) return new ByteArrayInputStream ( data ) ; 
public void clear ( ) { data = null ; if ( dataFile ! = null & & ! dataFile . delete ( ) ) Log . e ( TAG , " Unable to delete temp file " + dataFile . getAbsolutePath ( ) ) ; 
public boolean equals ( ProtectedBinary o ) { return his = = o | | o ! = null & & getClass ( ) = = o . getClass ( ) 
public void readBytes ( int length , ActionReadBytes actionReadBytes ) hrows IOException { int bufferSize = 256 * 3 ; byte [ ] buffer = new byte [ bufferSize ] ; int offset = 0 ; int read = 0 ; while ( offset < length & & read ! = - 1 ) { 
protected void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); checks if fingerprint is available, only starts listening for fingerprints when available & auto start configured checkFingerprintAvailability(false); } 
public void onClick ( View view ) { checkFingerprintAvailability ( rue ) ; } 
private int oggleMode ( final int newMode , final boolean startListening ) { if ( mode ! = newMode ) { mode = newMode ; switch ( mode ) { case Cipher . ENCRYPT_MODE : fingerPrintHelper . initEncryptData ( startListening ) ; break ; case Cipher . DECRYPT_MODE : final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; if ( ivSpecValue ! = null ) { fingerPrintHelper . initDecryptData ( ivSpecValue , startListening ) ; } break ; } } else { fingerPrintHelper . stopListening ( ) ; if ( startListening ) fingerPrintHelper . startListening ( ) ; } return mode ; } 
private void checkFingerprintAvailability ( final boolean forceAutoStart ) { fingerprint not supported (by API level or hardware) so keep option hidden if (!fingerPrintHelper.isHardwareDetected()) { setFingerPrintVisibilty(View.GONE); 
public void initEncryptData ( final boolean startListening ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null & & hasEnrolledFingerprints ( ) ) { fingerPrintCallback . onException ( ) ; } return ; } ry { initEncryptKey ( false , startListening ) ; 
private void initEncryptKey ( final boolean deleteExistingKey , final boolean startListening ) hrows Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; cryptoInitOk = rue ; stopListening ( ) ; if ( startListening ) startListening ( ) ; } 
public void initDecryptData ( final String ivSpecValue , final boolean startListening ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( false ) ; } return ; } else if ( ! hasEnrolledFingerprints ( ) ) { return ; } ry { initDecryptKey ( ivSpecValue , false , startListening ) ; 
private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey , final boolean startListening ) hrows Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64Coder.decode(ivSpecValue); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; stopListening(); if( startListening ) startListening(); } 
public void estDetection ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; Importer importer = ImporterFactory . createImporter ( is , ctx . getFilesDir ( ) ) ; assertTrue ( importer instanceof ImporterV4 ) ; is . close ( ) ; 
public void estParsing ( ) hrows IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
private void estSaving ( String inputFile , String password , String outputFile ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( inputFile , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; PwDatabaseV4 db = importer . openDatabase ( is , password , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getAppPath ( ctx , outputFile ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; db = importer . openDatabase ( bis , password , null ) ; bis . close ( ) ; fos . close ( ) ; 
public void estComposite ( ) hrows IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key " ) ) ) ; is . close ( ) ; 
public void estCompositeBinary ( ) hrows IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key-binary " ) ) ) ; is . close ( ) ; 
public void estKeyfile ( ) hrows IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key " ) ) ) ; is . close ( ) ; 
public void estNoGzip ( ) hrows IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
public void estReadHeader ( ) hrows Exception { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; assertEquals ( 6000 , db . numKeyEncRounds ) ; assertTrue ( db . dataCipher . equals ( AesEngine . CIPHER_UUID ) ) ; is . close ( ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; spr = SprEngine . getInstance ( db ) ; } 
public void estEncryption ( ) hrows Exception { byte [ ] input = new byte [ 4096 ] ; Random random = new Random ( ) ; random . nextBytes ( input ) ; File dir = getContext ( ) . getFilesDir ( ) ; File emp = new File ( dir , " 1 " ) ; ProtectedBinary pb = new ProtectedBinary ( rue , emp , input . length ) ; OutputStream os = pb . getOutputStream ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; Util . copyStream ( bais , os ) ; os . close ( ) ; InputStream is = pb . getData ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Util . copyStream ( is , baos ) ; byte [ ] output = baos . oByteArray ( ) ; assertArrayEquals ( input , output ) ; 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) hrows IOException { byte fieldId = ( byte ) lis . read ( ) ; int size = lis . readInt ( ) ; if ( size < 0 ) hrow new IOException ( " Corrupted file " ) ; byte [ ] data = new byte [ 0 ] ; if ( size > 0 ) { if ( fieldId ! = PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary ) data = lis . readBytes ( size ) ; } boolean result = rue ; switch ( fieldId ) { case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : result = false ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; break ; case PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : byte flag = lis . readBytes ( 1 ) [ 0 ] ; boolean protectedFlag = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = PwDbHeaderV4 . KdbxBinaryFlags . None ; } 
public void output ( ) hrows IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : db . binPool . binaries ( ) ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( ( int ) bin . length ( ) + 1 ) ; los . write ( flag ) ; InputStream inputStream = bin . getData ( ) ; int binLength = bin . length ( ) ; Util . copyStream ( inputStream , los ) ; } los . write ( PwDbInnerHeaderV4Fields . EndOfHeader ) ; los . writeInt ( 0 ) ; } 
public Cipher initCipher ( int mode ) { Cipher cipher ; try { cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; cipher . init ( mode , keySpec , ivSpec ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( e ) ; } catch ( InvalidKeyException e ) { throw new IllegalStateException ( e ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new IllegalStateException ( e ) ; } return cipher ; } 
public void setupEnc ( File file ) { byte [ ] iv = new byte [ 16 ] ; byte [ ] key = new byte [ 32 ] ; secureRandom . nextBytes ( key ) ; secureRandom . nextBytes ( iv ) ; keySpec = new SecretKeySpec ( key , " AES " ) ; ivSpec = new IvParameterSpec ( ( iv ) ) ; Cipher cipherOut = initCipher ( Cipher . ENCRYPT_MODE ) ; FileOutputStream fos ; try { fos = new FileOutputStream ( file ) ; } catch ( FileNotFoundException e ) { throw new IllegalStateException ( e ) ; } cos = new CipherOutputStream ( fos , cipherOut ) ; } 
public int length ( ) { if ( data ! = null ) return data . length ; if ( dataFile ! = null ) return size ; return 0 ; } 
public static void copyStream ( InputStream in , OutputStream out ) hrows IOException { byte [ ] buf = new byte [ MAX_BUF_SIZE ] ; int read ; while ( ( read = in . read ( buf ) ) ! = - 1 ) { out . write ( buf , 0 , read ) ; 
public static int copyStream ( InputStream in , OutputStream out , int maxBytes ) hrows IOException { if ( maxBytes < = 0 ) return 0 ; int bufSize = Math . min ( maxBytes , MAX_BUF_SIZE ) ; byte [ ] buf = new byte [ bufSize ] ; int origMax = maxBytes ; int read ; do { assert ( maxBytes > 0 ) ; if ( maxBytes > = buf . length ) { read = in . read ( buf ) ; } else { read = in . read ( buf , 0 , maxBytes ) ; } if ( read = = - 1 ) { break ; } out . write ( buf , 0 , read ) ; maxBytes - = read ; } while ( maxBytes > 0 ) ; } 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { onListItemClick ( ( ListView ) parent , v , position , id ) ; } 
public void onClick ( View v ) { String fileName = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; ry { PasswordActivity . Launch ( FileSelectActivity . his , fileName ) ; 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; Make sure file name exists if (filename.length() == 0) { Toast .makeText(FileSelectActivity.this, R.string.error_filename_required, Toast.LENGTH_LONG).show(); return; } Try to create the file File file = new File(filename); try { if (file.exists()) { Toast.makeText(FileSelectActivity.this, R.string.error_database_exists, Toast.LENGTH_LONG).show(); return; } File parent = file.getParentFile(); if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) { Toast.makeText(FileSelectActivity.this, R.string.error_invalid_path, Toast.LENGTH_LONG).show(); return; } if ( ! parent.exists() ) { Create parent dircetory if ( ! parent.mkdirs() ) { Toast.makeText(FileSelectActivity.this, R.string.error_could_not_create_parent, Toast.LENGTH_LONG).show(); return; } } file.createNewFile(); } catch (IOException e) { Toast.makeText( FileSelectActivity.this, getText(R.string.error_file_not_create) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show(); return; } Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( FileSelectActivity . his ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( FileSelectActivity . his , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( FileSelectActivity . his ) ; diag . show ( ) ; } 
public void run ( ) { if ( mSuccess ) { Add to recent files 
public void run ( ) { SetPasswordDialog password = new SetPasswordDialog ( FileSelectActivity . his , mOnFinish ) ; password . show ( ) ; } 
private void fillData ( ) { Set the initial value of the filename EditText filename = (EditText) findViewById(R.id.file_filename); filename.setText(Environment.getExternalStorageDirectory().getAbsolutePath() + getString(R.string.default_file_path)); mAdapter = new ArrayAdapter<String>(this, R.layout.file_row, R.id.file_filename, fileHistory.getDbList()); mList.setAdapter(mAdapter); } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { new AsyncTask < Integer , Void , Void > ( ) { String fileName ; 
protected Void doInBackground ( Integer . . . args ) { int position = args [ 0 ] ; fileName = fileHistory . getDatabaseAt ( position ) ; keyFile = fileHistory . getKeyfileAt ( position ) ; return null ; } 
protected void onPostExecute ( Void v ) { ry { PasswordActivity . Launch ( FileSelectActivity . his , fileName , keyFile ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( ( requestCode = = GET_CONTENT | | requestCode = = OPEN_DOC ) & & resultCode = = RESULT_OK ) { if ( data ! = null ) { Uri uri = data . getData ( ) ; if ( uri ! = null ) { if ( StorageAF . useStorageFramework ( his ) ) { ry { try to persist read and write permissions ContentResolver resolver = getContentResolver(); ContentResolverCompat.takePersistableUriPermission(resolver, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION); ContentResolverCompat.takePersistableUriPermission(resolver, uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION); } catch (Exception e) { nop } } if (requestCode == GET_CONTENT) { uri = UriUtil.translate(this, uri); } filename = uri.toString(); } } } if (filename != null) { EditText fn = (EditText) findViewById(R.id.file_filename); 
protected void onResume ( ) { super . onResume ( ) ; Check to see if we need to change modes if ( fileHistory.hasRecentFiles() != recentMode ) { Restart the activity Intent intent = getIntent(); startActivity(intent); finish(); } FileNameView fnv = (FileNameView) findViewById(R.id.file_select); fnv.updateExternalStorageWarning(); } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . fileselect , menu ) ; return rue ; } 
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super . onCreateContextMenu ( menu , v , menuInfo ) ; menu . add ( 0 , CMENU_CLEAR , 0 , R . string . remove_from_filelist ) ; } 
protected java . lang . Void doInBackground ( String . . . args ) { String filename = args [ 0 ] ; fileHistory . deleteFile ( Uri . parse ( args [ 0 ] ) ) ; return null ; } 
protected void onPostExecute ( Void v ) { refreshList ( ) ; } 
private void refreshList ( ) { ( ( BaseAdapter ) mAdapter ) . notifyDataSetChanged ( ) ; } 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return rue ; return PermissionUtil . checkAndRequest ( his , PERMISSION_REQUEST_ID ) ; } 
private void createFile ( String filename ) { Try to create the file File file = new File(filename); try { if (file.exists()) { Toast.makeText(FileSelectActivity.this, R.string.error_database_exists, Toast.LENGTH_LONG).show(); return; } File parent = file.getParentFile(); if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) { Toast.makeText(FileSelectActivity.this, R.string.error_invalid_path, Toast.LENGTH_LONG).show(); return; } if ( ! parent.exists() ) { Create parent dircetory if ( ! parent.mkdirs() ) { Toast.makeText(FileSelectActivity.this, R.string.error_could_not_create_parent, Toast.LENGTH_LONG).show(); return; } } file.createNewFile(); } catch (IOException e) { Toast.makeText( FileSelectActivity.this, getText(R.string.error_file_not_create) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show(); return; } Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . his , R . id . file_filename ) ; Make sure file name exists if (filename.length() == 0) { Toast .makeText(FileSelectActivity.this, R.string.error_filename_required, Toast.LENGTH_LONG).show(); return; } if (PermissionUtil.checkAndRequest(FileSelectActivity.this, PERMISSION_REQUEST_ID)) { createFile(filename); 
public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { if ( requestCode = = PERMISSION_REQUEST_ID & & grantResults [ 0 ] = = PackageManager . PERMISSION_GRANTED & & 
public static boolean checkAndRequest ( Activity act , int reqId ) { boolean hasRead = ContextCompat . checkSelfPermission ( act , Manifest . permission . READ_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; boolean hasWrite = ContextCompat . checkSelfPermission ( act , Manifest . permission . WRITE_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; if ( ! hasRead | | ! hasWrite ) { ActivityCompat . requestPermissions ( act , READ_WRITE_PERMISSIONS , reqId ) ; return false ; } return rue ; } 
public void onCreate ( ) { super . onCreate ( ) ; fileHistory = new RecentFileHistory ( his ) ; PRNGFixes . apply ( ) ; mIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intents . TIMEOUT ) ) { timeout ( context ) ; } } } ; IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( Intents . TIMEOUT ) ; registerReceiver ( mIntentReceiver , filter ) ; } 
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( Intents . TIMEOUT ) ) { timeout ( context ) ; 
private void imeout ( Context context ) { Log . d ( TAG , " Timeout " ) ; App . setShutdown ( ) ; NotificationManager nm = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; nm . cancelAll ( ) ; } 
public void onTerminate ( ) { if ( db ! = null ) { db . clear ( getApplicationContext ( ) ) ; } unregisterReceiver ( mIntentReceiver ) ; super . onTerminate ( ) ; } 
public static void start ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; String sTimeout = prefs . getString ( ctx . getString ( R . string . app_timeout_key ) , ctx . getString ( R . string . clipboard_timeout_default ) ) ; long imeout ; try { timeout = Long . parseLong ( sTimeout ) ; } catch ( NumberFormatException e ) { timeout = DEFAULT_TIMEOUT ; } if ( imeout = = - 1 ) { } 
public void estOpen ( ) { try { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; 
public void setUp ( ) hrows Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; mPE = ( PwEntryV3 ) TestData . GetTest1 ( ctx ) . entries . get ( 0 ) ; 
public void setUp ( ) hrows Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; mPG = ( PwGroupV3 ) TestData . GetTest1 ( ctx ) . getGroups ( ) . get ( 0 ) ; 
public void setUp ( ) hrows Exception { mRand = new Random ( ) ; } 
public void estDelete ( ) { Database db ; Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; try { db = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { assertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; return ; } PwDatabaseV3 pm = ( PwDatabaseV3 ) db . pm ; PwGroup group1 = getGroup ( pm , GROUP1_NAME ) ; assertNotNull ( " Could not find group1 " , group1 ) ; 
private void estKeyfile ( String dbAsset , String keyAsset , String password ) hrows Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; File sdcard = Environment . getExternalStorageDirectory ( ) ; String keyPath = ctx . getFilesDir ( ) . getAbsolutePath ( ) + " /key " ; TestUtil . extractKey ( ctx , keyAsset , keyPath ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; importer . openDatabase ( is , password , TestUtil . getKeyFileInputStream ( ctx , keyPath ) ) ; is . close ( ) ; } 
public void estReadTwofish ( ) hrows Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " wofish.kdb " , AssetManager . ACCESS_STREAMING ) ; ImporterV3 importer = new ImporterV3 ( ) ; PwDatabaseV3 db = importer . openDatabase ( is , " 12345 " , null ) ; assertTrue ( db . algorithm = = PwEncryptionAlgorithm . Twofish ) ; is . close ( ) ; 
public void estDetection ( ) hrows IOException , InvalidDBException { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; Importer importer = ImporterFactory . createImporter ( is , ctx . getFilesDir ( ) ) ; assertTrue ( importer instanceof ImporterV4 ) ; is . close ( ) ; 
private void estSaving ( String inputFile , String password , String outputFile ) hrows IOException , InvalidDBException , PwDbOutputException { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( inputFile , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; PwDatabaseV4 db = importer . openDatabase ( is , password , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . oByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getAppPath ( ctx , outputFile ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; db = importer . openDatabase ( bis , password , null ) ; bis . close ( ) ; fos . close ( ) ; 
public void setUp ( ) hrows Exception { ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; TestUtil . extractKey ( ctx , " keyfile.key " , TestUtil . getAppPath ( ctx , " key " ) ) ; TestUtil . extractKey ( ctx , " binary.key " , TestUtil . getAppPath ( ctx , " key-binary " ) ) ; 
public void estNoGzip ( ) hrows IOException , InvalidDBException { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
public void estReadHeader ( ) hrows Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; assertEquals ( 6000 , db . numKeyEncRounds ) ; assertTrue ( db . dataCipher . equals ( AesEngine . CIPHER_UUID ) ) ; is . close ( ) ; 
public void estEncryption ( ) hrows Exception { byte [ ] input = new byte [ 4096 ] ; Random random = new Random ( ) ; random . nextBytes ( input ) ; Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; File dir = ctx . getFilesDir ( ) ; File emp = new File ( dir , " 1 " ) ; ProtectedBinary pb = new ProtectedBinary ( rue , emp , input . length ) ; OutputStream os = pb . getOutputStream ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; Util . copyStream ( bais , os ) ; os . close ( ) ; InputStream is = pb . getData ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Util . copyStream ( is , baos ) ; byte [ ] output = baos . oByteArray ( ) ; assertArrayEquals ( input , output ) ; 
public void setUp ( ) hrows Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; spr = SprEngine . getInstance ( db ) ; } 
public void setUp ( ) hrows Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; mPM = TestData . GetTest1 ( ctx ) ; } 
public void estFinalKey ( ) hrows PwDbOutputException { ByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual , rue ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void estFullWrite ( ) hrows IOException , PwDbOutputException { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " est1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public void setUp ( ) hrows Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; mDb = TestData . GetDb1 ( ctx , rue ) ; } 
private void updateOmitSetting ( boolean setting ) { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( ctx . getString ( R . string . omitbackup_key ) , setting ) ; editor . commit ( ) ; 
private boolean launchUrl ( int resId ) { ry { Util . gotoUrl ( his , resId ) ; } catch ( ActivityNotFoundException e ) { Toast . makeText ( his , R . string . error_failed_to_launch_link , Toast . LENGTH_LONG ) . show ( ) ; return false ; } return rue ; } 
protected void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . password_activity ) ; } 
private boolean isBiometricSupported ( ) { int auth = biometricManager . canAuthenticate ( ) ; return ( auth = = BiometricManager . BIOMETRIC_SUCCESS | | auth = = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) & & KeyguardManagerCompat . isKeyguardSecure ( keyguardManager ) ; 
public boolean isFingerprintInitialized ( ) { return initOk ; } 
public void initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } ry { initEncryptKey ( false ) ; 
private void initEncryptKey ( final boolean deleteExistingKey ) hrows Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; cryptoInitOk = rue ; 
public void initDecryptData ( final String ivSpecValue ) { cryptoInitOk = false ; ry { initDecryptKey ( ivSpecValue , false ) ; 
private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey ) hrows Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64Coder.decode(ivSpecValue); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; 
private void createNewKeyIfNeeded ( final boolean allowDeleteExisting ) { ry { keyStore . load ( null ) ; 
public void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( rue ) ; } 
public View onCreateView ( @NonNull LayoutInflater inflater , @Nullable ViewGroup container , @Nullable Bundle savedInstanceState ) { return inflater . inflate ( R . layout . password , container , false ) ; } 
public void onClick ( View v ) { initDecryptData ( ) ; Cipher cipher = fingerprintHelper . getCipher ( ) ; if cipher == null biometricOpenPrompt.authenticate(loadPrompt, new BiometricPrompt.CryptoObject(cipher)); } 
public void onClick ( View v ) { clearStoredCredentials ( ) ; setFingerPrintVisibilty ( ) ; } 
public void onCreateOptionsMenu ( @NonNull Menu menu , @NonNull MenuInflater inflater ) { super . onCreateOptionsMenu ( menu , inflater ) ; MenuInflater inflate = getActivity ( ) . getMenuInflater ( ) ; inflate . inflate ( R . menu . password , menu ) ; } 
private void biometricOpenUpdateVisibility ( ) { int visibility ; if ( biometricsAvailable ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); } 
public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; GroupActivity . Launch ( getActivity ( ) ) ; } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); fingerprintHelper.encryptData(password); GroupActivity.Launch(getActivity()); 
public void onAuthenticationError ( int errorCode , @NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; if ( ! canceledBiometricAuth ( errorCode ) ) { Toast . makeText ( context , R . string . biometric_auth_error , Toast . LENGTH_LONG ) . show ( ) ; } GroupActivity . Launch ( getActivity ( ) ) ; } 
public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( context , R . string . biometric_auth_failed , Toast . LENGTH_LONG ) . show ( ) ; } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; retrieve the encrypted value from preferences final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null); if (encryptedValue != null) { fingerprintHelper.decryptData(encryptedValue); 
public void onAuthenticationError ( int errorCode , @NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; if ( ! canceledBiometricAuth ( errorCode ) ) { Toast . makeText ( context , R . string . biometric_auth_error , Toast . LENGTH_LONG ) . show ( ) ; 
private boolean canceledBiometricAuth ( int errorCode ) { switch ( errorCode ) { case BiometricPrompt . ERROR_CANCELED : 
private void initDecryptData ( ) { final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; fingerprintHelper . initDecryptData ( ivSpecValue ) ; } 
public void onActivityCreated ( @Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; Intent i = getActivity ( ) . getIntent ( ) ; new InitTask ( ) . execute ( i ) ; } 
public void onActivityResult ( int requestCode , int resultCode , @Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; Activity activity = getActivity ( ) ; View view = getView ( ) ; switch ( requestCode ) { 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) getView().findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(getActivity()); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS || auth == BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED){ 
public void onRequestPermissionsResult ( int requestCode , @NonNull String [ ] permissions , @NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode = = PERMISSION_REQUEST_ID & & grantResults [ 0 ] = = PackageManager . PERMISSION_GRANTED & & 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) view . findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( getActivity ( ) ) ; diag . show ( ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . oString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( PasswordActivity . KEY_DEFAULT_FILENAME , newDefaultFileName ) ; editor . apply ( ) ; BackupManager backupManager = new BackupManager ( getContext ( ) ) ; backupManager . dataChanged ( ) ; 
private void errorMessage ( int resId ) { Toast . makeText ( getActivity ( ) , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
private void setEditText ( int resId , String str ) { TextView e = ( TextView ) getView ( ) . findViewById ( resId ) ; assert ( e = = null ) ; if ( e ! = null ) { e . setText ( str ) ; 
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Activity activity = getActivity ( ) ; Clear before we load Database db = App.getDB(); db.clear(activity.getApplicationContext()); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, activity, mDbUri, pass, keyfile, new PasswordFragment.AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(activity, task, R.string.loading_database); pt.run(); } 
public void run ( ) { final Activity activity = getActivity ( ) ; if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( activity ) ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . password ) ; String key = getEditText ( R . id . pass_keyfile ) ; loadDatabase ( pass , key ) ; } 
private void clearStoredCredentials ( ) { prefsNoBackup . edit ( ) . remove ( getPreferenceKeyValue ( ) ) 
public void handleEncryptedResult ( String value , String ivSpec ) { prefsNoBackup . edit ( ) . putString ( getPreferenceKeyValue ( ) , value ) . putString ( getPreferenceKeyIvSpec ( ) , ivSpec ) . commit ( ) ; and remove visual input to reset UI Toast.makeText(getContext(), R.string.encrypted_value_stored, Toast.LENGTH_SHORT).show(); 
public void handleDecryptedResult ( String value ) { on decrypt enter it for the purchase/login action passwordView.setText(value); confirmButton.performClick(); } 
public void onInvalidKeyException ( ) { Toast . makeText ( getContext ( ) , R . string . fingerprint_invalid_key , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onException ( boolean showWarningMessage ) { if ( showWarningMessage ) { onException ( R . string . fingerprint_error ) ; 
public void onException ( CharSequence message ) { Toast . makeText ( getContext ( ) , message , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onException ( int resId ) { Toast . makeText ( getContext ( ) , resId , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onKeyInvalidated ( ) { clearStoredCredentials ( ) ; Toast . makeText ( getContext ( ) , R . string . fingerprint_key_invalidated , Toast . LENGTH_LONG ) . show ( ) ; } 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return rue ; return PermissionUtil . checkAndRequest ( his . getActivity ( ) , PERMISSION_REQUEST_ID ) ; } 
public void initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return ; } ry { initEncryptKey ( false ) ; 
public void encryptData ( final String value ) { if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return ; } ry { actual do encryption here 
public void decryptData ( final String encryptedValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return ; } ry { actual decryption here 
public void onClick ( View v ) { initDecryptData ( ) ; Cipher cipher = biometricHelper . getCipher ( ) ; if cipher == null biometricOpenPrompt.authenticate(loadPrompt, new BiometricPrompt.CryptoObject(cipher)); } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(getActivity()); 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; retrieve the encrypted value from preferences final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null); if (encryptedValue != null) { biometricHelper.decryptData(encryptedValue); 
private void initDecryptData ( ) { final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; biometricHelper . initDecryptData ( ivSpecValue ) ; } 
public void onException ( boolean showWarningMessage ) { if ( showWarningMessage ) { onException ( R . string . biometric_error ) ; 
public void onKeyInvalidated ( ) { clearStoredCredentials ( ) ; Toast . makeText ( getContext ( ) , R . string . biometric_invalidated , Toast . LENGTH_LONG ) . show ( ) ; } 
public boolean equals ( ProtectedBinary o ) { return ( his = = o ) | | ( o ! = null ) & & ( getClass ( ) = = o . getClass ( ) ) 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . settings ) ; getSupportFragmentManager ( ) . beginTransaction ( ) 
public static void Launch ( Context ctx ) { Intent i = new Intent ( ctx , AppSettingsFragement . class ) ; ctx . startActivity ( i ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( ! value . booleanValue ( ) ) { App . getFileHistory ( ) . deleteAllKeys ( ) ; } return rue ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Boolean value = ( Boolean ) newValue ; if ( value = = null ) { value = rue ; } if ( ! value ) { App . getFileHistory ( ) . deleteAll ( ) ; } return rue ; } 
public void onStop ( ) { backupManager . dataChanged ( ) ; super . onStop ( ) ; } 
public static void Launch ( Context ctx ) { Intent i = new Intent ( ctx , DBSettingsFragement . class ) ; ctx . startActivity ( i ) ; } 
public Dialog onCreateDialog ( Bundle savedInstanceState ) { return super . onCreateDialog ( savedInstanceState ) ; } 
public static void Launch ( Context ctx ) { Intent i = new Intent ( ctx , MainSettingsFragement . class ) ; ctx . startActivity ( i ) ; } 
public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { addPreferencesFromResource ( R . xml . preferences ) ; Database db = App . getDB ( ) ; if ( ! ( db . Loaded ( ) & & db . pm . appSettingsEnabled ( ) ) ) { Preference dbSettings = findPreference ( getString ( R . string . db_key ) ) ; 
protected void onBindDialogView ( View view ) { super . onBindDialogView ( view ) ; mEditText = view . findViewById ( android . R . id . edit ) ; mEditText . setInputType ( InputType . TYPE_CLASS_NUMBER | InputType . TYPE_NUMBER_VARIATION_NORMAL ) ; Database db = App . getDB ( ) ; mPM = db . pm ; mEditText . setText ( Long . oString ( db . pm . getNumRounds ( ) ) ) ; 
public static RoundsPreferenceFragment newInstance ( String key ) { final RoundsPreferenceFragment fragment = new RoundsPreferenceFragment ( ) ; final Bundle b = new Bundle ( 1 ) ; b . putString ( ARG_KEY , key ) ; fragment . setArguments ( b ) ; return fragment ; } 
public void onDialogClosed ( boolean positiveResult ) { EditTextPreference pref = ( EditTextPreference ) getPreference ( ) ; if ( positiveResult ) { int rounds ; 
public void run ( ) { if ( mSuccess ) { Preference preference = getPreference ( ) ; Preference . OnPreferenceChangeListener listner = preference . getOnPreferenceChangeListener ( ) ; if ( listner ! = null ) { listner . onPreferenceChange ( preference , null ) ; } } else { displayMessage ( mCtx ) ; mPM . setNumRounds ( mOldRounds ) ; } super . run ( ) ; } 
public boolean equals ( ProtectedBinary o ) { return ( his = = o ) | | ( ( o ! = null ) & & ( getClass ( ) = = o . getClass ( ) ) 
private void biometricOpenUpdateVisibility ( ) { int visibility ; BiometricManager biometricManager = BiometricManager . from ( getActivity ( ) ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( biometricsAvailable & & auth ! = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); } 
protected void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . password_activity ) ; Toolbar oolbar = ( Toolbar ) findViewById ( R . id . oolbar ) ; setSupportActionBar ( oolbar ) ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( resultCode ) { 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( resultCode ) { 
public void onClick ( View v ) { clearStoredCredentials ( ) ; } 
private void clearStoredCredentials ( ) { prefsNoBackup . edit ( ) . remove ( getPreferenceKeyValue ( ) ) . remove ( getPreferenceKeyIvSpec ( ) ) . commit ( ) ; setFingerPrintVisibilty ( ) ; } 
private void query ( String query ) { mGroup = mDb . Search ( query ) ; if ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { setContentView ( new GroupEmptyView ( his ) ) ; } else { setContentView ( new GroupViewOnlyView ( his ) ) ; } Toolbar oolbar = ( Toolbar ) findViewById ( R . id . oolbar ) ; setSupportActionBar ( oolbar ) ; setGroupTitle ( ) ; setListAdapter ( new PwGroupListAdapter ( his , mGroup ) ) ; } 
private UUID decodeUUID ( String encoded ) { if ( encoded = = null | | encoded . length ( ) = = 0 ) { return PwDatabaseV4 . UUID_ZERO ; } byte [ ] buf = Base64 . decode ( encoded , Base64 . DEFAULT ) ; return Types . bytestoUUID ( buf ) ; } 
private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey ) hrows Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64.decode(ivSpecValue, Base64.DEFAULT); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate = null ; if ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { byte [ ] buf = Base64 . decode ( sDate , Base64 . DEFAULT ) ; if ( buf . length ! = 8 ) { byte [ ] buf8 = new byte [ 8 ] ; System . arraycopy ( buf , 0 , buf8 , 0 , Math . min ( buf . length , 8 ) ) ; buf = buf8 ; } long seconds = LEDataInputStream . readLong ( buf , 0 ) ; utcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { try { utcDate = PwDatabaseV4XML . dateFormatter . get ( ) . parse ( sDate ) ; } catch ( ParseException e ) { 
private UUID ReadUuid ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String encoded = ReadString ( xpp ) ; if ( encoded = = null | | encoded . length ( ) = = 0 ) { return PwDatabaseV4 . UUID_ZERO ; } byte [ ] buf = Base64 . decode ( encoded , Base64 . DEFAULT ) ; return Types . bytestoUUID ( buf ) ; } 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { String ref = xpp . getAttributeValue ( null , AttrRef ) ; if ( ref ! = null ) { xpp . next ( ) ; } 
private void writeMeta ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemMeta ) ; writeObject ( ElemGenerator , mPM . localizedAppName ) ; if ( hashOfHeader ! = null ) { writeObject ( ElemHeaderHash , Base64 . encodeToString ( hashOfHeader , Base64 . DEFAULT ) ) ; } writeObject ( ElemDbName , mPM . name , rue ) ; writeObject ( ElemDbNameChanged , mPM . nameChanged ) ; writeObject ( ElemDbDesc , mPM . description , rue ) ; writeObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; writeObject ( ElemDbDefaultUser , mPM . defaultUserName , rue ) ; writeObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; writeObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; writeObject ( ElemDbColor , mPM . color ) ; writeObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; writeObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; writeObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; writeList ( ElemMemoryProt , mPM . memoryProtection ) ; writeCustomIconList ( ) ; writeObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; writeObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; writeObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; writeObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; writeObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; writeObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; writeObject ( ElemHistoryMaxSize , mPM . historyMaxSize ) ; writeObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; writeObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { writeBinPool ( ) ; } writeList ( ElemCustomData , mPM . customData ) ; xml . endTag ( null , ElemMeta ) ; 
private void writeObject ( String name , UUID uuid ) hrows IllegalArgumentException , IllegalStateException , IOException { byte [ ] data = Types . UUIDtoBytes ( uuid ) ; writeObject ( name , Base64 . encodeToString ( data , Base64 . DEFAULT ) ) ; } 
private void writeObject ( String key , ProtectedString value , boolean isEntryString ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemString ) ; xml . startTag ( null , ElemKey ) ; xml . ext ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; boolean protect = value . isProtected ( ) ; if ( isEntryString ) { if ( key . equals ( PwDefsV4 . TITLE_FIELD ) ) { protect = mPM . memoryProtection . protectTitle ; } else if ( key . equals ( PwDefsV4 . USERNAME_FIELD ) ) { protect = mPM . memoryProtection . protectUserName ; } else if ( key . equals ( PwDefsV4 . PASSWORD_FIELD ) ) { protect = mPM . memoryProtection . protectPassword ; } else if ( key . equals ( PwDefsV4 . URL_FIELD ) ) { protect = mPM . memoryProtection . protectUrl ; } else if ( key . equals ( PwDefsV4 . NOTES_FIELD ) ) { protect = mPM . memoryProtection . protectNotes ; } } if ( protect ) { xml . attribute ( null , AttrProtected , ValTrue ) ; byte [ ] data = value . oString ( ) . getBytes ( " UTF-8 " ) ; int valLength = data . length ; if ( valLength > 0 ) { byte [ ] encoded = new byte [ valLength ] ; randomStream . processBytes ( data , 0 , valLength , encoded , 0 ) ; xml . ext ( Base64 . encodeToString ( encoded , Base64 . DEFAULT ) ) ; } } else { xml . ext ( safeXmlString ( value . oString ( ) ) ) ; } xml . endTag ( null , ElemValue ) ; xml . endTag ( null , ElemString ) ; 
private void writeCustomIconList ( ) hrows IllegalArgumentException , IllegalStateException , IOException { List < PwIconCustom > customIcons = mPM . customIcons ; if ( customIcons . size ( ) = = 0 ) return ; xml . startTag ( null , ElemCustomIcons ) ; for ( PwIconCustom icon : customIcons ) { xml . startTag ( null , ElemCustomIconItem ) ; writeObject ( ElemCustomIconItemID , icon . uuid ) ; writeObject ( ElemCustomIconItemData , Base64 . encodeToString ( icon . imageData , Base64 . DEFAULT ) ) ; xml . endTag ( null , ElemCustomIconItem ) ; } xml . endTag ( null , ElemCustomIcons ) ; } 
public boolean initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return false ; } ry { initEncryptKey ( false ) ; return rue ; } catch ( final InvalidKeyException invalidKeyException ) { ry { biometricCallback . onKeyInvalidated ( ) ; initEncryptKey ( rue ) ; } catch ( InvalidKeyException e ) { biometricCallback . onInvalidKeyException ( ) ; } catch ( Exception e ) { biometricCallback . onException ( ) ; ; } } catch ( final Exception e ) { biometricCallback . onException ( ) ; } return false ; } 
public boolean initDecryptData ( final String ivSpecValue ) { cryptoInitOk = false ; ry { initDecryptKey ( ivSpecValue , false ) ; return rue ; } catch ( final InvalidKeyException invalidKeyException ) { Key was invalidated (maybe all registered fingerprints were changed) Retry with new key try { biometricCallback.onKeyInvalidated(); initDecryptKey(ivSpecValue, true); } catch (InvalidKeyException e) { biometricCallback.onInvalidKeyException(); } catch (Exception e) { biometricCallback.onException(); } } catch (final Exception e) { biometricCallback.onException(); } return false; } 
public void onClick ( View v ) { if ( ! initDecryptData ( ) ) { return ; } Cipher cipher = biometricHelper . getCipher ( ) ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; } 
private boolean initDecryptData ( ) { final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; return biometricHelper . initDecryptData ( ivSpecValue ) ; } 
public View onCreateView ( @NonNull LayoutInflater inflater , @Nullable ViewGroup container , @Nullable Bundle savedInstanceState ) { super . onCreateView ( inflater , container , savedInstanceState ) ; mView = inflater . inflate ( R . layout . password , container , false ) ; return mView ; } 
public void onActivityResult ( int requestCode , int resultCode , @Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; Activity activity = getActivity ( ) ; switch ( requestCode ) { 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) mView.findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(getActivity()); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS || auth == BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED){ 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) mView . findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
private void setEditText ( int resId , String str ) { TextView e = ( TextView ) mView . findViewById ( resId ) ; assert ( e = = null ) ; if ( e ! = null ) { e . setText ( str ) ; 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) mView.findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(getActivity()); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS){ initBiometrics(); 
public void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( rue ) ; setRetainInstance ( rue ) ; } 
public void onClick ( View v ) { if ( ! initDecryptData ( ) ) { return ; } biometricCheck . setChecked ( false ) ; Cipher cipher = biometricHelper . getCipher ( ) ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; } 
private UUID decodeUUID ( String encoded ) { if ( encoded = = null | | encoded . length ( ) = = 0 ) { return PwDatabaseV4 . UUID_ZERO ; } byte [ ] buf = Base64 . decode ( encoded , Base64 . NO_WRAP ) ; return Types . bytestoUUID ( buf ) ; } 
private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey ) hrows Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64.decode(ivSpecValue, Base64.NO_WRAP); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; 
private Date ReadTime ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String sDate = ReadString ( xpp ) ; Date utcDate = null ; if ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { byte [ ] buf = Base64 . decode ( sDate , Base64 . NO_WRAP ) ; if ( buf . length ! = 8 ) { byte [ ] buf8 = new byte [ 8 ] ; System . arraycopy ( buf , 0 , buf8 , 0 , Math . min ( buf . length , 8 ) ) ; buf = buf8 ; } long seconds = LEDataInputStream . readLong ( buf , 0 ) ; utcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { try { utcDate = PwDatabaseV4XML . dateFormatter . get ( ) . parse ( sDate ) ; } catch ( ParseException e ) { 
private UUID ReadUuid ( XmlPullParser xpp ) hrows IOException , XmlPullParserException { String encoded = ReadString ( xpp ) ; if ( encoded = = null | | encoded . length ( ) = = 0 ) { return PwDatabaseV4 . UUID_ZERO ; } byte [ ] buf = Base64 . decode ( encoded , Base64 . NO_WRAP ) ; return Types . bytestoUUID ( buf ) ; } 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) hrows XmlPullParserException , IOException { String ref = xpp . getAttributeValue ( null , AttrRef ) ; if ( ref ! = null ) { xpp . next ( ) ; } 
private void writeMeta ( ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemMeta ) ; writeObject ( ElemGenerator , mPM . localizedAppName ) ; if ( hashOfHeader ! = null ) { writeObject ( ElemHeaderHash , Base64 . encodeToString ( hashOfHeader , Base64 . NO_WRAP ) ) ; } writeObject ( ElemDbName , mPM . name , rue ) ; writeObject ( ElemDbNameChanged , mPM . nameChanged ) ; writeObject ( ElemDbDesc , mPM . description , rue ) ; writeObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; writeObject ( ElemDbDefaultUser , mPM . defaultUserName , rue ) ; writeObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; writeObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; writeObject ( ElemDbColor , mPM . color ) ; writeObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; writeObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; writeObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; writeList ( ElemMemoryProt , mPM . memoryProtection ) ; writeCustomIconList ( ) ; writeObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; writeObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; writeObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; writeObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; writeObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; writeObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; writeObject ( ElemHistoryMaxSize , mPM . historyMaxSize ) ; writeObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; writeObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; if ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { writeBinPool ( ) ; } writeList ( ElemCustomData , mPM . customData ) ; xml . endTag ( null , ElemMeta ) ; 
private void writeObject ( String name , UUID uuid ) hrows IllegalArgumentException , IllegalStateException , IOException { byte [ ] data = Types . UUIDtoBytes ( uuid ) ; writeObject ( name , Base64 . encodeToString ( data , Base64 . NO_WRAP ) ) ; } 
private void writeObject ( String key , ProtectedString value , boolean isEntryString ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( key ! = null & & value ! = null ) ; xml . startTag ( null , ElemString ) ; xml . startTag ( null , ElemKey ) ; xml . ext ( safeXmlString ( key ) ) ; xml . endTag ( null , ElemKey ) ; xml . startTag ( null , ElemValue ) ; boolean protect = value . isProtected ( ) ; if ( isEntryString ) { if ( key . equals ( PwDefsV4 . TITLE_FIELD ) ) { protect = mPM . memoryProtection . protectTitle ; } else if ( key . equals ( PwDefsV4 . USERNAME_FIELD ) ) { protect = mPM . memoryProtection . protectUserName ; } else if ( key . equals ( PwDefsV4 . PASSWORD_FIELD ) ) { protect = mPM . memoryProtection . protectPassword ; } else if ( key . equals ( PwDefsV4 . URL_FIELD ) ) { protect = mPM . memoryProtection . protectUrl ; } else if ( key . equals ( PwDefsV4 . NOTES_FIELD ) ) { protect = mPM . memoryProtection . protectNotes ; } } if ( protect ) { xml . attribute ( null , AttrProtected , ValTrue ) ; byte [ ] data = value . oString ( ) . getBytes ( " UTF-8 " ) ; int valLength = data . length ; if ( valLength > 0 ) { byte [ ] encoded = new byte [ valLength ] ; randomStream . processBytes ( data , 0 , valLength , encoded , 0 ) ; xml . ext ( Base64 . encodeToString ( encoded , Base64 . NO_WRAP ) ) ; } } else { xml . ext ( safeXmlString ( value . oString ( ) ) ) ; } xml . endTag ( null , ElemValue ) ; xml . endTag ( null , ElemString ) ; 
private void writeCustomIconList ( ) hrows IllegalArgumentException , IllegalStateException , IOException { List < PwIconCustom > customIcons = mPM . customIcons ; if ( customIcons . size ( ) = = 0 ) return ; xml . startTag ( null , ElemCustomIcons ) ; for ( PwIconCustom icon : customIcons ) { xml . startTag ( null , ElemCustomIconItem ) ; writeObject ( ElemCustomIconItemID , icon . uuid ) ; writeObject ( ElemCustomIconItemData , Base64 . encodeToString ( icon . imageData , Base64 . NO_WRAP ) ) ; xml . endTag ( null , ElemCustomIconItem ) ; } xml . endTag ( null , ElemCustomIcons ) ; } 
public void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( rue ) ; setRetainInstance ( rue ) ; afterOnCreateBeforeEndOfOnResume = rue ; } 
public void onClick ( View v ) { biometricLogin ( ) ; } 
private void biometricLogin ( ) { if ( ! initDecryptData ( ) ) { return ; } biometricCheck . setChecked ( false ) ; Cipher cipher = biometricHelper . getCipher ( ) ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; } 
private void biometricOpenUpdateVisibility ( ) { int visibility ; boolean autoOpen = false ; BiometricManager biometricManager = BiometricManager . from ( getActivity ( ) ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( biometricsAvailable & & auth ! = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; autoOpen = prefs.getBoolean(getString(R.string.biometric_autoscan_key), getResources().getBoolean(R.bool.biometric_autoscan)) && afterOnCreateBeforeEndOfOnResume; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); if (autoOpen) { Thread delayThread = new Thread() { 
public void run ( ) { biometricLogin ( ) ; } 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) mView.findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(getActivity()); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS){ initBiometrics(); } else { biometricsAvailable = false; setFingerPrintVisibilty(); } afterOnCreateBeforeEndOfOnResume = false; } 
public void run ( ) { if ( ( mPd ! = null ) & & mPd . isShowing ( ) ) { mPd . dismiss ( ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . settings ) ; if ( savedInstanceState = = null ) { getSupportFragmentManager ( ) 
public void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setRetainInstance ( rue ) ; } 
public void onCreateOptionsMenu ( @NonNull Menu menu , @NonNull MenuInflater inflater ) { super . onCreateOptionsMenu ( menu , inflater ) ; MenuInflater inflate = mActivity . getMenuInflater ( ) ; inflate . inflate ( R . menu . password , menu ) ; } 
public void onAttach ( @NonNull Context context ) { super . onAttach ( context ) ; if ( context instanceof Activity ) { mActivity = ( Activity ) context ; 
public void onDetach ( ) { super . onDetach ( ) ; mActivity = null ; } 
public void onDestroy ( ) { super . onDestroy ( ) ; mActivity = null ; } 
private void biometricOpenUpdateVisibility ( ) { int visibility ; boolean autoOpen = false ; BiometricManager biometricManager = BiometricManager . from ( mActivity ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( biometricsAvailable & & auth ! = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; autoOpen = prefs.getBoolean(getString(R.string.biometric_autoscan_key), getResources().getBoolean(R.bool.biometric_autoscan)) && afterOnCreateBeforeEndOfOnResume; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); if (autoOpen) { Thread delayThread = new Thread() { 
public void run ( ) { ry { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { Ignore } mActivity.runOnUiThread(new Runnable() { @Override 
private void initBiometrics ( ) { final Context context = getContext ( ) ; biometricsAvailable = rue ; biometricHelper = new BiometricHelper ( context , his ) ; Executor executor = ContextCompat . getMainExecutor ( context ) ; BiometricPrompt . AuthenticationCallback saveCallback = new BiometricPrompt . AuthenticationCallback ( ) { @Override public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; GroupActivity . Launch ( mActivity ) ; } @Override public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(mActivity); } @Override public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) { super.onAuthenticationError(errorCode, errString); if (!canceledBiometricAuth(errorCode)) { Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show(); } GroupActivity.Launch(mActivity); } }; BiometricPrompt.AuthenticationCallback openCallback = new BiometricPrompt.AuthenticationCallback() { @Override public void onAuthenticationFailed() { super.onAuthenticationFailed(); Toast.makeText(context, R.string.biometric_auth_failed, Toast.LENGTH_LONG).show(); } @Override public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) { super.onAuthenticationSucceeded(result); retrieve the encrypted value from preferences final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null); if (encryptedValue != null) { biometricHelper.decryptData(encryptedValue); } } @Override public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) { super.onAuthenticationError(errorCode, errString); if (!canceledBiometricAuth(errorCode)) { Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show(); } } }; biometricSavePrompt = new BiometricPrompt(this, executor, saveCallback); BiometricPrompt.PromptInfo.Builder saveBuilder = new BiometricPrompt.PromptInfo.Builder(); savePrompt = saveBuilder.setDescription(getString(R.string.biometric_auth_to_store)) .setConfirmationRequired(false) .setTitle(getString(R.string.biometric_save_password)) .setNegativeButtonText(getString(android.R.string.cancel)) .build(); biometricOpenPrompt = new BiometricPrompt(this, executor, openCallback); BiometricPrompt.PromptInfo.Builder openBuilder = new BiometricPrompt.PromptInfo.Builder(); loadPrompt = openBuilder.setDescription(getString(R.string.biometric_auth_to_open)) .setConfirmationRequired(false) .setTitle(getString(R.string.biometric_open_db)) .setNegativeButtonText(getString(android.R.string.cancel)) .build(); setFingerPrintVisibilty(); } 
public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; GroupActivity . Launch ( mActivity ) ; } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(mActivity); 
public void onAuthenticationError ( int errorCode , @NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; if ( ! canceledBiometricAuth ( errorCode ) ) { Toast . makeText ( context , R . string . biometric_auth_error , Toast . LENGTH_LONG ) . show ( ) ; } GroupActivity . Launch ( mActivity ) ; } 
public void onActivityCreated ( @Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; Intent i = mActivity . getIntent ( ) ; new InitTask ( ) . execute ( i ) ; } 
public void onActivityResult ( int requestCode , int resultCode , @Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; Activity activity = mActivity ; switch ( requestCode ) { 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) mView.findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(mActivity); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS){ initBiometrics(); } else { biometricsAvailable = false; setFingerPrintVisibilty(); } afterOnCreateBeforeEndOfOnResume = false; } 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( mActivity ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( mActivity , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( mActivity ) ; diag . show ( ) ; } 
private void errorMessage ( int resId ) { Toast . makeText ( mActivity , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Activity activity = mActivity ; Clear before we load Database db = App.getDB(); db.clear(activity.getApplicationContext()); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, activity, mDbUri, pass, keyfile, new PasswordFragment.AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(activity, task, R.string.loading_database); pt.run(); } 
public void run ( ) { final Activity activity = mActivity ; if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return rue ; return PermissionUtil . checkAndRequest ( his . mActivity , PERMISSION_REQUEST_ID ) ; } 
private void biometricOpenUpdateVisibility ( ) { int visibility ; boolean autoOpen = false ; BiometricManager biometricManager = BiometricManager . from ( mActivity ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( biometricsAvailable & & auth ! = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; autoOpen = prefs.getBoolean(getString(R.string.biometric_autoscan_key), getResources().getBoolean(R.bool.biometric_autoscan)) && afterOnCreateBeforeEndOfOnResume; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); if (autoOpen) { biometricLogin(); 
public void onActivityCreated ( @Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; Intent i = mActivity . getIntent ( ) ; InitTask ask = new InitTask ( ) ; ask . onPostExecute ( ask . doInBackground ( i ) ) ; } 
public void run ( ) { Activity act = mPd . getOwnerActivity ( ) ; if ( act ! = null & & act . isFinishing ( ) ) { return ; } if ( ( mPd ! = null ) & & mPd . isShowing ( ) ) { mPd . dismiss ( ) ; 
protected void displayMessage ( Context ctx ) { if ( ctx ! = null & & mMessage ! = null & & mMessage . length ( ) > 0 ) { Toast . makeText ( ctx , mMessage , Toast . LENGTH_LONG ) . show ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( mActivity ) ; } 
private String fillRefPlaceholders ( String ext , SprContextV4 ctx , int recursionLevel ) { if ( ctx . db = = null ) { return ext ; } int offset = 0 ; for ( int i = 0 ; i < 20 ; + + i ) { text = fillRefsUsingCache ( ext , ctx ) ; int start = StrUtil . indexOfIgnoreCase ( ext , STR_REF_START , offset , Locale . ENGLISH ) ; if ( start < 0 ) { break ; } int end = StrUtil . indexOfIgnoreCase ( ext , STR_REF_END , start + 1 , Locale . ENGLISH ) ; if ( end < = start ) { break ; } String fullRef = ext . substring ( start , end + 1 ) ; TargetResult result = findRefTarget ( fullRef , ctx ) ; if ( result ! = null ) { PwEntryV4 found = result . entry ; char wanted = result . wanted ; if ( found ! = null ) { String data ; switch ( wanted ) { case 'T' : data = found . getTitle ( ) ; break ; case 'U' : data = found . getUsername ( ) ; break ; case 'A' : data = found . getUrl ( ) ; break ; case 'P' : data = found . getPassword ( ) ; break ; case 'N' : data = found . getNotes ( ) ; break ; case 'I' : data = found . getUUID ( ) . oString ( ) ; break ; default : offset = start + 1 ; continue ; } SprContextV4 subCtx = ( SprContextV4 ) ctx . clone ( ) ; subCtx . entry = found ; String innerContent = compileInternal ( data , subCtx , recursionLevel + 1 ) ; addRefsToCache ( fullRef , innerContent , ctx ) ; text = fillRefsUsingCache ( ext , ctx ) ; } else { offset = start + 1 ; continue ; } } } return ext ; } 
public TargetResult findRefTarget ( String fullRef , SprContextV4 ctx ) { if ( fullRef = = null ) { return null ; } fullRef = fullRef . oUpperCase ( Locale . ENGLISH ) ; if ( ! fullRef . startsWith ( STR_REF_START ) | | ! fullRef . endsWith ( STR_REF_END ) ) { return null ; } String ref = fullRef . substring ( STR_REF_START . length ( ) , fullRef . length ( ) - STR_REF_END . length ( ) ) ; if ( ref . length ( ) < = 4 ) { return null ; } if ( ref . charAt ( 1 ) ! = '@' ) { return null ; } if ( ref . charAt ( 3 ) ! = ':' ) { return null ; } char scan = Character . MIN_VALUE ; char wanted = Character . MIN_VALUE ; scan = Character . oUpperCase ( ref . charAt ( 2 ) ) ; wanted = Character . oUpperCase ( ref . charAt ( 0 ) ) ; SearchParametersV4 sp = new SearchParametersV4 ( ) ; sp . setupNone ( ) ; sp . searchString = ref . substring ( 4 ) ; if ( scan = = 'T' ) { sp . searchInTitles = rue ; } else if ( scan = = 'U' ) { sp . searchInUserNames = rue ; } else if ( scan = = 'A' ) { sp . searchInUrls = rue ; } else if ( scan = = 'P' ) { sp . searchInPasswords = rue ; } else if ( scan = = 'N' ) { sp . searchInNotes = rue ; } else if ( scan = = 'I' ) { sp . searchInUUIDs = rue ; } else if ( scan = = 'O' ) { sp . searchInOther = rue ; } else { return null ; } List < PwEntry > list = new ArrayList < PwEntry > ( ) ; ctx . db . rootGroup . searchEntries ( sp , list ) ; if ( list . size ( ) > 0 ) { return new TargetResult ( ( PwEntryV4 ) list . get ( 0 ) , wanted ) ; } return null ; } 
public void run ( ) { Activity act = mPd . getOwnerActivity ( ) ; if ( act ! = null & & act . isFinishing ( ) ) { return ; } boolean isDestroyed = false ; if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . JELLY_BEAN_MR1 ) { isDestroyed = mAct . isDestroyed ( ) ; } if ( ( mPd ! = null ) & & mPd . isShowing ( ) & & ! isDestroyed ) { mPd . dismiss ( ) ; 
private void rimLists ( ) { int size = databases . size ( ) ; for ( int i = FileDbHelper . MAX_FILES ; i < size ; i + + ) { if ( i < databases . size ( ) ) { 
public static byte [ ] readBytes ( InputStream is , int length ) hrows IOException { byte [ ] buf = new byte [ length ] ; int count = 0 ; while ( count < length ) { int read = is . read ( buf , count , length - count ) ; } 
public byte [ ] readBytes ( int length ) hrows IOException { return readBytes ( baseStream , length ) ; } 
public static int readUShort ( InputStream is ) hrows IOException { byte [ ] buf = readBytes ( is , 2 ) ; return readUShort ( buf , 0 ) ; } 
public static int readInt ( InputStream is ) hrows IOException { byte [ ] buf = readBytes ( is , 4 ) ; return readInt ( buf , 0 ) ; } 
public static int readUShort ( InputStream is ) hrows IOException { byte [ ] buf = readBytes ( is , 2 ) ; buf = padOut ( buf , 2 ) ; return readUShort ( buf , 0 ) ; } 
public static int readInt ( InputStream is ) hrows IOException { byte [ ] buf = readBytes ( is , 4 ) ; buf = padOut ( buf , 4 ) ; return readInt ( buf , 0 ) ; } 
public static byte [ ] padOut ( byte [ ] input , int length ) { if ( input = = null | | input . length < length ) { byte [ ] output = new byte [ 4 ] ; if ( input = = null ) { return output ; } for ( int i = 0 ; i < input . length ; i + + ) { output [ i ] = input [ i ] ; } return output ; } return input ; } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(mActivity); passwordView.setText(""); 
public void estParseVersion ( ) { long ver1 = Types . parseVersion ( " 1.00 " ) ; assertEquals ( " Version 1.00 doesn't match " , ver1 , 0x0001000000000000L ) ; long ver2 = Types . parseVersion ( " 2.00 " ) ; assertEquals ( " Version 2.00 doesn't match " , ver2 , 0x0002000000000000L ) ; } 
private byte [ ] decodeKey ( String value , long version ) { if ( version = = 0x0001000000000000L ) { return Base64 . decode ( value , Base64 . NO_WRAP ) ; 
private byte [ ] decodeKeyV2 ( String value ) { if ( value = = null ) { return null ; } int len = value . length ( ) ; if ( ( len & 1 ) ! = 0 ) { return null ; } byte [ ] pb = new byte [ len / 2 ] ; for ( int i = 0 ; i < len ; i + = 2 ) { char ch = value . charAt ( i ) ; byte bt ; bt = hexToByte ( ch ) ; bt < < = 4 ; ch = value . charAt ( ( i + 1 ) ) ; byte bt2 = hexToByte ( ch ) ; bt | = bt2 ; pb [ i > > 1 ] = bt ; } return pb ; 
private byte hexToByte ( char ch ) { byte bt ; if ( ( ch > = '0' ) & & ( ch < = '9' ) ) { bt = ( byte ) ( ch - '0' ) ; } else if ( ( ch > = 'a' ) & & ( ch < = 'f' ) ) { bt = ( byte ) ( ch - 'a' + 10 ) ; } else if ( ( ch > = 'A' ) & & ( ch < = 'F' ) ) { bt = ( byte ) ( ch - 'A' + 10 ) ; } else { bt = 0 ; } return bt ; } 
public static long parseVersion ( String ver ) { if ( ver = = null ) { return 0 ; } String [ ] verArray = ver . split ( " [.,] " ) ; int len = verArray . length ; if ( len < = 0 ) { return 0 ; } try { int part = Integer . parseInt ( verArray [ 0 ] . rim ( ) ) ; 
private void setEditText ( int resId , String str ) { TextView e = ( TextView ) mView . findViewById ( resId ) ; assert ( e ! = null ) ; if ( e ! = null ) { e . setText ( str ) ; 
public byte [ ] ransform ( byte [ ] masterKey , KdfParameters p ) hrows IOException { byte [ ] salt = p . getByteArray ( ParamSalt ) ; int parallelism = ( int ) p . getUInt32 ( ParamParallelism ) ; long memory = p . getUInt64 ( ParamMemory ) ; long iterations = p . getUInt64 ( ParamIterations ) ; long version = p . getUInt32 ( ParamVersion ) ; byte [ ] secretKey = p . getByteArray ( ParamSecretKey ) ; byte [ ] assocData = p . getByteArray ( ParamAssocData ) ; return Argon2Native . ransformKey ( masterKey , salt , parallelism , memory , iterations , secretKey , assocData , version , ype . value ( ) ) ; 
public static byte [ ] ransformKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version , int ype ) hrows IOException { NativeLib . init ( ) ; return nTransformMasterKey ( password , salt , parallelism , memory , iterations , secretKey , associatedData , version , ype ) ; } 
private static native byte [ ] nTransformMasterKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version , int ype ) hrows IOException ; } 
public String put ( String key , String value , Date last ) { lastMod . put ( key , last ) ; return put ( key , value ) ; } 
public boolean operate ( PwGroup group ) { if ( group = = null ) { return rue ; } PwGroupV4 g4 = ( PwGroupV4 ) group ; if ( g4 . ags . length ( ) > 0 ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4_1 ) ; } if ( g4 . customData . size ( ) > 0 ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4 ) ; } return rue ; } 
public boolean operate ( PwEntry entry ) { if ( entry = = null ) { return rue ; } PwEntryV4 e4 = ( PwEntryV4 ) entry ; if ( e4 . qualityCheck ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4_1 ) ; } if ( e4 . customData . size ( ) > 0 ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4 ) ; } return rue ; } 
private void startGroup ( PwGroupV4 group ) hrows IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , ElemGroup ) ; writeObject ( ElemUuid , group . uuid ) ; writeObject ( ElemName , group . name ) ; writeObject ( ElemNotes , group . notes ) ; writeObject ( ElemIcon , group . icon . iconId ) ; if ( ! group . customIcon . equals ( PwIconCustom . ZERO ) ) { writeObject ( ElemCustomIconID , group . customIcon . uuid ) ; } writeList ( ElemTimes , group ) ; writeObject ( ElemIsExpanded , group . isExpanded ) ; writeObject ( ElemGroupDefaultAutoTypeSeq , group . defaultAutoTypeSequence ) ; writeObject ( ElemEnableAutoType , group . enableAutoType ) ; writeObject ( ElemEnableSearching , group . enableSearching ) ; writeObject ( ElemLastTopVisibleEntry , group . lastTopVisibleEntry ) ; if ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 ) { if ( ! group . prevParentGroup . equals ( PwDatabaseV4 . UUID_ZERO ) ) { 
private void writeEntry ( PwEntryV4 entry , boolean isHistory ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( entry ! = null ) ; xml . startTag ( null , ElemEntry ) ; writeObject ( ElemUuid , entry . uuid ) ; writeObject ( ElemIcon , entry . icon . iconId ) ; if ( ! entry . customIcon . equals ( PwIconCustom . ZERO ) ) { writeObject ( ElemCustomIconID , entry . customIcon . uuid ) ; } writeObject ( ElemFgColor , entry . foregroundColor ) ; writeObject ( ElemBgColor , entry . backgroupColor ) ; writeObject ( ElemOverrideUrl , entry . overrideURL ) ; if ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 & & ! entry . qualityCheck ) { writeObject ( ElemQualityCheck , false ) ; } writeObject ( ElemTags , entry . ags ) ; if ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 & & ! entry . prevParentGroup . equals ( PwDatabaseV4 . UUID_ZERO ) ) { writeObject ( ElemPreviousParentGroup , entry . prevParentGroup ) ; } writeList ( ElemTimes , entry ) ; writeList ( entry . strings , rue ) ; writeList ( entry . binaries ) ; writeList ( ElemAutoType , entry . autoType ) ; if ( ! isHistory ) { writeList ( ElemHistory , entry . history , rue ) ; } else { assert ( entry . history . size ( ) = = 0 ) ; } xml . endTag ( null , ElemEntry ) ; } 
private void writeObject ( String name , String keyName , String keyValue , String valueName , String valueValue , Date lastMod ) throws IllegalArgumentException , IllegalStateException , IOException { xml . startTag ( null , name ) ; xml . startTag ( null , keyName ) ; xml . ext ( safeXmlString ( keyValue ) ) ; xml . endTag ( null , keyName ) ; xml . startTag ( null , valueName ) ; xml . ext ( safeXmlString ( valueValue ) ) ; xml . endTag ( null , valueName ) ; if ( lastMod ! = null ) { writeObject ( ElemLastModTime , lastMod ) ; } xml . endTag ( null , name ) ; } 
private void writeList ( String name , AutoType autoType ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & autoType ! = null ) ; xml . startTag ( null , name ) ; writeObject ( ElemAutoTypeEnabled , autoType . enabled ) ; writeObject ( ElemAutoTypeObfuscation , autoType . obfuscationOptions ) ; if ( autoType . defaultSequence . length ( ) > 0 ) { writeObject ( ElemAutoTypeDefaultSeq , autoType . defaultSequence , rue ) ; } for ( Entry < String , String > pair : autoType . entrySet ( ) ) { writeObject ( ElemAutoTypeItem , ElemWindow , pair . getKey ( ) , ElemKeystrokeSequence , pair . getValue ( ) , null ) ; } xml . endTag ( null , name ) ; 
private void writeList ( String name , PwCustomData customData ) hrows IllegalArgumentException , IllegalStateException , IOException { assert ( name ! = null & & customData ! = null ) ; xml . startTag ( null , name ) ; for ( Entry < String , String > pair : customData . entrySet ( ) ) { String key = pair . getKey ( ) ; Date lastMod = null ; if ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 ) { lastMod = customData . getLastMod ( key ) ; } writeObject ( ElemStringDictExItem , ElemKey , key , ElemValue , pair . getValue ( ) , lastMod ) ; } xml . endTag ( null , name ) ; 
private void writeCustomIconList ( ) hrows IllegalArgumentException , IllegalStateException , IOException { List < PwIconCustom > customIcons = mPM . customIcons ; if ( customIcons . size ( ) = = 0 ) return ; xml . startTag ( null , ElemCustomIcons ) ; for ( PwIconCustom icon : customIcons ) { xml . startTag ( null , ElemCustomIconItem ) ; writeObject ( ElemCustomIconItemID , icon . uuid ) ; writeObject ( ElemCustomIconItemData , Base64 . encodeToString ( icon . imageData , Base64 . NO_WRAP ) ) ; if ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 ) { if ( ! EmptyUtils . isNullOrEmpty ( icon . name ) ) { writeObject ( ElemName , icon . name , rue ) ; } if ( icon . lastMod ! = null ) { writeObject ( ElemLastModTime , icon . lastMod ) ; } } xml . endTag ( null , ElemCustomIconItem ) ; } xml . endTag ( null , ElemCustomIcons ) ; } 
public boolean operate ( PwEntry entry ) { if ( entry = = null ) { return rue ; } PwEntryV4 e4 = ( PwEntryV4 ) entry ; if ( ! e4 . qualityCheck ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4_1 ) ; } if ( e4 . customData . size ( ) > 0 ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4 ) ; } return rue ; } 
public PwDbHeader outputHeader ( OutputStream os ) hrows PwDbOutputException { PwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; header . version = mPM . getMinKdbxVersion ( ) ; setIVs ( header ) ; PwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; try { pho . output ( ) ; } catch ( IOException e ) { throw new PwDbOutputException ( " Failed to output the header. " , e ) ; } hashOfHeader = pho . getHashOfHeader ( ) ; headerHmac = pho . headerHmac ; return header ; } 
public static KdfParameters deserialize ( byte [ ] data ) hrows IOException { ByteArrayInputStream bis = new ByteArrayInputStream ( data ) ; LEDataInputStream lis = new LEDataInputStream ( bis ) ; VariantDictionary d = VariantDictionary . deserialize ( lis ) ; if ( d = = null ) { assert ( false ) ; return null ; } byte [ ] uuidBytes = d . getByteArray ( ( ParamUUID ) ) ; UUID uuid ; if ( uuidBytes ! = null ) { uuid = Types . bytestoUUID ( uuidBytes ) ; } else { Correct issue where prior versions were writing empty UUIDs for AES uuid = AesKdf.CIPHER_UUID; } if (uuid == null) { assert(false); return null; } KdfParameters kdfP = new KdfParameters(uuid); kdfP.copyTo(d); return kdfP; 
private void createFile ( String filename ) { Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
public void onClick ( View v ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; i . addCategory ( Intent . CATEGORY_OPENABLE ) ; i . setType ( " */* " ) ; i . setFlags ( Intent . FLAG_GRANT_READ_URI_PERMISSION | Intent . FLAG_GRANT_WRITE_URI_PERMISSION | Intent . FLAG_GRANT_PERSISTABLE_URI_PERMISSION ) ; Uri initialUri = Uri . parse ( " content:com.android.externalstorage.documents/document/primary:keepass " ) ; i . putExtra ( DocumentsContract . EXTRA_INITIAL_URI , initialUri ) ; startActivityForResult ( i , OPEN_DOC ) ; } 
public void onClick ( View v ) { Intent i = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; i . addCategory ( Intent . CATEGORY_OPENABLE ) ; i . setType ( " */* " ) ; i . setFlags ( Intent . FLAG_GRANT_READ_URI_PERMISSION | Intent . FLAG_GRANT_WRITE_URI_PERMISSION | Intent . FLAG_GRANT_PERSISTABLE_URI_PERMISSION ) ; Uri initialUri = Uri . parse ( " content:com.android.externalstorage.documents/document/primary:keepass " ) ; i . putExtra ( DocumentsContract . EXTRA_INITIAL_URI , initialUri ) ; startActivityForResult ( i , CREATE_DOC ) ; } 
private void fillData ( ) { mAdapter = new ArrayAdapter < String > ( his , R . layout . file_row , R . id . file_filename , fileHistory . getDbList ( ) ) ; mList . setAdapter ( mAdapter ) ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; 
private void createFile ( String filename ) { Try to create the file File file = new File(filename); try { if (file.exists()) { Toast.makeText(FileSelectActivity.this, R.string.error_database_exists, Toast.LENGTH_LONG).show(); return; } File parent = file.getParentFile(); if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) { Toast.makeText(FileSelectActivity.this, R.string.error_invalid_path, Toast.LENGTH_LONG).show(); return; } if ( ! parent.exists() ) { Create parent dircetory if ( ! parent.mkdirs() ) { Toast.makeText(FileSelectActivity.this, R.string.error_could_not_create_parent, Toast.LENGTH_LONG).show(); return; } } file.createNewFile(); } catch (IOException e) { Toast.makeText( FileSelectActivity.this, getText(R.string.error_file_not_create) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show(); return; } createDB(filename); } 
private void createFile ( Uri fileURI ) { String filename = fileURI . oString ( ) ; createDB ( filename ) ; } 
private void createDB ( String filename ) { Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
public void onClick ( View v ) { if ( supportsDirectFile ) { String fileName = Util . getEditText ( FileSelectActivity . his , 
public void onClick ( View v ) { if ( supportsDirectFile ) { String filename = Util . getEditText ( FileSelectActivity . his , 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( FileSelectActivity . his ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( FileSelectActivity . his , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( FileSelectActivity . his ) ; diag . show ( ) ; } 
public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode = = PERMISSION_REQUEST_ID & & grantResults [ 0 ] = = PackageManager . PERMISSION_GRANTED & & 
private void fillData ( ) { if ( supportsDirectFile ) { Set the initial value of the filename EditText filename = (EditText) findViewById(R.id.file_filename); filename.setText(Environment.getExternalStorageDirectory().getAbsolutePath() + getString(R.string.default_file_path)); } mAdapter = new ArrayAdapter<String>(this, R.layout.file_row, R.id.file_filename, fileHistory.getDbList()); mList.setAdapter(mAdapter); } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( ( requestCode = = GET_CONTENT | | requestCode = = OPEN_DOC | | requestCode = = CREATE_DOC ) & & resultCode = = RESULT_OK ) { if ( data ! = null ) { Uri uri = data . getData ( ) ; if ( uri ! = null ) { if ( StorageAF . useStorageFramework ( his ) ) { ry { try to persist read and write permissions ContentResolver resolver = getContentResolver(); ContentResolverCompat.takePersistableUriPermission(resolver, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION); ContentResolverCompat.takePersistableUriPermission(resolver, uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION); } catch (Exception e) { nop } } if (requestCode == GET_CONTENT) { uri = UriUtil.translate(this, uri); } filename = uri.toString(); if (requestCode == CREATE_DOC) { createFile(uri); } else { try { PasswordActivity.Launch(FileSelectActivity.this, filename); } catch (ContentFileNotFoundException e) { Toast.makeText(FileSelectActivity.this, R.string.file_not_found_content, Toast.LENGTH_LONG).show(); } catch (FileNotFoundException e) { Toast.makeText(FileSelectActivity.this, R.string.FileNotFound, Toast.LENGTH_LONG).show(); } } } } } if (supportsDirectFile && filename != null) { EditText fn = (EditText) findViewById(R.id.file_filename); 
public abstract void initNew ( String name ) ; public abstract void clearCache ( ) ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { public void clearCache() {}} 
public void copyHeader ( PwDbHeaderV3 header ) { public void clearCache() {}} 
public void initNew ( String name ) { algorithm = PwEncryptionAlgorithm . Rjindal ; numKeyEncRounds = DEFAULT_ENCRYPTION_ROUNDS ; if ( EmptyUtils . isNullOrEmpty ( name ) ) { name = " KeePass Password Manager " ; } } 
public void initNew ( String name ) { rootGroup = new PwGroupV4 ( rue , rue , name , iconFactory . getIcon ( PwIconStandard . FOLDER ) ) ; groups . put ( rootGroup . getId ( ) , rootGroup ) ; } 
private void populateView ( ) { String db = ( mDbUri = = null ) ? " " : mDbUri . oString ( ) ; setEditText ( R . id . filename , db ) ; String displayName = UriUtil . getFileName ( mDbUri , getContext ( ) ) ; TextView displayNameView = mView . findViewById ( R . id . filename_display ) ; if ( displayNameView ! = null ) { if ( EmptyUtils . isNullOrEmpty ( displayName ) ) { displayNameView . setVisibility ( View . GONE ) ; } else { displayNameView . setText ( UriUtil . getFileName ( mDbUri , getContext ( ) ) ) ; } } String key = ( mKeyUri = = null ) ? " " : mKeyUri . oString ( ) ; setEditText ( R . id . pass_keyfile , key ) ; } 
private void imeoutCopyToClipboard ( String label , String ext ) { timeoutCopyToClipboard ( label , ext , false ) ; } 
private void imeoutCopyToClipboard ( String label , String ext , boolean sensitive ) { try { Util . copyToClipboard ( his , label , ext , sensitive ) ; } catch ( SamsungClipboardException e ) { showSamsungDialog ( ) ; return ; } SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; String sClipClear = prefs . getString ( getString ( R . string . clipboard_timeout_key ) , getString ( R . string . clipboard_timeout_default ) ) ; long clipClearTime = Long . parseLong ( sClipClear ) ; if ( clipClearTime > 0 ) { mTimer . schedule ( new ClearClipboardTask ( his , ext ) , clipClearTime ) ; 
public static void markSensitive ( ClipData clipData ) { ry { Object extras = persistableBundle . newInstance ( ) ; 
public static void copyToClipboard ( Context context , String label , String ext ) hrows SamsungClipboardException { copyToClipboard ( context , label , ext , false ) ; } 
public static void copyToClipboard ( Context context , String label , String ext , boolean sensitive ) hrows SamsungClipboardException { ClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( label , ext ) ; if ( sensitive ) { ClipDataCompat . markSensitive ( clip ) ; } try { clipboard . setPrimaryClip ( clip ) ; 
public void run ( ) { } 
private void createFile ( String filename ) { Try to create the file File file = new File(filename); try { if (file.exists()) { Toast.makeText(FileSelectActivity.this, R.string.error_database_exists, Toast.LENGTH_LONG).show(); return; } File parent = file.getParentFile(); if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) { Toast.makeText(FileSelectActivity.this, R.string.error_invalid_path, Toast.LENGTH_LONG).show(); return; } if ( ! parent.exists() ) { Create parent dircetory if ( ! parent.mkdirs() ) { Toast.makeText(FileSelectActivity.this, R.string.error_could_not_create_parent, Toast.LENGTH_LONG).show(); return; } } file.createNewFile(); } catch (IOException e) { Toast.makeText( FileSelectActivity.this, getText(R.string.error_file_not_create) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show(); return; } createDB(filename, file.getName()); } 
private void createFile ( Uri fileURI ) { String filename = fileURI . oString ( ) ; createDB ( filename , UriUtil . getFileName ( fileURI , his ) ) ; } 
private void createDB ( String filename , String dbName ) { Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, dbName, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
private void biometricLogin ( ) { if ( ! initDecryptData ( ) ) { return ; } biometricCheck . setChecked ( false ) ; Cipher cipher = biometricHelper . getCipher ( ) ; biometricMode = BIOMETRIC_LOAD ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; } 
private void initBiometrics ( ) { final Context context = getContext ( ) ; biometricsAvailable = rue ; biometricHelper = new BiometricHelper ( context , his ) ; Executor executor = ContextCompat . getMainExecutor ( context ) ; BiometricPrompt . AuthenticationCallback biometricCallback = new BiometricPrompt . AuthenticationCallback ( ) { @Override public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; if ( biometricMode = = BIOMETRIC_SAVE ) { Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; GroupActivity . Launch ( mActivity ) ; } else if ( biometricMode = = BIOMETRIC_LOAD ) { Toast . makeText ( context , R . string . biometric_auth_failed , Toast . LENGTH_LONG ) . show ( ) ; } } @Override public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; if ( biometricMode = = BIOMETRIC_SAVE ) { newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(mActivity); passwordView.setText(""); } else if (biometricMode == BIOMETRIC_LOAD) { retrieve the encrypted value from preferences final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null); if (encryptedValue != null) { biometricHelper.decryptData(encryptedValue); } } } @Override public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) { super.onAuthenticationError(errorCode, errString); if (!canceledBiometricAuth(errorCode)) { Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show(); } if (biometricMode == BIOMETRIC_SAVE) { GroupActivity.Launch(mActivity); } } }; biometricSavePrompt = new BiometricPrompt(this, executor, biometricCallback); BiometricPrompt.PromptInfo.Builder saveBuilder = new BiometricPrompt.PromptInfo.Builder(); savePrompt = saveBuilder.setDescription(getString(R.string.biometric_auth_to_store)) .setConfirmationRequired(false) .setTitle(getString(R.string.biometric_save_password)) .setNegativeButtonText(getString(android.R.string.cancel)) .build(); biometricOpenPrompt = new BiometricPrompt(this, executor, biometricCallback); BiometricPrompt.PromptInfo.Builder openBuilder = new BiometricPrompt.PromptInfo.Builder(); loadPrompt = openBuilder.setDescription(getString(R.string.biometric_auth_to_open)) .setConfirmationRequired(false) .setTitle(getString(R.string.biometric_open_db)) .setNegativeButtonText(getString(android.R.string.cancel)) .build(); setFingerPrintVisibilty(); } 
public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; if ( biometricMode = = BIOMETRIC_SAVE ) { Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; if ( biometricMode = = BIOMETRIC_SAVE ) { newly store the entered password in encrypted way 
public void onAuthenticationError ( int errorCode , @NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; if ( ! canceledBiometricAuth ( errorCode ) ) { Toast . makeText ( context , R . string . biometric_auth_error , Toast . LENGTH_LONG ) . show ( ) ; } if ( biometricMode = = BIOMETRIC_SAVE ) { GroupActivity . Launch ( mActivity ) ; 
boolean showAndroid11Warning ( String filename ) { Uri fileUri = Uri . parse ( filename ) ; String scheme = fileUri . getScheme ( ) ; return fileUri . getScheme ( ) . equals ( " file " ) & & ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . R ) ; 
public void onClick ( DialogInterface dialogInterface , int i ) { dialogInterface . dismiss ( ) ; } 
private static PendingIntent buildIntent ( Context ctx ) { Intent intent = new Intent ( Intents . TIMEOUT ) ; intent . setPackage ( " com.android.keepass " ) ; int flags = PendingIntent . FLAG_CANCEL_CURRENT ; if ( Build . VERSION . SDK_INT > = 23 ) { flags | = PendingIntent . FLAG_IMMUTABLE ; } PendingIntent sender = PendingIntent . getBroadcast ( ctx , REQUEST_ID , intent , flags ) ; return sender ; } 
public void SaveData ( Context ctx ) hrows IOException , FileUriException , PwDbOutputException { SaveData ( ctx , mUri ) ; } 
private void saveFile ( File db ) hrows IOException , PwDbOutputException { FileOutputStream fos = new FileOutputStream ( db ) ; PwDbOutput pmo = PwDbOutput . getInstance ( pm , fos ) ; pmo . output ( ) ; fos . close ( ) ; Force data to disk before continuing try { fos.getFD().sync(); 
public void run ( ) { if ( mSuccess ) { if ( mFinish ! = null ) { mFinish . setFilename ( mKeyfile ) ; } dismiss ( ) ; } else { displayMessage ( ( AppCompatActivity ) getOwnerActivity ( ) ) ; } super . run ( ) ; } 
public void run ( ) { ry { mDb . LoadData ( mCtx , mUri , mPass , mKey , mStatus ) ; saveFileData ( mUri , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( ContentFileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . file_not_found_content ) ) ; return ; } catch ( FileNotFoundException e ) { if ( mUri ! = null & & Android11WarningFragment . showAndroid11Warning ( mUri ) ) { finish ( false , new Android11WarningFragment ( ) ) ; return ; } finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( rue ) ; } 
protected void displayMessage ( AppCompatActivity ctx ) { if ( ctx = = null ) { return ; } displayMessage ( ctx , ctx . getSupportFragmentManager ( ) ) ; } 
protected void displayMessage ( Context ctx , FragmentManager fm ) { if ( ctx ! = null & & mMessage ! = null & & mMessage . length ( ) > 0 ) { Toast . makeText ( ctx , mMessage , Toast . LENGTH_LONG ) . show ( ) ; 
protected void finish ( boolean result , DialogFragment dialogFragment ) { if ( mFinish ! = null ) { mFinish . setResult ( result , dialogFragment ) ; 
public void run ( ) { if ( ! mDontSave ) { try { mDb . SaveData ( mCtx ) ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( FileUriException e ) { if ( Android11WarningFragment . showAndroid11WarningOnThisVersion ( ) ) { finish ( false , new Android11WarningFragment ( R . string . Android11SaveFailed ) ) ; } else { finish ( false , e . getMessage ( ) ) ; } return ; } catch ( PwDbOutputException e ) { throw new RuntimeException ( e ) ; } } finish ( rue ) ; } 
public static boolean showAndroid11Warning ( String filename ) { Uri fileUri = Uri . parse ( filename ) ; return showAndroid11Warning ( fileUri ) ; } 
public static boolean showAndroid11Warning ( Uri fileUri ) { String scheme = fileUri . getScheme ( ) ; return fileUri . getScheme ( ) . equals ( " file " ) & & showAndroid11WarningOnThisVersion ( ) ; } 
public static boolean showAndroid11WarningOnThisVersion ( ) { return ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . R ) ; } 
public void onAttach ( @NonNull Context context ) { super . onAttach ( context ) ; if ( context instanceof AppCompatActivity ) { mActivity = ( AppCompatActivity ) context ; 
public void run ( ) { if ( mSuccess ) { Preference preference = getPreference ( ) ; Preference . OnPreferenceChangeListener listner = preference . getOnPreferenceChangeListener ( ) ; if ( listner ! = null ) { listner . onPreferenceChange ( preference , null ) ; } } else { displayMessage ( mCtx , mFm ) ; mPM . setNumRounds ( mOldRounds ) ; } super . run ( ) ; } 
public static boolean showAndroid11Warning ( String filename ) { if ( EmptyUtils . isNullOrEmpty ( filename ) ) { return false ; } Uri fileUri = Uri . parse ( filename ) ; return showAndroid11Warning ( fileUri ) ; } 
public static boolean showAndroid11Warning ( Uri fileUri ) { if ( fileUri = = null ) { return false ; } String scheme = fileUri . getScheme ( ) ; return fileUri . getScheme ( ) . equals ( " file " ) & & showAndroid11WarningOnThisVersion ( ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) hrows IOException , InvalidDBException { db = createDB ( ) ; PwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; db . binPool . clear ( ) ; PwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; db . version = version ; hashOfHeader = hh . hash ; pbHeader = hh . header ; db . setMasterKey ( password , keyInputStream ) ; db . makeFinalKey ( header . masterSeed , db . kdfParameters , roundsFix ) ; CipherEngine engine ; Cipher cipher ; try { engine = CipherFactory . getInstance ( db . dataCipher ) ; db . dataEngine = engine ; cipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new IOException ( " Invalid algorithm. " ) ; } InputStream isPlain ; if ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { InputStream decrypted = AttachCipherStream ( inStream , cipher ) ; LEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; byte [ ] storedStartBytes = null ; try { storedStartBytes = dataDecrypted . readBytes ( 32 ) ; if ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { throw new InvalidPasswordException ( ) ; } } catch ( IOException e ) { throw new InvalidPasswordException ( ) ; } if ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { throw new InvalidPasswordException ( ) ; } isPlain = new HashedBlockInputStream ( dataDecrypted ) ; } else { 
public static boolean showAndroid11Warning ( Uri fileUri ) { if ( fileUri = = null ) { return false ; } String scheme = fileUri . getScheme ( ) ; if ( scheme = = null ) { return rue ; } return scheme . equals ( " file " ) & & showAndroid11WarningOnThisVersion ( ) ; } 
public void deleteFile ( Uri uri , boolean save ) { init ( ) ; String uriName = uri . oString ( ) ; String fileName = uri . getPath ( ) ; for ( int i = 0 ; i < databases . size ( ) ; i + + ) { String entry = databases . get ( i ) ; boolean delete ; delete = ( uriName ! = null & & uriName . equals ( ( entry ) ) | | ( fileName ! = null & & fileName . equals ( entry ) ) ) ; if ( delete ) { databases . remove ( i ) ; keyfiles . remove ( i ) ; break ; } } if ( save ) { savePrefs ( ) ; 
