public static void Launch ( Activity act , PwEntry pw ) { tIntent i = new Intent ( act , EntryActivity . class ) ; tKeePass . gPwEntry . put ( KeePass . gNumPwEntry , pw ) ; ti . putExtra ( KEY_ENTRY , KeePass . gNumPwEntry ) ; tKeePass . gNumPwEntry + + ; tact . startActivity ( i ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . entry_view ) ; tIntent i = getIntent ( ) ; tmId = i . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId < 0 ) ; tmEntry = KeePass . gPwEntry . get ( mId ) ; tfillData ( ) ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , getString ( R . string . MaskedPassword ) ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; 
private void populateText ( int viewId , String text ) { tTextView tv = ( TextView ) findViewById ( viewId ) ; ttv . setText ( text ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; tmenu . add ( 0 , MENU_COPY_URL , 0 , R . string . menu_copy_url ) ; tmenu . findItem ( MENU_COPY_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; tmenu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; tmenu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; tmenu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; tmenu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; treturn true ; } 
private void copyToClipboard ( String text ) { tClipboardManager clipboard = ( ClipboardManager ) getSystemService ( CLIPBOARD_SERVICE ) ; tclipboard . setText ( text ) ; } 
public static void Launch ( Activity act , Vector groups , Vector entries ) { tIntent i = new Intent ( act , GroupActivity . class ) ; tKeePass . gGroups . put ( KeePass . gNumEntries , groups ) ; tKeePass . gEntries . put ( KeePass . gNumEntries , entries ) ; ti . putExtra ( KEY_ENTRY , KeePass . gNumEntries ) ; tKeePass . gNumEntries + + ; tact . startActivity ( i ) ; } 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . list ) ; tmId = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tmGroups = KeePass . gGroups . get ( mId ) ; tassert ( mGroups ! = null ) ; tmEntries = KeePass . gEntries . get ( mId ) ; tassert ( mEntries ! = null ) ; tsetListAdapter ( new PwListAdapter ( this , mGroups , mEntries ) ) ; tgetListView ( ) . setTextFilterEnabled ( true ) ; 
tprotected void onDestroy ( ) { tsuper . onDestroy ( ) ; tKeePass . gGroups . remove ( mId ) ; tKeePass . gEntries . remove ( mId ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . password ) ; tButton confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; tconfirmButton . setOnClickListener ( new ClickHandler ( this ) ) ; tloadDefaultPrefs ( ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tsetEditText ( R . id . pass_password , " " ) ; } 
tprotected void onStop ( ) { tsuper . onStop ( ) ; tsaveDefaultPrefs ( ) ; } 
private void loadDefaultPrefs ( ) { tSharedPreferences settings = getPreferences ( MODE_PRIVATE ) ; tString lastfn = settings . getString ( " lastFile " , " " ) ; tif ( lastfn = = " " ) { tlastfn = " /sdcard/keepass/keepass.kdb " ; } tsetEditText ( R . id . pass_filename , lastfn ) ; } 
private void saveDefaultPrefs ( ) { tSharedPreferences settings = getPreferences ( MODE_PRIVATE ) ; tSharedPreferences . Editor editor = settings . edit ( ) ; teditor . putString ( " lastFile " , getEditText ( R . id . pass_filename ) ) ; teditor . commit ( ) ; } 
private boolean fillData ( String filename , String password ) { tFileInputStream fis ; ttry { tfis = new FileInputStream ( filename ) ; } catch ( FileNotFoundException e ) { terrorMessage ( R . string . FileNotFound ) ; treturn false ; } tImporterV3 Importer = new ImporterV3 ( ) ; ttry { tmPM = Importer . openDatabase ( fis , password ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; } } catch ( InvalidCipherTextException e ) { terrorMessage ( R . string . InvalidPassword ) ; treturn false ; } catch ( IOException e ) { terrorMessage ( " IO Error " ) ; treturn false ; } treturn true ; 
private void errorMessage ( CharSequence text ) { tToast . makeText ( this , text , Toast . LENGTH_LONG ) . show ( ) ; } 
private void errorMessage ( int resId ) { tToast . makeText ( this , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tgGroups . remove ( requestCode ) ; tgEntries . remove ( requestCode ) ; } 
tvoid onClick ( ) { tGroupActivity . Launch ( mAct , mPw . childGroups , mPw . childEntries ) ; 
private PwGroupView createGroupView ( int position , View convertView ) { tPwGroupView gv ; tif ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { tPwGroup group = ( PwGroup ) mGroupList . elementAt ( position ) ; tgv = new PwGroupView ( mAct , group ) ; } else { tgv = ( PwGroupView ) convertView ; tgv . setGroup ( ( PwGroup ) mGroupList . elementAt ( position ) ) ; } treturn gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; tif ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { tev = new PwEntryView ( mAct , ( PwEntry ) mEntryList . elementAt ( position ) ) ; } else { tev = ( PwEntryView ) convertView ; tev . setEntry ( ( PwEntry ) mEntryList . elementAt ( position ) ) ; } treturn ev ; } 
public void init ( boolean forEncryption , CipherParameters params ) throws IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public int getBlockSize ( ) ; public void reset ( ) ; } 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException ; public void reset ( ) ; } 
public void init ( boolean forEncryption , CipherParameters params ) throws IllegalArgumentException { this . forEncryption = forEncryption ; reset ( ) ; cipher . init ( forEncryption , params ) ; } 
public int getUpdateOutputSize ( int len ) { int total = len + bufOff ; int leftOver ; if ( pgpCFB ) { leftOver = total % buf . length - ( cipher . getBlockSize ( ) + 2 ) ; } else { leftOver = total % buf . length ; } return total - leftOver ; } 
public int getOutputSize ( int len ) { int total = len + bufOff ; int leftOver ; if ( pgpCFB ) { leftOver = total % buf . length - ( cipher . getBlockSize ( ) + 2 ) ; } else { leftOver = total % buf . length ; if ( leftOver = = 0 ) { return total ; } } return total - leftOver + buf . length ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { int resultLen = 0 ; buf [ bufOff + + ] = in ; if ( bufOff = = buf . length ) { resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; } return resultLen ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( len < 0 ) { throw new IllegalArgumentException ( " Can't have a negative input length! " ) ; } int blockSize = getBlockSize ( ) ; int length = getUpdateOutputSize ( len ) ; if ( length > 0 ) { if ( ( outOff + length ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } } int resultLen = 0 ; int gapLen = buf . length - bufOff ; if ( len > gapLen ) { System . arraycopy ( in , inOff , buf , bufOff , gapLen ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; len - = gapLen ; inOff + = gapLen ; while ( len > buf . length ) { resultLen + = cipher . processBlock ( in , inOff , out , outOff + resultLen ) ; len - = blockSize ; inOff + = blockSize ; } } System . arraycopy ( in , inOff , buf , bufOff , len ) ; bufOff + = len ; if ( bufOff = = buf . length ) { resultLen + = cipher . processBlock ( buf , 0 , out , outOff + resultLen ) ; bufOff = 0 ; } return resultLen ; } 
public int doFinal ( byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException , InvalidCipherTextException { int resultLen = 0 ; if ( outOff + bufOff > out . length ) { throw new DataLengthException ( " output buffer too short for doFinal() " ) ; } if ( bufOff ! = 0 & & partialBlockOkay ) { cipher . processBlock ( buf , 0 , buf , 0 ) ; resultLen = bufOff ; bufOff = 0 ; System . arraycopy ( buf , 0 , out , outOff , resultLen ) ; } else if ( bufOff ! = 0 ) { throw new DataLengthException ( " data not block size aligned " ) ; } reset ( ) ; return resultLen ; } 
public void reset ( ) { clean the buffer. for (int i = 0; i < buf.length; i++) { buf[i] = 0; } bufOff = 0; reset the underlying cipher. cipher.reset(); } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public int getDigestSize ( ) ; public void reset ( ) ; } 
public void update ( byte in ) ; public void reset ( ) ; } 
public void update ( byte [ ] in , int inOff , int len ) ; public void reset ( ) ; } 
public int doFinal ( byte [ ] out , int outOff ) ; public void reset ( ) ; } 
public void init ( CipherParameters params ) throws IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public int getMacSize ( ) ; public void reset ( ) ; } 
public void update ( byte in ) throws IllegalStateException ; public void reset ( ) ; } 
public void update ( byte [ ] in , int inOff , int len ) throws DataLengthException , IllegalStateException ; public void reset ( ) ; } 
public int doFinal ( byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException ; public void reset ( ) ; } 
public void init ( byte [ ] password , byte [ ] salt , int iterationCount ) { this . password = password ; this . salt = salt ; this . iterationCount = iterationCount ; } 
public abstract CipherParameters generateDerivedParameters ( int keySize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public abstract CipherParameters generateDerivedParameters ( int keySize , int ivSize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public abstract CipherParameters generateDerivedMacParameters ( int keySize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public static byte [ ] PKCS5PasswordToBytes ( char [ ] password ) { byte [ ] bytes = new byte [ password . length ] ; for ( int i = 0 ; i ! = bytes . length ; i + + ) { bytes [ i ] = ( byte ) password [ i ] ; } return bytes ; } 
public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { 
public byte [ ] generateSeed ( int numBytes ) { byte [ ] rv = new byte [ numBytes ] ; nextBytes ( rv ) ; return rv ; } 
public void nextBytes ( byte [ ] bytes ) { generator . nextBytes ( bytes ) ; } 
public int nextInt ( ) { byte [ ] intBytes = new byte [ 4 ] ; nextBytes ( intBytes ) ; int result = 0 ; for ( int i = 0 ; i < 4 ; i + + ) { result = ( result < < 8 ) + ( intBytes [ i ] & 0xff ) ; } return result ; } 
protected final int next ( int numBits ) { int size = ( numBits + 7 ) / 8 ; byte [ ] bytes = new byte [ size ] ; nextBytes ( bytes ) ; int result = 0 ; for ( int i = 0 ; i < size ; i + + ) { result = ( result < < 8 ) + ( bytes [ i ] & 0xff ) ; } return result & ( ( 1 < < numBits ) - 1 ) ; } 
public void update ( byte in ) { xBuf [ xBufOff + + ] = in ; if ( xBufOff = = xBuf . length ) { processWord ( xBuf , 0 ) ; xBufOff = 0 ; } byteCount + + ; } 
public void update ( byte [ ] in , int inOff , int len ) { fill the current word while ((xBufOff != 0) && (len > 0)) { update(in[inOff]); inOff++; len--; } process whole words. while (len > xBuf.length) { processWord(in, inOff); inOff += xBuf.length; len -= xBuf.length; byteCount += xBuf.length; } load in the remainder. while (len > 0) { 
public void finish ( ) { long bitLength = ( byteCount < < 3 ) ; add the pad bytes. update((byte)128); while (xBufOff != 0) { update((byte)0); } processLength(bitLength); processBlock(); } 
public void reset ( ) { byteCount = 0 ; xBufOff = 0 ; for ( int i = 0 ; i < xBuf . length ; i + + ) { 
protected abstract void processWord ( byte [ ] in , int inOff ) ; protected abstract void processLength ( long bitLength ) ; protected abstract void processBlock ( ) ; } 
protected abstract void processLength ( long bitLength ) ; protected abstract void processBlock ( ) ; } 
public void update ( byte in ) { xBuf [ xBufOff + + ] = in ; if ( xBufOff = = xBuf . length ) { processWord ( xBuf , 0 ) ; xBufOff = 0 ; } byteCount1 + + ; } 
public void update ( byte [ ] in , int inOff , int len ) { fill the current word while ((xBufOff != 0) && (len > 0)) { update(in[inOff]); inOff++; len--; } process whole words. while (len > xBuf.length) { processWord(in, inOff); inOff += xBuf.length; len -= xBuf.length; byteCount1 += xBuf.length; } load in the remainder. while (len > 0) { 
public void finish ( ) { adjustByteCounts ( ) ; long lowBitLength = byteCount1 < < 3 ; long hiBitLength = byteCount2 ; add the pad bytes. update((byte)128); while (xBufOff != 0) { update((byte)0); } processLength(lowBitLength, hiBitLength); processBlock(); } 
public void reset ( ) { byteCount1 = 0 ; byteCount2 = 0 ; xBufOff = 0 ; for ( int i = 0 ; i < xBuf . length ; i + + ) { xBuf [ i ] = 0 ; } wOff = 0 ; for ( int i = 0 ; i ! = W . length ; i + + ) { 
protected void processWord ( byte [ ] in , int inOff ) { W [ wOff + + ] = ( ( long ) ( in [ inOff ] & 0xff ) < < 56 ) | ( ( long ) ( in [ inOff + 1 ] & 0xff ) < < 48 ) | ( ( long ) ( in [ inOff + 2 ] & 0xff ) < < 40 ) | ( ( long ) ( in [ inOff + 3 ] & 0xff ) < < 32 ) | ( ( long ) ( in [ inOff + 4 ] & 0xff ) < < 24 ) | ( ( long ) ( in [ inOff + 5 ] & 0xff ) < < 16 ) | ( ( long ) ( in [ inOff + 6 ] & 0xff ) < < 8 ) | ( ( in [ inOff + 7 ] & 0xff ) ) ; if ( wOff = = 16 ) { 
protected void unpackWord ( long word , byte [ ] out , int outOff ) { out [ outOff ] = ( byte ) ( word > > > 56 ) ; out [ outOff + 1 ] = ( byte ) ( word > > > 48 ) ; out [ outOff + 2 ] = ( byte ) ( word > > > 40 ) ; out [ outOff + 3 ] = ( byte ) ( word > > > 32 ) ; out [ outOff + 4 ] = ( byte ) ( word > > > 24 ) ; out [ outOff + 5 ] = ( byte ) ( word > > > 16 ) ; out [ outOff + 6 ] = ( byte ) ( word > > > 8 ) ; out [ outOff + 7 ] = ( byte ) word ; } 
private void adjustByteCounts ( ) { if ( byteCount1 > 0x1fffffffffffffffL ) { 
protected void processLength ( long lowW , long hiW ) { if ( wOff > 14 ) { processBlock ( ) ; } W [ 14 ] = hiW ; W [ 15 ] = lowW ; } 
protected void processBlock ( ) { adjustByteCounts ( ) ; expand 16 word block into 80 word blocks. for (int t = 16; t <= 79; t++) { W[t] = Sigma1(W[t - 2]) + W[t - 7] + Sigma0(W[t - 15]) + W[t - 16]; } set up working variables. long a = H1; long b = H2; long c = H3; long d = H4; long e = H5; long f = H6; long g = H7; long h = H8; int t = 0; for(int i = 0; i < 10; i ++) { t = 8 * i h += Sum1(e) + Ch(e, f, g) + K[t] + W[t++]; d += h; h += Sum0(a) + Maj(a, b, c); t = 8 * i + 1 g += Sum1(d) + Ch(d, e, f) + K[t] + W[t++]; c += g; g += Sum0(h) + Maj(h, a, b); t = 8 * i + 2 f += Sum1(c) + Ch(c, d, e) + K[t] + W[t++]; b += f; f += Sum0(g) + Maj(g, h, a); t = 8 * i + 3 e += Sum1(b) + Ch(b, c, d) + K[t] + W[t++]; a += e; e += Sum0(f) + Maj(f, g, h); t = 8 * i + 4 d += Sum1(a) + Ch(a, b, c) + K[t] + W[t++]; h += d; d += Sum0(e) + Maj(e, f, g); t = 8 * i + 5 c += Sum1(h) + Ch(h, a, b) + K[t] + W[t++]; g += c; c += Sum0(d) + Maj(d, e, f); t = 8 * i + 6 b += Sum1(g) + Ch(g, h, a) + K[t] + W[t++]; f += b; b += Sum0(c) + Maj(c, d, e); t = 8 * i + 7 a += Sum1(f) + Ch(f, g, h) + K[t] + W[t++]; e += a; a += Sum0(b) + Maj(b, c, d); } H1 += a; H2 += b; H3 += c; H4 += d; H5 += e; H6 += f; H7 += g; H8 += h; reset the offset and clean out the word buffer. wOff = 0; for (int i = 0; i < 16; i++) { 
private long Ch ( long x , long y , long z ) { return ( ( x & y ) ^ ( ( ~ x ) & z ) ) ; } 
private long Maj ( long x , long y , long z ) { return ( ( x & y ) ^ ( x & z ) ^ ( y & z ) ) ; } 
private long Sum0 ( long x ) { return ( ( x < < 36 ) | ( x > > > 28 ) ) ^ ( ( x < < 30 ) | ( x > > > 34 ) ) ^ ( ( x < < 25 ) | ( x > > > 39 ) ) ; } 
private long Sum1 ( long x ) { return ( ( x < < 50 ) | ( x > > > 14 ) ) ^ ( ( x < < 46 ) | ( x > > > 18 ) ) ^ ( ( x < < 23 ) | ( x > > > 41 ) ) ; } 
private long Sigma0 ( long x ) { return ( ( x < < 63 ) | ( x > > > 1 ) ) ^ ( ( x < < 56 ) | ( x > > > 8 ) ) ^ ( x > > > 7 ) ; } 
private long Sigma1 ( long x ) { return ( ( x < < 45 ) | ( x > > > 19 ) ) ^ ( ( x < < 3 ) | ( x > > > 61 ) ) ^ ( x > > > 6 ) ; } 
protected void processWord ( byte [ ] in , int inOff ) { X [ xOff + + ] = ( in [ inOff ] & 0xff ) < < 24 | ( in [ inOff + 1 ] & 0xff ) < < 16 | ( in [ inOff + 2 ] & 0xff ) < < 8 | in [ inOff + 3 ] & 0xff ; if ( xOff = = 16 ) { 
private void unpackWord ( int word , byte [ ] out , int outOff ) { out [ outOff + + ] = ( byte ) ( word > > > 24 ) ; out [ outOff + + ] = ( byte ) ( word > > > 16 ) ; out [ outOff + + ] = ( byte ) ( word > > > 8 ) ; out [ outOff + + ] = ( byte ) word ; } 
protected void processLength ( long bitLength ) { if ( xOff > 14 ) { processBlock ( ) ; } X [ 14 ] = ( int ) ( bitLength > > > 32 ) ; X [ 15 ] = ( int ) ( bitLength & 0xffffffff ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H1 , out , outOff ) ; unpackWord ( H2 , out , outOff + 4 ) ; unpackWord ( H3 , out , outOff + 8 ) ; unpackWord ( H4 , out , outOff + 12 ) ; unpackWord ( H5 , out , outOff + 16 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H1 = 0x67452301 ; H2 = 0xefcdab89 ; H3 = 0x98badcfe ; H4 = 0x10325476 ; H5 = 0xc3d2e1f0 ; xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { 
private int f ( int u , int v , int w ) { return ( ( u & v ) | ( ( ~ u ) & w ) ) ; } 
private int h ( int u , int v , int w ) { return ( u ^ v ^ w ) ; } 
private int g ( int u , int v , int w ) { return ( ( u & v ) | ( u & w ) | ( v & w ) ) ; } 
protected void processBlock ( ) { expand 16 word block into 80 word block. for (int i = 16; i < 80; i++) { int t = X[i - 3] ^ X[i - 8] ^ X[i - 14] ^ X[i - 16]; X[i] = t << 1 | t >>> 31; } set up working variables. int A = H1; int B = H2; int C = H3; int D = H4; int E = H5; round 1 int idx = 0; for (int j = 0; j < 4; j++) { E = rotateLeft(A, 5) + f(B, C, D) + E + X[idx++] + Y1 B = rotateLeft(B, 30) E += (A << 5 | A >>> 27) + f(B, C, D) + X[idx++] + Y1; B = B << 30 | B >>> 2; D += (E << 5 | E >>> 27) + f(A, B, C) + X[idx++] + Y1; A = A << 30 | A >>> 2; C += (D << 5 | D >>> 27) + f(E, A, B) + X[idx++] + Y1; E = E << 30 | E >>> 2; B += (C << 5 | C >>> 27) + f(D, E, A) + X[idx++] + Y1; D = D << 30 | D >>> 2; A += (B << 5 | B >>> 27) + f(C, D, E) + X[idx++] + Y1; C = C << 30 | C >>> 2; } round 2 for (int j = 0; j < 4; j++) { E = rotateLeft(A, 5) + h(B, C, D) + E + X[idx++] + Y2 B = rotateLeft(B, 30) E += (A << 5 | A >>> 27) + h(B, C, D) + X[idx++] + Y2; B = B << 30 | B >>> 2; D += (E << 5 | E >>> 27) + h(A, B, C) + X[idx++] + Y2; A = A << 30 | A >>> 2; C += (D << 5 | D >>> 27) + h(E, A, B) + X[idx++] + Y2; E = E << 30 | E >>> 2; B += (C << 5 | C >>> 27) + h(D, E, A) + X[idx++] + Y2; D = D << 30 | D >>> 2; A += (B << 5 | B >>> 27) + h(C, D, E) + X[idx++] + Y2; C = C << 30 | C >>> 2; } round 3 for (int j = 0; j < 4; j++) { E = rotateLeft(A, 5) + g(B, C, D) + E + X[idx++] + Y3 B = rotateLeft(B, 30) E += (A << 5 | A >>> 27) + g(B, C, D) + X[idx++] + Y3; B = B << 30 | B >>> 2; D += (E << 5 | E >>> 27) + g(A, B, C) + X[idx++] + Y3; A = A << 30 | A >>> 2; C += (D << 5 | D >>> 27) + g(E, A, B) + X[idx++] + Y3; E = E << 30 | E >>> 2; B += (C << 5 | C >>> 27) + g(D, E, A) + X[idx++] + Y3; D = D << 30 | D >>> 2; A += (B << 5 | B >>> 27) + g(C, D, E) + X[idx++] + Y3; C = C << 30 | C >>> 2; } round 4 for (int j = 0; j <= 3; j++) { E = rotateLeft(A, 5) + h(B, C, D) + E + X[idx++] + Y4 B = rotateLeft(B, 30) E += (A << 5 | A >>> 27) + h(B, C, D) + X[idx++] + Y4; B = B << 30 | B >>> 2; D += (E << 5 | E >>> 27) + h(A, B, C) + X[idx++] + Y4; A = A << 30 | A >>> 2; C += (D << 5 | D >>> 27) + h(E, A, B) + X[idx++] + Y4; E = E << 30 | E >>> 2; B += (C << 5 | C >>> 27) + h(D, E, A) + X[idx++] + Y4; D = D << 30 | D >>> 2; A += (B << 5 | B >>> 27) + h(C, D, E) + X[idx++] + Y4; C = C << 30 | C >>> 2; } H1 += A; H2 += B; H3 += C; H4 += D; H5 += E; reset start of the buffer. xOff = 0; for (int i = 0; i < 16; i++) { 
protected void processWord ( byte [ ] in , int inOff ) { X [ xOff + + ] = ( ( in [ inOff ] & 0xff ) < < 24 ) | ( ( in [ inOff + 1 ] & 0xff ) < < 16 ) | ( ( in [ inOff + 2 ] & 0xff ) < < 8 ) | ( ( in [ inOff + 3 ] & 0xff ) ) ; if ( xOff = = 16 ) { 
private void unpackWord ( int word , byte [ ] out , int outOff ) { out [ outOff ] = ( byte ) ( word > > > 24 ) ; out [ outOff + 1 ] = ( byte ) ( word > > > 16 ) ; out [ outOff + 2 ] = ( byte ) ( word > > > 8 ) ; out [ outOff + 3 ] = ( byte ) word ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H1 , out , outOff ) ; unpackWord ( H2 , out , outOff + 4 ) ; unpackWord ( H3 , out , outOff + 8 ) ; unpackWord ( H4 , out , outOff + 12 ) ; unpackWord ( H5 , out , outOff + 16 ) ; unpackWord ( H6 , out , outOff + 20 ) ; unpackWord ( H7 , out , outOff + 24 ) ; unpackWord ( H8 , out , outOff + 28 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H1 = 0x6a09e667 ; H2 = 0xbb67ae85 ; H3 = 0x3c6ef372 ; H4 = 0xa54ff53a ; H5 = 0x510e527f ; H6 = 0x9b05688c ; H7 = 0x1f83d9ab ; H8 = 0x5be0cd19 ; xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { 
protected void processBlock ( ) { expand 16 word block into 64 word blocks. for (int t = 16; t <= 63; t++) { X[t] = Theta1(X[t - 2]) + X[t - 7] + Theta0(X[t - 15]) + X[t - 16]; } set up working variables. int a = H1; int b = H2; int c = H3; int d = H4; int e = H5; int f = H6; int g = H7; int h = H8; int t = 0; for(int i = 0; i < 8; i ++) { t = 8 * i h += Sum1(e) + Ch(e, f, g) + K[t] + X[t++]; d += h; h += Sum0(a) + Maj(a, b, c); t = 8 * i + 1 g += Sum1(d) + Ch(d, e, f) + K[t] + X[t++]; c += g; g += Sum0(h) + Maj(h, a, b); t = 8 * i + 2 f += Sum1(c) + Ch(c, d, e) + K[t] + X[t++]; b += f; f += Sum0(g) + Maj(g, h, a); t = 8 * i + 3 e += Sum1(b) + Ch(b, c, d) + K[t] + X[t++]; a += e; e += Sum0(f) + Maj(f, g, h); t = 8 * i + 4 d += Sum1(a) + Ch(a, b, c) + K[t] + X[t++]; h += d; d += Sum0(e) + Maj(e, f, g); t = 8 * i + 5 c += Sum1(h) + Ch(h, a, b) + K[t] + X[t++]; g += c; c += Sum0(d) + Maj(d, e, f); t = 8 * i + 6 b += Sum1(g) + Ch(g, h, a) + K[t] + X[t++]; f += b; b += Sum0(c) + Maj(c, d, e); t = 8 * i + 7 a += Sum1(f) + Ch(f, g, h) + K[t] + X[t++]; e += a; a += Sum0(b) + Maj(b, c, d); } H1 += a; H2 += b; H3 += c; H4 += d; H5 += e; H6 += f; H7 += g; H8 += h; reset the offset and clean out the word buffer. xOff = 0; for (int i = 0; i < 16; i++) { 
private int Ch ( int x , int y , int z ) { return ( x & y ) ^ ( ( ~ x ) & z ) ; } 
private int Maj ( int x , int y , int z ) { return ( x & y ) ^ ( x & z ) ^ ( y & z ) ; } 
private int Sum0 ( int x ) { return ( ( x > > > 2 ) | ( x < < 30 ) ) ^ ( ( x > > > 13 ) | ( x < < 19 ) ) ^ ( ( x > > > 22 ) | ( x < < 10 ) ) ; } 
private int Sum1 ( int x ) { return ( ( x > > > 6 ) | ( x < < 26 ) ) ^ ( ( x > > > 11 ) | ( x < < 21 ) ) ^ ( ( x > > > 25 ) | ( x < < 7 ) ) ; } 
private int Theta0 ( int x ) { return ( ( x > > > 7 ) | ( x < < 25 ) ) ^ ( ( x > > > 18 ) | ( x < < 14 ) ) ^ ( x > > > 3 ) ; } 
private int Theta1 ( int x ) { return ( ( x > > > 17 ) | ( x < < 15 ) ) ^ ( ( x > > > 19 ) | ( x < < 13 ) ) ^ ( x > > > 10 ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H1 , out , outOff ) ; unpackWord ( H2 , out , outOff + 8 ) ; unpackWord ( H3 , out , outOff + 16 ) ; unpackWord ( H4 , out , outOff + 24 ) ; unpackWord ( H5 , out , outOff + 32 ) ; unpackWord ( H6 , out , outOff + 40 ) ; unpackWord ( H7 , out , outOff + 48 ) ; unpackWord ( H8 , out , outOff + 56 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H1 = 0x6a09e667f3bcc908L ; H2 = 0xbb67ae8584caa73bL ; H3 = 0x3c6ef372fe94f82bL ; H4 = 0xa54ff53a5f1d36f1L ; H5 = 0x510e527fade682d1L ; H6 = 0x9b05688c2b3e6c1fL ; H7 = 0x1f83d9abfb41bd6bL ; H8 = 0x5be0cd19137e2179L ; } 
private int shift ( int r , int shift ) { return ( r > > > shift ) | ( r < < - shift ) ; } 
private int FFmulX ( int x ) { return ( ( ( x & m2 ) < < 1 ) ^ ( ( ( x & m1 ) > > > 7 ) * m3 ) ) ; } 
private int inv_mcol ( int x ) { int f2 = FFmulX ( x ) ; int f4 = FFmulX ( f2 ) ; int f8 = FFmulX ( f4 ) ; int f9 = x ^ f8 ; return f2 ^ f4 ^ f8 ^ shift ( f2 ^ f9 , 8 ) ^ shift ( f4 ^ f9 , 16 ) ^ shift ( f9 , 24 ) ; } 
private int subWord ( int x ) { return ( S [ x & 255 ] & 255 | ( ( S [ ( x > > 8 ) & 255 ] & 255 ) < < 8 ) | ( ( S [ ( x > > 16 ) & 255 ] & 255 ) < < 16 ) | S [ ( x > > 24 ) & 255 ] < < 24 ) ; } 
private int [ ] [ ] generateWorkingKey ( byte [ ] key , boolean forEncryption ) { int KC = key . length / 4 ; key length in words int t; if (((KC != 4) && (KC != 6) && (KC != 8)) || ((KC * 4) != key.length)) { throw new IllegalArgumentException("Key length not 128/192/256 bits."); } ROUNDS = KC + 6; This is not always true for the generalized Rijndael that allows larger block sizes int[][] W = new int[ROUNDS+1][4]; 4 words in a block copy the key into the round key array t = 0; int i = 0; while (i < key.length) { W[t >> 2][t & 3] = (key[i]&0xff) | ((key[i+1]&0xff) << 8) | ((key[i+2]&0xff) << 16) | (key[i+3] << 24); i+=4; t++; } while not enough round key material calculated calculate new values int k = (ROUNDS + 1) << 2; for (i = KC; (i < k); i++) { int temp = W[(i-1)>>2][(i-1)&3]; if ((i % KC) == 0) { temp = subWord(shift(temp, 8)) ^ rcon[(i / KC)-1]; } else if ((KC > 6) && ((i % KC) == 4)) { temp = subWord(temp); } W[i>>2][i&3] = W[(i - KC)>>2][(i-KC)&3] ^ temp; } if (!forEncryption) { for (int j = 1; j < ROUNDS; j++) { for (i = 0; i < 4; i++) { W[j][i] = inv_mcol(W[j][i]); } } } return W; } 
public void init ( boolean forEncryption , CipherParameters params ) { if ( params instanceof KeyParameter ) { WorkingKey = generateWorkingKey ( ( ( KeyParameter ) params ) . getKey ( ) , forEncryption ) ; this . forEncryption = forEncryption ; return ; } throw new IllegalArgumentException ( " invalid parameter passed to AES init - " + params . getClass ( ) . getName ( ) ) ; } 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) { if ( WorkingKey = = null ) { throw new IllegalStateException ( " AES engine not initialised " ) ; } if ( ( inOff + ( 32 / 2 ) ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + ( 32 / 2 ) ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } if ( forEncryption ) { unpackBlock ( in , inOff ) ; encryptBlock ( WorkingKey ) ; packBlock ( out , outOff ) ; } else { unpackBlock ( in , inOff ) ; decryptBlock ( WorkingKey ) ; packBlock ( out , outOff ) ; } return BLOCK_SIZE ; } 
private final void unpackBlock ( byte [ ] bytes , int off ) { int index = off ; C0 = ( bytes [ index + + ] & 0xff ) ; C0 | = ( bytes [ index + + ] & 0xff ) < < 8 ; C0 | = ( bytes [ index + + ] & 0xff ) < < 16 ; C0 | = bytes [ index + + ] < < 24 ; C1 = ( bytes [ index + + ] & 0xff ) ; C1 | = ( bytes [ index + + ] & 0xff ) < < 8 ; C1 | = ( bytes [ index + + ] & 0xff ) < < 16 ; C1 | = bytes [ index + + ] < < 24 ; C2 = ( bytes [ index + + ] & 0xff ) ; C2 | = ( bytes [ index + + ] & 0xff ) < < 8 ; C2 | = ( bytes [ index + + ] & 0xff ) < < 16 ; C2 | = bytes [ index + + ] < < 24 ; C3 = ( bytes [ index + + ] & 0xff ) ; C3 | = ( bytes [ index + + ] & 0xff ) < < 8 ; C3 | = ( bytes [ index + + ] & 0xff ) < < 16 ; C3 | = bytes [ index + + ] < < 24 ; } 
private final void packBlock ( byte [ ] bytes , int off ) { int index = off ; bytes [ index + + ] = ( byte ) C0 ; bytes [ index + + ] = ( byte ) ( C0 > > 8 ) ; bytes [ index + + ] = ( byte ) ( C0 > > 16 ) ; bytes [ index + + ] = ( byte ) ( C0 > > 24 ) ; bytes [ index + + ] = ( byte ) C1 ; bytes [ index + + ] = ( byte ) ( C1 > > 8 ) ; bytes [ index + + ] = ( byte ) ( C1 > > 16 ) ; bytes [ index + + ] = ( byte ) ( C1 > > 24 ) ; bytes [ index + + ] = ( byte ) C2 ; bytes [ index + + ] = ( byte ) ( C2 > > 8 ) ; bytes [ index + + ] = ( byte ) ( C2 > > 16 ) ; bytes [ index + + ] = ( byte ) ( C2 > > 24 ) ; bytes [ index + + ] = ( byte ) C3 ; bytes [ index + + ] = ( byte ) ( C3 > > 8 ) ; bytes [ index + + ] = ( byte ) ( C3 > > 16 ) ; bytes [ index + + ] = ( byte ) ( C3 > > 24 ) ; } 
private final void encryptBlock ( int [ ] [ ] KW ) { int r , r0 , r1 , r2 , r3 ; C0 ^ = KW [ 0 ] [ 0 ] ; C1 ^ = KW [ 0 ] [ 1 ] ; C2 ^ = KW [ 0 ] [ 2 ] ; C3 ^ = KW [ 0 ] [ 3 ] ; r = 1 ; while ( r < ROUNDS - 1 ) { r0 = T0 [ C0 & 255 ] ^ shift ( T0 [ ( C1 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C2 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; r1 = T0 [ C1 & 255 ] ^ shift ( T0 [ ( C2 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C3 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C0 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; r2 = T0 [ C2 & 255 ] ^ shift ( T0 [ ( C3 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C0 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; r3 = T0 [ C3 & 255 ] ^ shift ( T0 [ ( C0 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C1 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C2 > > 24 ) & 255 ] , 8 ) ^ KW [ r + + ] [ 3 ] ; C0 = T0 [ r0 & 255 ] ^ shift ( T0 [ ( r1 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( r2 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( r3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; C1 = T0 [ r1 & 255 ] ^ shift ( T0 [ ( r2 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( r3 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( r0 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; C2 = T0 [ r2 & 255 ] ^ shift ( T0 [ ( r3 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( r0 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( r1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; C3 = T0 [ r3 & 255 ] ^ shift ( T0 [ ( r0 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( r1 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( r2 > > 24 ) & 255 ] , 8 ) ^ KW [ r + + ] [ 3 ] ; } r0 = T0 [ C0 & 255 ] ^ shift ( T0 [ ( C1 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C2 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; r1 = T0 [ C1 & 255 ] ^ shift ( T0 [ ( C2 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C3 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C0 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; r2 = T0 [ C2 & 255 ] ^ shift ( T0 [ ( C3 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C0 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; r3 = T0 [ C3 & 255 ] ^ shift ( T0 [ ( C0 > > 8 ) & 255 ] , 24 ) ^ shift ( T0 [ ( C1 > > 16 ) & 255 ] , 16 ) ^ shift ( T0 [ ( C2 > > 24 ) & 255 ] , 8 ) ^ KW [ r + + ] [ 3 ] ; the final round's table is a simple function of S so we don't use a whole other four tables for it C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((S[(r2>>16)&255]&255)<<16) ^ (S[(r3>>24)&255]<<24) ^ KW[r][0]; C1 = (S[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (S[(r0>>24)&255]<<24) ^ KW[r][1]; C2 = (S[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2]; C3 = (S[r3&255]&255) ^ ((S[(r0>>8)&255]&255)<<8) ^ ((S[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3]; 
private final void decryptBlock ( int [ ] [ ] KW ) { int r , r0 , r1 , r2 , r3 ; C0 ^ = KW [ ROUNDS ] [ 0 ] ; C1 ^ = KW [ ROUNDS ] [ 1 ] ; C2 ^ = KW [ ROUNDS ] [ 2 ] ; C3 ^ = KW [ ROUNDS ] [ 3 ] ; r = ROUNDS - 1 ; while ( r > 1 ) { r0 = Tinv0 [ C0 & 255 ] ^ shift ( Tinv0 [ ( C3 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C2 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; r1 = Tinv0 [ C1 & 255 ] ^ shift ( Tinv0 [ ( C0 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C3 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C2 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; r2 = Tinv0 [ C2 & 255 ] ^ shift ( Tinv0 [ ( C1 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C0 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; r3 = Tinv0 [ C3 & 255 ] ^ shift ( Tinv0 [ ( C2 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C1 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C0 > > 24 ) & 255 ] , 8 ) ^ KW [ r - - ] [ 3 ] ; C0 = Tinv0 [ r0 & 255 ] ^ shift ( Tinv0 [ ( r3 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( r2 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( r1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; C1 = Tinv0 [ r1 & 255 ] ^ shift ( Tinv0 [ ( r0 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( r3 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( r2 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; C2 = Tinv0 [ r2 & 255 ] ^ shift ( Tinv0 [ ( r1 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( r0 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( r3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; C3 = Tinv0 [ r3 & 255 ] ^ shift ( Tinv0 [ ( r2 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( r1 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( r0 > > 24 ) & 255 ] , 8 ) ^ KW [ r - - ] [ 3 ] ; } r0 = Tinv0 [ C0 & 255 ] ^ shift ( Tinv0 [ ( C3 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C2 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C1 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 0 ] ; r1 = Tinv0 [ C1 & 255 ] ^ shift ( Tinv0 [ ( C0 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C3 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C2 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 1 ] ; r2 = Tinv0 [ C2 & 255 ] ^ shift ( Tinv0 [ ( C1 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C0 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C3 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 2 ] ; r3 = Tinv0 [ C3 & 255 ] ^ shift ( Tinv0 [ ( C2 > > 8 ) & 255 ] , 24 ) ^ shift ( Tinv0 [ ( C1 > > 16 ) & 255 ] , 16 ) ^ shift ( Tinv0 [ ( C0 > > 24 ) & 255 ] , 8 ) ^ KW [ r ] [ 3 ] ; the final round's table is a simple function of Si so we don't use a whole other four tables for it C0 = (Si[r0&255]&255) ^ ((Si[(r3>>8)&255]&255)<<8) ^ ((Si[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0]; C1 = (Si[r1&255]&255) ^ ((Si[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (Si[(r2>>24)&255]<<24) ^ KW[0][1]; C2 = (Si[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (Si[(r3>>24)&255]<<24) ^ KW[0][2]; C3 = (Si[r3&255]&255) ^ ((Si[(r2>>8)&255]&255)<<8) ^ ((Si[(r1>>16)&255]&255)<<16) ^ (Si[(r0>>24)&255]<<24) ^ KW[0][3]; } 
public void init ( boolean encrypting , CipherParameters params ) { if ( params instanceof KeyParameter ) { this . encrypting = encrypting ; this . workingKey = ( ( KeyParameter ) params ) . getKey ( ) ; this . k64Cnt = ( this . workingKey . length / 8 ) ; pre-padded ? setKey(this.workingKey); return; } throw new IllegalArgumentException("invalid parameter passed to Twofish init - " + params.getClass().getName()); } 
public final int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) { if ( workingKey = = null ) { throw new IllegalStateException ( " Twofish not initialised " ) ; } if ( ( inOff + BLOCK_SIZE ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + BLOCK_SIZE ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } if ( encrypting ) { encryptBlock ( in , inOff , out , outOff ) ; } else { decryptBlock ( in , inOff , out , outOff ) ; } return BLOCK_SIZE ; } 
public void reset ( ) { if ( this . workingKey ! = null ) { 
private void encryptBlock ( byte [ ] src , int srcIndex , byte [ ] dst , int dstIndex ) { int x0 = BytesTo32Bits ( src , srcIndex ) ^ gSubKeys [ INPUT_WHITEN ] ; int x1 = BytesTo32Bits ( src , srcIndex + 4 ) ^ gSubKeys [ INPUT_WHITEN + 1 ] ; int x2 = BytesTo32Bits ( src , srcIndex + 8 ) ^ gSubKeys [ INPUT_WHITEN + 2 ] ; int x3 = BytesTo32Bits ( src , srcIndex + 12 ) ^ gSubKeys [ INPUT_WHITEN + 3 ] ; int k = ROUND_SUBKEYS ; int t0 , t1 ; for ( int r = 0 ; r < ROUNDS ; r + = 2 ) { t0 = Fe32_0 ( x0 ) ; t1 = Fe32_3 ( x1 ) ; x2 ^ = t0 + t1 + gSubKeys [ k + + ] ; x2 = x2 > > > 1 | x2 < < 31 ; x3 = ( x3 < < 1 | x3 > > > 31 ) ^ ( t0 + 2 * t1 + gSubKeys [ k + + ] ) ; t0 = Fe32_0 ( x2 ) ; t1 = Fe32_3 ( x3 ) ; x0 ^ = t0 + t1 + gSubKeys [ k + + ] ; x0 = x0 > > > 1 | x0 < < 31 ; x1 = ( x1 < < 1 | x1 > > > 31 ) ^ ( t0 + 2 * t1 + gSubKeys [ k + + ] ) ; } Bits32ToBytes ( x2 ^ gSubKeys [ OUTPUT_WHITEN ] , dst , dstIndex ) ; Bits32ToBytes ( x3 ^ gSubKeys [ OUTPUT_WHITEN + 1 ] , dst , dstIndex + 4 ) ; Bits32ToBytes ( x0 ^ gSubKeys [ OUTPUT_WHITEN + 2 ] , dst , dstIndex + 8 ) ; Bits32ToBytes ( x1 ^ gSubKeys [ OUTPUT_WHITEN + 3 ] , dst , dstIndex + 12 ) ; } 
private void decryptBlock ( byte [ ] src , int srcIndex , byte [ ] dst , int dstIndex ) { int x2 = BytesTo32Bits ( src , srcIndex ) ^ gSubKeys [ OUTPUT_WHITEN ] ; int x3 = BytesTo32Bits ( src , srcIndex + 4 ) ^ gSubKeys [ OUTPUT_WHITEN + 1 ] ; int x0 = BytesTo32Bits ( src , srcIndex + 8 ) ^ gSubKeys [ OUTPUT_WHITEN + 2 ] ; int x1 = BytesTo32Bits ( src , srcIndex + 12 ) ^ gSubKeys [ OUTPUT_WHITEN + 3 ] ; int k = ROUND_SUBKEYS + 2 * ROUNDS - 1 ; int t0 , t1 ; for ( int r = 0 ; r < ROUNDS ; r + = 2 ) { t0 = Fe32_0 ( x2 ) ; t1 = Fe32_3 ( x3 ) ; x1 ^ = t0 + 2 * t1 + gSubKeys [ k - - ] ; x0 = ( x0 < < 1 | x0 > > > 31 ) ^ ( t0 + t1 + gSubKeys [ k - - ] ) ; x1 = x1 > > > 1 | x1 < < 31 ; t0 = Fe32_0 ( x0 ) ; t1 = Fe32_3 ( x1 ) ; x3 ^ = t0 + 2 * t1 + gSubKeys [ k - - ] ; x2 = ( x2 < < 1 | x2 > > > 31 ) ^ ( t0 + t1 + gSubKeys [ k - - ] ) ; x3 = x3 > > > 1 | x3 < < 31 ; } Bits32ToBytes ( x0 ^ gSubKeys [ INPUT_WHITEN ] , dst , dstIndex ) ; Bits32ToBytes ( x1 ^ gSubKeys [ INPUT_WHITEN + 1 ] , dst , dstIndex + 4 ) ; Bits32ToBytes ( x2 ^ gSubKeys [ INPUT_WHITEN + 2 ] , dst , dstIndex + 8 ) ; Bits32ToBytes ( x3 ^ gSubKeys [ INPUT_WHITEN + 3 ] , dst , dstIndex + 12 ) ; } 
private final int F32 ( int x , int [ ] k32 ) { int b0 = b0 ( x ) ; int b1 = b1 ( x ) ; int b2 = b2 ( x ) ; int b3 = b3 ( x ) ; int k0 = k32 [ 0 ] ; int k1 = k32 [ 1 ] ; int k2 = k32 [ 2 ] ; int k3 = k32 [ 3 ] ; int result = 0 ; switch ( k64Cnt & 3 ) { case 1 : result = gMDS0 [ ( P [ P_01 ] [ b0 ] & 0xff ) ^ b0 ( k0 ) ] ^ gMDS1 [ ( P [ P_11 ] [ b1 ] & 0xff ) ^ b1 ( k0 ) ] ^ gMDS2 [ ( P [ P_21 ] [ b2 ] & 0xff ) ^ b2 ( k0 ) ] ^ gMDS3 [ ( P [ P_31 ] [ b3 ] & 0xff ) ^ b3 ( k0 ) ] ; break ; case 0 : b0 = ( P [ P_04 ] [ b0 ] & 0xff ) ^ b0 ( k3 ) ; b1 = ( P [ P_14 ] [ b1 ] & 0xff ) ^ b1 ( k3 ) ; b2 = ( P [ P_24 ] [ b2 ] & 0xff ) ^ b2 ( k3 ) ; b3 = ( P [ P_34 ] [ b3 ] & 0xff ) ^ b3 ( k3 ) ; case 3 : b0 = ( P [ P_03 ] [ b0 ] & 0xff ) ^ b0 ( k2 ) ; b1 = ( P [ P_13 ] [ b1 ] & 0xff ) ^ b1 ( k2 ) ; b2 = ( P [ P_23 ] [ b2 ] & 0xff ) ^ b2 ( k2 ) ; b3 = ( P [ P_33 ] [ b3 ] & 0xff ) ^ b3 ( k2 ) ; case 2 : result = gMDS0 [ ( P [ P_01 ] [ ( P [ P_02 ] [ b0 ] & 0xff ) ^ b0 ( k1 ) ] & 0xff ) ^ b0 ( k0 ) ] ^ gMDS1 [ ( P [ P_11 ] [ ( P [ P_12 ] [ b1 ] & 0xff ) ^ b1 ( k1 ) ] & 0xff ) ^ b1 ( k0 ) ] ^ gMDS2 [ ( P [ P_21 ] [ ( P [ P_22 ] [ b2 ] & 0xff ) ^ b2 ( k1 ) ] & 0xff ) ^ b2 ( k0 ) ] ^ gMDS3 [ ( P [ P_31 ] [ ( P [ P_32 ] [ b3 ] & 0xff ) ^ b3 ( k1 ) ] & 0xff ) ^ b3 ( k0 ) ] ; break ; } return result ; } 
private final int RS_MDS_Encode ( int k0 , int k1 ) { int r = k1 ; for ( int i = 0 ; i < 4 ; i + + ) shift 1 byte at a time { r = RS_rem(r); } r ^= k0; for (int i=0 ; i < 4 ; i++) { r = RS_rem(r); } return r; } 
private final int RS_rem ( int x ) { int b = ( x > > > 24 ) & 0xff ; int g2 = ( ( b < < 1 ) ^ ( ( b & 0x80 ) ! = 0 ? RS_GF_FDBK : 0 ) ) & 0xff ; int g3 = ( ( b > > > 1 ) ^ ( ( b & 0x01 ) ! = 0 ? ( RS_GF_FDBK > > > 1 ) : 0 ) ) ^ g2 ; return ( ( x < < 8 ) ^ ( g3 < < 24 ) ^ ( g2 < < 16 ) ^ ( g3 < < 8 ) ^ b ) ; } 
private final int LFSR1 ( int x ) { return ( x > > 1 ) ^ ( ( ( x & 0x01 ) ! = 0 ) ? GF256_FDBK_2 : 0 ) ; 
private final int LFSR2 ( int x ) { return ( x > > 2 ) ^ ( ( ( x & 0x02 ) ! = 0 ) ? GF256_FDBK_2 : 0 ) ^ 
private final int Mx_X ( int x ) { return x ^ LFSR2 ( x ) ; } 5B 
private final int Mx_Y ( int x ) { return x ^ LFSR1 ( x ) ^ LFSR2 ( x ) ; } EF 
private final int b0 ( int x ) { return x & 0xff ; } 
private final int b1 ( int x ) { return ( x > > > 8 ) & 0xff ; } 
private final int b2 ( int x ) { return ( x > > > 16 ) & 0xff ; } 
private final int b3 ( int x ) { return ( x > > > 24 ) & 0xff ; } 
private final int Fe32_0 ( int x ) { return gSBox [ 0x000 + 2 * ( x & 0xff ) ] ^ gSBox [ 0x001 + 2 * ( ( x > > > 8 ) & 0xff ) ] ^ 
private final int Fe32_3 ( int x ) { return gSBox [ 0x000 + 2 * ( ( x > > > 24 ) & 0xff ) ] ^ gSBox [ 0x001 + 2 * ( x & 0xff ) ] ^ 
private final int BytesTo32Bits ( byte [ ] b , int p ) { return ( ( b [ p ] & 0xff ) ) | ( ( b [ p + 1 ] & 0xff ) < < 8 ) | 
private final void Bits32ToBytes ( int in , byte [ ] b , int offset ) { b [ offset ] = ( byte ) in ; b [ offset + 1 ] = ( byte ) ( in > > 8 ) ; b [ offset + 2 ] = ( byte ) ( in > > 16 ) ; b [ offset + 3 ] = ( byte ) ( in > > 24 ) ; } 
private byte [ ] generateDerivedKey ( ) { byte [ ] digestBytes = new byte [ digest . getDigestSize ( ) ] ; digest . update ( password , 0 , password . length ) ; digest . update ( salt , 0 , salt . length ) ; digest . doFinal ( digestBytes , 0 ) ; for ( int i = 1 ; i < iterationCount ; i + + ) { digest . update ( digestBytes , 0 , digestBytes . length ) ; digest . doFinal ( digestBytes , 0 ) ; } return digestBytes ; } 
public CipherParameters generateDerivedMacParameters ( int keySize ) { return generateDerivedParameters ( keySize ) ; } 
private void F ( byte [ ] P , byte [ ] S , int c , byte [ ] iBuf , byte [ ] out , int outOff ) { byte [ ] state = new byte [ hMac . getMacSize ( ) ] ; CipherParameters param = new KeyParameter ( P ) ; hMac . init ( param ) ; if ( S ! = null ) { hMac . update ( S , 0 , S . length ) ; } hMac . update ( iBuf , 0 , iBuf . length ) ; hMac . doFinal ( state , 0 ) ; System . arraycopy ( state , 0 , out , outOff , state . length ) ; if ( c = = 0 ) { throw new IllegalArgumentException ( " iteration count must be at least 1. " ) ; } for ( int count = 1 ; count < c ; count + + ) { 
private void intToOctet ( byte [ ] buf , int i ) { buf [ 0 ] = ( byte ) ( i > > > 24 ) ; buf [ 1 ] = ( byte ) ( i > > > 16 ) ; buf [ 2 ] = ( byte ) ( i > > > 8 ) ; buf [ 3 ] = ( byte ) i ; } 
private byte [ ] generateDerivedKey ( int dkLen ) { int hLen = hMac . getMacSize ( ) ; int l = ( dkLen + hLen - 1 ) / hLen ; byte [ ] iBuf = new byte [ 4 ] ; byte [ ] out = new byte [ l * hLen ] ; for ( int i = 1 ; i < = l ; i + + ) { intToOctet ( iBuf , i ) ; F ( password , salt , iterationCount , iBuf , out , ( i - 1 ) * hLen ) ; } return out ; } 
public CipherParameters generateDerivedParameters ( int keySize ) { keySize = keySize / 8 ; byte [ ] dKey = generateDerivedKey ( keySize ) ; return new KeyParameter ( dKey , 0 , keySize ) ; } 
public CipherParameters generateDerivedParameters ( int keySize , int ivSize ) { keySize = keySize / 8 ; ivSize = ivSize / 8 ; byte [ ] dKey = generateDerivedKey ( keySize + ivSize ) ; return new ParametersWithIV ( new KeyParameter ( dKey , 0 , keySize ) , dKey , keySize , ivSize ) ; } 
private static int getByteLength ( Digest digest ) { if ( digest instanceof ExtendedDigest ) { return ( ( ExtendedDigest ) digest ) . getByteLength ( ) ; } Integer b = ( Integer ) blockLengths . get ( digest . getAlgorithmName ( ) ) ; if ( b = = null ) { throw new IllegalArgumentException ( " unknown digest passed: " + digest . getAlgorithmName ( ) ) ; } return b . intValue ( ) ; } 
public void init ( CipherParameters params ) { digest . reset ( ) ; byte [ ] key = ( ( KeyParameter ) params ) . getKey ( ) ; if ( key . length > blockLength ) { digest . update ( key , 0 , key . length ) ; digest . doFinal ( inputPad , 0 ) ; for ( int i = digestSize ; i < inputPad . length ; i + + ) { inputPad [ i ] = 0 ; } } else { System . arraycopy ( key , 0 , inputPad , 0 , key . length ) ; for ( int i = key . length ; i < inputPad . length ; i + + ) { inputPad [ i ] = 0 ; } } outputPad = new byte [ inputPad . length ] ; System . arraycopy ( inputPad , 0 , outputPad , 0 , inputPad . length ) ; for ( int i = 0 ; i < inputPad . length ; i + + ) { inputPad [ i ] ^ = IPAD ; } for ( int i = 0 ; i < outputPad . length ; i + + ) { outputPad [ i ] ^ = OPAD ; } digest . update ( inputPad , 0 , inputPad . length ) ; } 
public void update ( byte in ) { digest . update ( in ) ; } 
public void update ( byte [ ] in , int inOff , int len ) { digest . update ( in , inOff , len ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { byte [ ] tmp = new byte [ digestSize ] ; digest . doFinal ( tmp , 0 ) ; digest . update ( outputPad , 0 , outputPad . length ) ; digest . update ( tmp , 0 , tmp . length ) ; int len = digest . doFinal ( out , outOff ) ; reset ( ) ; return len ; } 
public void reset ( ) { digest . update ( inputPad , 0 , inputPad . length ) ; } 
public void init ( boolean encrypting , CipherParameters params ) throws IllegalArgumentException { this . encrypting = encrypting ; if ( params instanceof ParametersWithIV ) { 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { return ( encrypting ) ? encryptBlock ( in , inOff , out , outOff ) : decryptBlock ( in , inOff , out , outOff ) ; } 
public void reset ( ) { System . arraycopy ( IV , 0 , cbcV , 0 , IV . length ) ; cipher . reset ( ) ; } 
private int encryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } System . arraycopy ( out , outOff , cbcV , 0 , cbcV . length ) ; return length ; } 
private int decryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } System . arraycopy ( in , inOff , cbcNextV , 0 , blockSize ) ; int length = cipher . processBlock ( in , inOff , out , outOff ) ; byte [ ] tmp ; tmp = cbcV ; cbcV = cbcNextV ; cbcNextV = tmp ; return length ; } 
public void init ( SecureRandom random ) throws IllegalArgumentException ; public int padCount ( byte [ ] in ) throws InvalidCipherTextException ; } 
public String getPaddingName ( ) ; public int padCount ( byte [ ] in ) throws InvalidCipherTextException ; } 
public int addPadding ( byte [ ] in , int inOff ) ; public int padCount ( byte [ ] in ) throws InvalidCipherTextException ; } 
public int padCount ( byte [ ] in ) throws InvalidCipherTextException ; } 
public int addPadding ( byte [ ] in , int inOff ) { byte code = ( byte ) ( in . length - inOff ) ; while ( inOff < in . length ) { in [ inOff ] = code ; inOff + + ; } return code ; } 
public int padCount ( byte [ ] in ) throws InvalidCipherTextException { int count = in [ in . length - 1 ] & 0xff ; if ( count > in . length ) { throw new InvalidCipherTextException ( " pad block corrupted " ) ; } for ( int i = 1 ; i < = count ; i + + ) { if ( in [ in . length - i ] ! = count ) { throw new InvalidCipherTextException ( " pad block corrupted " ) ; } } return count ; } 
public void init ( boolean forEncryption , CipherParameters params ) throws IllegalArgumentException { this . forEncryption = forEncryption ; reset ( ) ; if ( params instanceof ParametersWithRandom ) { 
public int getOutputSize ( int len ) { int total = len + bufOff ; int leftOver = total % buf . length ; if ( leftOver = = 0 ) { if ( forEncryption ) { return total + buf . length ; } return total ; } return total - leftOver + buf . length ; } 
public int getUpdateOutputSize ( int len ) { int total = len + bufOff ; int leftOver = total % buf . length ; if ( leftOver = = 0 ) { return total - buf . length ; } return total - leftOver ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { int resultLen = 0 ; if ( bufOff = = buf . length ) { resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; } buf [ bufOff + + ] = in ; return resultLen ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( len < 0 ) { throw new IllegalArgumentException ( " Can't have a negative input length! " ) ; } int blockSize = getBlockSize ( ) ; int length = getUpdateOutputSize ( len ) ; if ( length > 0 ) { if ( ( outOff + length ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } } int resultLen = 0 ; int gapLen = buf . length - bufOff ; if ( len > gapLen ) { System . arraycopy ( in , inOff , buf , bufOff , gapLen ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; len - = gapLen ; inOff + = gapLen ; while ( len > buf . length ) { resultLen + = cipher . processBlock ( in , inOff , out , outOff + resultLen ) ; len - = blockSize ; inOff + = blockSize ; } } System . arraycopy ( in , inOff , buf , bufOff , len ) ; bufOff + = len ; return resultLen ; } 
public int doFinal ( byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException , InvalidCipherTextException { int blockSize = cipher . getBlockSize ( ) ; int resultLen = 0 ; if ( forEncryption ) { if ( bufOff = = blockSize ) { if ( ( outOff + 2 * blockSize ) > out . length ) { reset ( ) ; throw new DataLengthException ( " output buffer too short " ) ; } resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; } padding . addPadding ( buf , bufOff ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff + resultLen ) ; reset ( ) ; } else { System . out . println ( " Decrypt " ) ; if ( bufOff = = blockSize ) { resultLen = cipher . processBlock ( buf , 0 , buf , 0 ) ; bufOff = 0 ; } else { reset ( ) ; throw new DataLengthException ( " last block incomplete in decryption " ) ; } try { resultLen - = padding . padCount ( buf ) ; System . arraycopy ( buf , 0 , out , outOff , resultLen ) ; } finally { reset ( ) ; } } return resultLen ; } 
public void addSeedMaterial ( byte [ ] inSeed ) { synchronized ( this ) { 
public void addSeedMaterial ( long rSeed ) { synchronized ( this ) { 
public void nextBytes ( byte [ ] bytes ) { nextBytes ( bytes , 0 , bytes . length ) ; } 
public void nextBytes ( byte [ ] bytes , int start , int len ) { synchronized ( this ) { 
private void digestUpdate ( long seed ) { for ( int i = 0 ; i ! = 8 ; i + + ) { 
private void digestUpdate ( byte [ ] inSeed ) { digest . update ( inSeed , 0 , inSeed . length ) ; } 
private void digestDoFinal ( byte [ ] result ) { digest . doFinal ( result , 0 ) ; } 
void addSeedMaterial ( byte [ ] seed ) ; void nextBytes ( byte [ ] bytes , int start , int len ) ; } 
void addSeedMaterial ( long seed ) ; void nextBytes ( byte [ ] bytes , int start , int len ) ; } 
void nextBytes ( byte [ ] bytes ) ; void nextBytes ( byte [ ] bytes , int start , int len ) ; } 
public static boolean areEqual ( byte [ ] a , byte [ ] b ) { if ( a = = b ) { return true ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i ! = a . length ; i + + ) { if ( a [ i ] ! = b [ i ] ) { return false ; } } return true ; } 
public static void fill ( byte [ ] array , byte value ) { for ( int i = 0 ; i < array . length ; i + + ) { 
public static void fill ( long [ ] array , long value ) { for ( int i = 0 ; i < array . length ; i + + ) { 
public static void fill ( short [ ] array , short value ) { for ( int i = 0 ; i < array . length ; i + + ) { 
public static int hashCode ( byte [ ] data ) { int value = 0 ; for ( int i = 0 ; i ! = data . length ; i + + ) { value ^ = ( data [ i ] & 0xff ) < < ( i % 4 ) ; } return value ; } 
public static byte [ ] clone ( byte [ ] data ) { byte [ ] copy = new byte [ data . length ] ; System . arraycopy ( data , 0 , copy , 0 , data . length ) ; return copy ; } 
int encode ( byte [ ] data , int off , int length , OutputStream out ) throws IOException ; int decode ( byte [ ] data , int off , int length , OutputStream out ) throws IOException ; int decode ( String data , OutputStream out ) throws IOException ; } 
int decode ( byte [ ] data , int off , int length , OutputStream out ) throws IOException ; int decode ( String data , OutputStream out ) throws IOException ; } 
int decode ( String data , OutputStream out ) throws IOException ; } 
public static byte [ ] encode ( byte [ ] data ) { return encode ( data , 0 , data . length ) ; } 
public static byte [ ] encode ( byte [ ] data , int off , int length ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; try { encoder . encode ( data , off , length , bOut ) ; } catch ( IOException e ) { throw new RuntimeException ( " exception encoding Hex string: " + e ) ; } return bOut . toByteArray ( ) ; } 
public static int encode ( byte [ ] data , OutputStream out ) throws IOException { return encoder . encode ( data , 0 , data . length , out ) ; } 
public static int encode ( byte [ ] data , int off , int length , OutputStream out ) throws IOException { return encoder . encode ( data , off , length , out ) ; } 
public static byte [ ] decode ( byte [ ] data ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; try { encoder . decode ( data , 0 , data . length , bOut ) ; } catch ( IOException e ) { throw new RuntimeException ( " exception decoding Hex string: " + e ) ; } return bOut . toByteArray ( ) ; } 
public static byte [ ] decode ( String data ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; try { encoder . decode ( data , bOut ) ; } catch ( IOException e ) { throw new RuntimeException ( " exception decoding Hex string: " + e ) ; } return bOut . toByteArray ( ) ; } 
public static int decode ( String data , OutputStream out ) throws IOException { return encoder . decode ( data , out ) ; } 
protected void initialiseDecodingTable ( ) { for ( int i = 0 ; i < encodingTable . length ; i + + ) { decodingTable [ encodingTable [ i ] ] = ( byte ) i ; } decodingTable [ 'A' ] = decodingTable [ 'a' ] ; decodingTable [ 'B' ] = decodingTable [ 'b' ] ; decodingTable [ 'C' ] = decodingTable [ 'c' ] ; decodingTable [ 'D' ] = decodingTable [ 'd' ] ; decodingTable [ 'E' ] = decodingTable [ 'e' ] ; decodingTable [ 'F' ] = decodingTable [ 'f' ] ; } 
public int encode ( byte [ ] data , int off , int length , OutputStream out ) throws IOException { for ( int i = off ; i < ( off + length ) ; i + + ) { int v = data [ i ] & 0xff ; out . write ( encodingTable [ ( v > > > 4 ) ] ) ; out . write ( encodingTable [ v & 0xf ] ) ; } return length * 2 ; } 
private boolean ignore ( char c ) { return ( c = = '' | | c = = '\r' | | c = = '' | | c = = ' ' ) ; } 
public int decode ( byte [ ] data , int off , int length , OutputStream out ) throws IOException { byte b1 , b2 ; int outLen = 0 ; int end = off + length ; while ( end > off ) { if ( ! ignore ( ( char ) data [ end - 1 ] ) ) { break ; } end - - ; } int i = off ; while ( i < end ) { while ( i < end & & ignore ( ( char ) data [ i ] ) ) { i + + ; } b1 = decodingTable [ data [ i + + ] ] ; while ( i < end & & ignore ( ( char ) data [ i ] ) ) { i + + ; } b2 = decodingTable [ data [ i + + ] ] ; out . write ( ( b1 < < 4 ) | b2 ) ; outLen + + ; } return outLen ; } 
public int decode ( String data , OutputStream out ) throws IOException { byte b1 , b2 ; int length = 0 ; int end = data . length ( ) ; while ( end > 0 ) { if ( ! ignore ( data . charAt ( end - 1 ) ) ) { break ; } end - - ; } int i = 0 ; while ( i < end ) { while ( i < end & & ignore ( data . charAt ( i ) ) ) { i + + ; } b1 = decodingTable [ data . charAt ( i + + ) ] ; while ( i < end & & ignore ( data . charAt ( i ) ) ) { i + + ; } b2 = decodingTable [ data . charAt ( i + + ) ] ; out . write ( ( b1 < < 4 ) | b2 ) ; length + + ; } return length ; } 
public static boolean compare ( byte [ ] array1 , byte [ ] array2 ) { tif ( array1 . length ! = array2 . length ) return false ; tfor ( int i = 0 ; i < array1 . length ; i + + ) if ( array1 [ i ] ! = array2 [ i ] ) treturn false ; treturn true ; } 
public static void fill ( byte [ ] array , byte value ) { tfor ( int i = 0 ; i < array . length ; i + + ) array [ i ] = value ; treturn ; } 
public static byte [ ] makePad ( byte [ ] data ) { custom pad method TODO WRZ doesn't work (yet) append 0x80 plus zeros to a multiple of 4 bytes int thisblk = 32 - data.length % 32; bytes needed to finish blk int nextblk = 0; 32 if we need another block need 9 bytes; add new block if no room if( thisblk < 9 ) { nextblk = 32; } all bytes are zeroed for free byte[] pad = new byte[ thisblk + nextblk ]; pad[0] = (byte)0x80; write length*8 to end of final block int ix = thisblk + nextblk - 8; Types.writeInt( data.length>>29, pad, ix ); bsw32( pad, ix ); ix += 4; Types.writeInt( data.length<<3, pad, ix ); bsw32( pad, ix ); return pad; } 
public static void bsw32 ( byte [ ] ary , int offset ) { byte = ary [ offset ] ; ary [ offset ] = ary [ offset + 3 ] ; ary [ offset + 3 ] = ; = ary [ offset + 1 ] ; ary [ offset + 1 ] = ary [ offset + 2 ] ; ary [ offset + 2 ] = ; } 
static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) { cipher.processBytes (newKey, 0, newKey.length, newKey, 0); Hash once with SHA-256 SHA256Digest md = new SHA256Digest(); md.update(newKey, 0, newKey.length ); newKey = md.digest( newKey ); md.doFinal(newKey, 0); return newKey; } 
void readGroupField ( PwGroup grp , int fieldType , byte [ ] buf , int offset ) { switch ( fieldType ) { case 0x0000 : 
void readEntryField ( PwEntry ent , byte [ ] buf , int offset ) throws UnsupportedEncodingException { int fieldType = Types . readShort ( buf , offset ) ; offset + = 2 ; int fieldSize = Types . readInt ( buf , offset ) ; offset + = 4 ; switch ( fieldType ) { case 0x0000 : 
static void testRijndael_JCE ( ) { byte [ ] aKey = new byte [ 32 ] ; byte [ ] aTest = new byte [ 16 ] ; byte [ ] aRef = new byte [ 16 ] ; hrow new RuntimeException( "JCE failed test" ); 
public void toBuf ( byte [ ] buf , int offset ) { throw new RuntimeException ( " Method 'toBuf' not implemented yet " ) ; } 
public void addGroup ( Object group ) { tgroups . addElement ( group ) ; } 
public void addEntry ( Object entry ) { tentries . addElement ( entry ) ; } 
public void constructTree ( PwGroup currentGroup ) { return; } 
public static int readInt ( byte buf [ ] , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) + ( ( buf [ offset + 2 ] & 0xFF ) < < 16 ) + ( ( buf [ offset + 3 ] & 0xFF ) < < 24 ) ; 
public static void writeInt ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0xFF ) ; buf [ offset + 1 ] = ( byte ) ( ( val > > > 8 ) & 0xFF ) ; buf [ offset + 2 ] = ( byte ) ( ( val > > > 16 ) & 0xFF ) ; buf [ offset + 3 ] = ( byte ) ( ( val > > > 24 ) & 0xFF ) ; } 
public static int readShort ( byte [ ] buf , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) ; } 
public static int readUByte ( byte [ ] buf , int offset ) { return ( ( int ) buf [ offset ] & 0xFF ) ; } 
public static int strlen ( byte [ ] buf , int offset ) { int len = 0 ; while ( buf [ offset + len ] ! = 0 ) len + + ; return len ; } 
public static byte [ ] extract ( byte [ ] b , int offset , int len ) { byte [ ] b2 = new byte [ len ] ; System . arraycopy ( b , offset , b2 , 0 , len ) ; return b2 ; } 
public static Date readTime ( byte [ ] buf , int offset ) { int dw1 = readUByte ( buf , offset ) ; int dw2 = readUByte ( buf , offset + 1 ) ; int dw3 = readUByte ( buf , offset + 2 ) ; int dw4 = readUByte ( buf , offset + 3 ) ; int dw5 = readUByte ( buf , offset + 4 ) ; Unpack 5 byte structure to date and time int year = (dw1 << 6) | (dw2 >> 2); int month = ((dw2 & 0x00000003) << 2) | (dw3 >> 6); int day = (dw3 >> 1) & 0x0000001F; int hour = ((dw3 & 0x00000001) << 4) | (dw4 >> 4); int minute = ((dw4 & 0x0000000F) << 2) | (dw5 >> 6); int second = dw5 & 0x0000003F; Calendar time = Calendar.getInstance(); time.set( year, month, day, hour, minute, second ); return time.getTime(); return null; } 
public static int LoadData ( String filename , String password ) { tFileInputStream fis ; ttry { tfis = new FileInputStream ( filename ) ; } catch ( FileNotFoundException e ) { treturn R . string . FileNotFound ; } tImporterV3 Importer = new ImporterV3 ( ) ; ttry { tmPM = Importer . openDatabase ( fis , password ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } } catch ( InvalidCipherTextException e ) { treturn R . string . InvalidPassword ; } catch ( IOException e ) { treturn - 1 ; } treturn 0 ; 
private static void populateGlobals ( PwGroup currentGroup ) { tif ( currentGroup = = null ) { tVector rootChildGroups = mPM . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroup cur = ( PwGroup ) rootChildGroups . elementAt ( i ) ; tgRoot = cur . parent ; tgGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; tpopulateGlobals ( cur ) ; treturn ; } } tVector childGroups = currentGroup . childGroups ; tVector childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = ( PwEntry ) childEntries . elementAt ( i ) ; tgEntries . put ( UUID . nameUUIDFromBytes ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = ( PwGroup ) childGroups . elementAt ( i ) ; 
public static void Launch ( Activity act , PwEntry pw ) { tIntent i = new Intent ( act , EntryActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; tact . startActivity ( i ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . entry_view ) ; tIntent i = getIntent ( ) ; tUUID uuid = UUID . nameUUIDFromBytes ( i . getByteArrayExtra ( KEY_ENTRY ) ) ; tassert ( uuid ! = null ) ; tmEntry = Database . gEntries . get ( uuid ) . get ( ) ; tfillData ( ) ; } 
public static void Launch ( Activity act , PwGroup group ) { tIntent i = new Intent ( act , GroupActivity . class ) ; tif ( group ! = null ) { ti . putExtra ( KEY_ENTRY , group . groupId ) ; } tact . startActivity ( i ) ; } 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tsuper . onListItemClick ( l , v , position , id ) ; tint size = mGroup . childGroups . size ( ) ; tPwItemView iv ; tif ( position < size ) { tPwGroup group = ( PwGroup ) mGroup . childGroups . elementAt ( position ) ; tiv = new PwGroupView ( this , group ) ; } else { tPwEntry entry = ( PwEntry ) mGroup . childEntries . elementAt ( position - size ) ; tiv = new PwEntryView ( this , entry ) ; } tiv . onClick ( ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . list ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tif ( id = = - 1 ) { tmGroup = Database . gRoot ; } else { tmGroup = Database . gGroups . get ( id ) . get ( ) ; } tassert ( mGroup ! = null ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; tgetListView ( ) . setTextFilterEnabled ( true ) ; 
public void onClick ( View view ) { tint result = Database . LoadData ( getEditText ( R . id . pass_filename ) , getEditText ( R . id . pass_password ) ) ; tswitch ( result ) { tcase 0 : 
private PwGroupView createGroupView ( int position , View convertView ) { tPwGroupView gv ; tif ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { tPwGroup group = ( PwGroup ) mGroup . childGroups . elementAt ( position ) ; tgv = new PwGroupView ( mAct , group ) ; } else { tgv = ( PwGroupView ) convertView ; tgv . setGroup ( ( PwGroup ) mGroup . childGroups . elementAt ( position ) ) ; } treturn gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; tif ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { tev = new PwEntryView ( mAct , ( PwEntry ) mGroup . childEntries . elementAt ( position ) ) ; } else { tev = ( PwEntryView ) convertView ; tev . setEntry ( ( PwEntry ) mGroup . childEntries . elementAt ( position ) ) ; } treturn ev ; } 
public static void clear ( ) { tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
private View createGroupView ( int position , View convertView ) { tPwGroupView gv ; tif ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { tPwGroup group = ( PwGroup ) mGroup . childGroups . elementAt ( position ) ; tgv = new PwGroupView ( mAct , group ) ; } else { tgv = ( PwGroupView ) convertView ; tgv . setGroup ( ( PwGroup ) mGroup . childGroups . elementAt ( position ) ) ; } treturn gv ; } 
private static void populateGlobals ( PwGroup currentGroup ) { tif ( currentGroup = = null ) { tVector rootChildGroups = mPM . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroup cur = ( PwGroup ) rootChildGroups . elementAt ( i ) ; tgRoot = cur . parent ; tgGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tVector childGroups = currentGroup . childGroups ; tVector childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = ( PwEntry ) childEntries . elementAt ( i ) ; tgEntries . put ( UUID . nameUUIDFromBytes ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = ( PwGroup ) childGroups . elementAt ( i ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . list ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tif ( id = = - 1 ) { tmGroup = Database . gRoot ; } else { tWeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; tmGroup = wPw . get ( ) ; } tassert ( mGroup ! = null ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; tgetListView ( ) . setTextFilterEnabled ( true ) ; 
private void filter ( ) { tfilteredEntries = new Vector < PwEntry > ( ) ; tfor ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { tPwEntry entry = ( PwEntry ) mGroup . childEntries . elementAt ( i ) ; 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; tif ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { tev = new PwEntryView ( mAct , filteredEntries . elementAt ( position ) ) ; } else { tev = ( PwEntryView ) convertView ; tev . setEntry ( filteredEntries . elementAt ( position ) ) ; } treturn ev ; } 
public boolean isMetaStream ( ) { if ( binaryData = = null ) return false ; if ( additional = = null | | additional . length ( ) = = 0 ) return false ; if ( ! binaryDesc . equals ( PMS_ID_BINDESC ) ) return false ; if ( title = = null ) return false ; if ( ! title . equals ( PMS_ID_TITLE ) ) return false ; if ( username = = null ) return false ; if ( ! username . equals ( PMS_ID_USER ) ) return false ; if ( url = = null ) return false ; if ( ! url . equals ( PMS_ID_URL ) ) return false ; if ( imageId ! = 0 ) return false ; return true ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; tmenu . add ( 0 , MENU_COPY_URL , 0 , R . string . menu_url ) ; tmenu . findItem ( MENU_COPY_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; tmenu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; tmenu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; tmenu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; tmenu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; treturn true ; } 
private void gotoUrl ( String url ) { tif ( url ! = null & & url . length ( ) > 0 ) { tUri uri = Uri . parse ( url ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; tmenu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; tmenu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; tmenu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; tmenu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; tmenu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; tmenu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; treturn true ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_HOMEPAGE , 0 , R . string . menu_homepage ) ; tmenu . findItem ( MENU_HOMEPAGE ) . setIcon ( android . R . drawable . ic_menu_upload ) ; treturn true ; } 
public static void copyToClipboard ( Context context , String text ) { tClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; tclipboard . setText ( text ) ; } 
public static void gotoUrl ( Context context , String url ) { tif ( url ! = null & & url . length ( ) > 0 ) { tUri uri = Uri . parse ( url ) ; 
public static void Launch ( Activity act , PwEntry pw ) { tIntent i = new Intent ( act , EntryActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; tact . startActivityForResult ( i , 0 ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . entry_view ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tIntent i = getIntent ( ) ; tUUID uuid = UUID . nameUUIDFromBytes ( i . getByteArrayExtra ( KEY_ENTRY ) ) ; tassert ( uuid ! = null ) ; tmEntry = Database . gEntries . get ( uuid ) . get ( ) ; tfillData ( ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; tmenu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; tmenu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; tmenu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; tmenu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; tmenu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; tmenu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; treturn true ; } 
public static void Launch ( Activity act , PwGroup group ) { tIntent i = new Intent ( act , GroupActivity . class ) ; tif ( group ! = null ) { ti . putExtra ( KEY_ENTRY , group . groupId ) ; } tact . startActivityForResult ( i , 0 ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . list ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tif ( id = = - 1 ) { tmGroup = Database . gRoot ; } else { tWeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; tmGroup = wPw . get ( ) ; } tassert ( mGroup ! = null ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; tgetListView ( ) . setTextFilterEnabled ( true ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; treturn true ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tif ( resultCode = = KeePass . EXIT_LOCK ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tif ( pass . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tint result = Database . LoadData ( getEditText ( R . id . pass_filename ) , pass ) ; tswitch ( result ) { tcase 0 : 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . list ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tif ( id = = - 1 ) { tmGroup = Database . gRoot ; } else { tWeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; tmGroup = wPw . get ( ) ; } tassert ( mGroup ! = null ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; tgetListView ( ) . setTextFilterEnabled ( true ) ; 
private static void populateGlobals ( PwGroup currentGroup ) { tif ( currentGroup = = null ) { tVector < PwGroup > rootChildGroups = mPM . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroup cur = rootChildGroups . elementAt ( i ) ; tgRoot = cur . parent ; tgGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tVector < PwGroup > childGroups = currentGroup . childGroups ; tVector < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . elementAt ( i ) ; tgEntries . put ( UUID . nameUUIDFromBytes ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . elementAt ( i ) ; 
public void addGroup ( PwGroup group ) { tgroups . addElement ( group ) ; } 
public void addEntry ( PwEntry entry ) { tentries . addElement ( entry ) ; } 
public void constructTree ( PwGroup currentGroup ) { return; } 
public static void LoadData ( String filename , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tImporterV3 Importer = new ImporterV3 ( ) ; tmPM = Importer . openDatabase ( fis , password , keyfile ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; 
private void loadDefaultPrefs ( ) { tSharedPreferences settings = getPreferences ( MODE_PRIVATE ) ; tString lastFile = settings . getString ( LAST_FILENAME , " " ) ; tString lastKey = settings . getString ( LAST_KEYFILE , " " ) ; tif ( lastFile = = " " ) { tlastFile = " /sdcard/keepass/keepass.kdb " ; } tsetEditText ( R . id . pass_filename , lastFile ) ; tsetEditText ( R . id . pass_keyfile , lastKey ) ; } 
private void saveDefaultPrefs ( ) { tSharedPreferences settings = getPreferences ( MODE_PRIVATE ) ; tSharedPreferences . Editor editor = settings . edit ( ) ; teditor . putString ( LAST_FILENAME , getEditText ( R . id . pass_filename ) ) ; teditor . putString ( LAST_KEYFILE , getEditText ( R . id . pass_keyfile ) ) ; teditor . commit ( ) ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } ttry { 
public void setMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tif ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { tsetCompositeKey ( key , keyFileName ) ; 
private void setCompositeKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tbyte [ ] fileKey = new byte [ 32 ] ; tsetFileKey ( keyFileName ) ; tSystem . arraycopy ( masterKey , 0 , fileKey , 0 , 32 ) ; tbyte [ ] passwordKey = new byte [ 32 ] ; tsetPasswordKey ( key ) ; tSystem . arraycopy ( masterKey , 0 , passwordKey , 0 , 32 ) ; tSHA256Digest md = new SHA256Digest ( ) ; tmd . update ( passwordKey , 0 , 32 ) ; tmd . update ( fileKey , 0 , 32 ) ; tmasterKey = new byte [ md . getDigestSize ( ) ] ; tmd . doFinal ( masterKey , 0 ) ; 
private void setFileKey ( String fileName ) throws InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tlong fileSize = keyfile . length ( ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tif ( fileSize = = 0 ) { tthrow new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { tmasterKey = new byte [ 32 ] ; tif ( fis . read ( masterKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tif ( fis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } tmasterKey = hexStringToByteArray ( new String ( hex ) ) ; treturn ; } tSHA256Digest md = new SHA256Digest ( ) ; tbyte [ ] buffer = new byte [ 2048 ] ; tint offset = 0 ; ttry { twhile ( true ) { tint bytesRead = fis . read ( buffer , 0 , 2048 ) ; tif ( bytesRead = = - 1 ) break ; md.doFinal(masterKey, 0); } 
public static byte [ ] hexStringToByteArray ( String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / 2 ] ; for ( int i = 0 ; i < len ; i + = 2 ) { data [ i / 2 ] = ( byte ) ( ( Character . digit ( s . charAt ( i ) , 16 ) < < 4 ) + Character . digit ( s . charAt ( i + 1 ) , 16 ) ) ; } return data ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tIntent i = new Intent ( this , PasswordActivity . class ) ; tstartActivityForResult ( i , 0 ) ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tif ( resultCode = = 0 ) { tfinish ( ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tIntent i = new Intent ( this , FileSelectActivity . class ) ; tstartActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , String fileName ) throws FileNotFoundException { tLaunch ( act , fileName , " " ) ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) throws FileNotFoundException { tFile dbFile = new File ( fileName ) ; tif ( ! dbFile . exists ( ) ) { tthrow new FileNotFoundException ( ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tif ( resultCode = = KeePass . EXIT_LOCK ) { tsetResult ( KeePass . EXIT_LOCK ) ; tfinish ( ) ; } tDatabase . clear ( ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tIntent i = getIntent ( ) ; tmFileName = i . getStringExtra ( KEY_FILENAME ) ; tmKeyFile = i . getStringExtra ( KEY_KEYFILE ) ; tsetContentView ( R . layout . password ) ; tpopulateView ( ) ; tButton confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; tconfirmButton . setOnClickListener ( new ClickHandler ( this ) ) ; } 
private void populateView ( ) { tsetEditText ( R . id . pass_filename , mFileName ) ; tsetEditText ( R . id . pass_keyfile , mKeyFile ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } ttry { tString fileName = getEditText ( R . id . pass_filename ) ; 
private void saveFileData ( String fileName , String key ) { tFileDbHelper db = new FileDbHelper ( this ) ; tdb . open ( ) ; tdb . createFile ( fileName , key ) ; tdb . close ( ) ; } 
public void onCreate ( SQLiteDatabase db ) { tdb . execSQL ( DATABASE_CREATE ) ; ContentValues vals = new ContentValues(); 
private void deletePrefs ( SharedPreferences prefs ) { SharedPreferences.Editor editor = prefs.edit(); 
public FileDbHelper open ( ) throws SQLException { tmDbHelper = new DatabaseHelper ( mCtx ) ; tmDb = mDbHelper . getWritableDatabase ( ) ; treturn this ; } 
public Cursor fetchAllFiles ( ) { tCursor ret ; tret = mDb . query ( FILE_TABLE , new String [ ] { KEY_FILE_ID , KEY_FILE_FILENAME , KEY_FILE_KEYFILE } , null , null , null , null , KEY_FILE_UPDATED + " DESC " , Integer . toString ( MAX_FILES ) ) ; treturn ret ; } 
public Cursor fetchFile ( long fileId ) throws SQLException { tCursor cursor = mDb . query ( true , FILE_TABLE , new String [ ] { KEY_FILE_FILENAME , KEY_FILE_KEYFILE } , tKEY_FILE_ID + " = " + fileId , null , null , null , null , null ) ; tif ( cursor ! = null ) { tcursor . moveToFirst ( ) ; } treturn cursor ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . file_selection ) ; tButton openButton = ( Button ) findViewById ( R . id . file_button ) ; topenButton . setOnClickListener ( new ClickHandler ( this ) ) ; tmDbHelper = new FileDbHelper ( this ) ; tmDbHelper . open ( ) ; tfillData ( ) ; 
private void fillData ( ) { } 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tsuper . onListItemClick ( l , v , position , id ) ; tCursor cursor = mDbHelper . fetchFile ( id ) ; tstartManagingCursor ( cursor ) ; tString fileName = cursor . getString ( cursor . getColumnIndexOrThrow ( FileDbHelper . KEY_FILE_FILENAME ) ) ; tString keyFile = cursor . getString ( cursor . getColumnIndexOrThrow ( FileDbHelper . KEY_FILE_KEYFILE ) ) ; ttry { tPasswordActivity . Launch ( this , fileName , keyFile ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; } 
public void onClick ( View v ) { tString fileName = Util . getEditText ( mAct , R . id . file_filename ) ; ttry { tPasswordActivity . Launch ( mAct , fileName ) ; 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tsuper . onListItemClick ( l , v , position , id ) ; tint size = mGroup . childGroups . size ( ) ; tif ( position < size ) { tPwGroup group = ( PwGroup ) mGroup . childGroups . elementAt ( position ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . list ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tif ( id = = - 1 ) { tmGroup = Database . gRoot ; } else { tWeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; tmGroup = wPw . get ( ) ; } tassert ( mGroup ! = null ) ; tsetGroupTitle ( ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; tgetListView ( ) . setTextFilterEnabled ( true ) ; 
private View createGroupView ( int position , View convertView ) { tPwGroupView gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; } 
public static Test suite ( ) { return new TestSuiteBuilder ( AllTests . class ) . includeAllPackagesUnderHere ( ) 
public void testReadWriteInt ( ) { tbyte [ ] orig = new byte [ 8 ] ; tbyte [ ] dest = new byte [ 8 ] ; tfor ( int i = 0 ; i < 4 ; i + + ) { torig [ i ] = 0 ; } tfor ( int i = 4 ; i < 8 ; i + + ) { torig [ 4 ] = Byte . MAX_VALUE ; } tint one = Types . readInt ( orig , 0 ) ; tint two = Types . readInt ( orig , 4 ) ; tTypes . writeInt ( one , dest , 0 ) ; tTypes . writeInt ( two , dest , 4 ) ; tassertArrayEquals ( orig , dest ) ; 
public IBinder onBind ( Intent intent ) { } 
public void startTimeout ( long seconds ) { tmTimer . schedule ( new TimeoutTask ( ) , seconds ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tstartService ( new Intent ( getContext ( ) , TimeoutService . class ) ) ; tmService = getService ( ) ; tassertNotNull ( mService ) ; } 
public void testTimeout ( ) { tassertFalse ( " Timeout is not set at the beginning. " , mService . HasTimedOut ( ) ) ; tmService . startTimeout ( 1000 ) ; tassertFalse ( " Timeout too early. " , mService . HasTimedOut ( ) ) ; ttry { tThread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { tassertTrue ( " Thread interrupted. " , false ) ; } tassertTrue ( " Timeout was not set. " , mService . HasTimedOut ( ) ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tstartService ( new Intent ( this , TimeoutService . class ) ) ; 
tprotected void onStart ( ) { tsuper . onStart ( ) ; tstartFileSelect ( ) ; } 
private void startFileSelect ( ) { tIntent intent = new Intent ( this , FileSelectActivity . class ) ; tstartActivityForResult ( intent , 0 ) ; } 
tprotected void onDestroy ( ) { tsuper . onDestroy ( ) ; tstopService ( new Intent ( this , TimeoutService . class ) ) ; } 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( TimeoutIntents . LOCK ) ) { tDatabase . clear ( ) ; 
public void cleanUp ( ) { tmAct . unregisterReceiver ( mIntentReceiver ) ; } 
public void startTimeout ( ) { tmAct . sendBroadcast ( new Intent ( TimeoutIntents . START ) ) ; } 
public void stopTimeout ( ) { tmAct . sendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tmLM = new LockManager ( this ) ; } 
tprotected void onDestroy ( ) { tmLM . cleanUp ( ) ; tsuper . onDestroy ( ) ; } 
tprotected void onPause ( ) { tsuper . onPause ( ) ; tmLM . startTimeout ( ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tmLM . stopTimeout ( ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
tprotected void onPause ( ) { tsuper . onPause ( ) ; tsendBroadcast ( new Intent ( TimeoutIntents . START ) ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tsendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tmIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( TimeoutIntents . START ) ) { tstartTimeout ( DEFAULT_TIMEOUT ) ; } else if ( action . equals ( TimeoutIntents . CANCEL ) ) { tcancel ( ) ; } } } ; tIntentFilter filter = new IntentFilter ( ) ; tfilter . addAction ( TimeoutIntents . START ) ; tfilter . addAction ( TimeoutIntents . CANCEL ) ; tregisterReceiver ( mIntentReceiver , filter ) ; 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( TimeoutIntents . START ) ) { tstartTimeout ( DEFAULT_TIMEOUT ) ; 
public void onDestroy ( ) { tsuper . onDestroy ( ) ; tunregisterReceiver ( mIntentReceiver ) ; } 
public void run ( ) { ttimeout = true ; tsendBroadcast ( new Intent ( TimeoutIntents . LOCK ) ) ; } 
public void startTimeout ( long milliseconds ) { tmTimer = new Timer ( ) ; tmTimer . schedule ( new TimeoutTask ( ) , milliseconds ) ; } 
public void cancel ( ) { tif ( mTimer ! = null ) { tmTimer . cancel ( ) ; } ttimeout = false ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , getString ( R . string . MaskedPassword ) ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; tTextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; tcomment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; tcomment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . list ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tif ( id = = - 1 ) { tmGroup = Database . gRoot ; } else { tWeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; tmGroup = wPw . get ( ) ; } tassert ( mGroup ! = null ) ; tsetGroupTitle ( ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; tListView lv = getListView ( ) ; tlv . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; tlv . setTextFilterEnabled ( true ) ; 
private void timeoutCopyToClipboard ( String text ) { tUtil . copyToClipboard ( this , text ) ; tmTimer . schedule ( new ClearClipboardTask ( this , text ) , CLIP_CLEAR_TIME ) ; } 
private void uiClearClipToast ( ) { tToast . makeText ( this , R . string . ClearClipboard , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void run ( ) { tString currentClip = Util . getClipboard ( mCtx ) ; tif ( currentClip . equals ( mClearText ) ) { tUtil . copyToClipboard ( mCtx , " " ) ; 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; tmPd = ProgressDialog . show ( mAct , " Working... " , " Loading database " , true , false ) ; tThread bkgLoad = new Thread ( new BackgroundLoad ( fileName , pass , key ) ) ; tbkgLoad . start ( ) ; 
public void run ( ) { tmPd . dismiss ( ) ; tif ( mMsg . length ( ) > 0 ) { tToast . makeText ( PasswordActivity . this , mMsg , Toast . LENGTH_LONG ) . show ( ) ; } tif ( mLaunch ) { tGroupActivity . Launch ( PasswordActivity . this , null ) ; 
public void run ( ) { ttry { tDatabase . LoadData ( mFileName , mPass , mKey ) ; 
public void run ( ) { tToast . makeText ( mCtx , mText , Toast . LENGTH_LONG ) . show ( ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; tmenu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; treturn true ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , getString ( R . string . MaskedPassword ) ) ; tDateFormat df = DateFormat . getInstance ( ) ; tString date = df . format ( mEntry . tCreation ) ; tpopulateText ( R . id . entry_created , date ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; tTextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; tcomment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; tcomment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
public void saveDatabase ( PwManager manager , OutputStream outStream ) { } } 
public void output ( ) throws IOException { } 
public void output ( ) throws IOException { } 
public static long readUInt ( byte buf [ ] , int offset ) { int firstByte = 0 ; int secondByte = 0 ; int thirdByte = 0 ; int fourthByte = 0 ; firstByte = ( 0x000000FF & ( ( int ) buf [ offset ] ) ) ; secondByte = ( 0x000000FF & ( ( int ) buf [ offset + 1 ] ) ) ; thirdByte = ( 0x000000FF & ( ( int ) buf [ offset + 2 ] ) ) ; fourthByte = ( 0x000000FF & ( ( int ) buf [ offset + 3 ] ) ) ; return ( ( long ) ( firstByte < < 24 | secondByte < < 16 
public static byte [ ] writeUInt ( long val ) { tbyte [ ] buf = new byte [ 4 ] ; tbuf [ 0 ] = ( byte ) ( ( val & 0xFF000000L ) > > 24 ) ; tbuf [ 1 ] = ( byte ) ( ( val & 0x00FF0000L ) > > 16 ) ; tbuf [ 2 ] = ( byte ) ( ( val & 0x0000FF00L ) > > 8 ) ; tbuf [ 3 ] = ( byte ) ( val & 0x000000FFL ) ; treturn buf ; } 
public static byte [ ] writeInt ( int val ) { byte [ ] buf = new byte [ 4 ] ; writeInt ( val , buf , 0 ) ; return buf ; } 
public static void writeShort ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0xFF ) ; buf [ offset + 1 ] = ( byte ) ( ( val > > > 8 ) & 0xFF ) ; } 
public static byte [ ] writeShort ( int val ) { byte [ ] buf = new byte [ 2 ] ; writeShort ( val , buf , 0 ) ; return buf ; } 
public static void writeUByte ( int val , byte [ ] buf , int offset ) { buf [ offset ] = ( byte ) ( val & 0xFF ) ; } 
public static byte [ ] writeUByte ( int val ) { byte [ ] buf = new byte [ 2 ] ; writeUByte ( val , buf , 0 ) ; return buf ; } 
public static Date readTime ( byte [ ] buf , int offset ) { int dw1 = readUByte ( buf , offset ) ; int dw2 = readUByte ( buf , offset + 1 ) ; int dw3 = readUByte ( buf , offset + 2 ) ; int dw4 = readUByte ( buf , offset + 3 ) ; int dw5 = readUByte ( buf , offset + 4 ) ; Unpack 5 byte structure to date and time int year = (dw1 << 6) | (dw2 >> 2); int month = ((dw2 & 0x00000003) << 2) | (dw3 >> 6); int day = (dw3 >> 1) & 0x0000001F; int hour = ((dw3 & 0x00000001) << 4) | (dw4 >> 4); int minute = ((dw4 & 0x0000000F) << 2) | (dw5 >> 6); int second = dw5 & 0x0000003F; Calendar time = Calendar.getInstance(); time.set( year, month, day, hour, minute, second ); return time.getTime(); 
public static byte [ ] writeTime ( Date date ) { byte [ ] buf = new byte [ 5 ] ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; int month = cal . get ( Calendar . MONTH ) ; int day = cal . get ( Calendar . DAY_OF_MONTH ) ; int hour = cal . get ( Calendar . HOUR_OF_DAY ) ; int minute = cal . get ( Calendar . MINUTE ) ; int second = cal . get ( Calendar . SECOND ) ; buf [ 0 ] = ( byte ) ( ( year > > 6 ) & 0x0000003F ) ; buf [ 1 ] = ( byte ) ( ( ( year & 0x0000003F ) < < 2 ) | ( ( month > > 2 ) & 3 ) ) ; buf [ 2 ] = ( byte ) ( ( ( month & 0x00000003 ) < < 6 ) | ( ( day & 0x0000001F ) < < 1 ) | ( ( hour > > 4 ) & 0x00000001 ) ) ; buf [ 3 ] = ( byte ) ( ( ( hour & 0x0000000F ) < < 4 ) | ( ( minute > > 2 ) & 0x0000000F ) ) ; buf [ 4 ] = ( byte ) ( ( ( minute & 0x00000003 ) < < 6 ) | ( second & 0x0000003F ) ) ; return buf ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tmPE = TestData . GetTest1 ( ) . entries . get ( 0 ) ; 
public void testName ( ) { tassertTrue ( " Name was " + mPE . title , mPE . title . equals ( " Amazon " ) ) ; } 
public void testPassword ( ) throws UnsupportedEncodingException { tString sPass = " 12345 " ; tbyte [ ] password = sPass . getBytes ( " UTF-8 " ) ; tassertArrayEquals ( password , mPE . getPassword ( ) ) ; } 
public void testCreation ( ) { tCalendar cal = Calendar . getInstance ( ) ; tcal . setTime ( mPE . tCreation ) ; tassertTrue ( " Incorrect year. " , cal . get ( Calendar . YEAR ) = = 2009 ) ; tassertTrue ( " Incorrect month. " , cal . get ( Calendar . MONTH ) = = 4 ) ; tassertTrue ( " Incorrect day. " , cal . get ( Calendar . DAY_OF_MONTH ) = = 23 ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tmPM = TestData . GetTest1 ( ) ; 
public void testPlainContent ( ) throws IOException { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; assertEquals("Difference at byte " + i, mPM.postHeader[i], buf[i]); 
public void testChecksum ( ) throws NoSuchAlgorithmException , IOException { tFileOutputStream fos = new FileOutputStream ( " /dev/null " ) ; tMessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; tDigestOutputStream dos = new DigestOutputStream ( fos , md ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tmPG = TestData . GetTest1 ( ) . groups . get ( 0 ) ; 
public void testGroupName ( ) { assertTrue ( " Name was " + mPG . name , mPG . name . equals ( " Internet " ) ) ; } 
public static PwManager GetTest1 ( ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tif ( test1 = = null ) { tFileInputStream fis = new FileInputStream ( " /sdcard/test1.kdb " ) ; tImporterV3 importer = new ImporterV3 ( ) ; ttest1 = importer . openDatabase ( fis , " 12345 " , " " ) ; tif ( test1 ! = null ) { ttest1 . constructTree ( null ) ; } } treturn test1 ; } 
public void testReadWriteIntZero ( ) { ttestReadWriteInt ( ( byte ) 0 ) ; } 
public void testReadWriteIntMin ( ) { ttestReadWriteInt ( Byte . MIN_VALUE ) ; } 
public void testReadWriteIntMax ( ) { ttestReadWriteInt ( Byte . MAX_VALUE ) ; } 
private void testReadWriteInt ( byte value ) { tbyte [ ] orig = new byte [ 4 ] ; tbyte [ ] dest = new byte [ 4 ] ; tfor ( int i = 0 ; i < 4 ; i + + ) { torig [ i ] = 0 ; } tsetArray ( orig , value , 0 , 4 ) ; tint one = Types . readInt ( orig , 0 ) ; tTypes . writeInt ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
public void testReadWriteShortZero ( ) { ttestReadWriteShort ( ( byte ) 0 ) ; } 
public void testReadWriteShortMin ( ) { ttestReadWriteShort ( Byte . MIN_VALUE ) ; } 
public void testReadWriteShortMax ( ) { ttestReadWriteShort ( Byte . MAX_VALUE ) ; } 
private void testReadWriteShort ( byte value ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; tsetArray ( orig , value , 0 , 2 ) ; tint one = Types . readShort ( orig , 0 ) ; tTypes . writeShort ( one , dest , 0 ) ; } 
public void testReadWriteByteZero ( ) { ttestReadWriteByte ( ( byte ) 0 ) ; } 
public void testReadWriteByteMin ( ) { ttestReadWriteByte ( Byte . MIN_VALUE ) ; } 
public void testReadWriteByteMax ( ) { ttestReadWriteShort ( Byte . MAX_VALUE ) ; } 
private void testReadWriteByte ( byte value ) { tbyte [ ] orig = new byte [ 1 ] ; tbyte [ ] dest = new byte [ 1 ] ; tsetArray ( orig , value , 0 , 1 ) ; tint one = Types . readUByte ( orig , 0 ) ; tTypes . writeUByte ( one , dest , 0 ) ; } 
public void output ( ) throws IOException { } 
public static void writeShort ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0x00FF ) ; buf [ offset + 1 ] = ( byte ) ( ( val & 0xFF00 ) > > 8 ) ; } 
public void testReadWriteShortOne ( ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; torig [ 0 ] = 0 ; torig [ 1 ] = 1 ; tint one = Types . readShort ( orig , 0 ) ; tdest = Types . writeShort ( one ) ; tassertArrayEquals ( orig , dest ) ; 
public void output ( ) throws IOException { } 
public void output ( ) throws IOException { } 
public static byte writeUByte ( int val ) { byte [ ] buf = new byte [ 1 ] ; writeUByte ( val , buf , 0 ) ; return buf [ 0 ] ; } 
public static Date readTime ( byte [ ] buf , int offset ) { int dw1 = readUByte ( buf , offset ) ; int dw2 = readUByte ( buf , offset + 1 ) ; int dw3 = readUByte ( buf , offset + 2 ) ; int dw4 = readUByte ( buf , offset + 3 ) ; int dw5 = readUByte ( buf , offset + 4 ) ; Unpack 5 byte structure to date and time int year = (dw1 << 6) | (dw2 >> 2); int month = ((dw2 & 0x00000003) << 2) | (dw3 >> 6); int day = (dw3 >> 1) & 0x0000001F; int hour = ((dw3 & 0x00000001) << 4) | (dw4 >> 4); int minute = ((dw4 & 0x0000000F) << 2) | (dw5 >> 6); int second = dw5 & 0x0000003F; Calendar time = Calendar.getInstance(); File format is a 1 based month, java Calendar uses a zero based month time.set( year, month-1, day, hour, minute, second ); return time.getTime(); 
public static void writeCString ( String str , OutputStream os ) throws IOException { byte [ ] initial = str . getBytes ( " UTF-8 " ) ; int length = initial . length ; os . write ( writeInt ( length + 1 ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; 
public static byte [ ] writeTime ( Date date ) { byte [ ] buf = new byte [ 5 ] ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; buf[1] = writeUByte(((year & 0x0000003F) << 2) | ((month >> 2) & 0x00000003) ); buf[2] = (byte)(((month & 0x00000003) << 6) | ((day & 0x0000001F) << 1) | ((hour >> 4) & 0x00000001)); buf[3] = (byte)(((hour & 0x0000000F) << 4) | ((minute >> 2) & 0x0000000F)); buf[4] = (byte)(((minute & 0x00000003) << 6) | (second & 0x0000003F)); return buf; } 
public void testCreation ( ) { tCalendar cal = Calendar . getInstance ( ) ; tcal . setTime ( mPE . tCreation ) ; tassertEquals ( " Incorrect year. " , cal . get ( Calendar . YEAR ) , 2009 ) ; tassertEquals ( " Incorrect month. " , cal . get ( Calendar . MONTH ) , 3 ) ; tassertEquals ( " Incorrect day. " , cal . get ( Calendar . DAY_OF_MONTH ) , 23 ) ; } 
public void testPlainContent ( ) throws IOException { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; assertEquals("Buf31: " + mPM.postHeader[31] + " Buf32: " + mPM.postHeader[32] + "Buf33: " + mPM.postHeader[33] + " Year: " + cal.get(Calendar.YEAR) + " Month: " + cal.get(Calendar.MONTH) + " Difference at byte " + i, mPM.postHeader[i], buf[i]); 
public void testDate ( ) { tCalendar expected = Calendar . getInstance ( ) ; texpected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; tbyte [ ] buf = Types . writeTime ( expected . getTime ( ) ) ; tCalendar actual = Calendar . getInstance ( ) ; tactual . setTime ( Types . readTime ( buf , 0 ) ) ; tassertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; tassertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; tassertEquals ( " Day mismatch: " , 2 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; tassertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; tassertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; tassertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
public void output ( ) throws IOException { } 
public void output ( ) throws IOException { } 
public void testPlainContent ( ) throws IOException { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; assertArrayEquals(mPM.postHeader, bos.toByteArray()); 
public void output ( ) throws IOException { tmOS . write ( Types . writeInt ( mHeader . signature1 ) ) ; tmOS . write ( Types . writeInt ( mHeader . signature2 ) ) ; tmOS . write ( Types . writeInt ( mHeader . flags ) ) ; tmOS . write ( Types . writeInt ( mHeader . version ) ) ; tmOS . write ( mHeader . masterSeed ) ; tmOS . write ( mHeader . encryptionIV ) ; tmOS . write ( Types . writeInt ( mHeader . numGroups ) ) ; tmOS . write ( Types . writeInt ( mHeader . numEntries ) ) ; tmOS . write ( mHeader . contentsHash ) ; tmOS . write ( mHeader . masterSeed2 ) ; tmOS . write ( Types . writeInt ( mHeader . numKeyEncRounds ) ) ; 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void output ( ) throws IOException { } 
public void outputPlanGroupAndEntries ( OutputStream os ) throws IOException { PwEntry pe = mPM.entries.get(i); 
public void close ( ) throws IOException { tsuper . close ( ) ; tmFile . close ( ) ; } 
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { tsuper . write ( buffer , offset , count ) ; tmFile . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) throws IOException { tsuper . write ( buffer ) ; tmFile . write ( buffer ) ; } 
public void write ( int oneByte ) throws IOException { tmFile . write ( oneByte ) ; } 
public void seek ( long pos ) throws IOException { tmFile . seek ( pos ) ; } 
public static int writeCString ( String str , OutputStream os ) throws IOException { byte [ ] initial = str . getBytes ( " UTF-8 " ) ; int length = initial . length + 1 ; os . write ( writeInt ( length ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; return length ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( ) ; 
public void testPlainContent ( ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , bos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . toByteArray ( ) ) ; 
public void testChecksum ( ) throws NoSuchAlgorithmException , IOException { FileOutputStream fos = new FileOutputStream ( " /dev/null " ) ; MessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; DigestOutputStream dos = new DigestOutputStream ( fos , md ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , dos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( dos ) ; assertArrayEquals ( " Hash of groups and entries failed. " , md . digest ( ) , mPM . dbHeader . contentsHash ) ; } 
public void testHeader ( ) throws Exception { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , PwManagerOutput . DEBUG ) ; pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertArrayEquals ( " Header does not match. " , bExpected . toByteArray ( ) , bActual . toByteArray ( ) ) ; } 
public static PwManager GetTest1 ( ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tif ( test1 = = null ) { tFileInputStream fis = new FileInputStream ( " /sdcard/test1.kdb " ) ; tImporterV3 importer = new ImporterV3 ( ImporterV3 . DEBUG ) ; ttest1 = importer . openDatabase ( fis , " 12345 " , " " ) ; tif ( test1 ! = null ) { ttest1 . constructTree ( null ) ; } } treturn test1 ; } 
public void close ( ) throws PwManagerOutputException { ttry { tmOS . close ( ) ; 
public void output ( ) throws PwManagerOutputException , IOException { tPwDbHeader header = outputHeader ( mOS ) ; /* 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
public static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) { cipher.processBytes (newKey, 0, newKey.length, newKey, 0); Hash once with SHA-256 SHA256Digest md = new SHA256Digest(); md.update(newKey, 0, newKey.length ); newKey = md.digest( newKey ); md.doFinal(newKey, 0); return newKey; } 
public void testPlainContent ( ) throws IOException , PwManagerOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , bos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . toByteArray ( ) ) ; 
public void testChecksum ( ) throws NoSuchAlgorithmException , IOException , PwManagerOutputException { FileOutputStream fos = new FileOutputStream ( " /dev/null " ) ; MessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; DigestOutputStream dos = new DigestOutputStream ( fos , md ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , dos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( dos ) ; assertArrayEquals ( " Hash of groups and entries failed. " , md . digest ( ) , mPM . dbHeader . contentsHash ) ; } 
public void testHeader ( ) throws PwManagerOutputException , IOException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , PwManagerOutput . DEBUG ) ; pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertArrayEquals ( " Header does not match. " , bExpected . toByteArray ( ) , bActual . toByteArray ( ) ) ; } 
public void testFullWrite ( ) throws IOException , PwManagerOutputException { tFile file = new File ( " /sdcard/test1.kdb " ) ; tFileInputStream fis = new FileInputStream ( file ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public abstract CipherParameters generateDerivedParameters ( int keySize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public abstract CipherParameters generateDerivedParameters ( int keySize , int ivSize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public abstract CipherParameters generateDerivedMacParameters ( int keySize ) ; public static byte [ ] PKCS12PasswordToBytes ( char [ ] password ) { if ( password . length > 0 ) { +1 for extra 2 pad bytes. byte[] bytes = new byte[(password.length + 1) * 2]; for (int i = 0; i != password.length; i ++) { bytes[i * 2] = (byte)(password[i] >>> 8); bytes[i * 2 + 1] = (byte)password[i]; } return bytes; } else { return new byte[0]; } }} 
public static byte [ ] PKCS5PasswordToUTF8Bytes ( char [ ] password ) { return Strings . toUTF8ByteArray ( password ) ; } 
public int padCount ( byte [ ] in ) throws InvalidCipherTextException { int count = in [ in . length - 1 ] & 0xff ; if ( count > in . length | | count = = 0 ) { throw new InvalidCipherTextException ( " pad block corrupted " ) ; } for ( int i = 1 ; i < = count ; i + + ) { if ( in [ in . length - i ] ! = count ) { throw new InvalidCipherTextException ( " pad block corrupted " ) ; } } return count ; } 
public int doFinal ( byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException , InvalidCipherTextException { int blockSize = cipher . getBlockSize ( ) ; int resultLen = 0 ; if ( forEncryption ) { if ( bufOff = = blockSize ) { if ( ( outOff + 2 * blockSize ) > out . length ) { reset ( ) ; throw new DataLengthException ( " output buffer too short " ) ; } resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; bufOff = 0 ; } padding . addPadding ( buf , bufOff ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff + resultLen ) ; reset ( ) ; } else { if ( bufOff = = blockSize ) { resultLen = cipher . processBlock ( buf , 0 , buf , 0 ) ; bufOff = 0 ; } else { reset ( ) ; throw new DataLengthException ( " last block incomplete in decryption " ) ; } try { resultLen - = padding . padCount ( buf ) ; System . arraycopy ( buf , 0 , out , outOff , resultLen ) ; } finally { reset ( ) ; } } return resultLen ; } 
private void cycleSeed ( ) { digestUpdate ( seed ) ; digestAddCounter ( seedCounter + + ) ; digestDoFinal ( seed ) ; } 
private void generateState ( ) { digestAddCounter ( stateCounter + + ) ; digestUpdate ( state ) ; digestUpdate ( seed ) ; digestDoFinal ( state ) ; if ( ( stateCounter % CYCLE_COUNT ) = = 0 ) { 
private void digestAddCounter ( long seed ) { for ( int i = 0 ; i ! = 8 ; i + + ) { 
public static boolean areEqual ( boolean [ ] a , boolean [ ] b ) { if ( a = = b ) { return true ; } if ( a = = null | | b = = null ) { return false ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i ! = a . length ; i + + ) { if ( a [ i ] ! = b [ i ] ) { return false ; } } return true ; } 
public static boolean areEqual ( byte [ ] a , byte [ ] b ) { if ( a = = b ) { return true ; } if ( a = = null | | b = = null ) { return false ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i ! = a . length ; i + + ) { if ( a [ i ] ! = b [ i ] ) { return false ; } } return true ; } 
public static boolean areEqual ( int [ ] a , int [ ] b ) { if ( a = = b ) { return true ; } if ( a = = null | | b = = null ) { return false ; } if ( a . length ! = b . length ) { return false ; } for ( int i = 0 ; i ! = a . length ; i + + ) { if ( a [ i ] ! = b [ i ] ) { return false ; } } return true ; } 
public static int hashCode ( byte [ ] data ) { if ( data = = null ) { return 0 ; } int i = data . length ; int hc = i + 1 ; while ( - - i > = 0 ) { hc * = 257 ; hc ^ = data [ i ] ; } return hc ; } 
public static byte [ ] clone ( byte [ ] data ) { if ( data = = null ) { return null ; } byte [ ] copy = new byte [ data . length ] ; System . arraycopy ( data , 0 , copy , 0 , data . length ) ; return copy ; } 
public static int [ ] clone ( int [ ] data ) { if ( data = = null ) { return null ; } int [ ] copy = new int [ data . length ] ; System . arraycopy ( data , 0 , copy , 0 , data . length ) ; return copy ; } 
public static String fromUTF8ByteArray ( byte [ ] bytes ) { int i = 0 ; int length = 0 ; while ( i < bytes . length ) { length + + ; if ( ( bytes [ i ] & 0xf0 ) = = 0xf0 ) { surrogate pair length++; i += 4; } else if ((bytes[i] & 0xe0) == 0xe0) { i += 3; } else if ((bytes[i] & 0xc0) == 0xc0) { i += 2; } else { i += 1; } } char[] cs = new char[length]; i = 0; length = 0; while (i < bytes.length) { char ch; if ((bytes[i] & 0xf0) == 0xf0) { int codePoint = ((bytes[i] & 0x03) << 18) | ((bytes[i+1] & 0x3F) << 12) | ((bytes[i+2] & 0x3F) << 6) | (bytes[i+3] & 0x3F); int U = codePoint - 0x10000; char W1 = (char)(0xD800 | (U >> 10)); char W2 = (char)(0xDC00 | (U & 0x3FF)); cs[length++] = W1; ch = W2; i += 4; } else if ((bytes[i] & 0xe0) == 0xe0) { ch = (char)(((bytes[i] & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)); i += 3; } else if ((bytes[i] & 0xd0) == 0xd0) { ch = (char)(((bytes[i] & 0x1f) << 6) | (bytes[i + 1] & 0x3f)); i += 2; } else if ((bytes[i] & 0xc0) == 0xc0) { ch = (char)(((bytes[i] & 0x1f) << 6) | (bytes[i + 1] & 0x3f)); i += 2; } else { ch = (char)(bytes[i] & 0xff); i += 1; } cs[length++] = ch; } return new String(cs); } 
public static byte [ ] toUTF8ByteArray ( String string ) { return toUTF8ByteArray ( string . toCharArray ( ) ) ; } 
public static byte [ ] toUTF8ByteArray ( char [ ] string ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; char [ ] c = string ; int i = 0 ; while ( i < c . length ) { char ch = c [ i ] ; if ( ch < 0x0080 ) { bOut . write ( ch ) ; } else if ( ch < 0x0800 ) { bOut . write ( 0xc0 | ( ch > > 6 ) ) ; bOut . write ( 0x80 | ( ch & 0x3f ) ) ; } surrogate pair else if (ch >= 0xD800 && ch <= 0xDFFF) { in error - can only happen, if the Java String class has a bug. if (i + 1 >= c.length) { throw new IllegalStateException("invalid UTF-16 codepoint"); } char W1 = ch; ch = c[++i]; char W2 = ch; in error - can only happen, if the Java String class has a bug. if (W1 > 0xDBFF) { throw new IllegalStateException("invalid UTF-16 codepoint"); } int codePoint = (((W1 & 0x03FF) << 10) | (W2 & 0x03FF)) + 0x10000; bOut.write(0xf0 | (codePoint >> 18)); bOut.write(0x80 | ((codePoint >> 12) & 0x3F)); bOut.write(0x80 | ((codePoint >> 6) & 0x3F)); bOut.write(0x80 | (codePoint & 0x3F)); } else { bOut.write(0xe0 | (ch >> 12)); bOut.write(0x80 | ((ch >> 6) & 0x3F)); bOut.write(0x80 | (ch & 0x3F)); } i++; } return bOut.toByteArray(); } 
public static String toUpperCase ( String string ) { boolean changed = false ; char [ ] chars = string . toCharArray ( ) ; for ( int i = 0 ; i ! = chars . length ; i + + ) { char ch = chars [ i ] ; if ( 'a' < = ch & & 'z' > = ch ) { changed = true ; chars [ i ] = ( char ) ( ch - 'a' + 'A' ) ; } } if ( changed ) { return new String ( chars ) ; } return string ; } 
public static String toLowerCase ( String string ) { boolean changed = false ; char [ ] chars = string . toCharArray ( ) ; for ( int i = 0 ; i ! = chars . length ; i + + ) { char ch = chars [ i ] ; if ( 'A' < = ch & & 'Z' > = ch ) { changed = true ; chars [ i ] = ( char ) ( ch - 'A' + 'a' ) ; } } if ( changed ) { return new String ( chars ) ; } return string ; } 
public static byte [ ] toByteArray ( String string ) { byte [ ] bytes = new byte [ string . length ( ) ] ; for ( int i = 0 ; i ! = bytes . length ; i + + ) { char ch = string . charAt ( i ) ; bytes [ i ] = ( byte ) ch ; } return bytes ; } 
public static String [ ] split ( String input , char delimiter ) { Vector v = new Vector ( ) ; boolean moreTokens = true ; String subString ; while ( moreTokens ) { int tokenLocation = input . indexOf ( delimiter ) ; if ( tokenLocation > 0 ) { subString = input . substring ( 0 , tokenLocation ) ; v . addElement ( subString ) ; input = input . substring ( tokenLocation + 1 ) ; } else { moreTokens = false ; v . addElement ( input ) ; } } String [ ] res = new String [ v . size ( ) ] ; for ( int i = 0 ; i ! = res . length ; i + + ) { res [ i ] = ( String ) v . elementAt ( i ) ; } return res ; } 
public static void LoadData ( String filename , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tImporterV3 Importer = new ImporterV3 ( ImporterV3 . DEBUG ) ; mPM.constructTree(null); 
public void run ( ) { tmPd . dismiss ( ) ; GroupActivity.Launch(PasswordActivity.this, null); 
public void output ( ) throws IOException { } 
public byte [ ] getFinalKey ( PwDbHeader header ) throws PwManagerOutputException { 
public void output ( ) throws PwManagerOutputException , IOException { tPwDbHeader header = outputHeader ( mOS ) ; tbyte [ ] finalKey = getFinalKey ( header ) ; tCipher cipher ; ttry { tcipher = Cipher . getInstance ( " AES/CBC/PKCS5Padding " ) ; } catch ( Exception e ) { tthrow new PwManagerOutputException ( " Algorithm not supported. " ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( mPM . finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
public static byte [ ] makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , byte [ ] masterKey , int numRounds ) { byte [ ] transformedMasterKey = transformMasterKey ( masterSeed2 , masterKey , numRounds ) ; return finalKey; } 
public static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) { cipher.processBytes (newKey, 0, newKey.length, newKey, 0); Hash once with SHA-256 SHA256Digest md = new SHA256Digest(); md.update(newKey, 0, newKey.length ); newKey = md.digest( newKey ); md.doFinal(newKey, 0); return newKey; } 
public void testPlainContent ( ) throws IOException , PwManagerOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , bos , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . toByteArray ( ) ) ; 
public void testChecksum ( ) throws NoSuchAlgorithmException , IOException , PwManagerOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwManagerOutput pos = new PwManagerOutput(mPM, dos, PwManagerOutput.DEBUG); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
private void assertHeadersEquals ( PwDbHeader expected , PwDbHeader actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . masterSeed2 , actual . masterSeed2 ) ; } 
public void testHeader ( ) throws PwManagerOutputException , IOException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , PwManagerOutput . DEBUG ) ; PwDbHeader header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . toByteArray ( ) , bActual . toByteArray ( ) ) ; } 
public void testFinalKey ( ) throws PwManagerOutputException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , PwManagerOutput . DEBUG ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey2 ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void testFullWrite ( ) throws IOException , PwManagerOutputException { tFile file = new File ( " /sdcard/test1.kdb " ) ; tFileInputStream fis = new FileInputStream ( file ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public void close ( ) throws IOException { tbyte [ ] block = new byte [ 2 * mCipher . getBlockSize ( ) ] ; tint bytes ; ttry { tbytes = mCipher . doFinal ( block , 0 ) ; } catch ( DataLengthException e ) { tthrow new IOException ( e . getMessage ( ) ) ; } catch ( IllegalStateException e ) { tthrow new IOException ( " IllegalStateException. " ) ; } catch ( InvalidCipherTextException e ) { tthrow new IOException ( " InvalidCipherText. " ) ; } tif ( bytes > 0 ) { tmOS . write ( block , 0 , bytes ) ; 
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { tint outputLen = mCipher . getUpdateOutputSize ( count ) ; tif ( outputLen > 0 ) { tbyte [ ] block = new byte [ outputLen ] ; 
public void write ( byte [ ] buffer ) throws IOException { tint length = buffer . length ; tint outputLen = mCipher . getUpdateOutputSize ( length ) ; tif ( outputLen > 0 ) { tbyte [ ] block = new byte [ outputLen ] ; 
public void write ( int oneByte ) throws IOException { tint outputLen = mCipher . getUpdateOutputSize ( 1 ) ; tif ( outputLen > 0 ) { tbyte [ ] block = new byte [ outputLen ] ; 
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { tsuper . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) throws IOException { tsuper . write ( buffer ) ; } 
public byte [ ] getFinalKey ( PwDbHeader header ) throws PwManagerOutputException { ttry { treturn ImporterV3 . makeFinalKey ( header . masterSeed , header . masterSeed2 , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public byte [ ] getFinalKey2 ( PwDbHeader header ) throws PwManagerOutputException { ttry { treturn ImporterV3 . makeFinalKey ( header . masterSeed , header . masterSeed2 , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public void output ( ) throws PwManagerOutputException , IOException { tPwDbHeader header = outputHeader ( mOS ) ; tbyte [ ] finalKey = getFinalKey ( header ) ; tCipher cipher ; ttry { tcipher = Cipher . getInstance ( " AES/CBC/PKCS5Padding " ) ; } catch ( Exception e ) { tthrow new PwManagerOutputException ( " Algorithm not supported. " ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
public static byte [ ] makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , byte [ ] masterKey , int numRounds ) throws IOException { return md.digest(); } 
public static void LoadData ( String filename , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tImporterV3 Importer = new ImporterV3 ( ImporterV3 . DEBUG ) ; } 
public static void SaveData ( ) throws IOException , PwManagerOutputException { tSaveData ( mFilename ) ; } 
public static void SaveData ( String filename ) throws IOException , PwManagerOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; tPwManagerOutput pmo = new PwManagerOutput ( mPM , fos ) ; tpmo . output ( ) ; tfos . close ( ) ; tFile orig = new File ( filename ) ; torig . delete ( ) ; tif ( ! tempFile . renameTo ( orig ) ) { tthrow new IOException ( " Failed to store database. " ) ; } tmFilename = filename ; 
public static void clear ( ) { tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . entry_view ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tIntent i = getIntent ( ) ; tUUID uuid = UUID . nameUUIDFromBytes ( i . getByteArrayExtra ( KEY_ENTRY ) ) ; tassert ( uuid ! = null ) ; tmEntry = Database . gEntries . get ( uuid ) . get ( ) ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , getString ( R . string . MaskedPassword ) ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . tCreation ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . tLastMod ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . tLastAccess ) ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; tTextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; tcomment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; tcomment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
public void output ( ) throws PwManagerOutputException , IOException { tPwDbHeader header = outputHeader ( mOS ) ; tbyte [ ] finalKey = getFinalKey ( header ) ; tCipher cipher ; ttry { tcipher = Cipher . getInstance ( " AES/CBC/PKCS5Padding " ) ; } catch ( Exception e ) { tthrow new PwManagerOutputException ( " Algorithm not supported. " ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
public static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException 
public void testDatabase ( ) { ttry { tDatabase . LoadData ( " /sdcard/test1.kdb " , " 12345 " , " " ) ; 
public void onClick ( View v ) { tEntryEditActivity . Launch ( EntryActivity . this , mEntry ) ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , new String ( mEntry . getPassword ( ) ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . tCreation ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . tLastMod ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . tLastAccess ) ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; tTextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; tcomment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; tcomment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
public static void Launch ( Activity act , PwEntry pw ) { tIntent i = new Intent ( act , EntryEditActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; tact . startActivity ( i ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; treturn true ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; tTextView comment = ( TextView ) findViewById ( R . id . entry_comment ) ; tcomment . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; tcomment . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; 
public static void LoadData ( String filename , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tImporterV3 Importer = new ImporterV3 ( ) ; tmPM = Importer . openDatabase ( fis , password , keyfile ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tmFilename = filename ; } 
public static void UpdateEntry ( PwEntry oldE , PwEntry newE ) throws IOException , PwManagerOutputException { toldE . assign ( newE ) ; tSaveData ( ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
private void writeDate ( byte [ ] type , byte [ ] date ) throws IOException { tmOS . write ( type ) ; tmOS . write ( DATE_FIELD_SIZE ) ; tif ( date ! = null ) { tmOS . write ( date ) ; 
public void assign ( PwEntry source ) { uuid = source . uuid ; groupId = source . groupId ; imageId = source . imageId ; title = source . title ; url = source . url ; username = source . username ; password = source . password ; additional = source . additional ; tCreation = source . tCreation ; tLastMod = source . tLastMod ; tLastAccess = source . tLastAccess ; tExpire = source . tExpire ; binaryDesc = source . binaryDesc ; binaryData = source . binaryData ; } 
public static byte [ ] writeTime ( Date date ) { if ( date = = null ) { return null ; } byte [ ] buf = new byte [ 5 ] ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; buf[1] = writeUByte(((year & 0x0000003F) << 2) | ((month >> 2) & 0x00000003) ); buf[2] = (byte)(((month & 0x00000003) << 6) | ((day & 0x0000001F) << 1) | ((hour >> 4) & 0x00000001)); buf[3] = (byte)(((hour & 0x0000000F) << 4) | ((minute >> 2) & 0x0000000F)); buf[4] = (byte)(((minute & 0x00000003) << 6) | (second & 0x0000003F)); return buf; } 
public static int writeCString ( String str , OutputStream os ) throws IOException { if ( str = = null ) { return 0 ; } byte [ ] initial = str . getBytes ( " UTF-8 " ) ; int length = initial . length + 1 ; os . write ( writeInt ( length ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; return length ; } 
public static void UpdateEntry ( PwEntry oldE , PwEntry newE ) throws IOException , PwManagerOutputException { tif ( ! oldE . title . equals ( newE . title ) ) { tPwGroup parent = oldE . parent ; tif ( parent ! = null ) { tgDirty . put ( parent , new WeakReference < PwGroup > ( parent ) ) ; } } toldE . assign ( newE ) ; tSaveData ( ) ; } 
public static void Launch ( Activity act , PwEntry pw , int pos ) { tIntent i = new Intent ( act , EntryActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; ti . putExtra ( KEY_REFRESH_POS , pos ) ; tact . startActivityForResult ( i , 0 ) ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tif ( resultCode = = KeePass . EXIT_REFRESH | | resultCode = = KeePass . EXIT_REFRESH_TITLE ) { tfillData ( ) ; 
public static void Launch ( Activity act , PwEntry pw ) { tIntent i = new Intent ( act , EntryEditActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; bkgStore.start(); 
public void run ( ) { ttry { tDatabase . UpdateEntry ( mOld , mNew ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tif ( Database . gDirty . get ( mGroup ) ! = null ) { tDatabase . gDirty . remove ( mGroup ) ; 
public static void Launch ( Activity act , String fileName , String keyFile ) throws FileNotFoundException { tFile dbFile = new File ( fileName ) ; tif ( ! dbFile . exists ( ) ) { tthrow new FileNotFoundException ( ) ; } tIntent i = new Intent ( act , PasswordActivity . class ) ; ti . putExtra ( KEY_FILENAME , fileName ) ; ti . putExtra ( KEY_KEYFILE , keyFile ) ; tact . startActivityForResult ( i , 0 ) ; 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , new String ( mEntry . getPassword ( ) ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . tCreation ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . tLastMod ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . tLastAccess ) ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
public static void NewEntry ( PwEntry entry ) throws IOException , PwManagerOutputException { tPwGroup parent = entry . parent ; 
public static void UpdateEntry ( PwEntry oldE , PwEntry newE ) throws IOException , PwManagerOutputException { tif ( ! oldE . title . equals ( newE . title ) ) { tPwGroup parent = oldE . parent ; tif ( parent ! = null ) { } 
public static void Launch ( Activity act , PwEntry pw ) { tIntent i = new Intent ( act , EntryEditActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; tact . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroup parent ) { tIntent i = new Intent ( act , EntryEditActivity . class ) ; ti . putExtra ( KEY_PARENT , parent . groupId ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; bkgStore.start(); 
public static void Launch ( Activity act , PwGroup group ) { tIntent i = new Intent ( act , GroupActivity . class ) ; tif ( group ! = null ) { ti . putExtra ( KEY_ENTRY , group . groupId ) ; } tact . startActivityForResult ( i , 0 ) ; } 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tsuper . onListItemClick ( l , v , position , id ) ; tListAdapter adapt = getListAdapter ( ) ; tClickView cv = ( ClickView ) adapt . getView ( position , null , null ) ; tcv . onClick ( ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . group_view_only ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tif ( id = = - 1 ) { tmGroup = Database . gRoot ; } else { tWeakReference < PwGroup > wPw = Database . gGroups . get ( id ) ; tmGroup = wPw . get ( ) ; } tassert ( mGroup ! = null ) ; tsetGroupTitle ( ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; tstyleScrollBars ( ) ; 
tprotected void styleScrollBars ( ) { tListView lv = getListView ( ) ; tlv . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; tlv . setTextFilterEnabled ( true ) ; 
public static void Launch ( Activity act , PwGroup group ) { tIntent i = new Intent ( act , GroupAddEntryActivity . class ) ; ti . putExtra ( KEY_ENTRY , group . groupId ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tEntryEditActivity . Launch ( GroupAddEntryActivity . this , mGroup ) ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; tmPd = ProgressDialog . show ( mAct , " Working... " , " Loading database " , true , false ) ; tmIsDialogUp = true ; tThread bkgLoad = new Thread ( new BackgroundLoad ( fileName , pass , key ) ) ; tbkgLoad . start ( ) ; 
public void run ( ) { tmPd . dismiss ( ) ; tmIsDialogUp = false ; tif ( mMsg . length ( ) > 0 ) { tToast . makeText ( PasswordActivity . this , mMsg , Toast . LENGTH_LONG ) . show ( ) ; } tif ( mLaunch ) { tGroupActivity . Launch ( PasswordActivity . this , null ) ; 
public void notifyDataSetChanged ( ) { tsuper . notifyDataSetChanged ( ) ; tfilter ( ) ; } 
public void notifyDataSetInvalidated ( ) { tsuper . notifyDataSetInvalidated ( ) ; tfilter ( ) ; } 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
private int writeByteArray ( byte [ ] data ) throws IOException { tint dataLen ; tif ( data ! = null ) { tdataLen = data . length ; } else { tdataLen = 0 ; } tmOS . write ( BINARY_DATA_FIELD_TYPE ) ; tmOS . write ( Types . writeInt ( dataLen ) ) ; tif ( data ! = null ) { tmOS . write ( data ) ; } treturn dataLen ; 
public static int writeCString ( String str , OutputStream os ) throws IOException { if ( str = = null ) { os . write ( writeInt ( 0 ) ) ; return 0 ; } byte [ ] initial = str . getBytes ( " UTF-8 " ) ; int length = initial . length + 1 ; os . write ( writeInt ( length ) ) ; os . write ( initial ) ; os . write ( 0x00 ) ; return length ; } 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; title = source . title ; url = source . url ; username = source . username ; int passLen = source . binaryData . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; tCreation = new Date ( source . tCreation . getTime ( ) ) ; tLastMod = new Date ( source . tLastMod . getTime ( ) ) ; tLastAccess = new Date ( source . tLastAccess . getTime ( ) ) ; tExpire = new Date ( source . tExpire . getTime ( ) ) ; binaryDesc = source . binaryDesc ; int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; 
public void output ( ) throws PwManagerOutputException { tPwDbHeader header = outputHeader ( mOS ) ; tbyte [ ] finalKey = getFinalKey ( header ) ; tCipher cipher ; ttry { tcipher = Cipher . getInstance ( " AES/CBC/PKCS5Padding " ) ; } catch ( Exception e ) { tthrow new PwManagerOutputException ( " Algorithm not supported. " ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
private static void populateGlobals ( PwGroup currentGroup ) { tif ( currentGroup = = null ) { tVector < PwGroup > rootChildGroups = mPM . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroup cur = rootChildGroups . elementAt ( i ) ; tgRoot = cur . parent ; tgGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tVector < PwGroup > childGroups = currentGroup . childGroups ; tVector < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . elementAt ( i ) ; tgEntries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . elementAt ( i ) ; 
public void run ( ) { ttry { tDatabase . LoadData ( PasswordActivity . this , mFileName , mPass , mKey ) ; 
public static UUID bytestoUUID ( byte [ ] buf ) { long msb = 0 ; for ( int i = 0 ; i < 8 ; i + + ) { msb = ( msb < < 8 ) | ( buf [ i ] & 0xff ) ; } long lsb = 0 ; for ( int i = 8 ; i < 16 ; i + + ) { lsb = ( lsb < < 8 ) | ( buf [ i ] & 0xff ) ; } return new UUID ( msb , lsb ) ; 
public static void LoadData ( Context ctx , String filename , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tImporterV3 Importer = new ImporterV3 ( ) ; tmPM = Importer . openDatabase ( fis , password , keyfile ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tmFilename = filename ; tsearchHelper = new SearchDbHelper ( ctx ) ; tsearchHelper . open ( ) ; tbuildSearchIndex ( ctx ) ; } 
private static void buildSearchIndex ( Context ctx ) { tfor ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { tPwEntry entry = mPM . entries . get ( i ) ; 
public static void NewEntry ( PwEntry entry ) throws IOException , PwManagerOutputException { tPwGroup parent = entry . parent ; } 
public static void UndoNewEntry ( PwEntry entry ) { } 
public static void UpdateEntry ( PwEntry oldE , PwEntry newE ) throws IOException , PwManagerOutputException { searchHelper.updateEntry(oldE); 
public static void UndoUpdateEntry ( PwEntry old , PwEntry backup ) { } 
public static void clear ( ) { tif ( searchHelper ! = null ) { tsearchHelper . close ( ) ; tsearchHelper = null ; } tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; } 
public void onCreate ( SQLiteDatabase db ) { tdb . execSQL ( DATABASE_CREATE ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public SearchDbHelper open ( ) throws SQLException { tmDbHelper = new DatabaseHelper ( mCtx ) ; tmDb = mDbHelper . getWritableDatabase ( ) ; tclear ( ) ; treturn this ; } 
private void clear ( ) { tmDb . delete ( SEARCH_TABLE , null , null ) ; } 
private ContentValues buildNewEntryContent ( PwEntry entry ) { tContentValues cv = new ContentValues ( ) ; tUUID uuid = Types . bytestoUUID ( entry . uuid ) ; tString uuidStr = uuid . toString ( ) ; tcv . put ( KEY_UUID , uuidStr ) ; tcv . put ( KEY_TITLE , entry . title ) ; tcv . put ( KEY_URL , entry . url ) ; tcv . put ( KEY_COMMENT , entry . additional ) ; treturn cv ; } 
public void insertEntry ( PwEntry entry ) { tContentValues cv = buildNewEntryContent ( entry ) ; tmDb . insert ( SEARCH_TABLE , null , cv ) ; } 
public void updateEntry ( PwEntry entry ) { tContentValues cv = buildNewEntryContent ( entry ) ; tString uuidStr = cv . getAsString ( KEY_UUID ) ; tmDb . update ( SEARCH_TABLE , cv , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; 
public PwGroup search ( String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroup group = new PwGroup ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new Vector < PwEntry > ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tbyte [ ] bUuid = cursor . getBlob ( 0 ) ; tUUID uuid = Types . bytestoUUID ( bUuid ) ; tPwEntry entry = Database . gEntries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } treturn group ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tImporterV3 Importer = new ImporterV3 ( ) ; tmPM = Importer . openDatabase ( fis , password , keyfile ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tmFilename = filename ; tsearchHelper = new SearchDbHelper ( ctx ) ; tsearchHelper . open ( ) ; tbuildSearchIndex ( ctx ) ; } 
private void buildSearchIndex ( Context ctx ) { tfor ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { tPwEntry entry = mPM . entries . get ( i ) ; 
public void NewEntry ( PwEntry entry ) throws IOException , PwManagerOutputException { tPwGroup parent = entry . parent ; } 
public void UndoNewEntry ( PwEntry entry ) { } 
public void UpdateEntry ( PwEntry oldE , PwEntry newE ) throws IOException , PwManagerOutputException { searchHelper.updateEntry(oldE); 
public void UndoUpdateEntry ( PwEntry old , PwEntry backup ) { } 
public void SaveData ( ) throws IOException , PwManagerOutputException { tSaveData ( mFilename ) ; } 
public void SaveData ( String filename ) throws IOException , PwManagerOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; tPwManagerOutput pmo = new PwManagerOutput ( mPM , fos ) ; tpmo . output ( ) ; tfos . close ( ) ; tFile orig = new File ( filename ) ; torig . delete ( ) ; tif ( ! tempFile . renameTo ( orig ) ) { tthrow new IOException ( " Failed to store database. " ) ; } tmFilename = filename ; 
private void populateGlobals ( PwGroup currentGroup ) { tif ( currentGroup = = null ) { tVector < PwGroup > rootChildGroups = mPM . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroup cur = rootChildGroups . elementAt ( i ) ; tgRoot = cur . parent ; tgGroups . put ( cur . groupId , new WeakReference < PwGroup > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tVector < PwGroup > childGroups = currentGroup . childGroups ; tVector < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . elementAt ( i ) ; tgEntries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . elementAt ( i ) ; 
public void clear ( ) { tif ( searchHelper ! = null ) { tsearchHelper . close ( ) ; tsearchHelper = null ; } tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tif ( KeePass . db . gDirty . get ( mGroup ) ! = null ) { tKeePass . db . gDirty . remove ( mGroup ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . group_view_only ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tassert ( mId > = 0 ) ; tif ( id = = - 1 ) { tmGroup = KeePass . db . gRoot ; } else { tWeakReference < PwGroup > wPw = KeePass . db . gGroups . get ( id ) ; tmGroup = wPw . get ( ) ; } tassert ( mGroup ! = null ) ; tsetGroupTitle ( ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; tstyleScrollBars ( ) ; 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( TimeoutIntents . LOCK ) ) { tKeePass . db . clear ( ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tif ( resultCode = = KeePass . EXIT_LOCK ) { tsetResult ( KeePass . EXIT_LOCK ) ; tfinish ( ) ; } tKeePass . db . clear ( ) ; } 
public void run ( ) { ttry { tKeePass . db . LoadData ( PasswordActivity . this , mFileName , mPass , mKey ) ; 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroup search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroup group = new PwGroup ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new Vector < PwEntry > ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tbyte [ ] bUuid = cursor . getBlob ( 0 ) ; tUUID uuid = Types . bytestoUUID ( bUuid ) ; tPwEntry entry = db . gEntries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } treturn group ; } 
public static Test suite ( ) { treturn new TestSuiteBuilder ( AllTests . class ) . includePackages ( " com.android.keepass.tests.output " ) 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tmPE = TestData . GetTest1 ( getContext ( ) ) . entries . get ( 0 ) ; 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tmPG = TestData . GetTest1 ( getContext ( ) ) . groups . get ( 0 ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( getContext ( ) ) ; 
public void testFullWrite ( ) throws IOException , PwManagerOutputException { tAssetManager am = getContext ( ) . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public static PwManager GetTest1 ( Context ctx ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tif ( test1 = = null ) { tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ImporterV3 . DEBUG ) ; ttest1 = importer . openDatabase ( is , " 12345 " , " " ) ; tif ( test1 ! = null ) { ttest1 . constructTree ( null ) ; } } treturn test1 ; } 
tprotected void setUp ( ) throws Exception { } public void testSearch ( ) { } } 
public static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " InvalidKeyException: " + e . getMessage ( ) ) ; } return md.digest(); 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . group_view_only ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tint id = getIntent ( ) . getIntExtra ( KEY_ENTRY , - 1 ) ; tif ( id = = - 1 ) { tmGroup = KeePass . db . gRoot ; } else { tWeakReference < PwGroup > wPw = KeePass . db . gGroups . get ( id ) ; tmGroup = wPw . get ( ) ; } tassert ( mGroup ! = null ) ; tsetGroupTitle ( ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . group_view_only ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tstyleScrollBars ( ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; tmenu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; treturn true ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tLoadData ( ctx , is , password , keyfile , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tLoadData ( ctx , filename , password , keyfile , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , boolean debug ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tLoadData ( ctx , fis , password , keyfile , debug ) ; tmFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tImporterV3 Importer = new ImporterV3 ( debug ) ; tmPM = Importer . openDatabase ( is , password , keyfile ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tsearchHelper = new SearchDbHelper ( ctx ) ; tsearchHelper . open ( ) ; tbuildSearchIndex ( ctx ) ; 
public PwGroup Search ( String str ) { treturn searchHelper . search ( this , str ) ; } 
public static Database GetDb1 ( Context ctx ) throws IOException , InvalidCipherTextException , InvalidKeyFileException { tif ( mDb = = null ) { tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( TEST1_KDB , AssetManager . ACCESS_STREAMING ) ; tmDb = new Database ( ) ; tmDb . LoadData ( ctx , is , TEST1_PASSWORD , TEST1_KEYFILE , ImporterV3 . DEBUG ) ; tmDb . mFilename = " /sdcard/test1.kdb " ; } treturn mDb ; 
public static PwManager GetTest1 ( Context ctx ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tif ( mDb = = null ) { tGetDb1 ( ctx ) ; } treturn mDb . mPM ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroup search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroup group = new PwGroup ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new Vector < PwEntry > ( ) ; tgroup . childGroups = new Vector < PwGroup > ( ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntry entry = db . gEntries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } treturn group ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tmGroup = processSearchIntent ( getIntent ( ) ) ; tassert ( mGroup ! = null ) ; tif ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { tsetContentView ( R . layout . group_empty ) ; } else { tsetContentView ( R . layout . group_view_only ) ; } tsetGroupTitle ( ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; } 
tprotected void onNewIntent ( Intent intent ) { tsuper . onNewIntent ( intent ) ; tmGroup = processSearchIntent ( intent ) ; tassert ( mGroup ! = null ) ; } 
private PwGroup processSearchIntent ( Intent queryIntent ) { 
tprotected void setUp ( ) throws Exception { super . setUp ( ) ; mDb = TestData . GetDb1 ( getContext ( ) ) ; } 
public void testSearch ( ) { tPwGroup results = mDb . Search ( " Amazon " ) ; tassertTrue ( " Search result not found. " , results . childEntries . size ( ) > 1 ) ; 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; tmPd = ProgressDialog . show ( mAct , " Working... " , " Loading database " , true , false ) ; tThread bkgLoad = new Thread ( new BackgroundLoad ( fileName , pass , key ) ) ; tbkgLoad . start ( ) ; 
public void testSearch ( ) { tPwGroup results = mDb . Search ( " Amazon " ) ; tassertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; bkgStore.start(); 
public static Database GetDb1 ( Context ctx ) throws IOException , InvalidCipherTextException , InvalidKeyFileException { tif ( mDb1 = = null ) { tmDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " /sdcard/test1.kdb " ) ; } treturn mDb1 ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) throws IOException , InvalidCipherTextException , InvalidKeyFileException { tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; tDatabase Db = new Database ( ) ; tDb . LoadData ( ctx , is , password , keyfile , ImporterV3 . DEBUG ) ; tDb . mFilename = filename ; treturn Db ; 
public static PwManager GetTest1 ( Context ctx ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tif ( mDb1 = = null ) { tGetDb1 ( ctx ) ; } treturn mDb1 . mPM ; } 
public static byte [ ] makePad ( byte [ ] data ) { custom pad method append 0x80 plus zeros to a multiple of 4 bytes int thisblk = 32 - data.length % 32; bytes needed to finish blk int nextblk = 0; 32 if we need another block need 9 bytes; add new block if no room if( thisblk < 9 ) { nextblk = 32; } all bytes are zeroed for free byte[] pad = new byte[ thisblk + nextblk ]; pad[0] = (byte)0x80; write length*8 to end of final block int ix = thisblk + nextblk - 8; Types.writeInt( data.length>>29, pad, ix ); bsw32( pad, ix ); ix += 4; Types.writeInt( data.length<<3, pad, ix ); bsw32( pad, ix ); return pad; } 
public static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { Cipher cipher ; try { cipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { throw new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } try { cipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " InvalidKeyException: " + e . getMessage ( ) ) ; } return md.digest(); } 
public static byte [ ] makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , byte [ ] masterKey , int numRounds ) throws IOException { } 
public static byte [ ] makePad ( byte [ ] data ) { } 
public static void bsw32 ( byte [ ] ary , int offset ) { tbyte = ary [ offset ] ; tary [ offset ] = ary [ offset + 3 ] ; tary [ offset + 3 ] = ; tt = ary [ offset + 1 ] ; tary [ offset + 1 ] = ary [ offset + 2 ] ; tary [ offset + 2 ] = ; } 
public static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { tCipher cipher ; ttry { tcipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " InvalidKeyException: " + e . getMessage ( ) ) ; } } 
tvoid readGroupField ( PwGroup grp , int fieldType , byte [ ] buf , int offset ) { tswitch ( fieldType ) { tcase 0x0000 : 
tvoid readEntryField ( PwEntry ent , byte [ ] buf , int offset ) tthrows UnsupportedEncodingException { tint fieldType = Types . readShort ( buf , offset ) ; toffset + = 2 ; tint fieldSize = Types . readInt ( buf , offset ) ; toffset + = 4 ; tswitch ( fieldType ) { tcase 0x0000 : 
public void testOpen ( ) { ttry { tTestData . GetDb ( getContext ( ) , ASSET , PASSWORD , KEYFILE , FILENAME ) ; 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; title = source . title ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; tCreation = new Date ( source . tCreation . getTime ( ) ) ; tLastMod = new Date ( source . tLastMod . getTime ( ) ) ; tLastAccess = new Date ( source . tLastAccess . getTime ( ) ) ; tExpire = new Date ( source . tExpire . getTime ( ) ) ; binaryDesc = source . binaryDesc ; int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; 
public static void gotoUrl ( Context context , String url ) throws ActivityNotFoundException { tif ( url ! = null & & url . length ( ) > 0 ) { tUri uri = Uri . parse ( url ) ; 
public void NewGroup ( String name , PwGroup parent ) throws PwManagerOutputException , IOException { 
public static void Launch ( Activity act , PwGroup group , int mode ) { tIntent i = new Intent ( act , GroupActivity . class ) ; tif ( group ! = null ) { ti . putExtra ( KEY_ENTRY , group . groupId ) ; } ti . putExtra ( KEY_MODE , mode ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tEntryEditActivity . Launch ( GroupActivity . this , mGroup ) ; } 
public void onDismiss ( DialogInterface dialog ) { tString res = mDialog . getResponse ( ) ; ttry { tKeePass . db . NewGroup ( res , mGroup ) ; } catch ( PwManagerOutputException e ) { tToast . makeText ( mAct , R . string . error_could_not_create_group , Toast . LENGTH_LONG ) . show ( ) ; treturn ; } catch ( IOException e ) { tToast . makeText ( mAct , R . string . error_could_not_create_group , Toast . LENGTH_LONG ) . show ( ) ; treturn ; } tmAct . refreshIfDirty ( ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; trefreshIfDirty ( ) ; } 
public void refreshIfDirty ( ) { tif ( KeePass . db . gDirty . get ( mGroup ) ! = null ) { tKeePass . db . gDirty . remove ( mGroup ) ; 
public void onClick ( View v ) { tTextView nameField = ( TextView ) findViewById ( R . id . group_name ) ; tString name = nameField . getText ( ) . toString ( ) ; tif ( name . length ( ) > 0 ) { tmRes = name ; 
public void run ( ) { tmPd . dismiss ( ) ; tif ( mMsg . length ( ) > 0 ) { tToast . makeText ( PasswordActivity . this , mMsg , Toast . LENGTH_LONG ) . show ( ) ; } tif ( mLaunch ) { tGroupActivity . Launch ( PasswordActivity . this , null , GroupActivity . ADD_GROUP_ONLY ) ; 
tvoid onClick ( ) { tGroupActivity . Launch ( mAct , mPw , GroupActivity . FULL ) ; 
public void constructTree ( PwGroup currentGroup ) { return; } 
public PwGroup newGroup ( String name , PwGroup parent ) { return group; } 
public void removeGroup ( PwGroup group ) { tgroup . parent . childGroups . remove ( group ) ; tgroups . remove ( group ) ; } 
private int newGroupId ( ) { tboolean foundUnusedId = false ; tint newId = 0 ; tRandom random = new Random ( ) ; twhile ( ! foundUnusedId ) { tnewId = random . nextInt ( ) ; tif ( ! isGroupIdUsed ( newId ) ) { tfoundUnusedId = true ; } } treturn newId ; } 
private boolean isGroupIdUsed ( int id ) { tfor ( int i = 0 ; i < groups . size ( ) ; i + + ) { tif ( groups . get ( i ) . groupId = = id ) { treturn true ; } } treturn false ; } 
public void onDismiss ( DialogInterface dialog ) { tString res = mDialog . getResponse ( ) ; tif ( ! mDialog . canceled ( ) & & res . length ( ) > 0 ) { tmPd = ProgressDialog . show ( GroupActivity . this , " Working... " , " Saving database " , true , false ) ; 
public void run ( ) { ttry { tKeePass . db . NewGroup ( mName , mParent ) ; 
public void onClick ( View v ) { tmCanceled = true ; tcancel ( ) ; } 
tabstract public void onClick ( ) ; tabstract public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) ; tabstract public boolean onContextItemSelected ( MenuItem item ) ; } 
tabstract public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) ; tabstract public boolean onContextItemSelected ( MenuItem item ) ; } 
public void onCreateContextMenu ( ContextMenu menu , View v , tContextMenuInfo menuInfo ) { tAdapterContextMenuInfo acmi = ( AdapterContextMenuInfo ) menuInfo ; tClickView cv = ( ClickView ) acmi . targetView ; tcv . onCreateMenu ( menu , menuInfo ) ; } 
public boolean onContextItemSelected ( MenuItem item ) { tAdapterContextMenuInfo acmi = ( AdapterContextMenuInfo ) item . getMenuInfo ( ) ; tClickView cv = ( ClickView ) acmi . targetView ; treturn cv . onContextItemSelected ( item ) ; } 
tprotected void onStart ( ) { tsuper . onStart ( ) ; tstartFileSelect ( ) ; } 
public void run ( ) { 
public void run ( ) { tThread = new Thread ( mTask ) ; tt . start ( ) ; } 
private void launchEntry ( ) { tEntryActivity . Launch ( mAct , mPw , mPos ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tmenu . add ( 0 , MENU_EDIT , 0 , R . string . menu_edit ) ; menu.add(0, MENU_DELETE, 0, R.string.menu_delete); 
private void launchGroup ( ) { tGroupActivity . Launch ( mAct , mPw , GroupActivity . FULL ) ; } 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tmenu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; TODO: Re-enable need to address entries and last group issue 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . group_view_only ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; 
public void clear ( ) { tif ( searchHelper ! = null ) { tsearchHelper . close ( ) ; tsearchHelper = null ; } tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; tshutdown = false ; } 
public void run ( ) { mDb.gDirty.put(parent, new WeakReference<PwGroup>(mGroup)); 
private void saveError ( String msg ) { tundoRemoveGroup ( ) ; tuiHandler . post ( new UIToastTask ( mCtx , msg ) ) ; } 
private void undoRemoveGroup ( ) { tmDb . mPM . groups . add ( mGroup ) ; tPwGroup parent = mGroup . parent ; tif ( parent ! = null ) { tparent . childGroups . add ( mGroup ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tmLM . stopTimeout ( ) ; tif ( KeePass . db . shutdown ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tmLM . stopTimeout ( ) ; tif ( KeePass . db . shutdown ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
public void run ( ) { ttimeout = true ; tif ( KeePass . db ! = null ) { tKeePass . db . shutdown = true ; 
public static Test suite ( ) { treturn new TestSuiteBuilder ( AllTests . class ) . includePackages ( " com.keepassdroid.tests.output " ) 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tIntent i = getIntent ( ) ; tString action = i . getAction ( ) ; tif ( action ! = null & & action . equals ( VIEW_INTENT ) ) { tmFileName = i . getDataString ( ) ; tif ( ! mFileName . substring ( 0 , 7 ) . equals ( " file:} 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; } 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
public void outputGroups ( OutputStream os , PwGroup group ) throws PwManagerOutputException { outputGroups(os, group.childGroups.get(i)); 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public void onDismiss ( DialogInterface dialog ) { tString res = mDialog . getResponse ( ) ; tif ( ! mDialog . canceled ( ) & & res . length ( ) > 0 ) { tGroupActivity act = GroupActivity . this ; 
public void run ( ) { tToast . makeText ( GroupBaseActivity . this , " Unrecoverable error: " + mMsg , Toast . LENGTH_LONG ) ; tKeePass . db . shutdown = true ; tfinish ( ) ; } 
private void deleteEntry ( ) { tDeleteEntry task = new DeleteEntry ( KeePass . db , mPw , mAct , new Handler ( ) ) ; tProgressTask pt = new ProgressTask ( mAct , task , mAct . new RefreshTask ( ) ) ; tpt . run ( ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tmenu . add ( 0 , MENU_EDIT , 0 , R . string . menu_edit ) ; tmenu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; } 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tmenu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; tmenu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; TODO: Re-enable need to address entries and last group issue 
public void run ( ) { tPwGroup parent = mEntry . parent ; } 
private void undoNewEntry ( PwEntry entry ) { } 
public void run ( ) { tPwManager pm = mDb . mPM ; mDb.gGroups.put(group.groupId, new WeakReference<PwGroup>(group)); 
public void run ( ) { tSearchDbHelper dbHelper = new SearchDbHelper ( mCtx ) ; tdbHelper . open ( ) ; tfor ( int i = 0 ; i < mEntries . size ( ) ; i + + ) { tPwEntry entry = mEntries . get ( i ) ; tif ( entry ! = null ) { tremoveEntry ( entry , dbHelper ) ; } } tdbHelper . close ( ) ; } 
private void removeEntry ( PwEntry entry , SearchDbHelper dbHelper ) { mDb.gDirty.put(parent, new WeakReference<PwGroup>(parent)); 
private void saveError ( PwEntry entry , String msg ) { tundoRemoveEntry ( entry ) ; tmHandler . post ( new UIToastTask ( mCtx , msg ) ) ; } 
private void undoRemoveEntry ( PwEntry entry ) { tmDb . mPM . entries . add ( entry ) ; tPwGroup parent = entry . parent ; tif ( parent ! = null ) { tparent . childEntries . add ( entry ) ; 
public void run ( ) { mDb.gDirty.put(parent, new WeakReference<PwGroup>(parent)); 
private void saveError ( String msg ) { mHandler.post(mAct.new FatalError(msg)); 
public void run ( ) { } 
private void undoUpdateEntry ( PwEntry old , PwEntry backup ) { } 
public void output ( ) throws PwManagerOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
private void sortGroupsForOutput ( ) { tVector < PwGroup > groupList = new Vector < PwGroup > ( ) ; } 
private void sortGroup ( PwGroup group , Vector < PwGroup > groupList ) { sortGroup(group.childGroups.get(i), groupList); 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public void updateEntry ( PwEntry entry ) { tContentValues cv = buildNewEntryContent ( entry ) ; tString uuidStr = cv . getAsString ( KEY_UUID ) ; tmDb . update ( SEARCH_TABLE , cv , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public void deleteEntry ( PwEntry entry ) { tUUID uuid = Types . bytestoUUID ( entry . uuid ) ; tString uuidStr = uuid . toString ( ) ; tmDb . delete ( SEARCH_TABLE , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwGroup group1 = getGroup ( db . mPM , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
public void testSearch ( ) { tPwGroup results = mDb . Search ( " Amazon " ) ; tassertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tIntent i = getIntent ( ) ; tString action = i . getAction ( ) ; tif ( action ! = null & & action . equals ( VIEW_INTENT ) ) { tmFileName = i . getDataString ( ) ; tif ( ! mFileName . substring ( 0 , 7 ) . equals ( " file:} 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; tLoadDB task = new LoadDB ( KeePass . db , PasswordActivity . this , new Handler ( ) , fileName , pass , key ) ; tProgressTask pt = new ProgressTask ( PasswordActivity . this , task , new AfterLoad ( ) ) ; tpt . run ( ) ; } 
public void run ( ) { tGroupActivity . Launch ( PasswordActivity . this , null , GroupActivity . ADD_GROUP_ONLY ) ; } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; 
private void saveFileData ( String fileName , String key ) { tFileDbHelper db = new FileDbHelper ( mCtx ) ; tdb . open ( ) ; tdb . createFile ( fileName , key ) ; tdb . close ( ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; tHandler handler = new Handler ( ) ; tLoadDB task = new LoadDB ( KeePass . db , PasswordActivity . this , handler , fileName , pass , key , new AfterLoad ( handler ) ) ; tProgressTask pt = new ProgressTask ( PasswordActivity . this , task ) ; tpt . run ( ) ; } 
public void run ( ) { tif ( mSuccess ) { tGroupActivity . Launch ( PasswordActivity . this , null , GroupActivity . ADD_GROUP_ONLY ) ; 
public void run ( ) { 
public void run ( ) { tsuper . run ( ) ; 
private void deleteEntry ( ) { tHandler handler = new Handler ( ) ; tDeleteEntry task = new DeleteEntry ( KeePass . db , mPw , mAct , handler , mAct . new RefreshTask ( handler ) ) ; tProgressTask pt = new ProgressTask ( mAct , task ) ; tpt . run ( ) ; 
public void run ( ) { tPwGroup parent = mEntry . parent ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . parent ; } 
public void run ( ) { tPwManager pm = mDb . mPM ; } 
public void run ( ) { tif ( mSuccess ) { } 
public void run ( ) { tSearchDbHelper dbHelper = new SearchDbHelper ( mCtx ) ; tdbHelper . open ( ) ; } 
public void run ( ) { tif ( mSuccess ) { 
public void run ( ) { save.run(); 
public void run ( ) { tif ( mSuccess ) { super.run(); 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( InvalidCipherTextException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } tfinish ( true ) ; } 
public void run ( ) { tif ( mOnFinish ! = null ) { Pass on result on call finish 
tprotected void displayMessage ( Context ctx ) { tif ( mMessage ! = null & & mMessage . length ( ) > 0 ) { tToast . makeText ( ctx , mMessage , Toast . LENGTH_LONG ) . show ( ) ; 
tprotected void finish ( boolean result , String message ) { tif ( mFinish ! = null ) { tmFinish . setResult ( result , message ) ; 
tprotected void finish ( boolean result ) { tif ( mFinish ! = null ) { tmFinish . setResult ( result ) ; 
public void run ( ) { tif ( ! mDontSave ) { ttry { tmDb . SaveData ( ) ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( PwManagerOutputException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } } tfinish ( true ) ; } 
public void run ( ) { } 
public void run ( ) { tif ( mSuccess ) { } 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; title = source . title ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; tCreation = new Date ( source . tCreation . getTime ( ) ) ; tLastMod = new Date ( source . tLastMod . getTime ( ) ) ; tLastAccess = new Date ( source . tLastAccess . getTime ( ) ) ; tExpire = new Date ( source . tExpire . getTime ( ) ) ; binaryDesc = source . binaryDesc ; int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; parent = source . parent ; 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwGroup group1 = getGroup ( db . mPM , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; tHandler handler = new Handler ( ) ; tLoadDB task = new LoadDB ( KeePass . db , PasswordActivity . this , fileName , pass , key , new AfterLoad ( handler ) ) ; tProgressTask pt = new ProgressTask ( PasswordActivity . this , task ) ; tpt . run ( ) ; } 
private void deleteEntry ( ) { tHandler handler = new Handler ( ) ; tDeleteEntry task = new DeleteEntry ( KeePass . db , mPw , mAct , mAct . new RefreshTask ( handler ) ) ; tProgressTask pt = new ProgressTask ( mAct , task ) ; tpt . run ( ) ; 
public void run ( ) { tPwGroup parent = mEntry . parent ; } 
public void run ( ) { tPwManager pm = mDb . mPM ; } 
public void run ( ) { tSearchDbHelper dbHelper = new SearchDbHelper ( mCtx ) ; tdbHelper . open ( ) ; } 
public void run ( ) { save.run(); 
public void run ( ) { } 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwGroup group1 = getGroup ( db . mPM , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tmenu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; tmenu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; tHandler handler = new Handler ( ) ; tLoadDB task = new LoadDB ( KeePass . db , PasswordActivity . this , fileName , pass , key , new AfterLoad ( handler ) ) ; tProgressTask pt = new ProgressTask ( PasswordActivity . this , task , R . string . loading_database ) ; tpt . run ( ) ; } 
private void deleteEntry ( ) { tHandler handler = new Handler ( ) ; tDeleteEntry task = new DeleteEntry ( KeePass . db , mPw , mAct , mAct . new RefreshTask ( handler ) ) ; tProgressTask pt = new ProgressTask ( mAct , task , R . string . saving_database ) ; tpt . run ( ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; tmenu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; tmenu . add ( 0 , MENU_DB_SETTINGS , 0 , R . string . menu_db_settings ) ; tmenu . findItem ( MENU_DB_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_manage ) ; treturn true ; } 
public static void Launch ( Activity act ) { tIntent i = new Intent ( act , DatabaseSettingsActivity . class ) ; tact . startActivity ( i ) ; } 
public void onClick ( View v ) { tint rounds ; ttry { tEditText editRounds = ( EditText ) findViewById ( R . id . rounds ) ; tString strRounds = editRounds . getText ( ) . toString ( ) ; trounds = Integer . parseInt ( strRounds ) ; } catch ( NumberFormatException e ) { tToast . makeText ( DatabaseSettingsActivity . this , R . string . error_rounds_not_number , Toast . LENGTH_LONG ) . show ( ) ; treturn ; } tint oldRounds = mPM . numKeyEncRounds ; tmPM . numKeyEncRounds = rounds ; tHandler handler = new Handler ( ) ; tSaveDB save = new SaveDB ( KeePass . db , new AfterSave ( handler , oldRounds ) ) ; tProgressTask pt = new ProgressTask ( DatabaseSettingsActivity . this , save , R . string . saving_database ) ; tpt . run ( ) ; } 
public void run ( ) { tif ( mSuccess ) { tfinish ( ) ; } else { tdisplayMessage ( DatabaseSettingsActivity . this ) ; tmPM . numKeyEncRounds = mOldRounds ; } tsuper . run ( ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; tmenu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; tmenu . add ( 0 , MENU_DB_SETTINGS , 0 , R . string . menu_db_settings ) ; tmenu . findItem ( MENU_DB_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; tmenu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; treturn true ; } 
public void onClick ( View v ) { tTextView passView = ( TextView ) findViewById ( R . id . pass_password ) ; tString pass = passView . getText ( ) . toString ( ) ; tTextView passConfView = ( TextView ) findViewById ( R . id . pass_conf_password ) ; tString confpass = passConfView . getText ( ) . toString ( ) ; } 
public void run ( ) { tif ( mSuccess ) { tdismiss ( ) ; } else { tdisplayMessage ( getContext ( ) ) ; } tsuper . run ( ) ; } 
public void setMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tmasterKey = getMasterKey ( key , keyFileName ) ; } 
public static byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tif ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { treturn getCompositeKey ( key , keyFileName ) ; 
private static byte [ ] getCompositeKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tbyte [ ] fileKey = getFileKey ( keyFileName ) ; tbyte [ ] passwordKey = getPasswordKey ( key ) ; tSHA256Digest md = new SHA256Digest ( ) ; tmd . update ( passwordKey , 0 , 32 ) ; tmd . update ( fileKey , 0 , 32 ) ; tbyte [ ] outputKey = new byte [ md . getDigestSize ( ) ] ; tmd . doFinal ( outputKey , 0 ) ; treturn outputKey ; 
private static byte [ ] getFileKey ( String fileName ) throws InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tlong fileSize = keyfile . length ( ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tif ( fileSize = = 0 ) { tthrow new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { tbyte [ ] outputKey = new byte [ 32 ] ; tif ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn outputKey ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tif ( fis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn hexStringToByteArray ( new String ( hex ) ) ; } tSHA256Digest md = new SHA256Digest ( ) ; tbyte [ ] buffer = new byte [ 2048 ] ; tint offset = 0 ; ttry { twhile ( true ) { tint bytesRead = fis . read ( buffer , 0 , 2048 ) ; tif ( bytesRead = = - 1 ) break ; return outputKey; } 
public void run ( ) { tPwManager pm = mDb . mPM ; tbyte [ ] backupKey = new byte [ pm . masterKey . length ] ; tSystem . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public void run ( ) { tif ( ! mSuccess ) { } 
private void erase ( byte [ ] array ) { tif ( array = = null ) return ; tfor ( int i = 0 ; i < array . length ; i + + ) { tarray [ i ] = 0 ; 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; 
public void onClick ( View v ) { tTextView passView = ( TextView ) findViewById ( R . id . pass_password ) ; tString pass = passView . getText ( ) . toString ( ) ; tTextView passConfView = ( TextView ) findViewById ( R . id . pass_conf_password ) ; tString confpass = passConfView . getText ( ) . toString ( ) ; } 
public void onClick ( View v ) { tcancel ( ) ; tif ( mFinish ! = null ) { tmFinish . run ( ) ; 
public void run ( ) { tif ( mSuccess ) { tif ( mFinish ! = null ) { tmFinish . setFilename ( mKeyfile ) ; } tdismiss ( ) ; } else { tdisplayMessage ( getContext ( ) ) ; } tsuper . run ( ) ; } 
public void run ( ) { save.run(); 
public void run ( ) { tPwManager pm = mDb . mPM ; tbyte [ ] backupKey = new byte [ pm . masterKey . length ] ; tSystem . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public boolean hasRecentFiles ( ) { tCursor cursor = fetchAllFiles ( ) ; treturn cursor . getCount ( ) > 0 ; } 
public void onClick ( View v ) { tString fileName = Util . getEditText ( FileSelectActivity . this , R . id . file_filename ) ; ttry { tPasswordActivity . Launch ( FileSelectActivity . this , fileName ) ; 
public void onClick ( View v ) { tString filename = Util . getEditText ( FileSelectActivity . this , R . id . file_filename ) ; 
public void run ( ) { tif ( mSuccess ) { Add to recent files 
public void run ( ) { tSetPasswordDialog password = new SetPasswordDialog ( FileSelectActivity . this , mOnFinish ) ; tpassword . show ( ) ; } 
public void onClick ( View v ) { tString fileName = Util . getEditText ( FileSelectActivity . this , tR . id . file_filename ) ; ttry { tPasswordActivity . Launch ( FileSelectActivity . this , fileName ) ; 
public void onClick ( View v ) { tString filename = Util . getEditText ( FileSelectActivity . this , tR . id . file_filename ) ; createTask.run(); 
public void run ( ) { tif ( mSuccess ) { Add to recent files 
public void run ( ) { tSetPasswordDialog password = new SetPasswordDialog ( tFileSelectActivity . this , mOnFinish ) ; tpassword . show ( ) ; } 
private void fillData ( ) { } 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tsuper . onListItemClick ( l , v , position , id ) ; tCursor cursor = mDbHelper . fetchFile ( id ) ; tstartManagingCursor ( cursor ) ; tString fileName = cursor . getString ( cursor . getColumnIndexOrThrow ( FileDbHelper . KEY_FILE_FILENAME ) ) ; tString keyFile = cursor . getString ( cursor . getColumnIndexOrThrow ( FileDbHelper . KEY_FILE_KEYFILE ) ) ; ttry { tPasswordActivity . Launch ( this , fileName , keyFile ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; } 
tprotected void onPause ( ) { tsuper . onPause ( ) ; tsendBroadcast ( new Intent ( TimeoutIntents . START ) ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tsendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; Restart the activity 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; tmenu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; treturn true ; } 
public void run ( ) { tPwGroup parent = mEntry . parent ; } 
public void run ( ) { tPwManager pm = mDb . mPM ; } 
public void run ( ) { tif ( mSuccess ) { } 
public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } 
public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } 
public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . name . compareTo ( object2 . name ) ; } 
public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . title . compareTo ( object2 . title ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; tmenu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; tmenu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; tmenu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; tmenu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; tmenu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; tmenu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; treturn true ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . menu_show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; treturn true ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; tmenu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; tmenu . add ( 0 , MENU_DB_SETTINGS , 0 , R . string . menu_db_settings ) ; tmenu . findItem ( MENU_DB_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; tmenu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; treturn true ; } 
public static void gotoUrl ( Context context , int resId ) throws ActivityNotFoundException { tgotoUrl ( context , context . getString ( resId ) ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; tmenu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; treturn true ; } 
public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . name . compareToIgnoreCase ( object2 . name ) ; } 
public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . title . compareToIgnoreCase ( object2 . title ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , tboolean isChecked ) { tTextView password = ( TextView ) findViewById ( R . id . pass_password ) ; tif ( isChecked ) { tpassword . setTransformationMethod ( null ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tImporterV3 Importer = new ImporterV3 ( debug ) ; tmPM = Importer . openDatabase ( is , password , keyfile ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tsearchHelper = new SearchDbHelper ( ctx ) ; tsearchHelper . open ( ) ; tbuildSearchIndex ( ctx ) ; tloaded = true ; 
public void clear ( ) { tif ( searchHelper ! = null ) { tsearchHelper . close ( ) ; tsearchHelper = null ; } tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; tshutdown = false ; tloaded = false ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public void refreshIfDirty ( ) { tDatabase db = App . getDB ( ) ; tif ( db . gDirty . get ( mGroup ) ! = null ) { tdb . gDirty . remove ( mGroup ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tif ( resultCode = = KeePass . EXIT_LOCK ) { tsetResult ( KeePass . EXIT_LOCK ) ; tfinish ( ) ; } tApp . getDB ( ) . clear ( ) ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; 
private void deleteEntry ( ) { tHandler handler = new Handler ( ) ; tDeleteEntry task = new DeleteEntry ( App . getDB ( ) , mPw , mAct , mAct . new RefreshTask ( handler ) ) ; tProgressTask pt = new ProgressTask ( mAct , task , R . string . saving_database ) ; tpt . run ( ) ; 
public void onClick ( View v ) { tTextView passView = ( TextView ) findViewById ( R . id . pass_password ) ; tString pass = passView . getText ( ) . toString ( ) ; tTextView passConfView = ( TextView ) findViewById ( R . id . pass_conf_password ) ; tString confpass = passConfView . getText ( ) . toString ( ) ; } 
public void onTerminate ( ) { tsuper . onTerminate ( ) ; tif ( db ! = null ) { tdb . clear ( ) ; 
public void run ( ) { save.run(); 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetResult ( KeePass . EXIT_NORMAL ) ; tmDb = App . getDB ( ) ; } 
private PwGroup processSearchIntent ( Intent queryIntent ) { 
public void run ( ) { ttimeout = true ; tApp . getDB ( ) . shutdown = true ; } 
public void onClick ( View v ) { tint rounds ; ttry { tEditText editRounds = ( EditText ) findViewById ( R . id . rounds ) ; tString strRounds = editRounds . getText ( ) . toString ( ) ; trounds = Integer . parseInt ( strRounds ) ; } catch ( NumberFormatException e ) { tToast . makeText ( DatabaseSettingsActivity . this , R . string . error_rounds_not_number , Toast . LENGTH_LONG ) . show ( ) ; treturn ; } tint oldRounds = mPM . numKeyEncRounds ; tmPM . numKeyEncRounds = rounds ; tHandler handler = new Handler ( ) ; tSaveDB save = new SaveDB ( App . getDB ( ) , new AfterSave ( handler , oldRounds ) ) ; tProgressTask pt = new ProgressTask ( DatabaseSettingsActivity . this , save , R . string . saving_database ) ; tpt . run ( ) ; } 
public void clear ( ) { tif ( searchHelper ! = null ) { tsearchHelper . close ( ) ; tsearchHelper = null ; } tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; tloaded = false ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tmLM . stopTimeout ( ) ; tif ( App . isShutdown ( ) ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tmLM . stopTimeout ( ) ; tif ( App . isShutdown ( ) ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
public void onClick ( View view ) { tString pass = getEditText ( R . id . pass_password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . pass_filename ) ; 
public void run ( ) { ttimeout = true ; tApp . setShutdown ( ) ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tmIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( TimeoutIntents . START ) ) { tLog . w ( TAG , " Start " ) ; tstartTimeout ( DEFAULT_TIMEOUT ) ; } else if ( action . equals ( TimeoutIntents . CANCEL ) ) { tLog . w ( TAG , " Stop " ) ; tcancel ( ) ; } } } ; tIntentFilter filter = new IntentFilter ( ) ; tfilter . addAction ( TimeoutIntents . START ) ; tfilter . addAction ( TimeoutIntents . CANCEL ) ; tregisterReceiver ( mIntentReceiver , filter ) ; 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( TimeoutIntents . START ) ) { tLog . w ( TAG , " Start " ) ; 
public void run ( ) { tLog . w ( TAG , " Timeout " ) ; tApp . setShutdown ( ) ; } 
public void cancel ( ) { tif ( mTimer ! = null ) { tmTimer . cancel ( ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tsendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; tif ( App . isShutdown ( ) ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tsendBroadcast ( new Intent ( TimeoutIntents . CANCEL ) ) ; tif ( App . isShutdown ( ) ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tImporterV3 Importer = new ImporterV3 ( debug ) ; tmPM = Importer . openDatabase ( is , password , keyfile ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tsearchHelper = new SearchDbHelper ( ctx ) ; tbuildSearchIndex ( ) ; tloaded = true ; 
private void buildSearchIndex ( ) { tsearchHelper . open ( ) ; tfor ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { tPwEntry entry = mPM . entries . get ( i ) ; tsearchHelper . insertEntry ( entry ) ; } tsearchHelper . close ( ) ; } 
public PwGroup Search ( String str ) { tsearchHelper . open ( ) ; tPwGroup group = searchHelper . search ( this , str ) ; tsearchHelper . close ( ) ; treturn group ; 
public void clear ( ) { tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; tloaded = false ; } 
public void run ( ) { tSearchDbHelper dbHelper = new SearchDbHelper ( mCtx ) ; tdbHelper . open ( ) ; 
public void run ( ) { tif ( mSuccess ) { 
public boolean hasRecentFiles ( ) { tCursor cursor = fetchAllFiles ( ) ; tboolean hasRecent = cursor . getCount ( ) > 0 ; tcursor . close ( ) ; treturn hasRecent ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroup search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroup group = new PwGroup ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new Vector < PwEntry > ( ) ; tgroup . childGroups = new Vector < PwGroup > ( ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntry entry = db . gEntries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
private void buildSearchIndex ( ) { tinitSearch ( ) ; tsearchHelper . open ( ) ; tfor ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { tPwEntry entry = mPM . entries . get ( i ) ; tif ( ! entry . isMetaStream ( ) ) { tsearchHelper . insertEntry ( entry ) ; } } tsearchHelper . close ( ) ; } 
public void clear ( ) { tinitSearch ( ) ; tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; tloaded = false ; } 
public void initSearch ( ) { tsearchHelper . open ( ) ; tsearchHelper . clear ( ) ; tsearchHelper . close ( ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public SearchDbHelper open ( ) throws SQLException { tmDbHelper = new DatabaseHelper ( mCtx ) ; tmDb = mDbHelper . getWritableDatabase ( ) ; treturn this ; } 
public void clear ( ) { tmDb . delete ( SEARCH_TABLE , null , null ) ; } 
public static Database GetDb1 ( Context ctx ) throws IOException , InvalidCipherTextException , InvalidKeyFileException { treturn GetDb1 ( ctx , false ) ; } 
public static Database GetDb1 ( Context ctx , boolean forceReload ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tif ( mDb1 = = null | | forceReload ) { tmDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " /sdcard/test1.kdb " ) ; } treturn mDb1 ; } 
tprotected void setUp ( ) throws Exception { super . setUp ( ) ; mDb = TestData . GetDb1 ( getContext ( ) , true ) ; } 
public void initSearch ( ) { tif ( searchHelper ! = null ) { tsearchHelper . open ( ) ; 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . parent ; } 
public void run ( ) { tif ( mSuccess ) { } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , new String ( mEntry . getPassword ( ) ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . tCreation ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . tLastMod ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . tLastAccess ) ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; tmenu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; tmenu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; tmenu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; tmenu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; tmenu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; tmenu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; treturn true ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_PASS , 0 , R . string . show_password ) ; tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; treturn true ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . username ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , new String ( mEntry . getPassword ( ) ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . tCreation ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . tLastMod ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . tLastAccess ) ) ; tif ( PwEntry . IsNever ( mEntry . tExpire ) ) { tpopulateText ( R . id . entry_expires , R . string . never ) ; } else { tpopulateText ( R . id . entry_expires , df . format ( mEntry . tExpire ) ) ; } tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
private void populateText ( int viewId , int resId ) { tTextView tv = ( TextView ) findViewById ( viewId ) ; ttv . setText ( resId ) ; } 
public static boolean IsNever ( Date date ) { tCalendar never = Calendar . getInstance ( ) ; tnever . setTime ( NEVER_EXPIRE ) ; tnever . set ( Calendar . MILLISECOND , 0 ) ; tCalendar cal = Calendar . getInstance ( ) ; tcal . setTime ( date ) ; tcal . set ( Calendar . MILLISECOND , 0 ) ; treturn ( never . get ( Calendar . YEAR ) = = cal . get ( Calendar . YEAR ) ) & & ( never . get ( Calendar . MONTH ) = = cal . get ( Calendar . MONTH ) ) & & 
public void onCheckedChanged ( CompoundButton buttonView , tboolean isChecked ) { tTextView password = ( TextView ) findViewById ( R . id . password ) ; tif ( isChecked ) { tpassword . setTransformationMethod ( null ) ; 
private void populateView ( ) { tsetEditText ( R . id . filename , mFileName ) ; tsetEditText ( R . id . pass_keyfile , mKeyFile ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tif ( pass . length ( ) = = 0 & & key . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . filename ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tif ( App . isShutdown ( ) ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
tprotected void onPause ( ) { tsuper . onPause ( ) ; tTimeout . start ( this ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tTimeout . cancel ( this ) ; } 
tprotected void onPause ( ) { tsuper . onPause ( ) ; tTimeout . start ( this ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tTimeout . cancel ( this ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; Restart the activity 
public void onCreate ( ) { tsuper . onCreate ( ) ; tmIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( TimeoutIntents . TIMEOUT ) ) { ttimeout ( context ) ; } } } ; tIntentFilter filter = new IntentFilter ( ) ; tfilter . addAction ( TimeoutIntents . TIMEOUT ) ; tregisterReceiver ( mIntentReceiver , filter ) ; 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( TimeoutIntents . TIMEOUT ) ) { ttimeout ( context ) ; 
private void timeout ( Context context ) { tLog . d ( TAG , " Timeout " ) ; tApp . setShutdown ( ) ; } 
private static PendingIntent buildIntent ( Context ctx ) { tIntent intent = new Intent ( TimeoutIntents . TIMEOUT ) ; tPendingIntent sender = PendingIntent . getBroadcast ( ctx , REQUEST_ID , intent , PendingIntent . FLAG_CANCEL_CURRENT ) ; treturn sender ; } 
public static void start ( Context ctx ) { tlong triggerTime = System . currentTimeMillis ( ) + DEFAULT_TIMEOUT ; tAlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; tLog . d ( TAG , " Timeout start " ) ; tam . set ( AlarmManager . RTC , triggerTime , buildIntent ( ctx ) ) ; } 
public static void cancel ( Context ctx ) { tAlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; tLog . d ( TAG , " Timeout cancel " ) ; tam . cancel ( buildIntent ( ctx ) ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tcheckShutdown ( ) ; } 
private void checkShutdown ( ) { tif ( App . isShutdown ( ) ) { tsetResult ( KeePass . EXIT_LOCK ) ; 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( Intents . COPY_USERNAME ) ) { tString username = mEntry . username ; 
tprotected void onDestroy ( ) { tunregisterReceiver ( mIntentReceiver ) ; tmNM . cancelAll ( ) ; tsuper . onDestroy ( ) ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tmIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( Intents . TIMEOUT ) ) { ttimeout ( context ) ; } } } ; tIntentFilter filter = new IntentFilter ( ) ; tfilter . addAction ( Intents . TIMEOUT ) ; tregisterReceiver ( mIntentReceiver , filter ) ; 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( Intents . TIMEOUT ) ) { ttimeout ( context ) ; 
private void timeout ( Context context ) { tLog . d ( TAG , " Timeout " ) ; tApp . setShutdown ( ) ; tNotificationManager nm = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; tnm . cancelAll ( ) ; } 
private static PendingIntent buildIntent ( Context ctx ) { tIntent intent = new Intent ( Intents . TIMEOUT ) ; tPendingIntent sender = PendingIntent . getBroadcast ( ctx , REQUEST_ID , intent , PendingIntent . FLAG_CANCEL_CURRENT ) ; treturn sender ; } 
public void onClick ( View v ) { tString filename = Util . getEditText ( FileSelectActivity . this , tR . id . file_filename ) ; createTask.run(); 
public void run ( ) { save.run(); 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; tmenu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; tmenu . add ( 0 , MENU_DB_SETTINGS , 0 , R . string . menu_db_settings ) ; tmenu . findItem ( MENU_DB_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; tmenu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; tmenu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; treturn true ; } 
private void retrieveSettings ( ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; tmRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; tmenu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; tmenu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; treturn true ; } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; tif ( mRememberKeyfile ) { tsaveFileData ( mFileName , mKey ) ; } } catch ( InvalidCipherTextException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } tfinish ( true ) ; } 
public void deleteAll ( ) { tmDb . delete ( FILE_TABLE , null , null ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; tmenu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_ABOUT , 0 , R . string . menu_about ) ; tmenu . findItem ( MENU_ABOUT ) . setIcon ( android . R . drawable . ic_menu_help ) ; treturn true ; } 
public static void Launch ( Context ctx ) { tIntent i = new Intent ( ctx , AppSettingsActivity . class ) ; tctx . startActivity ( i ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tBoolean value = ( Boolean ) newValue ; tif ( ! value . booleanValue ( ) ) { tFileDbHelper helper = new FileDbHelper ( AppSettingsActivity . this ) ; thelper . open ( ) ; thelper . deleteAll ( ) ; thelper . close ( ) ; } treturn true ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; tmenu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; tmenu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; tmenu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; tmenu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; treturn true ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tsetRounds ( App . getDB ( ) , preference ) ; treturn true ; } 
tprotected View onCreateDialogView ( ) { tView view = super . onCreateDialogView ( ) ; tmRoundsView = ( TextView ) view . findViewById ( R . id . rounds ) ; tDatabase db = App . getDB ( ) ; tmPM = db . mPM ; tint numRounds = mPM . numKeyEncRounds ; tmRoundsView . setText ( Integer . toString ( numRounds ) ) ; treturn view ; } 
tprotected void onDialogClosed ( boolean positiveResult ) { tsuper . onDialogClosed ( positiveResult ) ; tif ( positiveResult ) { tint rounds ; 
public void run ( ) { tif ( mSuccess ) { tOnPreferenceChangeListener listner = getOnPreferenceChangeListener ( ) ; tif ( listner ! = null ) { tlistner . onPreferenceChange ( RoundsPreference . this , null ) ; } } else { tdisplayMessage ( mCtx ) ; tmPM . numKeyEncRounds = mOldRounds ; } tsuper . run ( ) ; } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( InvalidCipherTextException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } tfinish ( true ) ; } 
private void saveFileData ( String fileName , String key ) { tFileDbHelper db = new FileDbHelper ( mCtx ) ; tdb . open ( ) ; tif ( ! mRememberKeyfile ) { tkey = " " ; } tdb . createFile ( fileName , key ) ; tdb . close ( ) ; } 
public void deleteAllKeys ( ) { tContentValues vals = new ContentValues ( ) ; tvals . put ( KEY_FILE_KEYFILE , " " ) ; tmDb . update ( FILE_TABLE , vals , null , null ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tBoolean value = ( Boolean ) newValue ; tif ( ! value . booleanValue ( ) ) { tFileDbHelper helper = new FileDbHelper ( AppSettingsActivity . this ) ; thelper . open ( ) ; thelper . deleteAllKeys ( ) ; thelper . close ( ) ; } treturn true ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tif ( isFinishing ( ) ) { treturn ; } tsetResult ( KeePass . EXIT_NORMAL ) ; tmDb = App . getDB ( ) ; } 
public void deleteFile ( String filename ) { tmDb . delete ( FILE_TABLE , KEY_FILE_FILENAME + " = ? " , new String [ ] { filename } ) ; } 
public void onCreateContextMenu ( ContextMenu menu , View v , tContextMenuInfo menuInfo ) { tsuper . onCreateContextMenu ( menu , v , menuInfo ) ; tmenu . add ( 0 , CMENU_CLEAR , 0 , R . string . remove_from_filelist ) ; } 
private void refreshList ( ) { tCursorAdapter ca = ( CursorAdapter ) getListAdapter ( ) ; tCursor cursor = ca . getCursor ( ) ; tcursor . requery ( ) ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tif ( resultCode = = EXIT_NORMAL ) { tfinish ( ) ; 
private void timeoutCopyToClipboard ( String text ) { tUtil . copyToClipboard ( this , text ) ; tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; tString sClipClear = prefs . getString ( getString ( R . string . clipboard_timeout_key ) , getString ( R . string . clipboard_timeout_default ) ) ; tlong clipClearTime = Integer . parseInt ( sClipClear ) ; tif ( clipClearTime > 0 ) { tmTimer . schedule ( new ClearClipboardTask ( this , text ) , clipClearTime ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tstartService ( new Intent ( this , TimeoutService . class ) ) ; 
public byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { tCipher cipher ; ttry { tcipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " InvalidKeyException: " + e . getMessage ( ) ) ; } } 
public abstract byte [ ] transformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) throws IOException ; } 
public static FinalKey createFinalKey ( ) { treturn createFinalKey ( false ) ; } 
public static FinalKey createFinalKey ( boolean androidOverride ) { return new NativeFinalKey(); 
private static boolean init ( ) { tif ( ! isLoaded ) { ttry { tSystem . loadLibrary ( " final-key " ) ; } catch ( UnsatisfiedLinkError e ) { treturn false ; } tisLoaded = true ; tloadSuccess = true ; } treturn loadSuccess ; 
public byte [ ] transformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) throws IOException { tinit ( ) ; tbyte [ ] newKey = nativeTransformMasterKey ( seed , key , rounds ) ; return md.digest(); 
private static native byte [ ] nativeTransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) ; } 
public static byte [ ] reflect ( byte [ ] key ) { tinit ( ) ; treturn nativeReflect ( key ) ; } 
public void run ( ) { ttry { tDebug . startMethodTracing ( " load " ) ; tmDb . LoadData ( mCtx , mFileName , mPass , mKey ) ; tsaveFileData ( mFileName , mKey ) ; tDebug . stopMethodTracing ( ) ; } catch ( InvalidCipherTextException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } tfinish ( true ) ; } 
public static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { tFinalKey key = FinalKeyFactory . createFinalKey ( true ) ; treturn key . transformMasterKey ( pKeySeed , pKey , rounds ) ; } 
public byte [ ] transformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) throws IOException { tinit ( ) ; treturn nativeTransformMasterKey ( seed , key , rounds ) ; 
public void SaveData ( String filename ) throws IOException , PwManagerOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; tPwManagerOutput pmo = new PwManagerOutput ( mPM , fos , App . getCalendar ( ) ) ; tpmo . output ( ) ; tfos . close ( ) ; tFile orig = new File ( filename ) ; torig . delete ( ) ; tif ( ! tempFile . renameTo ( orig ) ) { tthrow new IOException ( " Failed to store database. " ) ; } tmFilename = filename ; 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void output ( ) throws IOException { } 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwManagerOutputException { PwEntry pe = mPM.entries.get(i); 
public static byte [ ] writeTime ( Date date , Calendar cal ) { if ( date = = null ) { return null ; } byte [ ] buf = new byte [ 5 ] ; if ( cal = = null ) { tcal = Calendar . getInstance ( ) ; } cal . setTime ( date ) ; int year = cal . get ( Calendar . YEAR ) ; buf[1] = writeUByte(((year & 0x0000003F) << 2) | ((month >> 2) & 0x00000003) ); buf[2] = (byte)(((month & 0x00000003) << 6) | ((day & 0x0000001F) << 1) | ((hour >> 4) & 0x00000001)); buf[3] = (byte)(((hour & 0x0000000F) << 4) | ((minute >> 2) & 0x0000000F)); buf[4] = (byte)(((minute & 0x00000003) << 6) | (second & 0x0000003F)); return buf; } 
public void testDate ( ) { tCalendar cal = Calendar . getInstance ( ) ; tCalendar expected = Calendar . getInstance ( ) ; texpected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; tbyte [ ] buf = Types . writeTime ( expected . getTime ( ) , cal ) ; tCalendar actual = Calendar . getInstance ( ) ; tactual . setTime ( Types . readTime ( buf , 0 ) ) ; tassertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; tassertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; tassertEquals ( " Day mismatch: " , 2 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; tassertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; tassertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; tassertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( getContext ( ) ) ; mCal = Calendar . getInstance ( ) ; } 
public void testPlainContent ( ) throws IOException , PwManagerOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwManagerOutput pos = new PwManagerOutput ( mPM , bos , mCal , PwManagerOutput . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . toByteArray ( ) ) ; 
public void testChecksum ( ) throws NoSuchAlgorithmException , IOException , PwManagerOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwManagerOutput pos = new PwManagerOutput(mPM, dos, mCal, PwManagerOutput.DEBUG); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
public void testHeader ( ) throws PwManagerOutputException , IOException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , mCal , PwManagerOutput . DEBUG ) ; PwDbHeader header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . toByteArray ( ) , bActual . toByteArray ( ) ) ; } 
public void testFinalKey ( ) throws PwManagerOutputException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwManagerOutput pActual = new PwManagerOutput ( mPM , bActual , mCal , PwManagerOutput . DEBUG ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey2 ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void testFullWrite ( ) throws IOException , PwManagerOutputException { tAssetManager am = getContext ( ) . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { tFinalKey key = FinalKeyFactory . createFinalKey ( ) ; treturn key . transformMasterKey ( pKeySeed , pKey , rounds ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tLoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tLoadData ( ctx , filename , password , keyfile , status , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) throws InvalidCipherTextException , IOException , InvalidKeyFileException , FileNotFoundException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tLoadData ( ctx , fis , password , keyfile , status , debug ) ; tmFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws InvalidCipherTextException , IOException , InvalidKeyFileException { tImporterV3 Importer = new ImporterV3 ( debug ) ; tmPM = Importer . openDatabase ( is , password , keyfile , status ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tstatus . updateMessage ( R . string . building_search_idx ) ; tsearchHelper = new SearchDbHelper ( ctx ) ; tbuildSearchIndex ( ) ; tloaded = true ; } 
public void updateMessage ( int resId ) { tif ( mCtx ! = null & & mPD ! = null & & mHandler ! = null ) { tmHandler . post ( new UpdateMessage ( resId ) ) ; 
public void run ( ) { tmPD . setMessage ( mCtx . getString ( mResId ) ) ; } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( InvalidCipherTextException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } tfinish ( true ) ; } 
public PwManager openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidCipherTextException , InvalidKeyFileException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public static boolean init ( ) { tif ( ! isLoaded ) { ttry { tSystem . loadLibrary ( " final-key " ) ; } catch ( UnsatisfiedLinkError e ) { treturn false ; } tisLoaded = true ; tloadSuccess = true ; } treturn loadSuccess ; 
public static boolean availble ( ) { treturn NativeLib . init ( ) ; } 
public byte [ ] transformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) throws IOException { tNativeLib . init ( ) ; treturn nativeTransformMasterKey ( seed , key , rounds ) ; 
private static native byte [ ] nativeTransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) ; } 
public static byte [ ] reflect ( byte [ ] key ) { tNativeLib . init ( ) ; treturn nativeReflect ( key ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException { tLoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException { tLoadData ( ctx , filename , password , keyfile , status , ! ImporterV3 . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tLoadData ( ctx , fis , password , keyfile , status , debug ) ; tmFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tImporterV3 Importer = new ImporterV3 ( debug ) ; tmPM = Importer . openDatabase ( is , password , keyfile , status ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tstatus . updateMessage ( R . string . building_search_idx ) ; tsearchHelper = new SearchDbHelper ( ctx ) ; tbuildSearchIndex ( ) ; tloaded = true ; } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( InvalidPasswordException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } tfinish ( true ) ; } 
public void output ( ) throws PwManagerOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public PwManager openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public static Database GetDb1 ( Context ctx ) throws IOException , InvalidKeyFileException , InvalidPasswordException { treturn GetDb1 ( ctx , false ) ; } 
public static Database GetDb1 ( Context ctx , boolean forceReload ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tif ( mDb1 = = null | | forceReload ) { tmDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " /sdcard/test1.kdb " ) ; } treturn mDb1 ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) throws InvalidKeyFileException , IOException , InvalidPasswordException { tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; tDatabase Db = new Database ( ) ; tDb . LoadData ( ctx , is , password , keyfile , ImporterV3 . DEBUG ) ; tDb . mFilename = filename ; treturn Db ; 
public static PwManager GetTest1 ( Context ctx ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tif ( mDb1 = = null ) { tGetDb1 ( ctx ) ; } treturn mDb1 . mPM ; } 
tprotected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) tthrows IllegalBlockSizeException , BadPaddingException { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte [ ] output = new byte [ maxSize ] ; tint finalSize = doFinal ( input , inputOffset , inputLen , output , 0 ) ; tif ( maxSize = = finalSize ) { treturn output ; 
tprotected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , tbyte [ ] output , int outputOffset ) throws ShortBufferException , tIllegalBlockSizeException , BadPaddingException { tint result = doFinal ( input , inputOffset , inputLen , output , outputOffset ) ; tif ( result = = - 1 ) { tthrow new ShortBufferException ( ) ; } treturn result ; } 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tmBuffered = 0 ; tint outputSize = engineGetOutputSize ( inputLen ) ; tint updateAmt = tnativeUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; tint finalAmt = nativeDoFinal ( mCtxPtr , output , outputOffset + updateAmt , outputSize - updateAmt ) ; treturn updateAmt + finalAmt ; } 
private native int nativeDoFinal ( long ctxPtr , byte [ ] output , int outputOffest , int outputSize ) ; @Override tprotected int engineGetBlockSize ( ) { treturn AES_BLOCK_SIZE ; } @Override tprotected byte [ ] engineGetIV ( ) { treturn mIV ; } @Override tprotected int engineGetOutputSize ( int inputLen ) { tint totalLen = mBuffered + inputLen ; tif ( ! mPadding | | ! mEncrypting ) { treturn totalLen ; } tint padLen = AES_BLOCK_SIZE - ( totalLen % AES_BLOCK_SIZE ) ; } 
tprotected int engineGetBlockSize ( ) { treturn AES_BLOCK_SIZE ; } 
tprotected int engineGetOutputSize ( int inputLen ) { tint totalLen = mBuffered + inputLen ; tif ( ! mPadding | | ! mEncrypting ) { treturn totalLen ; } tint padLen = AES_BLOCK_SIZE - ( totalLen % AES_BLOCK_SIZE ) ; } 
tprotected AlgorithmParameters engineGetParameters ( ) { } 
tprotected void engineInit ( int opmode , Key key , SecureRandom random ) tthrows InvalidKeyException { tbyte [ ] ivArray = new byte [ 16 ] ; trandom . nextBytes ( ivArray ) ; tinit ( opmode , key , new IvParameterSpec ( ivArray ) ) ; } 
tprotected void engineInit ( int opmode , Key key , tAlgorithmParameterSpec params , SecureRandom random ) tthrows InvalidKeyException , InvalidAlgorithmParameterException { tIvParameterSpec ivparam ; tif ( params instanceof IvParameterSpec ) { tivparam = ( IvParameterSpec ) params ; } else { tthrow new InvalidAlgorithmParameterException ( " params must be an IvParameterSpec. " ) ; } tinit ( opmode , key , ivparam ) ; } 
tprotected void engineInit ( int opmode , Key key , AlgorithmParameters params , tSecureRandom random ) throws InvalidKeyException , tInvalidAlgorithmParameterException { ttry { tengineInit ( opmode , key , params . getParameterSpec ( AlgorithmParameterSpec . class ) , random ) ; 
private void init ( int opmode , Key key , IvParameterSpec params ) { tif ( mIsInited ) { tcleanup ( ) ; tNativeLib . init ( ) ; } tmIV = params . getIV ( ) ; tmEncrypting = opmode = = Cipher . ENCRYPT_MODE ; tmBuffered = 0 ; tmCtxPtr = nativeInit ( mEncrypting , key . getEncoded ( ) , mIV , mPadding ) ; } 
private native long nativeInit ( boolean encrypt , byte [ ] key , byte [ ] iv , boolean mPadding ) ; private void cleanup ( ) { tnativeCleanup ( mCtxPtr ) ; tmCtxPtr = 0 ; } private native void nativeCleanup ( long ctxPtr ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
private void cleanup ( ) { tnativeCleanup ( mCtxPtr ) ; tmCtxPtr = 0 ; } 
private native void nativeCleanup ( long ctxPtr ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; 
tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; 
tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; 
tprotected int engineUpdate ( byte [ ] input , int inputOffset , int inputLen , tbyte [ ] output , int outputOffset ) throws ShortBufferException { tint result = update ( input , inputOffset , inputLen , output , outputOffset ) ; tif ( result = = - 1 ) { tthrow new ShortBufferException ( " Insufficient buffer. " ) ; } treturn result ; 
tint update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tmBuffered = ( mBuffered + inputLen ) % AES_BLOCK_SIZE ; treturn nativeUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , engineGetOutputSize ( inputLen ) ) ; } 
private native int nativeUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; } 
public byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { tCipher cipher ; ttry { tcipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " InvalidPasswordException: " + e . getMessage ( ) ) ; } } 
public void testEncrypt ( ) throws InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , IllegalBlockSizeException , BadPaddingException , InvalidAlgorithmParameterException { } 
private void testFinal ( int dataSize ) throws NoSuchAlgorithmException , NoSuchPaddingException , IllegalBlockSizeException , BadPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tmRand = new Random ( ) ; } 
public void testReflect ( ) { tboolean available = NativeFinalKey . availble ( ) ; tassertTrue ( " NativeFinalKey library cannot be loaded " , available ) ; tbyte [ ] key = new byte [ 32 ] ; tmRand . nextBytes ( key ) ; tbyte [ ] out = NativeFinalKey . reflect ( key ) ; tassertArrayEquals ( " Array not reflected correctly " , key , out ) ; 
public void testNativeAndroid ( ) throws IOException { } 
private void testNativeFinalKey ( int rounds ) throws IOException { tbyte [ ] seed = new byte [ 32 ] ; tbyte [ ] key = new byte [ 32 ] ; tbyte [ ] nativeKey ; tbyte [ ] androidKey ; tmRand . nextBytes ( seed ) ; tmRand . nextBytes ( key ) ; tAndroidFinalKey aKey = new AndroidFinalKey ( ) ; tandroidKey = aKey . transformMasterKey ( seed , key , rounds ) ; tNativeFinalKey nKey = new NativeFinalKey ( ) ; tnativeKey = nKey . transformMasterKey ( seed , key , rounds ) ; tassertArrayEquals ( " Does not match " , androidKey , nativeKey ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tImporterV3 Importer = new ImporterV3 ( App . getCalendar ( ) , debug ) ; } 
public void SaveData ( String filename ) throws IOException , PwManagerOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; 
public static Date readTime ( byte [ ] buf , int offset , Calendar time ) { int dw1 = readUByte ( buf , offset ) ; int dw2 = readUByte ( buf , offset + 1 ) ; int dw3 = readUByte ( buf , offset + 2 ) ; int dw4 = readUByte ( buf , offset + 3 ) ; int dw5 = readUByte ( buf , offset + 4 ) ; ime = Calendar.getInstance(); } File format is a 1 based month, java Calendar uses a zero based month time.set( year, month-1, day, hour, minute, second ); return time.getTime(); 
public void testDate ( ) { tCalendar cal = Calendar . getInstance ( ) ; tCalendar expected = Calendar . getInstance ( ) ; texpected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; tbyte [ ] buf = Types . writeTime ( expected . getTime ( ) , cal ) ; tCalendar actual = Calendar . getInstance ( ) ; tactual . setTime ( Types . readTime ( buf , 0 , cal ) ) ; tassertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; tassertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; tassertEquals ( " Day mismatch: " , 2 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; tassertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; tassertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; tassertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tImporterV3 Importer = new ImporterV3 ( App . getCalendar ( ) , debug ) ; } 
public void buildSearchIndex ( Context ctx ) { tsearchHelper = new SearchDbHelper ( ctx ) ; tinitSearch ( ) ; tsearchHelper . open ( ) ; tfor ( int i = 0 ; i < mPM . entries . size ( ) ; i + + ) { tPwEntry entry = mPM . entries . get ( i ) ; tif ( ! entry . isMetaStream ( ) ) { tsearchHelper . insertEntry ( entry ) ; } } tsearchHelper . close ( ) ; tindexBuilt = true ; } 
private void deleteEntry ( ) { tHandler handler = new Handler ( ) ; tDeleteEntry task = new DeleteEntry ( App . getDB ( ) , mPw , mAct . new RefreshTask ( handler ) ) ; tProgressTask pt = new ProgressTask ( mAct , task , R . string . saving_database ) ; tpt . run ( ) ; 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . parent ; } 
public void run ( ) { tmDb . buildSearchIndex ( mCtx ) ; tfinish ( true ) ; } 
public void run ( ) { 
public void run ( ) { tif ( mSuccess ) { tif ( mDb . indexBuilt ) { tSearchDbHelper dbHelper = mDb . searchHelper ; tdbHelper . open ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { tif ( mSuccess ) { } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tif ( isFinishing ( ) ) { treturn ; } tsetResult ( KeePass . EXIT_NORMAL ) ; tmDb = App . getDB ( ) ; /* 
private void performSearch ( String query ) { tif ( mDb . indexBuilt ) { tquery ( query ) ; 
private void query ( String query ) { tmGroup = mDb . Search ( query ) ; tif ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { tsetContentView ( R . layout . group_empty ) ; } else { tsetContentView ( R . layout . group_view_only ) ; } tsetGroupTitle ( ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; } 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwGroup group1 = getGroup ( db . mPM , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
public void testSearch ( ) { tmDb . buildSearchIndex ( getContext ( ) ) ; tPwGroup results = mDb . Search ( " Amazon " ) ; tassertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
private static void fill ( byte [ ] array , byte value ) { tfor ( int i = 0 ; i < array . length ; i + + ) array [ i ] = value ; treturn ; } 
private static byte [ ] getCompositeKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tbyte [ ] fileKey = getFileKey ( keyFileName ) ; tbyte [ ] passwordKey = getPasswordKey ( key ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tmd . update ( passwordKey ) ; treturn md . digest ( fileKey ) ; 
private static byte [ ] getFileKey ( String fileName ) throws InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tlong fileSize = keyfile . length ( ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tif ( fileSize = = 0 ) { tthrow new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { tbyte [ ] outputKey = new byte [ 32 ] ; tif ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn outputKey ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tif ( fis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn hexStringToByteArray ( new String ( hex ) ) ; } tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } return md.digest(); } 
private static byte [ ] getPasswordKey ( String key ) throws IOException { tassert ( key ! = null ) ; tif ( key . length ( ) = = 0 ) throw new IllegalArgumentException ( " Key cannot be empty. " ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } return md.digest(); } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tImporterV3 Importer = new ImporterV3 ( debug ) ; tmPM = Importer . openDatabase ( is , password , keyfile , status ) ; tif ( mPM ! = null ) { tmPM . constructTree ( null ) ; tpopulateGlobals ( null ) ; } tloaded = true ; } 
public void SaveData ( String filename ) throws IOException , PwManagerOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public Object clone ( ) { tPwDate copy = new PwDate ( ) ; tif ( cDateBuilt ) { tbyte [ ] newC = new byte [ DATE_SIZE ] ; tSystem . arraycopy ( cDate , 0 , newC , 0 , DATE_SIZE ) ; tcopy . cDate = newC ; tcopy . cDateBuilt = true ; } tif ( jDateBuilt ) { tcopy . jDate = ( Date ) jDate . clone ( ) ; tcopy . jDateBuilt = true ; } treturn copy ; } 
public static Date readTime ( byte [ ] buf , int offset , Calendar time ) { tint dw1 = Types . readUByte ( buf , offset ) ; tint dw2 = Types . readUByte ( buf , offset + 1 ) ; tint dw3 = Types . readUByte ( buf , offset + 2 ) ; tint dw4 = Types . readUByte ( buf , offset + 3 ) ; tint dw5 = Types . readUByte ( buf , offset + 4 ) ; return time.getTime(); 
public static byte [ ] writeTime ( Date date , Calendar cal ) { tif ( date = = null ) { treturn null ; } tbyte [ ] buf = new byte [ 5 ] ; tif ( cal = = null ) { tcal = Calendar . getInstance ( ) ; } tcal . setTime ( date ) ; tint year = cal . get ( Calendar . YEAR ) ; } 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void output ( ) throws IOException { } 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; title = source . title ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; tCreation = ( PwDate ) source . tCreation . clone ( ) ; tLastMod = ( PwDate ) source . tLastMod . clone ( ) ; tLastAccess = ( PwDate ) source . tLastAccess . clone ( ) ; tExpire = ( PwDate ) source . tExpire . clone ( ) ; binaryDesc = source . binaryDesc ; int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; parent = source . parent ; 
public PwGroup newGroup ( String name , PwGroup parent ) { return group; } 
public void testCreation ( ) { tCalendar cal = Calendar . getInstance ( ) ; tcal . setTime ( mPE . tCreation . getJDate ( ) ) ; tassertEquals ( " Incorrect year. " , cal . get ( Calendar . YEAR ) , 2009 ) ; tassertEquals ( " Incorrect month. " , cal . get ( Calendar . MONTH ) , 3 ) ; tassertEquals ( " Incorrect day. " , cal . get ( Calendar . DAY_OF_MONTH ) , 23 ) ; } 
public void testDate ( ) { tCalendar cal = Calendar . getInstance ( ) ; tCalendar expected = Calendar . getInstance ( ) ; texpected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; tbyte [ ] buf = PwDate . writeTime ( expected . getTime ( ) , cal ) ; tCalendar actual = Calendar . getInstance ( ) ; tactual . setTime ( PwDate . readTime ( buf , 0 , cal ) ) ; tassertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; tassertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; tassertEquals ( " Day mismatch: " , 2 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; tassertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; tassertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; tassertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; mPM = TestData . GetTest1 ( getContext ( ) ) ; } 
public static boolean IsNever ( Date date ) { tCalendar never = Calendar . getInstance ( ) ; tnever . setTime ( NEVER_EXPIRE ) ; tnever . set ( Calendar . MILLISECOND , 0 ) ; tCalendar cal = Calendar . getInstance ( ) ; tcal . setTime ( date ) ; tcal . set ( Calendar . MILLISECOND , 0 ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . YEAR ) + " R= " + cal . get ( Calendar . YEAR ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . MONTH ) + " R= " + cal . get ( Calendar . MONTH ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . DAY_OF_MONTH ) + " R= " + cal . get ( Calendar . DAY_OF_MONTH ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . HOUR ) + " R= " + cal . get ( Calendar . HOUR ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . MINUTE ) + " R= " + cal . get ( Calendar . MINUTE ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . SECOND ) + " R= " + cal . get ( Calendar . SECOND ) ) ; treturn ( never . get ( Calendar . YEAR ) = = cal . get ( Calendar . YEAR ) ) & & ( never . get ( Calendar . MONTH ) = = cal . get ( Calendar . MONTH ) ) & & 
tprotected void onDestroy ( ) { } 
private static void staticInit ( ) { tmIsStaticInit = true ; } 
private static void addToCleanupQueue ( NativeAESCipherSpi ref , long ptr ) { tLog . d ( " KeepassDroid " , " queued cipher context: " + ptr ) ; tmCleanup . put ( new PhantomReference < NativeAESCipherSpi > ( ref , mQueue ) , ptr ) ; } 
private native int nativeDoFinal ( long ctxPtr , byte [ ] output , int outputOffest , int outputSize ) ; @Override tprotected int engineGetBlockSize ( ) { treturn AES_BLOCK_SIZE ; } @Override tprotected byte [ ] engineGetIV ( ) { treturn mIV ; } @Override tprotected int engineGetOutputSize ( int inputLen ) { tint totalLen = mBuffered + inputLen ; tif ( ! mPadding | | ! mEncrypting ) { treturn totalLen ; } tint padLen = AES_BLOCK_SIZE - ( totalLen % AES_BLOCK_SIZE ) ; } 
private void init ( int opmode , Key key , IvParameterSpec params ) { tif ( mIsInited ) { } 
private native long nativeInit ( boolean encrypt , byte [ ] key , byte [ ] iv , boolean mPadding ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
public void buildSearchIndex ( Context ctx ) { tDebug . startMethodTracing ( " search " ) ; tsearchHelper = new SearchDbHelper ( ctx ) ; tinitSearch ( ) ; tsearchHelper . open ( ) ; tsearchHelper . insertEntry ( mPM . entries ) ; tsearchHelper . close ( ) ; tindexBuilt = true ; tDebug . stopMethodTracing ( ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public SearchDbHelper open ( ) throws SQLException { tmDbHelper = new DatabaseHelper ( mCtx ) ; tmDb = mDbHelper . getWritableDatabase ( ) ; tmDb . execSQL ( PRAGMA_NO_SYNCHRONOUS ) ; treturn this ; } 
public void insertEntry ( Vector < PwEntry > entries ) { tmDb . beginTransaction ( ) ; ttry { tfor ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public void assign ( PwEntry source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; title = source . title ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; tCreation = ( PwDate ) source . tCreation . clone ( ) ; tLastMod = ( PwDate ) source . tLastMod . clone ( ) ; tLastAccess = ( PwDate ) source . tLastAccess . clone ( ) ; tExpire = ( PwDate ) source . tExpire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public static int writeCString ( String str , OutputStream os ) throws IOException { if ( str = = null ) { return length; } 
tvoid readGroupField ( PwGroup grp , int fieldType , byte [ ] buf , int offset ) throws UnsupportedEncodingException { tswitch ( fieldType ) { tcase 0x0000 : 
tvoid readEntryField ( PwEntry ent , byte [ ] buf , int offset ) tthrows UnsupportedEncodingException { tint fieldType = Types . readShort ( buf , offset ) ; toffset + = 2 ; tint fieldSize = Types . readInt ( buf , offset ) ; toffset + = 4 ; tswitch ( fieldType ) { tcase 0x0000 : 
public static String readCString ( byte [ ] buf , int offset ) throws UnsupportedEncodingException { String jstring = new String ( buf , offset , strlen ( buf , offset ) , " UTF-8 " ) ; if ( REPLACE ) { jstring = jstring . replace ( CRLF , SEP ) ; } return jstring ; } 
public static int writeCString ( String str , OutputStream os ) throws IOException { if ( str = = null ) { return length; } 
public void clear ( ) { tinitSearch ( ) ; tindexBuilt = false ; tgGroups . clear ( ) ; tgEntries . clear ( ) ; tgRoot = null ; tmPM = null ; tmFilename = null ; tloaded = false ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tif ( mShowPassword ) { tmenu . add ( 0 , MENU_PASS , 0 , R . string . menu_hide_password ) ; } else { tmenu . add ( 0 , MENU_PASS , 0 , R . string . show_password ) ; } tmenu . findItem ( MENU_PASS ) . setIcon ( android . R . drawable . ic_menu_view ) ; tmenu . add ( 0 , MENU_GOTO_URL , 0 , R . string . menu_url ) ; tmenu . findItem ( MENU_GOTO_URL ) . setIcon ( android . R . drawable . ic_menu_upload ) ; tmenu . add ( 0 , MENU_COPY_USER , 0 , R . string . menu_copy_user ) ; tmenu . findItem ( MENU_COPY_USER ) . setIcon ( android . R . drawable . ic_menu_set_as ) ; tmenu . add ( 0 , MENU_COPY_PASS , 0 , R . string . menu_copy_pass ) ; tmenu . findItem ( MENU_COPY_PASS ) . setIcon ( android . R . drawable . ic_menu_agenda ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; treturn true ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; 
public void onStart ( Intent intent , int startId ) { tsuper . onStart ( intent , startId ) ; tLog . d ( TAG , " Timeout service started " ) ; } 
private void timeout ( Context context ) { tLog . d ( TAG , " Timeout " ) ; tApp . setShutdown ( ) ; tNotificationManager nm = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; tnm . cancelAll ( ) ; tstopSelf ( ) ; } 
public void onDestroy ( ) { tsuper . onDestroy ( ) ; tLog . d ( TAG , " Timeout service stopped " ) ; tunregisterReceiver ( mIntentReceiver ) ; } 
public static void start ( Context ctx ) { tctx . startService ( new Intent ( ctx , TimeoutService . class ) ) ; tlong triggerTime = System . currentTimeMillis ( ) + DEFAULT_TIMEOUT ; tAlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; tLog . d ( TAG , " Timeout start " ) ; tam . set ( AlarmManager . RTC , triggerTime , buildIntent ( ctx ) ) ; } 
public static void cancel ( Context ctx ) { tAlarmManager am = ( AlarmManager ) ctx . getSystemService ( Context . ALARM_SERVICE ) ; tLog . d ( TAG , " Timeout cancel " ) ; tam . cancel ( buildIntent ( ctx ) ) ; tctx . stopService ( new Intent ( ctx , TimeoutService . class ) ) ; 
public void buildSearchIndex ( Context ctx ) { tDebug . startMethodTracing ( " search " ) ; tsearchHelper = new SearchDbHelper ( ctx ) ; tinitSearch ( ) ; tsearchHelper . open ( ) ; tsearchHelper . insertEntry ( mPM . entries ) ; tsearchHelper . close ( ) ; tindexBuilt = true ; tDebug . stopMethodTracing ( ) ; } 
public PwGroupV3 Search ( String str ) { tsearchHelper . open ( ) ; tPwGroupV3 group = searchHelper . search ( this , str ) ; tsearchHelper . close ( ) ; treturn group ; 
public void SaveData ( ) throws IOException , PwDbOutputException { tSaveData ( mFilename ) ; } 
public void SaveData ( String filename ) throws IOException , PwDbOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; 
private void populateGlobals ( PwGroupV3 currentGroup ) { tif ( currentGroup = = null ) { tVector < PwGroupV3 > rootChildGroups = mPM . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroupV3 cur = rootChildGroups . elementAt ( i ) ; tgRoot = cur . parent ; tgGroups . put ( cur . groupId , new WeakReference < PwGroupV3 > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tVector < PwGroupV3 > childGroups = currentGroup . childGroups ; tVector < PwEntryV3 > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntryV3 cur = childEntries . elementAt ( i ) ; tgEntries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntryV3 > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroupV3 cur = childGroups . elementAt ( i ) ; 
public static void Launch ( Activity act , PwEntryV3 pw , int pos ) { tIntent i = new Intent ( act , EntryActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; ti . putExtra ( KEY_REFRESH_POS , pos ) ; tact . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwEntryV3 pw ) { tIntent i = new Intent ( act , EntryEditActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; tact . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroupV3 parent ) { tIntent i = new Intent ( act , EntryEditActivity . class ) ; ti . putExtra ( KEY_PARENT , parent . groupId ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public static void Launch ( Activity act , PwGroupV3 group , int mode ) { tIntent i = new Intent ( act , GroupActivity . class ) ; tif ( group ! = null ) { ti . putExtra ( KEY_ENTRY , group . groupId ) ; } ti . putExtra ( KEY_MODE , mode ) ; tact . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroupV3 group ) { tIntent i = new Intent ( act , GroupActivity . class ) ; tif ( group ! = null ) { ti . putExtra ( KEY_ENTRY , group . groupId ) ; } tact . startActivityForResult ( i , 0 ) ; } 
private void filter ( ) { tfilteredEntries = new Vector < PwEntryV3 > ( ) ; tfor ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { tPwEntryV3 entry = ( PwEntryV3 ) mGroup . childEntries . elementAt ( i ) ; 
private View createGroupView ( int position , View convertView ) { tPwGroupView gv ; } 
public void addGroup ( PwGroupV3 group ) { tgroups . addElement ( group ) ; } 
public void addEntry ( PwEntryV3 entry ) { tentries . addElement ( entry ) ; } 
public void constructTree ( PwGroupV3 currentGroup ) { return; } 
public PwGroupV3 newGroup ( String name , PwGroupV3 parent ) { return group; } 
public void removeGroup ( PwGroupV3 group ) { tgroup . parent . childGroups . remove ( group ) ; tgroups . remove ( group ) ; } 
public void assign ( PwEntryV3 source ) { System . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; groupId = source . groupId ; imageId = source . imageId ; title = source . title ; url = source . url ; username = source . username ; int passLen = source . password . length ; password = new byte [ passLen ] ; System . arraycopy ( source . password , 0 , password , 0 , passLen ) ; additional = source . additional ; tCreation = ( PwDate ) source . tCreation . clone ( ) ; tLastMod = ( PwDate ) source . tLastMod . clone ( ) ; tLastAccess = ( PwDate ) source . tLastAccess . clone ( ) ; tExpire = ( PwDate ) source . tExpire . clone ( ) ; binaryDesc = source . binaryDesc ; if ( source . binaryData ! = null ) { int descLen = source . binaryData . length ; binaryData = new byte [ descLen ] ; System . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } parent = source . parent ; 
public int compare ( PwGroupV3 object1 , PwGroupV3 object2 ) { treturn object1 . name . compareToIgnoreCase ( object2 . name ) ; } 
public int compare ( PwEntryV3 object1 , PwEntryV3 object2 ) { treturn object1 . title . compareToIgnoreCase ( object2 . title ) ; } 
public void run ( ) { tPwGroupV3 parent = mEntry . parent ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroupV3 parent = mEntry . parent ; } 
public void run ( ) { tPwDatabaseV3 pm = mDb . mPM ; } 
public void run ( ) { tif ( mSuccess ) { } 
public void run ( ) { save.run(); 
public void run ( ) { 
public void run ( ) { tif ( mSuccess ) { tif ( mDb . indexBuilt ) { tSearchDbHelper dbHelper = mDb . searchHelper ; tdbHelper . open ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { tif ( mSuccess ) { super.run(); 
public void run ( ) { tif ( ! mDontSave ) { ttry { tmDb . SaveData ( ) ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( PwDbOutputException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } } tfinish ( true ) ; } 
public void run ( ) { tPwDatabaseV3 pm = mDb . mPM ; tbyte [ ] backupKey = new byte [ pm . masterKey . length ] ; tSystem . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public void run ( ) { tif ( mSuccess ) { } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
tvoid readGroupField ( PwGroupV3 grp , int fieldType , byte [ ] buf , int offset ) throws UnsupportedEncodingException { tswitch ( fieldType ) { tcase 0x0000 : 
tvoid readEntryField ( PwEntryV3 ent , byte [ ] buf , int offset ) tthrows UnsupportedEncodingException { tint fieldType = Types . readShort ( buf , offset ) ; toffset + = 2 ; tint fieldSize = Types . readInt ( buf , offset ) ; toffset + = 4 ; tswitch ( fieldType ) { tcase 0x0000 : 
public byte [ ] getFinalKey ( PwDbHeaderV3 header ) throws PwDbOutputException { ttry { treturn ImporterV3 . makeFinalKey ( header . masterSeed , header . masterSeed2 , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public byte [ ] getFinalKey2 ( PwDbHeaderV3 header ) throws PwDbOutputException { ttry { treturn ImporterV3 . makeFinalKey ( header . masterSeed , header . masterSeed2 , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public void output ( ) throws PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwDbOutputException { PwEntryV3 pe = mPM.entries.get(i); 
private void sortGroupsForOutput ( ) { tVector < PwGroupV3 > groupList = new Vector < PwGroupV3 > ( ) ; } 
private void sortGroup ( PwGroupV3 group , Vector < PwGroupV3 > groupList ) { sortGroup(group.childGroups.get(i), groupList); 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
private ContentValues buildNewEntryContent ( PwEntryV3 entry ) { tContentValues cv = new ContentValues ( ) ; tUUID uuid = Types . bytestoUUID ( entry . uuid ) ; tString uuidStr = uuid . toString ( ) ; tcv . put ( KEY_UUID , uuidStr ) ; tcv . put ( KEY_TITLE , entry . title ) ; tcv . put ( KEY_URL , entry . url ) ; tcv . put ( KEY_COMMENT , entry . additional ) ; treturn cv ; } 
public void insertEntry ( PwEntryV3 entry ) { tContentValues cv = buildNewEntryContent ( entry ) ; tmDb . insert ( SEARCH_TABLE , null , cv ) ; } 
public void insertEntry ( Vector < PwEntryV3 > entries ) { tmDb . beginTransaction ( ) ; ttry { tfor ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public void updateEntry ( PwEntryV3 entry ) { tContentValues cv = buildNewEntryContent ( entry ) ; tString uuidStr = cv . getAsString ( KEY_UUID ) ; tmDb . update ( SEARCH_TABLE , cv , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public void deleteEntry ( PwEntryV3 entry ) { tUUID uuid = Types . bytestoUUID ( entry . uuid ) ; tString uuidStr = uuid . toString ( ) ; tmDb . delete ( SEARCH_TABLE , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public PwGroupV3 search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroupV3 group = new PwGroupV3 ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new Vector < PwEntryV3 > ( ) ; tgroup . childGroups = new Vector < PwGroupV3 > ( ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntryV3 entry = db . gEntries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwGroupV3 group1 = getGroup ( db . mPM , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
public static PwDatabaseV3 GetTest1 ( Context ctx ) throws IOException , InvalidKeyFileException , InvalidPasswordException { tif ( mDb1 = = null ) { tGetDb1 ( ctx ) ; } treturn mDb1 . mPM ; } 
public void testPlainContent ( ) throws IOException , PwDbOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV3Output pos = new PwDbV3Output ( mPM , bos , PwDbV3Output . DEBUG ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . toByteArray ( ) ) ; 
public void testChecksum ( ) throws NoSuchAlgorithmException , IOException , PwDbOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwDbV3Output pos = new PwDbV3Output(mPM, dos, PwDbV3Output.DEBUG); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . masterSeed2 , actual . masterSeed2 ) ; } 
public void testHeader ( ) throws PwDbOutputException , IOException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeaderV3 header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutput outExpected = new PwDbHeaderOutput ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . toByteArray ( ) , bActual . toByteArray ( ) ) ; } 
public void testFinalKey ( ) throws PwDbOutputException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeaderV3 hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey2 ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void testFullWrite ( ) throws IOException , PwDbOutputException { tAssetManager am = getContext ( ) . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public void testSearch ( ) { tmDb . buildSearchIndex ( getContext ( ) ) ; tPwGroupV3 results = mDb . Search ( " Amazon " ) ; tassertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
public static boolean IsNever ( Date date ) { tCalendar never = Calendar . getInstance ( ) ; tnever . setTime ( NEVER_EXPIRE ) ; tnever . set ( Calendar . MILLISECOND , 0 ) ; tCalendar cal = Calendar . getInstance ( ) ; tcal . setTime ( date ) ; tcal . set ( Calendar . MILLISECOND , 0 ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . YEAR ) + " R= " + cal . get ( Calendar . YEAR ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . MONTH ) + " R= " + cal . get ( Calendar . MONTH ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . DAY_OF_MONTH ) + " R= " + cal . get ( Calendar . DAY_OF_MONTH ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . HOUR ) + " R= " + cal . get ( Calendar . HOUR ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . MINUTE ) + " R= " + cal . get ( Calendar . MINUTE ) ) ; tLog . d ( " never " , " L= " + never . get ( Calendar . SECOND ) + " R= " + cal . get ( Calendar . SECOND ) ) ; treturn ( never . get ( Calendar . YEAR ) = = cal . get ( Calendar . YEAR ) ) & & ( never . get ( Calendar . MONTH ) = = cal . get ( Calendar . MONTH ) ) & & 
private static void fill ( byte [ ] array , byte value ) { tfor ( int i = 0 ; i < array . length ; i + + ) tarray [ i ] = value ; treturn ; } 
public boolean isMetaStream ( ) { tif ( binaryData = = null ) return false ; tif ( additional = = null | | additional . length ( ) = = 0 ) return false ; tif ( ! binaryDesc . equals ( PMS_ID_BINDESC ) ) return false ; tif ( title = = null ) return false ; tif ( ! title . equals ( PMS_ID_TITLE ) ) return false ; tif ( username = = null ) return false ; tif ( ! username . equals ( PMS_ID_USER ) ) return false ; tif ( url = = null ) return false ; tif ( ! url . equals ( PMS_ID_URL ) ) return false ; tif ( imageId ! = 0 ) return false ; treturn true ; } 
public void assign ( PwEntryV3 source ) { tSystem . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; tgroupId = source . groupId ; timageId = source . imageId ; ttitle = source . title ; turl = source . url ; tusername = source . username ; tint passLen = source . password . length ; tpassword = new byte [ passLen ] ; tSystem . arraycopy ( source . password , 0 , password , 0 , passLen ) ; tadditional = source . additional ; ttCreation = ( PwDate ) source . tCreation . clone ( ) ; ttLastMod = ( PwDate ) source . tLastMod . clone ( ) ; ttLastAccess = ( PwDate ) source . tLastAccess . clone ( ) ; ttExpire = ( PwDate ) source . tExpire . clone ( ) ; tbinaryDesc = source . binaryDesc ; tif ( source . binaryData ! = null ) { tint descLen = source . binaryData . length ; tbinaryData = new byte [ descLen ] ; tSystem . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } tparent = source . parent ; 
public void refreshTitle ( ) { tmTv . setText ( mPw . getDisplayTitle ( ) ) ; } 
public boolean isTan ( ) { treturn title . equals ( PMS_TAN_ENTRY ) ; } 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . group_add_entry , this ) ; 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . group_empty , this ) ; 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . group_root , this ) ; 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . group_view_only , this ) ; 
private void query ( String query ) { tmGroup = mDb . Search ( query ) ; tif ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { tsetContentView ( new GroupEmptyView ( this ) ) ; } else { tsetContentView ( new GroupViewOnlyView ( this ) ) ; } tsetGroupTitle ( ) ; tsetListAdapter ( new PwListAdapter ( this , mGroup ) ) ; } 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . group_header , this ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { tLoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { tLoadData ( ctx , filename , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tLoadData ( ctx , fis , password , keyfile , status , debug ) ; tmFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public boolean matchesHeader ( int sig1 , int sig2 ) { treturn ( sig1 = = PWM_DBSIG_1 ) & & ( sig2 = = PWM_DBSIG_2 ) ; } 
public boolean matchesHeader ( int sig1 , int sig2 ) { treturn ( sig1 = = PWM_DBSIG_1 ) & & ( ( sig2 = = PWM_DBSIG_2 ) | | ( sig2 = = PWM_DBSIG_2 ) ) ; } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( InvalidPasswordException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidDBSignatureException e ) { tfinish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; treturn ; } catch ( Kdb4Exception e ) { tfinish ( false , mCtx . getString ( R . string . error_kdb4 ) ) ; treturn ; } tfinish ( true ) ; } 
public static Importer createImporter ( InputStream is ) throws Kdb4Exception , InvalidDBSignatureException , IOException { treturn createImporter ( is , false ) ; } 
public static Importer createImporter ( InputStream is , boolean debug ) throws Kdb4Exception , InvalidDBSignatureException , IOException { tint sig1 = Types . readInt ( is ) ; tint sig2 = Types . readInt ( is ) ; tPwDbHeaderV3 h3 = new PwDbHeaderV3 ( ) ; tPwDbHeaderV4 h4 = new PwDbHeaderV4 ( ) ; tif ( h3 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV3 ( debug ) ; } else if ( h4 . matchesHeader ( sig1 , sig2 ) ) { tthrow new Kdb4Exception ( ) ; 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public static int readInt ( InputStream is ) throws IOException { byte [ ] buf = new byte [ 4 ] ; is . read ( buf , 0 , 4 ) ; return Types . readInt ( buf , 0 ) ; } 
public void testDetection ( ) throws IOException , InvalidDBSignatureException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; ttry { tImporterFactory . createImporter ( is ) ; } catch ( Kdb4Exception e ) { treturn ; } tassertTrue ( false ) ; 
public static Database GetDb1 ( Context ctx ) throws Exception { treturn GetDb1 ( ctx , false ) ; } 
public static Database GetDb1 ( Context ctx , boolean forceReload ) throws Exception { tif ( mDb1 = = null | | forceReload ) { tmDb1 = GetDb ( ctx , TEST1_KDB , TEST1_PASSWORD , TEST1_KEYFILE , " /sdcard/test1.kdb " ) ; } treturn mDb1 ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) throws Exception { tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; tDatabase Db = new Database ( ) ; tDb . LoadData ( ctx , is , password , keyfile , Importer . DEBUG ) ; tDb . mFilename = filename ; treturn Db ; 
public static PwDatabaseV3 GetTest1 ( Context ctx ) throws Exception { tif ( mDb1 = = null ) { tGetDb1 ( ctx ) ; } treturn mDb1 . mPM ; } 
public static boolean matchesHeader ( int sig1 , int sig2 ) { treturn ( sig1 = = PWM_DBSIG_1 ) & & ( sig2 = = DBSIG_2 ) ; } 
public static boolean matchesHeader ( int sig1 , int sig2 ) { treturn ( sig1 = = PWM_DBSIG_1 ) & & ( ( sig2 = = DBSIG_2 ) | | ( sig2 = = DBSIG_2 ) ) ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException ; } 
public static Importer createImporter ( InputStream is , boolean debug ) throws Kdb4Exception , InvalidDBSignatureException , IOException { tint sig1 = Types . readInt ( is ) ; tint sig2 = Types . readInt ( is ) ; tif ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV3 ( debug ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { tthrow new Kdb4Exception ( ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile ) throws IOException , InvalidKeyFileException , tInvalidPasswordException , InvalidDBSignatureException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException { treturn null ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tLoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tLoadData ( ctx , filename , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , FileNotFoundException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tLoadData ( ctx , fis , password , keyfile , status , debug ) ; tmFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public void loadFromFile ( byte buf [ ] , int offset ) { tsignature1 = Types . readInt ( buf , offset + 0 ) ; tsignature2 = Types . readInt ( buf , offset + 4 ) ; tflags = Types . readInt ( buf , offset + 8 ) ; tversion = Types . readInt ( buf , offset + 12 ) ; tSystem . arraycopy ( buf , offset + 16 , mMasterSeed , 0 , 16 ) ; tSystem . arraycopy ( buf , offset + 32 , encryptionIV , 0 , 16 ) ; tnumGroups = Types . readInt ( buf , offset + 48 ) ; tnumEntries = Types . readInt ( buf , offset + 52 ) ; tSystem . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; tSystem . arraycopy ( buf , offset + 88 , mTransformSeed , 0 , 32 ) ; tnumKeyEncRounds = Types . readInt ( buf , offset + 120 ) ; } 
public void loadFromFile ( InputStream is ) throws IOException , InvalidDBVersionException { tlong version = Types . readUInt ( is ) ; tif ( ! validVersion ( version ) ) { tthrow new InvalidDBVersionException ( ) ; } tboolean done = false ; twhile ( ! done ) { tdone = readHeaderField ( is ) ; 
private boolean readHeaderField ( InputStream is ) throws IOException { tbyte fieldID = ( byte ) is . read ( ) ; tint fieldSize = Types . readShort ( is ) ; tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = is . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tcase PwDbHeaderV4Fields . MasterSeed : tmMasterSeed = fieldData ; tcase PwDbHeaderV4Fields . TransformSeed : tmTransformSeed = fieldData ; tcase PwDbHeaderV4Fields . TransformRounds : } treturn false ; } 
private void setCipher ( byte [ ] pbId ) throws IOException { tif ( pbId = = null | | pbId . length ! = 16 ) { tthrow new IOException ( " Invalid cipher ID. " ) ; } tmDb . mDataCipher = Types . bytestoUUID ( pbId ) ; } 
private void setCompressionFlags ( byte [ ] pbFlags ) throws IOException { tif ( pbFlags = = null | | pbFlags . length ! = 4 ) { tthrow new IOException ( " Invalid compression flags. " ) ; } tint flag = Types . readInt ( pbFlags , 0 ) ; tif ( flag > = PwCompressionAlgorithm . Count ) { tthrow new IOException ( " Unrecognized compression flag. " ) ; } tmDb . mCompression = flag ; 
private boolean validVersion ( long version ) { treturn ! ( ( version & FILE_VERSION_CRITICAL_MASK ) > ( FILE_VERSION_32 & FILE_VERSION_CRITICAL_MASK ) ) ; 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( InvalidPasswordException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidDBSignatureException e ) { tfinish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; treturn ; } catch ( Kdb4Exception e ) { tfinish ( false , mCtx . getString ( R . string . error_kdb4 ) ) ; treturn ; } catch ( InvalidDBVersionException e ) { tfinish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; treturn ; } tfinish ( true ) ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException ; } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public void output ( ) throws IOException { tmOS . write ( Types . writeInt ( mHeader . signature1 ) ) ; tmOS . write ( Types . writeInt ( mHeader . signature2 ) ) ; tmOS . write ( Types . writeInt ( mHeader . flags ) ) ; tmOS . write ( Types . writeInt ( mHeader . version ) ) ; tmOS . write ( mHeader . mMasterSeed ) ; tmOS . write ( mHeader . encryptionIV ) ; tmOS . write ( Types . writeInt ( mHeader . numGroups ) ) ; tmOS . write ( Types . writeInt ( mHeader . numEntries ) ) ; tmOS . write ( mHeader . contentsHash ) ; tmOS . write ( mHeader . mTransformSeed ) ; tmOS . write ( Types . writeInt ( mHeader . numKeyEncRounds ) ) ; 
public byte [ ] getFinalKey ( PwDbHeader header ) throws PwDbOutputException { ttry { treturn ImporterV3 . makeFinalKey ( header . mMasterSeed , header . mTransformSeed , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public byte [ ] getFinalKey2 ( PwDbHeader header ) throws PwDbOutputException { ttry { treturn ImporterV3 . makeFinalKey ( header . mMasterSeed , header . mTransformSeed , mPM . masterKey , mPM . numKeyEncRounds ) ; 
public static long readUInt ( byte buf [ ] , int offset ) { return ( readInt ( buf , offset ) & INT_TO_LONG_MASK ) ; } 
public static long readUInt ( InputStream is ) throws IOException { return ( readInt ( is ) & INT_TO_LONG_MASK ) ; } 
public static int readShort ( InputStream is ) throws IOException { byte [ ] buf = new byte [ 2 ] ; is . read ( buf , 0 , 2 ) ; return readShort ( buf , 0 ) ; } 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . mMasterSeed , actual . mMasterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . mTransformSeed , actual . mTransformSeed ) ; } 
public void testFinalKey ( ) throws PwDbOutputException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey2 ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void loadFromFile ( byte buf [ ] , int offset ) throws IOException { tsignature1 = Types . readInt ( buf , offset + 0 ) ; tsignature2 = Types . readInt ( buf , offset + 4 ) ; tflags = Types . readInt ( buf , offset + 8 ) ; tversion = Types . readInt ( buf , offset + 12 ) ; tSystem . arraycopy ( buf , offset + 16 , mMasterSeed , 0 , 16 ) ; tSystem . arraycopy ( buf , offset + 32 , encryptionIV , 0 , 16 ) ; tnumGroups = Types . readInt ( buf , offset + 48 ) ; tnumEntries = Types . readInt ( buf , offset + 52 ) ; tSystem . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; tSystem . arraycopy ( buf , offset + 88 , mTransformSeed , 0 , 32 ) ; tnumKeyEncRounds = Types . readInt ( buf , offset + 120 ) ; tif ( numKeyEncRounds < 0 ) { TODO: Really treat this like an unsigned integer 
private boolean readHeaderField ( InputStream is ) throws IOException { tbyte fieldID = ( byte ) is . read ( ) ; tint fieldSize = Types . readShort ( is ) ; tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = is . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tcase PwDbHeaderV4Fields . MasterSeed : tmMasterSeed = fieldData ; tcase PwDbHeaderV4Fields . TransformSeed : tmTransformSeed = fieldData ; tcase PwDbHeaderV4Fields . TransformRounds : tsetTransformRounds ( fieldData ) ; } treturn false ; } 
private void setTransformRounds ( byte [ ] rounds ) throws IOException { tif ( rounds = = null | | rounds . length ! = 8 ) { tthrow new IOException ( " Invalid rounds. " ) ; } tlong rnd = Types . readLong ( rounds , 0 ) ; tif ( rnd < 0 ) { TODO: Actually support really large numbers 
public void run ( ) { save.run(); 
public byte [ ] getFinalKey ( PwDbHeader header ) throws PwDbOutputException { ttry { treturn ImporterV3 . makeFinalKey ( header . mMasterSeed , header . mTransformSeed , mPM . masterKey , mPM . mNumKeyEncRounds ) ; 
public byte [ ] getFinalKey2 ( PwDbHeader header ) throws PwDbOutputException { ttry { treturn ImporterV3 . makeFinalKey ( header . mMasterSeed , header . mTransformSeed , mPM . masterKey , mPM . mNumKeyEncRounds ) ; 
tprotected View onCreateDialogView ( ) { tView view = super . onCreateDialogView ( ) ; tmRoundsView = ( TextView ) view . findViewById ( R . id . rounds ) ; tDatabase db = App . getDB ( ) ; tmPM = db . mPM ; tint numRounds = mPM . mNumKeyEncRounds ; tmRoundsView . setText ( Integer . toString ( numRounds ) ) ; treturn view ; } 
public void run ( ) { tif ( mSuccess ) { tOnPreferenceChangeListener listner = getOnPreferenceChangeListener ( ) ; tif ( listner ! = null ) { tlistner . onPreferenceChange ( RoundsPreference . this , null ) ; } } else { tdisplayMessage ( mCtx ) ; tmPM . mNumKeyEncRounds = mOldRounds ; } tsuper . run ( ) ; } 
public static long readLong ( byte buf [ ] , int offset ) { treturn ( ( long ) buf [ offset + 0 ] & 0xFF ) + ( ( ( long ) buf [ offset + 1 ] & 0xFF ) < < 8 ) + ( ( ( long ) buf [ offset + 2 ] & 0xFF ) < < 16 ) + ( ( ( long ) buf [ offset + 3 ] & 0xFF ) < < 24 ) 
public static void writeLong ( long val , byte [ ] buf , int offset ) { tbuf [ offset + 0 ] = ( byte ) ( val & 0xFF ) ; tbuf [ offset + 1 ] = ( byte ) ( ( val > > > 8 ) & 0xFF ) ; tbuf [ offset + 2 ] = ( byte ) ( ( val > > > 16 ) & 0xFF ) ; tbuf [ offset + 3 ] = ( byte ) ( ( val > > > 24 ) & 0xFF ) ; tbuf [ offset + 4 ] = ( byte ) ( ( val > > > 32 ) & 0xFF ) ; tbuf [ offset + 5 ] = ( byte ) ( ( val > > > 40 ) & 0xFF ) ; tbuf [ offset + 6 ] = ( byte ) ( ( val > > > 48 ) & 0xFF ) ; tbuf [ offset + 7 ] = ( byte ) ( ( val > > > 56 ) & 0xFF ) ; } 
public void testReadWriteLongZero ( ) { ttestReadWriteLong ( ( byte ) 0 ) ; } 
public void testReadWriteLongMax ( ) { ttestReadWriteLong ( Byte . MAX_VALUE ) ; } 
public void testReadWriteLongMin ( ) { ttestReadWriteLong ( Byte . MIN_VALUE ) ; } 
public void testReadWriteLongRnd ( ) { tRandom rnd = new Random ( ) ; tbyte [ ] buf = new byte [ 1 ] ; trnd . nextBytes ( buf ) ; ttestReadWriteLong ( buf [ 0 ] ) ; } 
private void testReadWriteLong ( byte value ) { tbyte [ ] orig = new byte [ 8 ] ; tbyte [ ] dest = new byte [ 8 ] ; tsetArray ( orig , value , 0 , 8 ) ; tlong one = Types . readLong ( orig , 0 ) ; tTypes . writeLong ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
private void testReadWriteShort ( byte value ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; tsetArray ( orig , value , 0 , 2 ) ; tint one = Types . readShort ( orig , 0 ) ; tTypes . writeShort ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
private void testReadWriteByte ( byte value ) { tbyte [ ] orig = new byte [ 1 ] ; tbyte [ ] dest = new byte [ 1 ] ; tsetArray ( orig , value , 0 , 1 ) ; tint one = Types . readUByte ( orig , 0 ) ; tTypes . writeUByte ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
public void loadFromFile ( byte buf [ ] , int offset ) throws IOException { tsignature1 = Types . readInt ( buf , offset + 0 ) ; tsignature2 = Types . readInt ( buf , offset + 4 ) ; tflags = Types . readInt ( buf , offset + 8 ) ; tversion = Types . readInt ( buf , offset + 12 ) ; tSystem . arraycopy ( buf , offset + 16 , mMasterSeed , 0 , 16 ) ; tSystem . arraycopy ( buf , offset + 32 , mEncryptionIV , 0 , 16 ) ; tnumGroups = Types . readInt ( buf , offset + 48 ) ; tnumEntries = Types . readInt ( buf , offset + 52 ) ; tSystem . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; tSystem . arraycopy ( buf , offset + 88 , mTransformSeed , 0 , 32 ) ; tnumKeyEncRounds = Types . readInt ( buf , offset + 120 ) ; tif ( numKeyEncRounds < 0 ) { TODO: Really treat this like an unsigned integer 
public void loadFromFile ( InputStream is ) throws IOException , InvalidDBVersionException { tint sig1 = Types . readInt ( is ) ; tint sig2 = Types . readInt ( is ) ; tif ( ! matchesHeader ( sig1 , sig2 ) ) { tthrow new InvalidDBVersionException ( ) ; } tlong version = Types . readUInt ( is ) ; tif ( ! validVersion ( version ) ) { tthrow new InvalidDBVersionException ( ) ; } tboolean done = false ; twhile ( ! done ) { tdone = readHeaderField ( is ) ; 
private boolean readHeaderField ( InputStream is ) throws IOException { tbyte fieldID = ( byte ) is . read ( ) ; tint fieldSize = Types . readShort ( is ) ; tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = is . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmMasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : tmTransformSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tsetTransformRounds ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tmEncryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . ProtectedStreamKey : tmProtectedStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tmStreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tsetRandomStreamID ( fieldData ) ; tbreak ; tdefault : tthrow new IOException ( " Invalid header type. " ) ; } treturn false ; } 
private void setCompressionFlags ( byte [ ] pbFlags ) throws IOException { tif ( pbFlags = = null | | pbFlags . length ! = 4 ) { tthrow new IOException ( " Invalid compression flags. " ) ; } tint flag = Types . readInt ( pbFlags , 0 ) ; tif ( flag < 0 | | flag > = PwCompressionAlgorithm . Count ) { tthrow new IOException ( " Unrecognized compression flag. " ) ; } tmDb . mCompression = flag ; 
private void setTransformRounds ( byte [ ] rounds ) throws IOException { tif ( rounds = = null | | rounds . length ! = 8 ) { tthrow new IOException ( " Invalid rounds. " ) ; } tlong rnd = Types . readLong ( rounds , 0 ) ; tif ( rnd < 0 ) { 
private void setRandomStreamID ( byte [ ] streamID ) throws IOException { tif ( streamID = = null | | streamID . length ! = 4 ) { tthrow new IOException ( " Invalid stream id. " ) ; } tint id = Types . readInt ( streamID , 0 ) ; tif ( id < 0 | | id > = CrsAlgorithm . Count ) { tthrow new IOException ( " Invalid stream id. " ) ; } tmInnerRandomStream = id ; } 
public void run ( ) { tPwDatabase pm = mDb . mPM ; tbyte [ ] backupKey = new byte [ pm . masterKey . length ] ; tSystem . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile ) throws IOException , InvalidKeyFileException , tInvalidPasswordException , InvalidDBSignatureException , InvalidDBVersionException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { tPwDatabaseV4 db = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; treturn db ; } 
public void output ( ) throws IOException { tmOS . write ( Types . writeInt ( mHeader . signature1 ) ) ; tmOS . write ( Types . writeInt ( mHeader . signature2 ) ) ; tmOS . write ( Types . writeInt ( mHeader . flags ) ) ; tmOS . write ( Types . writeInt ( mHeader . version ) ) ; tmOS . write ( mHeader . mMasterSeed ) ; tmOS . write ( mHeader . mEncryptionIV ) ; tmOS . write ( Types . writeInt ( mHeader . numGroups ) ) ; tmOS . write ( Types . writeInt ( mHeader . numEntries ) ) ; tmOS . write ( mHeader . contentsHash ) ; tmOS . write ( mHeader . mTransformSeed ) ; tmOS . write ( Types . writeInt ( mHeader . numKeyEncRounds ) ) ; 
public void output ( ) throws PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.mEncryptionIV) ); 
public void testReadHeader ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , null , null ) ; tassertEquals ( 6000 , db . mNumKeyEncRounds ) ; 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . mEncryptionIV , actual . mEncryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . mMasterSeed , actual . mMasterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . mTransformSeed , actual . mTransformSeed ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public void buildSearchIndex ( Context ctx ) { tDebug . startMethodTracing ( " search " ) ; tsearchHelper = new SearchDbHelper ( ctx ) ; tinitSearch ( ) ; tsearchHelper . open ( ) ; tsearchHelper . insertEntry ( pm . entries ) ; tsearchHelper . close ( ) ; tindexBuilt = true ; tDebug . stopMethodTracing ( ) ; } 
public void SaveData ( String filename ) throws IOException , PwDbOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; 
private void populateGlobals ( PwGroupV3 currentGroup ) { tif ( currentGroup = = null ) { tVector < PwGroupV3 > rootChildGroups = pm . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroupV3 cur = rootChildGroups . elementAt ( i ) ; troot = cur . parent ; tgroups . put ( cur . groupId , new WeakReference < PwGroupV3 > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tVector < PwGroupV3 > childGroups = currentGroup . childGroups ; tVector < PwEntryV3 > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntryV3 cur = childEntries . elementAt ( i ) ; tentries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntryV3 > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroupV3 cur = childGroups . elementAt ( i ) ; 
public void clear ( ) { tinitSearch ( ) ; tindexBuilt = false ; tgroups . clear ( ) ; tentries . clear ( ) ; troot = null ; tpm = null ; tmFilename = null ; tloaded = false ; } 
public void refreshIfDirty ( ) { tDatabase db = App . getDB ( ) ; tif ( db . dirty . get ( mGroup ) ! = null ) { tdb . dirty . remove ( mGroup ) ; 
public static byte [ ] getMasterKey ( String key , String keyFileName ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tif ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { treturn getCompositeKey ( key , keyFileName ) ; 
public void setMasterKey ( String key , String keyFileName ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tmasterKey = getMasterKey ( key , keyFileName ) ; } 
private static byte [ ] getCompositeKey ( String key , String keyFileName ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tbyte [ ] fileKey = getFileKey ( keyFileName ) ; tbyte [ ] passwordKey = getPasswordKey ( key ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tmd . update ( passwordKey ) ; treturn md . digest ( fileKey ) ; 
private static byte [ ] getFileKey ( String fileName ) tthrows InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tlong fileSize = keyfile . length ( ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tif ( fileSize = = 0 ) { tthrow new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { tbyte [ ] outputKey = new byte [ 32 ] ; tif ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn outputKey ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tif ( fis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn hexStringToByteArray ( new String ( hex ) ) ; } tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } } 
public static byte [ ] hexStringToByteArray ( String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / 2 ] ; for ( int i = 0 ; i < len ; i + = 2 ) { data [ i / 2 ] = ( byte ) ( ( Character . digit ( s . charAt ( i ) , 16 ) < < 4 ) + Character . digit ( s . charAt ( i + 1 ) , 16 ) ) ; } return data ; } 
private static byte [ ] getPasswordKey ( String key ) throws IOException { tassert ( key ! = null ) ; tif ( key . length ( ) = = 0 ) throw new IllegalArgumentException ( " Key cannot be empty. " ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } } 
private boolean readHeaderField ( InputStream is ) throws IOException { tbyte fieldID = ( byte ) is . read ( ) ; tint fieldSize = Types . readShort ( is ) ; tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = is . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmMasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : tmTransformSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tsetTransformRounds ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tmEncryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . ProtectedStreamKey : tprotectedStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tstreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tsetRandomStreamID ( fieldData ) ; tbreak ; tdefault : tthrow new IOException ( " Invalid header type. " ) ; } treturn false ; } 
private void setCipher ( byte [ ] pbId ) throws IOException { tif ( pbId = = null | | pbId . length ! = 16 ) { tthrow new IOException ( " Invalid cipher ID. " ) ; } tdb . dataCipher = Types . bytestoUUID ( pbId ) ; } 
private void setCompressionFlags ( byte [ ] pbFlags ) throws IOException { tif ( pbFlags = = null | | pbFlags . length ! = 4 ) { tthrow new IOException ( " Invalid compression flags. " ) ; } tint flag = Types . readInt ( pbFlags , 0 ) ; tif ( flag < 0 | | flag > = PwCompressionAlgorithm . Count ) { tthrow new IOException ( " Unrecognized compression flag. " ) ; } tdb . compressionAlgorithm = flag ; 
private void setTransformRounds ( byte [ ] rounds ) throws IOException { tif ( rounds = = null | | rounds . length ! = 8 ) { tthrow new IOException ( " Invalid rounds. " ) ; } tlong rnd = Types . readLong ( rounds , 0 ) ; tif ( rnd < 0 ) { 
private void setRandomStreamID ( byte [ ] streamID ) throws IOException { tif ( streamID = = null | | streamID . length ! = 4 ) { tthrow new IOException ( " Invalid stream id. " ) ; } tint id = Types . readInt ( streamID , 0 ) ; tif ( id < 0 | | id > = CrsAlgorithm . Count ) { tthrow new IOException ( " Invalid stream id. " ) ; } tinnerRandomStream = id ; } 
public void run ( ) { tPwGroupV3 parent = mEntry . parent ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroupV3 parent = mEntry . parent ; } 
public void run ( ) { tPwDatabaseV3 pm = mDb . pm ; } 
public void run ( ) { tif ( mSuccess ) { } 
public void run ( ) { save.run(); 
public void run ( ) { 
public void run ( ) { tif ( mSuccess ) { tif ( mDb . indexBuilt ) { tSearchDbHelper dbHelper = mDb . searchHelper ; tdbHelper . open ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { tif ( mSuccess ) { super.run(); 
public void run ( ) { tPwDatabase pm = mDb . pm ; tbyte [ ] backupKey = new byte [ pm . masterKey . length ] ; tSystem . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public void run ( ) { tif ( ! mSuccess ) { } 
public void run ( ) { tif ( mSuccess ) { } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroupV3 search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroupV3 group = new PwGroupV3 ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new Vector < PwEntryV3 > ( ) ; tgroup . childGroups = new Vector < PwGroupV3 > ( ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntryV3 entry = db . entries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
tprotected View onCreateDialogView ( ) { tView view = super . onCreateDialogView ( ) ; tmRoundsView = ( TextView ) view . findViewById ( R . id . rounds ) ; tDatabase db = App . getDB ( ) ; tmPM = db . pm ; tint numRounds = mPM . numKeyEncRounds ; tmRoundsView . setText ( Integer . toString ( numRounds ) ) ; treturn view ; } 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwGroupV3 group1 = getGroup ( db . pm , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
public void testReadHeader ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , null , null ) ; tassertEquals ( 6000 , db . numKeyEncRounds ) ; 
public static PwDatabaseV3 GetTest1 ( Context ctx ) throws Exception { tif ( mDb1 = = null ) { tGetDb1 ( ctx ) ; } treturn mDb1 . pm ; } 
public static Cipher getInstance ( String transformation ) throws NoSuchAlgorithmException , NoSuchPaddingException { treturn getInstance ( transformation , false ) ; } 
public static Cipher getInstance ( String transformation , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException { return Cipher.getInstance(transformation, new AESProvider()); 
private static boolean hasNativeImplementation ( String transformation ) { treturn transformation . equals ( " AES/CBC/PKCS5Padding " ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { tPwDatabaseV4 db = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; } 
public void output ( ) throws PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.mEncryptionIV) ); 
private void testFinal ( int dataSize ) throws NoSuchAlgorithmException , NoSuchPaddingException , IllegalBlockSizeException , BadPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { } 
public static Cipher getInstance ( UUID uuid ) throws NoSuchAlgorithmException , NoSuchPaddingException { tif ( uuid . equals ( AES_CIPHER ) ) { treturn CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public void testReadHeader ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , null , null ) ; tassertEquals ( 6000 , db . numKeyEncRounds ) ; tassertTrue ( db . dataCipher . equals ( CipherFactory . AES_CIPHER ) ) ; 
public static Cipher getInstance ( UUID uuid , byte [ ] key , byte [ ] IV ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { tif ( uuid . equals ( AES_CIPHER ) ) { tCipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; tcipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; treturn cipher ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public static PwCompressionAlgorithm fromId ( int num ) { tfor ( PwCompressionAlgorithm e : PwCompressionAlgorithm . values ( ) ) { tif ( e . id = = num ) { treturn e ; } } treturn null ; } 
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) throws IOException { } 
private static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { tFinalKey key = FinalKeyFactory . createFinalKey ( ) ; treturn key . transformMasterKey ( pKeySeed , pKey , rounds ) ; } 
private static byte [ ] getCompositeKey ( String key , String keyFileName ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tbyte [ ] fileKey = getFileKey ( keyFileName ) ; tbyte [ ] passwordKey = getPasswordKey ( key ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tmd . update ( passwordKey ) ; treturn md . digest ( fileKey ) ; } 
private static byte [ ] getPasswordKey ( String key ) throws IOException { tassert ( key ! = null ) ; tif ( key . length ( ) = = 0 ) throw new IllegalArgumentException ( " Key cannot be empty. " ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tbyte [ ] bKey ; ttry { tbKey = key . getBytes ( " ISO-8859-1 " ) ; } catch ( UnsupportedEncodingException e ) { tassert false ; tbKey = key . getBytes ( ) ; } tmd . update ( bKey , 0 , bKey . length ) ; treturn md . digest ( ) ; } 
public void loadFromFile ( byte buf [ ] , int offset ) throws IOException { tsignature1 = Types . readInt ( buf , offset + 0 ) ; tsignature2 = Types . readInt ( buf , offset + 4 ) ; tflags = Types . readInt ( buf , offset + 8 ) ; tversion = Types . readInt ( buf , offset + 12 ) ; tSystem . arraycopy ( buf , offset + 16 , masterSeed , 0 , 16 ) ; tSystem . arraycopy ( buf , offset + 32 , encryptionIV , 0 , 16 ) ; tnumGroups = Types . readInt ( buf , offset + 48 ) ; tnumEntries = Types . readInt ( buf , offset + 52 ) ; tSystem . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; tSystem . arraycopy ( buf , offset + 88 , transformSeed , 0 , 32 ) ; tnumKeyEncRounds = Types . readInt ( buf , offset + 120 ) ; tif ( numKeyEncRounds < 0 ) { TODO: Really treat this like an unsigned integer 
private boolean readHeaderField ( InputStream is ) throws IOException { tbyte fieldID = ( byte ) is . read ( ) ; tint fieldSize = Types . readShort ( is ) ; tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = is . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : ttransformSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tsetTransformRounds ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tencryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . ProtectedStreamKey : tprotectedStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tstreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tsetRandomStreamID ( fieldData ) ; tbreak ; tdefault : tthrow new IOException ( " Invalid header type. " ) ; } treturn false ; } 
private void setCompressionFlags ( byte [ ] pbFlags ) throws IOException { tif ( pbFlags = = null | | pbFlags . length ! = 4 ) { tthrow new IOException ( " Invalid compression flags. " ) ; } tint flag = Types . readInt ( pbFlags , 0 ) ; tif ( flag < 0 | | flag > = PwCompressionAlgorithm . count ) { tthrow new IOException ( " Unrecognized compression flag. " ) ; } tdb . compressionAlgorithm = PwCompressionAlgorithm . fromId ( flag ) ; 
private void setTransformRounds ( byte [ ] rounds ) throws IOException { tif ( rounds = = null | | rounds . length ! = 8 ) { tthrow new IOException ( " Invalid rounds. " ) ; } tlong rnd = Types . readLong ( rounds , 0 ) ; tif ( rnd < 0 | | rnd > Integer . MAX_VALUE ) { 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { tPwDatabaseV4 db = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; } 
public void output ( ) throws IOException { tmOS . write ( Types . writeInt ( mHeader . signature1 ) ) ; tmOS . write ( Types . writeInt ( mHeader . signature2 ) ) ; tmOS . write ( Types . writeInt ( mHeader . flags ) ) ; tmOS . write ( Types . writeInt ( mHeader . version ) ) ; tmOS . write ( mHeader . masterSeed ) ; tmOS . write ( mHeader . encryptionIV ) ; tmOS . write ( Types . writeInt ( mHeader . numGroups ) ) ; tmOS . write ( Types . writeInt ( mHeader . numEntries ) ) ; tmOS . write ( mHeader . contentsHash ) ; tmOS . write ( mHeader . transformSeed ) ; tmOS . write ( Types . writeInt ( mHeader . numKeyEncRounds ) ) ; 
public byte [ ] getFinalKey ( PwDbHeader header ) throws PwDbOutputException { ttry { tmPM . makeFinalKey ( header . masterSeed , header . transformSeed , mPM . numKeyEncRounds ) ; 
public void output ( ) throws PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public long readUInt ( ) throws IOException { treturn ( readInt ( ) & INT_TO_LONG_MASK ) ; } 
public byte [ ] readBytes ( int length ) throws IOException { tbyte [ ] buf = new byte [ length ] ; tint count = 0 ; twhile ( count < length ) { tint read = read ( buf , count , length - count ) ; } 
public void writeUInt ( long uint ) throws IOException { twriteInt ( ( int ) uint ) ; } 
public int read ( byte [ ] b ) throws IOException { treturn read ( b , 0 , b . length ) ; } 
public int read ( byte [ ] b , int offset , int length ) throws IOException { tif ( atEnd ) return - 1 ; tint remaining = length ; twhile ( remaining > 0 ) { tif ( bufferPos = = buffer . length ) { } 
private boolean ReadHashedBlock ( ) throws IOException { tif ( atEnd ) return false ; tbufferPos = 0 ; tlong index = baseStream . readUInt ( ) ; tif ( index ! = bufferIndex ) { tthrow new IOException ( " Invalid data format " ) ; } tbufferIndex + + ; tbyte [ ] storedHash = baseStream . readBytes ( HASH_SIZE ) ; tif ( storedHash = = null | | storedHash . length ! = HASH_SIZE ) { tthrow new IOException ( " Invalid data format " ) ; } tint bufferSize = baseStream . readInt ( ) ; tif ( bufferSize < 0 ) { tthrow new IOException ( " Invalid data format " ) ; } tif ( bufferSize = = 0 ) { tfor ( int hash = 0 ; hash < HASH_SIZE ; hash + + ) { tif ( storedHash [ hash ] ! = 0 ) { tthrow new IOException ( " Invalid data format " ) ; } } tatEnd = true ; tbuffer = new byte [ 0 ] ; treturn false ; } tbuffer = baseStream . readBytes ( bufferSize ) ; tif ( buffer = = null | | buffer . length ! = bufferSize ) { tthrow new IOException ( " Invalid data format " ) ; } tMessageDigest md = null ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not implemented here. " ) ; } tbyte [ ] computedHash = md . digest ( buffer ) ; tif ( computedHash = = null | | computedHash . length ! = HASH_SIZE ) { tthrow new IOException ( " Hash wrong size " ) ; } tif ( ! Arrays . equals ( storedHash , computedHash ) ) { tthrow new IOException ( " Hashes didn't match. " ) ; } treturn true ; } 
public int read ( ) throws IOException { tthrow new IOException ( " Not implemented. " ) ; } 
public void close ( ) throws IOException { tbaseStream . close ( ) ; } 
public static long readUInt ( byte buf [ ] , int offset ) { return ( readInt ( buf , offset ) & BetterDataInputStream . INT_TO_LONG_MASK ) ; } 
public static long readUInt ( InputStream is ) throws IOException { return ( readInt ( is ) & BetterDataInputStream . INT_TO_LONG_MASK ) ; } 
public void testReadHeader ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; tassertEquals ( 6000 , db . numKeyEncRounds ) ; tassertTrue ( db . dataCipher . equals ( CipherFactory . AES_CIPHER ) ) ; tam . close ( ) ; 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertEquals ( " Version unequal " , expected . version , actual . version ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . transformSeed , actual . transformSeed ) ; } 
public void testFinalKey ( ) throws PwDbOutputException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void testBlockAligned ( ) throws IOException { tfinal int blockSize = 1024 ; tbyte [ ] orig = new byte [ blockSize ] ; tRandom rnd = new Random ( ) ; trnd . nextBytes ( orig ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tHashedBlockOutputStream output = new HashedBlockOutputStream ( bos , blockSize ) ; toutput . write ( orig ) ; toutput . close ( ) ; tbyte [ ] encoded = bos . toByteArray ( ) ; tByteArrayInputStream bis = new ByteArrayInputStream ( encoded ) ; tHashedBlockInputStream input = new HashedBlockInputStream ( bis ) ; tByteArrayOutputStream decoded = new ByteArrayOutputStream ( ) ; twhile ( true ) { tbyte [ ] buf = new byte [ 1024 ] ; tint read = input . read ( buf ) ; tif ( read = = - 1 ) { tbreak ; } tdecoded . write ( buf , 0 , read ) ; } tbyte [ ] out = decoded . toByteArray ( ) ; tassertArrayEquals ( orig , out ) ; 
public void testBlockAligned ( ) throws IOException { ttestSize ( 1024 , 1024 ) ; } 
public void testOffset ( ) throws IOException { ttestSize ( 1500 , 1024 ) ; } 
private void testSize ( int blockSize , int bufferSize ) throws IOException { tbyte [ ] orig = new byte [ blockSize ] ; tRandom rnd = new Random ( ) ; trnd . nextBytes ( orig ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tHashedBlockOutputStream output = new HashedBlockOutputStream ( bos , bufferSize ) ; toutput . write ( orig ) ; toutput . close ( ) ; tbyte [ ] encoded = bos . toByteArray ( ) ; tByteArrayInputStream bis = new ByteArrayInputStream ( encoded ) ; tHashedBlockInputStream input = new HashedBlockInputStream ( bis ) ; tByteArrayOutputStream decoded = new ByteArrayOutputStream ( ) ; twhile ( true ) { tbyte [ ] buf = new byte [ 1024 ] ; tint read = input . read ( buf ) ; tif ( read = = - 1 ) { tbreak ; } tdecoded . write ( buf , 0 , read ) ; } tbyte [ ] out = decoded . toByteArray ( ) ; tassertArrayEquals ( orig , out ) ; 
public static Cipher getInstance ( UUID uuid , byte [ ] key , byte [ ] IV ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { tif ( uuid . equals ( AES_CIPHER ) ) { tCipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , true ) ; tcipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; treturn cipher ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public abstract byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException ; public abstract byte[] getPasswordKey(String key) throws IOException;} 
tprotected byte [ ] getCompositeKey ( String key , String keyFileName ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tbyte [ ] fileKey = getFileKey ( keyFileName ) ; tbyte [ ] passwordKey = getPasswordKey ( key ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tmd . update ( passwordKey ) ; treturn md . digest ( fileKey ) ; } 
tprotected static byte [ ] getFileKey ( String fileName ) tthrows InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tlong fileSize = keyfile . length ( ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tif ( fileSize = = 0 ) { tthrow new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { tbyte [ ] outputKey = new byte [ 32 ] ; tif ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn outputKey ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tif ( fis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn hexStringToByteArray ( new String ( hex ) ) ; } tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } } 
tprotected byte [ ] getPasswordKey ( String key , String encoding ) throws IOException { tassert ( key ! = null ) ; tif ( key . length ( ) = = 0 ) throw new IllegalArgumentException ( " Key cannot be empty. " ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tbyte [ ] bKey ; ttry { } 
public abstract byte [ ] getPasswordKey ( String key ) throws IOException ; } 
public byte [ ] getMasterKey ( String key , String keyFileName ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tif ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { treturn getCompositeKey ( key , keyFileName ) ; 
public byte [ ] getPasswordKey ( String key ) throws IOException { treturn getPasswordKey ( key , " ISO-8859-1 " ) ; } 
public byte [ ] getMasterKey ( String key , String keyFileName ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tbyte [ ] fKey ; tif ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { treturn getCompositeKey ( key , keyFileName ) ; } else if ( key . length ( ) > 0 ) { tfKey = getPasswordKey ( key ) ; } else if ( keyFileName . length ( ) > 0 ) { tfKey = getFileKey ( keyFileName ) ; } else { tthrow new IllegalArgumentException ( " Key cannot be empty. " ) ; } tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " No SHA-256 implementation " ) ; } treturn md . digest ( fKey ) ; } 
public byte [ ] getPasswordKey ( String key ) throws IOException { treturn getPasswordKey ( key , " UTF-8 " ) ; } 
public void loadFromFile ( byte buf [ ] , int offset ) throws IOException { tsignature1 = LEDataInputStream . readInt ( buf , offset + 0 ) ; tsignature2 = LEDataInputStream . readInt ( buf , offset + 4 ) ; tflags = LEDataInputStream . readInt ( buf , offset + 8 ) ; tversion = LEDataInputStream . readInt ( buf , offset + 12 ) ; tSystem . arraycopy ( buf , offset + 16 , masterSeed , 0 , 16 ) ; tSystem . arraycopy ( buf , offset + 32 , encryptionIV , 0 , 16 ) ; tnumGroups = LEDataInputStream . readInt ( buf , offset + 48 ) ; tnumEntries = LEDataInputStream . readInt ( buf , offset + 52 ) ; tSystem . arraycopy ( buf , offset + 56 , contentsHash , 0 , 32 ) ; tSystem . arraycopy ( buf , offset + 88 , transformSeed , 0 , 32 ) ; tnumKeyEncRounds = LEDataInputStream . readInt ( buf , offset + 120 ) ; tif ( numKeyEncRounds < 0 ) { TODO: Really treat this like an unsigned integer 
public void loadFromFile ( InputStream is ) throws IOException , InvalidDBVersionException { tint sig1 = LEDataInputStream . readInt ( is ) ; tint sig2 = LEDataInputStream . readInt ( is ) ; tif ( ! matchesHeader ( sig1 , sig2 ) ) { tthrow new InvalidDBVersionException ( ) ; } tlong version = LEDataInputStream . readUInt ( is ) ; tif ( ! validVersion ( version ) ) { tthrow new InvalidDBVersionException ( ) ; } tboolean done = false ; twhile ( ! done ) { tdone = readHeaderField ( is ) ; 
private void setCompressionFlags ( byte [ ] pbFlags ) throws IOException { tif ( pbFlags = = null | | pbFlags . length ! = 4 ) { tthrow new IOException ( " Invalid compression flags. " ) ; } tint flag = LEDataInputStream . readInt ( pbFlags , 0 ) ; tif ( flag < 0 | | flag > = PwCompressionAlgorithm . count ) { tthrow new IOException ( " Unrecognized compression flag. " ) ; } tdb . compressionAlgorithm = PwCompressionAlgorithm . fromId ( flag ) ; 
private void setTransformRounds ( byte [ ] rounds ) throws IOException { tif ( rounds = = null | | rounds . length ! = 8 ) { tthrow new IOException ( " Invalid rounds. " ) ; } tlong rnd = LEDataInputStream . readLong ( rounds , 0 ) ; tif ( rnd < 0 | | rnd > Integer . MAX_VALUE ) { 
private void setRandomStreamID ( byte [ ] streamID ) throws IOException { tif ( streamID = = null | | streamID . length ! = 4 ) { tthrow new IOException ( " Invalid stream id. " ) ; } tint id = LEDataInputStream . readInt ( streamID , 0 ) ; tif ( id < 0 | | id > = CrsAlgorithm . Count ) { tthrow new IOException ( " Invalid stream id. " ) ; } tinnerRandomStream = id ; } 
public static Importer createImporter ( InputStream is , boolean debug ) throws Kdb4Exception , InvalidDBSignatureException , IOException { tint sig1 = LEDataInputStream . readInt ( is ) ; tint sig2 = LEDataInputStream . readInt ( is ) ; tif ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV3 ( debug ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { tthrow new Kdb4Exception ( ) ; 
public static byte [ ] makePad ( byte [ ] data ) { } 
tvoid readEntryField ( PwEntryV3 ent , byte [ ] buf , int offset ) tthrows UnsupportedEncodingException { tint fieldType = Types . readShort ( buf , offset ) ; toffset + = 2 ; tint fieldSize = LEDataInputStream . readInt ( buf , offset ) ; toffset + = 4 ; tswitch ( fieldType ) { tcase 0x0000 : 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { tPwDatabaseV4 db = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; } 
private boolean ReadHashedBlock ( ) throws IOException { tif ( atEnd ) return false ; tbufferPos = 0 ; tlong index = baseStream . readUInt ( ) ; tif ( index ! = bufferIndex ) { tthrow new IOException ( " Invalid data format " ) ; } tbufferIndex + + ; tbyte [ ] storedHash = baseStream . readBytes ( 32 ) ; tif ( storedHash = = null | | storedHash . length ! = HASH_SIZE ) { tthrow new IOException ( " Invalid data format " ) ; } tint bufferSize = LEDataInputStream . readInt ( baseStream ) ; tif ( bufferSize < 0 ) { tthrow new IOException ( " Invalid data format " ) ; } tif ( bufferSize = = 0 ) { tfor ( int hash = 0 ; hash < HASH_SIZE ; hash + + ) { tif ( storedHash [ hash ] ! = 0 ) { tthrow new IOException ( " Invalid data format " ) ; } } tatEnd = true ; tbuffer = new byte [ 0 ] ; treturn false ; } tbuffer = baseStream . readBytes ( bufferSize ) ; tif ( buffer = = null | | buffer . length ! = bufferSize ) { tthrow new IOException ( " Invalid data format " ) ; } tMessageDigest md = null ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not implemented here. " ) ; } tbyte [ ] computedHash = md . digest ( buffer ) ; tif ( computedHash = = null | | computedHash . length ! = HASH_SIZE ) { tthrow new IOException ( " Hash wrong size " ) ; } tif ( ! Arrays . equals ( storedHash , computedHash ) ) { tthrow new IOException ( " Hashes didn't match. " ) ; } treturn true ; } 
private void init ( OutputStream os , int bufferSize ) { tbaseStream = new LEDataOutputStream ( os ) ; tbuffer = new byte [ bufferSize ] ; 
public void write ( int oneByte ) throws IOException { tbyte [ ] buf = new byte [ 1 ] ; twrite ( buf , 0 , 1 ) ; } 
public void close ( ) throws IOException { tif ( bufferPos ! = 0 ) { } 
public void flush ( ) throws IOException { tbaseStream . flush ( ) ; } 
public void write ( byte [ ] b , int offset , int count ) throws IOException { twhile ( count > 0 ) { tif ( bufferPos = = buffer . length ) { 
private void WriteHashedBlock ( ) throws IOException { tbaseStream . writeUInt ( bufferIndex ) ; tbufferIndex + + ; tif ( bufferPos > 0 ) { tMessageDigest md = null ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not implemented here. " ) ; } tbyte [ ] hash ; tmd . update ( buffer , 0 , bufferPos ) ; thash = md . digest ( ) ; tbaseStream . write ( hash ) ; } else { 
public void write ( byte [ ] buffer ) throws IOException { twrite ( buffer , 0 , buffer . length ) ; } 
public long readUInt ( ) throws IOException { treturn readUInt ( baseStream ) ; } 
public int readInt ( ) throws IOException { treturn readInt ( baseStream ) ; } 
public long readLong ( ) throws IOException { tbyte [ ] buf = readBytes ( 8 ) ; treturn readLong ( buf , 0 ) ; } 
public int available ( ) throws IOException { treturn baseStream . available ( ) ; } 
public void mark ( int readlimit ) { tbaseStream . mark ( readlimit ) ; } 
public boolean markSupported ( ) { treturn baseStream . markSupported ( ) ; } 
public int read ( ) throws IOException { treturn baseStream . read ( ) ; } 
public int read ( byte [ ] b , int offset , int length ) throws IOException { treturn baseStream . read ( b , offset , length ) ; } 
public int read ( byte [ ] b ) throws IOException { } 
public synchronized void reset ( ) throws IOException { tbaseStream . reset ( ) ; } 
public long skip ( long ) throws IOException { treturn baseStream . skip ( ) ; } 
public static long readUInt ( byte buf [ ] , int offset ) { return ( readInt ( buf , offset ) & INT_TO_LONG_MASK ) ; } 
public static int readInt ( InputStream is ) throws IOException { byte [ ] buf = new byte [ 4 ] ; is . read ( buf , 0 , 4 ) ; return readInt ( buf , 0 ) ; } 
public static long readUInt ( InputStream is ) throws IOException { return ( readInt ( is ) & INT_TO_LONG_MASK ) ; } 
 public static int readInt ( byte buf [ ] , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) + ( ( buf [ offset + 2 ] & 0xFF ) < < 16 ) + ( ( buf [ offset + 3 ] & 0xFF ) < < 24 ) ; 
public void writeUInt ( long uint ) throws IOException { tbaseStream . write ( Types . writeInt ( ( int ) uint ) ) ; } 
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { tbaseStream . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) throws IOException { tbaseStream . write ( buffer ) ; } 
public void write ( int oneByte ) throws IOException { tbaseStream . write ( oneByte ) ; } 
public void writeLong ( long val ) throws IOException { tbyte [ ] buf = new byte [ 8 ] ; twriteLong ( val , buf , 0 ) ; tbaseStream . write ( buf ) ; } 
public void writeInt ( int val ) throws IOException { tbyte [ ] buf = new byte [ 4 ] ; twriteInt ( val , buf , 0 ) ; tbaseStream . write ( buf ) ; } 
 public static void writeInt ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0xFF ) ; buf [ offset + 1 ] = ( byte ) ( ( val > > > 8 ) & 0xFF ) ; buf [ offset + 2 ] = ( byte ) ( ( val > > > 16 ) & 0xFF ) ; buf [ offset + 3 ] = ( byte ) ( ( val > > > 24 ) & 0xFF ) ; } 
public static byte [ ] writeInt ( int val ) { byte [ ] buf = new byte [ 4 ] ; LEDataOutputStream . writeInt ( val , buf , 0 ) ; return buf ; } 
private void testReadWriteLong ( byte value ) { tbyte [ ] orig = new byte [ 8 ] ; tbyte [ ] dest = new byte [ 8 ] ; tsetArray ( orig , value , 0 , 8 ) ; tlong one = LEDataInputStream . readLong ( orig , 0 ) ; tLEDataOutputStream . writeLong ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
private void testReadWriteInt ( byte value ) { tbyte [ ] orig = new byte [ 4 ] ; tbyte [ ] dest = new byte [ 4 ] ; tfor ( int i = 0 ; i < 4 ; i + + ) { torig [ i ] = 0 ; } tsetArray ( orig , value , 0 , 4 ) ; tint one = LEDataInputStream . readInt ( orig , 0 ) ; tLEDataOutputStream . writeInt ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { tPwDatabaseV4 db = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public void buildSearchIndex ( Context ctx ) { tDebug . startMethodTracing ( " search " ) ; tsearchHelper = new SearchDbHelper ( ctx ) ; tinitSearch ( ) ; tsearchHelper . open ( ) ; tsearchHelper . insertEntry ( pm . getEntries ( ) ) ; tsearchHelper . close ( ) ; tindexBuilt = true ; tDebug . stopMethodTracing ( ) ; } 
public void SaveData ( String filename ) throws IOException , PwDbOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; 
private void populateGlobals ( PwGroup currentGroup ) { tif ( currentGroup = = null ) { tVector < ? extends PwGroup > rootChildGroups = pm . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroup cur = rootChildGroups . elementAt ( i ) ; troot = cur . getParent ( ) ; tgroups . put ( cur . getId ( ) , new WeakReference < PwGroup > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tVector < PwGroup > childGroups = currentGroup . childGroups ; tVector < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . elementAt ( i ) ; tentries . put ( Types . bytestoUUID ( cur . uuid ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . elementAt ( i ) ; 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( Intents . COPY_USERNAME ) ) { tString username = mEntry . getUsername ( ) ; 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( PwEntryV3 . IsNever ( expires ) ) { tpopulateText ( R . id . entry_expires , R . string . never ) ; } else { tpopulateText ( R . id . entry_expires , df . format ( expires ) ) ; } tpopulateText ( R . id . entry_comment , mEntry . additional ) ; 
public static void Launch ( Activity act , PwEntry pw ) { tif ( ! ( pw instanceof PwEntryV3 ) ) { tthrow new RuntimeException ( " Not yet implemented. " ) ; } tIntent i = new Intent ( act , EntryEditActivity . class ) ; ti . putExtra ( KEY_ENTRY , pw . uuid ) ; tact . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroup pw ) { tif ( ! ( pw instanceof PwGroupV3 ) ) { tthrow new RuntimeException ( " Not yet implemented. " ) ; } tIntent i = new Intent ( act , EntryEditActivity . class ) ; tPwGroupV3 parent = ( PwGroupV3 ) pw ; ti . putExtra ( KEY_PARENT , parent . groupId ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
public static void Launch ( Activity act , PwGroup group , int mode ) { tIntent i ; tPwDatabase pm = App . getDB ( ) . pm ; tif ( pm instanceof PwDatabaseV3 ) { ti = new Intent ( act , GroupActivityV3 . class ) ; tif ( group ! = null ) { tPwGroupV3 g = ( PwGroupV3 ) group ; ti . putExtra ( KEY_ENTRY , g . groupId ) ; } } else if ( pm instanceof PwDatabaseV4 ) { tthrow new RuntimeException ( " Not yet implemented. " ) ; } else { tassert ( true ) ; } 
tprotected PwGroupIdV3 retrieveGroupId ( Intent i ) { tint id = i . getIntExtra ( KEY_ENTRY , - 1 ) ; tif ( id = = - 1 ) { treturn null ; } treturn new PwGroupIdV3 ( id ) ; } 
private void filter ( ) { tfilteredEntries = new Vector < PwEntry > ( ) ; tfor ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { tPwEntryV3 entry = ( PwEntryV3 ) mGroup . childEntries . elementAt ( i ) ; 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint updateAmt = tnativeUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; tint finalAmt = nativeDoFinal ( mCtxPtr , output , outputOffset + updateAmt , outputSize - updateAmt ) ; tint out = updateAmt + finalAmt ; tmBuffered = 0 ; treturn out ; } 
tprotected int engineGetOutputSize ( int inputLen ) { tint totalLen = mBuffered + inputLen ; tint padLen = AES_BLOCK_SIZE - ( totalLen % AES_BLOCK_SIZE ) ; } 
private native long nativeInit ( boolean encrypt , byte [ ] key , byte [ ] iv , boolean mPadding ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
tint update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint out = nativeUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; tmBuffered = ( mBuffered + ( ( inputLen - out ) ) ) % AES_BLOCK_SIZE ; treturn out ; 
public abstract byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException ; public abstract void setNumRonuds(long rounds) throws NumberFormatException;} 
public abstract byte [ ] getPasswordKey ( String key ) throws IOException ; public abstract Vector < PwGroup > getGrpRoots ( ) ; public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) throws NumberFormatException ; } 
public abstract Vector < PwGroup > getGrpRoots ( ) ; public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) throws NumberFormatException ; } 
public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) throws NumberFormatException ; } 
public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) throws NumberFormatException ; } 
public abstract long getNumRounds ( ) ; public abstract void setNumRonuds ( long rounds ) throws NumberFormatException ; } 
public abstract void setNumRonuds ( long rounds ) throws NumberFormatException ; } 
public void constructTree ( PwGroupV3 currentGroup ) { return; } 
public PwGroupV3 newGroup ( String name , PwGroupV3 parent ) { return group; } 
private boolean isGroupIdUsed ( int id ) { tfor ( int i = 0 ; i < groups . size ( ) ; i + + ) { tPwGroupV3 group = ( PwGroupV3 ) groups . get ( i ) ; tif ( group . groupId = = id ) { treturn true ; } } treturn false ; } 
public void setNumRonuds ( long rounds ) throws NumberFormatException { tif ( rounds > Integer . MAX_VALUE | | rounds < Integer . MIN_VALUE ) { tthrow new NumberFormatException ( ) ; } tnumKeyEncRounds = ( int ) rounds ; } 
public void parseDB ( Document d ) throws InconsistentDBException { tdoc = d ; tNodeList list = doc . getElementsByTagName ( " Root " ) ; tint len = list . getLength ( ) ; tif ( len < 0 | | len > 1 ) { tthrow new InconsistentDBException ( " Missing root node " ) ; } tNode root = list . item ( 1 ) ; trootGroup = new PwGroupV4 ( root ) ; } 
public void setNumRonuds ( long rounds ) throws NumberFormatException { tnumKeyEncRounds = rounds ; 
public Object clone ( ) { tPwEntry newEntry ; ttry { tnewEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { tassert ( false ) ; tthrow new RuntimeException ( " Clone should be supported " ) ; } tSystem . arraycopy ( uuid , 0 , newEntry . uuid , 0 , uuid . length ) ; tnewEntry . title = title ; tnewEntry . url = url ; tnewEntry . additional = additional ; treturn newEntry ; } 
public void assign ( PwEntry source ) { tSystem . arraycopy ( source . uuid , 0 , uuid , 0 , source . uuid . length ) ; ttitle = source . title ; turl = source . url ; tadditional = source . additional ; } 
public abstract void stampLastAccess ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public void assign ( PwEntry source ) { tif ( ! ( source instanceof PwEntryV3 ) ) { tthrow new RuntimeException ( " DB version mix " ) ; } tsuper . assign ( source ) ; tPwEntryV3 src = ( PwEntryV3 ) source ; tassign ( src ) ; 
private void assign ( PwEntryV3 source ) { tgroupId = source . groupId ; timageId = source . imageId ; tusername = source . username ; tint passLen = source . password . length ; tpassword = new byte [ passLen ] ; tSystem . arraycopy ( source . password , 0 , password , 0 , passLen ) ; ttCreation = ( PwDate ) source . tCreation . clone ( ) ; ttLastMod = ( PwDate ) source . tLastMod . clone ( ) ; ttLastAccess = ( PwDate ) source . tLastAccess . clone ( ) ; ttExpire = ( PwDate ) source . tExpire . clone ( ) ; tbinaryDesc = source . binaryDesc ; tif ( source . binaryData ! = null ) { tint descLen = source . binaryData . length ; tbinaryData = new byte [ descLen ] ; tSystem . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } tparent = source . parent ; 
public Object clone ( ) { tPwEntryV3 newEntry = ( PwEntryV3 ) super . clone ( ) ; tint passLen = password . length ; tpassword = new byte [ passLen ] ; tSystem . arraycopy ( password , 0 , newEntry . password , 0 , passLen ) ; tnewEntry . tCreation = ( PwDate ) tCreation . clone ( ) ; tnewEntry . tLastMod = ( PwDate ) tLastMod . clone ( ) ; tnewEntry . tLastAccess = ( PwDate ) tLastAccess . clone ( ) ; tnewEntry . tExpire = ( PwDate ) tExpire . clone ( ) ; tnewEntry . binaryDesc = binaryDesc ; tif ( binaryData ! = null ) { tint descLen = binaryData . length ; tnewEntry . binaryData = new byte [ descLen ] ; tSystem . arraycopy ( binaryData , 0 , newEntry . binaryData , 0 , descLen ) ; } tnewEntry . parent = parent ; treturn newEntry ; } 
public void stampLastAccess ( ) { tCalendar cal = Calendar . getInstance ( ) ; ttLastAccess = new PwDate ( cal . getTime ( ) ) ; 
public void assign ( PwEntry source ) { tsuper . assign ( source ) ; tif ( ! ( source instanceof PwEntryV4 ) ) { tthrow new RuntimeException ( " DB version mix. " ) ; } tPwEntryV4 src = ( PwEntryV4 ) source ; tassign ( src ) ; } 
private void assign ( PwEntryV4 source ) { tnode = source . node ; } 
public Object clone ( ) { tPwEntryV4 newEntry = ( PwEntryV4 ) super . clone ( ) ; treturn newEntry ; } 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; } 
public boolean equals ( Object compare ) { tif ( ! ( compare instanceof PwGroupIdV3 ) ) { treturn false ; } tPwGroupIdV3 cmp = ( PwGroupIdV3 ) compare ; treturn id = = cmp . id ; } 
public int hashCode ( ) { tInteger i = new Integer ( id ) ; treturn i . hashCode ( ) ; } 
public boolean equals ( Object id ) { tif ( ! ( id instanceof PwGroupIdV4 ) ) { treturn false ; } tPwGroupIdV4 v4 = ( PwGroupIdV4 ) id ; treturn uuid . equals ( v4 . uuid ) ; } 
public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } 
public void buildChildGroupsRecursive ( Vector < PwGroup > list ) { tlist . add ( this ) ; tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroupV4 child = ( PwGroupV4 ) childGroups . get ( i ) ; 
public void buildChildEntriesRecursive ( Vector < PwEntry > list ) { tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tlist . add ( childEntries . get ( i ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroupV4 child = ( PwGroupV4 ) childGroups . get ( i ) ; 
public abstract void addEntry ( ) ; @Override public void run ( ) { taddEntry ( ) ; } 
public void run ( ) { taddEntry ( ) ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public void addEntry ( ) { tPwGroupV3 parent = mEntry . getParent ( ) ; 
public void run ( ) { tPwDatabaseV3 pm = ( PwDatabaseV3 ) mDb . pm ; } 
public void run ( ) { tif ( mSuccess ) { } 
public void run ( ) { save.run(); 
public void run ( ) { 
public void run ( ) { tif ( mSuccess ) { tif ( mDb . indexBuilt ) { tSearchDbHelper dbHelper = mDb . searchHelper ; tdbHelper . open ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { tif ( mSuccess ) { super.run(); 
public void run ( ) { tif ( mSuccess ) { } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwDbOutputException { PwEntryV3 pe = (PwEntryV3) mPM.entries.get(i); 
private void sortGroupsForOutput ( ) { tVector < PwGroup > groupList = new Vector < PwGroup > ( ) ; } 
private void sortGroup ( PwGroupV3 group , Vector < PwGroup > groupList ) { sortGroup((PwGroupV3) group.childGroups.get(i), groupList); 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public void insertEntry ( Vector < ? extends PwEntry > entries ) { tmDb . beginTransaction ( ) ; ttry { tfor ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public PwGroupV3 search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroupV3 group = new PwGroupV3 ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new Vector < PwEntry > ( ) ; tgroup . setGroups ( new Vector < PwGroup > ( ) ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntryV3 entry = ( PwEntryV3 ) db . entries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
tprotected View onCreateDialogView ( ) { tView view = super . onCreateDialogView ( ) ; tmRoundsView = ( TextView ) view . findViewById ( R . id . rounds ) ; tDatabase db = App . getDB ( ) ; tmPM = db . pm ; tlong numRounds = mPM . getNumRounds ( ) ; tmRoundsView . setText ( Long . toString ( numRounds ) ) ; treturn view ; } 
public void run ( ) { tif ( mSuccess ) { tOnPreferenceChangeListener listner = getOnPreferenceChangeListener ( ) ; tif ( listner ! = null ) { tlistner . onPreferenceChange ( RoundsPreference . this , null ) ; } } else { tdisplayMessage ( mCtx ) ; tmPM . setNumRonuds ( mOldRounds ) ; } tsuper . run ( ) ; } 
public int read ( ) throws IOException { if ( finished ) { return ( ( o_buffer = = null ) | | ( index = = o_buffer . length ) ) ? - 1 : o_buffer [ index + + ] & 0xFF ; } if ( ( o_buffer ! = null ) & & ( index < o_buffer . length ) ) { return o_buffer [ index + + ] & 0xFF ; } index = 0 ; o_buffer = null ; int num_read ; while ( o_buffer = = null ) { if ( ( num_read = in . read ( i_buffer ) ) = = - 1 ) { try { o_buffer = cipher . doFinal ( ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } finished = true ; break ; } o_buffer = cipher . update ( i_buffer , 0 , num_read ) ; } return read ( ) ; } 
public int read ( byte [ ] b ) throws IOException { return read ( b , 0 , b . length ) ; } 
public int read ( byte [ ] b , int off , int len ) throws IOException { if ( in = = null ) { throw new NullPointerException ( " Underlying input stream is null " ) ; } int read_b ; int i ; for ( i = 0 ; i < len ; i + + ) { if ( ( read_b = read ( ) ) = = - 1 ) { return ( i = = 0 ) ? - 1 : i ; } if ( b ! = null ) { b [ off + i ] = ( byte ) read_b ; } } return i ; } 
public long skip ( long ) throws IOException { long i = 0 ; int available = available ( ) ; if ( available < ) { = available ; } while ( ( i < ) & & ( read ( ) ! = - 1 ) ) { i + + ; } return i ; } 
public int available ( ) throws IOException { return 0 ; } 
public void close ( ) throws IOException { in . close ( ) ; try { cipher . doFinal ( ) ; 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tmPE = ( PwEntryV3 ) TestData . GetTest1 ( getContext ( ) ) . entries . get ( 0 ) ; 
public void testPassword ( ) throws UnsupportedEncodingException { tString sPass = " 12345 " ; tbyte [ ] password = sPass . getBytes ( " UTF-8 " ) ; tassertArrayEquals ( password , mPE . getPasswordBytes ( ) ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tmPG = ( PwGroupV3 ) TestData . GetTest1 ( getContext ( ) ) . getGroups ( ) . get ( 0 ) ; 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwDatabaseV3 pm = ( PwDatabaseV3 ) db . pm ; tPwGroup group1 = getGroup ( pm , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
public void testDetection ( ) throws IOException , InvalidDBSignatureException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; ttry { tImporterFactory . createImporter ( is ) ; } catch ( Kdb4Exception e ) { treturn ; } tis . close ( ) ; tassertTrue ( false ) ; 
public void testReadHeader ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; tassertEquals ( 6000 , db . numKeyEncRounds ) ; tassertTrue ( db . dataCipher . equals ( CipherFactory . AES_CIPHER ) ) ; tis . close ( ) ; 
public static PwDatabaseV3 GetTest1 ( Context ctx ) throws Exception { tif ( mDb1 = = null ) { tGetDb1 ( ctx ) ; } treturn ( PwDatabaseV3 ) mDb1 . pm ; } 
public void testHeader ( ) throws PwDbOutputException , IOException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3Output ( mPM , bActual , PwDbV3Output . DEBUG ) ; PwDbHeaderV3 header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutputV3 outExpected = new PwDbHeaderOutputV3 ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . toByteArray ( ) , bActual . toByteArray ( ) ) ; } 
public void parseDB ( Document d ) throws InconsistentDBException { tdoc = d ; tNodeList list = doc . getElementsByTagName ( " Root " ) ; tint len = list . getLength ( ) ; tif ( len < 0 | | len > 1 ) { tthrow new InconsistentDBException ( " Missing root node " ) ; } tNode root = list . item ( 0 ) ; trootGroup = new PwGroupV4 ( root ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { tPwDatabaseV4 db = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
public static String encodeString ( String s ) { return new String ( encode ( s . getBytes ( ) ) ) ; } 
public static String encodeLines ( byte [ ] in ) { return encodeLines ( in , 0 , in . length , 76 , systemLineSeparator ) ; } 
public static String encodeLines ( byte [ ] in , int iOff , int iLen , int lineLen , String lineSeparator ) { int blockLen = ( lineLen * 3 ) / 4 ; if ( blockLen < = 0 ) throw new IllegalArgumentException ( ) ; int lines = ( iLen + blockLen - 1 ) / blockLen ; int bufLen = ( ( iLen + 2 ) / 3 ) * 4 + lines * lineSeparator . length ( ) ; StringBuilder buf = new StringBuilder ( bufLen ) ; int ip = 0 ; while ( ip < iLen ) { int l = Math . min ( iLen - ip , blockLen ) ; buf . append ( encode ( in , iOff + ip , l ) ) ; buf . append ( lineSeparator ) ; ip + = l ; } return buf . toString ( ) ; } 
public static char [ ] encode ( byte [ ] in ) { return encode ( in , 0 , in . length ) ; } 
public static char [ ] encode ( byte [ ] in , int iLen ) { return encode ( in , 0 , iLen ) ; } 
public static char [ ] encode ( byte [ ] in , int iOff , int iLen ) { int oDataLen = ( iLen * 4 + 2 ) / 3 ; output length without padding int oLen = ((iLen+2)/3)*4; output length including padding char[] out = new char[oLen]; int ip = iOff; int iEnd = iOff + iLen; int op = 0; while (ip < iEnd) { int i0 = in[ip++] & 0xff; int i1 = ip < iEnd ? in[ip++] & 0xff : 0; int i2 = ip < iEnd ? in[ip++] & 0xff : 0; int o0 = i0 >>> 2; int o1 = ((i0 & 3) << 4) | (i1 >>> 4); int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6); int o3 = i2 & 0x3F; out[op++] = map1[o0]; out[op++] = map1[o1]; out[op] = op < oDataLen ? map1[o2] : '='; op++; out[op] = op < oDataLen ? map1[o3] : '='; op++; } return out; } 
public static String decodeString ( String s ) { return new String ( decode ( s ) ) ; } 
public static byte [ ] decodeLines ( String s ) { char [ ] buf = new char [ s . length ( ) ] ; int p = 0 ; for ( int ip = 0 ; ip < s . length ( ) ; ip + + ) { char c = s . charAt ( ip ) ; if ( c ! = ' ' & & c ! = '\r' & & c ! = '' & & c ! = '' ) buf [ p + + ] = c ; } return decode ( buf , 0 , p ) ; } 
public static byte [ ] decode ( String s ) { return decode ( s . toCharArray ( ) ) ; } 
public static byte [ ] decode ( char [ ] in ) { return decode ( in , 0 , in . length ) ; } 
public static byte [ ] decode ( char [ ] in , int iOff , int iLen ) { if ( iLen % 4 ! = 0 ) throw new IllegalArgumentException ( " Length of Base64 encoded input string is not a multiple of 4. " ) ; while ( iLen > 0 & & in [ iOff + iLen - 1 ] = = '=' ) iLen - - ; int oLen = ( iLen * 3 ) / 4 ; byte [ ] out = new byte [ oLen ] ; int ip = iOff ; int iEnd = iOff + iLen ; int op = 0 ; while ( ip < iEnd ) { int i0 = in [ ip + + ] ; int i1 = in [ ip + + ] ; int i2 = ip < iEnd ? in [ ip + + ] : 'A' ; int i3 = ip < iEnd ? in [ ip + + ] : 'A' ; if ( i0 > 127 | | i1 > 127 | | i2 > 127 | | i3 > 127 ) throw new IllegalArgumentException ( " Illegal character in Base64 encoded data. " ) ; int b0 = map2 [ i0 ] ; int b1 = map2 [ i1 ] ; int b2 = map2 [ i2 ] ; int b3 = map2 [ i3 ] ; if ( b0 < 0 | | b1 < 0 | | b2 < 0 | | b3 < 0 ) throw new IllegalArgumentException ( " Illegal character in Base64 encoded data. " ) ; int o0 = ( b0 < < 2 ) | ( b1 > > > 4 ) ; int o1 = ( ( b1 & 0xf ) < < 4 ) | ( b2 > > > 2 ) ; int o2 = ( ( b2 & 3 ) < < 6 ) | b3 ; out [ op + + ] = ( byte ) o0 ; if ( op < oLen ) out [ op + + ] = ( byte ) o1 ; if ( op < oLen ) out [ op + + ] = ( byte ) o2 ; } return out ; } 
private void populateGlobals ( PwGroup currentGroup ) { tif ( currentGroup = = null ) { tVector < ? extends PwGroup > rootChildGroups = pm . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroup cur = rootChildGroups . elementAt ( i ) ; troot = cur . getParent ( ) ; tgroups . put ( cur . getId ( ) , new WeakReference < PwGroup > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tVector < PwGroup > childGroups = currentGroup . childGroups ; tVector < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . elementAt ( i ) ; tentries . put ( cur . getUUID ( ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . elementAt ( i ) ; 
public static void Launch ( Activity act , PwEntry pw , int pos ) { tIntent i = new Intent ( act , EntryActivity . class ) ; ti . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; ti . putExtra ( KEY_REFRESH_POS , pos ) ; tact . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwEntry pw ) { tif ( ! ( pw instanceof PwEntryV3 ) ) { tthrow new RuntimeException ( " Not yet implemented. " ) ; } tIntent i = new Intent ( act , EntryEditActivity . class ) ; ti . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
public static CrsAlgorithm fromId ( int num ) { tfor ( CrsAlgorithm e : CrsAlgorithm . values ( ) ) { tif ( e . id = = num ) { treturn e ; } } treturn null ; } 
tDate getLastModificationTime ( ) ; tvoid setLastModificationTime ( Date date ) ; tDate getCreationTime ( ) ; tvoid setCreationTime ( Date date ) ; tDate getLastAccessTime ( ) ; tvoid setLastAccessTime ( Date date ) ; tDate getExpiryTime ( ) ; tvoid setExpiryTime ( Date date ) ; tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tvoid setLastModificationTime ( Date date ) ; tDate getCreationTime ( ) ; tvoid setCreationTime ( Date date ) ; tDate getLastAccessTime ( ) ; tvoid setLastAccessTime ( Date date ) ; tDate getExpiryTime ( ) ; tvoid setExpiryTime ( Date date ) ; tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tDate getCreationTime ( ) ; tvoid setCreationTime ( Date date ) ; tDate getLastAccessTime ( ) ; tvoid setLastAccessTime ( Date date ) ; tDate getExpiryTime ( ) ; tvoid setExpiryTime ( Date date ) ; tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tvoid setCreationTime ( Date date ) ; tDate getLastAccessTime ( ) ; tvoid setLastAccessTime ( Date date ) ; tDate getExpiryTime ( ) ; tvoid setExpiryTime ( Date date ) ; tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tDate getLastAccessTime ( ) ; tvoid setLastAccessTime ( Date date ) ; tDate getExpiryTime ( ) ; tvoid setExpiryTime ( Date date ) ; tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tvoid setLastAccessTime ( Date date ) ; tDate getExpiryTime ( ) ; tvoid setExpiryTime ( Date date ) ; tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tDate getExpiryTime ( ) ; tvoid setExpiryTime ( Date date ) ; tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tvoid setExpiryTime ( Date date ) ; tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tboolean expires ( ) ; tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tvoid setExpires ( boolean exp ) ; tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tlong getUsageCount ( ) ; tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tvoid setUsageCount ( long count ) ; tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
tDate getLocationChanged ( ) ; tvoid setLocationChanged ( Date date ) ; } 
public boolean GetProtection ( String field ) { tif ( field . equalsIgnoreCase ( PwDefsV4 . TITLE_FIELD ) ) return protectTitle ; tif ( field . equalsIgnoreCase ( PwDefsV4 . USERNAME_FIELD ) ) return protectUserName ; tif ( field . equalsIgnoreCase ( PwDefsV4 . PASSWORD_FIELD ) ) return protectPassword ; tif ( field . equalsIgnoreCase ( PwDefsV4 . URL_FIELD ) ) return protectUrl ; tif ( field . equalsIgnoreCase ( PwDefsV4 . NOTES_FIELD ) ) return protectNotes ; treturn false ; } 
private void setRandomStreamID ( byte [ ] streamID ) throws IOException { tif ( streamID = = null | | streamID . length ! = 4 ) { tthrow new IOException ( " Invalid stream id. " ) ; } tint id = LEDataInputStream . readInt ( streamID , 0 ) ; tif ( id < 0 | | id > = CrsAlgorithm . count ) { tthrow new IOException ( " Invalid stream id. " ) ; } tinnerRandomStream = CrsAlgorithm . fromId ( id ) ; } 
public Object clone ( ) { tPwEntry newEntry ; ttry { tnewEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { tassert ( false ) ; tthrow new RuntimeException ( " Clone should be supported " ) ; } tnewEntry . setUUID ( getUUID ( ) ) ; tnewEntry . title = title ; tnewEntry . url = url ; tnewEntry . additional = additional ; treturn newEntry ; } 
public void assign ( PwEntry source ) { tsetUUID ( source . getUUID ( ) ) ; ttitle = source . title ; turl = source . url ; tadditional = source . additional ; } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; } 
public void put ( String key , String value ) { twindowSeqPairs . put ( key , value ) ; } 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; } 
public void AddGroup ( PwGroupV4 subGroup , boolean takeOwnership ) { tAddGroup ( subGroup , takeOwnership , false ) ; } 
public void AddGroup ( PwGroupV4 subGroup , boolean takeOwnership , boolean updateLocationChanged ) { tif ( subGroup = = null ) throw new RuntimeException ( " subGroup " ) ; tlistGroups . add ( subGroup ) ; tif ( takeOwnership ) subGroup . parent = this ; tif ( updateLocationChanged ) subGroup . parentGroupLastMod = new Date ( System . currentTimeMillis ( ) ) ; 
public void AddEntry ( PwEntryV4 pe , boolean takeOwnership ) { tAddEntry ( pe , takeOwnership , false ) ; } 
public void AddEntry ( PwEntryV4 pe , boolean takeOwnership , boolean updateLocationChanged ) { tassert ( pe ! = null ) ; tlistEntries . add ( pe ) ; tif ( takeOwnership ) pe . parent = this ; tif ( updateLocationChanged ) pe . setLocationChanged ( new Date ( System . currentTimeMillis ( ) ) ) ; } 
public abstract void addEntry ( ) ; @Override public void run ( ) { taddEntry ( ) ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public void addEntry ( ) { tPwGroupV3 parent = ( PwGroupV3 ) mEntry . getParent ( ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { tdb = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
private void ReadXmlStreamed ( InputStream readerStream ) throws IOException { ttry { tReadDocumentStreamed ( CreatePullParser ( readerStream ) ) ; 
private static XmlPullParser CreatePullParser ( InputStream readerStream ) throws XmlPullParserException { tXmlPullParserFactory xppf = XmlPullParserFactory . newInstance ( ) ; txppf . setNamespaceAware ( false ) ; tXmlPullParser xpp = xppf . newPullParser ( ) ; txpp . setInput ( readerStream , null ) ; treturn xpp ; } 
private KdbContext EndXmlElement ( KdbContext ctx , XmlPullParser xpp ) throws XmlPullParserException { tassert ( xpp . getEventType ( ) = = XmlPullParser . END_TAG ) ; tString name = xpp . getName ( ) ; tif ( ctx = = KdbContext . KeePassFile & & name . equalsIgnoreCase ( ElemDocNode ) ) { treturn KdbContext . Null ; 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate ; ttry { tutcDate = dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { te . printStackTrace ( ) ; tthrow new IOException ( e . getLocalizedMessage ( ) ) ; } treturn utcDate ; 
private void ReadUnknown ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tassert ( false ) ; tif ( xpp . isEmptyElementTag ( ) ) return ; tString unknownName = xpp . getName ( ) ; tProcessNode ( xpp ) ; twhile ( xpp . next ( ) ! = XmlPullParser . END_DOCUMENT ) { tif ( xpp . getEventType ( ) = = XmlPullParser . END_TAG ) break ; tif ( xpp . getEventType ( ) = = XmlPullParser . START_TAG ) continue ; tReadUnknown ( xpp ) ; } tassert ( xpp . getName ( ) = = unknownName ) ; 
private boolean ReadBool ( XmlPullParser xpp , boolean bDefault ) throws IOException , XmlPullParserException { tString str = ReadString ( xpp ) ; tif ( str . equalsIgnoreCase ( " true " ) ) { treturn true ; 
private UUID ReadUuid ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString encoded = ReadString ( xpp ) ; tif ( encoded = = null | | encoded . length ( ) = = 0 ) { treturn PwDatabaseV4 . UUID_ZERO ; } } 
private long ReadUInt ( XmlPullParser xpp , long uDefault ) throws IOException , XmlPullParserException { tlong u ; tu = ReadULong ( xpp , uDefault ) ; tif ( u < 0 | | u > MAX_UINT ) { tthrow new NumberFormatException ( " Outside of the uint size " ) ; } treturn u ; 
private long ReadULong ( XmlPullParser xpp , long uDefault ) throws IOException , XmlPullParserException { tString str = ReadString ( xpp ) ; tlong u ; ttry { tu = Long . parseLong ( str ) ; } catch ( NumberFormatException e ) { tu = uDefault ; } treturn u ; 
private String ReadProtectedString ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tbyte [ ] buf = ProcessNode ( xpp ) ; tif ( buf ! = null ) { ttry { treturn new String ( buf , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { te . printStackTrace ( ) ; tthrow new IOException ( e . getLocalizedMessage ( ) ) ; } } treturn ReadString ( xpp ) ; } 
private byte [ ] ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tbyte [ ] buf = ProcessNode ( xpp ) ; tif ( buf ! = null ) return buf ; tString base64 = ReadString ( xpp ) ; tif ( base64 . length ( ) = = 0 ) return new byte [ 0 ] ; treturn Base64Coder . decode ( base64 ) ; } 
private String ReadString ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tbyte [ ] buf = ProcessNode ( xpp ) ; tif ( buf ! = null ) { ttry { treturn new String ( buf , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { tthrow new IOException ( e . getLocalizedMessage ( ) ) ; } } 
private String ReadStringRaw ( XmlPullParser xpp ) throws XmlPullParserException , IOException { } 
private KdbContext SwitchContext ( KdbContext ctxCurrent , KdbContext ctxNew , tXmlPullParser xpp ) throws XmlPullParserException , IOException { tif ( xpp . isEmptyElementTag ( ) ) { txpp . next ( ) ; } 
private Boolean StringToBoolean ( String str ) { tif ( str = = null | | str . length ( ) = = 0 ) { treturn null ; } tString trimmed = str . trim ( ) ; tif ( trimmed . equalsIgnoreCase ( " true " ) ) { treturn true ; } else if ( trimmed . equalsIgnoreCase ( " false " ) ) { treturn false ; } treturn null ; 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
private ContentValues buildNewEntryContent ( PwEntry entry ) { tContentValues cv = new ContentValues ( ) ; tUUID uuid = entry . getUUID ( ) ; tString uuidStr = uuid . toString ( ) ; tcv . put ( KEY_UUID , uuidStr ) ; tcv . put ( KEY_TITLE , entry . title ) ; tcv . put ( KEY_URL , entry . url ) ; tcv . put ( KEY_COMMENT , entry . additional ) ; treturn cv ; } 
public void deleteEntry ( PwEntry entry ) { tUUID uuid = entry . getUUID ( ) ; tString uuidStr = uuid . toString ( ) ; tmDb . delete ( SEARCH_TABLE , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public PwGroupV3 search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroupV3 group = new PwGroupV3 ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new Vector < PwEntry > ( ) ; tgroup . setGroups ( new Vector < PwGroup > ( ) ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntry entry = ( PwEntry ) db . entries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
public static UUID bytestoUUID ( byte [ ] buf ) { return bytestoUUID ( buf , 0 ) ; } 
public static UUID bytestoUUID ( byte [ ] buf , int offset ) { long lsb = 0 ; for ( int i = 15 ; i > = 8 ; i - - ) { lsb = ( lsb < < 8 ) | ( buf [ i + offset ] & 0xff ) ; } long msb = 0 ; for ( int i = 7 ; i > = 0 ; i - - ) { msb = ( msb < < 8 ) | ( buf [ i + offset ] & 0xff ) ; } return new UUID ( msb , lsb ) ; 
public static byte [ ] UUIDtoBytes ( UUID uuid ) { byte [ ] buf = new byte [ 16 ] ; LEDataOutputStream . writeLong ( uuid . getMostSignificantBits ( ) , buf , 0 ) ; LEDataOutputStream . writeLong ( uuid . getLeastSignificantBits ( ) , buf , 8 ) ; return buf ; } 
public void init ( boolean forEncryption , CipherParameters params ) throws IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public byte returnByte ( byte in ) ; public void reset ( ) ; } 
public void processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) throws DataLengthException ; public void reset ( ) ; } 
private static byte [ ] toByteArray ( String string ) { byte [ ] bytes = new byte [ string . length ( ) ] ; for ( int i = 0 ; i ! = bytes . length ; i + + ) { char ch = string . charAt ( i ) ; bytes [ i ] = ( byte ) ch ; } return bytes ; } 
public byte returnByte ( byte in ) { if ( limitExceeded ( ) ) { throw new MaxBytesExceededException ( " 2^70 byte limit per IV; Change IV " ) ; } if ( index = = 0 ) { salsa20WordToByte ( engineState , keyStream ) ; engineState [ 8 ] + + ; if ( engineState [ 8 ] = = 0 ) { engineState [ 9 ] + + ; } } byte out = ( byte ) ( keyStream [ index ] ^ in ) ; index = ( index + 1 ) & 63 ; return out ; } 
public void processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) { if ( ! initialised ) { throw new IllegalStateException ( getAlgorithmName ( ) + " not initialised " ) ; } if ( ( inOff + len ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + len ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } if ( limitExceeded ( len ) ) { throw new MaxBytesExceededException ( " 2^70 byte limit per IV would be exceeded; Change IV " ) ; } for ( int i = 0 ; i < len ; i + + ) { 
public void reset ( ) { setKey ( workingKey , workingIV ) ; } 
private void salsa20WordToByte ( int [ ] input , byte [ ] output ) { System . arraycopy ( input , 0 , x , 0 , input . length ) ; for ( int i = 0 ; i < 10 ; i + + ) { x [ 4 ] ^ = rotl ( ( x [ 0 ] + x [ 12 ] ) , 7 ) ; x [ 8 ] ^ = rotl ( ( x [ 4 ] + x [ 0 ] ) , 9 ) ; x [ 12 ] ^ = rotl ( ( x [ 8 ] + x [ 4 ] ) , 13 ) ; x [ 0 ] ^ = rotl ( ( x [ 12 ] + x [ 8 ] ) , 18 ) ; x [ 9 ] ^ = rotl ( ( x [ 5 ] + x [ 1 ] ) , 7 ) ; x [ 13 ] ^ = rotl ( ( x [ 9 ] + x [ 5 ] ) , 9 ) ; x [ 1 ] ^ = rotl ( ( x [ 13 ] + x [ 9 ] ) , 13 ) ; x [ 5 ] ^ = rotl ( ( x [ 1 ] + x [ 13 ] ) , 18 ) ; x [ 14 ] ^ = rotl ( ( x [ 10 ] + x [ 6 ] ) , 7 ) ; x [ 2 ] ^ = rotl ( ( x [ 14 ] + x [ 10 ] ) , 9 ) ; x [ 6 ] ^ = rotl ( ( x [ 2 ] + x [ 14 ] ) , 13 ) ; x [ 10 ] ^ = rotl ( ( x [ 6 ] + x [ 2 ] ) , 18 ) ; x [ 3 ] ^ = rotl ( ( x [ 15 ] + x [ 11 ] ) , 7 ) ; x [ 7 ] ^ = rotl ( ( x [ 3 ] + x [ 15 ] ) , 9 ) ; x [ 11 ] ^ = rotl ( ( x [ 7 ] + x [ 3 ] ) , 13 ) ; x [ 15 ] ^ = rotl ( ( x [ 11 ] + x [ 7 ] ) , 18 ) ; x [ 1 ] ^ = rotl ( ( x [ 0 ] + x [ 3 ] ) , 7 ) ; x [ 2 ] ^ = rotl ( ( x [ 1 ] + x [ 0 ] ) , 9 ) ; x [ 3 ] ^ = rotl ( ( x [ 2 ] + x [ 1 ] ) , 13 ) ; x [ 0 ] ^ = rotl ( ( x [ 3 ] + x [ 2 ] ) , 18 ) ; x [ 6 ] ^ = rotl ( ( x [ 5 ] + x [ 4 ] ) , 7 ) ; x [ 7 ] ^ = rotl ( ( x [ 6 ] + x [ 5 ] ) , 9 ) ; x [ 4 ] ^ = rotl ( ( x [ 7 ] + x [ 6 ] ) , 13 ) ; x [ 5 ] ^ = rotl ( ( x [ 4 ] + x [ 7 ] ) , 18 ) ; x [ 11 ] ^ = rotl ( ( x [ 10 ] + x [ 9 ] ) , 7 ) ; x [ 8 ] ^ = rotl ( ( x [ 11 ] + x [ 10 ] ) , 9 ) ; x [ 9 ] ^ = rotl ( ( x [ 8 ] + x [ 11 ] ) , 13 ) ; x [ 10 ] ^ = rotl ( ( x [ 9 ] + x [ 8 ] ) , 18 ) ; x [ 12 ] ^ = rotl ( ( x [ 15 ] + x [ 14 ] ) , 7 ) ; x [ 13 ] ^ = rotl ( ( x [ 12 ] + x [ 15 ] ) , 9 ) ; x [ 14 ] ^ = rotl ( ( x [ 13 ] + x [ 12 ] ) , 13 ) ; x [ 15 ] ^ = rotl ( ( x [ 14 ] + x [ 13 ] ) , 18 ) ; } int offset = 0 ; for ( int i = 0 ; i < stateSize ; i + + ) { intToByteLittle ( x [ i ] + input [ i ] , output , offset ) ; offset + = 4 ; } for ( int i = stateSize ; i < x . length ; i + + ) { 
private byte [ ] intToByteLittle ( int x , byte [ ] out , int off ) { out [ off ] = ( byte ) x ; out [ off + 1 ] = ( byte ) ( x > > > 8 ) ; out [ off + 2 ] = ( byte ) ( x > > > 16 ) ; out [ off + 3 ] = ( byte ) ( x > > > 24 ) ; return out ; } 
private int rotl ( int x , int y ) { return ( x < < y ) | ( x > > > - y ) ; } 
private int byteToIntLittle ( byte [ ] x , int offset ) { return ( ( x [ offset ] & 255 ) ) | ( ( x [ offset + 1 ] & 255 ) < < 8 ) | 
private void resetCounter ( ) { cW0 = 0 ; cW1 = 0 ; cW2 = 0 ; } 
private boolean limitExceeded ( ) { cW0 + + ; if ( cW0 = = 0 ) { cW1 + + ; if ( cW1 = = 0 ) { cW2 + + ; return ( cW2 & 0x20 ) ! = 0 ; 2^(32 + 32 + 6) } } return false; } 
private boolean limitExceeded ( int len ) { if ( cW0 > = 0 ) { cW0 + = len ; } else { cW0 + = len ; if ( cW0 > = 0 ) { cW1 + + ; if ( cW1 = = 0 ) { cW2 + + ; return ( cW2 & 0x20 ) ! = 0 ; 2^(32 + 32 + 6) } } } return false; } 
public static String [ ] split ( String input , char delimiter ) { Vector v = new Vector ( ) ; boolean moreTokens = true ; String subString ; while ( moreTokens ) { int tokenLocation = input . indexOf ( delimiter ) ; if ( tokenLocation > 0 ) { subString = input . substring ( 0 , tokenLocation ) ; v . addElement ( subString ) ; input = input . substring ( tokenLocation + 1 ) ; } else { moreTokens = false ; v . addElement ( input ) ; } } String [ ] res = new String [ v . size ( ) ] ; for ( int i = 0 ; i ! = res . length ; i + + ) { res [ i ] = ( String ) v . elementAt ( i ) ; } return res ; } 
public void testUUID ( ) { tRandom rnd = new Random ( ) ; tbyte [ ] bUUID = new byte [ 16 ] ; trnd . nextBytes ( bUUID ) ; tUUID uuid = Types . bytestoUUID ( bUUID ) ; tbyte [ ] eUUID = Types . UUIDtoBytes ( uuid ) ; tassertArrayEquals ( " UUID match failed " , bUUID , eUUID ) ; } 
private void assign ( PwEntryV4 source ) { tparent = source . parent ; tuuid = source . uuid ; tstrings = source . strings ; tcustomIconUuid = source . customIconUuid ; tforegroundColor = source . foregroundColor ; tbackgroupColor = source . backgroupColor ; toverrideURL = source . overrideURL ; tautoType = source . autoType ; thistory = source . history ; tparentGroupLastMod = source . parentGroupLastMod ; tcreation = source . creation ; tlastMod = source . lastMod ; tlastAccess = source . lastAccess ; texpireDate = source . expireDate ; texpires = source . expires ; tusageCount = source . usageCount ; 
public void stampLastAccess ( ) { tlastAccess = new Date ( System . currentTimeMillis ( ) ) ; } 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . title . compareToIgnoreCase ( object2 . title ) ; } } } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . title . compareToIgnoreCase ( object2 . title ) ; } } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . title . compareToIgnoreCase ( object2 . title ) ; } } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . title . compareToIgnoreCase ( object2 . title ) ; } } } 
public void run ( ) { tif ( mSuccess ) { } 
private View createGroupView ( int position , View convertView ) { tPwGroupView gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidKeyFileException , InvalidPasswordException , tInvalidDBSignatureException , InvalidDBVersionException { tdb = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tmenu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; } 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tsuper . onCreateMenu ( menu , menuInfo ) ; tmenu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
private void populateGlobals ( PwGroup currentGroup ) { tif ( currentGroup = = null ) { tVector < ? extends PwGroup > rootChildGroups = pm . getGrpRoots ( ) ; tfor ( int i = 0 ; i < rootChildGroups . size ( ) ; i + + ) { tPwGroup cur = rootChildGroups . elementAt ( i ) ; tgroups . put ( cur . getId ( ) , new WeakReference < PwGroup > ( cur ) ) ; tpopulateGlobals ( cur ) ; } treturn ; } tList < PwGroup > childGroups = currentGroup . childGroups ; tList < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . get ( i ) ; tentries . put ( cur . getUUID ( ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . get ( i ) ; 
public static void Launch ( Activity act , PwGroup group , int mode ) { tIntent i ; } 
tprotected PwGroupId retrieveGroupId ( Intent i ) { tString uuid = i . getStringExtra ( KEY_ENTRY ) ; tif ( uuid = = null | | uuid . length ( ) = = 0 ) { treturn null ; } treturn new PwGroupIdV4 ( UUID . fromString ( uuid ) ) ; } 
private void filter ( ) { tfilteredEntries = new Vector < PwEntry > ( ) ; tfor ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { tPwEntry entry = mGroup . childEntries . get ( i ) ; 
private View createGroupView ( int position , View convertView ) { tPwGroupView gv ; tPwGroup group = mGroup . childGroups . get ( position ) ; tgv = PwGroupView . getInstance ( mAct , group ) ; treturn gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; tev = PwEntryView . getInstance ( mAct , filteredEntries . elementAt ( position ) , position ) ; treturn ev ; } 
public void constructTree ( PwGroupV3 currentGroup ) { return; } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract void setUUID ( UUID u ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public void AddGroup ( PwGroupV4 subGroup , boolean takeOwnership , boolean updateLocationChanged ) { tif ( subGroup = = null ) throw new RuntimeException ( " subGroup " ) ; tchildGroups . add ( subGroup ) ; tif ( takeOwnership ) subGroup . parent = this ; tif ( updateLocationChanged ) subGroup . parentGroupLastMod = new Date ( System . currentTimeMillis ( ) ) ; 
public void AddEntry ( PwEntryV4 pe , boolean takeOwnership , boolean updateLocationChanged ) { tassert ( pe ! = null ) ; tchildEntries . add ( pe ) ; tif ( takeOwnership ) pe . parent = this ; tif ( updateLocationChanged ) pe . setLocationChanged ( new Date ( System . currentTimeMillis ( ) ) ) ; } 
public abstract void addEntry ( ) ; @Override public void run ( ) { taddEntry ( ) ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public static Importer createImporter ( InputStream is , boolean debug ) throws Kdb4Exception , InvalidDBSignatureException , IOException { tint sig1 = LEDataInputStream . readInt ( is ) ; tint sig2 = LEDataInputStream . readInt ( is ) ; tif ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV3 ( debug ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV4 ( ) ; 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( PwEntryV3 . IsNever ( expires ) ) { tpopulateText ( R . id . entry_expires , R . string . never ) ; } else { tpopulateText ( R . id . entry_expires , df . format ( expires ) ) ; } tpopulateText ( R . id . entry_comment , mEntry . additional ) ; 
public Object clone ( ) { tPwEntry newEntry ; ttry { tnewEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { tassert ( false ) ; tthrow new RuntimeException ( " Clone should be supported " ) ; } tnewEntry . setUUID ( getUUID ( ) ) ; tnewEntry . url = url ; tnewEntry . additional = additional ; treturn newEntry ; } 
public void assign ( PwEntry source ) { tsetUUID ( source . getUUID ( ) ) ; turl = source . url ; tadditional = source . additional ; } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
private void assign ( PwEntryV3 source ) { ttitle = source . title ; tgroupId = source . groupId ; timageId = source . imageId ; tusername = source . username ; tint passLen = source . password . length ; tpassword = new byte [ passLen ] ; tSystem . arraycopy ( source . password , 0 , password , 0 , passLen ) ; ttCreation = ( PwDate ) source . tCreation . clone ( ) ; ttLastMod = ( PwDate ) source . tLastMod . clone ( ) ; ttLastAccess = ( PwDate ) source . tLastAccess . clone ( ) ; ttExpire = ( PwDate ) source . tExpire . clone ( ) ; tbinaryDesc = source . binaryDesc ; tif ( source . binaryData ! = null ) { tint descLen = source . binaryData . length ; tbinaryData = new byte [ descLen ] ; tSystem . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } tparent = source . parent ; 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } } } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } private class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new EntryNameComparator ( ) ) ; } private class EntryNameComparator implements Comparator < PwEntry > { @Override public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } } } 
public int compare ( PwEntry object1 , PwEntry object2 ) { treturn object1 . getTitle ( ) . compareToIgnoreCase ( object2 . getTitle ( ) ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
private ContentValues buildNewEntryContent ( PwEntry entry ) { tContentValues cv = new ContentValues ( ) ; tUUID uuid = entry . getUUID ( ) ; tString uuidStr = uuid . toString ( ) ; tcv . put ( KEY_UUID , uuidStr ) ; tcv . put ( KEY_TITLE , entry . getTitle ( ) ) ; tcv . put ( KEY_URL , entry . url ) ; tcv . put ( KEY_COMMENT , entry . additional ) ; treturn cv ; } 
private void fillData ( ) { tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( PwEntryV3 . IsNever ( expires ) ) { tpopulateText ( R . id . entry_expires , R . string . never ) ; } else { tpopulateText ( R . id . entry_expires , df . format ( expires ) ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public Object clone ( ) { tPwEntry newEntry ; ttry { tnewEntry = ( PwEntry ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { tassert ( false ) ; tthrow new RuntimeException ( " Clone should be supported " ) ; } treturn newEntry ; } 
public void assign ( PwEntry source ) { } public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } } 
private void assign ( PwEntryV3 source ) { ttitle = source . title ; turl = source . url ; tgroupId = source . groupId ; timageId = source . imageId ; tusername = source . username ; tadditional = source . additional ; tuuid = source . uuid ; tint passLen = source . password . length ; tpassword = new byte [ passLen ] ; tSystem . arraycopy ( source . password , 0 , password , 0 , passLen ) ; ttCreation = ( PwDate ) source . tCreation . clone ( ) ; ttLastMod = ( PwDate ) source . tLastMod . clone ( ) ; ttLastAccess = ( PwDate ) source . tLastAccess . clone ( ) ; ttExpire = ( PwDate ) source . tExpire . clone ( ) ; tbinaryDesc = source . binaryDesc ; tif ( source . binaryData ! = null ) { tint descLen = source . binaryData . length ; tbinaryData = new byte [ descLen ] ; tSystem . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } tparent = source . parent ; 
public boolean expires ( ) { treturn ! IsNever ( tExpire . getJDate ( ) ) ; } 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
private ContentValues buildNewEntryContent ( PwEntry entry ) { tContentValues cv = new ContentValues ( ) ; tUUID uuid = entry . getUUID ( ) ; tString uuidStr = uuid . toString ( ) ; tcv . put ( KEY_UUID , uuidStr ) ; tcv . put ( KEY_TITLE , entry . getTitle ( ) ) ; tcv . put ( KEY_URL , entry . getUrl ( ) ) ; tcv . put ( KEY_COMMENT , entry . getNotes ( ) ) ; treturn cv ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidKeyFileException , InvalidPasswordException , InvalidDBSignatureException , Kdb4Exception , InvalidDBVersionException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
private void populateGlobals ( PwGroup currentGroup ) { tList < PwGroup > childGroups = currentGroup . childGroups ; tList < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . get ( i ) ; tentries . put ( cur . getUUID ( ) , new WeakReference < PwEntry > ( cur ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . get ( i ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; treturn true ; 
public static void Launch ( Activity act , PwEntry pw , int pos ) { tIntent i ; tif ( pw instanceof PwEntryV4 ) { ti = new Intent ( act , EntryActivityV4 . class ) ; } else { ti = new Intent ( act , EntryActivity . class ) ; } ti . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; ti . putExtra ( KEY_REFRESH_POS , pos ) ; tact . startActivityForResult ( i , 0 ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tDatabase db = App . getDB ( ) ; } 
tprotected void setupEditButtons ( ) { }} 
public static void Launch ( Activity act ) { tLaunch ( act , null ) ; } 
public static void Launch ( Activity act , PwGroup group ) { tIntent i ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; treturn true ; 
tprotected void setupButtons ( ) { taddGroupEnabled = false ; taddEntryEnabled = false ; } 
public void run ( ) { tif ( mSuccess ) { tGroupActivity . Launch ( PasswordActivity . this ) ; 
public abstract byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException ; public abstract boolean appSettingsEnabled();} 
public abstract byte [ ] getPasswordKey ( String key ) throws IOException ; public abstract Vector < PwGroup > getGrpRoots ( ) ; public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract Vector < PwGroup > getGrpRoots ( ) ; public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract Vector < PwGroup > getGroups ( ) ; public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract Vector < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public void setNumRounds ( long rounds ) throws NumberFormatException { tif ( rounds > Integer . MAX_VALUE | | rounds < Integer . MIN_VALUE ) { tthrow new NumberFormatException ( ) ; } tnumKeyEncRounds = ( int ) rounds ; } 
public void setNumRounds ( long rounds ) throws NumberFormatException { tnumKeyEncRounds = rounds ; 
public void run ( ) { tif ( mSuccess ) { tOnPreferenceChangeListener listner = getOnPreferenceChangeListener ( ) ; tif ( listner ! = null ) { tlistner . onPreferenceChange ( RoundsPreference . this , null ) ; } } else { tdisplayMessage ( mCtx ) ; tmPM . setNumRounds ( mOldRounds ) ; } tsuper . run ( ) ; } 
private void launchGroup ( ) { tGroupActivity . Launch ( mAct , mPw ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) throws IOException , InvalidDBException { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) throws IOException , FileNotFoundException , InvalidDBException { tLoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) throws IOException , FileNotFoundException , InvalidDBException { tLoadData ( ctx , filename , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , FileNotFoundException , InvalidDBException { tFileInputStream fis ; tfis = new FileInputStream ( filename ) ; tLoadData ( ctx , fis , password , keyfile , status , debug ) ; tmFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws IOException , InvalidDBException { tLoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( ArcFourException e ) { tfinish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; treturn ; } catch ( InvalidPasswordException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidDBSignatureException e ) { tfinish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; treturn ; } catch ( InvalidDBVersionException e ) { tfinish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; treturn ; } catch ( InvalidDBException e ) { tfinish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; treturn ; } tfinish ( true ) ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidDBException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) tthrows IOException , InvalidDBException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , String keyfile , UpdateStatus status ) tthrows IOException , InvalidDBException ; } 
public static Importer createImporter ( InputStream is ) throws InvalidDBSignatureException , IOException { treturn createImporter ( is , false ) ; } 
public static Importer createImporter ( InputStream is , boolean debug ) throws InvalidDBSignatureException , IOException { tint sig1 = LEDataInputStream . readInt ( is ) ; tint sig2 = LEDataInputStream . readInt ( is ) ; tif ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV3 ( debug ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV4 ( ) ; } tthrow new InvalidDBSignatureException ( ) ; 
public PwDatabase openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidDBException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile ) throws IOException , InvalidDBException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
public void testDetection ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporter importer = ImporterFactory . createImporter ( is ) ; tis . close ( ) ; tassertTrue ( importer instanceof ImporterV4 ) ; 
public void assign ( PwEntry source ) { timageId = source . imageId ; } 
public abstract void stampLastAccess ( ) ; public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract UUID getUUID ( ) ; public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract void setUUID ( UUID u ) ; public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract String getTitle ( ) ; public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract String getUsername ( ) ; public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract String getPassword ( ) ; public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract String getUrl ( ) ; public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract String getNotes ( ) ; public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract Date getCreate ( ) ; public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract Date getMod ( ) ; public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract Date getAccess ( ) ; public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract Date getExpire ( ) ; public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract boolean expires ( ) ; public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract PwGroup getParent ( ) ; public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } @Override public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } } 
public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntry other = ( PwEntry ) obj ; tif ( imageId ! = other . imageId ) treturn false ; treturn true ; } 
private void assign ( PwEntryV3 source ) { ttitle = source . title ; turl = source . url ; tgroupId = source . groupId ; tusername = source . username ; tadditional = source . additional ; tuuid = source . uuid ; tint passLen = source . password . length ; tpassword = new byte [ passLen ] ; tSystem . arraycopy ( source . password , 0 , password , 0 , passLen ) ; ttCreation = ( PwDate ) source . tCreation . clone ( ) ; ttLastMod = ( PwDate ) source . tLastMod . clone ( ) ; ttLastAccess = ( PwDate ) source . tLastAccess . clone ( ) ; ttExpire = ( PwDate ) source . tExpire . clone ( ) ; tbinaryDesc = source . binaryDesc ; tif ( source . binaryData ! = null ) { tint descLen = source . binaryData . length ; tbinaryData = new byte [ descLen ] ; tSystem . arraycopy ( source . binaryData , 0 , binaryData , 0 , descLen ) ; } tparent = source . parent ; 
public int hashCode ( ) { tfinal int prime = 31 ; tint result = 1 ; tresult = prime * result + getOuterType ( ) . hashCode ( ) ; tresult = prime * result + ( ( defaultSequence = = null ) ? 0 : defaultSequence . hashCode ( ) ) ; tresult = prime * result + ( enabled ? 1231 : 1237 ) ; tresult = prime * result + ( int ) ( obfuscationOptions ^ ( obfuscationOptions > > > 32 ) ) ; tresult = prime * result + ( ( windowSeqPairs = = null ) ? 0 : windowSeqPairs . hashCode ( ) ) ; treturn result ; } 
public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tAutoType other = ( AutoType ) obj ; tif ( ! getOuterType ( ) . equals ( other . getOuterType ( ) ) ) treturn false ; tif ( defaultSequence = = null ) { tif ( other . defaultSequence ! = null ) treturn false ; } else if ( ! defaultSequence . equals ( other . defaultSequence ) ) treturn false ; tif ( enabled ! = other . enabled ) treturn false ; tif ( obfuscationOptions ! = other . obfuscationOptions ) treturn false ; tif ( windowSeqPairs = = null ) { tif ( other . windowSeqPairs ! = null ) treturn false ; } else if ( ! windowSeqPairs . equals ( other . windowSeqPairs ) ) treturn false ; treturn true ; } 
public void assign ( PwEntry source ) { tif ( ! ( source instanceof PwEntryV4 ) ) { tthrow new RuntimeException ( " DB version mix. " ) ; } tsuper . assign ( source ) ; tPwEntryV4 src = ( PwEntryV4 ) source ; tassign ( src ) ; } 
private void assign ( PwEntryV4 source ) { tparent = source . parent ; tuuid = source . uuid ; tstrings = source . strings ; tbinaries = source . binaries ; tcustomIconUuid = source . customIconUuid ; tforegroundColor = source . foregroundColor ; tbackgroupColor = source . backgroupColor ; toverrideURL = source . overrideURL ; tautoType = source . autoType ; thistory = source . history ; tparentGroupLastMod = source . parentGroupLastMod ; tcreation = source . creation ; tlastMod = source . lastMod ; tlastAccess = source . lastAccess ; texpireDate = source . expireDate ; texpires = source . expires ; tusageCount = source . usageCount ; turl = source . url ; tadditional = source . additional ; 
public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( ! super . equals ( obj ) ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwEntryV4 other = ( PwEntryV4 ) obj ; tif ( additional = = null ) { tif ( other . additional ! = null ) treturn false ; } else if ( ! additional . equals ( other . additional ) ) treturn false ; tif ( autoType = = null ) { tif ( other . autoType ! = null ) treturn false ; } else if ( ! autoType . equals ( other . autoType ) ) treturn false ; tif ( backgroupColor = = null ) { tif ( other . backgroupColor ! = null ) treturn false ; } else if ( ! backgroupColor . equals ( other . backgroupColor ) ) treturn false ; tif ( binaries = = null ) { tif ( other . binaries ! = null ) treturn false ; } else if ( ! binaries . equals ( other . binaries ) ) treturn false ; tif ( creation = = null ) { tif ( other . creation ! = null ) treturn false ; } else if ( ! creation . equals ( other . creation ) ) treturn false ; tif ( customIconUuid = = null ) { tif ( other . customIconUuid ! = null ) treturn false ; } else if ( ! customIconUuid . equals ( other . customIconUuid ) ) treturn false ; tif ( expireDate = = null ) { tif ( other . expireDate ! = null ) treturn false ; } else if ( ! expireDate . equals ( other . expireDate ) ) treturn false ; tif ( expires ! = other . expires ) treturn false ; tif ( foregroundColor = = null ) { tif ( other . foregroundColor ! = null ) treturn false ; } else if ( ! foregroundColor . equals ( other . foregroundColor ) ) treturn false ; tif ( history = = null ) { tif ( other . history ! = null ) treturn false ; } else if ( ! history . equals ( other . history ) ) treturn false ; tif ( lastAccess = = null ) { tif ( other . lastAccess ! = null ) treturn false ; } else if ( ! lastAccess . equals ( other . lastAccess ) ) treturn false ; tif ( lastMod = = null ) { tif ( other . lastMod ! = null ) treturn false ; } else if ( ! lastMod . equals ( other . lastMod ) ) treturn false ; tif ( overrideURL = = null ) { tif ( other . overrideURL ! = null ) treturn false ; } else if ( ! overrideURL . equals ( other . overrideURL ) ) treturn false ; tif ( parent = = null ) { tif ( other . parent ! = null ) treturn false ; } else if ( ! parent . equals ( other . parent ) ) treturn false ; tif ( parentGroupLastMod = = null ) { tif ( other . parentGroupLastMod ! = null ) treturn false ; } else if ( ! parentGroupLastMod . equals ( other . parentGroupLastMod ) ) treturn false ; tif ( strings = = null ) { tif ( other . strings ! = null ) treturn false ; } else if ( ! strings . equals ( other . strings ) ) treturn false ; tif ( url = = null ) { tif ( other . url ! = null ) treturn false ; } else if ( ! url . equals ( other . url ) ) treturn false ; tif ( usageCount ! = other . usageCount ) treturn false ; tif ( uuid = = null ) { tif ( other . uuid ! = null ) treturn false ; } else if ( ! uuid . equals ( other . uuid ) ) treturn false ; treturn true ; } 
public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwGroupV4 other = ( PwGroupV4 ) obj ; tif ( creation = = null ) { tif ( other . creation ! = null ) treturn false ; } else if ( ! creation . equals ( other . creation ) ) treturn false ; tif ( customIconUuid = = null ) { tif ( other . customIconUuid ! = null ) treturn false ; } else if ( ! customIconUuid . equals ( other . customIconUuid ) ) treturn false ; tif ( defaultAutoTypeSequence = = null ) { tif ( other . defaultAutoTypeSequence ! = null ) treturn false ; } else if ( ! defaultAutoTypeSequence . equals ( other . defaultAutoTypeSequence ) ) treturn false ; tif ( enableAutoType = = null ) { tif ( other . enableAutoType ! = null ) treturn false ; } else if ( ! enableAutoType . equals ( other . enableAutoType ) ) treturn false ; tif ( enableSearching = = null ) { tif ( other . enableSearching ! = null ) treturn false ; } else if ( ! enableSearching . equals ( other . enableSearching ) ) treturn false ; tif ( expireDate = = null ) { tif ( other . expireDate ! = null ) treturn false ; } else if ( ! expireDate . equals ( other . expireDate ) ) treturn false ; tif ( expires ! = other . expires ) treturn false ; tif ( iconId ! = other . iconId ) treturn false ; tif ( isExpanded ! = other . isExpanded ) treturn false ; tif ( lastAccess = = null ) { tif ( other . lastAccess ! = null ) treturn false ; } else if ( ! lastAccess . equals ( other . lastAccess ) ) treturn false ; tif ( lastMod = = null ) { tif ( other . lastMod ! = null ) treturn false ; } else if ( ! lastMod . equals ( other . lastMod ) ) treturn false ; tif ( lastTopVisibleEntry = = null ) { tif ( other . lastTopVisibleEntry ! = null ) treturn false ; } else if ( ! lastTopVisibleEntry . equals ( other . lastTopVisibleEntry ) ) treturn false ; tif ( name = = null ) { tif ( other . name ! = null ) treturn false ; } else if ( ! name . equals ( other . name ) ) treturn false ; tif ( notes = = null ) { tif ( other . notes ! = null ) treturn false ; } else if ( ! notes . equals ( other . notes ) ) treturn false ; tif ( parent = = null ) { tif ( other . parent ! = null ) treturn false ; } else if ( ! parent . equals ( other . parent ) ) treturn false ; tif ( parentGroupLastMod = = null ) { tif ( other . parentGroupLastMod ! = null ) treturn false ; } else if ( ! parentGroupLastMod . equals ( other . parentGroupLastMod ) ) treturn false ; tif ( usageCount ! = other . usageCount ) treturn false ; tif ( uuid = = null ) { tif ( other . uuid ! = null ) treturn false ; } else if ( ! uuid . equals ( other . uuid ) ) treturn false ; treturn true ; } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( ArcFourException e ) { tfinish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; treturn ; } catch ( InvalidPasswordException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( InvalidDBSignatureException e ) { tfinish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; treturn ; } catch ( InvalidDBVersionException e ) { tfinish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; treturn ; } catch ( InvalidDBException e ) { tfinish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; treturn ; } catch ( OutOfMemoryError e ) { tfinish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; treturn ; } tfinish ( true ) ; } 
public void testDate ( ) { tPwDate jDate = new PwDate ( System . currentTimeMillis ( ) ) ; tPwDate intermediate = ( PwDate ) jDate . clone ( ) ; tPwDate cDate = new PwDate ( intermediate . getCDate ( ) , 0 ) ; tassertTrue ( " jDate and intermediate not equal " , jDate . equals ( intermediate ) ) ; tassertTrue ( " jDate and cDate not equal " , cDate . equals ( jDate ) ) ; 
public void testAssign ( ) { tPwEntryV4 entry = new PwEntryV4 ( ) ; tentry . additional = " test223 " ; tentry . autoType = entry . new AutoType ( ) ; tentry . autoType . defaultSequence = " 1324 " ; tentry . autoType . enabled = true ; tentry . autoType . obfuscationOptions = 123412432109L ; tentry . autoType . put ( " key " , " value " ) ; tentry . backgroupColor = " blue " ; tentry . binaries . put ( " key1 " , new byte [ ] { 0 , 1 } ) ; tentry . customIconUuid = UUID . randomUUID ( ) ; tentry . foregroundColor = " red " ; tentry . history . add ( new PwEntryV4 ( ) ) ; tentry . imageId = 5 ; tentry . overrideURL = " override " ; tentry . parent = new PwGroupV4 ( ) ; tentry . strings . put ( " key2 " , " value2 " ) ; tentry . url = " http:localhost " ; tentry . uuid = UUID . randomUUID ( ) ; tPwEntryV4 target = new PwEntryV4 ( ) ; ttarget . assign ( entry ) ; tassertTrue ( " Entries do not match. " , entry . equals ( target ) ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tDatabase db = App . getDB ( ) ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tfileDbHelper = new FileDbHelper ( this ) ; tfileDbHelper . open ( ) ; 
public void onTerminate ( ) { tsuper . onTerminate ( ) ; tif ( db ! = null ) { tdb . clear ( ) ; } tif ( fileDbHelper ! = null & & fileDbHelper . isOpen ( ) ) { tfileDbHelper . close ( ) ; 
private void saveFileData ( String fileName , String key ) { tFileDbHelper db = App . fileDbHelper ; tif ( ! mRememberKeyfile ) { tkey = " " ; } tdb . createFile ( fileName , key ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tBoolean value = ( Boolean ) newValue ; tif ( ! value . booleanValue ( ) ) { tFileDbHelper helper = App . fileDbHelper ; thelper . deleteAllKeys ( ) ; } treturn true ; } 
public void onClick ( View v ) { tString filename = Util . getEditText ( FileSelectActivity . this , tR . id . file_filename ) ; createTask.run(); 
public void testDetection ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporter importer = ImporterFactory . createImporter ( is ) ; tassertTrue ( importer instanceof ImporterV4 ) ; tis . close ( ) ; 
public void testParsing ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " 12345 " , " " ) ; tis . close ( ) ; 
public void testAssign ( ) { tPwEntryV4 entry = new PwEntryV4 ( ) ; tentry . additional = " test223 " ; tentry . autoType = entry . new AutoType ( ) ; tentry . autoType . defaultSequence = " 1324 " ; tentry . autoType . enabled = true ; tentry . autoType . obfuscationOptions = 123412432109L ; tentry . autoType . put ( " key " , " value " ) ; tentry . backgroupColor = " blue " ; tentry . binaries . put ( " key1 " , new byte [ ] { 0 , 1 } ) ; tentry . customIconUuid = UUID . randomUUID ( ) ; tentry . foregroundColor = " red " ; tentry . history . add ( new PwEntryV4 ( ) ) ; tentry . imageId = 5 ; tentry . overrideURL = " override " ; tentry . parent = new PwGroupV4 ( ) ; tentry . strings . put ( " key2 " , " value2 " ) ; tentry . url = " http:localhost " ; tentry . uuid = UUID . randomUUID ( ) ; tPwEntryV4 target = new PwEntryV4 ( ) ; ttarget . assign ( entry ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public void buildSearchIndex ( Context ctx ) { tsearchHelper = new SearchDbHelper ( ctx ) ; tinitSearch ( ) ; tsearchHelper . open ( ) ; tsearchHelper . insertEntry ( pm . getEntries ( ) ) ; tsearchHelper . close ( ) ; tindexBuilt = true ; } 
public void notifyDataSetChanged ( ) { tsuper . notifyDataSetChanged ( ) ; tfilter ( ) ; tsort ( ) ; } 
public void notifyDataSetInvalidated ( ) { tsuper . notifyDataSetInvalidated ( ) ; tfilter ( ) ; tsort ( ) ; } 
private void filter ( ) { tfilteredEntries = new ArrayList < PwEntry > ( ) ; tfor ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { tPwEntry entry = mGroup . childEntries . get ( i ) ; 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; tev = PwEntryView . getInstance ( mAct , filteredEntries . get ( position ) , position ) ; treturn ev ; } 
public abstract byte [ ] getMasterKey ( String key , String keyFileName ) throws InvalidKeyFileException , IOException ; public abstract boolean appSettingsEnabled();} 
public abstract byte [ ] getPasswordKey ( String key ) throws IOException ; public abstract List < PwGroup > getGrpRoots ( ) ; public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract List < PwGroup > getGrpRoots ( ) ; public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; } 
public void constructTree ( PwGroupV3 currentGroup ) { } 
public PwGroupV3 newGroup ( String name , PwGroupV3 parent ) { } 
public void removeGroup ( PwGroupV3 group ) { tgroup . parent . childGroups . remove ( group ) ; tgroups . remove ( group ) ; } 
private int newGroupId ( ) { tboolean foundUnusedId = false ; tint newId = 0 ; tRandom random = new Random ( ) ; twhile ( ! foundUnusedId ) { tnewId = random . nextInt ( ) ; tif ( ! isGroupIdUsed ( newId ) ) { tfoundUnusedId = true ; } } treturn newId ; } 
private boolean isGroupIdUsed ( int id ) { tfor ( int i = 0 ; i < groups . size ( ) ; i + + ) { tPwGroupV3 group = ( PwGroupV3 ) groups . get ( i ) ; tif ( group . groupId = = id ) { treturn true ; } } treturn false ; } 
public byte [ ] getMasterKey ( String key , String keyFileName ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyFileName ! = null ) ; tif ( key . length ( ) > 0 & & keyFileName . length ( ) > 0 ) { treturn getCompositeKey ( key , keyFileName ) ; 
public void setNumRounds ( long rounds ) throws NumberFormatException { tif ( rounds > Integer . MAX_VALUE | | rounds < Integer . MIN_VALUE ) { tthrow new NumberFormatException ( ) ; } tnumKeyEncRounds = ( int ) rounds ; } 
public void buildChildGroupsRecursive ( List < PwGroup > list ) { tlist . add ( this ) ; tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroupV4 child = ( PwGroupV4 ) childGroups . get ( i ) ; 
public void buildChildEntriesRecursive ( List < PwEntry > list ) { tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tlist . add ( childEntries . get ( i ) ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroupV4 child = ( PwGroupV4 ) childGroups . get ( i ) ; 
public abstract void addEntry ( ) ; @Override public void run ( ) { taddEntry ( ) ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { save.run(); 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwDbOutputException { PwEntryV3 pe = (PwEntryV3) mPM.entries.get(i); 
private void sortGroupsForOutput ( ) { tList < PwGroup > groupList = new ArrayList < PwGroup > ( ) ; } 
private void sortGroup ( PwGroupV3 group , List < PwGroup > groupList ) { sortGroup((PwGroupV3) group.childGroups.get(i), groupList); 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public void insertEntry ( List < ? extends PwEntry > entries ) { tmDb . beginTransaction ( ) ; ttry { tfor ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public PwGroupV3 search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroupV3 group = new PwGroupV3 ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new ArrayList < PwEntry > ( ) ; tgroup . setGroups ( new ArrayList < PwGroup > ( ) ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntry entry = ( PwEntry ) db . entries . get ( uuid ) . get ( ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
private void populateGlobals ( PwGroup currentGroup ) { tList < PwGroup > childGroups = currentGroup . childGroups ; tList < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . get ( i ) ; tentries . put ( cur . getUUID ( ) , cur ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . get ( i ) ; 
public void clear ( ) { tinitSearch ( ) ; tindexBuilt = false ; tgroups . clear ( ) ; tentries . clear ( ) ; tdirty . clear ( ) ; troot = null ; tpm = null ; tmFilename = null ; tloaded = false ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tDatabase db = App . getDB ( ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SORT , 0 , R . string . sort_name ) ; tmenu . findItem ( MENU_SORT ) . setIcon ( android . R . drawable . ic_menu_sort_by_size ) ; treturn true ; 
public void refreshIfDirty ( ) { tDatabase db = App . getDB ( ) ; tif ( db . dirty . contains ( mGroup ) ) { tdb . dirty . remove ( mGroup ) ; 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; tmenu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; tmenu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; tmenu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_CHANGE_MASTER_KEY , 0 , R . string . menu_change_key ) ; tmenu . findItem ( MENU_CHANGE_MASTER_KEY ) . setIcon ( android . R . drawable . ic_menu_manage ) ; tmenu . add ( 0 , MENU_SORT , 0 , R . string . sort_name ) ; tmenu . findItem ( MENU_SORT ) . setIcon ( android . R . drawable . ic_menu_sort_by_size ) ; treturn true ; } 
public boolean onPrepareOptionsMenu ( Menu menu ) { tif ( ! super . onPrepareOptionsMenu ( menu ) ) { treturn false ; } tsetSortMenuText ( menu ) ; treturn true ; } 
private void toggleSort ( ) { 
public void notifyDataSetChanged ( ) { tsuper . notifyDataSetChanged ( ) ; tfilterAndSort ( ) ; } 
public void notifyDataSetInvalidated ( ) { tsuper . notifyDataSetInvalidated ( ) ; tfilterAndSort ( ) ; } 
private void filterAndSort ( ) { tentriesForViewing = new ArrayList < PwEntry > ( ) ; tfor ( int i = 0 ; i < mGroup . childEntries . size ( ) ; i + + ) { tPwEntry entry = mGroup . childEntries . get ( i ) ; tif ( ! entry . isMetaStream ( ) ) { tentriesForViewing . add ( entry ) ; } } tboolean sortLists = prefs . getBoolean ( mAct . getString ( R . string . sort_key ) , tmAct . getResources ( ) . getBoolean ( R . bool . sort_default ) ) ; tif ( sortLists ) { tgroupsForViewing = new ArrayList < PwGroup > ( mGroup . childGroups ) ; 
private View createGroupView ( int position , View convertView ) { tPwGroupView gv ; tPwGroup group = groupsForViewing . get ( position ) ; tgv = PwGroupView . getInstance ( mAct , group ) ; treturn gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntryView ev ; tev = PwEntryView . getInstance ( mAct , entriesForViewing . get ( position ) , position ) ; treturn ev ; } 
public abstract PwGroup getParent ( ) ; public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } } 
public abstract PwGroupId getId ( ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } } 
public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } 
public abstract void addEntry ( ) ; @Override public void run ( ) { taddEntry ( ) ; } 
public void run ( ) { tif ( mSuccess ) { } 
public void run ( ) { tif ( mSuccess ) { } 
public void run ( ) { tif ( mSuccess ) { tif ( mDb . indexBuilt ) { tSearchDbHelper dbHelper = mDb . searchHelper ; tdbHelper . open ( ) ; 
public void run ( ) { tif ( mSuccess ) { super.run(); 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroupV3 search ( Database db , String qStr ) { tCursor cursor ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { qStr } , null , null , null , null ) ; tPwGroupV3 group = new PwGroupV3 ( ) ; tgroup . name = " Search results " ; tgroup . childEntries = new ArrayList < PwEntry > ( ) ; tgroup . setGroups ( new ArrayList < PwGroup > ( ) ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntry entry = ( PwEntry ) db . entries . get ( uuid ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tif ( isFinishing ( ) ) { treturn ; } tsetResult ( KeePass . EXIT_NORMAL ) ; tmDb = App . getDB ( ) ; 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . group_add_entry , this ) ; tButton addEntry = ( Button ) findViewById ( R . id . add_entry ) ; taddEntry . setVisibility ( INVISIBLE ) ; 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . group_add_entry , this ) ; 
tprotected static byte [ ] getFileKey ( String fileName ) tthrows InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tbyte [ ] key = loadXmlKeyFile ( fileName ) ; tif ( key ! = null ) { treturn key ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tlong fileSize = keyfile . length ( ) ; tif ( fileSize = = 0 ) { tthrow new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { tbyte [ ] outputKey = new byte [ 32 ] ; tif ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn outputKey ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tif ( fis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn hexStringToByteArray ( new String ( hex ) ) ; } tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tInputStream key = getContext ( ) . getAssets ( ) . open ( " keyfile.key " , AssetManager . ACCESS_STREAMING ) ; tFileOutputStream keyFile = new FileOutputStream ( " /sdcard/key " ) ; twhile ( true ) { tbyte [ ] buf = new byte [ 1024 ] ; tint read = key . read ( buf ) ; tif ( read = = - 1 ) { tbreak ; } else { tkeyFile . write ( buf ) ; } } tkeyFile . close ( ) ; 
public void testComposite ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " 12345 " , " /sdcard/key " ) ; tis . close ( ) ; 
public void testKeyfile ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " " , " /sdcard/key " ) ; tis . close ( ) ; 
public byte [ ] getEncoded ( ) throws IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ASN1OutputStream aOut = new ASN1OutputStream ( bOut ) ; aOut . writeObject ( this ) ; return bOut . toByteArray ( ) ; } 
public byte [ ] getEncoded ( String encoding ) throws IOException { if ( encoding . equals ( DER ) ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; DEROutputStream dOut = new DEROutputStream ( bOut ) ; dOut . writeObject ( this ) ; return bOut . toByteArray ( ) ; } return this . getEncoded ( ) ; } 
public int hashCode ( ) { return this . toASN1Object ( ) . hashCode ( ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( ! ( o instanceof DEREncodable ) ) { return false ; } DEREncodable other = ( DEREncodable ) o ; return this . toASN1Object ( ) . equals ( other . getDERObject ( ) ) ; } 
protected int readLength ( ) throws IOException { return readLength ( this , limit ) ; } 
protected void readFully ( byte [ ] bytes ) throws IOException { if ( Streams . readFully ( this , bytes ) ! = bytes . length ) { 
protected DERObject buildObject ( int tag , int tagNo , int length ) throws IOException { boolean isConstructed = ( tag & CONSTRUCTED ) ! = 0 ; DefiniteLengthInputStream defIn = new DefiniteLengthInputStream ( this , length ) ; if ( ( tag & APPLICATION ) ! = 0 ) { return new DERApplicationSpecific ( isConstructed , tagNo , defIn . toByteArray ( ) ) ; } if ( ( tag & TAGGED ) ! = 0 ) { return new BERTaggedObjectParser ( tag , tagNo , defIn ) . getDERObject ( ) ; } if ( isConstructed ) { TODO There are other tags that may be constructed (e.g. BIT_STRING) switch (tagNo) { case OCTET_STRING: yes, people actually do this... return new BERConstructedOctetString(buildDEREncodableVector(defIn).v); case SEQUENCE: if (lazyEvaluate) { return new LazyDERSequence(defIn.toByteArray()); } else { return DERFactory.createSequence(buildDEREncodableVector(defIn)); } case SET: return DERFactory.createSet(buildDEREncodableVector(defIn), false); case EXTERNAL: return new DERExternal(buildDEREncodableVector(defIn)); default: return new DERUnknownTag(true, tagNo, defIn.toByteArray()); } } return createPrimitiveDERObject(tagNo, defIn.toByteArray()); } 
ASN1EncodableVector buildEncodableVector ( ) throws IOException { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; DERObject o ; while ( ( o = readObject ( ) ) ! = null ) { v . add ( o ) ; } return v ; } 
ASN1EncodableVector buildDEREncodableVector ( DefiniteLengthInputStream dIn ) throws IOException { return new ASN1InputStream ( dIn ) . buildEncodableVector ( ) ; } 
public DERObject readObject ( ) throws IOException { int tag = read ( ) ; if ( tag < = 0 ) { if ( tag = = 0 ) { throw new IOException ( " unexpected end-of-contents marker " ) ; } return null ; } calculate tag number int tagNo = readTagNumber(this, tag); boolean isConstructed = (tag & CONSTRUCTED) != 0; calculate length int length = readLength(); if (length < 0) indefinite length method { 
static int readTagNumber ( InputStream s , int tag ) throws IOException { int tagNo = tag & 0x1f ; with tagged object tag number is bottom 5 bits, or stored at the start of the content if (tagNo == 0x1f) { tagNo = 0; int b = s.read(); X.690-0207 8.1.2.4.2 "c) bits 7 to 1 of the first subsequent octet shall not all be zero." if ((b & 0x7f) == 0) Note: -1 will pass { throw new IOException("corrupted stream - invalid high tag number found"); } while ((b >= 0) && ((b & 0x80) != 0)) { tagNo |= (b & 0x7f); tagNo <<= 7; b = s.read(); } if (b < 0) { throw new EOFException("EOF found inside tag value."); } tagNo |= (b & 0x7f); } return tagNo; } 
static int readLength ( InputStream s , int limit ) throws IOException { int length = s . read ( ) ; if ( length < 0 ) { throw new EOFException ( " EOF found when length expected " ) ; } if ( length = = 0x80 ) { return - 1 ; indefinite-length encoding } if (length > 127) { int size = length & 0x7f; if (size > 4) { throw new IOException("DER length more than 4 bytes: " + size); } length = 0; for (int i = 0; i < size; i++) { int next = s.read(); if (next < 0) { throw new EOFException("EOF found reading length"); } length = (length << 8) + next; } if (length < 0) { throw new IOException("corrupted stream - negative length found"); } if (length >= limit) after all we must have read at least 1 byte { throw new IOException("corrupted stream - out of bounds length found"); } } return length; } 
static DERObject createPrimitiveDERObject ( int tagNo , byte [ ] bytes ) { switch ( tagNo ) { 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof ASN1Null ) ) { return false ; } return true ; } 
abstract void encode ( DEROutputStream out ) throws IOException ; public String toString ( ) { return " NULL " ; } } 
public static ASN1Object fromByteArray ( byte [ ] data ) throws IOException { ASN1InputStream aIn = new ASN1InputStream ( data ) ; return ( ASN1Object ) aIn . readObject ( ) ; } 
public final boolean equals ( Object o ) { if ( this = = o ) { return true ; } return ( o instanceof DEREncodable ) & & asn1Equals ( ( ( DEREncodable ) o ) . getDERObject ( ) ) ; } 
public abstract int hashCode ( ) ; abstract void encode ( DEROutputStream out ) throws IOException ; abstract boolean asn1Equals ( DERObject o ) ; } 
abstract void encode ( DEROutputStream out ) throws IOException ; abstract boolean asn1Equals ( DERObject o ) ; } 
public static ASN1OctetString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public static ASN1OctetString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN1OctetString ) { return ( ASN1OctetString ) obj ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } if ( obj instanceof ASN1Sequence ) { Vector v = new Vector ( ) ; Enumeration e = ( ( ASN1Sequence ) obj ) . getObjects ( ) ; while ( e . hasMoreElements ( ) ) { v . addElement ( e . nextElement ( ) ) ; } return new BERConstructedOctetString ( v ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public ASN1OctetStringParser parser ( ) { return this ; } 
public int hashCode ( ) { return Arrays . hashCode ( this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof ASN1OctetString ) ) { return false ; } ASN1OctetString other = ( ASN1OctetString ) o ; return Arrays . areEqual ( string , other . string ) ; } 
abstract void encode ( DEROutputStream out ) throws IOException ; public String toString ( ) { return " # " + new String ( Hex . encode ( string ) ) ; } } 
public String toString ( ) { return " # " + new String ( Hex . encode ( string ) ) ; } 
public void writeObject ( Object obj ) throws IOException { if ( obj = = null ) { 
public static ASN1Sequence getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN1Sequence ) { return ( ASN1Sequence ) obj ; } throw new IllegalArgumentException ( " unknown object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public ASN1SequenceParser parser ( ) { final ASN1Sequence outer = this ; return new ASN1SequenceParser ( ) { 
public DEREncodable readObject ( ) throws IOException { if ( index = = max ) { return null ; } DEREncodable obj = getObjectAt ( index + + ) ; if ( obj instanceof ASN1Sequence ) { return ( ( ASN1Sequence ) obj ) . parser ( ) ; } if ( obj instanceof ASN1Set ) { return ( ( ASN1Set ) obj ) . parser ( ) ; } return obj ; } 
public DEREncodable getObjectAt ( int index ) { return ( DEREncodable ) seq . elementAt ( index ) ; } 
public int hashCode ( ) { Enumeration e = this . getObjects ( ) ; int hashCode = size ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; hashCode * = 17 ; if ( o ! = null ) { hashCode ^ = o . hashCode ( ) ; } } return hashCode ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof ASN1Sequence ) ) { return false ; } ASN1Sequence other = ( ASN1Sequence ) o ; if ( this . size ( ) ! = other . size ( ) ) { return false ; } Enumeration s1 = this . getObjects ( ) ; Enumeration s2 = other . getObjects ( ) ; while ( s1 . hasMoreElements ( ) ) { DERObject o1 = ( ( DEREncodable ) s1 . nextElement ( ) ) . getDERObject ( ) ; DERObject o2 = ( ( DEREncodable ) s2 . nextElement ( ) ) . getDERObject ( ) ; if ( o1 = = o2 | | ( o1 ! = null & & o1 . equals ( o2 ) ) ) { continue ; } return false ; } return true ; } 
protected void addObject ( DEREncodable obj ) { seq . addElement ( obj ) ; } 
abstract void encode ( DEROutputStream out ) throws IOException ; public String toString ( ) { return seq . toString ( ) ; } } 
public String toString ( ) { return seq . toString ( ) ; } 
public static ASN1Set getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN1Set ) { return ( ASN1Set ) obj ; } throw new IllegalArgumentException ( " unknown object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public DEREncodable getObjectAt ( int index ) { return ( DEREncodable ) set . elementAt ( index ) ; } 
public ASN1SetParser parser ( ) { final ASN1Set outer = this ; return new ASN1SetParser ( ) { 
public DEREncodable readObject ( ) throws IOException { if ( index = = max ) { return null ; } DEREncodable obj = getObjectAt ( index + + ) ; if ( obj instanceof ASN1Sequence ) { return ( ( ASN1Sequence ) obj ) . parser ( ) ; } if ( obj instanceof ASN1Set ) { return ( ( ASN1Set ) obj ) . parser ( ) ; } return obj ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof ASN1Set ) ) { return false ; } ASN1Set other = ( ASN1Set ) o ; if ( this . size ( ) ! = other . size ( ) ) { return false ; } Enumeration s1 = this . getObjects ( ) ; Enumeration s2 = other . getObjects ( ) ; while ( s1 . hasMoreElements ( ) ) { DERObject o1 = ( ( DEREncodable ) s1 . nextElement ( ) ) . getDERObject ( ) ; DERObject o2 = ( ( DEREncodable ) s2 . nextElement ( ) ) . getDERObject ( ) ; if ( o1 = = o2 | | ( o1 ! = null & & o1 . equals ( o2 ) ) ) { continue ; } return false ; } return true ; } 
private boolean lessThanOrEqual ( byte [ ] a , byte [ ] b ) { if ( a . length < = b . length ) { 
private byte [ ] getEncoded ( DEREncodable obj ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ASN1OutputStream aOut = new ASN1OutputStream ( bOut ) ; try { aOut . writeObject ( obj ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " cannot encode object added to SET " ) ; } return bOut . toByteArray ( ) ; } 
protected void sort ( ) { if ( set . size ( ) > 1 ) { 
protected void addObject ( DEREncodable obj ) { set . addElement ( obj ) ; } 
abstract void encode ( DEROutputStream out ) throws IOException ; public String toString ( ) { return set . toString ( ) ; } } 
public String toString ( ) { return set . toString ( ) ; } 
public DEREncodable readObject ( ) throws IOException ; } 
private static int findLimit ( InputStream in ) { if ( in instanceof DefiniteLengthInputStream ) { return ( ( DefiniteLengthInputStream ) in ) . getRemaining ( ) ; } return Integer . MAX_VALUE ; } 
public DEREncodable readObject ( ) throws IOException { int tag = _in . read ( ) ; if ( tag = = - 1 ) { return null ; } turn of looking for "00" while we resolve the tag set00Check(false); calculate tag number int tagNo = ASN1InputStream.readTagNumber(_in, tag); boolean isConstructed = (tag & DERTags.CONSTRUCTED) != 0; calculate length int length = ASN1InputStream.readLength(_in, _limit); if (length < 0) indefinite length method { 
private void set00Check ( boolean enabled ) { if ( _in instanceof IndefiniteLengthInputStream ) { 
ASN1EncodableVector readVector ( ) throws IOException { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; DEREncodable obj ; while ( ( obj = readObject ( ) ) ! = null ) { v . add ( obj . getDERObject ( ) ) ; } return v ; } 
static public ASN1TaggedObject getInstance ( ASN1TaggedObject obj , boolean explicit ) { if ( explicit ) { return ( ASN1TaggedObject ) obj . getObject ( ) ; } throw new IllegalArgumentException ( " implicitly tagged tagged object " ) ; } 
static public ASN1TaggedObject getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN1TaggedObject ) { return ( ASN1TaggedObject ) obj ; } throw new IllegalArgumentException ( " unknown object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public int hashCode ( ) { int code = tagNo ; TODO: actually this is wrong - the problem is that a re-encoded object may end up with a different hashCode due to implicit tagging. As implicit tagging is ambiguous if a sequence is involved it seems the only correct method for both equals and hashCode is to compare the encodings... if (obj != null) { code ^= obj.hashCode(); } return code; } 
public boolean isExplicit ( ) { return explicit ; } 
public DEREncodable getObjectParser ( int tag , boolean isExplicit ) { switch ( tag ) { case DERTags . SET : return ASN1Set . getInstance ( this , isExplicit ) . parser ( ) ; case DERTags . SEQUENCE : return ASN1Sequence . getInstance ( this , isExplicit ) . parser ( ) ; case DERTags . OCTET_STRING : return ASN1OctetString . getInstance ( this , isExplicit ) . parser ( ) ; } if ( isExplicit ) { return getObject ( ) ; } throw new RuntimeException ( " implicit tagging not implemented for tag: " + tag ) ; } 
abstract void encode ( DEROutputStream out ) throws IOException ; public String toString ( ) { return " [ " + tagNo + " ] " + obj ; } } 
public String toString ( ) { return " [ " + tagNo + " ] " + obj ; } 
public int getTagNo ( ) ; public DEREncodable getObjectParser ( int tag , boolean isExplicit ) throws IOException ; } 
public DEREncodable getObjectParser ( int tag , boolean isExplicit ) throws IOException ; } 
public DEREncodable readObject ( ) throws IOException { return parser . readObject ( ) ; } 
tstatic private byte [ ] toBytes ( Vector octs ) { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i ! = octs . size ( ) ; i + + ) { try { DEROctetString o = ( DEROctetString ) octs . elementAt ( i ) ; bOut . write ( o . getOctets ( ) ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( octs . elementAt ( i ) . getClass ( ) . getName ( ) + " found in input should only contain DEROctetString " ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " exception converting octets " + e . toString ( ) ) ; } } return bOut . toByteArray ( ) ; } 
private Vector generateOcts ( ) { Vector vec = new Vector ( ) ; for ( int i = 0 ; i < string . length ; i + = MAX_LENGTH ) { int end ; if ( i + MAX_LENGTH > string . length ) { end = string . length ; } else { end = i + MAX_LENGTH ; } byte [ ] nStr = new byte [ end - i ] ; System . arraycopy ( string , i , nStr , 0 , nStr . length ) ; vec . addElement ( new DEROctetString ( nStr ) ) ; } return vec ; } 
public void encode ( DEROutputStream out ) throws IOException { if ( out instanceof ASN1OutputStream | | out instanceof BEROutputStream ) { 
void encode ( DEROutputStream out ) throws IOException { if ( out instanceof ASN1OutputStream | | out instanceof BEROutputStream ) { 
static BERSequence createSequence ( ASN1EncodableVector v ) { return v . size ( ) < 1 ? EMPTY_SEQUENCE : new BERSequence ( v ) ; } 
static BERSet createSet ( ASN1EncodableVector v ) { return v . size ( ) < 1 ? EMPTY_SET : new BERSet ( v ) ; } 
static BERSet createSet ( ASN1EncodableVector v , boolean needsSorting ) { return v . size ( ) < 1 ? EMPTY_SET : new BERSet ( v , needsSorting ) ; } 
private void writeHdr ( int tag ) throws IOException { _out . write ( tag ) ; _out . write ( 0x80 ) ; } 
protected void writeBERHeader ( int tag ) throws IOException { if ( _tagged ) { 
protected void writeBERBody ( InputStream contentStream ) throws IOException { int ch ; while ( ( ch = contentStream . read ( ) ) > = 0 ) { 
protected void writeBEREnd ( ) throws IOException { _out . write ( 0x00 ) ; _out . write ( 0x00 ) ; if ( _tagged & & _isExplicit ) write extra end for tag header { 
void encode ( DEROutputStream out ) throws IOException { throw new IOException ( " Eeek! " ) ; } 
public int hashCode ( ) { return 0 ; } 
public boolean equals ( Object o ) { return o = = this ; } 
private byte [ ] readIndefiniteLengthFully ( ) throws IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; int b , b1 ; b1 = read ( ) ; while ( ( b = read ( ) ) > = 0 ) { if ( b1 = = 0 & & b = = 0 ) { break ; } bOut . write ( b1 ) ; b1 = b ; } return bOut . toByteArray ( ) ; } 
private BERConstructedOctetString buildConstructedOctetString ( ) throws IOException { Vector octs = new Vector ( ) ; for ( ; ; ) { DERObject o = readObject ( ) ; if ( o = = END_OF_STREAM ) { break ; } octs . addElement ( o ) ; } return new BERConstructedOctetString ( octs ) ; } 
public DERObject readObject ( ) throws IOException { int tag = read ( ) ; if ( tag = = - 1 ) { throw new EOFException ( ) ; } int length = readLength ( ) ; if ( length < 0 ) indefinite length method { 
void encode ( DEROutputStream out ) throws IOException { if ( out instanceof ASN1OutputStream | | out instanceof BEROutputStream ) { 
public OutputStream getOctetOutputStream ( byte [ ] buf ) { return new BufferedBEROctetStream ( buf ) ; } 
public void write ( int b ) throws IOException { _buf [ _off + + ] = ( byte ) b ; if ( _off = = _buf . length ) { 
public void write ( byte [ ] b , int off , int len ) throws IOException { while ( len > 0 ) { 
public void close ( ) throws IOException { if ( _off ! = 0 ) { byte [ ] bytes = new byte [ _off ] ; System . arraycopy ( _buf , 0 , bytes , 0 , _off ) ; DEROctetString . encode ( _derOut , bytes ) ; } writeBEREnd ( ) ; } 
public void addObject ( DEREncodable object ) throws IOException { object . getDERObject ( ) . encode ( new BEROutputStream ( _out ) ) ; } 
public void close ( ) throws IOException { writeBEREnd ( ) ; } 
public DEREncodable readObject ( ) throws IOException { return _parser . readObject ( ) ; } 
public boolean isConstructed ( ) { return ( _baseTag & DERTags . CONSTRUCTED ) ! = 0 ; } 
public DEREncodable getObjectParser ( int tag , boolean isExplicit ) throws IOException { if ( isExplicit ) { return new ASN1StreamParser ( _contentStream ) . readObject ( ) ; } switch ( tag ) { case DERTags . SET : if ( _indefiniteLength ) { return new BERSetParser ( new ASN1StreamParser ( _contentStream ) ) ; } else { return new DERSetParser ( new ASN1StreamParser ( _contentStream ) ) ; } case DERTags . SEQUENCE : if ( _indefiniteLength ) { return new BERSequenceParser ( new ASN1StreamParser ( _contentStream ) ) ; } else { return new DERSequenceParser ( new ASN1StreamParser ( _contentStream ) ) ; } case DERTags . OCTET_STRING : TODO Is the handling of definite length constructed encodings correct? if (_indefiniteLength || this.isConstructed()) { return new BEROctetStringParser(new ASN1StreamParser(_contentStream)); } else { return new DEROctetStringParser((DefiniteLengthInputStream)_contentStream); } } throw new RuntimeException("implicit tagging not implemented"); } 
private ASN1EncodableVector rLoadVector ( InputStream in ) { try { 
public int read ( byte [ ] b , int off , int len ) throws IOException { if ( _currentStream = = null ) { if ( ! _first ) { return - 1 ; } ASN1OctetStringParser s = ( ASN1OctetStringParser ) _parser . readObject ( ) ; if ( s = = null ) { return - 1 ; } _first = false ; _currentStream = s . getOctetStream ( ) ; } int totalRead = 0 ; for ( ; ; ) { 
public int read ( ) throws IOException { if ( _currentStream = = null ) { if ( ! _first ) { return - 1 ; } ASN1OctetStringParser s = ( ASN1OctetStringParser ) _parser . readObject ( ) ; if ( s = = null ) { return - 1 ; } _first = false ; _currentStream = s . getOctetStream ( ) ; } for ( ; ; ) { 
public boolean isConstructed ( ) { return isConstructed ; } 
public DERObject getObject ( ) throws IOException { return new ASN1InputStream ( getContents ( ) ) . readObject ( ) ; } 
public DERObject getObject ( int derTagNo ) throws IOException { if ( derTagNo > = 0x1f ) { throw new IOException ( " unsupported tag number " ) ; } byte [ ] orig = this . getEncoded ( ) ; byte [ ] tmp = replaceTagNumber ( derTagNo , orig ) ; if ( ( orig [ 0 ] & DERTags . CONSTRUCTED ) ! = 0 ) { tmp [ 0 ] | = DERTags . CONSTRUCTED ; } return new ASN1InputStream ( tmp ) . readObject ( ) ; } 
void encode ( DEROutputStream out ) throws IOException { int classBits = DERTags . APPLICATION ; if ( isConstructed ) { classBits | = DERTags . CONSTRUCTED ; } out . writeEncoded ( classBits , tag , octets ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERApplicationSpecific ) ) { return false ; } DERApplicationSpecific other = ( DERApplicationSpecific ) o ; return isConstructed = = other . isConstructed & & tag = = other . tag 
public int hashCode ( ) { return ( isConstructed ? 1 : 0 ) ^ tag ^ Arrays . hashCode ( octets ) ; } 
private byte [ ] replaceTagNumber ( int newTag , byte [ ] input ) throws IOException { int tagNo = input [ 0 ] & 0x1f ; int index = 1 ; with tagged object tag number is bottom 5 bits, or stored at the start of the content if (tagNo == 0x1f) { tagNo = 0; int b = input[index++] & 0xff; X.690-0207 8.1.2.4.2 "c) bits 7 to 1 of the first subsequent octet shall not all be zero." if ((b & 0x7f) == 0) Note: -1 will pass { throw new ASN1ParsingException("corrupted stream - invalid high tag number found"); } while ((b >= 0) && ((b & 0x80) != 0)) { tagNo |= (b & 0x7f); tagNo <<= 7; b = input[index++] & 0xff; } tagNo |= (b & 0x7f); } byte[] tmp = new byte[input.length - index + 1]; System.arraycopy(input, index, tmp, 1, tmp.length - 1); tmp[0] = (byte)newTag; return tmp; } 
public static DERBMPString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERBMPString ) { return ( DERBMPString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERBMPString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERBMPString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public int hashCode ( ) { return this . getString ( ) . hashCode ( ) ; } 
protected boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERBMPString ) ) { return false ; } DERBMPString s = ( DERBMPString ) o ; return this . getString ( ) . equals ( s . getString ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { char [ ] c = string . toCharArray ( ) ; byte [ ] b = new byte [ c . length * 2 ] ; for ( int i = 0 ; i ! = c . length ; i + + ) { b [ 2 * i ] = ( byte ) ( c [ i ] > > 8 ) ; b [ 2 * i + 1 ] = ( byte ) c [ i ] ; } out . writeEncoded ( BMP_STRING , b ) ; } 
static protected int getPadBits ( int bitString ) { int val = 0 ; for ( int i = 3 ; i > = 0 ; i - - ) { this may look a little odd, but if it isn't done like this pre jdk1.2 JVM's break! if (i != 0) { if ((bitString >> (i * 8)) != 0) { val = (bitString >> (i * 8)) & 0xFF; break; } } else { if (bitString != 0) { val = bitString & 0xFF; break; } } } if (val == 0) { return 7; } int bits = 1; while (((val <<= 1) & 0xFF) != 0) { bits++; } return 8 - bits; } 
public static DERBitString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERBitString ) { return ( DERBitString ) obj ; } if ( obj instanceof ASN1OctetString ) { byte [ ] bytes = ( ( ASN1OctetString ) obj ) . getOctets ( ) ; int padBits = bytes [ 0 ] ; byte [ ] data = new byte [ bytes . length - 1 ] ; System . arraycopy ( bytes , 1 , data , 0 , bytes . length - 1 ) ; return new DERBitString ( data , padBits ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERBitString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public int intValue ( ) { int value = 0 ; for ( int i = 0 ; i ! = data . length & & i ! = 4 ; i + + ) { value | = ( data [ i ] & 0xff ) < < ( 8 * i ) ; } return value ; } 
void encode ( DEROutputStream out ) throws IOException { byte [ ] bytes = new byte [ getBytes ( ) . length + 1 ] ; bytes [ 0 ] = ( byte ) getPadBits ( ) ; System . arraycopy ( getBytes ( ) , 0 , bytes , 1 , bytes . length - 1 ) ; out . writeEncoded ( BIT_STRING , bytes ) ; } 
public int hashCode ( ) { return padBits ^ Arrays . hashCode ( data ) ; } 
protected boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERBitString ) ) { return false ; } DERBitString other = ( DERBitString ) o ; return this . padBits = = other . padBits & & Arrays . areEqual ( this . data , other . data ) ; 
public String toString ( ) { return getString ( ) ; } 
public static DERBoolean getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERBoolean ) { return ( DERBoolean ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERBoolean ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERBoolean getInstance ( boolean value ) { return ( value ? TRUE : FALSE ) ; } 
public static DERBoolean getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public boolean isTrue ( ) { return ( value ! = 0 ) ; } 
void encode ( DEROutputStream out ) throws IOException { byte [ ] bytes = new byte [ 1 ] ; bytes [ 0 ] = value ; out . writeEncoded ( BOOLEAN , bytes ) ; } 
protected boolean asn1Equals ( DERObject o ) { if ( ( o = = null ) | | ! ( o instanceof DERBoolean ) ) { return false ; } return ( value = = ( ( DERBoolean ) o ) . value ) ; } 
public String toString ( ) { return ( value ! = 0 ) ? " TRUE " : " FALSE " ; } 
public void addObject ( DEREncodable obj ) { super . addObject ( obj ) ; } 
void encode ( DEROutputStream out ) throws IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; DEROutputStream dOut = new DEROutputStream ( bOut ) ; Enumeration e = this . getObjects ( ) ; while ( e . hasMoreElements ( ) ) { Object obj = e . nextElement ( ) ; dOut . writeObject ( obj ) ; } dOut . close ( ) ; byte [ ] bytes = bOut . toByteArray ( ) ; out . writeEncoded ( SEQUENCE | CONSTRUCTED , bytes ) ; } 
public void addObject ( DEREncodable obj ) { super . addObject ( obj ) ; } 
void encode ( DEROutputStream out ) throws IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; DEROutputStream dOut = new DEROutputStream ( bOut ) ; Enumeration e = this . getObjects ( ) ; while ( e . hasMoreElements ( ) ) { Object obj = e . nextElement ( ) ; dOut . writeObject ( obj ) ; } dOut . close ( ) ; byte [ ] bytes = bOut . toByteArray ( ) ; out . writeEncoded ( SET | CONSTRUCTED , bytes ) ; } 
public void add ( DEREncodable obj ) { v . addElement ( obj ) ; } 
public DEREncodable get ( int i ) { return ( DEREncodable ) v . elementAt ( i ) ; } 
public static DEREnumerated getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DEREnumerated ) { return ( DEREnumerated ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DEREnumerated ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DEREnumerated getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( ENUMERATED , bytes ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DEREnumerated ) ) { return false ; } DEREnumerated other = ( DEREnumerated ) o ; return Arrays . areEqual ( this . bytes , other . bytes ) ; } 
public int hashCode ( ) { return Arrays . hashCode ( bytes ) ; } 
public int hashCode ( ) { int ret = 0 ; if ( directReference ! = null ) { ret = directReference . hashCode ( ) ; } if ( indirectReference ! = null ) { ret ^ = indirectReference . hashCode ( ) ; } if ( dataValueDescriptor ! = null ) { ret ^ = dataValueDescriptor . hashCode ( ) ; } ret ^ = externalContent . hashCode ( ) ; return ret ; } 
void encode ( DEROutputStream out ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; if ( directReference ! = null ) { baos . write ( directReference . getDEREncoded ( ) ) ; } if ( indirectReference ! = null ) { baos . write ( indirectReference . getDEREncoded ( ) ) ; } if ( dataValueDescriptor ! = null ) { baos . write ( dataValueDescriptor . getDEREncoded ( ) ) ; } DERTaggedObject obj = new DERTaggedObject ( encoding , externalContent ) ; baos . write ( obj . getDEREncoded ( ) ) ; out . writeEncoded ( DERTags . CONSTRUCTED , DERTags . EXTERNAL , baos . toByteArray ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERExternal ) ) { return false ; } if ( this = = o ) { return true ; } DERExternal other = ( DERExternal ) o ; if ( directReference ! = null ) { if ( other . directReference = = null | | ! other . directReference . equals ( directReference ) ) { return false ; } } if ( indirectReference ! = null ) { if ( other . indirectReference = = null | | ! other . indirectReference . equals ( indirectReference ) ) { return false ; } } if ( dataValueDescriptor ! = null ) { if ( other . dataValueDescriptor = = null | | ! other . dataValueDescriptor . equals ( dataValueDescriptor ) ) { return false ; } } return externalContent . equals ( other . externalContent ) ; } 
static DERSequence createSequence ( ASN1EncodableVector v ) { return v . size ( ) < 1 ? EMPTY_SEQUENCE : new DERSequence ( v ) ; } 
static DERSet createSet ( ASN1EncodableVector v ) { return v . size ( ) < 1 ? EMPTY_SET : new DERSet ( v ) ; } 
static DERSet createSet ( ASN1EncodableVector v , boolean needsSorting ) { return v . size ( ) < 1 ? EMPTY_SET : new DERSet ( v , needsSorting ) ; } 
public static DERGeneralString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERGeneralString ) { return ( DERGeneralString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERGeneralString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; 
public static DERGeneralString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( GENERAL_STRING , this . getOctets ( ) ) ; } 
public int hashCode ( ) { return this . getString ( ) . hashCode ( ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERGeneralString ) ) { return false ; } DERGeneralString s = ( DERGeneralString ) o ; return this . getString ( ) . equals ( s . getString ( ) ) ; } 
public static DERGeneralizedTime getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERGeneralizedTime ) { return ( DERGeneralizedTime ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERGeneralizedTime ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERGeneralizedTime getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
private String convert ( int time ) { if ( time < 10 ) { return " 0 " + time ; } return Integer . toString ( time ) ; } 
public Date getDate ( ) throws ParseException { SimpleDateFormat dateF ; String d = time ; if ( time . endsWith ( " Z " ) ) { if ( hasFractionalSeconds ( ) ) { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss.SSS'Z' " ) ; } else { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss'Z' " ) ; } dateF . setTimeZone ( new SimpleTimeZone ( 0 , " Z " ) ) ; } else if ( time . indexOf ( '-' ) > 0 | | time . indexOf ( '+' ) > 0 ) { d = this . getTime ( ) ; if ( hasFractionalSeconds ( ) ) { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss.SSSz " ) ; } else { dateF = new SimpleDateFormat ( " yyyyMMddHHmmssz " ) ; } dateF . setTimeZone ( new SimpleTimeZone ( 0 , " Z " ) ) ; } else { if ( hasFractionalSeconds ( ) ) { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss.SSS " ) ; } else { dateF = new SimpleDateFormat ( " yyyyMMddHHmmss " ) ; } dateF . setTimeZone ( new SimpleTimeZone ( 0 , TimeZone . getDefault ( ) . getID ( ) ) ) ; } if ( hasFractionalSeconds ( ) ) { java misinterprets extra digits as being milliseconds... String frac = d.substring(14); int index; for (index = 1; index < frac.length(); index++) { char ch = frac.charAt(index); if (!('0' <= ch && ch <= '9')) { break; } } if (index - 1 > 3) { frac = frac.substring(0, 4) + frac.substring(index); d = d.substring(0, 14) + frac; } } return dateF.parse(d); } 
private boolean hasFractionalSeconds ( ) { return time . indexOf ( '.' ) = = 14 ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( GENERALIZED_TIME , this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERGeneralizedTime ) ) { return false ; } return time . equals ( ( ( DERGeneralizedTime ) o ) . time ) ; } 
public int hashCode ( ) { return time . hashCode ( ) ; } 
private void writeLength ( OutputStream out , int length ) throws IOException { if ( length > 127 ) { 
void writeDEREncoded ( OutputStream out , int tag , byte [ ] bytes ) throws IOException { out . write ( tag ) ; writeLength ( out , bytes . length ) ; out . write ( bytes ) ; } 
void writeDEREncoded ( int tag , byte [ ] bytes ) throws IOException { if ( _tagged ) { 
void writeDEREncoded ( OutputStream out , int tag , InputStream in ) throws IOException { writeDEREncoded ( out , tag , Streams . readAll ( in ) ) ; } 
public static DERIA5String getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERIA5String ) { return ( DERIA5String ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERIA5String ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERIA5String getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( IA5_STRING , this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERIA5String ) ) { return false ; } DERIA5String s = ( DERIA5String ) o ; return this . getString ( ) . equals ( s . getString ( ) ) ; } 
public static boolean isIA5String ( String str ) { for ( int i = str . length ( ) - 1 ; i > = 0 ; i - - ) { char ch = str . charAt ( i ) ; if ( ch > 0x007f ) { return false ; } } return true ; } 
protected int readLength ( ) throws IOException { int length = read ( ) ; if ( length < 0 ) { throw new IOException ( " EOF found when length expected " ) ; } if ( length = = 0x80 ) { return - 1 ; indefinite-length encoding } if (length > 127) { int size = length & 0x7f; if (size > 4) { throw new IOException("DER length more than 4 bytes"); } length = 0; for (int i = 0; i < size; i++) { int next = read(); if (next < 0) { throw new IOException("EOF found reading length"); } length = (length << 8) + next; } if (length < 0) { throw new IOException("corrupted stream - negative length found"); } } return length; } 
protected void readFully ( byte [ ] bytes ) throws IOException { int left = bytes . length ; if ( left = = 0 ) { return ; } while ( left > 0 ) { 
protected DERObject buildObject ( int tag , byte [ ] bytes ) throws IOException { switch ( tag ) { 
public DERObject readObject ( ) throws IOException { int tag = read ( ) ; if ( tag = = - 1 ) { throw new EOFException ( ) ; } int length = readLength ( ) ; byte [ ] bytes = new byte [ length ] ; readFully ( bytes ) ; return buildObject ( tag , bytes ) ; } 
public static DERInteger getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERInteger ) { return ( DERInteger ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERInteger ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERInteger getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( INTEGER , bytes ) ; } 
public int hashCode ( ) { int value = 0 ; for ( int i = 0 ; i ! = bytes . length ; i + + ) { value ^ = ( bytes [ i ] & 0xff ) < < ( i % 4 ) ; } return value ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERInteger ) ) { return false ; } DERInteger other = ( DERInteger ) o ; return Arrays . areEqual ( bytes , other . bytes ) ; } 
public String toString ( ) { return getValue ( ) . toString ( ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( NULL , zeroBytes ) ; } 
public static DERNumericString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERNumericString ) { return ( DERNumericString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERNumericString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERNumericString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( NUMERIC_STRING , this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERNumericString ) ) { return false ; } DERNumericString s = ( DERNumericString ) o ; return this . getString ( ) . equals ( s . getString ( ) ) ; } 
public static boolean isNumericString ( String str ) { for ( int i = str . length ( ) - 1 ; i > = 0 ; i - - ) { char ch = str . charAt ( i ) ; if ( ch > 0x007f ) { return false ; } if ( ( '0' < = ch & & ch < = '9' ) | | ch = = ' ' ) { continue ; } return false ; } return true ; } 
public DERObject toASN1Object ( ) { return this ; } 
public abstract int hashCode ( ) ; public abstract boolean equals ( Object o ) ; abstract void encode ( DEROutputStream out ) throws IOException ; } 
public abstract boolean equals ( Object o ) ; abstract void encode ( DEROutputStream out ) throws IOException ; } 
abstract void encode ( DEROutputStream out ) throws IOException ; } 
public static DERObjectIdentifier getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERObjectIdentifier ) { return ( DERObjectIdentifier ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERObjectIdentifier ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERObjectIdentifier getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
private void writeField ( OutputStream out , long fieldValue ) throws IOException { if ( fieldValue > = ( 1L < < 7 ) ) { if ( fieldValue > = ( 1L < < 14 ) ) { if ( fieldValue > = ( 1L < < 21 ) ) { if ( fieldValue > = ( 1L < < 28 ) ) { if ( fieldValue > = ( 1L < < 35 ) ) { if ( fieldValue > = ( 1L < < 42 ) ) { if ( fieldValue > = ( 1L < < 49 ) ) { if ( fieldValue > = ( 1L < < 56 ) ) { out . write ( ( int ) ( fieldValue > > 56 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 49 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 42 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 35 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 28 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 21 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 14 ) | 0x80 ) ; } out . write ( ( int ) ( fieldValue > > 7 ) | 0x80 ) ; } out . write ( ( int ) fieldValue & 0x7f ) ; } 
private void writeField ( OutputStream out , BigInteger fieldValue ) throws IOException { int byteCount = ( fieldValue . bitLength ( ) + 6 ) / 7 ; if ( byteCount = = 0 ) { 
void encode ( DEROutputStream out ) throws IOException { OIDTokenizer tok = new OIDTokenizer ( identifier ) ; ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; DEROutputStream dOut = new DEROutputStream ( bOut ) ; writeField ( bOut , Integer . parseInt ( tok . nextToken ( ) ) * 40 + Integer . parseInt ( tok . nextToken ( ) ) ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) ; if ( token . length ( ) < 18 ) { writeField ( bOut , Long . parseLong ( token ) ) ; } else { writeField ( bOut , new BigInteger ( token ) ) ; } } dOut . close ( ) ; byte [ ] bytes = bOut . toByteArray ( ) ; out . writeEncoded ( OBJECT_IDENTIFIER , bytes ) ; } 
public int hashCode ( ) { return identifier . hashCode ( ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERObjectIdentifier ) ) { return false ; } return identifier . equals ( ( ( DERObjectIdentifier ) o ) . identifier ) ; } 
private static boolean isValidIdentifier ( String identifier ) { if ( identifier . length ( ) < 3 | | identifier . charAt ( 1 ) ! = '.' ) { return false ; } char first = identifier . charAt ( 0 ) ; if ( first < '0' | | first > '2' ) { return false ; } boolean periodAllowed = false ; for ( int i = identifier . length ( ) - 1 ; i > = 2 ; i - - ) { char ch = identifier . charAt ( i ) ; if ( '0' < = ch & & ch < = '9' ) { periodAllowed = true ; continue ; } if ( ch = = '.' ) { if ( ! periodAllowed ) { return false ; } periodAllowed = false ; continue ; } return false ; } return periodAllowed ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( OCTET_STRING , string ) ; } 
static void encode ( DEROutputStream derOut , byte [ ] bytes ) throws IOException { derOut . writeEncoded ( DERTags . OCTET_STRING , bytes ) ; } 
private void writeLength ( int length ) throws IOException { if ( length > 127 ) { 
void writeEncoded ( int tag , byte [ ] bytes ) throws IOException { write ( tag ) ; writeLength ( bytes . length ) ; write ( bytes ) ; } 
void writeTag ( int flags , int tagNo ) throws IOException { if ( tagNo < 31 ) { 
void writeEncoded ( int flags , int tagNo , byte [ ] bytes ) throws IOException { writeTag ( flags , tagNo ) ; writeLength ( bytes . length ) ; write ( bytes ) ; } 
protected void writeNull ( ) throws IOException { write ( NULL ) ; write ( 0x00 ) ; } 
public void write ( byte [ ] buf ) throws IOException { out . write ( buf , 0 , buf . length ) ; } 
public void write ( byte [ ] buf , int offSet , int len ) throws IOException { out . write ( buf , offSet , len ) ; } 
public static DERPrintableString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERPrintableString ) { return ( DERPrintableString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERPrintableString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERPrintableString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( PRINTABLE_STRING , this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERPrintableString ) ) { return false ; } DERPrintableString s = ( DERPrintableString ) o ; return this . getString ( ) . equals ( s . getString ( ) ) ; } 
public static boolean isPrintableString ( String str ) { for ( int i = str . length ( ) - 1 ; i > = 0 ; i - - ) { char ch = str . charAt ( i ) ; if ( ch > 0x007f ) { return false ; } if ( 'a' < = ch & & ch < = 'z' ) { continue ; } if ( 'A' < = ch & & ch < = 'Z' ) { continue ; } if ( '0' < = ch & & ch < = '9' ) { continue ; } switch ( ch ) { case ' ' : case '\'' : case '(' : case ')' : case '+' : case '-' : case '.' : case ':' : case '=' : case '?' : case '/' : case ',' : continue ; } return false ; } return true ; } 
void encode ( DEROutputStream out ) throws IOException { TODO Intermediate buffer could be avoided if we could calculate expected length ByteArrayOutputStream bOut = new ByteArrayOutputStream(); DEROutputStream dOut = new DEROutputStream(bOut); Enumeration e = this.getObjects(); while (e.hasMoreElements()) { Object obj = e.nextElement(); dOut.writeObject(obj); } dOut.close(); byte[] bytes = bOut.toByteArray(); out.writeEncoded(SEQUENCE | CONSTRUCTED, bytes); } 
public void addObject ( DEREncodable object ) throws IOException { object . getDERObject ( ) . encode ( new DEROutputStream ( _bOut ) ) ; } 
public void close ( ) throws IOException { writeDEREncoded ( DERTags . CONSTRUCTED | DERTags . SEQUENCE , _bOut . toByteArray ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { TODO Intermediate buffer could be avoided if we could calculate expected length ByteArrayOutputStream bOut = new ByteArrayOutputStream(); DEROutputStream dOut = new DEROutputStream(bOut); Enumeration e = this.getObjects(); while (e.hasMoreElements()) { Object obj = e.nextElement(); dOut.writeObject(obj); } dOut.close(); byte[] bytes = bOut.toByteArray(); out.writeEncoded(SET | CONSTRUCTED, bytes); } 
public static DERT61String getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERT61String ) { return ( DERT61String ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERT61String ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERT61String getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( T61_STRING , this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERT61String ) ) { return false ; } return this . getString ( ) . equals ( ( ( DERT61String ) o ) . getString ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { if ( ! empty ) { 
public static DERUTCTime getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERUTCTime ) { return ( DERUTCTime ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERUTCTime ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERUTCTime getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public Date getDate ( ) throws ParseException { SimpleDateFormat dateF = new SimpleDateFormat ( " yyMMddHHmmssz " ) ; return dateF . parse ( getTime ( ) ) ; } 
public Date getAdjustedDate ( ) throws ParseException { SimpleDateFormat dateF = new SimpleDateFormat ( " yyyyMMddHHmmssz " ) ; dateF . setTimeZone ( new SimpleTimeZone ( 0 , " Z " ) ) ; return dateF . parse ( getAdjustedTime ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( UTC_TIME , this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERUTCTime ) ) { return false ; } return time . equals ( ( ( DERUTCTime ) o ) . time ) ; } 
public static DERUTF8String getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERUTF8String ) ) { return false ; } DERUTF8String s = ( DERUTF8String ) o ; return this . getString ( ) . equals ( s . getString ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( UTF8_STRING , Strings . toUTF8ByteArray ( string ) ) ; } 
public static DERUniversalString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERUniversalString ) { return ( DERUniversalString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERUniversalString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERUniversalString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( UNIVERSAL_STRING , this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERUniversalString ) ) { return false ; } return this . getString ( ) . equals ( ( ( DERUniversalString ) o ) . getString ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( isConstructed ? DERTags . CONSTRUCTED : 0 , tag , data ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof DERUnknownTag ) ) { return false ; } DERUnknownTag other = ( DERUnknownTag ) o ; return isConstructed = = other . isConstructed & & tag = = other . tag 
public int hashCode ( ) { return ( isConstructed ? ~ 0 : 0 ) ^ tag ^ Arrays . hashCode ( data ) ; } 
public static DERVisibleString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERVisibleString ) { return ( DERVisibleString ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERVisibleString ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public static DERVisibleString getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( VISIBLE_STRING , this . getOctets ( ) ) ; } 
boolean asn1Equals ( DERObject o ) { if ( ! ( o instanceof DERVisibleString ) ) { return false ; } return this . getString ( ) . equals ( ( ( DERVisibleString ) o ) . getString ( ) ) ; } 
public int read ( ) throws IOException { if ( _remaining = = 0 ) { return - 1 ; } int b = _in . read ( ) ; if ( b < 0 ) { throw new EOFException ( " DEF length " + _originalLength + " object truncated by " + _remaining ) ; } if ( - - _remaining = = 0 ) { setParentEofDetect ( true ) ; } return b ; } 
public int read ( byte [ ] buf , int off , int len ) throws IOException { if ( _remaining = = 0 ) { return - 1 ; } int toRead = Math . min ( len , _remaining ) ; int numRead = _in . read ( buf , off , toRead ) ; if ( numRead < 0 ) { throw new EOFException ( " DEF length " + _originalLength + " object truncated by " + _remaining ) ; } if ( ( _remaining - = numRead ) = = 0 ) { setParentEofDetect ( true ) ; } return numRead ; } 
byte [ ] toByteArray ( ) throws IOException { if ( _remaining = = 0 ) { return EMPTY_BYTES ; } byte [ ] bytes = new byte [ _remaining ] ; if ( ( _remaining - = Streams . readFully ( _in , bytes ) ) ! = 0 ) { throw new EOFException ( " DEF length " + _originalLength + " object truncated by " + _remaining ) ; } setParentEofDetect ( true ) ; return bytes ; } 
void setEofOn00 ( boolean eofOn00 ) { _eofOn00 = eofOn00 ; checkForEof ( ) ; } 
private boolean checkForEof ( ) { if ( ! _eofReached & & _eofOn00 & & ( _b1 = = 0x00 & & _b2 = = 0x00 ) ) { _eofReached = true ; setParentEofDetect ( true ) ; } return _eofReached ; } 
public int read ( byte [ ] b , int off , int len ) throws IOException { Only use this optimisation if we aren't checking for 00 if (_eofOn00 || len < 3) { return super.read(b, off, len); } if (_eofReached) { return -1; } int numRead = _in.read(b, off + 2, len - 2); if (numRead < 0) { Corrupted stream throw new EOFException(); } b[off] = (byte)_b1; b[off + 1] = (byte)_b2; _b1 = _in.read(); _b2 = _in.read(); if (_b2 < 0) { Corrupted stream throw new EOFException(); } return numRead + 2; } 
public int read ( ) throws IOException { if ( checkForEof ( ) ) { return - 1 ; } int b = _in . read ( ) ; if ( b < 0 ) { Corrupted stream throw new EOFException(); } int v = _b1; _b1 = _b2; _b2 = b; return v; } 
public boolean hasMoreElements ( ) { return nextObj ! = null ; } 
public Object nextElement ( ) { Object o = nextObj ; nextObj = readObject ( ) ; return o ; } 
private void parse ( ) { Enumeration en = new LazyDERConstructionEnumeration ( encoded ) ; while ( en . hasMoreElements ( ) ) { addObject ( ( DEREncodable ) en . nextElement ( ) ) ; } parsed = true ; } 
public int size ( ) { if ( size < 0 ) { Enumeration en = new LazyDERConstructionEnumeration ( encoded ) ; size = 0 ; while ( en . hasMoreElements ( ) ) { en . nextElement ( ) ; size + + ; } } return size ; } 
void encode ( DEROutputStream out ) throws IOException { out . writeEncoded ( SEQUENCE | CONSTRUCTED , encoded ) ; } 
public boolean hasMoreTokens ( ) { return ( index ! = - 1 ) ; } 
public String nextToken ( ) { if ( index = = - 1 ) { return null ; } String token ; int end = oid . indexOf ( '.' , index ) ; if ( end = = - 1 ) { token = oid . substring ( index ) ; index = - 1 ; return token ; } token = oid . substring ( index , end ) ; index = end + 1 ; return token ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( oldWithNew ) ; v . add ( newWithOld ) ; v . add ( newWithNew ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { return x509v3PKCert . toASN1Object ( ) ; } 
public CertificateList [ ] toCertificateListArray ( ) { CertificateList [ ] result = new CertificateList [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = CertificateList . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject toASN1Object ( ) { return content ; } 
public CertStatus [ ] toCertStatusArray ( ) { CertStatus [ ] result = new CertStatus [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = CertStatus . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject toASN1Object ( ) { if ( certificate ! = null ) { return new DERTaggedObject ( true , 0 , certificate ) ; } return new DERTaggedObject ( true , 1 , encryptedCert ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certHash ) ; v . add ( certReqId ) ; if ( statusInfo ! = null ) { v . add ( statusInfo ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; addOptional ( v , owf ) ; v . add ( witness ) ; v . add ( challenge ) ; return new DERSequence ( v ) ; } 
private void addOptional ( ASN1EncodableVector v , ASN1Encodable obj ) { if ( obj ! = null ) { 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( pKIStatusInfo ) ; addOptional ( v , errorCode ) ; addOptional ( v , errorDetails ) ; return new DERSequence ( v ) ; } 
public InfoTypeAndValue [ ] toInfoTypeAndValueArray ( ) { InfoTypeAndValue [ ] result = new InfoTypeAndValue [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = InfoTypeAndValue . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( infoType ) ; if ( infoValue ! = null ) { v . add ( infoValue ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( salt ) ; v . add ( owf ) ; v . add ( iterationCount ) ; v . add ( mac ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { return val ; } 
public String toString ( ) { return " PKIFailureInfo: 0x " + Integer . toHexString ( this . intValue ( ) ) ; } 
public static PKIFreeText getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static PKIFreeText getInstance ( Object obj ) { if ( obj instanceof PKIFreeText ) { return ( PKIFreeText ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new PKIFreeText ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERUTF8String getStringAt ( int i ) { return ( DERUTF8String ) strings . getObjectAt ( i ) ; } 
public DERObject toASN1Object ( ) { return strings ; } 
public DERObject toASN1Object ( ) { return value ; } 
public static PKIStatusInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static PKIStatusInfo getInstance ( Object obj ) { if ( obj instanceof PKIStatusInfo ) { return ( PKIStatusInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new PKIStatusInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( status ) ; if ( statusString ! = null ) { v . add ( statusString ) ; } if ( failInfo ! = null ) { v . add ( failInfo ) ; } return new DERSequence ( v ) ; } 
public Challenge [ ] toChallengeArray ( ) { Challenge [ ] result = new Challenge [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = Challenge . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERInteger [ ] toDERIntegerArray ( ) { DERInteger [ ] result = new DERInteger [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = DERInteger . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certReqId ) ; v . add ( checkAfter ) ; if ( reason ! = null ) { v . add ( reason ) ; } return new DERSequence ( v ) ; } 
private DERInteger [ ] seqenceToDERIntegerArray ( ASN1Sequence seq ) { DERInteger [ ] result = new DERInteger [ seq . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = DERInteger . getInstance ( seq . getObjectAt ( i ) ) ; } return result ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certDetails ) ; if ( crlEntryDetails ! = null ) { v . add ( crlEntryDetails ) ; } return new DERSequence ( v ) ; } 
public RevDetails [ ] toRevDetailsArray ( ) { RevDetails [ ] result = new RevDetails [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = RevDetails . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public static Attribute getInstance ( Object o ) { if ( o = = null | | o instanceof Attribute ) { return ( Attribute ) o ; } if ( o instanceof ASN1Sequence ) { return new Attribute ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( attrType ) ; v . add ( attrValues ) ; return new DERSequence ( v ) ; } 
private void addAttribute ( DERObjectIdentifier oid , Attribute a ) { Object value = attributes . get ( oid ) ; if ( value = = null ) { 
public Attribute get ( DERObjectIdentifier oid ) { Object value = attributes . get ( oid ) ; if ( value instanceof Vector ) { return ( Attribute ) ( ( Vector ) value ) . elementAt ( 0 ) ; } return ( Attribute ) value ; } 
public ASN1EncodableVector getAll ( DERObjectIdentifier oid ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; Object value = attributes . get ( oid ) ; if ( value instanceof Vector ) { Enumeration e = ( ( Vector ) value ) . elements ( ) ; while ( e . hasMoreElements ( ) ) { v . add ( ( Attribute ) e . nextElement ( ) ) ; } } else if ( value ! = null ) { v . add ( ( Attribute ) value ) ; } return v ; } 
public Hashtable toHashtable ( ) { return copyTable ( attributes ) ; } 
public ASN1EncodableVector toASN1EncodableVector ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { Object value = e . nextElement ( ) ; if ( value instanceof Vector ) { Enumeration en = ( ( Vector ) value ) . elements ( ) ; while ( en . hasMoreElements ( ) ) { v . add ( Attribute . getInstance ( en . nextElement ( ) ) ) ; } } else { v . add ( Attribute . getInstance ( value ) ) ; } } return v ; } 
private Hashtable copyTable ( Hashtable in ) { Hashtable out = new Hashtable ( ) ; Enumeration e = in . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object key = e . nextElement ( ) ; out . put ( key , in . get ( key ) ) ; } return out ; } 
public static AuthEnvelopedData getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static AuthEnvelopedData getInstance ( Object obj ) { if ( obj = = null | | obj instanceof AuthEnvelopedData ) { return ( AuthEnvelopedData ) obj ; } if ( obj instanceof ASN1Sequence ) { return new AuthEnvelopedData ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid AuthEnvelopedData: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; if ( originatorInfo ! = null ) { v . add ( new DERTaggedObject ( false , 0 , originatorInfo ) ) ; } v . add ( recipientInfos ) ; v . add ( authEncryptedContentInfo ) ; "authAttrs optionally contains the authenticated attributes." if (authAttrs != null) { "AuthAttributes MUST be DER encoded, even if the rest of the AuthEnvelopedData structure is BER encoded." v.add(new DERTaggedObject(false, 1, authAttrs)); } v.add(mac); "unauthAttrs optionally contains the unauthenticated attributes." if (unauthAttrs != null) { v.add(new DERTaggedObject(false, 2, unauthAttrs)); } return new BERSequence(v); } 
public ASN1SetParser getRecipientInfos ( ) throws IOException { if ( ! originatorInfoCalled ) { getOriginatorInfo ( ) ; } if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } ASN1SetParser recipientInfos = ( ASN1SetParser ) nextObject ; nextObject = null ; return recipientInfos ; } 
public EncryptedContentInfoParser getAuthEncryptedContentInfo ( ) throws IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject ! = null ) { ASN1SequenceParser o = ( ASN1SequenceParser ) nextObject ; nextObject = null ; return new EncryptedContentInfoParser ( o ) ; } return null ; } 
public ASN1SetParser getAuthAttrs ( ) throws IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject instanceof ASN1TaggedObjectParser ) { DEREncodable o = nextObject ; nextObject = null ; return ( ASN1SetParser ) ( ( ASN1TaggedObjectParser ) o ) . getObjectParser ( DERTags . SET , false ) ; } TODO "The authAttrs MUST be present if the content type carried in EncryptedContentInfo is not id-data." return null; } 
public ASN1OctetString getMac ( ) throws IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } DEREncodable o = nextObject ; nextObject = null ; return ASN1OctetString . getInstance ( o . getDERObject ( ) ) ; } 
public ASN1SetParser getUnauthAttrs ( ) throws IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject ! = null ) { DEREncodable o = nextObject ; nextObject = null ; return ( ASN1SetParser ) ( ( ASN1TaggedObjectParser ) o ) . getObjectParser ( DERTags . SET , false ) ; } return null ; } 
public static AuthenticatedData getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static AuthenticatedData getInstance ( Object obj ) { if ( obj = = null | | obj instanceof AuthenticatedData ) { return ( AuthenticatedData ) obj ; } if ( obj instanceof ASN1Sequence ) { return new AuthenticatedData ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid AuthenticatedData: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; if ( originatorInfo ! = null ) { v . add ( new DERTaggedObject ( false , 0 , originatorInfo ) ) ; } v . add ( recipientInfos ) ; v . add ( macAlgorithm ) ; if ( digestAlgorithm ! = null ) { v . add ( new DERTaggedObject ( false , 1 , digestAlgorithm ) ) ; } v . add ( encapsulatedContentInfo ) ; if ( authAttrs ! = null ) { v . add ( new DERTaggedObject ( false , 2 , authAttrs ) ) ; } v . add ( mac ) ; if ( unauthAttrs ! = null ) { v . add ( new DERTaggedObject ( false , 3 , unauthAttrs ) ) ; } return new BERSequence ( v ) ; } 
public static int calculateVersion ( OriginatorInfo origInfo ) { if ( origInfo = = null ) { 
public AlgorithmIdentifier getMacAlgorithm ( ) throws IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject ! = null ) { ASN1SequenceParser o = ( ASN1SequenceParser ) nextObject ; nextObject = null ; return AlgorithmIdentifier . getInstance ( o . getDERObject ( ) ) ; } return null ; } 
public ContentInfoParser getEnapsulatedContentInfo ( ) throws IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject ! = null ) { ASN1SequenceParser o = ( ASN1SequenceParser ) nextObject ; nextObject = null ; return new ContentInfoParser ( o ) ; } return null ; } 
public ASN1SetParser getAuthAttrs ( ) throws IOException { if ( nextObject = = null ) { nextObject = seq . readObject ( ) ; } if ( nextObject instanceof ASN1TaggedObjectParser ) { DEREncodable o = nextObject ; nextObject = null ; return ( ASN1SetParser ) ( ( ASN1TaggedObjectParser ) o ) . getObjectParser ( DERTags . SET , false ) ; } return null ; } 
public static CompressedData getInstance ( ASN1TaggedObject _ato , boolean _explicit ) { return getInstance ( ASN1Sequence . getInstance ( _ato , _explicit ) ) ; } 
public static CompressedData getInstance ( Object _obj ) { if ( _obj = = null | | _obj instanceof CompressedData ) { return ( CompressedData ) _obj ; } if ( _obj instanceof ASN1Sequence ) { return new CompressedData ( ( ASN1Sequence ) _obj ) ; } throw new IllegalArgumentException ( " Invalid CompressedData: " + _obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( compressionAlgorithm ) ; v . add ( encapContentInfo ) ; return new BERSequence ( v ) ; } 
public static ContentInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ContentInfo ) { return ( ContentInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new ContentInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( contentType ) ; if ( content ! = null ) { v . add ( new BERTaggedObject ( 0 , content ) ) ; } return new BERSequence ( v ) ; } 
public DEREncodable getContent ( int tag ) throws IOException { if ( content ! = null ) { return content . getObjectParser ( tag , true ) ; } return null ; } 
public static EncryptedContentInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof EncryptedContentInfo ) { return ( EncryptedContentInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new EncryptedContentInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid EncryptedContentInfo: " + obj . getClass ( ) . getName ( ) ) ; 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( contentType ) ; v . add ( contentEncryptionAlgorithm ) ; if ( encryptedContent ! = null ) { v . add ( new BERTaggedObject ( false , 0 , encryptedContent ) ) ; } return new BERSequence ( v ) ; } 
public DEREncodable getEncryptedContent ( int tag ) throws IOException { return _encryptedContent . getObjectParser ( tag , false ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( encryptedContentInfo ) ; if ( unprotectedAttrs ! = null ) { v . add ( new BERTaggedObject ( false , 1 , unprotectedAttrs ) ) ; } return new BERSequence ( v ) ; } 
public ASN1SetParser getRecipientInfos ( ) throws IOException { if ( ! _originatorInfoCalled ) { getOriginatorInfo ( ) ; } if ( _nextObject = = null ) { _nextObject = _seq . readObject ( ) ; } ASN1SetParser recipientInfos = ( ASN1SetParser ) _nextObject ; _nextObject = null ; return recipientInfos ; } 
public EncryptedContentInfoParser getEncryptedContentInfo ( ) throws IOException { if ( _nextObject = = null ) { _nextObject = _seq . readObject ( ) ; } if ( _nextObject ! = null ) { ASN1SequenceParser o = ( ASN1SequenceParser ) _nextObject ; _nextObject = null ; return new EncryptedContentInfoParser ( o ) ; } return null ; } 
public ASN1SetParser getUnprotectedAttrs ( ) throws IOException { if ( _nextObject = = null ) { _nextObject = _seq . readObject ( ) ; } if ( _nextObject ! = null ) { DEREncodable o = _nextObject ; _nextObject = null ; return ( ASN1SetParser ) ( ( ASN1TaggedObjectParser ) o ) . getObjectParser ( DERTags . SET , false ) ; } return null ; } 
public static IssuerAndSerialNumber getInstance ( Object obj ) { if ( obj instanceof IssuerAndSerialNumber ) { return ( IssuerAndSerialNumber ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new IssuerAndSerialNumber ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Illegal object in IssuerAndSerialNumber: " + obj . getClass ( ) . getName ( ) ) ; 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( name ) ; v . add ( serialNumber ) ; return new DERSequence ( v ) ; } 
public static KEKIdentifier getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static KEKIdentifier getInstance ( Object obj ) { if ( obj = = null | | obj instanceof KEKIdentifier ) { return ( KEKIdentifier ) obj ; } if ( obj instanceof ASN1Sequence ) { return new KEKIdentifier ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid KEKIdentifier: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( keyIdentifier ) ; if ( date ! = null ) { v . add ( date ) ; } if ( other ! = null ) { v . add ( other ) ; } return new DERSequence ( v ) ; } 
public static KEKRecipientInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static KEKRecipientInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof KEKRecipientInfo ) { return ( KEKRecipientInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new KEKRecipientInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid KEKRecipientInfo: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( kekid ) ; v . add ( keyEncryptionAlgorithm ) ; v . add ( encryptedKey ) ; return new DERSequence ( v ) ; } 
public static KeyAgreeRecipientIdentifier getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public DERObject toASN1Object ( ) { if ( issuerSerial ! = null ) { return issuerSerial . toASN1Object ( ) ; } return new DERTaggedObject ( false , 0 , rKeyID ) ; } 
public static KeyTransRecipientInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof KeyTransRecipientInfo ) { return ( KeyTransRecipientInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new KeyTransRecipientInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Illegal object in KeyTransRecipientInfo: " + obj . getClass ( ) . getName ( ) ) ; 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( rid ) ; v . add ( keyEncryptionAlgorithm ) ; v . add ( encryptedKey ) ; return new DERSequence ( v ) ; } 
public static OriginatorInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static OriginatorInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OriginatorInfo ) { return ( OriginatorInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new OriginatorInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid OriginatorInfo: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( certs ! = null ) { v . add ( new DERTaggedObject ( false , 0 , certs ) ) ; } if ( crls ! = null ) { v . add ( new DERTaggedObject ( false , 1 , crls ) ) ; } return new DERSequence ( v ) ; } 
public static OriginatorPublicKey getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static OriginatorPublicKey getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OriginatorPublicKey ) { return ( OriginatorPublicKey ) obj ; } if ( obj instanceof ASN1Sequence ) { return new OriginatorPublicKey ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid OriginatorPublicKey: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algorithm ) ; v . add ( publicKey ) ; return new DERSequence ( v ) ; } 
public static OtherKeyAttribute getInstance ( Object o ) { if ( o = = null | | o instanceof OtherKeyAttribute ) { return ( OtherKeyAttribute ) o ; } if ( o instanceof ASN1Sequence ) { return new OtherKeyAttribute ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( keyAttrId ) ; v . add ( keyAttr ) ; return new DERSequence ( v ) ; } 
public static OtherRecipientInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static OtherRecipientInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OtherRecipientInfo ) { return ( OtherRecipientInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new OtherRecipientInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid OtherRecipientInfo: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( oriType ) ; v . add ( oriValue ) ; return new DERSequence ( v ) ; } 
public static PasswordRecipientInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static PasswordRecipientInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof PasswordRecipientInfo ) { return ( PasswordRecipientInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new PasswordRecipientInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid PasswordRecipientInfo: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; if ( keyDerivationAlgorithm ! = null ) { v . add ( new DERTaggedObject ( false , 0 , keyDerivationAlgorithm ) ) ; } v . add ( keyEncryptionAlgorithm ) ; v . add ( encryptedKey ) ; return new DERSequence ( v ) ; } 
public static RecipientEncryptedKey getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static RecipientEncryptedKey getInstance ( Object obj ) { if ( obj = = null | | obj instanceof RecipientEncryptedKey ) { return ( RecipientEncryptedKey ) obj ; } if ( obj instanceof ASN1Sequence ) { return new RecipientEncryptedKey ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid RecipientEncryptedKey: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( identifier ) ; v . add ( encryptedKey ) ; return new DERSequence ( v ) ; } 
public static RecipientIdentifier getInstance ( Object o ) { if ( o = = null | | o instanceof RecipientIdentifier ) { return ( RecipientIdentifier ) o ; } if ( o instanceof IssuerAndSerialNumber ) { return new RecipientIdentifier ( ( IssuerAndSerialNumber ) o ) ; } if ( o instanceof ASN1OctetString ) { return new RecipientIdentifier ( ( ASN1OctetString ) o ) ; } if ( o instanceof DERObject ) { return new RecipientIdentifier ( ( DERObject ) o ) ; } throw new IllegalArgumentException ( " Illegal object in RecipientIdentifier: " + o . getClass ( ) . getName ( ) ) ; 
public boolean isTagged ( ) { return ( id instanceof ASN1TaggedObject ) ; } 
public DERObject toASN1Object ( ) { return id . getDERObject ( ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( subjectKeyIdentifier ) ; if ( date ! = null ) { v . add ( date ) ; } if ( other ! = null ) { v . add ( other ) ; } return new DERSequence ( v ) ; } 
public static SignedData getInstance ( Object o ) { if ( o instanceof SignedData ) { return ( SignedData ) o ; } else if ( o instanceof ASN1Sequence ) { return new SignedData ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( digestAlgorithms ) ; v . add ( contentInfo ) ; if ( certificates ! = null ) { if ( certsBer ) { v . add ( new BERTaggedObject ( false , 0 , certificates ) ) ; } else { v . add ( new DERTaggedObject ( false , 0 , certificates ) ) ; } } if ( crls ! = null ) { if ( crlsBer ) { v . add ( new BERTaggedObject ( false , 1 , crls ) ) ; } else { v . add ( new DERTaggedObject ( false , 1 , crls ) ) ; } } v . add ( signerInfos ) ; return new BERSequence ( v ) ; } 
public static SignedDataParser getInstance ( Object o ) throws IOException { if ( o instanceof ASN1Sequence ) { return new SignedDataParser ( ( ( ASN1Sequence ) o ) . parser ( ) ) ; } if ( o instanceof ASN1SequenceParser ) { return new SignedDataParser ( ( ASN1SequenceParser ) o ) ; } throw new IOException ( " unknown object encountered: " + o . getClass ( ) . getName ( ) ) ; } 
public ASN1SetParser getDigestAlgorithms ( ) throws IOException { Object o = _seq . readObject ( ) ; if ( o instanceof ASN1Set ) { return ( ( ASN1Set ) o ) . parser ( ) ; } return ( ASN1SetParser ) o ; } 
public ContentInfoParser getEncapContentInfo ( ) throws IOException { return new ContentInfoParser ( ( ASN1SequenceParser ) _seq . readObject ( ) ) ; } 
public ASN1SetParser getSignerInfos ( ) throws IOException { if ( ! _certsCalled | | ! _crlsCalled ) { throw new IOException ( " getCerts() and/or getCrls() has not been called. " ) ; } if ( _nextObject = = null ) { _nextObject = _seq . readObject ( ) ; } return ( ASN1SetParser ) _nextObject ; } 
public static SignerIdentifier getInstance ( Object o ) { if ( o = = null | | o instanceof SignerIdentifier ) { return ( SignerIdentifier ) o ; } if ( o instanceof IssuerAndSerialNumber ) { return new SignerIdentifier ( ( IssuerAndSerialNumber ) o ) ; } if ( o instanceof ASN1OctetString ) { return new SignerIdentifier ( ( ASN1OctetString ) o ) ; } if ( o instanceof DERObject ) { return new SignerIdentifier ( ( DERObject ) o ) ; } throw new IllegalArgumentException ( " Illegal object in SignerIdentifier: " + o . getClass ( ) . getName ( ) ) ; 
public static SignerInfo getInstance ( Object o ) throws IllegalArgumentException { if ( o = = null | | o instanceof SignerInfo ) { return ( SignerInfo ) o ; } else if ( o instanceof ASN1Sequence ) { return new SignerInfo ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( sid ) ; v . add ( digAlgorithm ) ; if ( authenticatedAttributes ! = null ) { v . add ( new DERTaggedObject ( false , 0 , authenticatedAttributes ) ) ; } v . add ( digEncryptionAlgorithm ) ; v . add ( encryptedDigest ) ; if ( unauthenticatedAttributes ! = null ) { v . add ( new DERTaggedObject ( false , 1 , unauthenticatedAttributes ) ) ; } return new DERSequence ( v ) ; } 
public static Time getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; } 
public static Time getInstance ( Object obj ) { if ( obj instanceof Time ) { return ( Time ) obj ; } else if ( obj instanceof DERUTCTime ) { return new Time ( ( DERUTCTime ) obj ) ; } else if ( obj instanceof DERGeneralizedTime ) { return new Time ( ( DERGeneralizedTime ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { return time ; } 
public static MQVuserKeyingMaterial getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static MQVuserKeyingMaterial getInstance ( Object obj ) { if ( obj = = null | | obj instanceof MQVuserKeyingMaterial ) { return ( MQVuserKeyingMaterial ) obj ; } if ( obj instanceof ASN1Sequence ) { return new MQVuserKeyingMaterial ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid MQVuserKeyingMaterial: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( ephemeralPublicKey ) ; if ( addedukm ! = null ) { v . add ( new DERTaggedObject ( true , 0 , addedukm ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( type ) ; v . add ( value ) ; return new DERSequence ( v ) ; } 
public CertReqMsg [ ] toCertReqMsgArray ( ) { CertReqMsg [ ] result = new CertReqMsg [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = CertReqMsg . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certReq ) ; addOptional ( v , pop ) ; addOptional ( v , regInfo ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certReqId ) ; v . add ( certTemplate ) ; if ( controls ! = null ) { v . add ( controls ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; addOptional ( v , 0 , false , version ) ; addOptional ( v , 1 , false , serialNumber ) ; addOptional ( v , 2 , false , signingAlg ) ; addOptional ( v , 3 , true , issuer ) ; CHOICE addOptional(v, 4, false, validity); addOptional(v, 5, true, subject); CHOICE addOptional(v, 6, false, publicKey); addOptional(v, 7, false, issuerUID); addOptional(v, 8, false, subjectUID); addOptional(v, 9, false, extensions); return new DERSequence(v); } 
private void addOptional ( ASN1EncodableVector v , int tagNo , boolean isExplicit , ASN1Encodable obj ) { if ( obj ! = null ) { 
public AttributeTypeAndValue [ ] toAttributeTypeAndValueArray ( ) { AttributeTypeAndValue [ ] result = new AttributeTypeAndValue [ content . size ( ) ] ; for ( int i = 0 ; i ! = result . length ; i + + ) { result [ i ] = AttributeTypeAndValue . getInstance ( content . getObjectAt ( i ) ) ; } return result ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; addOptional ( v , 0 , intendedAlg ) ; addOptional ( v , 1 , symmAlg ) ; addOptional ( v , 2 , encSymmKey ) ; addOptional ( v , 3 , keyAlg ) ; addOptional ( v , 4 , valueHint ) ; v . add ( encValue ) ; return new DERSequence ( v ) ; } 
private void addOptional ( ASN1EncodableVector v , int tagNo , ASN1Encodable obj ) { if ( obj ! = null ) { 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( notBefore ! = null ) { v . add ( new DERTaggedObject ( true , 0 , notBefore ) ) ; } if ( notAfter ! = null ) { v . add ( new DERTaggedObject ( true , 1 , notAfter ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { return obj ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( poposkInput ! = null ) { v . add ( poposkInput ) ; } v . add ( algorithmIdentifier ) ; v . add ( signature ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( authInfo ) ; v . add ( publicKey ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { return new DERTaggedObject ( false , tagNo , obj ) ; } 
public static ECGOST3410ParamSetParameters getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static ECGOST3410ParamSetParameters getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ECGOST3410ParamSetParameters ) { return ( ECGOST3410ParamSetParameters ) obj ; } if ( obj instanceof ASN1Sequence ) { return new ECGOST3410ParamSetParameters ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid GOST3410Parameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( a ) ; v . add ( b ) ; v . add ( p ) ; v . add ( q ) ; v . add ( x ) ; v . add ( y ) ; return new DERSequence ( v ) ; } 
public static GOST28147Parameters getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static GOST28147Parameters getInstance ( Object obj ) { if ( obj = = null | | obj instanceof GOST28147Parameters ) { return ( GOST28147Parameters ) obj ; } if ( obj instanceof ASN1Sequence ) { return new GOST28147Parameters ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid GOST3410Parameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( iv ) ; v . add ( paramSet ) ; return new DERSequence ( v ) ; } 
public static GOST3410ParamSetParameters getByOID ( DERObjectIdentifier oid ) { return ( GOST3410ParamSetParameters ) params . get ( oid ) ; } 
public static GOST3410ParamSetParameters getByName ( String name ) { DERObjectIdentifier oid = ( DERObjectIdentifier ) objIds . get ( name ) ; if ( oid ! = null ) { return ( GOST3410ParamSetParameters ) params . get ( oid ) ; } return null ; } 
public static GOST3410ParamSetParameters getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static GOST3410ParamSetParameters getInstance ( Object obj ) { if ( obj = = null | | obj instanceof GOST3410ParamSetParameters ) { return ( GOST3410ParamSetParameters ) obj ; } if ( obj instanceof ASN1Sequence ) { return new GOST3410ParamSetParameters ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid GOST3410Parameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( keySize ) ) ; v . add ( p ) ; v . add ( q ) ; v . add ( a ) ; return new DERSequence ( v ) ; } 
public static GOST3410PublicKeyAlgParameters getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static GOST3410PublicKeyAlgParameters getInstance ( Object obj ) { if ( obj = = null | | obj instanceof GOST3410PublicKeyAlgParameters ) { return ( GOST3410PublicKeyAlgParameters ) obj ; } if ( obj instanceof ASN1Sequence ) { return new GOST3410PublicKeyAlgParameters ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid GOST3410Parameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( publicKeyParamSet ) ; v . add ( digestParamSet ) ; if ( encryptionParamSet ! = null ) { v . add ( encryptionParamSet ) ; } return new DERSequence ( v ) ; } 
public static CommitmentTypeIndication getInstance ( Object obj ) { if ( obj = = null | | obj instanceof CommitmentTypeIndication ) { return ( CommitmentTypeIndication ) obj ; } return new CommitmentTypeIndication ( ASN1Sequence . getInstance ( obj ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( commitmentTypeId ) ; if ( commitmentTypeQualifier ! = null ) { v . add ( commitmentTypeQualifier ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector dev = new ASN1EncodableVector ( ) ; dev . add ( commitmentTypeIdentifier ) ; if ( qualifier ! = null ) { dev . add ( qualifier ) ; } return new DERSequence ( dev ) ; } 
public static OtherHashAlgAndValue getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OtherHashAlgAndValue ) { return ( OtherHashAlgAndValue ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new OtherHashAlgAndValue ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in 'OtherHashAlgAndValue' factory : " 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( hashAlgorithm ) ; v . add ( hashValue ) ; return new DERSequence ( v ) ; } 
public static SPUserNotice getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SPUserNotice ) { return ( SPUserNotice ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SPUserNotice ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in 'SPUserNotice' factory : " 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( noticeRef ! = null ) { v . add ( noticeRef ) ; } if ( explicitText ! = null ) { v . add ( explicitText ) ; } return new DERSequence ( v ) ; } 
public static SPuri getInstance ( Object obj ) { if ( obj instanceof SPuri ) { return ( SPuri ) obj ; } else if ( obj instanceof DERIA5String ) { return new SPuri ( ( DERIA5String ) obj ) ; } throw new IllegalArgumentException ( " unknown object in 'SPuri' factory: " 
public DERObject toASN1Object ( ) { return uri . getDERObject ( ) ; } 
public static SigPolicyQualifierInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SigPolicyQualifierInfo ) { return ( SigPolicyQualifierInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SigPolicyQualifierInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in 'SigPolicyQualifierInfo' factory: " 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( sigPolicyQualifierId ) ; v . add ( sigQualifier ) ; return new DERSequence ( v ) ; } 
public static SigPolicyQualifiers getInstance ( Object obj ) { if ( obj instanceof SigPolicyQualifiers ) { return ( SigPolicyQualifiers ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SigPolicyQualifiers ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in 'SigPolicyQualifiers' factory: " 
public int size ( ) { return qualifiers . size ( ) ; } 
public SigPolicyQualifierInfo getStringAt ( int i ) { return SigPolicyQualifierInfo . getInstance ( qualifiers . getObjectAt ( i ) ) ; } 
public DERObject toASN1Object ( ) { return qualifiers ; } 
public static SignaturePolicyId getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SignaturePolicyId ) { return ( SignaturePolicyId ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SignaturePolicyId ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Unknown object in 'SignaturePolicyId' factory : " 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( sigPolicyId ) ; v . add ( sigPolicyHash ) ; if ( sigPolicyQualifiers ! = null ) { v . add ( sigPolicyQualifiers ) ; } return new DERSequence ( v ) ; } 
public static SignaturePolicyIdentifier getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SignaturePolicyIdentifier ) { return ( SignaturePolicyIdentifier ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SignaturePolicyIdentifier ( SignaturePolicyId . getInstance ( obj ) ) ; } else if ( obj instanceof ASN1Null ) { return new SignaturePolicyIdentifier ( ) ; } throw new IllegalArgumentException ( " unknown object in 'SignaturePolicyIdentifier' factory: " 
public boolean isSignaturePolicyImplied ( ) { return isSignaturePolicyImplied ; } 
public DERObject toASN1Object ( ) { if ( isSignaturePolicyImplied ) { 
public static SignerLocation getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SignerLocation ) { return ( SignerLocation ) obj ; } return new SignerLocation ( ASN1Sequence . getInstance ( obj ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( countryName ! = null ) { v . add ( new DERTaggedObject ( true , 0 , countryName ) ) ; } if ( localityName ! = null ) { v . add ( new DERTaggedObject ( true , 1 , localityName ) ) ; } if ( postalAddress ! = null ) { v . add ( new DERTaggedObject ( true , 2 , postalAddress ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( contentDescription ! = null ) { v . add ( contentDescription ) ; } v . add ( contentType ) ; return new DERSequence ( v ) ; } 
public static DataGroupHash getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DataGroupHash ) { return ( DataGroupHash ) obj ; } if ( obj instanceof ASN1Sequence ) { 
public DERObject toASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( dataGroupNumber ) ; seq . add ( dataGroupHashValue ) ; return new DERSequence ( seq ) ; } 
public static LDSSecurityObject getInstance ( Object obj ) { if ( obj = = null | | obj instanceof LDSSecurityObject ) { return ( LDSSecurityObject ) obj ; } if ( obj instanceof ASN1Sequence ) { return new LDSSecurityObject ( ASN1Sequence . getInstance ( obj ) ) ; } throw new IllegalArgumentException ( " unknown object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
private void checkDatagroupHashSeqSize ( int size ) { if ( ( size < 2 ) | | ( size > ub_DataGroups ) ) { 
public DERObject toASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( version ) ; seq . add ( digestAlgorithmIdentifier ) ; ASN1EncodableVector seqname = new ASN1EncodableVector ( ) ; for ( int i = 0 ; i < datagroupHash . length ; i + + ) { seqname . add ( datagroupHash [ i ] ) ; } seq . add ( new DERSequence ( seqname ) ) ; return new DERSequence ( seq ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; vec . add ( hashAlgorithm ) ; vec . add ( new DEROctetString ( certificateHash ) ) ; return new DERSequence ( vec ) ; } 
public DERObject toASN1Object ( ) { if ( publicKeyCert ! = null ) { return new DERTaggedObject ( 0 , new DEROctetString ( publicKeyCert ) ) ; } if ( attributeCert ! = null ) { return new DERTaggedObject ( 1 , new DEROctetString ( attributeCert ) ) ; } return cert . getDERObject ( ) ; } 
public DERObject toASN1Object ( ) { return information . toASN1Object ( ) ; } 
public DERObject toASN1Object ( ) { return declaration ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( currency ) ; seq . add ( amount ) ; seq . add ( exponent ) ; return new DERSequence ( seq ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; if ( namingAuthorityId ! = null ) { vec . add ( namingAuthorityId ) ; } if ( namingAuthorityUrl ! = null ) { vec . add ( new DERIA5String ( namingAuthorityUrl , true ) ) ; } if ( namingAuthorityText ! = null ) { vec . add ( namingAuthorityText ) ; } return new DERSequence ( vec ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; if ( namingAuthority ! = null ) { vec . add ( new DERTaggedObject ( true , 0 , namingAuthority ) ) ; } vec . add ( professionItems ) ; if ( professionOIDs ! = null ) { vec . add ( professionOIDs ) ; } if ( registrationNumber ! = null ) { vec . add ( new DERPrintableString ( registrationNumber , true ) ) ; } if ( addProfessionInfo ! = null ) { vec . add ( addProfessionInfo ) ; } return new DERSequence ( vec ) ; } 
public DERObject toASN1Object ( ) { return restriction . toASN1Object ( ) ; } 
public static CAST5CBCParameters getInstance ( Object o ) { if ( o instanceof CAST5CBCParameters ) { return ( CAST5CBCParameters ) o ; } else if ( o instanceof ASN1Sequence ) { return new CAST5CBCParameters ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in CAST5CBCParameter factory " ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( iv ) ; v . add ( keyLength ) ; return new DERSequence ( v ) ; } 
public static IDEACBCPar getInstance ( Object o ) { if ( o instanceof IDEACBCPar ) { return ( IDEACBCPar ) o ; } else if ( o instanceof ASN1Sequence ) { return new IDEACBCPar ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in IDEACBCPar factory " ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( iv ! = null ) { v . add ( iv ) ; } return new DERSequence ( v ) ; } 
public String toString ( ) { return " NetscapeCertType: 0x " + Integer . toHexString ( data [ 0 ] & 0xff ) ; } 
public String toString ( ) { return " NetscapeRevocationURL: " + this . getString ( ) ; } 
public String toString ( ) { return " VerisignCzagExtension: " + this . getString ( ) ; } 
public DERObject toASN1Object ( ) { return pkacSeq ; } 
public static BasicOCSPResponse getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static BasicOCSPResponse getInstance ( Object obj ) { if ( obj = = null | | obj instanceof BasicOCSPResponse ) { return ( BasicOCSPResponse ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new BasicOCSPResponse ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( tbsResponseData ) ; v . add ( signatureAlgorithm ) ; v . add ( signature ) ; if ( certs ! = null ) { v . add ( new DERTaggedObject ( true , 0 , certs ) ) ; } return new DERSequence ( v ) ; } 
public static CertID getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static CertID getInstance ( Object obj ) { if ( obj = = null | | obj instanceof CertID ) { return ( CertID ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new CertID ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( hashAlgorithm ) ; v . add ( issuerNameHash ) ; v . add ( issuerKeyHash ) ; v . add ( serialNumber ) ; return new DERSequence ( v ) ; } 
public static CertStatus getInstance ( Object obj ) { if ( obj = = null | | obj instanceof CertStatus ) { return ( CertStatus ) obj ; } else if ( obj instanceof ASN1TaggedObject ) { return new CertStatus ( ( ASN1TaggedObject ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public static CertStatus getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; must be explicitly tagged } 
public DERObject toASN1Object ( ) { return new DERTaggedObject ( false , tagNo , value ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( crlUrl ! = null ) { v . add ( new DERTaggedObject ( true , 0 , crlUrl ) ) ; } if ( crlNum ! = null ) { v . add ( new DERTaggedObject ( true , 1 , crlNum ) ) ; } if ( crlTime ! = null ) { v . add ( new DERTaggedObject ( true , 2 , crlTime ) ) ; } return new DERSequence ( v ) ; } 
public static OCSPResponse getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static OCSPResponse getInstance ( Object obj ) { if ( obj = = null | | obj instanceof OCSPResponse ) { return ( OCSPResponse ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new OCSPResponse ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( responseStatus ) ; if ( responseBytes ! = null ) { v . add ( new DERTaggedObject ( true , 0 , responseBytes ) ) ; } return new DERSequence ( v ) ; } 
public static Request getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static Request getInstance ( Object obj ) { if ( obj = = null | | obj instanceof Request ) { return ( Request ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new Request ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( reqCert ) ; if ( singleRequestExtensions ! = null ) { v . add ( new DERTaggedObject ( true , 0 , singleRequestExtensions ) ) ; } return new DERSequence ( v ) ; } 
public static ResponderID getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; must be explicitly tagged } 
public DERObject toASN1Object ( ) { if ( value instanceof ASN1OctetString ) { return new DERTaggedObject ( true , 2 , value ) ; } return new DERTaggedObject ( true , 1 , value ) ; } 
public static ResponseBytes getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static ResponseBytes getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ResponseBytes ) { return ( ResponseBytes ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new ResponseBytes ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( responseType ) ; v . add ( response ) ; return new DERSequence ( v ) ; } 
public static ResponseData getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static ResponseData getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ResponseData ) { return ( ResponseData ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new ResponseData ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( versionPresent | | ! version . equals ( V1 ) ) { v . add ( new DERTaggedObject ( true , 0 , version ) ) ; } v . add ( responderID ) ; v . add ( producedAt ) ; v . add ( responses ) ; if ( responseExtensions ! = null ) { v . add ( new DERTaggedObject ( true , 1 , responseExtensions ) ) ; } return new DERSequence ( v ) ; } 
public static RevokedInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static RevokedInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof RevokedInfo ) { return ( RevokedInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new RevokedInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( revocationTime ) ; if ( revocationReason ! = null ) { v . add ( new DERTaggedObject ( true , 0 , revocationReason ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( issuer ) ; if ( locator ! = null ) { v . add ( locator ) ; } return new DERSequence ( v ) ; } 
public static Signature getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static Signature getInstance ( Object obj ) { if ( obj = = null | | obj instanceof Signature ) { return ( Signature ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new Signature ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( signatureAlgorithm ) ; v . add ( signature ) ; if ( certs ! = null ) { v . add ( new DERTaggedObject ( true , 0 , certs ) ) ; } return new DERSequence ( v ) ; } 
public static SingleResponse getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static SingleResponse getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SingleResponse ) { return ( SingleResponse ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SingleResponse ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certID ) ; v . add ( certStatus ) ; v . add ( thisUpdate ) ; if ( nextUpdate ! = null ) { v . add ( new DERTaggedObject ( true , 0 , nextUpdate ) ) ; } if ( singleExtensions ! = null ) { v . add ( new DERTaggedObject ( true , 1 , singleExtensions ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( p ) ; v . add ( g ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; for ( int i = 0 ; i ! = info . length ; i + + ) { v . add ( info [ i ] ) ; } return new BERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( certId ) ; v . add ( new DERTaggedObject ( 0 , certValue ) ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { Construct the CertificateRequest ASN1EncodableVector v = new ASN1EncodableVector(); v.add(reqInfo); v.add(sigAlgId); v.add(sigBits); return new DERSequence(v); } 
public static CertificationRequestInfo getInstance ( Object obj ) { if ( obj instanceof CertificationRequestInfo ) { return ( CertificationRequestInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new CertificationRequestInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( subject ) ; v . add ( subjectPKInfo ) ; if ( attributes ! = null ) { v . add ( new DERTaggedObject ( false , 0 , attributes ) ) ; } return new DERSequence ( v ) ; } 
public static ContentInfo getInstance ( Object obj ) { if ( obj instanceof ContentInfo ) { return ( ContentInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new ContentInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public static EncryptedData getInstance ( Object obj ) { if ( obj instanceof EncryptedData ) { return ( EncryptedData ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new EncryptedData ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( 0 ) ) ; v . add ( data ) ; return new BERSequence ( v ) ; } 
public static EncryptedPrivateKeyInfo getInstance ( Object obj ) { if ( obj instanceof EncryptedData ) { return ( EncryptedPrivateKeyInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new EncryptedPrivateKeyInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algId ) ; v . add ( data ) ; return new DERSequence ( v ) ; } 
public static IssuerAndSerialNumber getInstance ( Object obj ) { if ( obj instanceof IssuerAndSerialNumber ) { return ( IssuerAndSerialNumber ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new IssuerAndSerialNumber ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( name ) ; v . add ( certSerialNumber ) ; return new DERSequence ( v ) ; } 
public static MacData getInstance ( Object obj ) { if ( obj instanceof MacData ) { return ( MacData ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new MacData ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( digInfo ) ; v . add ( new DEROctetString ( salt ) ) ; if ( ! iterationCount . equals ( ONE ) ) { v . add ( new DERInteger ( iterationCount ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( func ) ; v . add ( scheme ) ; return new DERSequence ( v ) ; } 
public static PBKDF2Params getInstance ( Object obj ) { if ( obj instanceof PBKDF2Params ) { return ( PBKDF2Params ) obj ; } if ( obj instanceof ASN1Sequence ) { return new PBKDF2Params ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( octStr ) ; v . add ( iterationCount ) ; if ( keyLength ! = null ) { v . add ( keyLength ) ; } return new DERSequence ( v ) ; } 
public static PKCS12PBEParams getInstance ( Object obj ) { if ( obj instanceof PKCS12PBEParams ) { return ( PKCS12PBEParams ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new PKCS12PBEParams ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( iv ) ; v . add ( iterations ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( 3 ) ) ; v . add ( contentInfo ) ; if ( macData ! = null ) { v . add ( macData ) ; } return new BERSequence ( v ) ; } 
public static PrivateKeyInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static PrivateKeyInfo getInstance ( Object obj ) { if ( obj instanceof PrivateKeyInfo ) { return ( PrivateKeyInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new PrivateKeyInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( 0 ) ) ; v . add ( algId ) ; v . add ( new DEROctetString ( privKey ) ) ; if ( attributes ! = null ) { v . add ( new DERTaggedObject ( false , 0 , attributes ) ) ; } return new DERSequence ( v ) ; } 
public static RC2CBCParameter getInstance ( Object o ) { if ( o instanceof ASN1Sequence ) { return new RC2CBCParameter ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in RC2CBCParameter factory " ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( version ! = null ) { v . add ( version ) ; } v . add ( iv ) ; return new DERSequence ( v ) ; } 
public static RSAESOAEPparams getInstance ( Object obj ) { if ( obj instanceof RSAESOAEPparams ) { return ( RSAESOAEPparams ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new RSAESOAEPparams ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( ! hashAlgorithm . equals ( DEFAULT_HASH_ALGORITHM ) ) { v . add ( new DERTaggedObject ( true , 0 , hashAlgorithm ) ) ; } if ( ! maskGenAlgorithm . equals ( DEFAULT_MASK_GEN_FUNCTION ) ) { v . add ( new DERTaggedObject ( true , 1 , maskGenAlgorithm ) ) ; } if ( ! pSourceAlgorithm . equals ( DEFAULT_P_SOURCE_ALGORITHM ) ) { v . add ( new DERTaggedObject ( true , 2 , pSourceAlgorithm ) ) ; } return new DERSequence ( v ) ; } 
public static RSAPrivateKeyStructure getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static RSAPrivateKeyStructure getInstance ( Object obj ) { if ( obj instanceof RSAPrivateKeyStructure ) { return ( RSAPrivateKeyStructure ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new RSAPrivateKeyStructure ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( version ) ) ; version v.add(new DERInteger(getModulus())); v.add(new DERInteger(getPublicExponent())); v.add(new DERInteger(getPrivateExponent())); v.add(new DERInteger(getPrime1())); v.add(new DERInteger(getPrime2())); v.add(new DERInteger(getExponent1())); v.add(new DERInteger(getExponent2())); v.add(new DERInteger(getCoefficient())); if (otherPrimeInfos != null) { v.add(otherPrimeInfos); } return new DERSequence(v); } 
public static RSASSAPSSparams getInstance ( Object obj ) { if ( obj = = null | | obj instanceof RSASSAPSSparams ) { return ( RSASSAPSSparams ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new RSASSAPSSparams ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( ! hashAlgorithm . equals ( DEFAULT_HASH_ALGORITHM ) ) { v . add ( new DERTaggedObject ( true , 0 , hashAlgorithm ) ) ; } if ( ! maskGenAlgorithm . equals ( DEFAULT_MASK_GEN_FUNCTION ) ) { v . add ( new DERTaggedObject ( true , 1 , maskGenAlgorithm ) ) ; } if ( ! saltLength . equals ( DEFAULT_SALT_LENGTH ) ) { v . add ( new DERTaggedObject ( true , 2 , saltLength ) ) ; } if ( ! trailerField . equals ( DEFAULT_TRAILER_FIELD ) ) { v . add ( new DERTaggedObject ( true , 3 , trailerField ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( bagId ) ; v . add ( new DERTaggedObject ( 0 , bagValue ) ) ; if ( bagAttributes ! = null ) { v . add ( bagAttributes ) ; } return new DERSequence ( v ) ; } 
public static SignedData getInstance ( Object o ) { if ( o instanceof SignedData ) { return ( SignedData ) o ; } else if ( o instanceof ASN1Sequence ) { return new SignedData ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + o ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( digestAlgorithms ) ; v . add ( contentInfo ) ; if ( certificates ! = null ) { v . add ( new DERTaggedObject ( false , 0 , certificates ) ) ; } if ( crls ! = null ) { v . add ( new DERTaggedObject ( false , 1 , crls ) ) ; } v . add ( signerInfos ) ; return new BERSequence ( v ) ; } 
public static SignerInfo getInstance ( Object o ) { if ( o instanceof SignerInfo ) { return ( SignerInfo ) o ; } else if ( o instanceof ASN1Sequence ) { return new SignerInfo ( ( ASN1Sequence ) o ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( issuerAndSerialNumber ) ; v . add ( digAlgorithm ) ; if ( authenticatedAttributes ! = null ) { v . add ( new DERTaggedObject ( false , 0 , authenticatedAttributes ) ) ; } v . add ( digEncryptionAlgorithm ) ; v . add ( encryptedDigest ) ; if ( unauthenticatedAttributes ! = null ) { v . add ( new DERTaggedObject ( false , 1 , unauthenticatedAttributes ) ) ; } return new DERSequence ( v ) ; } 
public static SMIMECapabilities getInstance ( Object o ) { if ( o = = null | | o instanceof SMIMECapabilities ) { return ( SMIMECapabilities ) o ; } if ( o instanceof ASN1Sequence ) { return new SMIMECapabilities ( ( ASN1Sequence ) o ) ; } if ( o instanceof Attribute ) { return new SMIMECapabilities ( ( ASN1Sequence ) ( ( ( Attribute ) o ) . getAttrValues ( ) . getObjectAt ( 0 ) ) ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + o . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { return capabilities ; } 
public static SMIMECapability getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SMIMECapability ) { return ( SMIMECapability ) obj ; } if ( obj instanceof ASN1Sequence ) { return new SMIMECapability ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid SMIMECapability " ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( capabilityID ) ; if ( parameters ! = null ) { v . add ( parameters ) ; } return new DERSequence ( v ) ; } 
public void addCapability ( DERObjectIdentifier capability ) { capabilities . add ( new DERSequence ( capability ) ) ; } 
public void addCapability ( DERObjectIdentifier capability , int value ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( capability ) ; v . add ( new DERInteger ( value ) ) ; capabilities . add ( new DERSequence ( v ) ) ; } 
public void addCapability ( DERObjectIdentifier capability , DEREncodable params ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( capability ) ; v . add ( params ) ; capabilities . add ( new DERSequence ( v ) ) ; } 
public DEREncodableVector toDEREncodableVector ( ) { return capabilities ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( seconds ! = null ) { v . add ( seconds ) ; } if ( millis ! = null ) { v . add ( new DERTaggedObject ( false , 0 , millis ) ) ; } if ( micros ! = null ) { v . add ( new DERTaggedObject ( false , 1 , micros ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( hashAlgorithm ) ; v . add ( new DEROctetString ( hashedMessage ) ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( messageImprint ) ; if ( tsaPolicy ! = null ) { v . add ( tsaPolicy ) ; } if ( nonce ! = null ) { v . add ( nonce ) ; } if ( certReq ! = null & & certReq . isTrue ( ) ) { v . add ( certReq ) ; } if ( extensions ! = null ) { v . add ( new DERTaggedObject ( false , 0 , extensions ) ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( pkiStatusInfo ) ; if ( timeStampToken ! = null ) { v . add ( timeStampToken ) ; } return new DERSequence ( v ) ; } 
tstatic void _dumpAsString ( String indent , boolean verbose , DERObject obj , StringBuffer buf ) { String nl = System . getProperty ( " line.separator " ) ; if ( obj instanceof ASN1Sequence ) { 
public static String dumpAsString ( Object obj ) { return dumpAsString ( obj , false ) ; } 
public static String dumpAsString ( Object obj , boolean verbose ) { StringBuffer buf = new StringBuffer ( ) ; if ( obj instanceof DERObject ) { _dumpAsString ( " " , verbose , ( DERObject ) obj , buf ) ; } else if ( obj instanceof DEREncodable ) { _dumpAsString ( " " , verbose , ( ( DEREncodable ) obj ) . getDERObject ( ) , buf ) ; } else { return " unknown object type " + obj . toString ( ) ; } return buf . toString ( ) ; } 
private static String dumpBinaryDataAsString ( String indent , byte [ ] bytes ) { String nl = System . getProperty ( " line.separator " ) ; StringBuffer buf = new StringBuffer ( ) ; indent + = TAB ; buf . append ( nl ) ; for ( int i = 0 ; i < bytes . length ; i + = SAMPLE_SIZE ) { if ( bytes . length - i > SAMPLE_SIZE ) { buf . append ( indent ) ; buf . append ( new String ( Hex . encode ( bytes , i , SAMPLE_SIZE ) ) ) ; buf . append ( TAB ) ; buf . append ( calculateAscString ( bytes , i , SAMPLE_SIZE ) ) ; buf . append ( nl ) ; } else { buf . append ( indent ) ; buf . append ( new String ( Hex . encode ( bytes , i , bytes . length - i ) ) ) ; for ( int j = bytes . length - i ; j ! = SAMPLE_SIZE ; j + + ) { buf . append ( " " ) ; } buf . append ( TAB ) ; buf . append ( calculateAscString ( bytes , i , bytes . length - i ) ) ; buf . append ( nl ) ; } } return buf . toString ( ) ; } 
private static String calculateAscString ( byte [ ] bytes , int off , int len ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = off ; i ! = off + len ; i + + ) { if ( bytes [ i ] > = ' ' & & bytes [ i ] < = '~' ) { buf . append ( ( char ) bytes [ i ] ) ; } } return buf . toString ( ) ; } 
public static String dumpAsString ( DERObject obj ) { StringBuffer buf = new StringBuffer ( ) ; _dumpAsString ( " " , false , obj , buf ) ; return buf . toString ( ) ; } 
public static String dumpAsString ( DEREncodable obj ) { StringBuffer buf = new StringBuffer ( ) ; _dumpAsString ( " " , false , obj . getDERObject ( ) , buf ) ; return buf . toString ( ) ; } 
public static void main ( String args [ ] ) throws Exception { FileInputStream fIn = new FileInputStream ( args [ 0 ] ) ; ASN1InputStream bIn = new ASN1InputStream ( fIn ) ; Object obj = null ; while ( ( obj = bIn . readObject ( ) ) ! = null ) { 
public String toString ( ) { return string . getString ( ) ; } 
public DERObject toASN1Object ( ) { return ( ( DEREncodable ) string ) . getDERObject ( ) ; } 
public static AlgorithmIdentifier getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static AlgorithmIdentifier getInstance ( Object obj ) { if ( obj = = null | | obj instanceof AlgorithmIdentifier ) { return ( AlgorithmIdentifier ) obj ; } if ( obj instanceof DERObjectIdentifier ) { return new AlgorithmIdentifier ( ( DERObjectIdentifier ) obj ) ; } if ( obj instanceof String ) { return new AlgorithmIdentifier ( ( String ) obj ) ; } if ( obj instanceof ASN1Sequence ) { return new AlgorithmIdentifier ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( objectId ) ; if ( parametersDefined ) { v . add ( parameters ) ; } return new DERSequence ( v ) ; } 
public static AttCertValidityPeriod getInstance ( Object obj ) { if ( obj instanceof AttCertValidityPeriod ) { return ( AttCertValidityPeriod ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new AttCertValidityPeriod ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( notBeforeTime ) ; v . add ( notAfterTime ) ; return new DERSequence ( v ) ; } 
public static BasicConstraints getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static BasicConstraints getInstance ( Object obj ) { if ( obj = = null | | obj instanceof BasicConstraints ) { return ( BasicConstraints ) obj ; } if ( obj instanceof ASN1Sequence ) { return new BasicConstraints ( ( ASN1Sequence ) obj ) ; } if ( obj instanceof X509Extension ) { return getInstance ( X509Extension . convertValueToObject ( ( X509Extension ) obj ) ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public boolean isCA ( ) { return ( cA ! = null ) & & cA . isTrue ( ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( cA ! = null ) { v . add ( cA ) ; } if ( pathLenConstraint ! = null ) yes some people actually do this when cA is false... { v.add(pathLenConstraint); } return new DERSequence(v); } 
public String toString ( ) { if ( pathLenConstraint = = null ) { if ( cA = = null ) { return " BasicConstraints: isCa(false) " ; } return " BasicConstraints: isCa( " + this . isCA ( ) + " ) " ; } return " BasicConstraints: isCa( " + this . isCA ( ) + " ), pathLenConstraint = " + pathLenConstraint . getValue ( ) ; } 
public String toString ( ) { return " CRLNumber: " + getCRLNumber ( ) ; } 
public String toString ( ) { String str ; int reason = getValue ( ) . intValue ( ) ; if ( reason < 0 | | reason > 10 ) { str = " invalid " ; } else { str = reasonString [ reason ] ; } return " CRLReason: " + str ; } 
public static CertificateList getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static CertificateList getInstance ( Object obj ) { if ( obj instanceof CertificateList ) { return ( CertificateList ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new CertificateList ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( tbsCertList ) ; v . add ( sigAlgId ) ; v . add ( sig ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; if ( forward ! = null ) { vec . add ( new DERTaggedObject ( 0 , forward ) ) ; } if ( reverse ! = null ) { vec . add ( new DERTaggedObject ( 1 , reverse ) ) ; } return new DERSequence ( vec ) ; } 
public static CertificatePolicies getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static CertificatePolicies getInstance ( Object obj ) { if ( obj instanceof CertificatePolicies ) { return ( CertificatePolicies ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new CertificatePolicies ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public void addPolicy ( String p ) { policies . addElement ( new DERObjectIdentifier ( p ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; We only do policyIdentifier yet... for (int i=0;i<policies.size();i++) { v.add(new DERSequence((DERObjectIdentifier)policies.elementAt(i))); } return new DERSequence(v); } 
public String toString ( ) { String p = null ; for ( int i = 0 ; i < policies . size ( ) ; i + + ) { if ( p ! = null ) { p + = " , " ; } p + = ( ( DERObjectIdentifier ) policies . elementAt ( i ) ) . getId ( ) ; } return " CertificatePolicies: " + p ; } 
public static DSAParameter getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static DSAParameter getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DSAParameter ) { return ( DSAParameter ) obj ; } if ( obj instanceof ASN1Sequence ) { return new DSAParameter ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid DSAParameter: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( p ) ; v . add ( q ) ; v . add ( g ) ; return new DERSequence ( v ) ; } 
public static DigestInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static DigestInfo getInstance ( Object obj ) { if ( obj instanceof DigestInfo ) { return ( DigestInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new DigestInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algId ) ; v . add ( new DEROctetString ( digest ) ) ; return new DERSequence ( v ) ; } 
public static DisplayText getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; must be explicitly tagged } 
public DERObject toASN1Object ( ) { return ( DERObject ) contents ; } 
public static ExtendedKeyUsage getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static ExtendedKeyUsage getInstance ( Object obj ) { if ( obj instanceof ExtendedKeyUsage ) { return ( ExtendedKeyUsage ) obj ; } if ( obj instanceof ASN1Sequence ) { return new ExtendedKeyUsage ( ( ASN1Sequence ) obj ) ; } if ( obj instanceof X509Extension ) { return getInstance ( X509Extension . convertValueToObject ( ( X509Extension ) obj ) ) ; } throw new IllegalArgumentException ( " Invalid ExtendedKeyUsage: " + obj . getClass ( ) . getName ( ) ) ; } 
public boolean hasKeyPurposeId ( KeyPurposeId keyPurposeId ) { return ( usageTable . get ( keyPurposeId ) ! = null ) ; } 
public int size ( ) { return usageTable . size ( ) ; } 
public DERObject toASN1Object ( ) { return seq ; } 
public static DERBitString getInstance ( Object obj ) needs to be DERBitString for other VMs { if (obj instanceof KeyUsage) { return (KeyUsage)obj; } if (obj instanceof X509Extension) { return new KeyUsage(DERBitString.getInstance(X509Extension.convertValueToObject((X509Extension)obj))); } return new KeyUsage(DERBitString.getInstance(obj)); } 
public String toString ( ) { if ( data . length = = 1 ) { return " KeyUsage: 0x " + Integer . toHexString ( data [ 0 ] & 0xff ) ; } return " KeyUsage: 0x " + Integer . toHexString ( ( data [ 1 ] & 0xff ) < < 8 | ( data [ 0 ] & 0xff ) ) ; } 
public static NoticeReference getInstance ( Object as ) { if ( as instanceof NoticeReference ) { return ( NoticeReference ) as ; } else if ( as instanceof ASN1Sequence ) { return new NoticeReference ( ( ASN1Sequence ) as ) ; } throw new IllegalArgumentException ( " unknown object in getInstance. " ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector av = new ASN1EncodableVector ( ) ; av . add ( organization ) ; av . add ( noticeNumbers ) ; return new DERSequence ( av ) ; } 
public static ObjectDigestInfo getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ObjectDigestInfo ) { return ( ObjectDigestInfo ) obj ; } if ( obj instanceof ASN1Sequence ) { return new ObjectDigestInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; 
public static ObjectDigestInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( digestedObjectType ) ; if ( otherObjectTypeID ! = null ) { v . add ( otherObjectTypeID ) ; } v . add ( digestAlgorithm ) ; v . add ( objectDigest ) ; return new DERSequence ( v ) ; } 
public static PolicyInformation getInstance ( Object obj ) { if ( obj = = null | | obj instanceof PolicyInformation ) { return ( PolicyInformation ) obj ; } return new PolicyInformation ( ASN1Sequence . getInstance ( obj ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( policyIdentifier ) ; if ( policyQualifiers ! = null ) { v . add ( policyQualifiers ) ; } return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { return seq ; } 
public static PolicyQualifierInfo getInstance ( Object as ) { if ( as instanceof PolicyQualifierInfo ) { return ( PolicyQualifierInfo ) as ; } else if ( as instanceof ASN1Sequence ) { return new PolicyQualifierInfo ( ( ASN1Sequence ) as ) ; } throw new IllegalArgumentException ( " unknown object in getInstance. " ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector dev = new ASN1EncodableVector ( ) ; dev . add ( policyQualifierId ) ; dev . add ( qualifier ) ; return new DERSequence ( dev ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; if ( _notBefore ! = null ) { v . add ( new DERTaggedObject ( false , 0 , _notBefore ) ) ; } if ( _notAfter ! = null ) { v . add ( new DERTaggedObject ( false , 1 , _notAfter ) ) ; } return new DERSequence ( v ) ; } 
public static RSAPublicKeyStructure getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static RSAPublicKeyStructure getInstance ( Object obj ) { if ( obj = = null | | obj instanceof RSAPublicKeyStructure ) { return ( RSAPublicKeyStructure ) obj ; } if ( obj instanceof ASN1Sequence ) { return new RSAPublicKeyStructure ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " Invalid RSAPublicKeyStructure: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( new DERInteger ( getModulus ( ) ) ) ; v . add ( new DERInteger ( getPublicExponent ( ) ) ) ; return new DERSequence ( v ) ; } 
public static SubjectDirectoryAttributes getInstance ( Object obj ) { if ( obj = = null | | obj instanceof SubjectDirectoryAttributes ) { return ( SubjectDirectoryAttributes ) obj ; } if ( obj instanceof ASN1Sequence ) { return new SubjectDirectoryAttributes ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { vec . add ( ( Attribute ) e . nextElement ( ) ) ; } return new DERSequence ( vec ) ; } 
public static SubjectPublicKeyInfo getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static SubjectPublicKeyInfo getInstance ( Object obj ) { if ( obj instanceof SubjectPublicKeyInfo ) { return ( SubjectPublicKeyInfo ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new SubjectPublicKeyInfo ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public DERObject getPublicKey ( ) throws IOException { ASN1InputStream aIn = new ASN1InputStream ( keyData . getBytes ( ) ) ; return aIn . readObject ( ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algId ) ; v . add ( keyData ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { return seq ; } 
public boolean hasMoreElements ( ) { return en . hasMoreElements ( ) ; } 
public Object nextElement ( ) { return new CRLEntry ( ASN1Sequence . getInstance ( en . nextElement ( ) ) ) ; } 
public boolean hasMoreElements ( ) { return false ; } 
public Object nextElement ( ) { return null ; TODO: check exception handling } 
public static TBSCertList getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static TBSCertList getInstance ( Object obj ) { if ( obj instanceof TBSCertList ) { return ( TBSCertList ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new TBSCertList ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public static TBSCertificateStructure getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static TBSCertificateStructure getInstance ( Object obj ) { if ( obj instanceof TBSCertificateStructure ) { return ( TBSCertificateStructure ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new TBSCertificateStructure ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
public static Time getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( obj . getObject ( ) ) ; must be explicitly tagged } 
public String toString ( ) { return getTime ( ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector av = new ASN1EncodableVector ( ) ; if ( noticeRef ! = null ) { av . add ( noticeRef ) ; } if ( explicitText ! = null ) { av . add ( explicitText ) ; } return new DERSequence ( av ) ; } 
public void setSerialNumber ( DERInteger serialNumber ) { this . serialNumber = serialNumber ; } 
public void setSignature ( AlgorithmIdentifier signature ) { this . signature = signature ; } 
public void setIssuer ( X509Name issuer ) { this . issuer = issuer ; } 
public void setStartDate ( Time startDate ) { this . startDate = startDate ; } 
public void setStartDate ( DERUTCTime startDate ) { this . startDate = new Time ( startDate ) ; } 
public void setEndDate ( Time endDate ) { this . endDate = endDate ; } 
public void setEndDate ( DERUTCTime endDate ) { this . endDate = new Time ( endDate ) ; } 
public void setSubject ( X509Name subject ) { this . subject = subject ; } 
public void setSubjectPublicKeyInfo ( SubjectPublicKeyInfo pubKeyInfo ) { this . subjectPublicKeyInfo = pubKeyInfo ; } 
public TBSCertificateStructure generateTBSCertificate ( ) { if ( ( serialNumber = = null ) | | ( signature = = null ) | | ( issuer = = null ) | | ( startDate = = null ) | | ( endDate = = null ) | | ( subject = = null ) | | ( subjectPublicKeyInfo = = null ) ) { throw new IllegalStateException ( " not all mandatory fields set in V1 TBScertificate generator " ) ; } ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq.add(version); - not required as default value. seq.add(serialNumber); seq.add(signature); seq.add(issuer); before and after dates ASN1EncodableVector validity = new ASN1EncodableVector(); validity.add(startDate); validity.add(endDate); seq.add(new DERSequence(validity)); seq.add(subject); seq.add(subjectPublicKeyInfo); return new TBSCertificateStructure(new DERSequence(seq)); } 
public void setThisUpdate ( DERUTCTime thisUpdate ) { this . thisUpdate = new Time ( thisUpdate ) ; } 
public void setNextUpdate ( DERUTCTime nextUpdate ) { this . nextUpdate = new Time ( nextUpdate ) ; } 
public void setThisUpdate ( Time thisUpdate ) { this . thisUpdate = thisUpdate ; } 
public void setNextUpdate ( Time nextUpdate ) { this . nextUpdate = nextUpdate ; } 
public void addCRLEntry ( ASN1Sequence crlEntry ) { if ( crlentries = = null ) { crlentries = new Vector ( ) ; } crlentries . addElement ( crlEntry ) ; } 
public void addCRLEntry ( DERInteger userCertificate , DERUTCTime revocationDate , int reason ) { addCRLEntry ( userCertificate , new Time ( revocationDate ) , reason ) ; } 
public void addCRLEntry ( DERInteger userCertificate , Time revocationDate , int reason ) { addCRLEntry ( userCertificate , revocationDate , reason , null ) ; } 
public void addCRLEntry ( DERInteger userCertificate , Time revocationDate , int reason , DERGeneralizedTime invalidityDate ) { Vector extOids = new Vector ( ) ; Vector extValues = new Vector ( ) ; if ( reason ! = 0 ) { CRLReason crlReason = new CRLReason ( reason ) ; try { extOids . addElement ( X509Extensions . ReasonCode ) ; extValues . addElement ( new X509Extension ( false , new DEROctetString ( crlReason . getEncoded ( ) ) ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " error encoding reason: " + e ) ; } } if ( invalidityDate ! = null ) { try { extOids . addElement ( X509Extensions . InvalidityDate ) ; extValues . addElement ( new X509Extension ( false , new DEROctetString ( invalidityDate . getEncoded ( ) ) ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " error encoding invalidityDate: " + e ) ; } } if ( extOids . size ( ) ! = 0 ) { 
public void addCRLEntry ( DERInteger userCertificate , Time revocationDate , X509Extensions extensions ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( userCertificate ) ; v . add ( revocationDate ) ; if ( extensions ! = null ) { v . add ( extensions ) ; } addCRLEntry ( new DERSequence ( v ) ) ; } 
public void setExtensions ( X509Extensions extensions ) { this . extensions = extensions ; } 
public TBSCertList generateTBSCertList ( ) { if ( ( signature = = null ) | | ( issuer = = null ) | | ( thisUpdate = = null ) ) { throw new IllegalStateException ( " Not all mandatory fields set in V2 TBSCertList generator. " ) ; } ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( signature ) ; v . add ( issuer ) ; v . add ( thisUpdate ) ; if ( nextUpdate ! = null ) { v . add ( nextUpdate ) ; } Add CRLEntries if they exist if (crlentries != null) { ASN1EncodableVector certs = new ASN1EncodableVector(); Enumeration it = crlentries.elements(); while(it.hasMoreElements()) { certs.add((ASN1Sequence)it.nextElement()); } v.add(new DERSequence(certs)); } if (extensions != null) { v.add(new DERTaggedObject(0, extensions)); } return new TBSCertList(new DERSequence(v)); } 
public void setIssuerUniqueID ( DERBitString uniqueID ) { this . issuerUniqueID = uniqueID ; } 
public void setSubjectUniqueID ( DERBitString uniqueID ) { this . subjectUniqueID = uniqueID ; } 
public void setExtensions ( X509Extensions extensions ) { this . extensions = extensions ; if ( extensions ! = null ) { 
public TBSCertificateStructure generateTBSCertificate ( ) { if ( ( serialNumber = = null ) | | ( signature = = null ) | | ( issuer = = null ) | | ( startDate = = null ) | | ( endDate = = null ) | | ( subject = = null & & ! altNamePresentAndCritical ) | | ( subjectPublicKeyInfo = = null ) ) { throw new IllegalStateException ( " not all mandatory fields set in V3 TBScertificate generator " ) ; } ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( version ) ; v . add ( serialNumber ) ; v . add ( signature ) ; v . add ( issuer ) ; before and after dates ASN1EncodableVector validity = new ASN1EncodableVector(); validity.add(startDate); validity.add(endDate); v.add(new DERSequence(validity)); if (subject != null) { v.add(subject); } else { v.add(new DERSequence()); } v.add(subjectPublicKeyInfo); if (issuerUniqueID != null) { v.add(new DERTaggedObject(false, 1, issuerUniqueID)); } if (subjectUniqueID != null) { v.add(new DERTaggedObject(false, 2, subjectUniqueID)); } if (extensions != null) { v.add(new DERTaggedObject(3, extensions)); } return new TBSCertificateStructure(new DERSequence(v)); } 
public static X509CertificateStructure getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static X509CertificateStructure getInstance ( Object obj ) { if ( obj instanceof X509CertificateStructure ) { return ( X509CertificateStructure ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new X509CertificateStructure ( ( ASN1Sequence ) obj ) ; } if ( obj ! = null ) { throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } throw new IllegalArgumentException ( " null object in factory " ) ; } 
public DERObject getConvertedValue ( DERObjectIdentifier oid , String value ) { if ( value . length ( ) ! = 0 & & value . charAt ( 0 ) = = '#' ) { try { return convertHexEncoded ( value , 1 ) ; } catch ( IOException e ) { throw new RuntimeException ( " can't recode value for oid " + oid . getId ( ) ) ; } } else { if ( value . length ( ) ! = 0 & & value . charAt ( 0 ) = = '\\' ) { value = value . substring ( 1 ) ; } if ( oid . equals ( X509Name . EmailAddress ) | | oid . equals ( X509Name . DC ) ) { return new DERIA5String ( value ) ; } else if ( oid . equals ( X509Name . DATE_OF_BIRTH ) ) accept time string as well as # (for compatibility) { return new DERGeneralizedTime(value); } else if (oid.equals(X509Name.C) || oid.equals(X509Name.SN) || oid.equals(X509Name.DN_QUALIFIER) || oid.equals(X509Name.TELEPHONE_NUMBER)) { return new DERPrintableString(value); } } return new DERUTF8String(value); } 
public boolean isCritical ( ) { return critical ; } 
public int hashCode ( ) { if ( this . isCritical ( ) ) { return this . getValue ( ) . hashCode ( ) ; } return ~ this . getValue ( ) . hashCode ( ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof X509Extension ) ) { return false ; } X509Extension other = ( X509Extension ) o ; return other . getValue ( ) . equals ( this . getValue ( ) ) & & ( other . isCritical ( ) = = this . isCritical ( ) ) ; 
public static ASN1Object convertValueToObject ( X509Extension ext ) throws IllegalArgumentException { try { 
public static X509Extensions getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static X509Extensions getInstance ( Object obj ) { if ( obj = = null | | obj instanceof X509Extensions ) { return ( X509Extensions ) obj ; } if ( obj instanceof ASN1Sequence ) { return new X509Extensions ( ( ASN1Sequence ) obj ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( " illegal object in getInstance: " + obj . getClass ( ) . getName ( ) ) ; } 
public Enumeration oids ( ) { return ordering . elements ( ) ; } 
public X509Extension getExtension ( DERObjectIdentifier oid ) { return ( X509Extension ) extensions . get ( oid ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; Enumeration e = ordering . elements ( ) ; while ( e . hasMoreElements ( ) ) { DERObjectIdentifier oid = ( DERObjectIdentifier ) e . nextElement ( ) ; X509Extension ext = ( X509Extension ) extensions . get ( oid ) ; ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( oid ) ; if ( ext . isCritical ( ) ) { v . add ( new DERBoolean ( true ) ) ; } v . add ( ext . getValue ( ) ) ; vec . add ( new DERSequence ( v ) ) ; } return new DERSequence ( vec ) ; } 
public boolean equivalent ( X509Extensions other ) { if ( extensions . size ( ) ! = other . extensions . size ( ) ) { return false ; } Enumeration e1 = extensions . keys ( ) ; while ( e1 . hasMoreElements ( ) ) { Object key = e1 . nextElement ( ) ; if ( ! extensions . get ( key ) . equals ( other . extensions . get ( key ) ) ) { return false ; } } return true ; } 
public void reset ( ) { extensions = new Hashtable ( ) ; extOrdering = new Vector ( ) ; } 
public void addExtension ( DERObjectIdentifier oid , boolean critical , DEREncodable value ) { try { 
public void addExtension ( DERObjectIdentifier oid , boolean critical , byte [ ] value ) { if ( extensions . containsKey ( oid ) ) { throw new IllegalArgumentException ( " extension " + oid + " already added " ) ; } extOrdering . addElement ( oid ) ; extensions . put ( oid , new X509Extension ( critical , new DEROctetString ( value ) ) ) ; } 
public boolean isEmpty ( ) { return extOrdering . isEmpty ( ) ; } 
public X509Extensions generate ( ) { return new X509Extensions ( extOrdering , extensions ) ; } 
public static X509Name getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; } 
public static X509Name getInstance ( Object obj ) { if ( obj = = null | | obj instanceof X509Name ) { return ( X509Name ) obj ; } else if ( obj instanceof ASN1Sequence ) { return new X509Name ( ( ASN1Sequence ) obj ) ; } throw new IllegalArgumentException ( " unknown object in factory: " + obj . getClass ( ) . getName ( ) ) ; } 
private DERObjectIdentifier decodeOID ( String name , Hashtable lookUp ) { if ( Strings . toUpperCase ( name ) . startsWith ( " OID. " ) ) { return new DERObjectIdentifier ( name . substring ( 4 ) ) ; } else if ( name . charAt ( 0 ) > = '0' & & name . charAt ( 0 ) < = '9' ) { return new DERObjectIdentifier ( name ) ; } DERObjectIdentifier oid = ( DERObjectIdentifier ) lookUp . get ( Strings . toLowerCase ( name ) ) ; if ( oid = = null ) { throw new IllegalArgumentException ( " Unknown object id - " + name + " - passed to distinguished name " ) ; } return oid ; } 
public Vector getValues ( DERObjectIdentifier oid ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i ! = values . size ( ) ; i + + ) { if ( ordering . elementAt ( i ) . equals ( oid ) ) { String val = ( String ) values . elementAt ( i ) ; if ( val . length ( ) > 2 & & val . charAt ( 0 ) = = '\\' & & val . charAt ( 1 ) = = '#' ) { v . addElement ( val . substring ( 1 ) ) ; } else { v . addElement ( val ) ; } } } return v ; } 
public DERObject toASN1Object ( ) { if ( seq = = null ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; ASN1EncodableVector sVec = new ASN1EncodableVector ( ) ; DERObjectIdentifier lstOid = null ; for ( int i = 0 ; i ! = ordering . size ( ) ; i + + ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; DERObjectIdentifier oid = ( DERObjectIdentifier ) ordering . elementAt ( i ) ; v . add ( oid ) ; String str = ( String ) values . elementAt ( i ) ; v . add ( converter . getConvertedValue ( oid , str ) ) ; if ( lstOid = = null | | ( ( Boolean ) this . added . elementAt ( i ) ) . booleanValue ( ) ) { sVec . add ( new DERSequence ( v ) ) ; } else { vec . add ( new DERSet ( sVec ) ) ; sVec = new ASN1EncodableVector ( ) ; sVec . add ( new DERSequence ( v ) ) ; } lstOid = oid ; } vec . add ( new DERSet ( sVec ) ) ; seq = new DERSequence ( vec ) ; } return seq ; } 
public int hashCode ( ) { if ( isHashCodeCalculated ) { return hashCodeValue ; } isHashCodeCalculated = true ; this needs to be order independent, like equals for (int i = 0; i != ordering.size(); i += 1) { String value = (String)values.elementAt(i); value = canonicalize(value); value = stripInternalSpaces(value); hashCodeValue ^= value.hashCode(); } return hashCodeValue; } 
private boolean equivalentStrings ( String s1 , String s2 ) { String value = canonicalize ( s1 ) ; String oValue = canonicalize ( s2 ) ; if ( ! value . equals ( oValue ) ) { value = stripInternalSpaces ( value ) ; oValue = stripInternalSpaces ( oValue ) ; if ( ! value . equals ( oValue ) ) { return false ; } } return true ; } 
private String canonicalize ( String s ) { String value = Strings . toLowerCase ( s . trim ( ) ) ; if ( value . length ( ) > 0 & & value . charAt ( 0 ) = = '#' ) { DERObject obj = decodeObject ( value ) ; if ( obj instanceof DERString ) { value = Strings . toLowerCase ( ( ( DERString ) obj ) . getString ( ) . trim ( ) ) ; } } return value ; } 
private ASN1Object decodeObject ( String oValue ) { try { 
private String stripInternalSpaces ( String str ) { StringBuffer res = new StringBuffer ( ) ; if ( str . length ( ) ! = 0 ) { char c1 = str . charAt ( 0 ) ; res . append ( c1 ) ; for ( int k = 1 ; k < str . length ( ) ; k + + ) { char c2 = str . charAt ( k ) ; if ( ! ( c1 = = ' ' & & c2 = = ' ' ) ) { res . append ( c2 ) ; } c1 = c2 ; } } return res . toString ( ) ; } 
private void appendValue ( StringBuffer buf , Hashtable oidSymbols , DERObjectIdentifier oid , String value ) { String sym = ( String ) oidSymbols . get ( oid ) ; if ( sym ! = null ) { buf . append ( sym ) ; } else { buf . append ( oid . getId ( ) ) ; } buf . append ( '=' ) ; int index = buf . length ( ) ; buf . append ( value ) ; int end = buf . length ( ) ; if ( value . length ( ) > = 2 & & value . charAt ( 0 ) = = '\\' & & value . charAt ( 1 ) = = '#' ) { index + = 2 ; } while ( index ! = end ) { 
public String toString ( boolean reverse , Hashtable oidSymbols ) { StringBuffer buf = new StringBuffer ( ) ; Vector components = new Vector ( ) ; boolean first = true ; StringBuffer ava = null ; for ( int i = 0 ; i < ordering . size ( ) ; i + + ) { if ( ( ( Boolean ) added . elementAt ( i ) ) . booleanValue ( ) ) { ava . append ( '+' ) ; appendValue ( ava , oidSymbols , ( DERObjectIdentifier ) ordering . elementAt ( i ) , ( String ) values . elementAt ( i ) ) ; } else { ava = new StringBuffer ( ) ; appendValue ( ava , oidSymbols , ( DERObjectIdentifier ) ordering . elementAt ( i ) , ( String ) values . elementAt ( i ) ) ; components . addElement ( ava ) ; } } if ( reverse ) { for ( int i = components . size ( ) - 1 ; i > = 0 ; i - - ) { if ( first ) { first = false ; } else { buf . append ( ',' ) ; } buf . append ( components . elementAt ( i ) . toString ( ) ) ; } } else { for ( int i = 0 ; i < components . size ( ) ; i + + ) { if ( first ) { first = false ; } else { buf . append ( ',' ) ; } buf . append ( components . elementAt ( i ) . toString ( ) ) ; } } return buf . toString ( ) ; } 
private String bytesToString ( byte [ ] data ) { char [ ] cs = new char [ data . length ] ; for ( int i = 0 ; i ! = cs . length ; i + + ) { cs [ i ] = ( char ) ( data [ i ] & 0xff ) ; } return new String ( cs ) ; } 
public String toString ( ) { return toString ( DefaultReverse , DefaultSymbols ) ; } 
protected DERObject convertHexEncoded ( String str , int off ) throws IOException { str = Strings . toLowerCase ( str ) ; byte [ ] data = new byte [ ( str . length ( ) - off ) / 2 ] ; for ( int index = 0 ; index ! = data . length ; index + + ) { char left = str . charAt ( ( index * 2 ) + off ) ; char right = str . charAt ( ( index * 2 ) + off + 1 ) ; if ( left < 'a' ) { data [ index ] = ( byte ) ( ( left - '0' ) < < 4 ) ; } else { data [ index ] = ( byte ) ( ( left - 'a' + 10 ) < < 4 ) ; } if ( right < 'a' ) { data [ index ] | = ( byte ) ( right - '0' ) ; } else { data [ index ] | = ( byte ) ( right - 'a' + 10 ) ; } } ASN1InputStream aIn = new ASN1InputStream ( data ) ; return aIn . readObject ( ) ; } 
protected boolean canBePrintable ( String str ) { return DERPrintableString . isPrintableString ( str ) ; } 
public abstract DERObject getConvertedValue ( DERObjectIdentifier oid , String value ) ; } 
public boolean hasMoreTokens ( ) { return ( index ! = value . length ( ) ) ; } 
public String nextToken ( ) { if ( index = = value . length ( ) ) { return null ; } int end = index + 1 ; boolean quoted = false ; boolean escaped = false ; buf . setLength ( 0 ) ; while ( end ! = value . length ( ) ) { char c = value . charAt ( end ) ; if ( c = = '"' ) { if ( ! escaped ) { quoted = ! quoted ; } else { buf . append ( c ) ; } escaped = false ; } else { if ( escaped | | quoted ) { if ( c = = '#' & & buf . charAt ( buf . length ( ) - 1 ) = = '=' ) { buf . append ( '\\' ) ; } else if ( c = = '+' & & seperator ! = '+' ) { buf . append ( '\\' ) ; } buf . append ( c ) ; escaped = false ; } else if ( c = = '\\' ) { escaped = true ; } else if ( c = = seperator ) { break ; } else { buf . append ( c ) ; } } end + + ; } index = end ; return buf . toString ( ) . trim ( ) ; } 
public static BiometricData getInstance ( Object obj ) { if ( obj = = null | | obj instanceof BiometricData ) { return ( BiometricData ) obj ; } if ( obj instanceof ASN1Sequence ) { 
public DERObject toASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( typeOfBiometricData ) ; seq . add ( hashAlgorithm ) ; seq . add ( biometricDataHash ) ; if ( sourceDataUri ! = null ) { seq . add ( sourceDataUri ) ; } return new DERSequence ( seq ) ; } 
public static Iso4217CurrencyCode getInstance ( Object obj ) { if ( obj = = null | | obj instanceof Iso4217CurrencyCode ) { return ( Iso4217CurrencyCode ) obj ; } if ( obj instanceof DERInteger ) { DERInteger numericobj = DERInteger . getInstance ( obj ) ; int numeric = numericobj . getValue ( ) . intValue ( ) ; return new Iso4217CurrencyCode ( numeric ) ; } else if ( obj instanceof DERPrintableString ) { DERPrintableString alphabetic = DERPrintableString . getInstance ( obj ) ; return new Iso4217CurrencyCode ( alphabetic . getString ( ) ) ; } throw new IllegalArgumentException ( " unknown object in getInstance " ) ; } 
public boolean isAlphabetic ( ) { return obj instanceof DERPrintableString ; } 
public DERObject toASN1Object ( ) { return obj . getDERObject ( ) ; } 
public static MonetaryValue getInstance ( Object obj ) { if ( obj = = null | | obj instanceof MonetaryValue ) { return ( MonetaryValue ) obj ; } if ( obj instanceof ASN1Sequence ) { return new MonetaryValue ( ASN1Sequence . getInstance ( obj ) ) ; } throw new IllegalArgumentException ( " unknown object in getInstance " ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( currency ) ; seq . add ( amount ) ; seq . add ( exponent ) ; return new DERSequence ( seq ) ; } 
public static QCStatement getInstance ( Object obj ) { if ( obj = = null | | obj instanceof QCStatement ) { return ( QCStatement ) obj ; } if ( obj instanceof ASN1Sequence ) { return new QCStatement ( ASN1Sequence . getInstance ( obj ) ) ; } throw new IllegalArgumentException ( " unknown object in getInstance " ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector seq = new ASN1EncodableVector ( ) ; seq . add ( qcStatementId ) ; if ( qcStatementInfo ! = null ) { seq . add ( qcStatementInfo ) ; } return new DERSequence ( seq ) ; } 
public boolean isPredefined ( ) { return obj instanceof DERInteger ; } 
public DERObject toASN1Object ( ) { return obj . getDERObject ( ) ; } 
public DERObject toASN1Object ( ) { if ( pseudonym ! = null ) { 
public DERObject toASN1Object ( ) { ASN1EncodableVector vec = new ASN1EncodableVector ( ) ; vec . add ( nameOrPseudonym ) ; if ( nameDistinguisher ! = null ) { vec . add ( new DERTaggedObject ( false , 0 , new DERInteger ( nameDistinguisher ) ) ) ; } if ( dateOfBirth ! = null ) { vec . add ( new DERTaggedObject ( false , 1 , dateOfBirth ) ) ; } if ( placeOfBirth ! = null ) { vec . add ( new DERTaggedObject ( true , 2 , placeOfBirth ) ) ; } if ( gender ! = null ) { vec . add ( new DERTaggedObject ( false , 3 , new DERPrintableString ( gender , true ) ) ) ; } if ( postalAddress ! = null ) { vec . add ( new DERTaggedObject ( true , 4 , postalAddress ) ) ; } return new DERSequence ( vec ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( algorithm ) ; v . add ( counter ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( keyInfo ) ; if ( partyAInfo ! = null ) { v . add ( new DERTaggedObject ( 0 , partyAInfo ) ) ; } v . add ( new DERTaggedObject ( 2 , suppPubInfo ) ) ; return new DERSequence ( v ) ; } 
public DERObject toASN1Object ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( this . id ) ; v . add ( this . parameters ) ; return new DERSequence ( v ) ; } 
public void init ( CipherParameters params ) throws IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public int getMacSize ( ) ; public void reset ( ) ; } 
public void update ( byte in ) throws IllegalStateException ; public void reset ( ) ; } 
public void update ( byte [ ] in , int inOff , int len ) throws DataLengthException , IllegalStateException ; public void reset ( ) ; } 
public void init ( boolean forEncryption , CipherParameters params ) { cipher . init ( forEncryption , params ) ; } 
public byte returnByte ( byte in ) { oneByte [ 0 ] = in ; cipher . processBlock ( oneByte , 0 , oneByte , 0 ) ; return oneByte [ 0 ] ; } 
public void processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) throws DataLengthException { if ( outOff + len > out . length ) { throw new DataLengthException ( " output buffer too small in processBytes() " ) ; } for ( int i = 0 ; i ! = len ; i + + ) { 
public void init ( boolean forWrapping , CipherParameters param ) ; public String getAlgorithmName ( ) ; public byte [ ] wrap ( byte [ ] in , int inOff , int inLen ) ; public byte [ ] unwrap ( byte [ ] in , int inOff , int inLen ) throws InvalidCipherTextException ; } 
public String getAlgorithmName ( ) ; public byte [ ] wrap ( byte [ ] in , int inOff , int inLen ) ; public byte [ ] unwrap ( byte [ ] in , int inOff , int inLen ) throws InvalidCipherTextException ; } 
public byte [ ] wrap ( byte [ ] in , int inOff , int inLen ) ; public byte [ ] unwrap ( byte [ ] in , int inOff , int inLen ) throws InvalidCipherTextException ; } 
public byte [ ] unwrap ( byte [ ] in , int inOff , int inLen ) throws InvalidCipherTextException ; } 
public int doFinal ( byte [ ] out , int outOff ) { add padding byte paddingByte = (byte)(M.length-mOff); for (int i=mOff;i<M.length;i++) { M[i] = paddingByte; } do final check sum processCheckSum(M); do final block process processBlock(M); processBlock(C); System.arraycopy(X,xOff,out,outOff,16); reset(); return DIGEST_LENGTH; } 
public void reset ( ) { xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { X [ i ] = 0 ; } mOff = 0 ; for ( int i = 0 ; i ! = M . length ; i + + ) { M [ i ] = 0 ; } COff = 0 ; for ( int i = 0 ; i ! = C . length ; i + + ) { 
public void update ( byte in ) { M [ mOff + + ] = in ; if ( mOff = = 16 ) { 
public void update ( byte [ ] in , int inOff , int len ) { fill the current word while ((mOff != 0) && (len > 0)) { update(in[inOff]); inOff++; len--; } process whole words. while (len > 16) { System.arraycopy(in,inOff,M,0,16); processCheckSum(M); processBlock(M); len -= 16; inOff += 16; } load in the remainder. while (len > 0) { 
protected void processCheckSum ( byte [ ] m ) { int L = C [ 15 ] ; for ( int i = 0 ; i < 16 ; i + + ) { 
protected void processBlock ( byte [ ] m ) { for ( int i = 0 ; i < 16 ; i + + ) { X [ i + 16 ] = m [ i ] ; X [ i + 32 ] = ( byte ) ( m [ i ] ^ X [ i ] ) ; } encrypt block int t = 0; for (int j=0;j<18;j++) { 
protected void processWord ( byte [ ] in , int inOff ) { X [ xOff + + ] = ( in [ inOff ] & 0xff ) | ( ( in [ inOff + 1 ] & 0xff ) < < 8 ) | ( ( in [ inOff + 2 ] & 0xff ) < < 16 ) | ( ( in [ inOff + 3 ] & 0xff ) < < 24 ) ; if ( xOff = = 16 ) { 
protected void processLength ( long bitLength ) { if ( xOff > 14 ) { processBlock ( ) ; } X [ 14 ] = ( int ) ( bitLength & 0xffffffff ) ; X [ 15 ] = ( int ) ( bitLength > > > 32 ) ; } 
private void unpackWord ( int word , byte [ ] out , int outOff ) { out [ outOff ] = ( byte ) word ; out [ outOff + 1 ] = ( byte ) ( word > > > 8 ) ; out [ outOff + 2 ] = ( byte ) ( word > > > 16 ) ; out [ outOff + 3 ] = ( byte ) ( word > > > 24 ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H1 , out , outOff ) ; unpackWord ( H2 , out , outOff + 4 ) ; unpackWord ( H3 , out , outOff + 8 ) ; unpackWord ( H4 , out , outOff + 12 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H1 = 0x67452301 ; H2 = 0xefcdab89 ; H3 = 0x98badcfe ; H4 = 0x10325476 ; xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { 
private int rotateLeft ( int x , int ) { return ( x < < ) | ( x > > > ( 32 - ) ) ; } 
private int F ( int u , int v , int w ) { return ( u & v ) | ( ~ u & w ) ; } 
private int G ( int u , int v , int w ) { return ( u & w ) | ( v & ~ w ) ; } 
private int H ( int u , int v , int w ) { return u ^ v ^ w ; } 
private int K ( int u , int v , int w ) { return v ^ ( u | ~ w ) ; } 
protected void processWord ( byte [ ] in , int inOff ) { X [ xOff + + ] = ( in [ inOff ] & 0xff ) | ( ( in [ inOff + 1 ] & 0xff ) < < 8 ) | ( ( in [ inOff + 2 ] & 0xff ) < < 16 ) | ( ( in [ inOff + 3 ] & 0xff ) < < 24 ) ; if ( xOff = = 16 ) { 
protected void processLength ( long bitLength ) { if ( xOff > 14 ) { processBlock ( ) ; } X [ 14 ] = ( int ) ( bitLength & 0xffffffff ) ; X [ 15 ] = ( int ) ( bitLength > > > 32 ) ; } 
private void unpackWord ( int word , byte [ ] out , int outOff ) { out [ outOff ] = ( byte ) word ; out [ outOff + 1 ] = ( byte ) ( word > > > 8 ) ; out [ outOff + 2 ] = ( byte ) ( word > > > 16 ) ; out [ outOff + 3 ] = ( byte ) ( word > > > 24 ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( H0 , out , outOff ) ; unpackWord ( H1 , out , outOff + 4 ) ; unpackWord ( H2 , out , outOff + 8 ) ; unpackWord ( H3 , out , outOff + 12 ) ; unpackWord ( H4 , out , outOff + 16 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { super . reset ( ) ; H0 = 0x67452301 ; H1 = 0xefcdab89 ; H2 = 0x98badcfe ; H3 = 0x10325476 ; H4 = 0xc3d2e1f0 ; xOff = 0 ; for ( int i = 0 ; i ! = X . length ; i + + ) { 
private int RL ( int x , int ) { return ( x < < ) | ( x > > > ( 32 - ) ) ; } 
private int f1 ( int x , int y , int z ) { return x ^ y ^ z ; } 
private int f2 ( int x , int y , int z ) { return ( x & y ) | ( ~ x & z ) ; } 
private int f3 ( int x , int y , int z ) { return ( x | ~ y ) ^ z ; } 
private int f4 ( int x , int y , int z ) { return ( x & z ) | ( y & ~ z ) ; } 
private int f5 ( int x , int y , int z ) { return x ^ ( y | ~ z ) ; } 
protected void processWord ( byte [ ] in , int inOff ) { Note: Inlined for performance X[xOff] = Pack.bigEndianToInt(in, inOff); int n = in[ inOff] << 24; n |= (in[++inOff] & 0xff) << 16; n |= (in[++inOff] & 0xff) << 8; n |= (in[++inOff] & 0xff); X[xOff] = n; if (++xOff == 16) { 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; Pack . intToBigEndian ( H1 , out , outOff ) ; Pack . intToBigEndian ( H2 , out , outOff + 4 ) ; Pack . intToBigEndian ( H3 , out , outOff + 8 ) ; Pack . intToBigEndian ( H4 , out , outOff + 12 ) ; Pack . intToBigEndian ( H5 , out , outOff + 16 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
protected void processWord ( byte [ ] in , int inOff ) { Note: Inlined for performance X[xOff] = Pack.bigEndianToInt(in, inOff); int n = in[inOff] << 24; n |= (in[++inOff] & 0xff) << 16; n |= (in[++inOff] & 0xff) << 8; n |= (in[++inOff] & 0xff); X[xOff] = n; if (++xOff == 16) { 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; Pack . intToBigEndian ( H1 , out , outOff ) ; Pack . intToBigEndian ( H2 , out , outOff + 4 ) ; Pack . intToBigEndian ( H3 , out , outOff + 8 ) ; Pack . intToBigEndian ( H4 , out , outOff + 12 ) ; Pack . intToBigEndian ( H5 , out , outOff + 16 ) ; Pack . intToBigEndian ( H6 , out , outOff + 20 ) ; Pack . intToBigEndian ( H7 , out , outOff + 24 ) ; Pack . intToBigEndian ( H8 , out , outOff + 28 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
protected void processBlock ( ) { expand 16 word block into 64 word blocks. for (int t = 16; t <= 63; t++) { X[t] = Theta1(X[t - 2]) + X[t - 7] + Theta0(X[t - 15]) + X[t - 16]; } set up working variables. int a = H1; int b = H2; int c = H3; int d = H4; int e = H5; int f = H6; int g = H7; int h = H8; int t = 0; for(int i = 0; i < 8; i ++) { t = 8 * i h += Sum1(e) + Ch(e, f, g) + K[t] + X[t]; d += h; h += Sum0(a) + Maj(a, b, c); ++t; t = 8 * i + 1 g += Sum1(d) + Ch(d, e, f) + K[t] + X[t]; c += g; g += Sum0(h) + Maj(h, a, b); ++t; t = 8 * i + 2 f += Sum1(c) + Ch(c, d, e) + K[t] + X[t]; b += f; f += Sum0(g) + Maj(g, h, a); ++t; t = 8 * i + 3 e += Sum1(b) + Ch(b, c, d) + K[t] + X[t]; a += e; e += Sum0(f) + Maj(f, g, h); ++t; t = 8 * i + 4 d += Sum1(a) + Ch(a, b, c) + K[t] + X[t]; h += d; d += Sum0(e) + Maj(e, f, g); ++t; t = 8 * i + 5 c += Sum1(h) + Ch(h, a, b) + K[t] + X[t]; g += c; c += Sum0(d) + Maj(d, e, f); ++t; t = 8 * i + 6 b += Sum1(g) + Ch(g, h, a) + K[t] + X[t]; f += b; b += Sum0(c) + Maj(c, d, e); ++t; t = 8 * i + 7 a += Sum1(f) + Ch(f, g, h) + K[t] + X[t]; e += a; a += Sum0(b) + Maj(b, c, d); ++t; } H1 += a; H2 += b; H3 += c; H4 += d; H5 += e; H6 += f; H7 += g; H8 += h; reset the offset and clean out the word buffer. xOff = 0; for (int i = 0; i < 16; i++) { 
private void processWord ( byte [ ] b , int off ) { x [ xOff + + ] = ( ( long ) ( b [ off + 7 ] & 0xff ) < < 56 ) | ( ( long ) ( b [ off + 6 ] & 0xff ) < < 48 ) | ( ( long ) ( b [ off + 5 ] & 0xff ) < < 40 ) | ( ( long ) ( b [ off + 4 ] & 0xff ) < < 32 ) | ( ( long ) ( b [ off + 3 ] & 0xff ) < < 24 ) | ( ( long ) ( b [ off + 2 ] & 0xff ) < < 16 ) | ( ( long ) ( b [ off + 1 ] & 0xff ) < < 8 ) | ( ( b [ off + 0 ] & 0xff ) ) ; if ( xOff = = x . length ) { processBlock ( ) ; } bOff = 0 ; } 
public void update ( byte in ) { buf [ bOff + + ] = in ; if ( bOff = = buf . length ) { processWord ( buf , 0 ) ; } byteCount + + ; } 
public void update ( byte [ ] in , int inOff , int len ) { fill the current word while ((bOff != 0) && (len > 0)) { update(in[inOff]); inOff++; len--; } process whole words. while (len > 8) { processWord(in, inOff); inOff += 8; len -= 8; byteCount += 8; } load in the remainder. while (len > 0) { 
private void roundABC ( long x , long mul ) { c ^ = x ; a - = t1 [ ( int ) c & 0xff ] ^ t2 [ ( int ) ( c > > 16 ) & 0xff ] ^ t3 [ ( int ) ( c > > 32 ) & 0xff ] ^ t4 [ ( int ) ( c > > 48 ) & 0xff ] ; b + = t4 [ ( int ) ( c > > 8 ) & 0xff ] ^ t3 [ ( int ) ( c > > 24 ) & 0xff ] ^ t2 [ ( int ) ( c > > 40 ) & 0xff ] ^ t1 [ ( int ) ( c > > 56 ) & 0xff ] ; b * = mul ; } 
private void roundBCA ( long x , long mul ) { a ^ = x ; b - = t1 [ ( int ) a & 0xff ] ^ t2 [ ( int ) ( a > > 16 ) & 0xff ] ^ t3 [ ( int ) ( a > > 32 ) & 0xff ] ^ t4 [ ( int ) ( a > > 48 ) & 0xff ] ; c + = t4 [ ( int ) ( a > > 8 ) & 0xff ] ^ t3 [ ( int ) ( a > > 24 ) & 0xff ] ^ t2 [ ( int ) ( a > > 40 ) & 0xff ] ^ t1 [ ( int ) ( a > > 56 ) & 0xff ] ; c * = mul ; } 
private void roundCAB ( long x , long mul ) { b ^ = x ; c - = t1 [ ( int ) b & 0xff ] ^ t2 [ ( int ) ( b > > 16 ) & 0xff ] ^ t3 [ ( int ) ( b > > 32 ) & 0xff ] ^ t4 [ ( int ) ( b > > 48 ) & 0xff ] ; a + = t4 [ ( int ) ( b > > 8 ) & 0xff ] ^ t3 [ ( int ) ( b > > 24 ) & 0xff ] ^ t2 [ ( int ) ( b > > 40 ) & 0xff ] ^ t1 [ ( int ) ( b > > 56 ) & 0xff ] ; a * = mul ; } 
private void keySchedule ( ) { x [ 0 ] - = x [ 7 ] ^ 0xA5A5A5A5A5A5A5A5L ; x [ 1 ] ^ = x [ 0 ] ; x [ 2 ] + = x [ 1 ] ; x [ 3 ] - = x [ 2 ] ^ ( ( ~ x [ 1 ] ) < < 19 ) ; x [ 4 ] ^ = x [ 3 ] ; x [ 5 ] + = x [ 4 ] ; x [ 6 ] - = x [ 5 ] ^ ( ( ~ x [ 4 ] ) > > > 23 ) ; x [ 7 ] ^ = x [ 6 ] ; x [ 0 ] + = x [ 7 ] ; x [ 1 ] - = x [ 0 ] ^ ( ( ~ x [ 7 ] ) < < 19 ) ; x [ 2 ] ^ = x [ 1 ] ; x [ 3 ] + = x [ 2 ] ; x [ 4 ] - = x [ 3 ] ^ ( ( ~ x [ 2 ] ) > > > 23 ) ; x [ 5 ] ^ = x [ 4 ] ; x [ 6 ] + = x [ 5 ] ; x [ 7 ] - = x [ 6 ] ^ 0x0123456789ABCDEFL ; } 
private void processBlock ( ) { save abc long aa = a; long bb = b; long cc = c; rounds and schedule roundABC(x[0], 5); roundBCA(x[1], 5); roundCAB(x[2], 5); roundABC(x[3], 5); roundBCA(x[4], 5); roundCAB(x[5], 5); roundABC(x[6], 5); roundBCA(x[7], 5); keySchedule(); roundCAB(x[0], 7); roundABC(x[1], 7); roundBCA(x[2], 7); roundCAB(x[3], 7); roundABC(x[4], 7); roundBCA(x[5], 7); roundCAB(x[6], 7); roundABC(x[7], 7); keySchedule(); roundBCA(x[0], 9); roundCAB(x[1], 9); roundABC(x[2], 9); roundBCA(x[3], 9); roundCAB(x[4], 9); roundABC(x[5], 9); roundBCA(x[6], 9); roundCAB(x[7], 9); feed forward a ^= aa; b -= bb; c += cc; clear the x buffer xOff = 0; for (int i = 0; i != x.length; i++) { 
public void unpackWord ( long r , byte [ ] out , int outOff ) { out [ outOff + 7 ] = ( byte ) ( r > > 56 ) ; out [ outOff + 6 ] = ( byte ) ( r > > 48 ) ; out [ outOff + 5 ] = ( byte ) ( r > > 40 ) ; out [ outOff + 4 ] = ( byte ) ( r > > 32 ) ; out [ outOff + 3 ] = ( byte ) ( r > > 24 ) ; out [ outOff + 2 ] = ( byte ) ( r > > 16 ) ; out [ outOff + 1 ] = ( byte ) ( r > > 8 ) ; out [ outOff ] = ( byte ) r ; } 
private void processLength ( long bitLength ) { x [ 7 ] = bitLength ; } 
private void finish ( ) { long bitLength = ( byteCount < < 3 ) ; update ( ( byte ) 0x01 ) ; while ( bOff ! = 0 ) { update ( ( byte ) 0 ) ; } processLength ( bitLength ) ; processBlock ( ) ; } 
public int doFinal ( byte [ ] out , int outOff ) { finish ( ) ; unpackWord ( a , out , outOff ) ; unpackWord ( b , out , outOff + 8 ) ; unpackWord ( c , out , outOff + 16 ) ; reset ( ) ; return DIGEST_LENGTH ; } 
public void reset ( ) { a = 0x0123456789ABCDEFL ; b = 0xFEDCBA9876543210L ; c = 0xF096A5B4C3B2E187L ; xOff = 0 ; for ( int i = 0 ; i ! = x . length ; i + + ) { x [ i ] = 0 ; } bOff = 0 ; for ( int i = 0 ; i ! = buf . length ; i + + ) { buf [ i ] = 0 ; } byteCount = 0 ; } 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) { if ( workingKey = = null ) { throw new IllegalStateException ( " Twofish not initialised " ) ; } if ( ( inOff + BLOCK_SIZE ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + BLOCK_SIZE ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } if ( encrypting ) { encryptBlock ( in , inOff , out , outOff ) ; } else { decryptBlock ( in , inOff , out , outOff ) ; } return BLOCK_SIZE ; } 
private int F32 ( int x , int [ ] k32 ) { int b0 = b0 ( x ) ; int b1 = b1 ( x ) ; int b2 = b2 ( x ) ; int b3 = b3 ( x ) ; int k0 = k32 [ 0 ] ; int k1 = k32 [ 1 ] ; int k2 = k32 [ 2 ] ; int k3 = k32 [ 3 ] ; int result = 0 ; switch ( k64Cnt & 3 ) { case 1 : result = gMDS0 [ ( P [ P_01 ] [ b0 ] & 0xff ) ^ b0 ( k0 ) ] ^ gMDS1 [ ( P [ P_11 ] [ b1 ] & 0xff ) ^ b1 ( k0 ) ] ^ gMDS2 [ ( P [ P_21 ] [ b2 ] & 0xff ) ^ b2 ( k0 ) ] ^ gMDS3 [ ( P [ P_31 ] [ b3 ] & 0xff ) ^ b3 ( k0 ) ] ; break ; case 0 : b0 = ( P [ P_04 ] [ b0 ] & 0xff ) ^ b0 ( k3 ) ; b1 = ( P [ P_14 ] [ b1 ] & 0xff ) ^ b1 ( k3 ) ; b2 = ( P [ P_24 ] [ b2 ] & 0xff ) ^ b2 ( k3 ) ; b3 = ( P [ P_34 ] [ b3 ] & 0xff ) ^ b3 ( k3 ) ; case 3 : b0 = ( P [ P_03 ] [ b0 ] & 0xff ) ^ b0 ( k2 ) ; b1 = ( P [ P_13 ] [ b1 ] & 0xff ) ^ b1 ( k2 ) ; b2 = ( P [ P_23 ] [ b2 ] & 0xff ) ^ b2 ( k2 ) ; b3 = ( P [ P_33 ] [ b3 ] & 0xff ) ^ b3 ( k2 ) ; case 2 : result = gMDS0 [ ( P [ P_01 ] [ ( P [ P_02 ] [ b0 ] & 0xff ) ^ b0 ( k1 ) ] & 0xff ) ^ b0 ( k0 ) ] ^ gMDS1 [ ( P [ P_11 ] [ ( P [ P_12 ] [ b1 ] & 0xff ) ^ b1 ( k1 ) ] & 0xff ) ^ b1 ( k0 ) ] ^ gMDS2 [ ( P [ P_21 ] [ ( P [ P_22 ] [ b2 ] & 0xff ) ^ b2 ( k1 ) ] & 0xff ) ^ b2 ( k0 ) ] ^ gMDS3 [ ( P [ P_31 ] [ ( P [ P_32 ] [ b3 ] & 0xff ) ^ b3 ( k1 ) ] & 0xff ) ^ b3 ( k0 ) ] ; break ; } return result ; } 
private int RS_MDS_Encode ( int k0 , int k1 ) { int r = k1 ; for ( int i = 0 ; i < 4 ; i + + ) shift 1 byte at a time { r = RS_rem(r); } r ^= k0; for (int i=0 ; i < 4 ; i++) { r = RS_rem(r); } return r; } 
private int RS_rem ( int x ) { int b = ( x > > > 24 ) & 0xff ; int g2 = ( ( b < < 1 ) ^ ( ( b & 0x80 ) ! = 0 ? RS_GF_FDBK : 0 ) ) & 0xff ; int g3 = ( ( b > > > 1 ) ^ ( ( b & 0x01 ) ! = 0 ? ( RS_GF_FDBK > > > 1 ) : 0 ) ) ^ g2 ; return ( ( x < < 8 ) ^ ( g3 < < 24 ) ^ ( g2 < < 16 ) ^ ( g3 < < 8 ) ^ b ) ; } 
private int LFSR1 ( int x ) { return ( x > > 1 ) ^ ( ( ( x & 0x01 ) ! = 0 ) ? GF256_FDBK_2 : 0 ) ; 
private int LFSR2 ( int x ) { return ( x > > 2 ) ^ ( ( ( x & 0x02 ) ! = 0 ) ? GF256_FDBK_2 : 0 ) ^ 
private int Mx_X ( int x ) { return x ^ LFSR2 ( x ) ; } 5B 
private int Mx_Y ( int x ) { return x ^ LFSR1 ( x ) ^ LFSR2 ( x ) ; } EF 
private int b1 ( int x ) { return ( x > > > 8 ) & 0xff ; } 
private int b2 ( int x ) { return ( x > > > 16 ) & 0xff ; } 
private int b3 ( int x ) { return ( x > > > 24 ) & 0xff ; } 
private int Fe32_0 ( int x ) { return gSBox [ 0x000 + 2 * ( x & 0xff ) ] ^ gSBox [ 0x001 + 2 * ( ( x > > > 8 ) & 0xff ) ] ^ 
private int Fe32_3 ( int x ) { return gSBox [ 0x000 + 2 * ( ( x > > > 24 ) & 0xff ) ] ^ gSBox [ 0x001 + 2 * ( x & 0xff ) ] ^ 
private int BytesTo32Bits ( byte [ ] b , int p ) { return ( ( b [ p ] & 0xff ) ) | ( ( b [ p + 1 ] & 0xff ) < < 8 ) | 
private void Bits32ToBytes ( int in , byte [ ] b , int offset ) { b [ offset ] = ( byte ) in ; b [ offset + 1 ] = ( byte ) ( in > > 8 ) ; b [ offset + 2 ] = ( byte ) ( in > > 16 ) ; b [ offset + 3 ] = ( byte ) ( in > > 24 ) ; } 
public void init ( byte [ ] password , byte [ ] salt ) { super . init ( password , salt , 1 ) ; } 
private byte [ ] generateDerivedKey ( int bytesNeeded ) { byte [ ] buf = new byte [ digest . getDigestSize ( ) ] ; byte [ ] key = new byte [ bytesNeeded ] ; int offset = 0 ; for ( ; ; ) { digest . update ( password , 0 , password . length ) ; digest . update ( salt , 0 , salt . length ) ; digest . doFinal ( buf , 0 ) ; int len = ( bytesNeeded > buf . length ) ? buf . length : bytesNeeded ; System . arraycopy ( buf , 0 , key , offset , len ) ; offset + = len ; check if we need any more bytesNeeded -= len; if (bytesNeeded == 0) { break; } do another round digest.reset(); digest.update(buf, 0, buf.length); } return key; } 
private void adjust ( byte [ ] a , int aOff , byte [ ] b ) { int x = ( b [ b . length - 1 ] & 0xff ) + ( a [ aOff + b . length - 1 ] & 0xff ) + 1 ; a [ aOff + b . length - 1 ] = ( byte ) x ; x > > > = 8 ; for ( int i = b . length - 2 ; i > = 0 ; i - - ) { 
private byte [ ] generateDerivedKey ( int idByte , int ) { byte [ ] D = new byte [ v ] ; byte [ ] dKey = new byte [ ] ; for ( int i = 0 ; i ! = D . length ; i + + ) { D [ i ] = ( byte ) idByte ; } byte [ ] S ; if ( ( salt ! = null ) & & ( salt . length ! = 0 ) ) { S = new byte [ v * ( ( salt . length + v - 1 ) / v ) ] ; for ( int i = 0 ; i ! = S . length ; i + + ) { S [ i ] = salt [ i % salt . length ] ; } } else { S = new byte [ 0 ] ; } byte [ ] P ; if ( ( password ! = null ) & & ( password . length ! = 0 ) ) { P = new byte [ v * ( ( password . length + v - 1 ) / v ) ] ; for ( int i = 0 ; i ! = P . length ; i + + ) { P [ i ] = password [ i % password . length ] ; } } else { P = new byte [ 0 ] ; } byte [ ] I = new byte [ S . length + P . length ] ; System . arraycopy ( S , 0 , I , 0 , S . length ) ; System . arraycopy ( P , 0 , I , S . length , P . length ) ; byte [ ] B = new byte [ v ] ; int c = ( + u - 1 ) / u ; for ( int i = 1 ; i < = c ; i + + ) { byte [ ] A = new byte [ u ] ; digest . update ( D , 0 , D . length ) ; digest . update ( I , 0 , I . length ) ; digest . doFinal ( A , 0 ) ; for ( int j = 1 ; j ! = iterationCount ; j + + ) { digest . update ( A , 0 , A . length ) ; digest . doFinal ( A , 0 ) ; } for ( int j = 0 ; j ! = B . length ; j + + ) { B [ j ] = A [ j % A . length ] ; } for ( int j = 0 ; j ! = I . length / v ; j + + ) { adjust ( I , j * v , B ) ; } if ( i = = c ) { System . arraycopy ( A , 0 , dKey , ( i - 1 ) * u , dKey . length - ( ( i - 1 ) * u ) ) ; } else { System . arraycopy ( A , 0 , dKey , ( i - 1 ) * u , A . length ) ; } } return dKey ; } 
public CipherParameters generateDerivedParameters ( int keySize ) { keySize = keySize / 8 ; byte [ ] dKey = generateDerivedKey ( KEY_MATERIAL , keySize ) ; return new KeyParameter ( dKey , 0 , keySize ) ; } 
public CipherParameters generateDerivedParameters ( int keySize , int ivSize ) { keySize = keySize / 8 ; ivSize = ivSize / 8 ; byte [ ] dKey = generateDerivedKey ( KEY_MATERIAL , keySize ) ; byte [ ] iv = generateDerivedKey ( IV_MATERIAL , ivSize ) ; return new ParametersWithIV ( new KeyParameter ( dKey , 0 , keySize ) , iv , 0 , ivSize ) ; } 
public CipherParameters generateDerivedMacParameters ( int keySize ) { keySize = keySize / 8 ; byte [ ] dKey = generateDerivedKey ( MAC_MATERIAL , keySize ) ; return new KeyParameter ( dKey , 0 , keySize ) ; } 
public int encryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } cipher . processBlock ( cfbV , 0 , cfbOutV , 0 ) ; XOR the cfbV with the plaintext producing the ciphertext for (int i = 0; i < blockSize; i++) { out[outOff + i] = (byte)(cfbOutV[i] ^ in[inOff + i]); } change over the input block. System.arraycopy(cfbV, blockSize, cfbV, 0, cfbV.length - blockSize); System.arraycopy(out, outOff, cfbV, cfbV.length - blockSize, blockSize); return blockSize; } 
public int decryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } cipher . processBlock ( cfbV , 0 , cfbOutV , 0 ) ; change over the input block. System.arraycopy(cfbV, blockSize, cfbV, 0, cfbV.length - blockSize); System.arraycopy(in, inOff, cfbV, cfbV.length - blockSize, blockSize); XOR the cfbV with the ciphertext producing the plaintext for (int i = 0; i < blockSize; i++) { out[outOff + i] = (byte)(cfbOutV[i] ^ in[inOff + i]); } return blockSize; } 
public void reset ( ) { System . arraycopy ( IV , 0 , cfbV , 0 , IV . length ) ; cipher . reset ( ) ; } 
public void init ( boolean encrypting , ignored by this OFB mode CipherParameters params) throws IllegalArgumentException { if (params instanceof ParametersWithIV) { 
public int processBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( " input buffer too short " ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } cipher . processBlock ( ofbV , 0 , ofbOutV , 0 ) ; XOR the ofbV with the plaintext producing the cipher text (and the next input block). for (int i = 0; i < blockSize; i++) { out[outOff + i] = (byte)(ofbOutV[i] ^ in[inOff + i]); } change over the input block. System.arraycopy(ofbV, blockSize, ofbV, 0, ofbV.length - blockSize); System.arraycopy(ofbOutV, 0, ofbV, ofbV.length - blockSize, blockSize); return blockSize; } 
public void reset ( ) { System . arraycopy ( IV , 0 , ofbV , 0 , IV . length ) ; cipher . reset ( ) ; } 
public boolean isPrivate ( ) { return privateKey ; } 
public static boolean isWeakKey ( byte [ ] key , int offset ) { if ( key . length - offset < DES_KEY_LENGTH ) { throw new IllegalArgumentException ( " key material too short. " ) ; } nextkey : for ( int i = 0 ; i < N_DES_WEAK_KEYS ; i + + ) { for ( int j = 0 ; j < DES_KEY_LENGTH ; j + + ) { if ( key [ j + offset ] ! = DES_weak_keys [ i * DES_KEY_LENGTH + j ] ) { continue nextkey ; } } return true ; } return false ; } 
public static void setOddParity ( byte [ ] bytes ) { for ( int i = 0 ; i < bytes . length ; i + + ) { 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof DHKeyParameters ) ) { return false ; } DHKeyParameters dhKey = ( DHKeyParameters ) obj ; if ( params = = null ) { 
public int hashCode ( ) { int code = isPrivate ( ) ? 0 : 1 ; if ( params ! = null ) { code ^ = params . hashCode ( ) ; } return code ; } 
private static int getDefaultMParam ( int lParam ) { if ( lParam = = 0 ) { return DEFAULT_MINIMUM_LENGTH ; } return lParam < DEFAULT_MINIMUM_LENGTH ? lParam : DEFAULT_MINIMUM_LENGTH ; } 
public int hashCode ( ) { return getP ( ) . hashCode ( ) ^ getG ( ) . hashCode ( ) ^ ( getQ ( ) ! = null ? getQ ( ) . hashCode ( ) : 0 ) ; } 
public int hashCode ( ) { return x . hashCode ( ) ^ super . hashCode ( ) ; } 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof DHPrivateKeyParameters ) ) { return false ; } DHPrivateKeyParameters other = ( DHPrivateKeyParameters ) obj ; return other . getX ( ) . equals ( this . x ) & & super . equals ( obj ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof DHValidationParameters ) ) { return false ; } DHValidationParameters other = ( DHValidationParameters ) o ; if ( other . counter ! = this . counter ) { return false ; } return Arrays . areEqual ( this . seed , other . seed ) ; } 
public int hashCode ( ) { return counter ^ Arrays . hashCode ( seed ) ; } 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof DSAParameters ) ) { return false ; } DSAParameters pm = ( DSAParameters ) obj ; return ( pm . getP ( ) . equals ( p ) & & pm . getQ ( ) . equals ( q ) & & pm . getG ( ) . equals ( g ) ) ; } 
public int hashCode ( ) { return getP ( ) . hashCode ( ) ^ getQ ( ) . hashCode ( ) ^ getG ( ) . hashCode ( ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof DSAValidationParameters ) ) { return false ; } DSAValidationParameters other = ( DSAValidationParameters ) o ; if ( other . counter ! = this . counter ) { return false ; } return Arrays . areEqual ( this . seed , other . seed ) ; } 
public static int bigEndianToInt ( byte [ ] bs , int off ) { int = bs [ off ] < < 24 ; | = ( bs [ + + off ] & 0xff ) < < 16 ; | = ( bs [ + + off ] & 0xff ) < < 8 ; | = ( bs [ + + off ] & 0xff ) ; return ; } 
public static void intToBigEndian ( int , byte [ ] bs , int off ) { bs [ off ] = ( byte ) ( > > > 24 ) ; bs [ + + off ] = ( byte ) ( > > > 16 ) ; bs [ + + off ] = ( byte ) ( > > > 8 ) ; bs [ + + off ] = ( byte ) ( ) ; } 
public static long bigEndianToLong ( byte [ ] bs , int off ) { int hi = bigEndianToInt ( bs , off ) ; int lo = bigEndianToInt ( bs , off + 4 ) ; return ( ( long ) ( hi & 0xffffffffL ) < < 32 ) | ( long ) ( lo & 0xffffffffL ) ; } 
public static void longToBigEndian ( long , byte [ ] bs , int off ) { intToBigEndian ( ( int ) ( > > > 32 ) , bs , off ) ; intToBigEndian ( ( int ) ( & 0xffffffffL ) , bs , off + 4 ) ; } 
void setBagAttribute ( DERObjectIdentifier oid , DEREncodable attribute ) ; DEREncodable getBagAttribute ( DERObjectIdentifier oid ) ; Enumeration getBagAttributeKeys ( ) ; } 
DEREncodable getBagAttribute ( DERObjectIdentifier oid ) ; Enumeration getBagAttributeKeys ( ) ; } 
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { x = ( BigInteger ) in . readObject ( ) ; this . dhSpec = new DHParameterSpec ( ( BigInteger ) in . readObject ( ) , ( BigInteger ) in . readObject ( ) , in . readInt ( ) ) ; } 
private void writeObject ( ObjectOutputStream out ) throws IOException { out . writeObject ( this . getX ( ) ) ; out . writeObject ( dhSpec . getP ( ) ) ; out . writeObject ( dhSpec . getG ( ) ) ; out . writeInt ( dhSpec . getL ( ) ) ; } 
public void setBagAttribute ( DERObjectIdentifier oid , DEREncodable attribute ) { attrCarrier . setBagAttribute ( oid , attribute ) ; } 
public DEREncodable getBagAttribute ( DERObjectIdentifier oid ) { return attrCarrier . getBagAttribute ( oid ) ; } 
boolean shouldTryWrongPKCS12 ( ) { return tryWrong ; } 
public int hashCode ( ) { return this . getModulus ( ) . hashCode ( ) ^ this . getPublicExponent ( ) . hashCode ( ) 
public boolean equals ( Object o ) { if ( o = = this ) { return true ; } if ( ! ( o instanceof RSAPrivateCrtKey ) ) { return false ; } RSAPrivateCrtKey key = ( RSAPrivateCrtKey ) o ; return this . getModulus ( ) . equals ( key . getModulus ( ) ) & & this . getPublicExponent ( ) . equals ( key . getPublicExponent ( ) ) 
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; String nl = System . getProperty ( " line.separator " ) ; buf . append ( " RSA Private CRT Key " ) . append ( nl ) ; buf . append ( " modulus: " ) . append ( this . getModulus ( ) . toString ( 16 ) ) . append ( nl ) ; buf . append ( " public exponent: " ) . append ( this . getPublicExponent ( ) . toString ( 16 ) ) . append ( nl ) ; buf . append ( " private exponent: " ) . append ( this . getPrivateExponent ( ) . toString ( 16 ) ) . append ( nl ) ; buf . append ( " primeP: " ) . append ( this . getPrimeP ( ) . toString ( 16 ) ) . append ( nl ) ; buf . append ( " primeQ: " ) . append ( this . getPrimeQ ( ) . toString ( 16 ) ) . append ( nl ) ; buf . append ( " primeExponentP: " ) . append ( this . getPrimeExponentP ( ) . toString ( 16 ) ) . append ( nl ) ; buf . append ( " primeExponentQ: " ) . append ( this . getPrimeExponentQ ( ) . toString ( 16 ) ) . append ( nl ) ; buf . append ( " crtCoefficient: " ) . append ( this . getCrtCoefficient ( ) . toString ( 16 ) ) . append ( nl ) ; return buf . toString ( ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof RSAPrivateKey ) ) { return false ; } if ( o = = this ) { return true ; } RSAPrivateKey key = ( RSAPrivateKey ) o ; return getModulus ( ) . equals ( key . getModulus ( ) ) & & getPrivateExponent ( ) . equals ( key . getPrivateExponent ( ) ) ; 
public int hashCode ( ) { return getModulus ( ) . hashCode ( ) ^ getPrivateExponent ( ) . hashCode ( ) ; } 
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { this . modulus = ( BigInteger ) in . readObject ( ) ; this . attrCarrier = new PKCS12BagAttributeCarrierImpl ( ) ; attrCarrier . readObject ( in ) ; this . privateExponent = ( BigInteger ) in . readObject ( ) ; } 
private void writeObject ( ObjectOutputStream out ) throws IOException { out . writeObject ( modulus ) ; attrCarrier . writeObject ( out ) ; out . writeObject ( privateExponent ) ; } 
protected int engineGetBlockSize ( ) { return 0 ; } 
protected byte [ ] engineGetIV ( ) { return ( ivParam ! = null ) ? ivParam . getIV ( ) : null ; } 
protected int engineGetKeySize ( Key key ) { return key . getEncoded ( ) . length * 8 ; } 
protected int engineGetOutputSize ( int inputLen ) { return inputLen ; } 
protected AlgorithmParameters engineGetParameters ( ) { if ( engineParams = = null ) { if ( pbeSpec ! = null ) { try { AlgorithmParameters engineParams = AlgorithmParameters . getInstance ( pbeAlgorithm , " BC " ) ; engineParams . init ( pbeSpec ) ; return engineParams ; } catch ( Exception e ) { return null ; } } } return engineParams ; } 
protected void engineSetMode ( String mode ) { if ( ! mode . equalsIgnoreCase ( " ECB " ) ) { 
protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { if ( ! padding . equalsIgnoreCase ( " NoPadding " ) ) { 
protected void engineInit ( int opmode , Key key , AlgorithmParameters params , SecureRandom random ) throws InvalidKeyException , InvalidAlgorithmParameterException { AlgorithmParameterSpec paramSpec = null ; if ( params ! = null ) { for ( int i = 0 ; i ! = availableSpecs . length ; i + + ) { try { paramSpec = params . getParameterSpec ( availableSpecs [ i ] ) ; break ; } catch ( Exception e ) { continue ; } } if ( paramSpec = = null ) { throw new InvalidAlgorithmParameterException ( " can't handle parameter " + params . toString ( ) ) ; } } engineInit ( opmode , key , paramSpec , random ) ; engineParams = params ; } 
protected void engineInit ( int opmode , Key key , SecureRandom random ) throws InvalidKeyException { try { 
protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { byte [ ] out = new byte [ inputLen ] ; cipher . processBytes ( input , inputOffset , inputLen , out , 0 ) ; return out ; } 
protected int engineUpdate ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) throws ShortBufferException { try { 
protected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) { if ( inputLen ! = 0 ) { byte [ ] out = engineUpdate ( input , inputOffset , inputLen ) ; cipher . reset ( ) ; return out ; } cipher . reset ( ) ; return new byte [ 0 ] ; } 
protected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { if ( inputLen ! = 0 ) { cipher . processBytes ( input , inputOffset , inputLen , output , outputOffset ) ; } cipher . reset ( ) ; return inputLen ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof DSAPrivateKey ) ) { return false ; } DSAPrivateKey other = ( DSAPrivateKey ) o ; return this . getX ( ) . equals ( other . getX ( ) ) & & this . getParams ( ) . getG ( ) . equals ( other . getParams ( ) . getG ( ) ) 
public int hashCode ( ) { return this . getX ( ) . hashCode ( ) ^ this . getParams ( ) . getG ( ) . hashCode ( ) ^ this . getParams ( ) . getP ( ) . hashCode ( ) ^ this . getParams ( ) . getQ ( ) . hashCode ( ) ; 
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { this . x = ( BigInteger ) in . readObject ( ) ; this . dsaSpec = new DSAParameterSpec ( ( BigInteger ) in . readObject ( ) , ( BigInteger ) in . readObject ( ) , ( BigInteger ) in . readObject ( ) ) ; this . attrCarrier = new PKCS12BagAttributeCarrierImpl ( ) ; attrCarrier . readObject ( in ) ; } 
private void writeObject ( ObjectOutputStream out ) throws IOException { out . writeObject ( x ) ; out . writeObject ( dsaSpec . getP ( ) ) ; out . writeObject ( dsaSpec . getQ ( ) ) ; out . writeObject ( dsaSpec . getG ( ) ) ; attrCarrier . writeObject ( out ) ; } 
static private PBEParametersGenerator makePBEGenerator ( int type , int hash ) { PBEParametersGenerator generator ; if ( type = = PKCS5S1 ) { switch ( hash ) { case MD2 : generator = new PKCS5S1ParametersGenerator ( new MD2Digest ( ) ) ; break ; case MD5 : generator = new PKCS5S1ParametersGenerator ( new MD5Digest ( ) ) ; break ; case SHA1 : generator = new PKCS5S1ParametersGenerator ( new SHA1Digest ( ) ) ; break ; default : throw new IllegalStateException ( " PKCS5 scheme 1 only supports MD2, MD5 and SHA1. " ) ; } } else if ( type = = PKCS5S2 ) { generator = new PKCS5S2ParametersGenerator ( ) ; } else if ( type = = PKCS12 ) { switch ( hash ) { case MD2 : generator = new PKCS12ParametersGenerator ( new MD2Digest ( ) ) ; break ; case MD5 : generator = new PKCS12ParametersGenerator ( new MD5Digest ( ) ) ; break ; case SHA1 : generator = new PKCS12ParametersGenerator ( new SHA1Digest ( ) ) ; break ; case RIPEMD160 : generator = new PKCS12ParametersGenerator ( new RIPEMD160Digest ( ) ) ; break ; case TIGER : generator = new PKCS12ParametersGenerator ( new TigerDigest ( ) ) ; break ; case SHA256 : generator = new PKCS12ParametersGenerator ( new SHA256Digest ( ) ) ; break ; default : throw new IllegalStateException ( " unknown digest scheme for PBE encryption. " ) ; } } else { generator = new OpenSSLPBEParametersGenerator ( ) ; } return generator ; } 
static CipherParameters makePBEMacParameters ( JCEPBEKey pbeKey , AlgorithmParameterSpec spec ) { if ( ( spec = = null ) | | ! ( spec instanceof PBEParameterSpec ) ) { throw new IllegalArgumentException ( " Need a PBEParameter spec with a PBE key. " ) ; } PBEParameterSpec pbeParam = ( PBEParameterSpec ) spec ; PBEParametersGenerator generator = makePBEGenerator ( pbeKey . getType ( ) , pbeKey . getDigest ( ) ) ; byte [ ] key = pbeKey . getEncoded ( ) ; CipherParameters param ; if ( pbeKey . shouldTryWrongPKCS12 ( ) ) { key = new byte [ 2 ] ; } generator . init ( key , pbeParam . getSalt ( ) , pbeParam . getIterationCount ( ) ) ; param = generator . generateDerivedMacParameters ( pbeKey . getKeySize ( ) ) ; for ( int i = 0 ; i ! = key . length ; i + + ) { key [ i ] = 0 ; } return param ; } 
static CipherParameters makePBEParameters ( PBEKeySpec keySpec , int type , int hash , int keySize , int ivSize ) { PBEParametersGenerator generator = makePBEGenerator ( type , hash ) ; byte [ ] key ; CipherParameters param ; if ( type = = PKCS12 ) { key = PBEParametersGenerator . PKCS12PasswordToBytes ( keySpec . getPassword ( ) ) ; } else { key = PBEParametersGenerator . PKCS5PasswordToBytes ( keySpec . getPassword ( ) ) ; } generator . init ( key , keySpec . getSalt ( ) , keySpec . getIterationCount ( ) ) ; if ( ivSize ! = 0 ) { param = generator . generateDerivedParameters ( keySize , ivSize ) ; } else { param = generator . generateDerivedParameters ( keySize ) ; } for ( int i = 0 ; i ! = key . length ; i + + ) { key [ i ] = 0 ; } return param ; } 
static CipherParameters makePBEMacParameters ( PBEKeySpec keySpec , int type , int hash , int keySize ) { PBEParametersGenerator generator = makePBEGenerator ( type , hash ) ; byte [ ] key ; CipherParameters param ; if ( type = = PKCS12 ) { key = PBEParametersGenerator . PKCS12PasswordToBytes ( keySpec . getPassword ( ) ) ; } else { key = PBEParametersGenerator . PKCS5PasswordToBytes ( keySpec . getPassword ( ) ) ; } generator . init ( key , keySpec . getSalt ( ) , keySpec . getIterationCount ( ) ) ; param = generator . generateDerivedMacParameters ( keySize ) ; for ( int i = 0 ; i ! = key . length ; i + + ) { key [ i ] = 0 ; } return param ; } 
public void setBagAttribute ( DERObjectIdentifier oid , DEREncodable attribute ) { if ( pkcs12Attributes . containsKey ( oid ) ) { preserve original ordering 
public DEREncodable getBagAttribute ( DERObjectIdentifier oid ) { return ( DEREncodable ) pkcs12Attributes . get ( oid ) ; } 
public void writeObject ( ObjectOutputStream out ) throws IOException { if ( pkcs12Ordering . size ( ) = = 0 ) { 
public void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { Object obj = in . readObject ( ) ; if ( obj instanceof Hashtable ) { 
protected int engineGetBlockSize ( ) { return 0 ; } 
protected byte [ ] engineGetIV ( ) { return ( byte [ ] ) iv . clone ( ) ; } 
protected int engineGetKeySize ( Key key ) { return key . getEncoded ( ) . length ; } 
protected int engineGetOutputSize ( int inputLen ) { return - 1 ; } 
protected AlgorithmParameters engineGetParameters ( ) { return null ; } 
protected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { throw new NoSuchAlgorithmException ( " can't support mode " + mode ) ; } 
protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { throw new NoSuchPaddingException ( " Padding " + padding + " unknown. " ) ; } 
tprotected void engineInit ( int opmode , Key key , AlgorithmParameters params , SecureRandom random ) throws InvalidKeyException , InvalidAlgorithmParameterException { AlgorithmParameterSpec paramSpec = null ; if ( params ! = null ) { for ( int i = 0 ; i ! = availableSpecs . length ; i + + ) { try { paramSpec = params . getParameterSpec ( availableSpecs [ i ] ) ; break ; } catch ( Exception e ) { try next spec } } if (paramSpec == null) { throw new InvalidAlgorithmParameterException("can't handle parameter " + params.toString()); } } engineParams = params; engineInit(opmode, key, paramSpec, random); } 
protected void engineInit ( int opmode , Key key , SecureRandom random ) throws InvalidKeyException { try { 
protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { throw new RuntimeException ( " not supported for wrapping " ) ; } 
protected int engineUpdate ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) throws ShortBufferException { throw new RuntimeException ( " not supported for wrapping " ) ; } 
protected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) throws IllegalBlockSizeException , BadPaddingException { return null ; } 
protected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) throws IllegalBlockSizeException , BadPaddingException { return 0 ; } 
protected byte [ ] engineWrap ( Key key ) throws IllegalBlockSizeException , java . security . InvalidKeyException { byte [ ] encoded = key . getEncoded ( ) ; if ( encoded = = null ) { throw new InvalidKeyException ( " Cannot wrap key, null encoding. " ) ; } try { 
protected Key engineUnwrap ( byte [ ] wrappedKey , String wrappedKeyAlgorithm , int wrappedKeyType ) throws InvalidKeyException { byte [ ] encoded ; try { if ( wrapEngine = = null ) { encoded = engineDoFinal ( wrappedKey , 0 , wrappedKey . length ) ; } else { encoded = wrapEngine . unwrap ( wrappedKey , 0 , wrappedKey . length ) ; } } catch ( InvalidCipherTextException e ) { throw new InvalidKeyException ( e . getMessage ( ) ) ; } catch ( BadPaddingException e ) { throw new InvalidKeyException ( e . getMessage ( ) ) ; } catch ( IllegalBlockSizeException e2 ) { throw new InvalidKeyException ( e2 . getMessage ( ) ) ; } if ( wrappedKeyType = = Cipher . SECRET_KEY ) { 
public static boolean constantTimeAreEqual ( byte [ ] a , byte [ ] b ) { if ( a = = b ) { return true ; } if ( a = = null | | b = = null ) { return false ; } if ( a . length ! = b . length ) { return false ; } int nonEqual = 0 ; for ( int i = 0 ; i ! = a . length ; i + + ) { nonEqual | = ( a [ i ] ^ b [ i ] ) ; } return nonEqual = = 0 ; } 
public static void drain ( InputStream inStr ) throws IOException { byte [ ] bs = new byte [ BUFFER_SIZE ] ; while ( inStr . read ( bs , 0 , bs . length ) > = 0 ) { 
public static byte [ ] readAll ( InputStream inStr ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; pipeAll ( inStr , buf ) ; return buf . toByteArray ( ) ; } 
public static byte [ ] readAllLimited ( InputStream inStr , int limit ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; pipeAllLimited ( inStr , limit , buf ) ; return buf . toByteArray ( ) ; } 
public static int readFully ( InputStream inStr , byte [ ] buf ) throws IOException { return readFully ( inStr , buf , 0 , buf . length ) ; } 
public static int readFully ( InputStream inStr , byte [ ] buf , int off , int len ) throws IOException { int totalRead = 0 ; while ( totalRead < len ) { int numRead = inStr . read ( buf , off + totalRead , len - totalRead ) ; if ( numRead < 0 ) { break ; } totalRead + = numRead ; } return totalRead ; } 
public static void pipeAll ( InputStream inStr , OutputStream outStr ) throws IOException { byte [ ] bs = new byte [ BUFFER_SIZE ] ; int numRead ; while ( ( numRead = inStr . read ( bs , 0 , bs . length ) ) > = 0 ) { 
public static long pipeAllLimited ( InputStream inStr , long limit , OutputStream outStr ) throws IOException { long total = 0 ; byte [ ] bs = new byte [ BUFFER_SIZE ] ; int numRead ; while ( ( numRead = inStr . read ( bs , 0 , bs . length ) ) > = 0 ) { total + = numRead ; if ( total > limit ) { throw new StreamOverflowException ( " Data Overflow " ) ; } outStr . write ( bs , 0 , numRead ) ; } return total ; } 
public int getOutputSize ( int length ) { Note: Can assume partialBlockOkay is true for purposes of this calculation return length + bufOff; } 
public void init ( boolean forEncryption , CipherParameters params ) throws IllegalArgumentException ; public void reset ( ) ; } 
public String getAlgorithmName ( ) ; public void reset ( ) ; } 
public BlockCipher getUnderlyingCipher ( ) ; public void reset ( ) ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) throws DataLengthException ; public void reset ( ) ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) throws DataLengthException ; public void reset ( ) ; } 
public int doFinal ( byte [ ] out , int outOff ) throws IllegalStateException , InvalidCipherTextException ; public void reset ( ) ; } 
public byte [ ] getMac ( ) ; public void reset ( ) ; } 
public int getUpdateOutputSize ( int len ) ; public void reset ( ) ; } 
public int getOutputSize ( int len ) ; public void reset ( ) ; } 
public void reset ( ) { System . arraycopy ( IV , 0 , cbcV , 0 , IV . length ) ; Arrays . fill ( cbcNextV , ( byte ) 0 ) ; cipher . reset ( ) ; } 
public int getOutputSize ( int len ) { return len + bufOff ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { int resultLen = 0 ; if ( bufOff = = buf . length ) { resultLen = cipher . processBlock ( buf , 0 , out , outOff ) ; System . arraycopy ( buf , blockSize , buf , 0 , blockSize ) ; bufOff = blockSize ; } buf [ bufOff + + ] = in ; return resultLen ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( len < 0 ) { throw new IllegalArgumentException ( " Can't have a negative input length! " ) ; } int blockSize = getBlockSize ( ) ; int length = getUpdateOutputSize ( len ) ; if ( length > 0 ) { if ( ( outOff + length ) > out . length ) { throw new DataLengthException ( " output buffer too short " ) ; } } int resultLen = 0 ; int gapLen = buf . length - bufOff ; if ( len > gapLen ) { System . arraycopy ( in , inOff , buf , bufOff , gapLen ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff ) ; System . arraycopy ( buf , blockSize , buf , 0 , blockSize ) ; bufOff = blockSize ; len - = gapLen ; inOff + = gapLen ; while ( len > blockSize ) { System . arraycopy ( in , inOff , buf , bufOff , blockSize ) ; resultLen + = cipher . processBlock ( buf , 0 , out , outOff + resultLen ) ; System . arraycopy ( buf , blockSize , buf , 0 , blockSize ) ; len - = blockSize ; inOff + = blockSize ; } } System . arraycopy ( in , inOff , buf , bufOff , len ) ; bufOff + = len ; return resultLen ; } 
public int doFinal ( byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException , InvalidCipherTextException { if ( bufOff + outOff > out . length ) { throw new DataLengthException ( " output buffer to small in doFinal " ) ; } int blockSize = cipher . getBlockSize ( ) ; int len = bufOff - blockSize ; byte [ ] block = new byte [ blockSize ] ; if ( forEncryption ) { cipher . processBlock ( buf , 0 , block , 0 ) ; if ( bufOff < blockSize ) { throw new DataLengthException ( " need at least one block of input for CTS " ) ; } for ( int i = bufOff ; i ! = buf . length ; i + + ) { buf [ i ] = block [ i - blockSize ] ; } for ( int i = blockSize ; i ! = bufOff ; i + + ) { buf [ i ] ^ = block [ i - blockSize ] ; } if ( cipher instanceof CBCBlockCipher ) { BlockCipher c = ( ( CBCBlockCipher ) cipher ) . getUnderlyingCipher ( ) ; c . processBlock ( buf , blockSize , out , outOff ) ; } else { cipher . processBlock ( buf , blockSize , out , outOff ) ; } System . arraycopy ( block , 0 , out , outOff + blockSize , len ) ; } else { byte [ ] lastBlock = new byte [ blockSize ] ; if ( cipher instanceof CBCBlockCipher ) { BlockCipher c = ( ( CBCBlockCipher ) cipher ) . getUnderlyingCipher ( ) ; c . processBlock ( buf , 0 , block , 0 ) ; } else { cipher . processBlock ( buf , 0 , block , 0 ) ; } for ( int i = blockSize ; i ! = bufOff ; i + + ) { lastBlock [ i - blockSize ] = ( byte ) ( block [ i - blockSize ] ^ buf [ i ] ) ; } System . arraycopy ( buf , blockSize , block , 0 , len ) ; cipher . processBlock ( block , 0 , out , outOff ) ; System . arraycopy ( lastBlock , 0 , out , outOff + blockSize , len ) ; } int offset = bufOff ; reset ( ) ; return offset ; } 
public Object run ( ) { setup ( ) ; return null ; } 
private void loadAlgorithms ( String packageName , String [ ] names ) { for ( int i = 0 ; i ! = names . length ; i + + ) { 
private void addMappings ( Map mappings ) { can't use putAll due to JDK 1.1 for (Iterator it = mappings.keySet().iterator(); it.hasNext();) { 
private void addHMACAlgorithm ( String algorithm , String algorithmClassName , String keyGeneratorClassName ) { String mainName = " HMAC " + algorithm ; put ( " Mac. " + mainName , algorithmClassName ) ; put ( " Alg.Alias.Mac.HMAC- " + algorithm , mainName ) ; put ( " Alg.Alias.Mac.HMAC/ " + algorithm , mainName ) ; put ( " KeyGenerator. " + mainName , keyGeneratorClassName ) ; put ( " Alg.Alias.KeyGenerator.HMAC- " + algorithm , mainName ) ; put ( " Alg.Alias.KeyGenerator.HMAC/ " + algorithm , mainName ) ; } 
private void addHMACAlias ( String algorithm , DERObjectIdentifier oid ) { String mainName = " HMAC " + algorithm ; put ( " Alg.Alias.Mac. " + oid , mainName ) ; put ( " Alg.Alias.KeyGenerator. " + oid , mainName ) ; } 
protected int engineGetBlockSize ( ) { return baseEngine . getBlockSize ( ) ; } 
protected int engineGetOutputSize ( int inputLen ) { return cipher . getOutputSize ( inputLen ) ; } 
protected AlgorithmParameters engineGetParameters ( ) { if ( engineParams = = null ) { if ( pbeSpec ! = null ) { try { engineParams = AlgorithmParameters . getInstance ( pbeAlgorithm , " BC " ) ; engineParams . init ( pbeSpec ) ; } catch ( Exception e ) { return null ; } } else if ( ivParam ! = null ) { String name = cipher . getUnderlyingCipher ( ) . getAlgorithmName ( ) ; if ( name . indexOf ( '/' ) > = 0 ) { name = name . substring ( 0 , name . indexOf ( '/' ) ) ; } try { engineParams = AlgorithmParameters . getInstance ( name , " BC " ) ; engineParams . init ( ivParam . getIV ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . toString ( ) ) ; } } } return engineParams ; } 
protected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { modeName = Strings . toUpperCase ( mode ) ; if ( modeName . equals ( " ECB " ) ) { 
protected void engineSetPadding ( String padding ) throws NoSuchPaddingException { String paddingName = Strings . toUpperCase ( padding ) ; if ( paddingName . equals ( " NOPADDING " ) ) { 
protected void engineInit ( int opmode , Key key , AlgorithmParameters params , SecureRandom random ) throws InvalidKeyException , InvalidAlgorithmParameterException { AlgorithmParameterSpec paramSpec = null ; if ( params ! = null ) { for ( int i = 0 ; i ! = availableSpecs . length ; i + + ) { try { paramSpec = params . getParameterSpec ( availableSpecs [ i ] ) ; break ; } catch ( Exception e ) { try again if possible } } if (paramSpec == null) { throw new InvalidAlgorithmParameterException("can't handle parameter " + params.toString()); } } engineInit(opmode, key, paramSpec, random); engineParams = params; } 
protected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { int length = cipher . getUpdateOutputSize ( inputLen ) ; if ( length > 0 ) { byte [ ] out = new byte [ length ] ; int len = cipher . processBytes ( input , inputOffset , inputLen , out , 0 ) ; if ( len = = 0 ) { return null ; } else if ( len ! = out . length ) { byte [ ] tmp = new byte [ len ] ; System . arraycopy ( out , 0 , tmp , 0 , len ) ; return tmp ; } return out ; } cipher . processBytes ( input , inputOffset , inputLen , null , 0 ) ; return null ; } 
protected int engineUpdate ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) throws ShortBufferException { try { 
protected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) throws IllegalBlockSizeException , BadPaddingException { int len = 0 ; byte [ ] tmp = new byte [ engineGetOutputSize ( inputLen ) ] ; if ( inputLen ! = 0 ) { len = cipher . processBytes ( input , inputOffset , inputLen , tmp , 0 ) ; } try { len + = cipher . doFinal ( tmp , len ) ; } catch ( DataLengthException e ) { throw new IllegalBlockSizeException ( e . getMessage ( ) ) ; } catch ( InvalidCipherTextException e ) { throw new BadPaddingException ( e . getMessage ( ) ) ; } if ( len = = tmp . length ) { return tmp ; } byte [ ] out = new byte [ len ] ; System . arraycopy ( tmp , 0 , out , 0 , len ) ; return out ; } 
protected int engineDoFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) throws IllegalBlockSizeException , BadPaddingException { int len = 0 ; if ( inputLen ! = 0 ) { len = cipher . processBytes ( input , inputOffset , inputLen , output , outputOffset ) ; } try { 
private boolean isAEADModeName ( String modeName ) { return " CCM " . equals ( modeName ) | | " EAX " . equals ( modeName ) | | " GCM " . equals ( modeName ) ; } 
public void init ( boolean forEncryption , CipherParameters params ) throws IllegalArgumentException { cipher . init ( forEncryption , params ) ; } 
public boolean wrapOnNoPadding ( ) { return ! ( cipher instanceof CTSBlockCipher ) ; } 
public int processByte ( byte in , byte [ ] out , int outOff ) throws DataLengthException { return cipher . processByte ( in , out , outOff ) ; } 
public int processBytes ( byte [ ] in , int inOff , int len , byte [ ] out , int outOff ) throws DataLengthException { return cipher . processBytes ( in , inOff , len , out , outOff ) ; } 
public int doFinal ( byte [ ] out , int outOff ) throws IllegalStateException , InvalidCipherTextException { return cipher . doFinal ( out , outOff ) ; } 
public static void Launch ( Activity act , PwGroup group ) { tIntent i ; } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , String keyfile ) tthrows IOException , InvalidDBException { treturn openDatabase ( inStream , password , keyfile , new UpdateStatus ( ) ) ; } 
public void output ( ) throws PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
protected DERObject buildObject ( int tag , int tagNo , int length ) throws IOException { boolean isConstructed = ( tag & CONSTRUCTED ) ! = 0 ; DefiniteLengthInputStream defIn = new DefiniteLengthInputStream ( this , length ) ; if ( ( tag & APPLICATION ) ! = 0 ) { return new DERApplicationSpecific ( isConstructed , tagNo , defIn . toByteArray ( ) ) ; } if ( ( tag & TAGGED ) ! = 0 ) { return new BERTaggedObjectParser ( tag , tagNo , defIn ) . getDERObject ( ) ; } if ( isConstructed ) { assert(false); return new LazyDERSequence(defIn.toByteArray()); } else { return DERFactory.createSequence(buildDEREncodableVector(defIn)); } case SET: return DERFactory.createSet(buildDEREncodableVector(defIn), false); case EXTERNAL: return new DERExternal(buildDEREncodableVector(defIn)); default: return new DERUnknownTag(true, tagNo, defIn.toByteArray()); } } return createPrimitiveDERObject(tagNo, defIn.toByteArray()); } 
public void testReadTwofish ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " twofish.kdb " , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; tPwDatabaseV3 db = importer . openDatabase ( is , " 12345 " , " " ) ; tassertTrue ( db . algorithm = = PwDbHeaderV3 . ALGO_TWOFISH ) ; tis . close ( ) ; 
public abstract void addEntry ( ) ; @Override public void run ( ) { taddEntry ( ) ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public abstract byte [ ] getPasswordKey ( String key ) throws IOException ; public abstract List < PwGroup > getGrpRoots ( ) ; public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract List < PwGroup > getGrpRoots ( ) ; public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract List < PwGroup > getGroups ( ) ; public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract List < PwEntry > getEntries ( ) ; public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract long getNumRounds ( ) ; public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract void setNumRounds ( long rounds ) throws NumberFormatException ; public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public abstract boolean appSettingsEnabled ( ) ; public abstract PwEncryptionAlgorithm getEncAlgorithm ( ) ; } 
public void run ( ) { save.run(); 
public void output ( ) throws PwDbOutputException { cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, "AES" ), new IvParameterSpec(header.encryptionIV) ); 
public void testReadTwofish ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " twofish.kdb " , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; tPwDatabaseV3 db = importer . openDatabase ( is , " 12345 " , " " ) ; tassertTrue ( db . algorithm = = PwEncryptionAlgorithm . Twofish ) ; tis . close ( ) ; 
tprotected byte [ ] getPasswordKey ( String key , String encoding ) throws IOException { tassert ( key ! = null ) ; tif ( key . length ( ) = = 0 ) throw new IllegalArgumentException ( " Key cannot be empty. " ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tbyte [ ] bKey ; ttry { tbKey = key . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { tassert false ; tbKey = key . getBytes ( ) ; } tmd . update ( bKey , 0 , bKey . length ) ; treturn md . digest ( ) ; } 
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { } 
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { } 
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { } 
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { } 
public PwGroupIdV3 newGroupId ( ) { tPwGroupIdV3 newId = new PwGroupIdV3 ( 0 ) ; tRandom random = new Random ( ) ; twhile ( true ) { tnewId = new PwGroupIdV3 ( random . nextInt ( ) ) ; tif ( ! isGroupIdUsed ( newId ) ) break ; } treturn newId ; } 
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { tsuper . addEntryTo ( newEntry , parent ) ; 
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { tsuper . addGroupTo ( newGroup , parent ) ; 
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { tsuper . removeEntryFrom ( remove , parent ) ; } 
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { tsuper . removeGroupFrom ( remove , parent ) ; } 
public PwGroupIdV4 newGroupId ( ) { tPwGroupIdV4 id = new PwGroupIdV4 ( UUID_ZERO ) ; twhile ( true ) { tid = new PwGroupIdV4 ( UUID . randomUUID ( ) ) ; tif ( ! isGroupIdUsed ( id ) ) break ; } treturn id ; } 
public abstract PwGroup getParent ( ) ; public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract void setId ( PwGroupId id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } 
public void initNewGroup ( String nm , PwGroupId newId ) { tsuper . initNewGroup ( nm , newId ) ; timageId = 0 ; tDate now = Calendar . getInstance ( ) . getTime ( ) ; ttCreation = new PwDate ( now ) ; ttLastAccess = new PwDate ( now ) ; ttLastMod = new PwDate ( now ) ; ttExpire = new PwDate ( PwGroupV3 . NEVER_EXPIRE ) ; 
public void run ( ) { tmDb . pm . addEntryTo ( mEntry , mEntry . getParent ( ) ) ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { tPwDatabase pm = ( PwDatabaseV3 ) mDb . pm ; } 
public void run ( ) { tif ( mSuccess ) { } 
tprotected byte [ ] getFileKey ( String fileName ) tthrows InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tbyte [ ] key = loadXmlKeyFile ( fileName ) ; tif ( key ! = null ) { treturn key ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tlong fileSize = keyfile . length ( ) ; tif ( fileSize = = 0 ) { tthrow new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { tbyte [ ] outputKey = new byte [ 32 ] ; tif ( fis . read ( outputKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn outputKey ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tif ( fis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn hexStringToByteArray ( new String ( hex ) ) ; } tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } } 
tprotected byte [ ] loadXmlKeyFile ( String fileName ) { treturn null ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tInputStream key = getContext ( ) . getAssets ( ) . open ( " keyfile.key " , AssetManager . ACCESS_STREAMING ) ; tFileOutputStream keyFile = new FileOutputStream ( " /sdcard/key " ) ; twhile ( true ) { tbyte [ ] buf = new byte [ 1024 ] ; tint read = key . read ( buf ) ; tif ( read = = - 1 ) { tbreak ; } else { tkeyFile . write ( buf , 0 , read ) ; } } tkeyFile . close ( ) ; 
public void testKeyfile ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " kdb_with_xml_keyfile.kdb " , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; timporter . openDatabase ( is , " 12345 " , " /sdcard/key " ) ; tis . close ( ) ; 
private long ReadLong ( XmlPullParser xpp , long def ) throws IOException , XmlPullParserException { tString str = ReadString ( xpp ) ; tlong u ; ttry { tu = Long . parseLong ( str ) ; } catch ( NumberFormatException e ) { tu = def ; } treturn u ; } 
private long ReadULong ( XmlPullParser xpp , long uDefault ) throws IOException , XmlPullParserException { tlong u = ReadLong ( xpp , uDefault ) ; tif ( u < 0 ) { tu = uDefault ; } treturn u ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
public int read ( ) throws IOException { tif ( atEnd ) return - 1 ; tif ( bufferPos = = buffer . length ) { tif ( ! ReadHashedBlock ( ) ) return - 1 ; } tint output = buffer [ bufferPos ] ; tbufferPos + + ; treturn output ; } 
public void testNoGzip ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " 12345 " , " " ) ; tis . close ( ) ; 
private void timeoutCopyToClipboard ( String text ) { tUtil . copyToClipboard ( this , text ) ; tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; tString sClipClear = prefs . getString ( getString ( R . string . clipboard_timeout_key ) , getString ( R . string . clipboard_timeout_default ) ) ; tlong clipClearTime = Long . parseLong ( sClipClear ) ; tif ( clipClearTime > 0 ) { tmTimer . schedule ( new ClearClipboardTask ( this , text ) , clipClearTime ) ; 
public static void start ( Context ctx ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tString sTimeout = prefs . getString ( ctx . getString ( R . string . app_timeout_key ) , ctx . getString ( R . string . clipboard_timeout_default ) ) ; tlong timeout ; ttry { ttimeout = Long . parseLong ( sTimeout ) ; } catch ( NumberFormatException e ) { ttimeout = DEFAULT_TIMEOUT ; } tif ( timeout = = - 1 ) { } 
public void onClick ( View v ) { tBrowserDialog . this . cancel ( ) ; } 
public void onClick ( View v ) { tUtil . gotoUrl ( getContext ( ) , R . string . oi_filemanager_market ) ; tBrowserDialog . this . cancel ( ) ; } 
public void onClick ( View v ) { tUtil . gotoUrl ( getContext ( ) , R . string . oi_filemanager_web ) ; tBrowserDialog . this . cancel ( ) ; } 
public void onClick ( View v ) { tif ( Interaction . isIntentAvailable ( FileSelectActivity . this , FILE_BROWSE_INTENT ) ) { tIntent i = new Intent ( FILE_BROWSE_INTENT ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tString filename = data . getDataString ( ) ; 
public static boolean isIntentAvailable ( Context context , String action ) { final PackageManager packageManager = context . getPackageManager ( ) ; final Intent intent = new Intent ( action ) ; List < ResolveInfo > list = packageManager . queryIntentActivities ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; return list . size ( ) > 0 ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tswitch ( requestCode ) { 
public void onClick ( View v ) { tif ( Interaction . isIntentAvailable ( PasswordActivity . this , Intents . FILE_BROWSE ) ) { tIntent i = new Intent ( Intents . FILE_BROWSE ) ; 
public void onClick ( View v ) { tif ( Interaction . isIntentAvailable ( FileSelectActivity . this , Intents . FILE_BROWSE ) ) { tIntent i = new Intent ( Intents . FILE_BROWSE ) ; 
private void fillData ( ) { } 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . file_selection_filename , this ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
public void updateExternalStorageWarning ( ) { tint warning = - 1 ; tString state = Environment . getExternalStorageState ( ) ; tif ( state . equals ( Environment . MEDIA_MOUNTED_READ_ONLY ) ) { twarning = R . string . warning_read_only ; } else if ( ! state . equals ( Environment . MEDIA_MOUNTED ) ) { twarning = R . string . warning_unmounted ; } tTextView tv = ( TextView ) findViewById ( R . id . label_warning ) ; tTextView label = ( TextView ) findViewById ( R . id . label_open_by_filename ) ; tRelativeLayout . LayoutParams lp = new RelativeLayout . LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ; tif ( warning ! = - 1 ) { ttv . setText ( warning ) ; ttv . setVisibility ( VISIBLE ) ; tlp . addRule ( RelativeLayout . BELOW , R . id . label_warning ) ; } else { ttv . setVisibility ( INVISIBLE ) ; } tlabel . setLayoutParams ( lp ) ; } 
tprotected byte [ ] getFileKey ( String fileName ) tthrows InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tbyte [ ] key = loadXmlKeyFile ( fileName ) ; tif ( key ! = null ) { treturn key ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( " Key file does not exist. " ) ; } tBufferedInputStream bis = new BufferedInputStream ( fis , 64 ) ; tlong fileSize = keyfile . length ( ) ; tif ( fileSize = = 0 ) { tthrow new InvalidKeyFileException ( " Key file is empty. " ) ; } else if ( fileSize = = 32 ) { tbyte [ ] outputKey = new byte [ 32 ] ; tif ( bis . read ( outputKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn outputKey ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tbis . mark ( 64 ) ; tif ( bis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } ttry { treturn hexStringToByteArray ( new String ( hex ) ) ; } catch ( IndexOutOfBoundsException e ) { } 
public static void extractKey ( Context ctx , String asset , String target ) throws Exception { tInputStream key = ctx . getAssets ( ) . open ( asset , AssetManager . ACCESS_STREAMING ) ; tFileOutputStream keyFile = new FileOutputStream ( target ) ; twhile ( true ) { tbyte [ ] buf = new byte [ 1024 ] ; tint read = key . read ( buf ) ; tif ( read = = - 1 ) { tbreak ; } else { tkeyFile . write ( buf , 0 , read ) ; } } tkeyFile . close ( ) ; 
private void testKeyfile ( String dbAsset , String keyAsset , String password ) throws Exception { tContext ctx = getContext ( ) ; tTestUtil . extractKey ( ctx , keyAsset , " /sdcard/key " ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; timporter . openDatabase ( is , password , " /sdcard/key " ) ; tis . close ( ) ; } 
public void testXMLKeyFile ( ) throws Exception { ttestKeyfile ( " kdb_with_xml_keyfile.kdb " , " keyfile.key " , " 12345 " ) ; } 
public void testBinary64KeyFile ( ) throws Exception { ttestKeyfile ( " binary-key.kdb " , " binary.key " , " 12345 " ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tTestUtil . extractKey ( getContext ( ) , " keyfile.key " , " /sdcard/key " ) ; } 
private void fillData ( ) { tint currIconResId = R . drawable . ic00 + mEntry . imageId ; tif ( currIconResId < R . drawable . ic99_blank ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tiv . setImageResource ( currIconResId ) ; } tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( PwEntryV3 . IsNever ( expires ) ) { tpopulateText ( R . id . entry_expires , R . string . never ) ; } else { tpopulateText ( R . id . entry_expires , df . format ( expires ) ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public void onClick ( View v ) { tIconPickerActivity . Launch ( EntryEditActivity . this ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tswitch ( resultCode ) { 
private void fillData ( ) { tint currIconResId = R . drawable . ic00 + mEntry . imageId ; tmSelectedIconID = mEntry . imageId ; tif ( currIconResId < R . drawable . ic99_blank ) { tImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; tcurrIconButton . setImageResource ( currIconResId ) ; } tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
public void onClick ( View v ) { tGroupEditActivity . Launch ( GroupActivity . this , mGroup ) ; } 
public static void Launch ( Activity act , PwGroup pw ) { tif ( ! ( pw instanceof PwGroupV3 ) ) { tthrow new RuntimeException ( " Not yet implemented. " ) ; } tIntent i = new Intent ( act , GroupEditActivity . class ) ; tPwGroupV3 parent = ( PwGroupV3 ) pw ; ti . putExtra ( KEY_PARENT , parent . groupId ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tIconPickerActivity . Launch ( GroupEditActivity . this ) ; } 
public void onClick ( View v ) { tTextView nameField = ( TextView ) findViewById ( R . id . group_name ) ; tString name = nameField . getText ( ) . toString ( ) ; tif ( name . length ( ) > 0 ) { 
public void onClick ( View v ) { tfinal Intent intent = new Intent ( ) ; tsetResult ( Activity . RESULT_CANCELED , intent ) ; tfinish ( ) ; } 
public static void Launch ( Activity act ) { tIntent i = new Intent ( act , IconPickerActivity . class ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { tfinal Intent intent = new Intent ( ) ; tintent . putExtra ( KEY_ICON_ID , position ) ; tsetResult ( Activity . RESULT_OK , intent ) ; tfinish ( ) ; } 
public abstract PwGroup getParent ( ) ; public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { @Override public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract PwGroup getParent ( ) ; public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract void setParent ( PwGroup parent ) ; public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract PwGroupId getId ( ) ; public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract void setId ( PwGroupId id ) ; public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract int getIconId ( ) ; public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract void setIconId ( int id ) ; public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract String getName ( ) ; public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public abstract Date getLastMod ( ) ; public void sortGroupsByName ( ) { tCollections . sort ( childGroups , new GroupNameComparator ( ) ) ; } public static class GroupNameComparator implements Comparator < PwGroup > { public int compare ( PwGroup object1 , PwGroup object2 ) { treturn object1 . getName ( ) . compareToIgnoreCase ( object2 . getName ( ) ) ; } } public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } } 
public void run ( ) { tPwDatabase pm = ( PwDatabaseV3 ) mDb . pm ; } 
public void run ( ) { save.run(); 
public boolean onCreateOptionsMenu ( Menu menu ) { tmenu . add ( 0 , MENU_DONATE , 0 , R . string . menu_donate ) ; tmenu . findItem ( MENU_DONATE ) . setIcon ( android . R . drawable . ic_menu_share ) ; tmenu . add ( 0 , MENU_LOCK , 0 , R . string . menu_lock ) ; tmenu . findItem ( MENU_LOCK ) . setIcon ( android . R . drawable . ic_lock_lock ) ; tmenu . add ( 0 , MENU_SEARCH , 0 , R . string . menu_search ) ; tmenu . findItem ( MENU_SEARCH ) . setIcon ( android . R . drawable . ic_menu_search ) ; tmenu . add ( 0 , MENU_APP_SETTINGS , 0 , R . string . menu_app_settings ) ; tmenu . findItem ( MENU_APP_SETTINGS ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; tmenu . add ( 0 , MENU_SORT , 0 , R . string . sort_name ) ; tmenu . findItem ( MENU_SORT ) . setIcon ( android . R . drawable . ic_menu_sort_by_size ) ; treturn true ; 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { } 
public PwGroup search ( Database db , String qStr ) { tCursor cursor ; tString queryWithWildCard = addWildCard ( qStr ) ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , new String [ ] { queryWithWildCard } , null , null , null , null ) ; tPwGroup group ; tif ( db . pm instanceof PwDatabaseV3 ) { tgroup = new PwGroupV3 ( ) ; } else if ( db . pm instanceof PwDatabaseV4 ) { tgroup = new PwGroupV4 ( ) ; } else { tLog . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; treturn null ; } tgroup . name = " Search results " ; tgroup . childEntries = new ArrayList < PwEntry > ( ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntry entry = ( PwEntry ) db . entries . get ( uuid ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
private String addWildCard ( String qStr ) { tString result = new String ( qStr ) ; tif ( qStr . endsWith ( " \" " ) | | qStr . endsWith ( " * " ) ) { } 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwDatabaseV3 pm = ( PwDatabaseV3 ) db . pm ; tPwGroup group1 = getGroup ( pm , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
private void fillData ( ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tiv . setImageResource ( Icons . iconToResId ( mEntry . imageId ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( PwEntryV3 . IsNever ( expires ) ) { tpopulateText ( R . id . entry_expires , R . string . never ) ; } else { tpopulateText ( R . id . entry_expires , df . format ( expires ) ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
private void fillData ( ) { tImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; tcurrIconButton . setImageResource ( Icons . iconToResId ( mEntry . imageId ) ) ; tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
private static void buildList ( ) { tif ( icons = = null ) { ticons = new HashMap < Integer , Integer > ( ) ; 
public static int iconToResId ( int iconId ) { tbuildList ( ) ; tInteger resId = icons . get ( iconId ) ; tif ( resId = = null ) { treturn R . drawable . ic99_blank ; } treturn resId ; } 
public static int count ( ) { tbuildList ( ) ; treturn icons . size ( ) ; } 
public void onClick ( View v ) { } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tif ( resultCode = = RESULT_OK ) { tString generatedPassword = data . getStringExtra ( " com.keepassdroid.password.generated_password " ) ; 
public static void Launch ( Activity act ) { tIntent i = new Intent ( act , GeneratePasswordActivity . class ) ; tact . startActivityForResult ( i , 0 ) ; } 
 public void onClick ( View v ) { tButton button = ( Button ) v ; tEditText editText = ( EditText ) findViewById ( R . id . length ) ; teditText . setText ( button . getText ( ) ) ; } 
public void onClick ( View v ) { tString password = generatePassword ( ) ; tEditText txtPassword = ( EditText ) findViewById ( R . id . password ) ; ttxtPassword . setText ( password ) ; } 
public void onClick ( View v ) { tEditText password = ( EditText ) findViewById ( R . id . password ) ; tIntent intent = new Intent ( ) ; tintent . putExtra ( " com.keepassdroid.password.generated_password " , password . getText ( ) . toString ( ) ) ; tsetResult ( RESULT_OK , intent ) ; tfinish ( ) ; } 
public void onClick ( View v ) { tsetResult ( RESULT_CANCELED ) ; tfinish ( ) ; } 
public String generatePassword ( ) { tString password = " " ; ttry { tint length = new Integer ( ( ( EditText ) findViewById ( R . id . length ) ) . getText ( ) . toString ( ) ) ; ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) ; tPasswordGenerator generator = new PasswordGenerator ( this ) ; tpassword = generator . generatePassword ( length , ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_lowercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_digits ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_minus ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_underline ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_space ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_specials ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_brackets ) ) . isChecked ( ) ) ; } catch ( NumberFormatException e ) { tToast . makeText ( this , R . string . error_wrong_length , Toast . LENGTH_LONG ) . show ( ) ; } catch ( IllegalArgumentException e ) { tToast . makeText ( this , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; } treturn password ; } 
public String generatePassword ( int length , boolean upperCase , boolean lowerCase , boolean digits , boolean minus , boolean underline , boolean space , boolean specials , boolean brackets ) throws IllegalArgumentException { tif ( length < = 0 ) tthrow new IllegalArgumentException ( cxt . getString ( R . string . error_wrong_length ) ) ; tif ( ! upperCase & & ! lowerCase & & ! digits & & ! minus & & ! underline & & ! space & & ! specials & & ! brackets ) tthrow new IllegalArgumentException ( cxt . getString ( R . string . error_pass_gen_type ) ) ; tString characterSet = getCharacterSet ( upperCase , lowerCase , digits , minus , underline , space , specials , brackets ) ; tint size = characterSet . length ( ) ; tStringBuffer buffer = new StringBuffer ( ) ; tif ( size > 0 ) { tRandom random = new Random ( ) ; tfor ( int i = 0 ; i < length ; i + + ) { tchar c = characterSet . charAt ( ( char ) random . nextInt ( size ) ) ; tbuffer . append ( c ) ; } } treturn buffer . toString ( ) ; } 
public void onClick ( View v ) { tEditText password = ( EditText ) findViewById ( R . id . password ) ; tIntent intent = new Intent ( ) ; tintent . putExtra ( " com.keepassdroid.password.generated_password " , password . getText ( ) . toString ( ) ) ; tsetResult ( EntryEditActivity . RESULT_OK_PASSWORD_GENERATOR , intent ) ; tfinish ( ) ; } 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { tfinal Intent intent = new Intent ( ) ; tintent . putExtra ( KEY_ICON_ID , position ) ; tsetResult ( EntryEditActivity . RESULT_OK_ICON_PICKER , intent ) ; tfinish ( ) ; } 
public String generatePassword ( int length , boolean upperCase , boolean lowerCase , boolean digits , boolean minus , boolean underline , boolean space , boolean specials , boolean brackets ) throws IllegalArgumentException { tif ( length < = 0 ) tthrow new IllegalArgumentException ( cxt . getString ( R . string . error_wrong_length ) ) ; tif ( ! upperCase & & ! lowerCase & & ! digits & & ! minus & & ! underline & & ! space & & ! specials & & ! brackets ) tthrow new IllegalArgumentException ( cxt . getString ( R . string . error_pass_gen_type ) ) ; tString characterSet = getCharacterSet ( upperCase , lowerCase , digits , minus , underline , space , specials , brackets ) ; tint size = characterSet . length ( ) ; tStringBuffer buffer = new StringBuffer ( ) ; tRandom random = new Random ( ) ; tif ( size > 0 ) { tfor ( int i = 0 ; i < length ; i + + ) { tchar c = characterSet . charAt ( ( char ) random . nextInt ( size ) ) ; tbuffer . append ( c ) ; } } treturn buffer . toString ( ) ; } 
public void clear ( ) { tinitSearch ( ) ; tindexBuilt = false ; tgroups . clear ( ) ; tentries . clear ( ) ; tdirty . clear ( ) ; tdrawFactory . clear ( ) ; troot = null ; tpm = null ; tmFilename = null ; tloaded = false ; } 
private void fillData ( ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( PwEntryV3 . IsNever ( expires ) ) { tpopulateText ( R . id . entry_expires , R . string . never ) ; } else { tpopulateText ( R . id . entry_expires , df . format ( expires ) ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
private void fillData ( ) { tImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
public boolean isMetaStream ( ) { tif ( binaryData = = null ) return false ; tif ( additional = = null | | additional . length ( ) = = 0 ) return false ; tif ( ! binaryDesc . equals ( PMS_ID_BINDESC ) ) return false ; tif ( title = = null ) return false ; tif ( ! title . equals ( PMS_ID_TITLE ) ) return false ; tif ( username = = null ) return false ; tif ( ! username . equals ( PMS_ID_USER ) ) return false ; tif ( url = = null ) return false ; tif ( ! url . equals ( PMS_ID_URL ) ) return false ; tif ( ! icon . isMetaStreamIcon ( ) ) return false ; treturn true ; } 
private void assign ( PwEntryV4 source ) { tparent = source . parent ; tuuid = source . uuid ; tstrings = source . strings ; tbinaries = source . binaries ; tcustomIcon = source . customIcon ; tforegroundColor = source . foregroundColor ; tbackgroupColor = source . backgroupColor ; toverrideURL = source . overrideURL ; tautoType = source . autoType ; thistory = source . history ; tparentGroupLastMod = source . parentGroupLastMod ; tcreation = source . creation ; tlastMod = source . lastMod ; tlastAccess = source . lastAccess ; texpireDate = source . expireDate ; texpires = source . expires ; tusageCount = source . usageCount ; turl = source . url ; tadditional = source . additional ; 
public int hashCode ( ) { tfinal int prime = 31 ; tint result = 1 ; tresult = prime * result + ( ( uuid = = null ) ? 0 : uuid . hashCode ( ) ) ; treturn result ; } 
public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwIconCustom other = ( PwIconCustom ) obj ; tif ( uuid = = null ) { tif ( other . uuid ! = null ) treturn false ; } else if ( ! uuid . equals ( other . uuid ) ) treturn false ; treturn true ; } 
public void put ( PwIconCustom icon ) { tcustomCache . put ( icon . uuid , icon ) ; } 
public int hashCode ( ) { tfinal int prime = 31 ; tint result = 1 ; tresult = prime * result + iconId ; treturn result ; } 
public boolean equals ( Object obj ) { tif ( this = = obj ) treturn true ; tif ( obj = = null ) treturn false ; tif ( getClass ( ) ! = obj . getClass ( ) ) treturn false ; tPwIconStandard other = ( PwIconStandard ) obj ; tif ( iconId ! = other . iconId ) treturn false ; treturn true ; } 
tvoid readGroupField ( PwDatabaseV3 db , PwGroupV3 grp , int fieldType , byte [ ] buf , int offset ) throws UnsupportedEncodingException { tswitch ( fieldType ) { tcase 0x0000 : 
tvoid readEntryField ( PwDatabaseV3 db , PwEntryV3 ent , byte [ ] buf , int offset ) tthrows UnsupportedEncodingException { tint fieldType = Types . readShort ( buf , offset ) ; toffset + = 2 ; tint fieldSize = LEDataInputStream . readInt ( buf , offset ) ; toffset + = 4 ; tswitch ( fieldType ) { tcase 0x0000 : 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void assignDrawableTo ( ImageView iv , Resources res , PwIcon icon ) { tDrawable draw = getIconDrawable ( res , icon ) ; tiv . setImageDrawable ( draw ) ; } 
private void initBlank ( Resources res ) { tif ( blank = = null ) { tblank = res . getDrawable ( R . drawable . ic99_blank ) ; 
public void clear ( ) { tstandardIconMap . clear ( ) ; tcustomIconMap . clear ( ) ; } 
public void testAssign ( ) { tPwEntryV4 entry = new PwEntryV4 ( ) ; tentry . additional = " test223 " ; tentry . autoType = entry . new AutoType ( ) ; tentry . autoType . defaultSequence = " 1324 " ; tentry . autoType . enabled = true ; tentry . autoType . obfuscationOptions = 123412432109L ; tentry . autoType . put ( " key " , " value " ) ; tentry . backgroupColor = " blue " ; tentry . binaries . put ( " key1 " , new byte [ ] { 0 , 1 } ) ; tentry . customIcon = new PwIconCustom ( UUID . randomUUID ( ) , new byte [ 0 ] ) ; tentry . foregroundColor = " red " ; tentry . history . add ( new PwEntryV4 ( ) ) ; tentry . icon = new PwIconStandard ( 5 ) ; tentry . overrideURL = " override " ; tentry . parent = new PwGroupV4 ( ) ; tentry . strings . put ( " key2 " , " value2 " ) ; tentry . url = " http:localhost " ; tentry . uuid = UUID . randomUUID ( ) ; tPwEntryV4 target = new PwEntryV4 ( ) ; ttarget . assign ( entry ) ; 
public void initNewGroup ( String nm , PwGroupId newId ) { tsuper . initNewGroup ( nm , newId ) ; tDate now = Calendar . getInstance ( ) . getTime ( ) ; ttCreation = new PwDate ( now ) ; ttLastAccess = new PwDate ( now ) ; ttLastMod = new PwDate ( now ) ; ttExpire = new PwDate ( PwGroupV3 . NEVER_EXPIRE ) ; 
public void run ( ) { tPwDatabase pm = ( PwDatabaseV3 ) mDb . pm ; } 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void output ( ) throws IOException { } 
public void dataChanged ( ) { tif ( backupManager ! = null & & dataChanged ! = null ) { ttry { 
public void onCreate ( ) { tString defaultPrefs = this . getPackageName ( ) + " _preferences " ; tSharedPreferencesBackupHelper prefHelper = new SharedPreferencesBackupHelper ( this , defaultPrefs ) ; taddHelper ( PREFS_BACKUP_KEY , prefHelper ) ; } 
tprotected void onStop ( ) { tbackupManager . dataChanged ( ) ; tsuper . onStop ( ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
private void fillData ( ) { tImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . title ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . url ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . additional ) ; } 
public void onClick ( View v ) { tEntryEditActivity act = EntryEditActivity . this ; } 
private void retrieveSettings ( ) { tmRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; tString defaultFilename = prefs . getString ( KEY_DEFAULT_FILENAME , " " ) ; tif ( mFileName . length ( ) > 0 & & mFileName . equals ( defaultFilename ) ) { tCheckBox checkbox = ( CheckBox ) findViewById ( R . id . default_database ) ; 
private void populateView ( ) { tsetEditText ( R . id . filename , mFileName ) ; tsetEditText ( R . id . pass_keyfile , mKeyFile ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , tboolean isChecked ) { tString newDefaultFileName ; tif ( isChecked ) { tnewDefaultFileName = mFileName ; } else { tnewDefaultFileName = " " ; } tSharedPreferences . Editor editor = prefs . edit ( ) ; teditor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; teditor . commit ( ) ; tBackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . this ) ; tbackupManager . dataChanged ( ) ; 
private void fillData ( ) { } 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint updateAmt = tnativeUpdateWrap ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; tint finalAmt = nativeDoFinalWrap ( mCtxPtr , output , outputOffset + updateAmt , outputSize - updateAmt ) ; tint out = updateAmt + finalAmt ; tmBuffered = 0 ; treturn out ; } 
private int nativeDoFinalWrap ( long ctxPtr , byte [ ] output , int outputOffest , int outputSize ) { tif ( mEncrypting ) { treturn nEncryptFinal ( ctxPtr , output , outputOffest , outputSize ) ; 
tprotected int engineGetOutputSize ( int inputLen ) { tint totalLen = mBuffered + inputLen ; tint padLen = AES_BLOCK_SIZE - ( totalLen % AES_BLOCK_SIZE ) ; } 
private void init ( int opmode , Key key , IvParameterSpec params ) { tif ( mIsInited ) { } 
private long nativeInitWrap ( byte [ ] key , byte [ ] iv ) { tif ( mEncrypting ) { treturn nEncryptInit ( key , iv ) ; 
private native long nEncryptInit ( byte [ ] key , byte [ ] iv ) ; private native long nDecryptInit ( byte [ ] key , byte [ ] iv ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
private native long nDecryptInit ( byte [ ] key , byte [ ] iv ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
tint update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint out = nativeUpdateWrap ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; tmBuffered = ( mBuffered + ( ( inputLen - out ) ) ) % AES_BLOCK_SIZE ; treturn out ; 
private int nativeUpdateWrap ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) { tif ( mEncrypting ) { treturn nEncryptUpdate ( ctxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; 
private native int nEncryptUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; private native int nDecryptUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; } 
private native int nDecryptUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; } 
public byte [ ] transformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) throws IOException { tNativeLib . init ( ) ; treturn nTransformMasterKey ( seed , key , rounds ) ; 
private static native byte [ ] nTransformMasterKey ( byte [ ] seed , byte [ ] key , int rounds ) ; } 
private native long nEncryptInit ( byte [ ] key , byte [ ] iv ) ; private native long nDecryptInit ( byte [ ] key , byte [ ] iv ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
private native long nDecryptInit ( byte [ ] key , byte [ ] iv ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint updateAmt = tnUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; tint finalAmt = nFinal ( mCtxPtr , mPadding , output , outputOffset + updateAmt , outputSize - updateAmt ) ; tint out = updateAmt + finalAmt ; tmBuffered = 0 ; treturn out ; } 
private native int nFinal ( long ctxPtr , boolean usePadding , byte [ ] output , int outputOffest , int outputSize ) ; @Override tprotected int engineGetBlockSize ( ) { treturn AES_BLOCK_SIZE ; } @Override tprotected byte [ ] engineGetIV ( ) { treturn mIV . clone ( ) ; } @Override tprotected int engineGetOutputSize ( int inputLen ) { tint totalLen = mBuffered + inputLen ; tint padLen = AES_BLOCK_SIZE - ( totalLen % AES_BLOCK_SIZE ) ; } 
private void init ( int opmode , Key key , IvParameterSpec params ) { tif ( mIsInited ) { } 
private native long nInit ( boolean encrypting , byte [ ] key , byte [ ] iv ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; 
tint update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint out = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; tmBuffered = ( mBuffered + ( ( inputLen - out ) ) ) % AES_BLOCK_SIZE ; treturn out ; 
private native int nUpdate ( long ctxPtr , byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset , int outputSize ) ; } 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint updateAmt ; tif ( input ! = null & & inputLen > 0 ) { tupdateAmt = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; } else { tupdateAmt = 0 ; } tint finalAmt = nFinal ( mCtxPtr , mPadding , output , outputOffset + updateAmt , outputSize - updateAmt ) ; tint out = updateAmt + finalAmt ; tmBuffered = 0 ; treturn out ; } 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint updateAmt ; tif ( input ! = null & & inputLen > 0 ) { tupdateAmt = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; } else { tupdateAmt = 0 ; } tint finalAmt = nFinal ( mCtxPtr , mPadding , output , outputOffset + updateAmt , outputSize - updateAmt ) ; tint out = updateAmt + finalAmt ; treturn out ; } 
private native int nFinal ( long ctxPtr , boolean usePadding , byte [ ] output , int outputOffest , int outputSize ) ; @Override tprotected int engineGetBlockSize ( ) { treturn AES_BLOCK_SIZE ; } @Override tprotected byte [ ] engineGetIV ( ) { treturn mIV . clone ( ) ; } @Override tprotected int engineGetOutputSize ( int inputLen ) { treturn inputLen + nGetCacheSize ( mCtxPtr ) + AES_BLOCK_SIZE ; } private native int nGetCacheSize ( long ctxPtr ) ; @Override tprotected AlgorithmParameters engineGetParameters ( ) { } 
tprotected int engineGetOutputSize ( int inputLen ) { treturn inputLen + nGetCacheSize ( mCtxPtr ) + AES_BLOCK_SIZE ; } 
private native int nGetCacheSize ( long ctxPtr ) ; @Override tprotected AlgorithmParameters engineGetParameters ( ) { } 
private void init ( int opmode , Key key , IvParameterSpec params ) { tif ( mIsInited ) { } 
private native long nInit ( boolean encrypting , byte [ ] key , byte [ ] iv ) ; @Override tprotected void engineSetMode ( String mode ) throws NoSuchAlgorithmException { tif ( ! mode . equals ( " CBC " ) ) { tthrow new NoSuchAlgorithmException ( " This only supports CBC mode " ) ; } } @Override tprotected void engineSetPadding ( String padding ) tthrows NoSuchPaddingException { tif ( ! mIsInited ) { tNativeLib . init ( ) ; } tif ( padding . length ( ) = = 0 ) { treturn ; } tif ( ! padding . equals ( " PKCS5Padding " ) ) { tthrow new NoSuchPaddingException ( " Only supports PKCS5Padding. " ) ; } tmPadding = true ; } @Override tprotected byte [ ] engineUpdate ( byte [ ] input , int inputOffset , int inputLen ) { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte output [ ] = new byte [ maxSize ] ; tint updateSize = update ( input , inputOffset , inputLen , output , 0 ) ; tif ( updateSize = = maxSize ) { treturn output ; } else { } 
tint update ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) { tint outputSize = engineGetOutputSize ( inputLen ) ; tint out = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; treturn out ; 
tprotected byte [ ] engineDoFinal ( byte [ ] input , int inputOffset , int inputLen ) tthrows IllegalBlockSizeException , BadPaddingException { tint maxSize = engineGetOutputSize ( inputLen ) ; tbyte [ ] output = new byte [ maxSize ] ; tint finalSize ; ttry { tfinalSize = doFinal ( input , inputOffset , inputLen , output , 0 ) ; } catch ( ShortBufferException e ) { return output; 
private int doFinal ( byte [ ] input , int inputOffset , int inputLen , byte [ ] output , int outputOffset ) tthrows ShortBufferException , IllegalBlockSizeException , BadPaddingException { tint outputSize = engineGetOutputSize ( inputLen ) ; tint updateAmt ; tif ( input ! = null & & inputLen > 0 ) { tupdateAmt = nUpdate ( mCtxPtr , input , inputOffset , inputLen , output , outputOffset , outputSize ) ; } else { tupdateAmt = 0 ; } tint finalAmt = nFinal ( mCtxPtr , mPadding , output , outputOffset + updateAmt , outputSize - updateAmt ) ; tint out = updateAmt + finalAmt ; treturn out ; } 
private native int nFinal ( long ctxPtr , boolean usePadding , byte [ ] output , int outputOffest , int outputSize ) tthrows ShortBufferException , IllegalBlockSizeException , BadPaddingException ; @Override tprotected int engineGetBlockSize ( ) { treturn AES_BLOCK_SIZE ; } @Override tprotected byte [ ] engineGetIV ( ) { treturn mIV . clone ( ) ; } @Override tprotected int engineGetOutputSize ( int inputLen ) { treturn inputLen + nGetCacheSize ( mCtxPtr ) + AES_BLOCK_SIZE ; } private native int nGetCacheSize ( long ctxPtr ) ; @Override tprotected AlgorithmParameters engineGetParameters ( ) { } 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . entry_view_contents , this ) ; } 
public void SaveData ( String filename ) throws IOException , PwDbOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; 
private void query ( String query ) { tmGroup = mDb . Search ( query ) ; tif ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { tsetContentView ( new GroupEmptyView ( this ) ) ; } else { tsetContentView ( new GroupViewOnlyView ( this ) ) ; } tsetGroupTitle ( ) ; tsetListAdapter ( new PwGroupListAdapter ( this , mGroup ) ) ; } 
public void SaveData ( String filename ) throws IOException , PwDbOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; 
tprotected void fillData ( ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( PwEntryV3 . IsNever ( expires ) ) { tpopulateText ( R . id . entry_expires , R . string . never ) ; } else { tpopulateText ( R . id . entry_expires , df . format ( expires ) ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
tprotected void setupEditButtons ( ) { }} 
tprotected void fillData ( ) { tsuper . fillData ( ) ; tViewGroup group = ( ViewGroup ) findViewById ( R . id . extra_strings ) ; tPwEntryV4 entry = ( PwEntryV4 ) mEntry ; for (Map.Entry<String, String> pair : entry.strings.entrySet()) { 
public static boolean IsStandardString ( String key ) { treturn key . equals ( STR_TITLE ) | | key . equals ( STR_USERNAME ) | | key . equals ( STR_PASSWORD ) | | key . equals ( STR_URL ) 
tprotected LayoutParams generateDefaultLayoutParams ( ) { treturn new LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ; } 
private void inflate ( Context context , String title , String value ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . entry_section , this ) ; tsetText ( R . id . title , title ) ; tsetText ( R . id . value , value ) ; } 
tprotected void fillData ( ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tDateFormat df = DateFormat . getInstance ( ) ; tpopulateText ( R . id . entry_created , df . format ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , df . format ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , df . format ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( mEntry . expires ( ) ) { tpopulateText ( R . id . entry_expires , df . format ( expires ) ) ; } else { tpopulateText ( R . id . entry_expires , R . string . never ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { tif ( oldVersion ! = DATABASE_VERSION ) { tdb . execSQL ( DATABASE_DROP ) ; 
private ContentValues buildNewEntryContent ( PwEntry entry ) { tContentValues cv = new ContentValues ( ) ; tUUID uuid = entry . getUUID ( ) ; tString uuidStr = uuid . toString ( ) ; tcv . put ( KEY_UUID , uuidStr ) ; tcv . put ( KEY_TITLE , entry . getTitle ( ) ) ; tcv . put ( KEY_URL , entry . getUrl ( ) ) ; tcv . put ( KEY_USERNAME , entry . getUsername ( ) ) ; tcv . put ( KEY_COMMENT , entry . getNotes ( ) ) ; treturn cv ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { }} 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { tpostHeader = new byte [ size ] ; tSystem . arraycopy ( buf , offset , postHeader , 0 , size ) ; } 
public void copyHeader ( PwDbHeaderV3 header ) { tdbHeader = header ; } 
public static Importer createImporter ( InputStream is , boolean debug ) throws InvalidDBSignatureException , IOException { tint sig1 = LEDataInputStream . readInt ( is ) ; tint sig2 = LEDataInputStream . readInt ( is ) ; tif ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { tif ( debug ) { treturn new ImporterV3Debug ( ) ; } treturn new ImporterV3 ( ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV4 ( ) ; } tthrow new InvalidDBSignatureException ( ) ; 
tprotected PwDatabaseV3 createDB ( ) { treturn new PwDatabaseV3 ( ) ; } 
tprotected PwDatabaseV3Debug createDB ( ) { treturn new PwDatabaseV3Debug ( ) ; } 
public PwDatabaseV3Debug openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { treturn ( PwDatabaseV3Debug ) super . openDatabase ( inStream , password , keyfile , status ) ; } 
tprotected void setIVs ( PwDatabaseV3 db , PwDbHeaderV3 header ) throws PwDbOutputException { tSecureRandom random ; ttry { trandom = SecureRandom . getInstance ( " SHA1PRNG " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new PwDbOutputException ( " Does not support secure random number generation. " ) ; } trandom . nextBytes ( header . encryptionIV ) ; trandom . nextBytes ( header . masterSeed ) ; trandom . nextBytes ( header . transformSeed ) ; } 
tprotected void setIVs ( PwDatabaseV3 db , PwDbHeaderV3 header ) tthrows PwDbOutputException { tPwDatabaseV3Debug debugDb = ( PwDatabaseV3Debug ) db ; } 
public static PwDatabaseV3Debug GetTest1 ( Context ctx ) throws Exception { tif ( mDb1 = = null ) { tGetDb1 ( ctx ) ; } treturn ( PwDatabaseV3Debug ) mDb1 . pm ; } 
public void testPlainContent ( ) throws IOException , PwDbOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV3Output pos = new PwDbV3OutputDebug ( mPM , bos ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . toByteArray ( ) ) ; 
public void testChecksum ( ) throws NoSuchAlgorithmException , IOException , PwDbOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwDbV3Output pos = new PwDbV3OutputDebug(mPM, dos); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
public void testHeader ( ) throws PwDbOutputException , IOException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual ) ; PwDbHeaderV3 header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutputV3 outExpected = new PwDbHeaderOutputV3 ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . toByteArray ( ) , bActual . toByteArray ( ) ) ; } 
public void testFinalKey ( ) throws PwDbOutputException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void testFullWrite ( ) throws IOException , PwDbOutputException { tAssetManager am = getContext ( ) . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
tprotected void fillData ( ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_created , getDateTime ( mEntry . getCreate ( ) ) ) ; tpopulateText ( R . id . entry_modified , getDateTime ( mEntry . getMod ( ) ) ) ; tpopulateText ( R . id . entry_accessed , getDateTime ( mEntry . getAccess ( ) ) ) ; tDate expires = mEntry . getExpire ( ) ; tif ( mEntry . expires ( ) ) { tpopulateText ( R . id . entry_expires , getDateTime ( expires ) ) ; } else { tpopulateText ( R . id . entry_expires , R . string . never ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
private ContentValues buildNewEntryContent ( PwEntry entry ) { tContentValues cv = new ContentValues ( ) ; tUUID uuid = entry . getUUID ( ) ; tString uuidStr = uuid . toString ( ) ; tcv . put ( KEY_UUID , uuidStr ) ; tcv . put ( KEY_TITLE , entry . getTitle ( ) ) ; tcv . put ( KEY_URL , entry . getUrl ( ) ) ; tcv . put ( KEY_USERNAME , entry . getUsername ( ) ) ; tcv . put ( KEY_BACKUP , tentry . getParent ( ) . getParent ( ) . getParent ( ) = = null ? entry . getParent ( ) . getName ( ) . compareToIgnoreCase ( " Backup " ) = = 0 : false ) ; } 
public PwGroup search ( Database db , String qStr ) { tCursor cursor ; tString queryWithWildCard = addWildCard ( qStr ) ; tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( mCtx ) ; tboolean isOmitPassword = prefs . getBoolean ( mCtx . getString ( R . string . omitbackup_key ) , mCtx . getResources ( ) . getBoolean ( R . bool . omitbackup_default ) ) ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " + ( isOmitPassword ? " AND " + KEY_BACKUP + " = 0 " : " " ) , new String [ ] { queryWithWildCard } , null , null , null , null ) ; tPwGroup group ; tif ( db . pm instanceof PwDatabaseV3 ) { tgroup = new PwGroupV3 ( ) ; } else if ( db . pm instanceof PwDatabaseV4 ) { tgroup = new PwGroupV4 ( ) ; } else { tLog . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; treturn null ; } tgroup . name = " Search results " ; tgroup . childEntries = new ArrayList < PwEntry > ( ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntry entry = ( PwEntry ) db . entries . get ( uuid ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
tprotected PwDatabaseV4 createDB ( ) { treturn new PwDatabaseV4 ( ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; theader . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
tprotected PwDatabaseV4Debug createDB ( ) { treturn new PwDatabaseV4Debug ( ) ; } 
public PwDatabaseV4Debug openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { treturn ( PwDatabaseV4Debug ) super . openDatabase ( inStream , password , keyfile , status ) ; } 
public abstract void output ( ) throws PwDbOutputException ; public abstract PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException ; } 
public abstract PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException ; } 
public void output ( ) throws PwDbOutputException { tprepForOutput ( ) ; tPwDbHeader header = outputHeader ( mOS ) ; tbyte [ ] finalKey = getFinalKey ( header ) ; tCipher cipher ; ttry { tif ( mPM . algorithm = = PwEncryptionAlgorithm . Rjindal ) { tcipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; } else if ( mPM . algorithm = = PwEncryptionAlgorithm . Twofish ) { tcipher = CipherFactory . getInstance ( " TWOFISH/CBC/PKCS7PADDING " ) ; } else { tthrow new Exception ( ) ; } } catch ( Exception e ) { tthrow new PwDbOutputException ( " Algorithm not supported. " ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
private void prepForOutput ( ) { } 
public void output ( ) throws PwDbOutputException { toutputHeader ( mOS ) ; 
public PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException { } 
public int available ( ) throws IOException { treturn is . available ( ) ; } 
public void close ( ) throws IOException { tis . close ( ) ; tos . close ( ) ; } 
public boolean markSupported ( ) { treturn is . markSupported ( ) ; } 
public int read ( ) throws IOException { tint data = is . read ( ) ; tif ( data ! = - 1 ) { tos . write ( data ) ; } treturn data ; } 
public int read ( byte [ ] b , int offset , int length ) throws IOException { tint len = is . read ( b , offset , length ) ; tif ( len ! = - 1 ) { tos . write ( b , offset , len ) ; } treturn len ; } 
public int read ( byte [ ] b ) throws IOException { tint len = is . read ( b ) ; tif ( len ! = - 1 ) { tos . write ( b , 0 , len ) ; } treturn len ; } 
public synchronized void reset ( ) throws IOException { tis . reset ( ) ; } 
public long skip ( long byteCount ) throws IOException { treturn is . skip ( byteCount ) ; } 
private int ReadInt ( XmlPullParser xpp , int def ) throws IOException , XmlPullParserException { tString str = ReadString ( xpp ) ; tint u ; ttry { tu = Integer . parseInt ( str ) ; } catch ( NumberFormatException e ) { tu = def ; } treturn u ; } 
private byte [ ] ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tString ref = xpp . getAttributeValue ( null , AttrRef ) ; tif ( ref ! = null ) { txpp . next ( ) ; } 
public void buildSearchIndex ( Context ctx ) { tsearchHelper = new SearchDbHelper ( ctx ) ; tinitSearch ( ) ; tsearchHelper . open ( ) ; tsearchHelper . insertEntry ( pm , pm . getEntries ( ) ) ; tsearchHelper . close ( ) ; tindexBuilt = true ; } 
public void clear ( ) { tinitSearch ( ) ; tgroups . clear ( ) ; tentries . clear ( ) ; tdirty . clear ( ) ; tdrawFactory . clear ( ) ; troot = null ; tpm = null ; tmFilename = null ; tloaded = false ; } 
public void initSearch ( ) { tindexBuilt = false ; tif ( searchHelper ! = null ) { tsearchHelper . open ( ) ; 
public abstract PwGroup createGroup ( ) ; public abstract boolean isBackup ( PwGroup group ) ; } 
public boolean isBackup ( PwGroup group ) { tPwGroupV3 g = ( PwGroupV3 ) group ; twhile ( g ! = null ) { tif ( g . level = = 0 & & g . name . equalsIgnoreCase ( " Backup " ) ) { treturn true ; } tg = g . parent ; } treturn false ; } 
public boolean isBackup ( PwGroup group ) { tif ( ! recycleBinEnabled ) { treturn false ; } tPwGroupV4 g = ( PwGroupV4 ) group ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
private void initOmitBackup ( ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( mCtx ) ; tisOmitBackup = prefs . getBoolean ( mCtx . getString ( R . string . omitbackup_key ) , mCtx . getResources ( ) . getBoolean ( R . bool . omitbackup_default ) ) ; 
public void clear ( ) { tmDb . delete ( SEARCH_TABLE , null , null ) ; tinitOmitBackup ( ) ; } 
private ContentValues buildNewEntryContent ( PwDatabase db , PwEntry entry ) { tContentValues cv = new ContentValues ( ) ; tUUID uuid = entry . getUUID ( ) ; tString uuidStr = uuid . toString ( ) ; tcv . put ( KEY_UUID , uuidStr ) ; tcv . put ( KEY_TITLE , entry . getTitle ( ) ) ; tcv . put ( KEY_URL , entry . getUrl ( ) ) ; tcv . put ( KEY_USERNAME , entry . getUsername ( ) ) ; tcv . put ( KEY_COMMENT , entry . getNotes ( ) ) ; treturn cv ; } 
public void insertEntry ( PwDatabase db , List < ? extends PwEntry > entries ) { tmDb . beginTransaction ( ) ; ttry { tfor ( int i = 0 ; i < entries . size ( ) ; i + + ) { 
public void updateEntry ( PwDatabase db , PwEntry entry ) { tContentValues cv = buildNewEntryContent ( db , entry ) ; tString uuidStr = cv . getAsString ( KEY_UUID ) ; tmDb . update ( SEARCH_TABLE , cv , KEY_UUID + " = ? " , new String [ ] { uuidStr } ) ; } 
public PwGroup search ( Database db , String qStr ) { tCursor cursor ; tString queryWithWildCard = addWildCard ( qStr ) ; tcursor = mDb . query ( true , SEARCH_TABLE , new String [ ] { KEY_UUID } , SEARCH_TABLE + " match ? " , tnew String [ ] { queryWithWildCard } , null , null , null , null ) ; tPwGroup group ; tif ( db . pm instanceof PwDatabaseV3 ) { tgroup = new PwGroupV3 ( ) ; } else if ( db . pm instanceof PwDatabaseV4 ) { tgroup = new PwGroupV4 ( ) ; } else { tLog . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; treturn null ; } tgroup . name = " Search results " ; tgroup . childEntries = new ArrayList < PwEntry > ( ) ; tcursor . moveToFirst ( ) ; twhile ( ! cursor . isAfterLast ( ) ) { tString sUUID = cursor . getString ( 0 ) ; tUUID uuid = UUID . fromString ( sUUID ) ; tLog . d ( " TAG " , uuid . toString ( ) ) ; tPwEntry entry = ( PwEntry ) db . entries . get ( uuid ) ; tgroup . childEntries . add ( entry ) ; tcursor . moveToNext ( ) ; } tcursor . close ( ) ; treturn group ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tApp . getDB ( ) . initSearch ( ) ; treturn true ; } 
public void testSearch ( ) { tmDb . indexBuilt = false ; tmDb . buildSearchIndex ( getContext ( ) ) ; tPwGroup results = mDb . Search ( " Amazon " ) ; tassertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; 
public void testBackupIncluded ( ) { tupdateOmitSetting ( false ) ; tmDb . indexBuilt = false ; tmDb . buildSearchIndex ( getContext ( ) ) ; tPwGroup results = mDb . Search ( " BackupOnly " ) ; tassertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; } 
public void testBackupExcluded ( ) { tupdateOmitSetting ( true ) ; tmDb . indexBuilt = false ; tmDb . buildSearchIndex ( getContext ( ) ) ; tPwGroup results = mDb . Search ( " BackupOnly " ) ; tassertFalse ( " Search result found, but should not have been. " , results . childEntries . size ( ) > 0 ) ; } 
private void updateOmitSetting ( boolean setting ) { tContext ctx = getContext ( ) ; tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tSharedPreferences . Editor editor = prefs . edit ( ) ; teditor . putBoolean ( ctx . getString ( R . string . omitbackup_key ) , setting ) ; teditor . commit ( ) ; 
public void loadFromFile ( InputStream is ) throws IOException , InvalidDBVersionException { tLEDataInputStream dis = new LEDataInputStream ( is ) ; tint sig1 = dis . readInt ( ) ; tint sig2 = dis . readInt ( ) ; tif ( ! matchesHeader ( sig1 , sig2 ) ) { tthrow new InvalidDBVersionException ( ) ; } tlong version = dis . readUInt ( ) ; tif ( ! validVersion ( version ) ) { tthrow new InvalidDBVersionException ( ) ; } tboolean done = false ; twhile ( ! done ) { tdone = readHeaderField ( dis ) ; 
private boolean readHeaderField ( LEDataInputStream dis ) throws IOException { tbyte fieldID = ( byte ) dis . read ( ) ; tint fieldSize = dis . readShort ( ) ; tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = dis . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : ttransformSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tsetTransformRounds ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tencryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . ProtectedStreamKey : tprotectedStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tstreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tsetRandomStreamID ( fieldData ) ; tbreak ; tdefault : tthrow new IOException ( " Invalid header type. " ) ; } treturn false ; } 
tvoid readEntryField ( PwDatabaseV3 db , PwEntryV3 ent , byte [ ] buf , int offset ) tthrows UnsupportedEncodingException { tint fieldType = LEDataInputStream . readShort ( buf , offset ) ; toffset + = 2 ; tint fieldSize = LEDataInputStream . readInt ( buf , offset ) ; toffset + = 4 ; tswitch ( fieldType ) { tcase 0x0000 : 
public static int readShort ( InputStream is ) throws IOException { byte [ ] buf = new byte [ 2 ] ; is . read ( buf , 0 , 2 ) ; return readShort ( buf , 0 ) ; } 
public int readShort ( ) throws IOException { treturn readShort ( baseStream ) ; } 
 public static int readShort ( byte [ ] buf , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) ; } 
public void testReadWriteShortOne ( ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; torig [ 0 ] = 0 ; torig [ 1 ] = 1 ; tint one = LEDataInputStream . readShort ( orig , 0 ) ; tdest = Types . writeShort ( one ) ; tassertArrayEquals ( orig , dest ) ; 
private void testReadWriteShort ( byte value ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; tsetArray ( orig , value , 0 , 2 ) ; tint one = LEDataInputStream . readShort ( orig , 0 ) ; tTypes . writeShort ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
public boolean matchesVersion ( ) { treturn compatibleHeaders ( version , DBVER_DW ) ; } 
public static boolean compatibleHeaders ( int one , int two ) { treturn ( one & 0xFFFFFF00 ) = = ( two & 0xFFFFFF00 ) ; } 
private void assertHeadersEquals ( PwDbHeaderV3 expected , PwDbHeaderV3 actual ) { assertEquals ( " Flags unequal " , expected . flags , actual . flags ) ; assertEquals ( " Entries unequal " , expected . numEntries , actual . numEntries ) ; assertEquals ( " Groups unequal " , expected . numGroups , actual . numGroups ) ; assertEquals ( " Key Rounds unequal " , expected . numKeyEncRounds , actual . numKeyEncRounds ) ; assertEquals ( " Signature1 unequal " , expected . signature1 , actual . signature1 ) ; assertEquals ( " Signature2 unequal " , expected . signature2 , actual . signature2 ) ; assertTrue ( " Version incompatible " , PwDbHeaderV3 . compatibleHeaders ( expected . version , actual . version ) ) ; assertArrayEquals ( " Hash unequal " , expected . contentsHash , actual . contentsHash ) ; assertArrayEquals ( " IV unequal " , expected . encryptionIV , actual . encryptionIV ) ; assertArrayEquals ( " Seed unequal " , expected . masterSeed , actual . masterSeed ) ; assertArrayEquals ( " Seed2 unequal " , expected . transformSeed , actual . transformSeed ) ; } 
private void retrieveSettings ( ) { tString defaultFilename = prefs . getString ( KEY_DEFAULT_FILENAME , " " ) ; tif ( mFileName . length ( ) > 0 & & mFileName . equals ( defaultFilename ) ) { tCheckBox checkbox = ( CheckBox ) findViewById ( R . id . default_database ) ; 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( Intents . TIMEOUT ) ) { tsetEditText ( R . id . password , " " ) ; 
tprotected void onDestroy ( ) { tunregisterReceiver ( mIntentReceiver ) ; tsuper . onDestroy ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public PwGroup Search ( String str ) { tPwGroup group = searchHelper . search ( this , str ) ; treturn group ; 
public void clear ( ) { tgroups . clear ( ) ; tentries . clear ( ) ; tdirty . clear ( ) ; tdrawFactory . clear ( ) ; troot = null ; tpm = null ; tmFilename = null ; tloaded = false ; } 
public abstract String getDisplayTitle ( ) ; public boolean isMetaStream ( ) { treturn false ; } public EntrySearchStringIterator stringIterator ( ) { treturn EntrySearchStringIterator . getInstance ( this ) ; } } 
public EntrySearchStringIterator stringIterator ( ) { treturn EntrySearchStringIterator . getInstance ( this ) ; } 
public void run ( ) { tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { tif ( mSuccess ) { 
public abstract boolean hasNext ( ) ; @Override public abstract String next ( ) ; @Override public void remove ( ) { tthrow new UnsupportedOperationException ( " This iterator cannot be used to remove strings. " ) ; } } 
public abstract String next ( ) ; @Override public void remove ( ) { tthrow new UnsupportedOperationException ( " This iterator cannot be used to remove strings. " ) ; } } 
public void remove ( ) { tthrow new UnsupportedOperationException ( " This iterator cannot be used to remove strings. " ) ; 
public String next ( ) { } 
public String next ( ) { tif ( current = = null ) { tthrow new NoSuchElementException ( " Past the end of the list. " ) ; } tString next = current ; tadvance ( ) ; treturn next ; } 
public void testDelete ( ) { tDatabase db ; tContext ctx = getContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwDatabaseV3 pm = ( PwDatabaseV3 ) db . pm ; tPwGroup group1 = getGroup ( pm , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
public void testBackupIncluded ( ) { tupdateOmitSetting ( false ) ; tPwGroup results = mDb . Search ( " BackupOnly " ) ; tassertTrue ( " Search result not found. " , results . childEntries . size ( ) > 0 ) ; } 
public void testBackupExcluded ( ) { tupdateOmitSetting ( true ) ; tPwGroup results = mDb . Search ( " BackupOnly " ) ; tassertFalse ( " Search result found, but should not have been. " , results . childEntries . size ( ) > 0 ) ; } 
public String next ( ) { } 
private boolean omitBackup ( ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( mCtx ) ; treturn prefs . getBoolean ( mCtx . getString ( R . string . omitbackup_key ) , mCtx . getResources ( ) . getBoolean ( R . bool . omitbackup_default ) ) ; 
private boolean isMarketInstalled ( ) { tIntent intent = new Intent ( ) ; tintent . setAction ( Intent . ACTION_VIEW ) ; tintent . setData ( Uri . parse ( " market:} 
public Object clone ( ) { tPwEntryV3 newEntry = ( PwEntryV3 ) super . clone ( ) ; tif ( password ! = null ) { tint passLen = password . length ; tpassword = new byte [ passLen ] ; tSystem . arraycopy ( password , 0 , newEntry . password , 0 , passLen ) ; } tnewEntry . tCreation = ( PwDate ) tCreation . clone ( ) ; tnewEntry . tLastMod = ( PwDate ) tLastMod . clone ( ) ; tnewEntry . tLastAccess = ( PwDate ) tLastAccess . clone ( ) ; tnewEntry . tExpire = ( PwDate ) tExpire . clone ( ) ; tnewEntry . binaryDesc = binaryDesc ; tif ( binaryData ! = null ) { tint descLen = binaryData . length ; tnewEntry . binaryData = new byte [ descLen ] ; tSystem . arraycopy ( binaryData , 0 , newEntry . binaryData , 0 , descLen ) ; } tnewEntry . parent = parent ; treturn newEntry ; } 
private static void initBlank ( Resources res ) { tif ( blank = = null ) { tblank = res . getDrawable ( R . drawable . ic99_blank ) ; 
private Bitmap resize ( Bitmap bitmap ) { tint width = bitmap . getWidth ( ) ; tint height = bitmap . getHeight ( ) ; tif ( width = = blankWidth & & height = = blankHeight ) { treturn bitmap ; } treturn Bitmap . createScaledBitmap ( bitmap , blankWidth , blankHeight , true ) ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { }} 
public void copyHeader ( PwDbHeaderV3 header ) { }} 
public void SaveData ( String filename ) throws IOException , PwDbOutputException { tFile tempFile = new File ( filename + " .tmp " ) ; tFileOutputStream fos = new FileOutputStream ( tempFile ) ; 
public void output ( ) throws IOException { tlos . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; tlos . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; tlos . writeUInt ( PwDbHeaderV4 . FILE_VERSION_32 ) ; 
private void writeHeaderField ( byte fieldId , byte [ ] pbData ) throws IOException { 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random ; ttry { trandom = SecureRandom . getInstance ( " SHA1PRNG " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new PwDbOutputException ( " Does not support secure random number generation. " ) ; } trandom . nextBytes ( header . encryptionIV ) ; trandom . nextBytes ( header . masterSeed ) ; trandom . nextBytes ( header . transformSeed ) ; treturn random ; } 
tprotected SecureRandom setIVs ( PwDbHeader h ) throws PwDbOutputException { tPwDbHeaderV3 header = ( PwDbHeaderV3 ) h ; } 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random = super . setIVs ( header ) ; tPwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; trandom . nextBytes ( h . protectedStreamKey ) ; treturn random ; } 
public PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException { tPwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; tsetIVs ( header ) ; treturn null ; } 
private boolean readHeaderField ( LEDataInputStream dis ) throws IOException { tbyte fieldID = ( byte ) dis . read ( ) ; tint fieldSize = dis . readUShort ( ) ; tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = dis . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : ttransformSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tsetTransformRounds ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tencryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . ProtectedStreamKey : tprotectedStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tstreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tsetRandomStreamID ( fieldData ) ; tbreak ; tdefault : tthrow new IOException ( " Invalid header type. " ) ; } treturn false ; } 
tvoid readEntryField ( PwDatabaseV3 db , PwEntryV3 ent , byte [ ] buf , int offset ) tthrows UnsupportedEncodingException { tint fieldType = LEDataInputStream . readUShort ( buf , offset ) ; toffset + = 2 ; tint fieldSize = LEDataInputStream . readInt ( buf , offset ) ; toffset + = 4 ; tswitch ( fieldType ) { tcase 0x0000 : 
public static int readUShort ( InputStream is ) throws IOException { byte [ ] buf = new byte [ 2 ] ; is . read ( buf , 0 , 2 ) ; return readUShort ( buf , 0 ) ; } 
public int readUShort ( ) throws IOException { treturn readUShort ( baseStream ) ; } 
 public static int readUShort ( byte [ ] buf , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) ; } 
public void testReadWriteShortOne ( ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; torig [ 0 ] = 0 ; torig [ 1 ] = 1 ; tint one = LEDataInputStream . readUShort ( orig , 0 ) ; tdest = Types . writeShort ( one ) ; tassertArrayEquals ( orig , dest ) ; 
private void testReadWriteShort ( byte value ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; tsetArray ( orig , value , 0 , 2 ) ; tint one = LEDataInputStream . readUShort ( orig , 0 ) ; tTypes . writeShort ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
public void output ( ) throws IOException { } 
public void writeUShort ( int val ) throws IOException { tbyte [ ] buf = new byte [ 2 ] ; twriteUShort ( val , buf , 0 ) ; tbaseStream . write ( buf ) ; } 
public static byte [ ] writeUShortBuf ( int val ) { byte [ ] buf = new byte [ 2 ] ; writeUShort ( val , buf , 0 ) ; return buf ; } 
 public static void writeUShort ( int val , byte [ ] buf , int offset ) { buf [ offset + 0 ] = ( byte ) ( val & 0x00FF ) ; buf [ offset + 1 ] = ( byte ) ( ( val & 0xFF00 ) > > 8 ) ; } 
public void testReadWriteShortOne ( ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; torig [ 0 ] = 0 ; torig [ 1 ] = 1 ; tint one = LEDataInputStream . readUShort ( orig , 0 ) ; tdest = LEDataOutputStream . writeUShortBuf ( one ) ; tassertArrayEquals ( orig , dest ) ; 
private void testReadWriteShort ( byte value ) { tbyte [ ] orig = new byte [ 2 ] ; tbyte [ ] dest = new byte [ 2 ] ; tsetArray ( orig , value , 0 , 2 ) ; tint one = LEDataInputStream . readUShort ( orig , 0 ) ; tLEDataOutputStream . writeUShort ( one , dest , 0 ) ; tassertArrayEquals ( orig , dest ) ; 
public void output ( ) throws IOException { tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature1 ) ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature2 ) ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . flags ) ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . version ) ) ; tmOS . write ( mHeader . masterSeed ) ; tmOS . write ( mHeader . encryptionIV ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numGroups ) ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numEntries ) ) ; tmOS . write ( mHeader . contentsHash ) ; tmOS . write ( mHeader . transformSeed ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numKeyEncRounds ) ) ; 
public void output ( ) throws IOException { tlos . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; tlos . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; tlos . writeUInt ( PwDbHeaderV4 . FILE_VERSION_32 ) ; twriteHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . transformSeed ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; twriteHeaderField ( PwDbHeaderV4Fields . ProtectedStreamKey , header . protectedStreamKey ) ; twriteHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; twriteHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; } 
private void writeHeaderField ( byte fieldId , byte [ ] pbData ) throws IOException { los.writeUShort(pbData.length); 
public void output ( ) throws PwDbOutputException { toutputHeader ( mOS ) ; } 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random = super . setIVs ( header ) ; tPwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; trandom . nextBytes ( h . protectedStreamKey ) ; th . innerRandomStream = CrsAlgorithm . Salsa20 ; trandomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . protectedStreamKey ) ; trandom . nextBytes ( h . streamStartBytes ) ; treturn random ; } 
public PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException { tPwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; tsetIVs ( header ) ; tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; ttry { tpho . output ( ) ; } catch ( IOException e ) { tthrow new PwDbOutputException ( " Failed to output the header. " ) ; } treturn header ; } 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
private int writeByteArray ( byte [ ] data ) throws IOException { tint dataLen ; tif ( data ! = null ) { tdataLen = data . length ; } else { tdataLen = 0 ; } tmOS . write ( BINARY_DATA_FIELD_TYPE ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( dataLen ) ) ; tif ( data ! = null ) { tmOS . write ( data ) ; } treturn dataLen ; 
public void output ( ) throws IOException { } 
public void writeUInt ( long uint ) throws IOException { tbaseStream . write ( LEDataOutputStream . writeIntBuf ( ( int ) uint ) ) ; } 
public static byte [ ] writeIntBuf ( int val ) { byte [ ] buf = new byte [ 4 ] ; writeInt ( val , buf , 0 ) ; return buf ; } 
 public static byte [ ] writeLongBuf ( long val ) { byte [ ] buf = new byte [ 8 ] ; writeLong ( val , buf , 0 ) ; return buf ; } 
public static int writeCString ( String str , OutputStream os ) throws IOException { if ( str = = null ) { return length; } 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate ; ttry { tutcDate = dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { tutcDate = new Date ( 0 L ) ; } treturn utcDate ; 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void output ( ) throws IOException { } 
private boolean isMarketInstalled ( ) { tPackageManager pm = getContext ( ) . getPackageManager ( ) ; ttry { tpm . getPackageInfo ( " com.android.vending " , 0 ) ; } catch ( NameNotFoundException e ) { treturn false ; } treturn true ; 
public void populateBlankFields ( PwDatabaseV3 db ) { tif ( icon = = null ) { ticon = db . iconFactory . getIcon ( 1 ) ; } tif ( username = = null ) { tusername = " " ; } tif ( password = = null ) { tpassword = new byte [ 0 ] ; } tif ( uuid = = null ) { tuuid = Types . UUIDtoBytes ( UUID . randomUUID ( ) ) ; } tif ( title = = null ) { ttitle = " " ; } tif ( url = = null ) { turl = " " ; } tif ( additional = = null ) { tadditional = " " ; } tif ( tCreation = = null ) { ttCreation = DEFAULT_PWDATE ; } tif ( tLastMod = = null ) { ttLastMod = DEFAULT_PWDATE ; } tif ( tLastAccess = = null ) { ttLastAccess = DEFAULT_PWDATE ; } tif ( tExpire = = null ) { ttExpire = PW_NEVER_EXPIRE ; } tif ( binaryDesc = = null ) { tbinaryDesc = " " ; } tif ( binaryData = = null ) { tbinaryData = new byte [ 0 ] ; 
public void populateBlankFields ( PwDatabaseV3 db ) { tif ( icon = = null ) { ticon = db . iconFactory . getIcon ( 1 ) ; } tif ( name = = null ) { tname = " " ; } tif ( tCreation = = null ) { ttCreation = PwEntryV3 . DEFAULT_PWDATE ; } tif ( tLastMod = = null ) { ttLastMod = PwEntryV3 . DEFAULT_PWDATE ; } tif ( tLastAccess = = null ) { ttLastAccess = PwEntryV3 . DEFAULT_PWDATE ; } tif ( tExpire = = null ) { ttExpire = PwEntryV3 . DEFAULT_PWDATE ; 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void output ( ) throws IOException { } 
public static boolean isNullOrEmpty ( String str ) { treturn ( str = = null ) | | str . isEmpty ( ) ; } 
public static boolean isNullOrEmpty ( byte [ ] buf ) { treturn ( buf = = null ) | | ( buf . length = = 0 ) ; } 
public static boolean isNullOrEmpty ( PwDate date ) { treturn ( date = = null ) | | date . equals ( PwEntryV3 . DEFAULT_PWDATE ) ; } 
public static Date readTime ( byte [ ] buf , int offset , Calendar time ) { tint dw1 = Types . readUByte ( buf , offset ) ; tint dw2 = Types . readUByte ( buf , offset + 1 ) ; tint dw3 = Types . readUByte ( buf , offset + 2 ) ; tint dw4 = Types . readUByte ( buf , offset + 3 ) ; tint dw5 = Types . readUByte ( buf , offset + 4 ) ; return time.getTime(); 
public static byte [ ] writeTime ( Date date ) { treturn writeTime ( date , null ) ; } 
public static byte [ ] writeTime ( Date date , Calendar cal ) { tif ( date = = null ) { treturn null ; } tbyte [ ] buf = new byte [ 5 ] ; tif ( cal = = null ) { tcal = Calendar . getInstance ( ) ; } tcal . setTime ( date ) ; tint year = cal . get ( Calendar . YEAR ) ; } 
public static boolean IsSameDate ( Date d1 , Date d2 ) { tCalendar cal1 = Calendar . getInstance ( ) ; tcal1 . setTime ( d1 ) ; tcal1 . set ( Calendar . MILLISECOND , 0 ) ; tCalendar cal2 = Calendar . getInstance ( ) ; tcal2 . setTime ( d2 ) ; tcal2 . set ( Calendar . MILLISECOND , 0 ) ; treturn ( cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) ) & & ( cal1 . get ( Calendar . MONTH ) = = cal2 . get ( Calendar . MONTH ) ) & & 
public static boolean IsNever ( Date date ) { treturn PwDate . IsSameDate ( NEVER_EXPIRE , date ) ; } 
public void output ( ) throws IOException { toutputBytes + = 134 ; } 
public void output ( ) throws IOException { } 
public static boolean isNullOrEmpty ( String str ) { treturn ( str = = null ) | | ( str . length ( ) = = 0 ) ; } 
public void testCreation ( ) { tCalendar cal = Calendar . getInstance ( ) ; tcal . setTime ( mPE . tCreation . getJDate ( ) ) ; tassertEquals ( " Incorrect year. " , cal . get ( Calendar . YEAR ) , 2009 ) ; tassertEquals ( " Incorrect month. " , cal . get ( Calendar . MONTH ) , 3 ) ; tassertEquals ( " Incorrect day. " , cal . get ( Calendar . DAY_OF_MONTH ) , 24 ) ; } 
tprotected void onDestroy ( ) { tif ( mIntentReceiver ! = null ) { tunregisterReceiver ( mIntentReceiver ) ; } tsuper . onDestroy ( ) ; } 
Object getKey ( ) ; Object getValue ( ) ; } 
boolean hasNext ( ) ; Object setValue(Object value);} 
Object next ( ) ; ----------------------------------------------------------------------- Object setValue(Object value);} 
Object getKey ( ) ; Object setValue(Object value);} 
Object getValue ( ) ; ----------------------------------------------------------------------- Object setValue(Object value);} 
void remove ( ) ; Object setValue ( Object value ) ; } 
public Object next ( ) { throw new NoSuchElementException ( " Iterator contains no elements " ) ; } 
public Object previous ( ) { throw new NoSuchElementException ( " Iterator contains no elements " ) ; } 
public void add ( Object obj ) { throw new UnsupportedOperationException ( " add() not supported for empty Iterator " ) ; } 
public void set ( Object obj ) { throw new IllegalStateException ( " Iterator contains no elements " ) ; } 
public void remove ( ) { throw new IllegalStateException ( " Iterator contains no elements " ) ; } 
public String toString ( ) { return new StringBuffer ( ) . append ( getKey ( ) ) 
public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof Map . Entry = = false ) { return false ; } Map . Entry other = ( Map . Entry ) obj ; return ( getKey ( ) = = null ? other . getKey ( ) = = null : getKey ( ) . equals ( other . getKey ( ) ) ) & & 
public int hashCode ( ) { return ( getKey ( ) = = null ? 0 : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) = = null ? 0 : getValue ( ) . hashCode ( ) ) ; 
public Object get ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; no local for hash index while (entry != null) { if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) { return entry.getValue(); } entry = entry.next; } return null; } 
public boolean containsKey ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; no local for hash index while (entry != null) { if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) { return true; } entry = entry.next; } return false; } 
public Object put ( Object key , Object value ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; updateEntry ( entry , value ) ; return oldValue ; } entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; return null ; } 
public void putAll ( Map map ) { int mapSize = map . size ( ) ; if ( mapSize = = 0 ) { return ; } int newSize = ( int ) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( Iterator it = map . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; 
public Object remove ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; HashEntry previous = null ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ; } return null ; } 
public void clear ( ) { modCount + + ; HashEntry [ ] data = this . data ; for ( int i = data . length - 1 ; i > = 0 ; i - - ) { data [ i ] = null ; } size = 0 ; } 
protected Object convertKey ( Object key ) { return ( key = = null ? NULL : key ) ; } 
protected int hash ( Object key ) { same as JDK 1.4 int h = key.hashCode(); h += ~(h << 9); h ^= (h >>> 14); h += (h << 4); h ^= (h >>> 10); return h; } 
protected boolean isEqualKey ( Object key1 , Object key2 ) { return ( key1 = = key2 | | key1 . equals ( key2 ) ) ; } 
protected boolean isEqualValue ( Object value1 , Object value2 ) { return ( value1 = = value2 | | value1 . equals ( value2 ) ) ; } 
protected int hashIndex ( int hashCode , int dataSize ) { return hashCode & ( dataSize - 1 ) ; } 
protected void updateEntry ( HashEntry entry , Object newValue ) { entry . setValue ( newValue ) ; } 
protected void reuseEntry ( HashEntry entry , int hashIndex , int hashCode , Object key , Object value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; entry . key = key ; entry . value = value ; } 
protected void addMapping ( int hashIndex , int hashCode , Object key , Object value ) { modCount + + ; HashEntry entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size + + ; checkCapacity ( ) ; } 
protected HashEntry createEntry ( HashEntry next , int hashCode , Object key , Object value ) { return new HashEntry ( next , hashCode , key , value ) ; } 
protected void addEntry ( HashEntry entry , int hashIndex ) { data [ hashIndex ] = entry ; } 
protected void removeMapping ( HashEntry entry , int hashIndex , HashEntry previous ) { modCount + + ; removeEntry ( entry , hashIndex , previous ) ; size - - ; destroyEntry ( entry ) ; } 
protected void removeEntry ( HashEntry entry , int hashIndex , HashEntry previous ) { if ( previous = = null ) { data [ hashIndex ] = entry . next ; 
protected void destroyEntry ( HashEntry entry ) { entry . next = null ; entry . key = null ; entry . value = null ; } 
protected void checkCapacity ( ) { if ( size > = threshold ) { int newCapacity = data . length * 2 ; 
protected void ensureCapacity ( int newCapacity ) { int oldCapacity = data . length ; if ( newCapacity < = oldCapacity ) { return ; } if ( size = = 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; 
protected int calculateNewCapacity ( int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { newCapacity < < = 1 ; multiply by two } if (newCapacity > MAXIMUM_CAPACITY) { newCapacity = MAXIMUM_CAPACITY; } } return newCapacity; } 
protected int calculateThreshold ( int newCapacity , float factor ) { return ( int ) ( newCapacity * factor ) ; } 
protected HashEntry entryNext ( HashEntry entry ) { return entry . next ; } 
protected int entryHashCode ( HashEntry entry ) { return entry . hashCode ; } 
protected Object entryKey ( HashEntry entry ) { return entry . key ; } 
protected Object entryValue ( HashEntry entry ) { return entry . value ; } 
public MapIterator mapIterator ( ) { if ( size = = 0 ) { return EmptyMapIterator . INSTANCE ; } return new HashMapIterator ( this ) ; } 
public Object next ( ) { return super . nextEntry ( ) . getKey ( ) ; } 
public Set entrySet ( ) { if ( entrySet = = null ) { entrySet = new EntrySet ( this ) ; } return entrySet ; } 
protected Iterator createEntrySetIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new EntrySetIterator ( this ) ; } 
public int size ( ) { return parent . size ( ) ; } 
public void clear ( ) { parent . clear ( ) ; } 
public boolean contains ( Object entry ) { if ( entry instanceof Map . Entry ) { Map . Entry e = ( Map . Entry ) entry ; Entry match = parent . getEntry ( e . getKey ( ) ) ; return ( match ! = null & & match . equals ( e ) ) ; } return false ; } 
public boolean remove ( Object obj ) { if ( obj instanceof Map . Entry = = false ) { return false ; } if ( contains ( obj ) = = false ) { return false ; } Map . Entry entry = ( Map . Entry ) obj ; Object key = entry . getKey ( ) ; parent . remove ( key ) ; return true ; } 
public Iterator iterator ( ) { return parent . createEntrySetIterator ( ) ; } 
public Object next ( ) { return super . nextEntry ( ) ; } 
public Set keySet ( ) { if ( keySet = = null ) { keySet = new KeySet ( this ) ; } return keySet ; } 
protected Iterator createKeySetIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new KeySetIterator ( this ) ; } 
public boolean contains ( Object key ) { return parent . containsKey ( key ) ; } 
public boolean remove ( Object key ) { boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } 
public Iterator iterator ( ) { return parent . createKeySetIterator ( ) ; } 
public Collection values ( ) { if ( values = = null ) { values = new Values ( this ) ; } return values ; } 
protected Iterator createValuesIterator ( ) { if ( size ( ) = = 0 ) { return EmptyIterator . INSTANCE ; } return new ValuesIterator ( this ) ; } 
public boolean contains ( Object value ) { return parent . containsValue ( value ) ; } 
public Iterator iterator ( ) { return parent . createValuesIterator ( ) ; } 
public Object next ( ) { return super . nextEntry ( ) . getValue ( ) ; } 
public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof Map . Entry = = false ) { return false ; } Map . Entry other = ( Map . Entry ) obj ; return ( getKey ( ) = = null ? other . getKey ( ) = = null : getKey ( ) . equals ( other . getKey ( ) ) ) & & 
public int hashCode ( ) { return ( getKey ( ) = = null ? 0 : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) = = null ? 0 : getValue ( ) . hashCode ( ) ) ; 
public String toString ( ) { return new StringBuffer ( ) . append ( getKey ( ) ) . append ( '=' ) . append ( getValue ( ) ) . toString ( ) ; } 
public boolean hasNext ( ) { return ( next ! = null ) ; } 
protected HashEntry nextEntry ( ) { if ( parent . modCount ! = expectedModCount ) { throw new ConcurrentModificationException ( ) ; } HashEntry newCurrent = next ; if ( newCurrent = = null ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } HashEntry [ ] data = parent . data ; int i = hashIndex ; HashEntry = newCurrent . next ; while ( = = null & & i > 0 ) { = data [ - - i ] ; } next = ; hashIndex = i ; last = newCurrent ; return newCurrent ; } 
protected HashEntry currentEntry ( ) { return last ; } 
public void remove ( ) { if ( last = = null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount ! = expectedModCount ) { throw new ConcurrentModificationException ( ) ; } parent . remove ( last . getKey ( ) ) ; last = null ; expectedModCount = parent . modCount ; } 
public String toString ( ) { if ( last ! = null ) { return " Iterator[ " + last . getKey ( ) + " = " + last . getValue ( ) + " ] " ; 
protected void doWriteObject ( ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; for ( MapIterator it = mapIterator ( ) ; it . hasNext ( ) ; ) { out . writeObject ( it . next ( ) ) ; 
protected void doReadObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat ( ) ; int capacity = in . readInt ( ) ; int size = in . readInt ( ) ; init ( ) ; threshold = calculateThreshold ( capacity , loadFactor ) ; data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i + + ) { Object key = in . readObject ( ) ; 
protected Object clone ( ) { try { AbstractHashedMap cloned = ( AbstractHashedMap ) super . clone ( ) ; 
public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof Map = = false ) { return false ; } Map map = ( Map ) obj ; if ( map . size ( ) ! = size ( ) ) { return false ; } MapIterator it = mapIterator ( ) ; try { while ( it . hasNext ( ) ) { Object key = it . next ( ) ; Object value = it . getValue ( ) ; if ( value = = null ) { if ( map . get ( key ) ! = null | | map . containsKey ( key ) = = false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) = = false ) { return false ; } } } } catch ( ClassCastException ignored ) { return false ; } catch ( NullPointerException ignored ) { return false ; } return true ; } 
public int hashCode ( ) { int total = 0 ; Iterator it = createEntrySetIterator ( ) ; while ( it . hasNext ( ) ) { total + = it . next ( ) . hashCode ( ) ; } return total ; } 
public String toString ( ) { if ( size ( ) = = 0 ) { return " {} " ; } StringBuffer buf = new StringBuffer ( 32 * size ( ) ) ; buf . append ( '{' ) ; MapIterator it = mapIterator ( ) ; boolean hasNext = it . hasNext ( ) ; while ( hasNext ) { Object key = it . next ( ) ; Object value = it . getValue ( ) ; buf . append ( key = = this ? " (this Map) " : key ) . append ( '=' ) . append ( value = = this ? " (this Map) " : value ) ; hasNext = it . hasNext ( ) ; if ( hasNext ) { buf . append ( ',' ) . append ( ' ' ) ; } } buf . append ( '}' ) ; return buf . toString ( ) ; } 
protected void init ( ) { queue = new ReferenceQueue ( ) ; } 
private static void verify ( String name , int type ) { if ( ( type < HARD ) | | ( type > WEAK ) ) { throw new IllegalArgumentException ( name + " must be HARD, SOFT, WEAK. " ) ; 
public int size ( ) { purgeBeforeRead ( ) ; return super . size ( ) ; } 
public boolean isEmpty ( ) { purgeBeforeRead ( ) ; return super . isEmpty ( ) ; } 
public boolean containsKey ( Object key ) { purgeBeforeRead ( ) ; Entry entry = getEntry ( key ) ; if ( entry = = null ) { return false ; } return ( entry . getValue ( ) ! = null ) ; } 
public boolean containsValue ( Object value ) { purgeBeforeRead ( ) ; if ( value = = null ) { return false ; } return super . containsValue ( value ) ; } 
public Object get ( Object key ) { purgeBeforeRead ( ) ; Entry entry = getEntry ( key ) ; if ( entry = = null ) { return null ; } return entry . getValue ( ) ; } 
public Object put ( Object key , Object value ) { if ( key = = null ) { throw new NullPointerException ( " null keys not allowed " ) ; } if ( value = = null ) { throw new NullPointerException ( " null values not allowed " ) ; } purgeBeforeWrite ( ) ; return super . put ( key , value ) ; } 
public Object remove ( Object key ) { if ( key = = null ) { return null ; } purgeBeforeWrite ( ) ; return super . remove ( key ) ; } 
public void clear ( ) { super . clear ( ) ; while ( queue . poll ( ) ! = null ) { } drain the queue } 
public MapIterator mapIterator ( ) { return new ReferenceMapIterator ( this ) ; } 
public Set entrySet ( ) { if ( entrySet = = null ) { entrySet = new ReferenceEntrySet ( this ) ; } return entrySet ; } 
public Set keySet ( ) { if ( keySet = = null ) { keySet = new ReferenceKeySet ( this ) ; } return keySet ; } 
public Collection values ( ) { if ( values = = null ) { values = new ReferenceValues ( this ) ; } return values ; } 
protected void purge ( ) { Reference ref = queue . poll ( ) ; while ( ref ! = null ) { purge ( ref ) ; 
protected void purge ( Reference ref ) { The hashCode of the reference is the hashCode of the mapping key, even if the reference refers to the mapping value... int hash = ref.hashCode(); int index = hashIndex(hash, data.length); HashEntry previous = null; HashEntry entry = data[index]; while (entry != null) { if (((ReferenceEntry) entry).purge(ref)) { 
protected int hashEntry ( Object key , Object value ) { return ( key = = null ? 0 : key . hashCode ( ) ) ^ ( value = = null ? 0 : value . hashCode ( ) ) ; 
protected boolean isEqualKey ( Object key1 , Object key2 ) { key2 = ( keyType > HARD ? ( ( Reference ) key2 ) . get ( ) : key2 ) ; return ( key1 = = key2 | | key1 . equals ( key2 ) ) ; } 
protected HashEntry createEntry ( HashEntry next , int hashCode , Object key , Object value ) { return new ReferenceEntry ( this , next , hashCode , key , value ) ; } 
protected Iterator createEntrySetIterator ( ) { return new ReferenceEntrySetIterator ( this ) ; } 
protected Iterator createKeySetIterator ( ) { return new ReferenceKeySetIterator ( this ) ; } 
protected Iterator createValuesIterator ( ) { return new ReferenceValuesIterator ( this ) ; } 
public Object [ ] toArray ( ) { return toArray ( new Object [ 0 ] ) ; } 
public Object [ ] toArray ( Object [ ] arr ) { special implementation to handle disappearing entries ArrayList list = new ArrayList(); Iterator iterator = iterator(); while (iterator.hasNext()) { Entry e = (Entry) iterator.next(); list.add(new DefaultMapEntry(e.getKey(), e.getValue())); } return list.toArray(arr); } 
public Object [ ] toArray ( Object [ ] arr ) { special implementation to handle disappearing keys List list = new ArrayList(parent.size()); for (Iterator it = iterator(); it.hasNext(); ) { list.add(it.next()); } return list.toArray(arr); } 
public Object [ ] toArray ( Object [ ] arr ) { special implementation to handle disappearing values List list = new ArrayList(parent.size()); for (Iterator it = iterator(); it.hasNext(); ) { list.add(it.next()); } return list.toArray(arr); } 
public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof Map . Entry = = false ) { return false ; } Map . Entry entry = ( Map . Entry ) obj ; Object entryKey = entry . getKey ( ) ; convert to hard reference Object entryValue = entry.getValue(); convert to hard reference if ((entryKey == null) || (entryValue == null)) { return false; } compare using map methods, aiding identity subclass note that key is direct access and value is via method return parent.isEqualKey(entryKey, key) && parent.isEqualValue(entryValue, getValue()); 
public int hashCode ( ) { return parent . hashEntry ( getKey ( ) , getValue ( ) ) ; } 
protected Object toReference ( int type , Object referent , int hash ) { switch ( type ) { case HARD : return referent ; 
boolean purge ( Reference ref ) { boolean r = ( parent . keyType > HARD ) & & ( key = = ref ) ; r = r | | ( ( parent . valueType > HARD ) & & ( value = = ref ) ) ; if ( r ) { if ( parent . keyType > HARD ) { ( ( Reference ) key ) . clear ( ) ; } if ( parent . valueType > HARD ) { ( ( Reference ) value ) . clear ( ) ; } else if ( parent . purgeValues ) { value = null ; } } return r ; } 
protected ReferenceEntry next ( ) { return ( ReferenceEntry ) next ; } 
public boolean hasNext ( ) { checkMod ( ) ; while ( nextNull ( ) ) { ReferenceEntry e = entry ; int i = index ; while ( ( e = = null ) & & ( i > 0 ) ) { i - - ; e = ( ReferenceEntry ) parent . data [ i ] ; } entry = e ; index = i ; if ( e = = null ) { currentKey = null ; currentValue = null ; return false ; } nextKey = e . getKey ( ) ; nextValue = e . getValue ( ) ; if ( nextNull ( ) ) { entry = entry . next ( ) ; } } return true ; } 
private void checkMod ( ) { if ( parent . modCount ! = expectedModCount ) { throw new ConcurrentModificationException ( ) ; 
private boolean nextNull ( ) { return ( nextKey = = null ) | | ( nextValue = = null ) ; } 
protected ReferenceEntry nextEntry ( ) { checkMod ( ) ; if ( nextNull ( ) & & ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } previous = entry ; entry = entry . next ( ) ; currentKey = nextKey ; currentValue = nextValue ; nextKey = null ; nextValue = null ; return previous ; } 
protected ReferenceEntry currentEntry ( ) { checkMod ( ) ; return previous ; } 
public Object next ( ) { return nextEntry ( ) ; } 
public void remove ( ) { checkMod ( ) ; if ( previous = = null ) { throw new IllegalStateException ( ) ; } parent . remove ( currentKey ) ; previous = null ; currentKey = null ; currentValue = null ; expectedModCount = parent . modCount ; } 
public Object next ( ) { return nextEntry ( ) . getKey ( ) ; } 
public Object next ( ) { return nextEntry ( ) . getValue ( ) ; } 
public int hashCode ( ) { return hash ; } 
protected void doWriteObject ( ObjectOutputStream out ) throws IOException { out . writeInt ( keyType ) ; out . writeInt ( valueType ) ; out . writeBoolean ( purgeValues ) ; out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; for ( MapIterator it = mapIterator ( ) ; it . hasNext ( ) ; ) { out . writeObject ( it . next ( ) ) ; out . writeObject ( it . getValue ( ) ) ; } out . writeObject ( null ) ; null terminate map do not call super.doWriteObject() as code there doesn't work for reference map 
protected void doReadObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { this . keyType = in . readInt ( ) ; this . valueType = in . readInt ( ) ; this . purgeValues = in . readBoolean ( ) ; this . loadFactor = in . readFloat ( ) ; int capacity = in . readInt ( ) ; init ( ) ; data = new HashEntry [ capacity ] ; while ( true ) { Object key = in . readObject ( ) ; if ( key = = null ) { break ; } Object value = in . readObject ( ) ; put ( key , value ) ; } threshold = calculateThreshold ( data . length , loadFactor ) ; do not call super.doReadObject() as code there doesn't work for reference map 
private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; doWriteObject ( out ) ; } 
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; doReadObject ( in ) ; } 
private View createGroupView ( int position , View convertView ) { tPwGroup group = groupsForViewing . get ( position ) ; tPwGroupView gv ; tif ( convertView = = null | | ! ( convertView instanceof PwGroupView ) ) { tgv = PwGroupView . getInstance ( mAct , group ) ; } telse { tgv = ( PwGroupView ) convertView ; tgv . convertView ( group ) ; } treturn gv ; } 
private PwEntryView createEntryView ( int position , View convertView ) { tPwEntry entry = entriesForViewing . get ( position ) ; tPwEntryView ev ; tif ( convertView = = null | | ! ( convertView instanceof PwEntryView ) ) { tev = PwEntryView . getInstance ( mAct , entry , position ) ; } telse { tev = ( PwEntryView ) convertView ; tev . convertView ( entry , position ) ; } treturn ev ; } 
private void populateView ( View ev , PwEntry pw , int pos ) { tmPw = pw ; tmPos = pos ; tImageView iv = ( ImageView ) ev . findViewById ( R . id . entry_icon ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , pw . getIcon ( ) ) ; tmTv . setText ( mPw . getDisplayTitle ( ) ) ; } 
public void convertView ( PwEntry pw , int pos ) { tpopulateView ( this , pw , pos ) ; } 
private void populateView ( View gv , PwGroup pw ) { tmPw = pw ; tImageView iv = ( ImageView ) gv . findViewById ( R . id . group_icon ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , pw . getIcon ( ) ) ; tmTv . setText ( pw . getName ( ) ) ; } 
public void convertView ( PwGroup pw ) { tpopulateView ( this , pw ) ; } 
public static void invalidateOptionsMenu ( Activity act ) { tif ( invalidateOptMenu ! = null ) { ttry { 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tmenu . findItem ( R . id . menu_change_master_key ) . setVisible ( false ) ; treturn true ; 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tMenuInflater inflater = getMenuInflater ( ) ; tinflater . inflate ( R . menu . group , menu ) ; treturn true ; } 
private void toggleSort ( ) { 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tMenuInflater inflate = getMenuInflater ( ) ; tinflate . inflate ( R . menu . password , menu ) ; treturn true ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tMenuInflater inflater = getMenuInflater ( ) ; tinflater . inflate ( R . menu . fileselect , menu ) ; treturn true ; } 
public byte [ ] loadFromFile ( InputStream is ) throws IOException , InvalidDBVersionException { tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " No SHA-256 implementation " ) ; } tDigestInputStream dis = new DigestInputStream ( is , md ) ; tLEDataInputStream lis = new LEDataInputStream ( dis ) ; tint sig1 = lis . readInt ( ) ; tint sig2 = lis . readInt ( ) ; tif ( ! matchesHeader ( sig1 , sig2 ) ) { tthrow new InvalidDBVersionException ( ) ; } tlong version = lis . readUInt ( ) ; tif ( ! validVersion ( version ) ) { tthrow new InvalidDBVersionException ( ) ; } tboolean done = false ; twhile ( ! done ) { tdone = readHeaderField ( lis ) ; } treturn md . digest ( ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = new PwDatabaseV4 ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; thashOfHeader = header . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
private void ReadXmlStreamed ( InputStream readerStream ) throws IOException , InvalidDBException { ttry { tReadDocumentStreamed ( CreatePullParser ( readerStream ) ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tTimeoutHelper . checkShutdown ( this ) ; } 
tprotected void onPause ( ) { tsuper . onPause ( ) ; tTimeoutHelper . pause ( this ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; tTimeoutHelper . resume ( this ) ; } 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
public static void pause ( Activity act ) { } 
public static void resume ( Activity act ) { We have timed out 
private void toggleSort ( ) { 
public void onCheckedChanged ( CompoundButton buttonView , tboolean isChecked ) { tString newDefaultFileName ; tif ( isChecked ) { tnewDefaultFileName = mFileName ; } else { tnewDefaultFileName = " " ; } tSharedPreferences . Editor editor = prefs . edit ( ) ; teditor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; tEditorCompat . apply ( editor ) ; tBackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . this ) ; tbackupManager . dataChanged ( ) ; 
public static void apply ( SharedPreferences . Editor edit ) { ttry { tapply . invoke ( edit , ( Object [ ] ) null ) ; 
public static void pause ( Activity act ) { } 
public void onCheckedChanged ( CompoundButton buttonView , tboolean isChecked ) { tTextView password = ( TextView ) findViewById ( R . id . password ) ; tif ( isChecked ) { tpassword . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
public boolean isTan ( ) { treturn getTitle ( ) . equals ( PMS_TAN_ENTRY ) & & ( getUsername ( ) . length ( ) > 0 ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tMenuInflater inflater = getMenuInflater ( ) ; tinflater . inflate ( R . menu . entry_edit , menu ) ; treturn true ; } 
public String generatePassword ( ) { tString password = " " ; ttry { tint length = Integer . valueOf ( ( ( EditText ) findViewById ( R . id . length ) ) . getText ( ) . toString ( ) ) ; ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) ; tPasswordGenerator generator = new PasswordGenerator ( this ) ; tpassword = generator . generatePassword ( length , ( ( CheckBox ) findViewById ( R . id . cb_uppercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_lowercase ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_digits ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_minus ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_underline ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_space ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_specials ) ) . isChecked ( ) , ( ( CheckBox ) findViewById ( R . id . cb_brackets ) ) . isChecked ( ) ) ; } catch ( NumberFormatException e ) { tToast . makeText ( this , R . string . error_wrong_length , Toast . LENGTH_LONG ) . show ( ) ; } catch ( IllegalArgumentException e ) { tToast . makeText ( this , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; } treturn password ; } 
public int hashCode ( ) { tInteger i = Integer . valueOf ( id ) ; treturn i . hashCode ( ) ; } 
private static void buildList ( ) { tif ( icons = = null ) { ticons = new SparseIntArray ( ) ; 
public static int iconToResId ( int iconId ) { tbuildList ( ) ; treturn icons . get ( iconId , R . drawable . ic99_blank ) ; } 
tprotected byte [ ] getFileKey ( String fileName ) tthrows InvalidKeyFileException , IOException { tassert ( fileName ! = null ) ; tFile keyfile = new File ( fileName ) ; tif ( ! keyfile . exists ( ) ) { tthrow new InvalidKeyFileException ( ) ; } tbyte [ ] key = loadXmlKeyFile ( fileName ) ; tif ( key ! = null ) { treturn key ; } tFileInputStream fis ; ttry { tfis = new FileInputStream ( keyfile ) ; } catch ( FileNotFoundException e ) { tthrow new InvalidKeyFileException ( ) ; } tBufferedInputStream bis = new BufferedInputStream ( fis , 64 ) ; tlong fileSize = keyfile . length ( ) ; tif ( fileSize = = 0 ) { tthrow new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { tbyte [ ] outputKey = new byte [ 32 ] ; tif ( bis . read ( outputKey , 0 , 32 ) ! = 32 ) { tthrow new IOException ( " Error reading key. " ) ; } treturn outputKey ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; tbis . mark ( 64 ) ; tif ( bis . read ( hex , 0 , 64 ) ! = 64 ) { tthrow new IOException ( " Error reading key. " ) ; } ttry { treturn hexStringToByteArray ( new String ( hex ) ) ; } catch ( IndexOutOfBoundsException e ) { } 
public void run ( ) { ttry { tmDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; tsaveFileData ( mFileName , mKey ) ; } catch ( ArcFourException e ) { tfinish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; treturn ; } catch ( InvalidPasswordException e ) { tfinish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; treturn ; } catch ( FileNotFoundException e ) { tfinish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; treturn ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( KeyFileEmptyException e ) { tfinish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; treturn ; } catch ( InvalidAlgorithmException e ) { tfinish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; treturn ; } catch ( InvalidKeyFileException e ) { tfinish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; treturn ; } catch ( InvalidDBSignatureException e ) { tfinish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; treturn ; } catch ( InvalidDBVersionException e ) { tfinish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; treturn ; } catch ( InvalidDBException e ) { tfinish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; treturn ; } catch ( OutOfMemoryError e ) { tfinish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; treturn ; } tfinish ( true ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tMenuInflater inflater = getMenuInflater ( ) ; tinflater . inflate ( R . menu . entry_edit , menu ) ; tMenuItem togglePassword = menu . findItem ( R . id . menu_toggle_pass ) ; tif ( mShowPassword ) { ttogglePassword . setTitle ( R . string . menu_hide_password ) ; } else { ttogglePassword . setTitle ( R . string . show_password ) ; } treturn true ; } 
private void fillPassword ( ) { tEditText txtPassword = ( EditText ) findViewById ( R . id . password ) ; ttxtPassword . setText ( generatePassword ( ) ) ; } 
private void performSearch ( String query ) { tquery ( query . trim ( ) ) ; } 
public void output ( ) throws IOException { tlos . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; tlos . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; tlos . writeUInt ( PwDbHeaderV4 . FILE_VERSION_32 ) ; twriteHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . transformSeed ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; twriteHeaderField ( PwDbHeaderV4Fields . ProtectedStreamKey , header . protectedStreamKey ) ; twriteHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; twriteHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; tlos . flush ( ) ; thashOfHeader = dos . getMessageDigest ( ) . digest ( ) ; } 
public void output ( ) throws PwDbOutputException { tPwDbHeaderV4 header = ( PwDbHeaderV4 ) outputHeader ( mOS ) ; tCipherOutputStream cos = attachStreamEncryptor ( header , mOS ) ; ttry { tcos . write ( header . streamStartBytes ) ; 
private void outputDatabase ( PwDbHeaderV4 header , OutputStream os ) { }} 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) throws PwDbOutputException { tCipher cipher ; ttry { tmPM . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) mPM . numKeyEncRounds ) ; tcipher = CipherFactory . getInstance ( mPM . dataCipher , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { tthrow new PwDbOutputException ( " Invalid algorithm. " ) ; } tCipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; treturn cos ; } 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random = super . setIVs ( header ) ; tPwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; trandom . nextBytes ( h . masterSeed ) ; trandom . nextBytes ( h . transformSeed ) ; trandom . nextBytes ( h . encryptionIV ) ; trandom . nextBytes ( h . protectedStreamKey ) ; th . innerRandomStream = CrsAlgorithm . Salsa20 ; trandomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . protectedStreamKey ) ; trandom . nextBytes ( h . streamStartBytes ) ; treturn random ; } 
tprotected PwDatabaseV4 createDB ( ) { treturn new PwDatabaseV4 ( ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; thashOfHeader = header . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate ; ttry { tutcDate = PwDatabaseV4XML . dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { tutcDate = new Date ( 0 L ) ; } treturn utcDate ; 
public void output ( ) throws PwDbOutputException { theader = ( PwDbHeaderV4 ) outputHeader ( mOS ) ; tCipherOutputStream cos = attachStreamEncryptor ( header , mOS ) ; tOutputStream compressed ; ttry { tcos . write ( header . streamStartBytes ) ; tHashedBlockOutputStream hashed = new HashedBlockOutputStream ( cos ) ; tif ( mPM . compressionAlgorithm = = PwCompressionAlgorithm . Gzip ) { tcompressed = new GZIPOutputStream ( hashed ) ; } else { tcompressed = hashed ; } } catch ( IOException e ) { tthrow new PwDbOutputException ( " Failed to set up output stream. " ) ; } ttry { toutputDatabase ( compressed ) ; 
private void outputDatabase ( OutputStream os ) throws IllegalArgumentException , IllegalStateException , IOException { 
private void outputMeta ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemMeta ) ; tWriteObject ( ElemGenerator , mPM . localizedAppName ) ; tif ( hashOfHeader ! = null ) { tWriteObject ( ElemHeaderHash , String . valueOf ( Base64Coder . encode ( hashOfHeader ) ) ) ; } tWriteObject ( ElemDbName , mPM . name , true ) ; tWriteObject ( ElemDbNameChanged , mPM . nameChanged ) ; tWriteObject ( ElemDbDesc , mPM . description , true ) ; tWriteObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; tWriteObject ( ElemDbDefaultUser , mPM . defaultUserName , true ) ; tWriteObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; tWriteObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; tWriteObject ( ElemDbColor , mPM . color ) ; tWriteObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; tWriteObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; tWriteObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; tWriteList ( ElemMemoryProt , mPM . memoryProtection ) ; tWriteCustomIconList ( ) ; tWriteObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; tWriteObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; tWriteObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; tWriteObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; tWriteObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; tWriteObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; tWriteObject ( ElemHistoryMaxItems , mPM . historyMaxSize ) ; tWriteObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; tWriteObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; txml . endTag ( null , ElemMeta ) ; 
public PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException { tPwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; tsetIVs ( header ) ; tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; ttry { tpho . output ( ) ; } catch ( IOException e ) { tthrow new PwDbOutputException ( " Failed to output the header. " ) ; } thashOfHeader = pho . getHashOfHeader ( ) ; treturn header ; } 
private void WriteObject ( String name , String value , boolean filterXmlChars ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & value ! = null ) ; txml . startTag ( null , name ) ; tif ( filterXmlChars ) { tvalue = SafeXmlString ( value ) ; } txml . text ( value ) ; txml . endTag ( null , name ) ; } 
private void WriteObject ( String name , String value ) throws IllegalArgumentException , IllegalStateException , IOException { tWriteObject ( name , value , false ) ; } 
private void WriteObject ( String name , Date value ) throws IllegalArgumentException , IllegalStateException , IOException { tWriteObject ( name , PwDatabaseV4XML . dateFormat . format ( value ) ) ; } 
private void WriteObject ( String name , long value ) throws IllegalArgumentException , IllegalStateException , IOException { tWriteObject ( name , String . valueOf ( value ) ) ; } 
private void WriteObject ( String name , boolean value ) throws IllegalArgumentException , IllegalStateException , IOException { tWriteObject ( name , value ? ValTrue : ValFalse ) ; } 
private void WriteObject ( String name , UUID uuid ) throws IllegalArgumentException , IllegalStateException , IOException { tbyte [ ] data = Types . UUIDtoBytes ( uuid ) ; tWriteObject ( name , String . valueOf ( Base64Coder . encode ( data ) ) ) ; } 
private void WriteList ( String name , MemoryProtectionConfig value ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & value ! = null ) ; txml . startTag ( null , name ) ; tWriteObject ( ElemProtTitle , value . protectTitle ) ; tWriteObject ( ElemProtUserName , value . protectUserName ) ; tWriteObject ( ElemProtPassword , value . protectPassword ) ; tWriteObject ( ElemProtURL , value . protectUrl ) ; tWriteObject ( ElemProtNotes , value . protectNotes ) ; txml . endTag ( null , name ) ; 
private void WriteCustomIconList ( ) throws IllegalArgumentException , IllegalStateException , IOException { tList < PwIconCustom > customIcons = mPM . customIcons ; tif ( customIcons . size ( ) = = 0 ) return ; txml . startTag ( null , ElemCustomIcons ) ; tfor ( PwIconCustom icon : customIcons ) { txml . startTag ( null , ElemCustomIconItem ) ; tWriteObject ( ElemCustomIconItemID , icon . uuid ) ; tWriteObject ( ElemCustomIconItemData , String . valueOf ( Base64Coder . encode ( icon . imageData ) ) ) ; txml . endTag ( null , ElemCustomIconItem ) ; } txml . endTag ( null , ElemCustomIcons ) ; } 
private String SafeXmlString ( String text ) { tif ( EmptyUtils . isNullOrEmpty ( text ) ) { treturn text ; } tStringBuilder sb = new StringBuilder ( ) ; tchar ch ; tfor ( int i = 0 ; i < text . length ( ) ; i + + ) { tch = text . charAt ( i ) ; tif ( ( ( ch > = 0x20 ) & & ( ch < = 0xD7FF ) ) | | ( ch = = 0x9 ) | | ( ch = = 0xA ) | | ( ch = = 0xD ) | | ( ( ch > = 0xE000 ) & & ( ch < = 0xFFFD ) ) ) { tsb . append ( ch ) ; } } treturn sb . toString ( ) ; } 
public ProtectedBinary get ( String key ) { treturn pool . get ( key ) ; } 
public ProtectedBinary put ( String key , ProtectedBinary value ) { treturn pool . put ( key , value ) ; } 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tString ref = xpp . getAttributeValue ( null , AttrRef ) ; tif ( ref ! = null ) { txpp . next ( ) ; } 
public int length ( ) { tif ( data = = null ) { treturn 0 ; } treturn data . length ; } 
public static void copyStream ( InputStream in , OutputStream out ) throws IOException { tbyte [ ] buf = new byte [ 1024 ] ; tint read ; twhile ( ( read = in . read ( buf ) ) ! = - 1 ) { tout . write ( buf , 0 , read ) ; 
public void testAssign ( ) { tPwEntryV4 entry = new PwEntryV4 ( ) ; tentry . additional = " test223 " ; tentry . autoType = entry . new AutoType ( ) ; tentry . autoType . defaultSequence = " 1324 " ; tentry . autoType . enabled = true ; tentry . autoType . obfuscationOptions = 123412432109L ; tentry . autoType . put ( " key " , " value " ) ; tentry . backgroupColor = " blue " ; tentry . binaries . put ( " key1 " , new ProtectedBinary ( false , new byte [ ] { 0 , 1 } ) ) ; tentry . customIcon = new PwIconCustom ( UUID . randomUUID ( ) , new byte [ 0 ] ) ; tentry . foregroundColor = " red " ; tentry . history . add ( new PwEntryV4 ( ) ) ; tentry . icon = new PwIconStandard ( 5 ) ; tentry . overrideURL = " override " ; tentry . parent = new PwGroupV4 ( ) ; tentry . strings . put ( " key2 " , " value2 " ) ; tentry . url = " http:localhost " ; tentry . uuid = UUID . randomUUID ( ) ; tPwEntryV4 target = new PwEntryV4 ( ) ; ttarget . assign ( entry ) ; 
tprotected void setupEditButtons ( ) { }} 
tprotected void fillData ( ) { tsuper . fillData ( ) ; tViewGroup group = ( ViewGroup ) findViewById ( R . id . extra_strings ) ; tPwEntryV4 entry = ( PwEntryV4 ) mEntry ; for (Map.Entry<String, ProtectedString> pair : entry.strings.entrySet()) { 
private ProtectedString ReadProtectedString ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tbyte [ ] buf = ProcessNode ( xpp ) ; tif ( buf ! = null ) { ttry { treturn new ProtectedString ( true , new String ( buf , " UTF-8 " ) ) ; } catch ( UnsupportedEncodingException e ) { te . printStackTrace ( ) ; tthrow new IOException ( e . getLocalizedMessage ( ) ) ; } } treturn new ProtectedString ( false , ReadString ( xpp ) ) ; } 
public int length ( ) { tif ( string = = null ) { treturn 0 ; } treturn string . length ( ) ; } 
public void testAssign ( ) { tPwEntryV4 entry = new PwEntryV4 ( ) ; tentry . additional = " test223 " ; tentry . autoType = entry . new AutoType ( ) ; tentry . autoType . defaultSequence = " 1324 " ; tentry . autoType . enabled = true ; tentry . autoType . obfuscationOptions = 123412432109L ; tentry . autoType . put ( " key " , " value " ) ; tentry . backgroupColor = " blue " ; tentry . binaries . put ( " key1 " , new ProtectedBinary ( false , new byte [ ] { 0 , 1 } ) ) ; tentry . customIcon = new PwIconCustom ( UUID . randomUUID ( ) , new byte [ 0 ] ) ; tentry . foregroundColor = " red " ; tentry . history . add ( new PwEntryV4 ( ) ) ; tentry . icon = new PwIconStandard ( 5 ) ; tentry . overrideURL = " override " ; tentry . parent = new PwGroupV4 ( ) ; tentry . strings . put ( " key2 " , new ProtectedString ( false , " value2 " ) ) ; tentry . url = " http:localhost " ; tentry . uuid = UUID . randomUUID ( ) ; tPwEntryV4 target = new PwEntryV4 ( ) ; ttarget . assign ( entry ) ; 
public Set < Entry < String , ProtectedBinary > > entrySet ( ) { treturn pool . entrySet ( ) ; } 
public boolean operate ( PwEntryV4 entry ) { tfor ( PwEntryV4 histEntry : entry . history ) { tpoolAdd ( histEntry . binaries ) ; } tpoolAdd ( entry . binaries ) ; treturn true ; } 
private void poolAdd ( Map < String , ProtectedBinary > dict ) { tfor ( ProtectedBinary pb : dict . values ( ) ) { tpoolAdd ( pb ) ; 
private void poolAdd ( ProtectedBinary pb ) { tassert ( pb ! = null ) ; tif ( poolFind ( pb ) ! = null ) return ; tpool . put ( String . valueOf ( pool . size ( ) ) , pb ) ; } 
private String poolFind ( ProtectedBinary pb ) { tfor ( Entry < String , ProtectedBinary > pair : pool . entrySet ( ) ) { tif ( pair . getValue ( ) . equals ( pb ) ) return pair . getKey ( ) ; } treturn null ; } 
private void build ( PwGroupV4 rootGroup ) { tEntryHandler eh = new AddBinaries ( ) ; trootGroup . preOrderTraverseTree ( null , eh ) ; } 
public boolean preOrderTraverseTree ( GroupHandler groupHandler , EntryHandler entryHandler ) { tif ( entryHandler ! = null ) { tfor ( PwEntry entry : childEntries ) { tif ( ! entryHandler . operate ( ( PwEntryV4 ) entry ) ) return false ; } } tfor ( PwGroup g : childGroups ) { tPwGroupV4 group = ( PwGroupV4 ) g ; tif ( ( groupHandler ! = null ) & & ! groupHandler . operate ( group ) ) return false ; tgroup . preOrderTraverseTree ( groupHandler , entryHandler ) ; } treturn true ; 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tString ref = xpp . getAttributeValue ( null , AttrRef ) ; tif ( ref ! = null ) { txpp . next ( ) ; } 
private void outputDatabase ( OutputStream os ) throws IllegalArgumentException , IllegalStateException , IOException { tbinPool = new BinaryPool ( ( PwGroupV4 ) mPM . rootGroup ) ; txml = Xml . newSerializer ( ) ; txml . setOutput ( os , " UTF-8 " ) ; txml . startDocument ( " UTF-8 " , true ) ; txml . startTag ( null , ElemDocNode ) ; twriteMeta ( ) ; txml . endTag ( null , ElemDocNode ) ; txml . endDocument ( ) ; 
private void writeMeta ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemMeta ) ; twriteObject ( ElemGenerator , mPM . localizedAppName ) ; tif ( hashOfHeader ! = null ) { twriteObject ( ElemHeaderHash , String . valueOf ( Base64Coder . encode ( hashOfHeader ) ) ) ; } twriteObject ( ElemDbName , mPM . name , true ) ; twriteObject ( ElemDbNameChanged , mPM . nameChanged ) ; twriteObject ( ElemDbDesc , mPM . description , true ) ; twriteObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; twriteObject ( ElemDbDefaultUser , mPM . defaultUserName , true ) ; twriteObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; twriteObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; twriteObject ( ElemDbColor , mPM . color ) ; twriteObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; twriteObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; twriteObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; twriteList ( ElemMemoryProt , mPM . memoryProtection ) ; twriteCustomIconList ( ) ; twriteObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; twriteObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; twriteObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; twriteObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; twriteObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; twriteObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; twriteObject ( ElemHistoryMaxItems , mPM . historyMaxSize ) ; twriteObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; twriteObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; twriteBinPool ( ) ; twriteList ( ElemCustomData , mPM . customData ) ; txml . endTag ( null , ElemMeta ) ; 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random = super . setIVs ( header ) ; tPwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; trandom . nextBytes ( h . masterSeed ) ; trandom . nextBytes ( h . transformSeed ) ; trandom . nextBytes ( h . encryptionIV ) ; trandom . nextBytes ( h . protectedStreamKey ) ; th . innerRandomStream = CrsAlgorithm . Salsa20 ; trandomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . protectedStreamKey ) ; tif ( randomStream = = null ) { tthrow new PwDbOutputException ( " Invalid random cipher " ) ; } trandom . nextBytes ( h . streamStartBytes ) ; treturn random ; } 
private void subWriteValue ( ProtectedBinary value ) throws IllegalArgumentException , IllegalStateException , IOException { tif ( value . isProtected ( ) ) { txml . attribute ( null , AttrProtected , ValTrue ) ; 
private void writeObject ( String name , String value , boolean filterXmlChars ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & value ! = null ) ; txml . startTag ( null , name ) ; tif ( filterXmlChars ) { tvalue = safeXmlString ( value ) ; } txml . text ( value ) ; txml . endTag ( null , name ) ; } 
private void writeObject ( String name , String value ) throws IllegalArgumentException , IllegalStateException , IOException { twriteObject ( name , value , false ) ; } 
private void writeObject ( String name , Date value ) throws IllegalArgumentException , IllegalStateException , IOException { twriteObject ( name , PwDatabaseV4XML . dateFormat . format ( value ) ) ; } 
private void writeObject ( String name , long value ) throws IllegalArgumentException , IllegalStateException , IOException { twriteObject ( name , String . valueOf ( value ) ) ; } 
private void writeObject ( String name , boolean value ) throws IllegalArgumentException , IllegalStateException , IOException { twriteObject ( name , value ? ValTrue : ValFalse ) ; } 
private void writeObject ( String name , UUID uuid ) throws IllegalArgumentException , IllegalStateException , IOException { tbyte [ ] data = Types . UUIDtoBytes ( uuid ) ; twriteObject ( name , String . valueOf ( Base64Coder . encode ( data ) ) ) ; } 
private void writeObject ( String name , String keyName , String keyValue , String valueName , String valueValue ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , name ) ; txml . startTag ( null , keyName ) ; txml . text ( safeXmlString ( keyValue ) ) ; txml . endTag ( null , keyName ) ; txml . startTag ( null , valueName ) ; txml . text ( safeXmlString ( valueValue ) ) ; txml . endTag ( null , valueName ) ; txml . endTag ( null , name ) ; } 
private void writeList ( String name , MemoryProtectionConfig value ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & value ! = null ) ; txml . startTag ( null , name ) ; twriteObject ( ElemProtTitle , value . protectTitle ) ; twriteObject ( ElemProtUserName , value . protectUserName ) ; twriteObject ( ElemProtPassword , value . protectPassword ) ; twriteObject ( ElemProtURL , value . protectUrl ) ; twriteObject ( ElemProtNotes , value . protectNotes ) ; txml . endTag ( null , name ) ; 
private void writeList ( String name , Map < String , String > customData ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & customData ! = null ) ; txml . startTag ( null , name ) ; tfor ( Entry < String , String > pair : customData . entrySet ( ) ) { twriteObject ( ElemStringDictExItem , ElemKey , pair . getKey ( ) , ElemValue , pair . getValue ( ) ) ; } txml . endTag ( null , name ) ; 
private void writeCustomIconList ( ) throws IllegalArgumentException , IllegalStateException , IOException { tList < PwIconCustom > customIcons = mPM . customIcons ; tif ( customIcons . size ( ) = = 0 ) return ; txml . startTag ( null , ElemCustomIcons ) ; tfor ( PwIconCustom icon : customIcons ) { txml . startTag ( null , ElemCustomIconItem ) ; twriteObject ( ElemCustomIconItemID , icon . uuid ) ; twriteObject ( ElemCustomIconItemData , String . valueOf ( Base64Coder . encode ( icon . imageData ) ) ) ; txml . endTag ( null , ElemCustomIconItem ) ; } txml . endTag ( null , ElemCustomIcons ) ; } 
private void writeBinPool ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemBinaries ) ; tfor ( Entry < String , ProtectedBinary > pair : binPool . entrySet ( ) ) { txml . startTag ( null , ElemBinary ) ; txml . attribute ( null , AttrId , pair . getKey ( ) ) ; tsubWriteValue ( pair . getValue ( ) ) ; txml . endTag ( null , ElemBinary ) ; } txml . endTag ( null , ElemBinaries ) ; 
private String safeXmlString ( String text ) { tif ( EmptyUtils . isNullOrEmpty ( text ) ) { treturn text ; } tStringBuilder sb = new StringBuilder ( ) ; tchar ch ; tfor ( int i = 0 ; i < text . length ( ) ; i + + ) { tch = text . charAt ( i ) ; tif ( ( ( ch > = 0x20 ) & & ( ch < = 0xD7FF ) ) | | ( ch = = 0x9 ) | | ( ch = = 0xA ) | | ( ch = = 0xD ) | | ( ( ch > = 0xE000 ) & & ( ch < = 0xFFFD ) ) ) { tsb . append ( ch ) ; } } treturn sb . toString ( ) ; } 
public boolean equals ( ProtectedBinary rhs ) { treturn ( protect = = rhs . protect ) & & Arrays . equals ( data , rhs . data ) ; } 
public static byte [ ] decompress ( byte [ ] input ) throws IOException { tByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; tGZIPInputStream gzis = new GZIPInputStream ( bais ) ; tByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; tUtil . copyStream ( gzis , baos ) ; tgzis . close ( ) ; treturn baos . toByteArray ( ) ; } 
public static byte [ ] compress ( byte [ ] input ) throws IOException { tByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; tByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; tGZIPOutputStream gzos = new GZIPOutputStream ( baos ) ; tUtil . copyStream ( bais , gzos ) ; tgzos . finish ( ) ; treturn baos . toByteArray ( ) ; } 
public String poolFind ( ProtectedBinary pb ) { tfor ( Entry < String , ProtectedBinary > pair : pool . entrySet ( ) ) { tif ( pair . getValue ( ) . equals ( pb ) ) return pair . getKey ( ) ; } treturn null ; } 
public Set < Entry < String , String > > entrySet ( ) { treturn windowSeqPairs . entrySet ( ) ; } 
public boolean operate ( PwGroupV4 group ) { tassert ( group ! = null ) ; twhile ( true ) { ttry { tif ( group . parent = = groupStack . peek ( ) ) { tgroupStack . push ( group ) ; tstartGroup ( group ) ; tbreak ; } else { tgroupStack . pop ( ) ; tif ( groupStack . size ( ) < = 0 ) return false ; tendGroup ( ) ; } } catch ( IOException e ) { tthrow new RuntimeException ( e ) ; } } treturn true ; } 
public boolean operate ( PwEntryV4 entry ) { tassert ( entry ! = null ) ; ttry { twriteEntry ( entry , false ) ; } catch ( IOException e ) { tthrow new RuntimeException ( e ) ; } treturn true ; } 
private void outputDatabase ( OutputStream os ) throws IllegalArgumentException , IllegalStateException , IOException { tbinPool = new BinaryPool ( ( PwGroupV4 ) mPM . rootGroup ) ; txml = Xml . newSerializer ( ) ; txml . setOutput ( os , " UTF-8 " ) ; txml . startDocument ( " UTF-8 " , true ) ; txml . startTag ( null , ElemDocNode ) ; twriteMeta ( ) ; tPwGroupV4 root = ( PwGroupV4 ) mPM . rootGroup ; txml . startTag ( null , ElemRoot ) ; tstartGroup ( root ) ; tStack < PwGroupV4 > groupStack = new Stack < PwGroupV4 > ( ) ; tgroupStack . push ( root ) ; tif ( ! root . preOrderTraverseTree ( new GroupWriter ( groupStack ) , new EntryWriter ( ) ) ) throw new RuntimeException ( " Writing groups failed " ) ; twhile ( groupStack . size ( ) > 1 ) { txml . endTag ( null , ElemGroup ) ; tgroupStack . pop ( ) ; } tendGroup ( ) ; twriteList ( ElemDeletedObjects , mPM . deletedObjects ) ; txml . endTag ( null , ElemRoot ) ; txml . endTag ( null , ElemDocNode ) ; txml . endDocument ( ) ; 
private void startGroup ( PwGroupV4 group ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemGroup ) ; twriteObject ( ElemUuid , group . uuid ) ; twriteObject ( ElemName , group . name ) ; twriteObject ( ElemNotes , group . notes ) ; twriteObject ( ElemIcon , group . icon . iconId ) ; tif ( ! group . customIcon . equals ( PwIconCustom . ZERO ) ) { twriteObject ( ElemCustomIconID , group . customIcon . uuid ) ; } twriteList ( ElemTimes , group ) ; twriteObject ( ElemIsExpanded , group . isExpanded ) ; twriteObject ( ElemGroupDefaultAutoTypeSeq , group . defaultAutoTypeSequence ) ; twriteObject ( ElemEnableAutoType , group . enableAutoType ) ; twriteObject ( ElemEnableSearching , group . enableSearching ) ; twriteObject ( ElemLastTopVisibleEntry , group . lastTopVisibleEntry ) ; 
private void endGroup ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . endTag ( null , ElemGroup ) ; } 
private void writeEntry ( PwEntryV4 entry , boolean isHistory ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( entry ! = null ) ; txml . startTag ( null , ElemEntry ) ; twriteObject ( ElemUuid , entry . uuid ) ; twriteObject ( ElemIcon , entry . icon . iconId ) ; tif ( entry . customIcon . equals ( PwIconCustom . ZERO ) ) { twriteObject ( ElemCustomIconID , entry . customIcon . uuid ) ; } twriteObject ( ElemFgColor , entry . foregroundColor ) ; twriteObject ( ElemBgColor , entry . backgroupColor ) ; twriteObject ( ElemOverrideUrl , entry . overrideURL ) ; twriteObject ( ElemTags , entry . tags ) ; twriteList ( ElemTimes , entry ) ; twriteList ( entry . strings , true ) ; twriteList ( entry . binaries ) ; twriteList ( ElemAutoType , entry . autoType ) ; tif ( ! isHistory ) { twriteList ( ElemHistory , entry . history , true ) ; } else { tassert ( entry . history . size ( ) = = 0 ) ; } txml . endTag ( null , ElemEntry ) ; } 
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( key ! = null & & value ! = null ) ; txml . startTag ( null , ElemBinary ) ; txml . startTag ( null , ElemKey ) ; txml . text ( safeXmlString ( key ) ) ; txml . endTag ( null , ElemKey ) ; txml . startTag ( null , ElemValue ) ; tString strRef = null ; tif ( allowRef ) { tstrRef = binPool . poolFind ( value ) ; } tif ( strRef ! = null ) { txml . attribute ( null , AttrRef , strRef ) ; } telse { tsubWriteValue ( value ) ; } txml . endTag ( null , ElemBinary ) ; } 
private void writeObject ( String name , Boolean value ) throws IllegalArgumentException , IllegalStateException , IOException { tString text ; tif ( value = = null ) { ttext = " null " ; } telse if ( value ) { ttext = ValTrue ; } telse { ttext = ValFalse ; } twriteObject ( name , text ) ; } 
private void writeList ( String name , AutoType autoType ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & autoType ! = null ) ; txml . startTag ( null , name ) ; twriteObject ( ElemAutoTypeEnabled , autoType . enabled ) ; twriteObject ( ElemAutoTypeObfuscation , autoType . obfuscationOptions ) ; tif ( autoType . defaultSequence . length ( ) > 0 ) { twriteObject ( ElemAutoTypeDefaultSeq , autoType . defaultSequence , true ) ; } tfor ( Entry < String , String > pair : autoType . entrySet ( ) ) { twriteObject ( ElemAutoTypeItem , ElemWindow , pair . getKey ( ) , ElemKeystrokeSequence , pair . getValue ( ) ) ; } txml . endTag ( null , name ) ; 
private void writeList ( Map < String , ProtectedString > strings , boolean isEntryString ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( strings ! = null ) ; tfor ( Entry < String , ProtectedString > pair : strings . entrySet ( ) ) { twriteObject ( pair . getKey ( ) , pair . getValue ( ) , isEntryString ) ; 
private void writeObject ( String key , ProtectedString value , boolean isEntryString ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( key ! = null & & value ! = null ) ; txml . startTag ( null , ElemString ) ; txml . startTag ( null , ElemKey ) ; txml . text ( safeXmlString ( key ) ) ; txml . endTag ( null , ElemKey ) ; txml . startTag ( null , ElemValue ) ; tboolean protect = value . isProtected ( ) ; tif ( isEntryString ) { tif ( key . equals ( PwDefsV4 . TITLE_FIELD ) ) { tprotect = mPM . memoryProtection . protectTitle ; } telse if ( key . equals ( PwDefsV4 . USERNAME_FIELD ) ) { tprotect = mPM . memoryProtection . protectUserName ; } telse if ( key . equals ( PwDefsV4 . PASSWORD_FIELD ) ) { tprotect = mPM . memoryProtection . protectPassword ; } telse if ( key . equals ( PwDefsV4 . URL_FIELD ) ) { tprotect = mPM . memoryProtection . protectUrl ; } telse if ( key . equals ( PwDefsV4 . NOTES_FIELD ) ) { tprotect = mPM . memoryProtection . protectNotes ; } } tif ( protect ) { txml . attribute ( null , AttrProtected , ValTrue ) ; tbyte [ ] data = value . toString ( ) . getBytes ( " UTF-8 " ) ; tint valLength = data . length ; tif ( valLength > 0 ) { tbyte [ ] encoded = new byte [ valLength ] ; trandomStream . processBytes ( data , 0 , valLength , encoded , 0 ) ; txml . text ( String . valueOf ( Base64Coder . encode ( encoded ) ) ) ; } telse { txml . text ( value . toString ( ) ) ; } } txml . endTag ( null , ElemValue ) ; txml . endTag ( null , ElemString ) ; 
private void writeObject ( String name , PwDeletedObject value ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & value ! = null ) ; txml . startTag ( null , name ) ; twriteObject ( ElemUuid , value . uuid ) ; twriteObject ( ElemDeletionTime , value . getDeletionTime ( ) ) ; txml . endTag ( null , name ) ; } 
private void writeList ( Map < String , ProtectedBinary > binaries ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( binaries ! = null ) ; tfor ( Entry < String , ProtectedBinary > pair : binaries . entrySet ( ) ) { twriteObject ( pair . getKey ( ) , pair . getValue ( ) , true ) ; 
private void writeList ( String name , List < PwDeletedObject > value ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & value ! = null ) ; txml . startTag ( null , name ) ; tfor ( PwDeletedObject pdo : value ) { twriteObject ( ElemDeletedObject , pdo ) ; } txml . endTag ( null , name ) ; 
private void writeList ( String name , ITimeLogger it ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & it ! = null ) ; txml . startTag ( null , name ) ; twriteObject ( ElemLastModTime , it . getLastModificationTime ( ) ) ; twriteObject ( ElemCreationTime , it . getCreationTime ( ) ) ; twriteObject ( ElemLastAccessTime , it . getLastAccessTime ( ) ) ; twriteObject ( ElemExpiryTime , it . getExpiryTime ( ) ) ; twriteObject ( ElemExpires , it . expires ( ) ) ; twriteObject ( ElemUsageCount , it . getUsageCount ( ) ) ; twriteObject ( ElemLocationChanged , it . getLocationChanged ( ) ) ; txml . endTag ( null , name ) ; } 
private void writeList ( String name , List < PwEntryV4 > value , boolean isHistory ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & value ! = null ) ; txml . startTag ( null , name ) ; tfor ( PwEntryV4 entry : value ) { twriteEntry ( entry , isHistory ) ; } txml . endTag ( null , name ) ; 
public void testSaving ( ) throws IOException , InvalidDBException , PwDbOutputException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; tis . close ( ) ; tFileOutputStream fos = new FileOutputStream ( " /sdcard/test-out.kdbx " , false ) ; tPwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , fos ) ; toutput . output ( ) ; tfos . close ( ) ; 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { tif ( uuid . equals ( AES_CIPHER ) ) { tCipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; tcipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; treturn cipher ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; thashOfHeader = header . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) throws PwDbOutputException { tCipher cipher ; ttry { tmPM . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) mPM . numKeyEncRounds ) ; tcipher = CipherFactory . getInstance ( mPM . dataCipher , Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { tthrow new PwDbOutputException ( " Invalid algorithm. " ) ; } tCipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; treturn cos ; } 
public int read ( ) throws IOException { tbytes + + ; treturn is . read ( ) ; } 
public int read ( byte [ ] buffer , int offset , int length ) throws IOException { tbytes + = length ; treturn is . read ( buffer , offset , length ) ; } 
public int read ( byte [ ] buffer ) throws IOException { tbytes + = buffer . length ; treturn is . read ( buffer ) ; } 
public long skip ( long byteCount ) throws IOException { tbytes + = byteCount ; treturn is . skip ( byteCount ) ; } 
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { tbytes + = count ; tos . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) throws IOException { tbytes + = buffer . length ; tos . write ( buffer ) ; } 
public void write ( int oneByte ) throws IOException { tbytes + + ; tos . write ( oneByte ) ; } 
public void testCipherFactory ( ) throws InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException { tbyte [ ] key = new byte [ 32 ] ; tbyte [ ] iv = new byte [ 16 ] ; tbyte [ ] plaintext = new byte [ 1024 ] ; trand . nextBytes ( key ) ; trand . nextBytes ( iv ) ; trand . nextBytes ( plaintext ) ; tCipher encrypt = CipherFactory . getInstance ( CipherFactory . AES_CIPHER , Cipher . ENCRYPT_MODE , key , iv ) ; tCipher decrypt = CipherFactory . getInstance ( CipherFactory . AES_CIPHER , Cipher . DECRYPT_MODE , key , iv ) ; tbyte [ ] secrettext = encrypt . doFinal ( plaintext ) ; tbyte [ ] decrypttext = decrypt . doFinal ( secrettext ) ; tassertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; } 
public void testCipherStreams ( ) throws InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException , IOException { tfinal int MESSAGE_LENGTH = 1024 ; tbyte [ ] key = new byte [ 32 ] ; tbyte [ ] iv = new byte [ 16 ] ; tbyte [ ] plaintext = new byte [ MESSAGE_LENGTH ] ; trand . nextBytes ( key ) ; trand . nextBytes ( iv ) ; trand . nextBytes ( plaintext ) ; tCipher encrypt = CipherFactory . getInstance ( CipherFactory . AES_CIPHER , Cipher . ENCRYPT_MODE , key , iv ) ; tCipher decrypt = CipherFactory . getInstance ( CipherFactory . AES_CIPHER , Cipher . DECRYPT_MODE , key , iv ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tCipherOutputStream cos = new CipherOutputStream ( bos , encrypt ) ; tcos . write ( plaintext ) ; tcos . close ( ) ; tbyte [ ] secrettext = bos . toByteArray ( ) ; tByteArrayInputStream bis = new ByteArrayInputStream ( secrettext ) ; tBetterCipherInputStream cis = new BetterCipherInputStream ( bis , decrypt ) ; tLEDataInputStream lis = new LEDataInputStream ( cis ) ; tbyte [ ] decrypttext = lis . readBytes ( MESSAGE_LENGTH ) ; tassertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; } 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { treturn getInstance ( uuid , opmode , key , IV , false ) ; } 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { tif ( uuid . equals ( AES_CIPHER ) ) { tCipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , androidOverride ) ; tcipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; treturn cipher ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tString keyfile , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; thashOfHeader = header . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyfile ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
public void testSaving ( ) throws IOException , InvalidDBException , PwDbOutputException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; tis . close ( ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tPwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; toutput . output ( ) ; tbyte [ ] data = bos . toByteArray ( ) ; tByteArrayInputStream bis = new ByteArrayInputStream ( data ) ; timporter = new ImporterV4 ( ) ; tdb = importer . openDatabase ( bis , " 12345 " , " " ) ; tbis . close ( ) ; 
public void output ( ) throws PwDbOutputException { theader = ( PwDbHeaderV4 ) outputHeader ( mOS ) ; tCipherOutputStream cos = attachStreamEncryptor ( header , mOS ) ; tOutputStream compressed ; ttry { tcos . write ( header . streamStartBytes ) ; 
public void write ( int oneByte ) throws IOException { tbyte [ ] buf = new byte [ 1 ] ; tbuf [ 0 ] = ( byte ) oneByte ; twrite ( buf , 0 , 1 ) ; } 
private void writeObject ( String key , ProtectedString value , boolean isEntryString ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( key ! = null & & value ! = null ) ; txml . startTag ( null , ElemString ) ; txml . startTag ( null , ElemKey ) ; txml . text ( safeXmlString ( key ) ) ; txml . endTag ( null , ElemKey ) ; txml . startTag ( null , ElemValue ) ; tboolean protect = value . isProtected ( ) ; tif ( isEntryString ) { tif ( key . equals ( PwDefsV4 . TITLE_FIELD ) ) { tprotect = mPM . memoryProtection . protectTitle ; } telse if ( key . equals ( PwDefsV4 . USERNAME_FIELD ) ) { tprotect = mPM . memoryProtection . protectUserName ; } telse if ( key . equals ( PwDefsV4 . PASSWORD_FIELD ) ) { tprotect = mPM . memoryProtection . protectPassword ; } telse if ( key . equals ( PwDefsV4 . URL_FIELD ) ) { tprotect = mPM . memoryProtection . protectUrl ; } telse if ( key . equals ( PwDefsV4 . NOTES_FIELD ) ) { tprotect = mPM . memoryProtection . protectNotes ; } } tif ( protect ) { txml . attribute ( null , AttrProtected , ValTrue ) ; tbyte [ ] data = value . toString ( ) . getBytes ( " UTF-8 " ) ; tint valLength = data . length ; tif ( valLength > 0 ) { tbyte [ ] encoded = new byte [ valLength ] ; trandomStream . processBytes ( data , 0 , valLength , encoded , 0 ) ; txml . text ( String . valueOf ( Base64Coder . encode ( encoded ) ) ) ; } } telse { txml . text ( safeXmlString ( value . toString ( ) ) ) ; } txml . endTag ( null , ElemValue ) ; txml . endTag ( null , ElemString ) ; 
private void testSize ( int blockSize , int bufferSize ) throws IOException { tbyte [ ] orig = new byte [ blockSize ] ; trand . nextBytes ( orig ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tHashedBlockOutputStream output = new HashedBlockOutputStream ( bos , bufferSize ) ; toutput . write ( orig ) ; toutput . close ( ) ; tbyte [ ] encoded = bos . toByteArray ( ) ; tByteArrayInputStream bis = new ByteArrayInputStream ( encoded ) ; tHashedBlockInputStream input = new HashedBlockInputStream ( bis ) ; tByteArrayOutputStream decoded = new ByteArrayOutputStream ( ) ; twhile ( true ) { tbyte [ ] buf = new byte [ 1024 ] ; tint read = input . read ( buf ) ; tif ( read = = - 1 ) { tbreak ; } tdecoded . write ( buf , 0 , read ) ; } tbyte [ ] out = decoded . toByteArray ( ) ; tassertArrayEquals ( orig , out ) ; 
public void testGZIPStream ( ) throws IOException { tfinal int testLength = 32000 ; tbyte [ ] orig = new byte [ testLength ] ; trand . nextBytes ( orig ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tHashedBlockOutputStream hos = new HashedBlockOutputStream ( bos ) ; tGZIPOutputStream zos = new GZIPOutputStream ( hos ) ; tzos . write ( orig ) ; tzos . close ( ) ; tbyte [ ] compressed = bos . toByteArray ( ) ; tByteArrayInputStream bis = new ByteArrayInputStream ( compressed ) ; tHashedBlockInputStream his = new HashedBlockInputStream ( bis ) ; tGZIPInputStream zis = new GZIPInputStream ( his ) ; tbyte [ ] uncompressed = new byte [ testLength ] ; tint read = 0 ; twhile ( read ! = - 1 & & testLength - read > 0 ) { tread + = zis . read ( uncompressed , read , testLength - read ) ; } tassertArrayEquals ( " Output not equal to input " , orig , uncompressed ) ; 
tprotected void fillData ( ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_created , getDateTime ( mEntry . getCreationTime ( ) ) ) ; tpopulateText ( R . id . entry_modified , getDateTime ( mEntry . getLastModificationTime ( ) ) ) ; tpopulateText ( R . id . entry_accessed , getDateTime ( mEntry . getLastAccessTime ( ) ) ) ; tDate expires = mEntry . getExpiryTime ( ) ; tif ( mEntry . expires ( ) ) { tpopulateText ( R . id . entry_expires , getDateTime ( expires ) ) ; } else { tpopulateText ( R . id . entry_expires , R . string . never ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
public static void Launch ( Activity act , PwEntry pw ) { tIntent i ; tif ( pw instanceof PwEntryV3 ) { ti = new Intent ( act , EntryEditActivityV3 . class ) ; } telse if ( pw instanceof PwEntryV4 ) { ti = new Intent ( act , EntryEditActivityV4 . class ) ; } telse { tthrow new RuntimeException ( " Not yet implemented. " ) ; } ti . putExtra ( KEY_ENTRY , Types . UUIDtoBytes ( pw . getUUID ( ) ) ) ; tact . startActivityForResult ( i , 0 ) ; } 
public static void Launch ( Activity act , PwGroup pw ) { tIntent i ; tif ( pw instanceof PwGroupV3 ) { ti = new Intent ( act , EntryEditActivityV3 . class ) ; tEntryEditActivityV3 . putParentId ( i , KEY_PARENT , ( PwGroupV3 ) pw ) ; } telse if ( pw instanceof PwGroupV4 ) { ti = new Intent ( act , EntryEditActivityV4 . class ) ; tEntryEditActivityV4 . putParentId ( i , KEY_PARENT , ( PwGroupV4 ) pw ) ; } telse { tthrow new RuntimeException ( " Not yet implemented. " ) ; } tact . startActivityForResult ( i , 0 ) ; } 
public void onClick ( View v ) { tGeneratePasswordActivity . Launch ( EntryEditActivity . this ) ; } 
tprotected PwEntry populateNewEntry ( ) { tPwEntry newEntry = mEntry . clone ( true ) ; tif ( mSelectedIconID = = - 1 & & mIsNew ) { tnewEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( 0 ) ; } telse { tnewEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( mSelectedIconID ) ; } tDate now = Calendar . getInstance ( ) . getTime ( ) ; tnewEntry . setLastAccessTime ( now ) ; tnewEntry . setLastModificationTime ( now ) ; tPwDatabase db = App . getDB ( ) . pm ; tnewEntry . setTitle ( Util . getEditText ( this , R . id . entry_title ) , db ) ; tnewEntry . setUrl ( Util . getEditText ( this , R . id . entry_url ) , db ) ; tnewEntry . setUsername ( Util . getEditText ( this , R . id . entry_user_name ) , db ) ; tnewEntry . setNotes ( Util . getEditText ( this , R . id . entry_comment ) , db ) ; tnewEntry . setPassword ( Util . getEditText ( this , R . id . entry_password ) , db ) ; treturn newEntry ; } 
private void fillData ( ) { tImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; } 
tprotected static void putParentId ( Intent i , String parentKey , PwGroupV3 parent ) { ti . putExtra ( parentKey , parent . groupId ) ; } 
tprotected static void putParentId ( Intent i , String parentKey , PwGroupV4 parent ) { tPwGroupId id = parent . getId ( ) ; tPwGroupIdV4 id4 = ( PwGroupIdV4 ) id ; ti . putExtra ( parentKey , Types . UUIDtoBytes ( id4 . getId ( ) ) ) ; 
public PwEntry clone ( boolean deepStrings ) { treturn ( PwEntry ) clone ( ) ; } 
public PwEntry clone ( boolean deepStrings ) { tPwEntryV4 entry = ( PwEntryV4 ) super . clone ( deepStrings ) ; tif ( deepStrings ) { tentry . strings = ( HashMap < String , ProtectedString > ) strings . clone ( ) ; } treturn entry ; } 
public void testSaving ( ) throws IOException , InvalidDBException , PwDbOutputException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , " " ) ; tis . close ( ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tPwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; toutput . output ( ) ; tbyte [ ] data = bos . toByteArray ( ) ; tFileOutputStream fos = new FileOutputStream ( " /sdcard/test-out.kdbx " , false ) ; tInputStream bis = new ByteArrayInputStream ( data ) ; tbis = new CopyInputStream ( bis , fos ) ; timporter = new ImporterV4 ( ) ; tdb = importer . openDatabase ( bis , " 12345 " , " " ) ; tbis . close ( ) ; tfos . close ( ) ; 
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( key ! = null & & value ! = null ) ; txml . startTag ( null , ElemBinary ) ; txml . startTag ( null , ElemKey ) ; txml . text ( safeXmlString ( key ) ) ; txml . endTag ( null , ElemKey ) ; txml . startTag ( null , ElemValue ) ; tString strRef = null ; tif ( allowRef ) { tstrRef = binPool . poolFind ( value ) ; } tif ( strRef ! = null ) { txml . attribute ( null , AttrRef , strRef ) ; } telse { tsubWriteValue ( value ) ; } txml . endTag ( null , ElemValue ) ; txml . endTag ( null , ElemBinary ) ; } 
public void run ( ) { tif ( ! mDontSave ) { ttry { tmDb . SaveData ( ) ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( PwDbOutputException e ) { } 
tprotected void setupButtons ( ) { taddGroupEnabled = false ; taddEntryEnabled = mGroup ! = App . getDB ( ) . root ; } 
tprotected void setupButtons ( ) { tif ( isRoot ) { taddGroupEnabled = true ; 
tprotected void setupButtons ( ) { taddGroupEnabled = false ; taddEntryEnabled = ! isRoot ; } 
public void onClick ( DialogInterface dialog , int which ) { tdismiss ( ) ; } 
public void onClick ( DialogInterface dialog , int which ) { tContext ctx = getContext ( ) ; tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tSharedPreferences . Editor edit = prefs . edit ( ) ; tedit . putBoolean ( ctx . getString ( R . string . show_beta_warning ) , false ) ; tedit . commit ( ) ; tdismiss ( ) ; } 
tprotected void setupButtons ( ) { taddGroupEnabled = true ; taddEntryEnabled = ! isRoot ; } 
public void onClick ( View v ) { tGroupEditActivity . Launch ( GroupActivity . this ) ; } 
public static void Launch ( Activity act ) { tIntent i = new Intent ( act , GroupEditActivity . class ) ; tact . startActivityForResult ( i , 0 ) ; } 
public void initNewGroup ( String nm , PwGroupId newId ) { tsuper . initNewGroup ( nm , newId ) ; tlastAccess = lastMod = creation = parentGroupLastMod = new Date ( ) ; } 
public void run ( ) { tPwDatabase pm = mDb . pm ; } 
tprotected void fillData ( boolean trimList ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( ) ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_created , getDateTime ( mEntry . getCreationTime ( ) ) ) ; tpopulateText ( R . id . entry_modified , getDateTime ( mEntry . getLastModificationTime ( ) ) ) ; tpopulateText ( R . id . entry_accessed , getDateTime ( mEntry . getLastAccessTime ( ) ) ) ; tDate expires = mEntry . getExpiryTime ( ) ; tif ( mEntry . expires ( ) ) { tpopulateText ( R . id . entry_expires , getDateTime ( expires ) ) ; } else { tpopulateText ( R . id . entry_expires , R . string . never ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tif ( resultCode = = KeePass . EXIT_REFRESH | | resultCode = = KeePass . EXIT_REFRESH_TITLE ) { tfillData ( true ) ; 
tprotected void fillData ( boolean trimList ) { tsuper . fillData ( trimList ) ; tViewGroup group = ( ViewGroup ) findViewById ( R . id . extra_strings ) ; tif ( trimList ) { tgroup . removeAllViews ( ) ; } tPwEntryV4 entry = ( PwEntryV4 ) mEntry ; for (Map.Entry<String, ProtectedString> pair : entry.strings.entrySet()) { 
tprotected boolean validateBeforeSaving ( ) { } 
tprotected void fillData ( ) { tImageButton currIconButton = ( ImageButton ) findViewById ( R . id . icon_button ) ; tApp . getDB ( ) . drawFactory . assignDrawableTo ( currIconButton , getResources ( ) , mEntry . getIcon ( ) ) ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( ) ) ; tString password = new String ( mEntry . getPassword ( ) ) ; tpopulateText ( R . id . entry_password , password ) ; tpopulateText ( R . id . entry_confpassword , password ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_comment , mEntry . getNotes ( ) ) ; } 
public void onClick ( View v ) { tLinearLayout container = ( LinearLayout ) findViewById ( R . id . advanced_container ) ; tEntryEditSection ees = ( EntryEditSection ) inflater . inflate ( R . layout . entry_edit_section , null ) ; tees . setData ( " " , new ProtectedString ( false , " " ) ) ; tcontainer . addView ( ees ) ; @Override 
public void run ( ) { tscroll . fullScroll ( ScrollView . FOCUS_DOWN ) ; } 
tprotected void fillData ( ) { tsuper . fillData ( ) ; tPwEntryV4 entry = ( PwEntryV4 ) mEntry ; tLinearLayout container = ( LinearLayout ) findViewById ( R . id . advanced_container ) ; tif ( entry . strings . size ( ) > 0 ) { tfor ( Entry < String , ProtectedString > pair : entry . strings . entrySet ( ) ) { 
tprotected void inflate ( LayoutInflater inflater , Context context , String title , String value ) { tinflater . inflate ( getLayout ( ) , this ) ; tsetText ( R . id . title , title ) ; tsetText ( R . id . value , value ) ; } 
tprotected PwEntry populateNewEntry ( ) { treturn populateNewEntry ( null ) ; } 
tprotected PwEntry populateNewEntry ( PwEntry entry ) { tPwEntry newEntry ; tif ( entry ! = null ) { tnewEntry = mEntry . clone ( true ) ; } telse { tnewEntry = entry ; } tDate now = Calendar . getInstance ( ) . getTime ( ) ; tnewEntry . setLastAccessTime ( now ) ; tnewEntry . setLastModificationTime ( now ) ; tPwDatabase db = App . getDB ( ) . pm ; tnewEntry . setTitle ( Util . getEditText ( this , R . id . entry_title ) , db ) ; tnewEntry . setUrl ( Util . getEditText ( this , R . id . entry_url ) , db ) ; tnewEntry . setUsername ( Util . getEditText ( this , R . id . entry_user_name ) , db ) ; tnewEntry . setNotes ( Util . getEditText ( this , R . id . entry_comment ) , db ) ; tnewEntry . setPassword ( Util . getEditText ( this , R . id . entry_password ) , db ) ; treturn newEntry ; } 
tprotected PwEntry populateNewEntry ( PwEntry entry ) { tPwEntry newEntry = super . populateNewEntry ( entry ) ; tif ( mSelectedIconID = = - 1 & & mIsNew ) { tnewEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( 0 ) ; } telse { tnewEntry . icon = App . getDB ( ) . pm . iconFactory . getIcon ( mSelectedIconID ) ; } treturn newEntry ; } 
public Object clone ( ) { tAutoType auto ; ttry { tauto = ( AutoType ) super . clone ( ) ; } tcatch ( CloneNotSupportedException e ) { tassert ( false ) ; tthrow new RuntimeException ( e ) ; } tauto . windowSeqPairs = ( HashMap < String , String > ) windowSeqPairs . clone ( ) ; treturn auto ; 
public PwEntryV4 cloneDeep ( ) { tPwEntryV4 entry = ( PwEntryV4 ) clone ( true ) ; tentry . binaries = ( HashMap < String , ProtectedBinary > ) binaries . clone ( ) ; tentry . history = ( ArrayList < PwEntryV4 > ) history . clone ( ) ; tentry . autoType = ( AutoType ) autoType . clone ( ) ; treturn entry ; } 
public void createBackup ( PwDatabaseV4 db ) { tPwEntryV4 copy = cloneDeep ( ) ; tcopy . history = new ArrayList < PwEntryV4 > ( ) ; thistory . add ( copy ) ; tif ( db ! = null ) maintainBackups ( db ) ; } 
private boolean maintainBackups ( PwDatabaseV4 db ) { tboolean deleted = false ; tint maxItems = db . historyMaxItems ; tif ( maxItems > = 0 ) { twhile ( history . size ( ) > maxItems ) { tremoveOldestBackup ( ) ; tdeleted = true ; } } tlong maxSize = db . historyMaxSize ; tif ( maxSize > = 0 ) { twhile ( true ) { tlong histSize = 0 ; tfor ( PwEntryV4 entry : history ) { thistSize + = entry . getSize ( ) ; } tif ( histSize > maxSize ) { tremoveOldestBackup ( ) ; tdeleted = true ; } else { tbreak ; } } } treturn deleted ; } 
private void removeOldestBackup ( ) { tDate min = null ; tint index = - 1 ; tfor ( int i = 0 ; i < history . size ( ) ; i + + ) { tPwEntry entry = history . get ( i ) ; tDate lastMod = entry . getLastModificationTime ( ) ; tif ( ( min = = null ) | | lastMod . before ( min ) ) { tindex = i ; tmin = lastMod ; } } tif ( index ! = - 1 ) { thistory . remove ( index ) ; 
private void writeEntry ( PwEntryV4 entry , boolean isHistory ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( entry ! = null ) ; txml . startTag ( null , ElemEntry ) ; twriteObject ( ElemUuid , entry . uuid ) ; twriteObject ( ElemIcon , entry . icon . iconId ) ; tif ( ! entry . customIcon . equals ( PwIconCustom . ZERO ) ) { twriteObject ( ElemCustomIconID , entry . customIcon . uuid ) ; } twriteObject ( ElemFgColor , entry . foregroundColor ) ; twriteObject ( ElemBgColor , entry . backgroupColor ) ; twriteObject ( ElemOverrideUrl , entry . overrideURL ) ; twriteObject ( ElemTags , entry . tags ) ; twriteList ( ElemTimes , entry ) ; twriteList ( entry . strings , true ) ; twriteList ( entry . binaries ) ; twriteList ( ElemAutoType , entry . autoType ) ; tif ( ! isHistory ) { twriteList ( ElemHistory , entry . history , true ) ; } else { tassert ( entry . history . size ( ) = = 0 ) ; } txml . endTag ( null , ElemEntry ) ; } 
public void testBackup ( ) { tPwDatabaseV4 db = new PwDatabaseV4 ( ) ; tdb . historyMaxItems = 2 ; tPwEntryV4 entry = new PwEntryV4 ( ) ; tentry . setTitle ( " Title1 " , db ) ; tentry . setUsername ( " User1 " , db ) ; tentry . createBackup ( db ) ; tentry . setTitle ( " Title2 " , db ) ; tentry . setUsername ( " User2 " , db ) ; tentry . createBackup ( db ) ; tentry . setTitle ( " Title3 " , db ) ; tentry . setUsername ( " User3 " , db ) ; tentry . createBackup ( db ) ; tPwEntryV4 backup = entry . history . get ( 0 ) ; tassertEquals ( " Title2 " , backup . getTitle ( ) ) ; tassertEquals ( " User2 " , backup . getUsername ( ) ) ; } 
tprotected PwEntry populateNewEntry ( PwEntry entry ) { tPwEntry newEntry ; tif ( entry = = null ) { tnewEntry = mEntry . clone ( true ) ; } telse { tnewEntry = entry ; } tDate now = Calendar . getInstance ( ) . getTime ( ) ; tnewEntry . setLastAccessTime ( now ) ; tnewEntry . setLastModificationTime ( now ) ; tPwDatabase db = App . getDB ( ) . pm ; tnewEntry . setTitle ( Util . getEditText ( this , R . id . entry_title ) , db ) ; tnewEntry . setUrl ( Util . getEditText ( this , R . id . entry_url ) , db ) ; tnewEntry . setUsername ( Util . getEditText ( this , R . id . entry_user_name ) , db ) ; tnewEntry . setNotes ( Util . getEditText ( this , R . id . entry_comment ) , db ) ; tnewEntry . setPassword ( Util . getEditText ( this , R . id . entry_password ) , db ) ; treturn newEntry ; } 
public PwGroup Search ( String str ) { tif ( searchHelper = = null ) { return null ; } tPwGroup group = searchHelper . search ( this , str ) ; treturn group ; 
private void timeoutCopyToClipboard ( String text ) { ttry { tUtil . copyToClipboard ( this , text ) ; } catch ( SamsungClipboardException e ) { tshowSamsungDialog ( ) ; treturn ; } tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; tString sClipClear = prefs . getString ( getString ( R . string . clipboard_timeout_key ) , getString ( R . string . clipboard_timeout_default ) ) ; tlong clipClearTime = Long . parseLong ( sClipClear ) ; tif ( clipClearTime > 0 ) { tmTimer . schedule ( new ClearClipboardTask ( this , text ) , clipClearTime ) ; 
public void run ( ) { tString currentClip = Util . getClipboard ( mCtx ) ; tif ( currentClip . equals ( mClearText ) ) { ttry { 
public void onClick ( DialogInterface dialog , int which ) { tdialog . dismiss ( ) ; } 
public static void copyToClipboard ( Context context , String text ) throws SamsungClipboardException { tClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ttry { tclipboard . setText ( text ) ; 
private void fillData ( ) { } 
private void writeMeta ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemMeta ) ; twriteObject ( ElemGenerator , mPM . localizedAppName ) ; tif ( hashOfHeader ! = null ) { twriteObject ( ElemHeaderHash , String . valueOf ( Base64Coder . encode ( hashOfHeader ) ) ) ; } twriteObject ( ElemDbName , mPM . name , true ) ; twriteObject ( ElemDbNameChanged , mPM . nameChanged ) ; twriteObject ( ElemDbDesc , mPM . description , true ) ; twriteObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; twriteObject ( ElemDbDefaultUser , mPM . defaultUserName , true ) ; twriteObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; twriteObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; twriteObject ( ElemDbColor , mPM . color ) ; twriteObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; twriteObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; twriteObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; twriteList ( ElemMemoryProt , mPM . memoryProtection ) ; twriteCustomIconList ( ) ; twriteObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; twriteObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; twriteObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; twriteObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; twriteObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; twriteObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; twriteObject ( ElemHistoryMaxSize , mPM . historyMaxSize ) ; twriteObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; twriteObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; twriteBinPool ( ) ; twriteList ( ElemCustomData , mPM . customData ) ; txml . endTag ( null , ElemMeta ) ; 
public static byte [ ] decompress ( byte [ ] input ) throws IOException { tByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; tGZIPInputStream gzis = new GZIPInputStream ( bais ) ; tByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; tUtil . copyStream ( gzis , baos ) ; treturn baos . toByteArray ( ) ; } 
public static byte [ ] compress ( byte [ ] input ) throws IOException { tByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; tByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; tGZIPOutputStream gzos = new GZIPOutputStream ( baos ) ; tUtil . copyStream ( bais , gzos ) ; tgzos . close ( ) ; treturn baos . toByteArray ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
tprotected void setupButtons ( ) { tsuper . setupButtons ( ) ; taddEntryEnabled = ! isRoot ; } 
tprotected void setupButtons ( ) { tsuper . setupButtons ( ) ; taddEntryEnabled = true ; } 
public void onClick ( View v ) { tif ( Interaction . isIntentAvailable ( PasswordActivity . this , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { tIntent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
public void onClick ( View v ) { tif ( Interaction . isIntentAvailable ( FileSelectActivity . this , Intent . ACTION_GET_CONTENT ) ) { tIntent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { tif ( Interaction . isIntentAvailable ( FileSelectActivity . this , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { tIntent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { tBrowserDialog diag = new BrowserDialog ( FileSelectActivity . this ) ; tdiag . show ( ) ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tString filename = null ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tfilename = data . getDataString ( ) ; tif ( filename ! = null ) { tif ( filename . startsWith ( " file: " ) ) { tfilename = filename . substring ( 7 ) ; } tfilename = URLDecoder . decode ( filename ) ; } } telse if ( requestCode = = GET_CONTENT & & resultCode = = RESULT_OK ) { tfilename = data . getData ( ) . getPath ( ) ; } tif ( filename ! = null ) { tEditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public void clear ( ) { tdirty . clear ( ) ; tdrawFactory . clear ( ) ; tpm = null ; tmFilename = null ; tloaded = false ; } 
public abstract PwGroup createGroup ( ) ; public abstract boolean isBackup ( PwGroup group ) ; public void populateGlobals ( PwGroup currentGroup ) { tList < PwGroup > childGroups = currentGroup . childGroups ; tList < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . get ( i ) ; tentries . put ( cur . getUUID ( ) , cur ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . get ( i ) ; tgroups . put ( cur . getId ( ) , cur ) ; tpopulateGlobals ( cur ) ; } } } 
public abstract boolean isBackup ( PwGroup group ) ; public void populateGlobals ( PwGroup currentGroup ) { tList < PwGroup > childGroups = currentGroup . childGroups ; tList < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . get ( i ) ; tentries . put ( cur . getUUID ( ) , cur ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . get ( i ) ; tgroups . put ( cur . getId ( ) , cur ) ; tpopulateGlobals ( cur ) ; } } } 
public void populateGlobals ( PwGroup currentGroup ) { tList < PwGroup > childGroups = currentGroup . childGroups ; tList < PwEntry > childEntries = currentGroup . childEntries ; tfor ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { tPwEntry cur = childEntries . get ( i ) ; tentries . put ( cur . getUUID ( ) , cur ) ; } tfor ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { tPwGroup cur = childGroups . get ( i ) ; 
public void populateGlobals ( PwGroup currentGroup ) { tgroups . put ( rootGroup . getId ( ) , rootGroup ) ; tsuper . populateGlobals ( currentGroup ) ; } 
public void run ( ) { tPwDatabase pm = mDb . pm ; tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { tPwDatabase pm = mDb . pm ; tif ( mSuccess ) { } 
public void run ( ) { save.run(); 
public void run ( ) { tif ( mSuccess ) { super.run(); 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tString filename = null ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tfilename = data . getDataString ( ) ; tif ( filename ! = null ) { tif ( filename . startsWith ( " file: " ) ) { tfilename = filename . substring ( 7 ) ; } tfilename = URLDecoder . decode ( filename ) ; } } telse if ( requestCode = = GET_CONTENT & & resultCode = = RESULT_OK ) { tfilename = data . getData ( ) . getPath ( ) ; } tif ( filename ! = null ) { tEditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public void onClick ( View v ) { tif ( Interaction . isIntentAvailable ( PasswordActivity . this , Intent . ACTION_GET_CONTENT ) ) { tIntent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { tif ( Interaction . isIntentAvailable ( PasswordActivity . this , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { tIntent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { tBrowserDialog diag = new BrowserDialog ( PasswordActivity . this ) ; tdiag . show ( ) ; } 
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { } 
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { } 
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { } 
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { } 
public void recycle ( PwEntry entry ) { } 
public void undoRecycle ( PwEntry entry , PwGroup origParent ) { tthrow new RuntimeException ( " Call not valid for .kdb databases. " ) ; } 
public void deleteEntry ( PwEntry entry ) { tPwGroup parent = entry . getParent ( ) ; tremoveEntryFrom ( entry , parent ) ; tparent . touch ( false , true ) ; 
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { taddEntryTo ( entry , origParent ) ; } 
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { treturn group ! = null ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { }} 
public void copyHeader ( PwDbHeaderV3 header ) { }} 
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { tif ( ! super . isGroupSearchable ( group , omitBackup ) ) { treturn false ; } treturn ! ( omitBackup & & isBackup ( group ) ) ; } 
public boolean isBackup ( PwGroup group ) { tif ( ! recycleBinEnabled ) { treturn false ; } treturn group . isContainedIn ( getRecycleBin ( ) ) ; } 
public boolean canRecycle ( PwGroup group ) { tif ( ! recycleBinEnabled ) { treturn false ; } tPwGroup recycle = getRecycleBin ( ) ; treturn ( recycle = = null ) | | ( ! group . isContainedIn ( recycle ) ) ; } 
public boolean canRecycle ( PwEntry entry ) { tif ( ! recycleBinEnabled ) { treturn false ; } tPwGroup parent = entry . getParent ( ) ; treturn ( parent ! = null ) & & canRecycle ( parent ) ; } 
public void recycle ( PwEntry entry ) { tensureRecycleBin ( ) ; tPwGroup parent = entry . getParent ( ) ; tremoveEntryFrom ( entry , parent ) ; tparent . touch ( false , true ) ; tPwGroup recycleBin = getRecycleBin ( ) ; taddEntryTo ( entry , recycleBin ) ; tentry . touch ( false , true ) ; tentry . touchLocation ( ) ; } 
public void undoRecycle ( PwEntry entry , PwGroup origParent ) { tPwGroup recycleBin = getRecycleBin ( ) ; tremoveEntryFrom ( entry , recycleBin ) ; taddEntryTo ( entry , origParent ) ; } 
public void deleteEntry ( PwEntry entry ) { tsuper . deleteEntry ( entry ) ; tdeletedObjects . add ( new PwDeletedObject ( entry . getUUID ( ) ) ) ; } 
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { tsuper . undoDeleteEntry ( entry , origParent ) ; tdeletedObjects . remove ( entry ) ; } 
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { tif ( ! super . isGroupSearchable ( group , omitBackup ) ) { treturn false ; } tPwGroupV4 g = ( PwGroupV4 ) group ; treturn g . isSearchEnabled ( ) ; } 
public boolean equals ( Object o ) { tif ( this = = o ) { treturn true ; } telse if ( o = = null ) { treturn false ; } telse if ( ! ( o instanceof PwDeletedObject ) ) { treturn false ; } tPwDeletedObject rhs = ( PwDeletedObject ) o ; treturn uuid . equals ( rhs . uuid ) ; } 
public void touch ( boolean modified , boolean touchParents ) { tDate now = new Date ( ) ; tsetLastAccessTime ( now ) ; tif ( modified ) { tsetLastModificationTime ( now ) ; } tPwGroup parent = getParent ( ) ; tif ( touchParents & & parent ! = null ) { tparent . touch ( modified , true ) ; 
public void touchLocation ( ) { } public abstract void setParent ( PwGroup parent ) ; } 
public void touch ( boolean modified , boolean touchParents ) { tsuper . touch ( modified , touchParents ) ; + + usageCount ; } 
public void touchLocation ( ) { tparentGroupLastMod = new Date ( ) ; } 
public abstract void setLastAccessTime ( Date date ) ; public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } public boolean isContainedIn ( PwGroup container ) { tPwGroup cur = this ; twhile ( cur ! = null ) { tif ( cur = = container ) { treturn true ; } tcur = cur . getParent ( ) ; } treturn false ; } public void touch ( boolean modified , boolean touchParents ) { tDate now = new Date ( ) ; tsetLastAccessTime ( now ) ; tif ( modified ) { tsetLastModificationTime ( now ) ; } tPwGroup parent = getParent ( ) ; tif ( touchParents & & parent ! = null ) { tparent . touch ( modified , true ) ; } } } 
public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } public boolean isContainedIn ( PwGroup container ) { tPwGroup cur = this ; twhile ( cur ! = null ) { tif ( cur = = container ) { treturn true ; } tcur = cur . getParent ( ) ; } treturn false ; } public void touch ( boolean modified , boolean touchParents ) { tDate now = new Date ( ) ; tsetLastAccessTime ( now ) ; tif ( modified ) { tsetLastModificationTime ( now ) ; } tPwGroup parent = getParent ( ) ; tif ( touchParents & & parent ! = null ) { tparent . touch ( modified , true ) ; } } } 
public boolean isContainedIn ( PwGroup container ) { tPwGroup cur = this ; twhile ( cur ! = null ) { tif ( cur = = container ) { treturn true ; } tcur = cur . getParent ( ) ; } treturn false ; } 
public boolean isSearchEnabled ( ) { treturn ( enableSearching = = null ) | | enableSearching ; } 
public void run ( ) { tPwDatabase pm = mDb . pm ; tif ( mSuccess ) { tPwGroup parent = mEntry . getParent ( ) ; } 
public void run ( ) { tPwDatabase pm = mDb . pm ; tif ( mSuccess ) { } 
public void run ( ) { tPwDatabase pm = mDb . pm ; tPwGroup parent = mEntry . getParent ( ) ; 
public void run ( ) { tPwDatabase pm = mDb . pm ; tif ( mSuccess ) { 
public void run ( ) { tif ( mSuccess ) { super.run(); 
public void run ( ) { } 
public PwGroup search ( Database db , String qStr ) { tPwDatabase pm = db . pm ; tPwGroup group ; tif ( pm instanceof PwDatabaseV3 ) { tgroup = new PwGroupV3 ( ) ; } else if ( pm instanceof PwDatabaseV4 ) { tgroup = new PwGroupV4 ( ) ; } else { tLog . d ( " SearchDbHelper " , " Tried to search with unknown db " ) ; treturn null ; } tgroup . name = mCtx . getString ( R . string . search_results ) ; tgroup . childEntries = new ArrayList < PwEntry > ( ) ; } 
public void processEntries ( PwEntry entry , List < PwEntry > results , String qStr , Locale loc ) { String str = iter.next(); 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate = null ; ttry { tutcDate = PwDatabaseV4XML . dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { 
public static Cipher getInstance ( String transformation , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException { return Cipher.getInstance(transformation, new AESProvider()); 
public static boolean deviceBlacklisted ( ) { tif ( ! blacklistInit ) { tblacklistInit = true ; } 
public static FinalKey createFinalKey ( boolean androidOverride ) { return new NativeFinalKey(); 
public void onTerminate ( ) { tif ( db ! = null ) { tdb . clear ( ) ; } tif ( fileDbHelper ! = null & & fileDbHelper . isOpen ( ) ) { tfileDbHelper . close ( ) ; } tsuper . onTerminate ( ) ; 
public static Date readTime ( byte [ ] buf , int offset , Calendar time ) { tint dw1 = Types . readUByte ( buf , offset ) ; tint dw2 = Types . readUByte ( buf , offset + 1 ) ; tint dw3 = Types . readUByte ( buf , offset + 2 ) ; tint dw4 = Types . readUByte ( buf , offset + 3 ) ; tint dw5 = Types . readUByte ( buf , offset + 4 ) ; return time.getTime(); 
public boolean isSearchEnabled ( ) { tPwGroupV4 group = this ; twhile ( group ! = null ) { tBoolean search = group . enableSearching ; tif ( search ! = null ) { treturn search ; } tgroup = group . parent ; } } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tfileHistory = new RecentFileHistory ( this ) ; } 
public void onTerminate ( ) { tif ( db ! = null ) { tdb . clear ( ) ; } tsuper . onTerminate ( ) ; } 
private void saveFileData ( String fileName , String key ) { tif ( ! mRememberKeyfile ) { tkey = " " ; } tApp . getFileHistory ( ) . createFile ( fileName , key ) ; } 
public static boolean deleteDatabase ( Context ctx ) { tFile file = ctx . getDatabasePath ( DATABASE_NAME ) ; if ( file = = null ) { throw new IllegalArgumentException ( " file must not be null " ) ; } boolean deleted = false ; deleted | = file . delete ( ) ; deleted | = new File ( file . getPath ( ) + " -journal " ) . delete ( ) ; deleted | = new File ( file . getPath ( ) + " -shm " ) . delete ( ) ; deleted | = new File ( file . getPath ( ) + " -wal " ) . delete ( ) ; File dir = file . getParentFile ( ) ; if ( dir ! = null ) { final String prefix = file . getName ( ) + " -mj " ; final FileFilter filter = new FileFilter ( ) { @Override public boolean accept ( File candidate ) { return candidate . getName ( ) . startsWith ( prefix ) ; } } ; for ( File masterJournal : dir . listFiles ( filter ) ) { deleted | = masterJournal . delete ( ) ; } } return deleted ; } 
public boolean accept ( File candidate ) { return candidate . getName ( ) . startsWith ( prefix ) ; } 
private void fillData ( ) { 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tsuper . onListItemClick ( l , v , position , id ) ; tString fileName = fileHistory . getDatabaseAt ( position ) ; tString keyFile = fileHistory . getKeyfileAt ( position ) ; ttry { tPasswordActivity . Launch ( this , fileName , keyFile ) ; 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
private void refreshList ( ) { @SuppressWarnings ( " unchecked " ) tArrayAdapter < String > adapter = ( ArrayAdapter < String > ) getListAdapter ( ) ; tadapter . notifyDataSetChanged ( ) ; / * 
private void init ( ) { tif ( databases = = null | | keyfiles = = null ) { tif ( ! upgradeFromSQL ( ) ) { 
private boolean upgradeFromSQL ( ) { ttry { } 
private boolean sqlDatabaseExists ( ) { tFile db = ctx . getDatabasePath ( FileDbHelper . DATABASE_NAME ) ; treturn db . exists ( ) ; } 
public void createFile ( String fileName , String keyFile ) { tinit ( ) ; } 
public boolean hasRecentFiles ( ) { tinit ( ) ; treturn databases . size ( ) > 0 ; } 
private void loadPrefs ( ) { tdatabases = loadList ( DB_KEY ) ; tkeyfiles = loadList ( KEYFILE_KEY ) ; } 
private void savePrefs ( ) { tsaveList ( DB_KEY , databases ) ; tsaveList ( KEYFILE_KEY , keyfiles ) ; } 
private List < String > loadList ( String keyprefix ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tint size = prefs . getInt ( keyprefix , 0 ) ; tList < String > list = new ArrayList < String > ( ) ; tfor ( int i = 0 ; i < size ; i + + ) { tlist . add ( prefs . getString ( keyprefix + " _ " + i , " " ) ) ; } treturn list ; } 
private void saveList ( String keyprefix , List < String > list ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tSharedPreferences . Editor edit = prefs . edit ( ) ; tint size = list . size ( ) ; tedit . putInt ( keyprefix , size ) ; tfor ( int i = 0 ; i < size ; i + + ) { tedit . putString ( keyprefix + " _ " + i , list . get ( i ) ) ; } tEditorCompat . apply ( edit ) ; } 
public void deleteFile ( String filename ) { tdeleteFile ( filename , true ) ; } 
public void deleteFile ( String filename , boolean save ) { tinit ( ) ; tfor ( int i = 0 ; i < databases . size ( ) ; i + + ) { tif ( filename . equals ( databases . get ( i ) ) ) { tdatabases . remove ( i ) ; tkeyfiles . remove ( i ) ; tbreak ; } } tif ( save ) { tsavePrefs ( ) ; 
public void deleteAllKeys ( ) { tinit ( ) ; tkeyfiles . clear ( ) ; tint size = databases . size ( ) ; tfor ( int i = 0 ; i < size ; i + + ) { tkeyfiles . add ( " " ) ; } tsavePrefs ( ) ; } 
private void trimLists ( ) { tint size = databases . size ( ) ; tfor ( int i = FileDbHelper . MAX_FILES ; i < size ; i + + ) { tdatabases . remove ( i ) ; 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tBoolean value = ( Boolean ) newValue ; tif ( ! value . booleanValue ( ) ) { tApp . getFileHistory ( ) . deleteAllKeys ( ) ; } treturn true ; } 
public void onClick ( View view ) { tString pass = getEditText ( R . id . password ) ; tString key = getEditText ( R . id . pass_keyfile ) ; tloadDatabase ( pass , key ) ; } 
private void loadDatabase ( String pass , String keyfile ) { tif ( pass . length ( ) = = 0 & & keyfile . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . filename ) ; } 
private boolean upgradeFromSQL ( ) { ttry { } 
public void createFile ( String fileName , String keyFile ) { tif ( ! enabled ) return ; tinit ( ) ; } 
public boolean hasRecentFiles ( ) { tif ( ! enabled ) return false ; tinit ( ) ; treturn databases . size ( ) > 0 ; } 
private void loadPrefs ( ) { tloadList ( databases , DB_KEY ) ; tloadList ( keyfiles , KEYFILE_KEY ) ; } 
private void loadList ( List < String > list , String keyprefix ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tint size = prefs . getInt ( keyprefix , 0 ) ; tlist . clear ( ) ; tfor ( int i = 0 ; i < size ; i + + ) { tlist . add ( prefs . getString ( keyprefix + " _ " + i , " " ) ) ; 
public void deleteAll ( ) { tinit ( ) ; tdatabases . clear ( ) ; tkeyfiles . clear ( ) ; tsavePrefs ( ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tBoolean value = ( Boolean ) newValue ; tif ( value = = null ) { tvalue = true ; } tif ( ! value ) { tApp . getFileHistory ( ) . deleteAll ( ) ; } treturn true ; } 
public void testDate ( ) { tCalendar cal = Calendar . getInstance ( ) ; tCalendar expected = Calendar . getInstance ( ) ; texpected . set ( 2008 , 1 , 2 , 3 , 4 , 5 ) ; tbyte [ ] buf = PwDate . writeTime ( expected . getTime ( ) , cal ) ; tCalendar actual = Calendar . getInstance ( ) ; tactual . setTime ( PwDate . readTime ( buf , 0 , cal ) ) ; tassertEquals ( " Year mismatch: " , 2008 , actual . get ( Calendar . YEAR ) ) ; tassertEquals ( " Month mismatch: " , 1 , actual . get ( Calendar . MONTH ) ) ; tassertEquals ( " Day mismatch: " , 1 , actual . get ( Calendar . DAY_OF_MONTH ) ) ; tassertEquals ( " Hour mismatch: " , 3 , actual . get ( Calendar . HOUR_OF_DAY ) ) ; tassertEquals ( " Minute mismatch: " , 4 , actual . get ( Calendar . MINUTE ) ) ; tassertEquals ( " Second mismatch: " , 5 , actual . get ( Calendar . SECOND ) ) ; } 
public void onClick ( View v ) { tIntent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; ti . setType ( " file/* " ) ; ttry { tstartActivityForResult ( i , GET_CONTENT ) ; 
private void fillData ( ) { } 
private void refreshList ( ) { @SuppressWarnings ( " unchecked " ) tArrayAdapter < String > adapter = ( ArrayAdapter < String > ) getListAdapter ( ) ; tadapter . notifyDataSetChanged ( ) ; } 
private void loadPrefs ( ) { tif ( databases = = null ) { tdatabases = new ArrayList < String > ( ) ; } tif ( keyfiles = = null ) { tkeyfiles = new ArrayList < String > ( ) ; } tloadList ( databases , DB_KEY ) ; tloadList ( keyfiles , KEYFILE_KEY ) ; } 
private void init ( ) { tif ( ! init ) { tif ( ! upgradeFromSQL ( ) ) { 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tString filename = null ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tfilename = data . getDataString ( ) ; tif ( filename ! = null ) { tif ( filename . startsWith ( " file: " ) ) { tfilename = filename . substring ( 7 ) ; } tfilename = URLDecoder . decode ( filename ) ; } } telse if ( requestCode = = GET_CONTENT & & resultCode = = RESULT_OK ) { tif ( data ! = null ) { tUri uri = data . getData ( ) ; tif ( uri ! = null ) { tfilename = uri . getPath ( ) ; } } } tif ( filename ! = null ) { tEditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public void onCreate ( ) { tsuper . onCreate ( ) ; tfileHistory = new RecentFileHistory ( this ) ; tPRNGFixes . apply ( ) ; } 
public static void apply ( ) { ttry { tif ( supportedOnThisDevice ( ) ) { 
private static boolean supportedOnThisDevice ( ) { tFile urandom = new File ( " /dev/urandom " ) ; treturn urandom . canRead ( ) & & urandom . canWrite ( ) ; } 
private static void applyOpenSSLFix ( ) throws SecurityException { if ( ( sdkVersion < VERSION_CODE_JELLY_BEAN ) | | ( sdkVersion > VERSION_CODE_JELLY_BEAN_MR2 ) ) { No need to apply the fix return; } try { Mix in the device- and invocation-specific seed. 
protected void engineSetSeed ( byte [ ] bytes ) { try { OutputStream out ; 
protected void engineNextBytes ( byte [ ] bytes ) { if ( ! mSeeded ) { Mix in the device- and invocation-specific seed. engineSetSeed(generateSeed()); } try { DataInputStream in; 
protected byte [ ] engineGenerateSeed ( int size ) { byte [ ] seed = new byte [ size ] ; engineNextBytes ( seed ) ; return seed ; } 
private static byte [ ] generateSeed ( ) { try { ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream ( ) ; 
private static boolean supportedOnThisDevice ( ) { tFile urandom = new File ( " /dev/urandom " ) ; 
private static boolean supportedOnThisDevice ( ) { if ( sdkVersion > VERSION_CODE_JELLY_BEAN_MR2 ) { return false ; } if ( onSELinuxEnforce ( ) ) { treturn false ; } tFile urandom = new File ( " /dev/urandom " ) ; 
private static boolean onSELinuxEnforce ( ) { ttry { tProcessBuilder builder = new ProcessBuilder ( " getenforce " ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tIntent i = getIntent ( ) ; tprefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; tmRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; tnew InitTask ( ) . execute ( i ) ; } 
tprotected Integer doInBackground ( Intent . . . args ) { tIntent i = args [ 0 ] ; tString action = i . getAction ( ) ; ; tif ( action ! = null & & action . equals ( VIEW_INTENT ) ) { tmFileName = i . getDataString ( ) ; tif ( ! mFileName . substring ( 0 , 7 ) . equals ( " file:} 
public void onCheckedChanged ( CompoundButton buttonView , tboolean isChecked ) { tTextView password = ( TextView ) findViewById ( R . id . password ) ; tif ( isChecked ) { tpassword . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
public void onClick ( View v ) { tIntent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; ti . setType ( " file/* " ) ; ttry { tstartActivityForResult ( i , GET_CONTENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { tif ( Interaction . isIntentAvailable ( PasswordActivity . this , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { tIntent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { tBrowserDialog diag = new BrowserDialog ( PasswordActivity . this ) ; tdiag . show ( ) ; } 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tsuper . onListItemClick ( l , v , position , id ) ; tnew AsyncTask < Integer , Void , Void > ( ) { tString fileName ; 
tprotected Void doInBackground ( Integer . . . args ) { tint position = args [ 0 ] ; tfileName = fileHistory . getDatabaseAt ( position ) ; tkeyFile = fileHistory . getKeyfileAt ( position ) ; treturn null ; } 
tprotected void onPostExecute ( Void v ) { ttry { tPasswordActivity . Launch ( FileSelectActivity . this , fileName , keyFile ) ; 
tprotected java . lang . Void doInBackground ( String . . . args ) { tString filename = args [ 0 ] ; tfileHistory . deleteFile ( filename ) ; treturn null ; } 
tprotected void onPostExecute ( Void v ) { trefreshList ( ) ; } 
private synchronized void init ( ) { tif ( ! init ) { tif ( ! upgradeFromSQL ( ) ) { 
private boolean searchStrings ( PwEntry entry , String term ) { tEntrySearchStringIterator iter = EntrySearchStringIterator . getInstance ( entry , sp ) ; twhile ( iter . hasNext ( ) ) { tString str = iter . next ( ) ; tif ( str ! = null & str . length ( ) > 0 ) { tif ( sp . ignoreCase ) { tstr = str . toLowerCase ( ) ; } tif ( str . indexOf ( term ) > = 0 ) { treturn true ; } } } treturn false ; } 
tprotected boolean searchID ( PwEntry e ) { tPwEntryV4 entry = ( PwEntryV4 ) e ; tif ( sp . searchInUUIDs ) { tString hex = UuidUtil . toHexString ( entry . uuid ) ; treturn StrUtil . indexOfIgnoreCase ( hex , sp . searchString ) > = 0 ; } treturn false ; } 
public void touchLocation ( ) { } public abstract void setParent ( PwGroup parent ) ; public boolean isSearchingEnabled ( ) { treturn false ; } } 
public abstract void setParent ( PwGroup parent ) ; public boolean isSearchingEnabled ( ) { treturn false ; } } 
public boolean isSearchingEnabled ( ) { tif ( parent ! = null ) { treturn parent . isSearchEnabled ( ) ; } treturn PwGroupV4 . DEFAULT_SEARCHING_ENABLED ; } 
public abstract void setLastAccessTime ( Date date ) ; public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } public boolean isContainedIn ( PwGroup container ) { tPwGroup cur = this ; twhile ( cur ! = null ) { tif ( cur = = container ) { treturn true ; } tcur = cur . getParent ( ) ; } treturn false ; } public void touch ( boolean modified , boolean touchParents ) { tDate now = new Date ( ) ; tsetLastAccessTime ( now ) ; tif ( modified ) { tsetLastModificationTime ( now ) ; } tPwGroup parent = getParent ( ) ; tif ( touchParents & & parent ! = null ) { tparent . touch ( modified , true ) ; } } public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { tif ( sp = = null ) { return ; } tif ( listStorage = = null ) { return ; } tList < String > terms = StrUtil . splitSearchTerms ( sp . searchString ) ; tif ( terms . size ( ) < = 1 | | sp . regularExpression ) { tsearchEntriesSingle ( sp , listStorage ) ; treturn ; } }} 
public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } public boolean isContainedIn ( PwGroup container ) { tPwGroup cur = this ; twhile ( cur ! = null ) { tif ( cur = = container ) { treturn true ; } tcur = cur . getParent ( ) ; } treturn false ; } public void touch ( boolean modified , boolean touchParents ) { tDate now = new Date ( ) ; tsetLastAccessTime ( now ) ; tif ( modified ) { tsetLastModificationTime ( now ) ; } tPwGroup parent = getParent ( ) ; tif ( touchParents & & parent ! = null ) { tparent . touch ( modified , true ) ; } } public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { tif ( sp = = null ) { return ; } tif ( listStorage = = null ) { return ; } tList < String > terms = StrUtil . splitSearchTerms ( sp . searchString ) ; tif ( terms . size ( ) < = 1 | | sp . regularExpression ) { tsearchEntriesSingle ( sp , listStorage ) ; treturn ; } }} 
public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { tif ( sp = = null ) { return ; } tif ( listStorage = = null ) { return ; } tList < String > terms = StrUtil . splitSearchTerms ( sp . searchString ) ; tif ( terms . size ( ) < = 1 | | sp . regularExpression ) { tsearchEntriesSingle ( sp , listStorage ) ; treturn ; } sp.searchString = fullSearch; 
public int compare ( String lhs , String rhs ) { treturn lhs . length ( ) - rhs . length ( ) ; } 
private boolean searchEntriesSingle ( SearchParameters spIn , List < PwEntry > listStorage ) { tSearchParameters sp = ( SearchParameters ) spIn . clone ( ) ; tEntryHandler < PwEntry > eh ; tif ( sp . searchString . length ( ) < = 0 ) { teh = new EntrySearchHandlerAll ( sp , listStorage ) ; } else { teh = EntrySearchHandler . getInstance ( this , sp , listStorage ) ; } tif ( ! preOrderTraverseTree ( null , eh ) ) { return false ; } treturn true ; } 
public boolean preOrderTraverseTree ( GroupHandler < PwGroup > groupHandler , EntryHandler < PwEntry > entryHandler ) { tif ( entryHandler ! = null ) { tfor ( PwEntry entry : childEntries ) { tif ( ! entryHandler . operate ( entry ) ) return false ; } } tfor ( PwGroup group : childGroups ) { tif ( ( groupHandler ! = null ) & & ! groupHandler . operate ( group ) ) return false ; tgroup . preOrderTraverseTree ( groupHandler , entryHandler ) ; } treturn true ; 
public void setupNone ( ) { tsearchInTitles = false ; tsearchInUserNames = false ; tsearchInPasswords = false ; tsearchInUrls = false ; tsearchInGroupNames = false ; tsearchInNotes = false ; } 
public void setupNone ( ) { tsuper . setupNone ( ) ; tsearchInOther = false ; tsearchInUUIDs = false ; tsearchInTags = false ; } 
public String next ( ) { } 
private void useSearchParameters ( ) { tif ( sp = = null ) { return ; } tboolean found = false ; twhile ( ! found ) { switch ( current ) { 
private void advance ( ) { twhile ( setIterator . hasNext ( ) ) { tEntry < String , ProtectedString > entry = setIterator . next ( ) ; tString key = entry . getKey ( ) ; tif ( searchInField ( key ) ) { tcurrent = entry . getValue ( ) . toString ( ) ; treturn ; } } tcurrent = null ; } 
private boolean searchInField ( String key ) { tif ( key . equals ( PwEntryV4 . STR_TITLE ) ) { treturn sp . searchInTitles ; 
public boolean operate ( PwGroup g ) { tPwGroupV4 group = ( PwGroupV4 ) g ; tassert ( group ! = null ) ; twhile ( true ) { ttry { tif ( group . parent = = groupStack . peek ( ) ) { tgroupStack . push ( group ) ; tstartGroup ( group ) ; tbreak ; } else { tgroupStack . pop ( ) ; tif ( groupStack . size ( ) < = 0 ) return false ; tendGroup ( ) ; } } catch ( IOException e ) { tthrow new RuntimeException ( e ) ; } } treturn true ; } 
public boolean operate ( PwEntry e ) { tPwEntryV4 entry = ( PwEntryV4 ) e ; tassert ( entry ! = null ) ; ttry { twriteEntry ( entry , false ) ; } catch ( IOException ex ) { tthrow new RuntimeException ( ex ) ; } treturn true ; } 
public String compile ( String text , PwEntry entry , PwDatabase database ) { treturn text ; } 
public String compile ( String text , PwEntry entry , PwDatabase database ) { tSprContextV4 ctx = new SprContextV4 ( ( PwDatabaseV4 ) database , ( PwEntryV4 ) entry ) ; treturn compileInternal ( text , ctx , 0 ) ; } 
private String compileInternal ( String text , SprContextV4 ctx , int recursionLevel ) { tif ( text = = null ) { return " " ; } tif ( ctx = = null ) { return " " ; } tif ( recursionLevel > = MAX_RECURSION_DEPTH ) { return " " ; } treturn fillRefPlaceholders ( text , ctx , recursionLevel ) ; } 
private String fillRefPlaceholders ( String text , SprContextV4 ctx , int recursionLevel ) { tif ( ctx . db = = null ) { return text ; } tint offset = 0 ; tfor ( int i = 0 ; i < 20 ; + + i ) { tint start = StrUtil . indexOfIgnoreCase ( text , STR_REF_START , offset ) ; tif ( start < 0 ) { break ; } tint end = StrUtil . indexOfIgnoreCase ( text , STR_REF_END , start + 1 ) ; tif ( end < 0 ) { break ; } tString fullRef = text . substring ( start , end - start + 1 ) ; tTargetResult result = findRefTarget ( fullRef , ctx ) ; tif ( result ! = null ) { PwEntryV4 found = result . entry ; char wanted = result . wanted ; if ( found ! = null ) { tString data ; tswitch ( wanted ) { tcase 'T' : tdata = found . getTitle ( ) ; tbreak ; tcase 'U' : tdata = found . getUsername ( ) ; tbreak ; tcase 'A' : tdata = found . getUrl ( ) ; tbreak ; tcase 'P' : tdata = found . getPassword ( ) ; tbreak ; tcase 'N' : tdata = found . getNotes ( ) ; tbreak ; tcase 'I' : tdata = found . getUUID ( ) . toString ( ) ; tbreak ; tdefault : toffset = start + 1 ; tcontinue ; } tSprContextV4 subCtx = ( SprContextV4 ) ctx . clone ( ) ; tsubCtx . entry = found ; tString innerContent = compileInternal ( data , subCtx , recursionLevel + 1 ) ; taddRefsToCache ( fullRef , innerContent , ctx ) ; ttext = fillRefsUsingCache ( text , ctx ) ; } } } treturn text ; } 
public TargetResult findRefTarget ( String fullRef , SprContextV4 ctx ) { tif ( fullRef = = null ) { return null ; } tfullRef = fullRef . toUpperCase ( ) ; tif ( ! fullRef . startsWith ( STR_REF_START ) | | ! fullRef . endsWith ( STR_REF_END ) ) { treturn null ; } tString ref = fullRef . substring ( STR_REF_START . length ( ) , fullRef . length ( ) - STR_REF_START . length ( ) - STR_REF_END . length ( ) ) ; tif ( ref . length ( ) < = 4 ) { return null ; } tif ( ref . charAt ( 1 ) ! = '@' ) { return null ; } tif ( ref . charAt ( 3 ) ! = ':' ) { return null ; } tchar scan = Character . MIN_VALUE ; tchar wanted = Character . MIN_VALUE ; tscan = Character . toUpperCase ( ref . charAt ( 2 ) ) ; twanted = Character . toUpperCase ( ref . charAt ( 0 ) ) ; tSearchParametersV4 sp = new SearchParametersV4 ( ) ; tsp . setupNone ( ) ; tsp . searchString = ref . substring ( 4 ) ; tif ( scan = = 'T' ) { sp . searchInTitles = true ; } telse if ( scan = = 'U' ) { sp . searchInUserNames = true ; } telse if ( scan = = 'A' ) { sp . searchInUrls = true ; } telse if ( scan = = 'P' ) { sp . searchInPasswords = true ; } telse if ( scan = = 'N' ) { sp . searchInNotes = true ; } telse if ( scan = = 'I' ) { sp . searchInUUIDs = true ; } telse if ( scan = = 'O' ) { sp . searchInOther = true ; } telse { return null ; } tList < PwEntry > list = new ArrayList < PwEntry > ( ) ; tctx . db . rootGroup . searchEntries ( sp , list ) ; tif ( list . size ( ) > 0 ) { treturn new TargetResult ( ( PwEntryV4 ) list . get ( 0 ) , wanted ) ; } treturn null ; } 
private void addRefsToCache ( String ref , String value , SprContextV4 ctx ) { tif ( ref = = null ) { return ; } tif ( value = = null ) { return ; } tif ( ctx = = null ) { return ; } tif ( ! ctx . refsCache . containsKey ( ref ) ) { tctx . refsCache . put ( ref , value ) ; 
private String fillRefsUsingCache ( String text , SprContextV4 ctx ) { tfor ( Entry < String , String > entry : ctx . refsCache . entrySet ( ) ) { ttext = StrUtil . replaceAllIgnoresCase ( text , entry . getKey ( ) , entry . getValue ( ) ) ; } treturn text ; 
public static List < String > splitSearchTerms ( String search ) { tList < String > list = new ArrayList < String > ( ) ; tif ( search = = null ) { return list ; } tStringBuilder sb = new StringBuilder ( ) ; tboolean quoted = false ; tfor ( int i = 0 ; i < search . length ( ) ; i + + ) { tchar ch = search . charAt ( i ) ; tif ( ( ( ch = = ' ' ) | | ( ch = = '' ) | | ( ch = = '\r' ) | | ( ch = = '' ) ) & & ! quoted ) { tint len = sb . length ( ) ; tif ( len > 0 ) { tlist . add ( sb . toString ( ) ) ; tsb . delete ( 0 , len ) ; } telse if ( ch = = '\"' ) { tquoted = ! quoted ; } telse { tsb . append ( ch ) ; } } } tif ( sb . length ( ) > 0 ) { tlist . add ( sb . toString ( ) ) ; } treturn list ; } 
public static int indexOfIgnoreCase ( String text , String search , int start ) { tif ( text = = null | | search = = null ) return - 1 ; treturn text . toLowerCase ( ) . indexOf ( search . toLowerCase ( ) , start ) ; } 
public static int indexOfIgnoreCase ( String text , String search ) { treturn indexOfIgnoreCase ( text , search , 0 ) ; } 
public static String replaceAllIgnoresCase ( String text , String find , String newText ) { tif ( text = = null | | find = = null | | newText = = null ) { return text ; } tint pos = 0 ; twhile ( pos < text . length ( ) ) { tpos = indexOfIgnoreCase ( text , find , pos ) ; tif ( pos < 0 ) { break ; } tString before = text . substring ( 0 , pos ) ; tString after = text . substring ( pos + find . length ( ) ) ; ttext = before . concat ( newText ) . concat ( after ) ; tpos + = newText . length ( ) ; } treturn text ; } 
public static String toHexString ( UUID uuid ) { tif ( uuid = = null ) { return null ; } tbyte [ ] buf = Types . UUIDtoBytes ( uuid ) ; tif ( buf = = null ) { return null ; } tint len = buf . length ; tif ( len = = 0 ) { return " " ; } tStringBuilder sb = new StringBuilder ( ) ; tshort bt ; tchar high , low ; tfor ( int i = 0 ; i < len ; i + + ) { tbt = ( short ) ( buf [ i ] & 0xFF ) ; thigh = ( char ) ( bt > > > 4 ) ; tlow = ( char ) ( bt & 0x0F ) ; tchar h , l ; th = byteToChar ( high ) ; tl = byteToChar ( low ) ; tsb . append ( byteToChar ( high ) ) ; tsb . append ( byteToChar ( low ) ) ; } treturn sb . toString ( ) ; } 
private static char byteToChar ( char bt ) { if ( bt > = 10 ) { return ( char ) ( 'A' + bt - 10 ) ; 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tdb = importer . openDatabase ( is , " 12345 " , " " ) ; tis . close ( ) ; tspr = SprEngine . getInstance ( db ) ; } 
public void testRefReplace ( ) { tUUID entryUUID = decodeUUID ( ENCODE_UUID ) ; tPwEntryV4 entry = ( PwEntryV4 ) db . entries . get ( entryUUID ) ; tassertEquals ( RESULT , spr . compile ( REF , entry , db ) ) ; 
private UUID decodeUUID ( String encoded ) { tif ( encoded = = null | | encoded . length ( ) = = 0 ) { treturn PwDatabaseV4 . UUID_ZERO ; } tbyte [ ] buf = Base64Coder . decode ( encoded ) ; treturn Types . bytestoUUID ( buf ) ; } 
public void testIndexOfIgnoreCase1 ( ) { tassertEquals ( 1 , StrUtil . indexOfIgnoreCase ( text , search ) ) ; } 
public void testIndexOfIgnoreCase2 ( ) { tassertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( text , search ) , 2 ) ; } 
public void testIndexOfIgnoreCase3 ( ) { tassertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( text , badSearch ) ) ; } 
public void testReplaceAllIgnoresCase1 ( ) { tassertEquals ( repResult , StrUtil . replaceAllIgnoresCase ( repText , repSearch , repNew ) ) ; } 
public void testReplaceAllIgnoresCase2 ( ) { tassertEquals ( repText , StrUtil . replaceAllIgnoresCase ( repText , repSearchBad , repNew ) ) ; } 
tprotected void fillData ( boolean trimList ) { tImageView iv = ( ImageView ) findViewById ( R . id . entry_icon ) ; tDatabase db = App . getDB ( ) ; tdb . drawFactory . assignDrawableTo ( iv , getResources ( ) , mEntry . getIcon ( ) ) ; tPwDatabase pm = db . pm ; tpopulateText ( R . id . entry_title , mEntry . getTitle ( true , pm ) ) ; tpopulateText ( R . id . entry_user_name , mEntry . getUsername ( true , pm ) ) ; tpopulateText ( R . id . entry_url , mEntry . getUrl ( true , pm ) ) ; tpopulateText ( R . id . entry_password , mEntry . getPassword ( true , pm ) ) ; tsetPasswordStyle ( ) ; tpopulateText ( R . id . entry_created , getDateTime ( mEntry . getCreationTime ( ) ) ) ; tpopulateText ( R . id . entry_modified , getDateTime ( mEntry . getLastModificationTime ( ) ) ) ; tpopulateText ( R . id . entry_accessed , getDateTime ( mEntry . getLastAccessTime ( ) ) ) ; tDate expires = mEntry . getExpiryTime ( ) ; tif ( mEntry . expires ( ) ) { tpopulateText ( R . id . entry_expires , getDateTime ( expires ) ) ; } else { tpopulateText ( R . id . entry_expires , R . string . never ) ; } tpopulateText ( R . id . entry_comment , mEntry . getNotes ( true , pm ) ) ; 
tprotected void fillData ( boolean trimList ) { tsuper . fillData ( trimList ) ; tViewGroup group = ( ViewGroup ) findViewById ( R . id . extra_strings ) ; tif ( trimList ) { tgroup . removeAllViews ( ) ; } tPwEntryV4 entry = ( PwEntryV4 ) mEntry ; tPwDatabase pm = App . getDB ( ) . pm ; tSprEngine spr = SprEngineV4 . getInstance ( pm ) ; for (Map.Entry<String, ProtectedString> pair : entry.strings.entrySet()) { 
private String decodeRefKey ( boolean decodeRef , String key , PwDatabase db ) { tString text = getString ( key ) ; tif ( decodeRef ) { ttext = decodeRef ( text , db ) ; } treturn text ; } 
private String decodeRef ( String text , PwDatabase db ) { tif ( db = = null ) { return text ; } tSprEngine spr = SprEngine . getInstance ( db ) ; treturn spr . compile ( text , this , db ) ; } 
private String fillRefPlaceholders ( String text , SprContextV4 ctx , int recursionLevel ) { tif ( ctx . db = = null ) { return text ; } tint offset = 0 ; tfor ( int i = 0 ; i < 20 ; + + i ) { ttext = fillRefsUsingCache ( text , ctx ) ; tint start = StrUtil . indexOfIgnoreCase ( text , STR_REF_START , offset ) ; tif ( start < 0 ) { break ; } tint end = StrUtil . indexOfIgnoreCase ( text , STR_REF_END , start + 1 ) ; tif ( end < = start ) { break ; } tString fullRef = text . substring ( start , end - start + 1 ) ; tTargetResult result = findRefTarget ( fullRef , ctx ) ; tif ( result ! = null ) { PwEntryV4 found = result . entry ; char wanted = result . wanted ; if ( found ! = null ) { tString data ; tswitch ( wanted ) { tcase 'T' : tdata = found . getTitle ( ) ; tbreak ; tcase 'U' : tdata = found . getUsername ( ) ; tbreak ; tcase 'A' : tdata = found . getUrl ( ) ; tbreak ; tcase 'P' : tdata = found . getPassword ( ) ; tbreak ; tcase 'N' : tdata = found . getNotes ( ) ; tbreak ; tcase 'I' : tdata = found . getUUID ( ) . toString ( ) ; tbreak ; tdefault : toffset = start + 1 ; tcontinue ; } tSprContextV4 subCtx = ( SprContextV4 ) ctx . clone ( ) ; tsubCtx . entry = found ; tString innerContent = compileInternal ( data , subCtx , recursionLevel + 1 ) ; taddRefsToCache ( fullRef , innerContent , ctx ) ; ttext = fillRefsUsingCache ( text , ctx ) ; } else { toffset = start + 1 ; tcontinue ; } } } treturn text ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tIntent i = getIntent ( ) ; tprefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; tmRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; tsetContentView ( R . layout . password ) ; tnew InitTask ( ) . execute ( i ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , FileNotFoundException , InvalidDBException { tFile file = new File ( filename ) ; tFileInputStream fis = new FileInputStream ( file ) ; tLoadData ( ctx , fis , password , keyfile , status , debug ) ; treadOnly = ! file . canWrite ( ) ; tmFilename = filename ; } 
tprotected void setupButtons ( ) { taddGroupEnabled = ! readOnly ; } 
tprotected void setupButtons ( ) { tsuper . setupButtons ( ) ; taddEntryEnabled = ! isRoot & & ! readOnly ; } 
tprotected void setupButtons ( ) { tsuper . setupButtons ( ) ; taddEntryEnabled = ! readOnly ; } 
public void onClick ( DialogInterface dialog , int which ) { tContext ctx = getContext ( ) ; tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tSharedPreferences . Editor edit = prefs . edit ( ) ; tedit . putBoolean ( ctx . getString ( showKey ) , false ) ; tedit . commit ( ) ; tdismiss ( ) ; } 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tmenu . add ( 0 , MENU_OPEN , 0 , R . string . menu_open ) ; tif ( ! readOnly ) { menu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; 
public void onCreateMenu ( ContextMenu menu , ContextMenuInfo menuInfo ) { tsuper . onCreateMenu ( menu , menuInfo ) ; tif ( ! readOnly ) { menu . add ( 0 , MENU_DELETE , 0 , R . string . menu_delete ) ; 
private static void applyOpenSSLFix ( ) throws SecurityException { if ( ( sdkVersion < BuildCompat . VERSION_CODE_JELLY_BEAN ) | | ( sdkVersion > BuildCompat . VERSION_CODE_JELLY_BEAN_MR2 ) ) { No need to apply the fix return; } try { Mix in the device- and invocation-specific seed. 
tprotected boolean searchID ( PwEntry e ) { tPwEntryV4 entry = ( PwEntryV4 ) e ; tif ( sp . searchInUUIDs ) { tString hex = UuidUtil . toHexString ( entry . uuid ) ; treturn StrUtil . indexOfIgnoreCase ( hex , sp . searchString , Locale . ENGLISH ) > = 0 ; } treturn false ; } 
private String fillRefPlaceholders ( String text , SprContextV4 ctx , int recursionLevel ) { tif ( ctx . db = = null ) { return text ; } tint offset = 0 ; tfor ( int i = 0 ; i < 20 ; + + i ) { ttext = fillRefsUsingCache ( text , ctx ) ; tint start = StrUtil . indexOfIgnoreCase ( text , STR_REF_START , offset , Locale . ENGLISH ) ; tif ( start < 0 ) { break ; } tint end = StrUtil . indexOfIgnoreCase ( text , STR_REF_END , start + 1 , Locale . ENGLISH ) ; tif ( end < = start ) { break ; } tString fullRef = text . substring ( start , end - start + 1 ) ; tTargetResult result = findRefTarget ( fullRef , ctx ) ; tif ( result ! = null ) { PwEntryV4 found = result . entry ; char wanted = result . wanted ; if ( found ! = null ) { tString data ; tswitch ( wanted ) { tcase 'T' : tdata = found . getTitle ( ) ; tbreak ; tcase 'U' : tdata = found . getUsername ( ) ; tbreak ; tcase 'A' : tdata = found . getUrl ( ) ; tbreak ; tcase 'P' : tdata = found . getPassword ( ) ; tbreak ; tcase 'N' : tdata = found . getNotes ( ) ; tbreak ; tcase 'I' : tdata = found . getUUID ( ) . toString ( ) ; tbreak ; tdefault : toffset = start + 1 ; tcontinue ; } tSprContextV4 subCtx = ( SprContextV4 ) ctx . clone ( ) ; tsubCtx . entry = found ; tString innerContent = compileInternal ( data , subCtx , recursionLevel + 1 ) ; taddRefsToCache ( fullRef , innerContent , ctx ) ; ttext = fillRefsUsingCache ( text , ctx ) ; } else { toffset = start + 1 ; tcontinue ; } } } treturn text ; } 
public TargetResult findRefTarget ( String fullRef , SprContextV4 ctx ) { tif ( fullRef = = null ) { return null ; } tfullRef = fullRef . toUpperCase ( Locale . ENGLISH ) ; tif ( ! fullRef . startsWith ( STR_REF_START ) | | ! fullRef . endsWith ( STR_REF_END ) ) { treturn null ; } tString ref = fullRef . substring ( STR_REF_START . length ( ) , fullRef . length ( ) - STR_REF_START . length ( ) - STR_REF_END . length ( ) ) ; tif ( ref . length ( ) < = 4 ) { return null ; } tif ( ref . charAt ( 1 ) ! = '@' ) { return null ; } tif ( ref . charAt ( 3 ) ! = ':' ) { return null ; } tchar scan = Character . MIN_VALUE ; tchar wanted = Character . MIN_VALUE ; tscan = Character . toUpperCase ( ref . charAt ( 2 ) ) ; twanted = Character . toUpperCase ( ref . charAt ( 0 ) ) ; tSearchParametersV4 sp = new SearchParametersV4 ( ) ; tsp . setupNone ( ) ; tsp . searchString = ref . substring ( 4 ) ; tif ( scan = = 'T' ) { sp . searchInTitles = true ; } telse if ( scan = = 'U' ) { sp . searchInUserNames = true ; } telse if ( scan = = 'A' ) { sp . searchInUrls = true ; } telse if ( scan = = 'P' ) { sp . searchInPasswords = true ; } telse if ( scan = = 'N' ) { sp . searchInNotes = true ; } telse if ( scan = = 'I' ) { sp . searchInUUIDs = true ; } telse if ( scan = = 'O' ) { sp . searchInOther = true ; } telse { return null ; } tList < PwEntry > list = new ArrayList < PwEntry > ( ) ; tctx . db . rootGroup . searchEntries ( sp , list ) ; tif ( list . size ( ) > 0 ) { treturn new TargetResult ( ( PwEntryV4 ) list . get ( 0 ) , wanted ) ; } treturn null ; } 
private String fillRefsUsingCache ( String text , SprContextV4 ctx ) { tfor ( Entry < String , String > entry : ctx . refsCache . entrySet ( ) ) { ttext = StrUtil . replaceAllIgnoresCase ( text , entry . getKey ( ) , entry . getValue ( ) , Locale . ENGLISH ) ; } treturn text ; 
public static int indexOfIgnoreCase ( String text , String search , int start , Locale locale ) { tif ( text = = null | | search = = null ) return - 1 ; treturn text . toLowerCase ( locale ) . indexOf ( search . toLowerCase ( locale ) , start ) ; } 
public static int indexOfIgnoreCase ( String text , String search , Locale locale ) { treturn indexOfIgnoreCase ( text , search , 0 , locale ) ; } 
public static String replaceAllIgnoresCase ( String text , String find , String newText , Locale locale ) { tif ( text = = null | | find = = null | | newText = = null ) { return text ; } tint pos = 0 ; twhile ( pos < text . length ( ) ) { tpos = indexOfIgnoreCase ( text , find , pos , locale ) ; tif ( pos < 0 ) { break ; } tString before = text . substring ( 0 , pos ) ; tString after = text . substring ( pos + find . length ( ) ) ; ttext = before . concat ( newText ) . concat ( after ) ; tpos + = newText . length ( ) ; } treturn text ; } 
public void testIndexOfIgnoreCase1 ( ) { tassertEquals ( 1 , StrUtil . indexOfIgnoreCase ( text , search , Locale . ENGLISH ) ) ; } 
public void testIndexOfIgnoreCase2 ( ) { tassertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( text , search , Locale . ENGLISH ) , 2 ) ; } 
public void testIndexOfIgnoreCase3 ( ) { tassertEquals ( - 1 , StrUtil . indexOfIgnoreCase ( text , badSearch , Locale . ENGLISH ) ) ; } 
public void testReplaceAllIgnoresCase1 ( ) { tassertEquals ( repResult , StrUtil . replaceAllIgnoresCase ( repText , repSearch , repNew , Locale . ENGLISH ) ) ; } 
public void testReplaceAllIgnoresCase2 ( ) { tassertEquals ( repText , StrUtil . replaceAllIgnoresCase ( repText , repSearchBad , repNew , Locale . ENGLISH ) ) ; } 
public void outputStart ( ) throws IOException { tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature1 ) ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . signature2 ) ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . flags ) ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . version ) ) ; tmOS . write ( mHeader . masterSeed ) ; tmOS . write ( mHeader . encryptionIV ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numGroups ) ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numEntries ) ) ; } 
public void outputContentHash ( ) throws IOException { tmOS . write ( mHeader . contentsHash ) ; } 
public void outputEnd ( ) throws IOException { tmOS . write ( mHeader . transformSeed ) ; tmOS . write ( LEDataOutputStream . writeIntBuf ( mHeader . numKeyEncRounds ) ) ; } 
public void output ( ) throws IOException { toutputStart ( ) ; toutputContentHash ( ) ; toutputEnd ( ) ; } 
public void outputPlanGroupAndEntries ( OutputStream os ) throws PwDbOutputException { tLEDataOutputStream los = new LEDataOutputStream ( os ) ; tif ( useHeaderHash ( ) & & headerHashBlock ! = null ) { try { los . writeUShort ( 0x0000 ) ; los . writeInt ( headerHashBlock . length ) ; los . write ( headerHashBlock ) ; } catch ( IOException e ) { throw new PwDbOutputException ( " Failed to output header hash: " + e . getMessage ( ) ) ; } } PwEntryV3 pe = (PwEntryV3) mPM.entries.get(i); 
private void writeExtData ( byte [ ] headerDigest , OutputStream os ) throws IOException { tLEDataOutputStream los = new LEDataOutputStream ( os ) ; writeExtDataField ( los , 0x0001 , headerDigest , headerDigest . length ) ; byte [ ] headerRandom = new byte [ 32 ] ; SecureRandom rand = new SecureRandom ( ) ; rand . nextBytes ( headerRandom ) ; writeExtDataField ( los , 0x0002 , headerRandom , headerRandom . length ) ; writeExtDataField ( los , 0xFFFF , null , 0 ) ; 
private void writeExtDataField ( LEDataOutputStream los , int fieldType , byte [ ] data , int fieldSize ) throws IOException { tlos . writeUShort ( fieldType ) ; tlos . writeInt ( fieldSize ) ; tif ( data ! = null ) { los . write ( data ) ; 
public void testPlainContent ( ) throws IOException , PwDbOutputException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV3Output pos = new PwDbV3OutputDebug ( mPM , bos , true ) ; pos . outputPlanGroupAndEntries ( bos ) ; assertTrue ( " No output " , bos . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Group and entry output doesn't match. " , mPM . postHeader , bos . toByteArray ( ) ) ; 
public void testChecksum ( ) throws NoSuchAlgorithmException , IOException , PwDbOutputException { NullOutputStream nos = new NullOutputStream(); MessageDigest md = MessageDigest.getInstance("SHA-256"); DigestOutputStream dos = new DigestOutputStream(nos, md); PwDbV3Output pos = new PwDbV3OutputDebug(mPM, dos, true); pos.outputPlanGroupAndEntries(dos); dos.close(); byte[] digest = md.digest(); assertTrue("No output", digest.length > 0); assertArrayEquals("Hash of groups and entries failed.", mPM.dbHeader.contentsHash, digest); } 
public void testHeader ( ) throws PwDbOutputException , IOException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual , true ) ; PwDbHeaderV3 header = pActual . outputHeader ( bActual ) ; ByteArrayOutputStream bExpected = new ByteArrayOutputStream ( ) ; PwDbHeaderOutputV3 outExpected = new PwDbHeaderOutputV3 ( mPM . dbHeader , bExpected ) ; outExpected . output ( ) ; assertHeadersEquals ( mPM . dbHeader , header ) ; assertTrue ( " No output " , bActual . toByteArray ( ) . length > 0 ) ; assertArrayEquals ( " Header does not match. " , bExpected . toByteArray ( ) , bActual . toByteArray ( ) ) ; } 
public void testFinalKey ( ) throws PwDbOutputException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual , true ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void testFullWrite ( ) throws IOException , PwDbOutputException { tAssetManager am = getContext ( ) . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tgetWindow ( ) . setFlags ( LayoutParams . FLAG_SECURE , LayoutParams . FLAG_SECURE ) ; } 
public void onClick ( View v ) { tLinearLayout container = ( LinearLayout ) findViewById ( R . id . advanced_container ) ; tEntryEditSection ees = ( EntryEditSection ) inflater . inflate ( R . layout . entry_edit_section , container , false ) ; tees . setData ( " " , new ProtectedString ( false , " " ) ) ; tcontainer . addView ( ees ) ; @Override 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE); 
public boolean onCreateOptionsMenu ( Menu menu ) { tsuper . onCreateOptionsMenu ( menu ) ; tMenuInflater inflater = getMenuInflater ( ) ; tinflater . inflate ( R . menu . entry_edit , menu ) ; tMenuItem togglePassword = menu . findItem ( R . id . menu_toggle_pass ) ; tif ( mShowPassword ) { ttogglePassword . setTitle ( R . string . menu_hide_password ) ; } else { ttogglePassword . setTitle ( R . string . menu_showpass ) ; } treturn true ; } 
tprotected void onDestroy ( ) { } 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { tif ( uuid . equals ( AES_CIPHER ) ) { tCipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , androidOverride ) ; tcipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; treturn cipher ; } else if ( uuid . equals ( TWOFISH_CIPHER ) ) { tCipher cipher ; tif ( opmode = = Cipher . ENCRYPT_MODE ) { tcipher = CipherFactory . getInstance ( " TWOFISH/CBC/ZeroBytePadding " , androidOverride ) ; } else { tcipher = CipherFactory . getInstance ( " TWOFISH/CBC/NoPadding " , androidOverride ) ; } tcipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; treturn cipher ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public int addPadding ( byte [ ] in , int inOff ) { int added = ( in . length - inOff ) ; while ( inOff < in . length ) { in [ inOff ] = ( byte ) 0 ; inOff + + ; } return added ; } 
public int padCount ( byte [ ] in ) throws InvalidCipherTextException { int count = in . length ; while ( count > 0 ) { if ( in [ count - 1 ] ! = 0 ) { break ; } count - - ; } return in . length - count ; } 
public String generatePassword ( int length , boolean upperCase , boolean lowerCase , boolean digits , boolean minus , boolean underline , boolean space , boolean specials , boolean brackets ) throws IllegalArgumentException { tif ( length < = 0 ) tthrow new IllegalArgumentException ( cxt . getString ( R . string . error_wrong_length ) ) ; tif ( ! upperCase & & ! lowerCase & & ! digits & & ! minus & & ! underline & & ! space & & ! specials & & ! brackets ) tthrow new IllegalArgumentException ( cxt . getString ( R . string . error_pass_gen_type ) ) ; tString characterSet = getCharacterSet ( upperCase , lowerCase , digits , minus , underline , space , specials , brackets ) ; tint size = characterSet . length ( ) ; tStringBuffer buffer = new StringBuffer ( ) ; tSecureRandom random = new SecureRandom ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public void clear ( ) { tdirty . clear ( ) ; tdrawFactory . clear ( ) ; tpm = null ; tmFilename = null ; tloaded = false ; tpasswordEncodingError = false ; } 
private void loadDatabase ( String pass , String keyfile ) { tif ( pass . length ( ) = = 0 & & keyfile . length ( ) = = 0 ) { terrorMessage ( R . string . error_nopass ) ; treturn ; } tString fileName = getEditText ( R . id . filename ) ; } 
public void run ( ) { tif ( db . passwordEncodingError ) { tPasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { tGroupActivity . Launch ( PasswordActivity . this ) ; } 
public void onClick ( DialogInterface dialog , int which ) { tpt . run ( ) ; } 
public boolean validatePasswordEncoding ( String key ) { tString encoding = getPasswordEncoding ( ) ; tbyte [ ] bKey ; ttry { tbKey = key . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { treturn false ; } tString reencoded ; ttry { reencoded = new String ( bKey , encoding ) ; } catch ( UnsupportedEncodingException e ) { treturn false ; } treturn key . equals ( reencoded ) ; } 
public byte [ ] getPasswordKey ( String key ) throws IOException { tassert ( key ! = null ) ; tif ( key . length ( ) = = 0 ) throw new IllegalArgumentException ( " Key cannot be empty. " ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tbyte [ ] bKey ; ttry { tbKey = key . getBytes ( getPasswordEncoding ( ) ) ; } catch ( UnsupportedEncodingException e ) { tassert false ; tbKey = key . getBytes ( ) ; } tmd . update ( bKey , 0 , bKey . length ) ; treturn md . digest ( ) ; } 
public boolean validatePasswordEncoding ( String key ) { treturn true ; } 
public boolean validatePassword ( Context ctx , DialogInterface . OnClickListener onclick ) { tif ( ! mDb . pm . validatePasswordEncoding ( mPassword ) ) { tPasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; tdialog . show ( ctx , onclick , true ) ; treturn false ; } treturn true ; } 
public void show ( Context ctx , DialogInterface . OnClickListener onclick ) { tshow ( ctx , onclick , false ) ; } 
public void onClick ( DialogInterface dialog , int which ) { tdialog . cancel ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { tBufferedInputStream bis = new BufferedInputStream ( is ) ; tif ( ! bis . markSupported ( ) ) { tthrow new IOException ( " Input stream does not support mark. " ) ; } } 
public void LoadData ( Context ctx , PwDatabase pm , String password , String keyfile , UpdateStatus status ) { tif ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } tsearchHelper = new SearchDbHelper ( ctx ) ; tloaded = true ; } 
private static boolean isKDBExtension ( String filename ) { tif ( filename = = null ) { return false ; } tint extIdx = filename . lastIndexOf ( " . " ) ; tif ( extIdx = = - 1 ) return false ; treturn filename . substring ( extIdx , filename . length ( ) ) . equalsIgnoreCase ( " .kdb " ) ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { }} 
public void copyHeader ( PwDbHeaderV3 header ) { }} 
private void initAndAddGroup ( String name , int iconId , PwGroup parent ) { tPwGroup group = createGroup ( ) ; tgroup . initNewGroup ( name , newGroupId ( ) ) ; tgroup . icon = iconFactory . getIcon ( iconId ) ; taddGroupTo ( group , parent ) ; } 
public void initNew ( String dbPath ) { talgorithm = PwEncryptionAlgorithm . Rjindal ; tnumKeyEncRounds = DEFAULT_ENCRYPTION_ROUNDS ; tname = " KeePass Password Manager " ; } 
public void initNew ( String dbPath ) { tString filename = URLUtil . guessFileName ( dbPath , null , null ) ; trootGroup = new PwGroupV4 ( true , true , dbNameFromPath ( dbPath ) , iconFactory . getIcon ( PwIconStandard . FOLDER ) ) ; } 
private String dbNameFromPath ( String dbPath ) { tString filename = URLUtil . guessFileName ( dbPath , null , null ) ; tif ( EmptyUtils . isNullOrEmpty ( filename ) ) { treturn " KeePass Database " ; } tint lastExtDot = filename . lastIndexOf ( " . " ) ; tif ( lastExtDot = = - 1 ) { treturn filename ; } treturn filename . substring ( 0 , lastExtDot ) ; } 
public void run ( ) { } 
private void testKeyfile ( String dbAsset , String keyAsset , String password ) throws Exception { tContext ctx = getContext ( ) ; tFile sdcard = Environment . getExternalStorageDirectory ( ) ; tString keyPath = sdcard . getAbsolutePath ( ) + " /key " ; tTestUtil . extractKey ( ctx , keyAsset , keyPath ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; timporter . openDatabase ( is , password , keyPath ) ; tis . close ( ) ; } 
public static void Launch ( Activity act , String fileName ) throws FileNotFoundException { Launch ( act , fileName , " " ) ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) throws FileNotFoundException { File dbFile = new File ( fileName ) ; if ( ! dbFile . exists ( ) ) { throw new FileNotFoundException ( ) ; } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; new InitTask ( ) . execute ( i ) ; } 
protected void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); } 
private void retrieveSettings ( ) { String defaultFilename = prefs . getString ( KEY_DEFAULT_FILENAME , " " ) ; if ( mFileName . length ( ) > 0 & & mFileName . equals ( defaultFilename ) ) { CheckBox checkbox = ( CheckBox ) findViewById ( R . id . default_database ) ; 
private void populateView ( ) { setEditText ( R . id . filename , mFileName ) ; setEditText ( R . id . pass_keyfile , mKeyFile ) ; } 
private void errorMessage ( int resId ) { Toast . makeText ( this , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mFileName ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . this ) ; backupManager . dataChanged ( ) ; 
public void onClick ( View view ) { String pass = getEditText ( R . id . password ) ; String key = getEditText ( R . id . pass_keyfile ) ; loadDatabase ( pass , key ) ; } 
private void loadDatabase ( String pass , String keyfile ) { if ( pass . length ( ) = = 0 & & keyfile . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, fileName, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflate = getMenuInflater ( ) ; inflate . inflate ( R . menu . password , menu ) ; return true ; } 
public void run ( ) { if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( PasswordActivity . this ) ; } 
protected Integer doInBackground ( Intent . . . args ) { Intent i = args [ 0 ] ; String action = i . getAction ( ) ; ; if ( action ! = null & & action . equals ( VIEW_INTENT ) ) { mFileName = i . getDataString ( ) ; if ( ! mFileName . substring ( 0 , 7 ) . equals ( " file: " ) ) { return R . string . error_can_not_handle_uri ; } mFileName = URLDecoder . decode ( mFileName . substring ( 7 , mFileName . length ( ) ) ) ; if ( mFileName . length ( ) = = 0 ) { No file name return R.string.FileNotFound; } File dbFile = new File(mFileName); if ( ! dbFile.exists() ) { File does not exist return R.string.FileNotFound; } mKeyFile = getKeyFile(mFileName); } else { mFileName = i.getStringExtra(KEY_FILENAME); mKeyFile = i.getStringExtra(KEY_KEYFILE); password = i.getStringExtra(KEY_PASSWORD); launch_immediately = i.getBooleanExtra(KEY_LAUNCH_IMMEDIATELY, false); if ( mKeyFile == null || mKeyFile.length() == 0) { mKeyFile = getKeyFile(mFileName); } } return null; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
public void onClick ( View v ) { Intent i = new Intent ( Intent . ACTION_GET_CONTENT ) ; i . setType ( " file/* " ) ; try { startActivityForResult ( i , GET_CONTENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( PasswordActivity . this , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( PasswordActivity . this ) ; diag . show ( ) ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mFileName , mPass , mKey , mStatus ) ; saveFileData ( mFileName , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( true ) ; } 
private void saveFileData ( String fileName , String key ) { if ( ! mRememberKeyfile ) { key = " " ; } App . getFileHistory ( ) . createFile ( fileName , key ) ; } 
private synchronized void init ( ) { if ( ! init ) { if ( ! upgradeFromSQL ( ) ) { 
private boolean upgradeFromSQL ( ) { try { Check for a database to upgrade from if (!sqlDatabaseExists()) { return false; } databases.clear(); keyfiles.clear(); FileDbHelper helper = new FileDbHelper(ctx); helper.open(); Cursor cursor = helper.fetchAllFiles(); int dbIndex = cursor.getColumnIndex(FileDbHelper.KEY_FILE_FILENAME); int keyIndex = cursor.getColumnIndex(FileDbHelper.KEY_FILE_KEYFILE); if(cursor.moveToFirst()) { while (cursor.moveToNext()) { String filename = cursor.getString(dbIndex); String keyfile = cursor.getString(keyIndex); databases.add(filename); keyfiles.add(keyfile); } } savePrefs(); cursor.close(); helper.close(); } catch (Exception e) { If upgrading fails, we'll just give up on it. } try { FileDbHelper.deleteDatabase(ctx); } catch (Exception e) { If we fail to delete it, just move on } return true; } 
private boolean sqlDatabaseExists ( ) { File db = ctx . getDatabasePath ( FileDbHelper . DATABASE_NAME ) ; return db . exists ( ) ; } 
public void createFile ( String fileName , String keyFile ) { if ( ! enabled ) return ; init ( ) ; Remove any existing instance of the same filename deleteFile(fileName, false); databases.add(0, fileName); keyfiles.add(0, keyFile); trimLists(); savePrefs(); } 
public boolean hasRecentFiles ( ) { if ( ! enabled ) return false ; init ( ) ; return databases . size ( ) > 0 ; } 
private void loadPrefs ( ) { loadList ( databases , DB_KEY ) ; loadList ( keyfiles , KEYFILE_KEY ) ; } 
private void savePrefs ( ) { saveList ( DB_KEY , databases ) ; saveList ( KEYFILE_KEY , keyfiles ) ; } 
private void loadList ( List < String > list , String keyprefix ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; int size = prefs . getInt ( keyprefix , 0 ) ; list . clear ( ) ; for ( int i = 0 ; i < size ; i + + ) { list . add ( prefs . getString ( keyprefix + " _ " + i , " " ) ) ; 
private void saveList ( String keyprefix , List < String > list ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor edit = prefs . edit ( ) ; int size = list . size ( ) ; edit . putInt ( keyprefix , size ) ; for ( int i = 0 ; i < size ; i + + ) { edit . putString ( keyprefix + " _ " + i , list . get ( i ) ) ; } EditorCompat . apply ( edit ) ; } 
public void deleteFile ( String filename ) { deleteFile ( filename , true ) ; } 
public void deleteFile ( String filename , boolean save ) { init ( ) ; for ( int i = 0 ; i < databases . size ( ) ; i + + ) { if ( filename . equals ( databases . get ( i ) ) ) { databases . remove ( i ) ; keyfiles . remove ( i ) ; break ; } } if ( save ) { savePrefs ( ) ; 
public void deleteAll ( ) { init ( ) ; databases . clear ( ) ; keyfiles . clear ( ) ; savePrefs ( ) ; } 
public void deleteAllKeys ( ) { init ( ) ; keyfiles . clear ( ) ; int size = databases . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { keyfiles . add ( " " ) ; } savePrefs ( ) ; } 
private void trimLists ( ) { int size = databases . size ( ) ; for ( int i = FileDbHelper . MAX_FILES ; i < size ; i + + ) { databases . remove ( i ) ; 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile ) throws IOException , InvalidDBException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile ) throws IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , filename , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status ) throws IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , filename , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , String filename , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , FileNotFoundException , InvalidDBException { File file = new File ( filename ) ; FileInputStream fis = new FileInputStream ( file ) ; LoadData ( ctx , fis , password , keyfile , status , debug ) ; readOnly = ! file . canWrite ( ) ; mFilename = filename ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , boolean debug ) throws IOException , InvalidDBException { LoadData ( ctx , is , password , keyfile , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , String keyfile , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, keyfile, status); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, keyfile, status); } loaded = true; } 
public void LoadData ( Context ctx , PwDatabase pm , String password , String keyfile , UpdateStatus status ) { if ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } searchHelper = new SearchDbHelper ( ctx ) ; loaded = true ; } 
public PwGroup Search ( String str ) { if ( searchHelper = = null ) { return null ; } PwGroup group = searchHelper . search ( this , str ) ; return group ; 
public void SaveData ( ) throws IOException , PwDbOutputException { SaveData ( mFilename ) ; } 
public void SaveData ( String filename ) throws IOException , PwDbOutputException { File tempFile = new File ( filename + " .tmp " ) ; FileOutputStream fos = new FileOutputStream ( tempFile ) ; BufferedOutputStream bos = new BufferedOutputStream(fos); PwDbV3Output pmo = new PwDbV3Output(pm, bos, App.getCalendar()); PwDbOutput pmo = PwDbOutput.getInstance(pm, fos); pmo.output(); bos.flush(); bos.close(); fos.close(); Force data to disk before continuing try { fos.getFD().sync(); } catch (SyncFailedException e) { Ignore if fsync fails. We tried. } File orig = new File(filename); if ( ! tempFile.renameTo(orig) ) { throw new IOException("Failed to store database."); } mFilename = filename; 
public void clear ( ) { dirty . clear ( ) ; drawFactory . clear ( ) ; pm = null ; mFilename = null ; loaded = false ; passwordEncodingError = false ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) throws Exception { tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; tDatabase Db = new Database ( ) ; tDb . LoadData ( ctx , is , password , keyfile , Importer . DEBUG ) ; tUri . Builder b = new Uri . Builder ( ) ; tDb . mUri = b . scheme ( " file " ) . path ( filename ) . build ( ) ; treturn Db ; 
public void LoadData ( Context ctx , Uri uri , String password , String keyfile ) throws IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , Uri uri , String password , String keyfile , UpdateStatus status ) throws IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void SaveData ( Context ctx ) throws IOException , PwDbOutputException { SaveData ( ctx , mUri ) ; } 
public void clear ( ) { dirty . clear ( ) ; drawFactory . clear ( ) ; pm = null ; mUri = null ; loaded = false ; passwordEncodingError = false ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) throws FileNotFoundException { Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
private void loadDatabase ( String pass , String keyfile ) { if ( pass . length ( ) = = 0 & & keyfile . length ( ) = = 0 ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Uri uri; if (mUri != null) { uri = mUri; } else { uri = Uri.parse(fileName); String scheme = uri.getScheme(); if (scheme == null || scheme.equals("")) { Uri.Builder builder = new Uri.Builder(); builder.scheme("file").authority("").path(fileName); uri = builder.build(); } } Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, uri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
public void run ( ) { tmDb . pm . addEntryTo ( mEntry , mEntry . getParent ( ) ) ; } 
public void run ( ) { tPwDatabase pm = mDb . pm ; } 
public void run ( ) { } 
public void run ( ) { tPwDatabase pm = mDb . pm ; tPwGroup parent = mEntry . getParent ( ) ; 
public void run ( ) { save.run(); 
public void run ( ) { try { mDb . LoadData ( mCtx , mUri , mPass , mKey , mStatus ) ; saveFileData ( mUri , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( true ) ; } 
private void saveFileData ( Uri uri , String key ) { if ( ! mRememberKeyfile ) { key = " " ; } App . getFileHistory ( ) . createFile ( uri , key ) ; } 
public void run ( ) { tif ( ! mDontSave ) { ttry { tmDb . SaveData ( mCtx ) ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( PwDbOutputException e ) { } 
public void run ( ) { tPwDatabase pm = mDb . pm ; tbyte [ ] backupKey = new byte [ pm . masterKey . length ] ; tSystem . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public void run ( ) { } 
public void onClick ( View v ) { tString filename = Util . getEditText ( FileSelectActivity . this , tR . id . file_filename ) ; createTask.run(); 
tprotected java . lang . Void doInBackground ( String . . . args ) { tString filename = args [ 0 ] ; tfileHistory . deleteFile ( Uri . parse ( args [ 0 ] ) ) ; treturn null ; } 
public void createFile ( Uri uri , String keyFile ) { if ( ! enabled ) return ; init ( ) ; Remove any existing instance of the same filename deleteFile(uri, false); databases.add(0, uri.toString()); keyfiles.add(0, keyFile); trimLists(); savePrefs(); } 
public void deleteFile ( Uri uri ) { deleteFile ( uri , true ) ; } 
public void deleteFile ( Uri uri , boolean save ) { init ( ) ; String uriName = uri . toString ( ) ; String fileName = uri . getPath ( ) ; for ( int i = 0 ; i < databases . size ( ) ; i + + ) { String entry = databases . get ( i ) ; if ( uriName . equals ( entry ) | | fileName . equals ( entry ) ) { databases . remove ( i ) ; keyfiles . remove ( i ) ; break ; } } if ( save ) { savePrefs ( ) ; 
private void deleteEntry ( ) { tHandler handler = new Handler ( ) ; tDeleteEntry task = new DeleteEntry ( mAct , App . getDB ( ) , mPw , mAct . new RefreshTask ( handler ) ) ; tProgressTask pt = new ProgressTask ( mAct , task , R . string . saving_database ) ; tpt . run ( ) ; 
public static InputStream getKeyFileInputStream ( Context ctx , String keyfile ) throws FileNotFoundException { tInputStream keyIs = null ; tif ( ! EmptyUtils . isNullOrEmpty ( keyfile ) ) { tUri uri = UriUtil . parseDefaultFile ( keyfile ) ; tkeyIs = UriUtil . getUriInputStream ( ctx , uri ) ; } treturn keyIs ; } 
private void testKeyfile ( String dbAsset , String keyAsset , String password ) throws Exception { tContext ctx = getContext ( ) ; tFile sdcard = Environment . getExternalStorageDirectory ( ) ; tString keyPath = sdcard . getAbsolutePath ( ) + " /key " ; tTestUtil . extractKey ( ctx , keyAsset , keyPath ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; timporter . openDatabase ( is , password , TestUtil . getKeyFileInputStream ( ctx , keyPath ) ) ; tis . close ( ) ; } 
public void testReadTwofish ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " twofish.kdb " , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; tPwDatabaseV3 db = importer . openDatabase ( is , " 12345 " , null ) ; tassertTrue ( db . algorithm = = PwEncryptionAlgorithm . Twofish ) ; tis . close ( ) ; 
public void testParsing ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " 12345 " , null ) ; tis . close ( ) ; 
public void testSaving ( ) throws IOException , InvalidDBException , PwDbOutputException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; tis . close ( ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tPwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; toutput . output ( ) ; tbyte [ ] data = bos . toByteArray ( ) ; tFileOutputStream fos = new FileOutputStream ( " /sdcard/test-out.kdbx " , false ) ; tInputStream bis = new ByteArrayInputStream ( data ) ; tbis = new CopyInputStream ( bis , fos ) ; timporter = new ImporterV4 ( ) ; tdb = importer . openDatabase ( bis , " 12345 " , null ) ; tbis . close ( ) ; tfos . close ( ) ; 
public void testComposite ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; tis . close ( ) ; 
public void testKeyfile ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; tis . close ( ) ; 
public void testNoGzip ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " 12345 " , null ) ; tis . close ( ) ; 
public void testReadHeader ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; tassertEquals ( 6000 , db . numKeyEncRounds ) ; tassertTrue ( db . dataCipher . equals ( CipherFactory . AES_CIPHER ) ) ; tis . close ( ) ; 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tdb = importer . openDatabase ( is , " 12345 " , null ) ; tis . close ( ) ; tspr = SprEngine . getInstance ( db ) ; } 
public static Database GetDb ( Context ctx , String asset , String password , String keyfile , String filename ) throws Exception { tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( asset , AssetManager . ACCESS_STREAMING ) ; tDatabase Db = new Database ( ) ; tInputStream keyIs = TestUtil . getKeyFileInputStream ( ctx , keyfile ) ; tDb . LoadData ( ctx , is , password , keyIs , Importer . DEBUG ) ; tUri . Builder b = new Uri . Builder ( ) ; tDb . mUri = b . scheme ( " file " ) . path ( filename ) . build ( ) ; treturn Db ; 
public void LoadData ( Context ctx , InputStream is , String password , InputStream keyInputStream ) throws IOException , InvalidDBException { LoadData ( ctx , is , password , keyInputStream , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , Uri uri , String password , Uri keyfile ) throws IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , new UpdateStatus ( ) , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , Uri uri , String password , Uri keyfile , UpdateStatus status ) throws IOException , FileNotFoundException , InvalidDBException { LoadData ( ctx , uri , password , keyfile , status , ! Importer . DEBUG ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , boolean debug ) throws IOException , InvalidDBException { LoadData ( ctx , is , password , kfIs , new UpdateStatus ( ) , debug ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, kfIs, status); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, kfIs, status); } loaded = true; } 
public void LoadData ( Context ctx , PwDatabase pm , String password , InputStream keyInputStream , UpdateStatus status ) { if ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } searchHelper = new SearchDbHelper ( ctx ) ; loaded = true ; } 
private void populateView ( ) { String db = ( mDbUri = = null ) ? " " : mDbUri . toString ( ) ; setEditText ( R . id . filename , db ) ; String key = ( mKeyUri = = null ) ? " " : mKeyUri . toString ( ) ; setEditText ( R . id . pass_keyfile , key ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . toString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . this ) ; backupManager . dataChanged ( ) ; 
private void loadDatabase ( String pass , String keyfile ) { loadDatabase ( pass , UriUtil . parseDefaultFile ( keyfile ) ) ; } 
private void loadDatabase ( String pass , Uri keyfile ) { if ( pass . length ( ) = = 0 & & ( keyfile = = null | | keyfile . toString ( ) . length ( ) = = 0 ) ) { errorMessage ( R . string . error_nopass ) ; return ; } String fileName = getEditText ( R . id . filename ) ; Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Uri uri = UriUtil.parseDefaultFile(fileName); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, uri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
public void setMasterKey ( String key , InputStream keyInputStream ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null ) ; tmasterKey = getMasterKey ( key , keyInputStream ) ; } 
tprotected byte [ ] getCompositeKey ( String key , InputStream keyInputStream ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null & & keyInputStream ! = null ) ; tbyte [ ] fileKey = getFileKey ( keyInputStream ) ; tbyte [ ] passwordKey = getPasswordKey ( key ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " SHA-256 not supported " ) ; } tmd . update ( passwordKey ) ; treturn md . digest ( fileKey ) ; } 
tprotected byte [ ] getFileKey ( InputStream keyInputStream ) tthrows InvalidKeyFileException , IOException { tassert ( keyInputStream ! = null ) ; tbyte [ ] key = loadXmlKeyFile ( keyInputStream ) ; tif ( key ! = null ) { treturn key ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Util . copyStream ( keyInputStream , bos ) ; tbyte [ ] keyData = bos . toByteArray ( ) ; tlong fileSize = keyData . length ; tif ( fileSize = = 0 ) { tthrow new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { treturn keyData ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; ttry { treturn hexStringToByteArray ( new String ( keyData ) ) ; } catch ( IndexOutOfBoundsException e ) { } 
public byte [ ] getMasterKey ( String key , InputStream keyInputStream ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null ) ; tif ( key . length ( ) > 0 & & keyInputStream ! = null ) { treturn getCompositeKey ( key , keyInputStream ) ; 
tprotected byte [ ] loadXmlKeyFile ( InputStream keyInputStream ) { treturn null ; } 
public byte [ ] getMasterKey ( String key , InputStream keyInputStream ) tthrows InvalidKeyFileException , IOException { tassert ( key ! = null ) ; tbyte [ ] fKey ; tif ( key . length ( ) > 0 & & keyInputStream ! = null ) { treturn getCompositeKey ( key , keyInputStream ) ; } else if ( key . length ( ) > 0 ) { tfKey = getPasswordKey ( key ) ; } else if ( keyInputStream ! = null ) { tfKey = getFileKey ( keyInputStream ) ; } else { tthrow new IllegalArgumentException ( " Key cannot be empty. " ) ; } tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " No SHA-256 implementation " ) ; } treturn md . digest ( fKey ) ; } 
public void run ( ) { } 
private void saveFileData ( Uri uri , Uri key ) { if ( ! mRememberKeyfile ) { key = null ; } App . getFileHistory ( ) . createFile ( uri , key ) ; } 
public void run ( ) { tPwDatabase pm = mDb . pm ; tbyte [ ] backupKey = new byte [ pm . masterKey . length ] ; tSystem . arraycopy ( pm . masterKey , 0 , backupKey , 0 , backupKey . length ) ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream ) tthrows IOException , InvalidDBException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) tthrows IOException , InvalidDBException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status ) tthrows IOException , InvalidDBException ; } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , InputStream kfIs ) tthrows IOException , InvalidDBException { treturn openDatabase ( inStream , password , kfIs , new UpdateStatus ( ) ) ; } 
public PwDatabaseV3Debug openDatabase ( InputStream inStream , String password , tInputStream keyInputStream , UpdateStatus status ) throws IOException , tInvalidDBException { treturn ( PwDatabaseV3Debug ) super . openDatabase ( inStream , password , keyInputStream , status ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tInputStream keyInputStream ) throws IOException , InvalidDBException { treturn openDatabase ( inStream , password , keyInputStream , new UpdateStatus ( ) ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tInputStream keyInputStream , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; thashOfHeader = header . loadFromFile ( inStream ) ; tdb . setMasterKey ( password , keyInputStream ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; 
public PwDatabaseV4Debug openDatabase ( InputStream inStream , String password , tInputStream keyInputFile , UpdateStatus status ) throws IOException , tInvalidDBException { treturn ( PwDatabaseV4Debug ) super . openDatabase ( inStream , password , keyInputFile , status ) ; } 
public void createFile ( Uri uri , Uri keyUri ) { if ( ! enabled | | uri = = null | | keyUri = = null ) return ; init ( ) ; Remove any existing instance of the same filename deleteFile(uri, false); databases.add(0, uri.toString()); keyfiles.add(0, keyUri.toString()); trimLists(); savePrefs(); } 
public static boolean isNullOrEmpty ( Uri uri ) { treturn ( uri = = null ) | | ( uri . toString ( ) . length ( ) = = 0 ) ; } 
public static boolean equalsDefaultfile ( Uri left , String right ) { left = parseDefaultFile ( left ) ; Uri uriRight = parseDefaultFile ( right ) ; return left . equals ( uriRight ) ; } 
public static InputStream getUriInputStream ( Context ctx , Uri uri ) throws FileNotFoundException { if ( uri = = null ) return null ; String scheme = uri . getScheme ( ) ; if ( scheme . equals ( " file " ) ) { return new FileInputStream ( uri . getPath ( ) ) ; 
public void initNew ( String dbPath ) { tString filename = URLUtil . guessFileName ( dbPath , null , null ) ; trootGroup = new PwGroupV4 ( true , true , dbNameFromPath ( dbPath ) , iconFactory . getIcon ( PwIconStandard . FOLDER ) ) ; tgroups . put ( rootGroup . getId ( ) , rootGroup ) ; } 
public void createFile ( Uri uri , Uri keyUri ) { if ( ! enabled | | uri = = null ) return ; init ( ) ; Remove any existing instance of the same filename deleteFile(uri, false); databases.add(0, uri.toString()); String key = (keyUri == null) ? "" : keyUri.toString(); keyfiles.add(0, key); trimLists(); savePrefs(); } 
public void run ( ) { } 
public static InputStream getUriInputStream ( Context ctx , Uri uri ) throws FileNotFoundException { if ( uri = = null ) return null ; String scheme = uri . getScheme ( ) ; if ( EmptyUtils . isNullOrEmpty ( scheme ) | | scheme . equals ( " file " ) ) { return new FileInputStream ( uri . getPath ( ) ) ; 
private void loadDatabase ( String pass , Uri keyfile ) { if ( pass . length ( ) = = 0 & & ( keyfile = = null | | keyfile . toString ( ) . length ( ) = = 0 ) ) { errorMessage ( R . string . error_nopass ) ; return ; } Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, mDbUri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tString filename = null ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tfilename = data . getDataString ( ) ; tif ( filename ! = null ) { tif ( filename . startsWith ( " file: " ) ) { tfilename = filename . substring ( 7 ) ; } tfilename = URLDecoder . decode ( filename ) ; } } telse if ( requestCode = = GET_CONTENT & & resultCode = = RESULT_OK ) { tif ( data ! = null ) { tUri uri = data . getData ( ) ; tif ( uri ! = null ) { tfilename = uri . toString ( ) ; } } } tif ( filename ! = null ) { tEditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( PasswordActivity . this ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
public static boolean supportsStorageFramework ( ) { return BuildCompat . getSdkVersion ( ) > = BuildCompat . VERSION_KITKAT ; } 
public static boolean useStorageFramework ( Context ctx ) { if ( ! supportsStorageFramework ( ) ) { return false ; } SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getBoolean ( ctx . getString ( R . string . saf_key ) , ctx . getResources ( ) . getBoolean ( R . bool . saf_default ) ) ; } 
public void onClick ( View v ) { tif ( StorageAF . useStorageFramework ( FileSelectActivity . this ) ) { tIntent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tString filename = null ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tfilename = data . getDataString ( ) ; tif ( filename ! = null ) { tif ( filename . startsWith ( " file: " ) ) { tfilename = filename . substring ( 7 ) ; } tfilename = URLDecoder . decode ( filename ) ; } } telse if ( ( requestCode = = GET_CONTENT | | requestCode = = OPEN_DOC ) & & resultCode = = RESULT_OK ) { tif ( data ! = null ) { tUri uri = data . getData ( ) ; tif ( uri ! = null ) { tfilename = uri . toString ( ) ; } } } tif ( filename ! = null ) { tEditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public static void Launch ( Activity act , String fileName , String keyFile ) throws FileNotFoundException { Uri uri = UriUtil . parseDefaultFile ( fileName ) ; String scheme = uri . getScheme ( ) ; if ( ! EmptyUtils . isNullOrEmpty ( scheme ) & & scheme . equalsIgnoreCase ( " file " ) ) { File dbFile = new File ( fileName ) ; if ( ! dbFile . exists ( ) ) { throw new FileNotFoundException ( ) ; } } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tString filename = null ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tfilename = data . getDataString ( ) ; tif ( filename ! = null ) { tif ( filename . startsWith ( " file: " ) ) { tfilename = filename . substring ( 7 ) ; } tfilename = URLDecoder . decode ( filename ) ; } } telse if ( ( requestCode = = GET_CONTENT | | requestCode = = OPEN_DOC ) & & resultCode = = RESULT_OK ) { tif ( data ! = null ) { tUri uri = data . getData ( ) ; tif ( uri ! = null ) { tif ( requestCode = = GET_CONTENT ) { turi = UriUtil . translate ( this , uri ) ; } tfilename = uri . toString ( ) ; } } } tif ( filename ! = null ) { tEditText fn = ( EditText ) findViewById ( R . id . file_filename ) ; 
public static Uri translate ( Context ctx , Uri uri ) { StorageAF provides nice URIs if (StorageAF.useStorageFramework(ctx) || hasWritableContentUri(uri)) { return uri; } String scheme = uri.getScheme(); if (EmptyUtils.isNullOrEmpty(scheme)) { return uri; } String filepath = null; Use content resolver to try and find the file if (scheme.equalsIgnoreCase("content")) { Cursor cursor = ctx.getContentResolver().query(uri, new String[] {android.provider.MediaStore.Images.ImageColumns.DATA}, null, null, null); cursor.moveToFirst(); filepath = cursor.getString(0); cursor.close(); if (!isValidFilePath(filepath)) { filepath = null; } } Try using the URI path as a straight file if (EmptyUtils.isNullOrEmpty(filepath)) { filepath = uri.getPath(); if (!isValidFilePath(filepath)) { filepath = null; } } Update the file to a file URI if (!EmptyUtils.isNullOrEmpty(filepath)) { Uri.Builder b = new Uri.Builder(); uri = b.scheme("file").authority("").path(filepath).build(); } return uri; } 
private static boolean isValidFilePath ( String filepath ) { File file = new File ( filepath ) ; return file . exists ( ) & & file . canRead ( ) ; } 
public int read ( ) throws IOException { tif ( atEnd ) return - 1 ; tif ( bufferPos = = buffer . length ) { tif ( ! ReadHashedBlock ( ) ) return - 1 ; } tint output = Types . readUByte ( buffer , bufferPos ) ; tbufferPos + + ; treturn output ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) throws FileNotFoundException { Uri uri = UriUtil . parseDefaultFile ( fileName ) ; String scheme = uri . getScheme ( ) ; if ( ! EmptyUtils . isNullOrEmpty ( scheme ) & & scheme . equalsIgnoreCase ( " file " ) ) { File dbFile = new File ( uri . getPath ( ) ) ; if ( ! dbFile . exists ( ) ) { throw new FileNotFoundException ( ) ; } } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
public void run ( ) { try { mDb . LoadData ( mCtx , mUri , mPass , mKey , mStatus ) ; saveFileData ( mUri , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( ContentFileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . file_not_found_content ) ) ; return ; } catch ( FileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( true ) ; } 
public static Uri translate ( Context ctx , Uri uri ) { StorageAF provides nice URIs if (StorageAF.useStorageFramework(ctx) || hasWritableContentUri(uri)) { return uri; } String scheme = uri.getScheme(); if (EmptyUtils.isNullOrEmpty(scheme)) { return uri; } String filepath = null; Use content resolver to try and find the file if (scheme.equalsIgnoreCase("content")) { Cursor cursor = ctx.getContentResolver().query(uri, new String[] {android.provider.MediaStore.Images.ImageColumns.DATA}, null, null, null); cursor.moveToFirst(); filepath = cursor.getString(0); cursor.close(); if (!isValidFilePath(filepath)) { filepath = null; } } Try using the URI path as a straight file if (EmptyUtils.isNullOrEmpty(filepath)) { filepath = uri.getEncodedPath(); if (!isValidFilePath(filepath)) { filepath = null; } } Update the file to a file URI if (!EmptyUtils.isNullOrEmpty(filepath)) { Uri.Builder b = new Uri.Builder(); uri = b.scheme("file").authority("").path(filepath).build(); } return uri; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tTestUtil . extractKey ( getContext ( ) , " keyfile.key " , " /sdcard/key " ) ; tTestUtil . extractKey ( getContext ( ) , " binary.key " , " /sdcard/key-binary " ) ; } 
public void testComposite ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; tis . close ( ) ; 
public void testCompositeBinary ( ) throws IOException , InvalidDBException { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; timporter . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key-binary " ) ) ; tis . close ( ) ; 
tprotected byte [ ] getFileKey ( InputStream keyInputStream ) tthrows InvalidKeyFileException , IOException { tassert ( keyInputStream ! = null ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Util . copyStream ( keyInputStream , bos ) ; byte [ ] keyData = bos . toByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( keyData ) ; tbyte [ ] key = loadXmlKeyFile ( bis ) ; tif ( key ! = null ) { treturn key ; } tlong fileSize = keyData . length ; tif ( fileSize = = 0 ) { tthrow new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { treturn keyData ; } else if ( fileSize = = 64 ) { tbyte [ ] hex = new byte [ 64 ] ; ttry { treturn hexStringToByteArray ( new String ( keyData ) ) ; } catch ( IndexOutOfBoundsException e ) { } 
public void testDetection ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; Importer importer = ImporterFactory . createImporter ( is ) ; assertTrue ( importer instanceof ImporterV4 ) ; is . close ( ) ; 
public void testParsing ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
public void testSaving ( ) throws IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . toByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( " /sdcard/test-out.kdbx " , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , " 12345 " , null ) ; bis . close ( ) ; fos . close ( ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; TestUtil . extractKey ( getContext ( ) , " keyfile.key " , " /sdcard/key " ) ; TestUtil . extractKey ( getContext ( ) , " binary.key " , " /sdcard/key-binary " ) ; } 
public void testComposite ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; is . close ( ) ; 
public void testCompositeBinary ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key-binary " ) ) ; is . close ( ) ; 
public void testKeyfile ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , " /sdcard/key " ) ) ; is . close ( ) ; 
public void testNoGzip ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
private static boolean isKDBExtension ( String filename ) { if ( filename = = null ) { return false ; } int extIdx = filename . lastIndexOf ( " . " ) ; if ( extIdx = = - 1 ) return false ; return filename . substring ( extIdx , filename . length ( ) ) . equalsIgnoreCase ( " .kdb " ) ; } 
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) throws IOException { Write checksum Checksum MessageDigest md = null; try { md = MessageDigest.getInstance("SHA-256"); } catch (NoSuchAlgorithmException e) { throw new IOException("SHA-256 not implemented here."); } NullOutputStream nos = new NullOutputStream(); DigestOutputStream dos = new DigestOutputStream(nos, md); byte[] transformedMasterKey = transformMasterKey(masterSeed2, masterKey, numRounds); dos.write(masterSeed); dos.write(transformedMasterKey); finalKey = md.digest(); } 
private static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . transformMasterKey ( pKeySeed , pKey , rounds ) ; } 
public void setMasterKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key ! = null ) ; masterKey = getMasterKey ( key , keyInputStream ) ; } 
protected byte [ ] getCompositeKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key ! = null & & keyInputStream ! = null ) ; byte [ ] fileKey = getFileKey ( keyInputStream ) ; byte [ ] passwordKey = getPasswordKey ( key ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } md . update ( passwordKey ) ; return md . digest ( fileKey ) ; } 
protected byte [ ] getFileKey ( InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( keyInputStream ! = null ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Util . copyStream ( keyInputStream , bos ) ; byte [ ] keyData = bos . toByteArray ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( keyData ) ; byte [ ] key = loadXmlKeyFile ( bis ) ; if ( key ! = null ) { return key ; } long fileSize = keyData . length ; if ( fileSize = = 0 ) { throw new KeyFileEmptyException ( ) ; } else if ( fileSize = = 32 ) { return keyData ; } else if ( fileSize = = 64 ) { byte [ ] hex = new byte [ 64 ] ; try { return hexStringToByteArray ( new String ( keyData ) ) ; } catch ( IndexOutOfBoundsException e ) { Key is not base 64, treat it as binary data } } MessageDigest md; try { md = MessageDigest.getInstance("SHA-256"); } catch (NoSuchAlgorithmException e) { throw new IOException("SHA-256 not supported"); } SHA256Digest md = new SHA256Digest(); byte[] buffer = new byte[2048]; int offset = 0; try { md.update(keyData); } catch (Exception e) { System.out.println(e.toString()); } return md.digest(); } 
public boolean validatePasswordEncoding ( String key ) { String encoding = getPasswordEncoding ( ) ; byte [ ] bKey ; try { bKey = key . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { return false ; } String reencoded ; try { reencoded = new String ( bKey , encoding ) ; } catch ( UnsupportedEncodingException e ) { return false ; } return key . equals ( reencoded ) ; } 
public byte [ ] getPasswordKey ( String key ) throws IOException { assert ( key ! = null ) ; if ( key . length ( ) = = 0 ) throw new IllegalArgumentException ( " Key cannot be empty. " ) ; MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " SHA-256 not supported " ) ; } byte [ ] bKey ; try { bKey = key . getBytes ( getPasswordEncoding ( ) ) ; } catch ( UnsupportedEncodingException e ) { assert false ; bKey = key . getBytes ( ) ; } md . update ( bKey , 0 , bKey . length ) ; return md . digest ( ) ; } 
public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { Add group to parent group if ( parent == null ) { parent = rootGroup; } parent.childGroups.add(newGroup); newGroup.setParent(parent); groups.put(newGroup.getId(), newGroup); parent.touch(true, true); } 
public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { Remove group from parent group parent.childGroups.remove(remove); groups.remove(remove.getId()); } 
public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { Add entry to parent if (parent != null) { parent.childEntries.add(newEntry); } newEntry.setParent(parent); entries.put(newEntry.getUUID(), newEntry); } 
public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { Remove entry for parent if (parent != null) { parent.childEntries.remove(remove); } entries.remove(remove.getUUID()); } 
public void populateGlobals ( PwGroup currentGroup ) { List < PwGroup > childGroups = currentGroup . childGroups ; List < PwEntry > childEntries = currentGroup . childEntries ; for ( int i = 0 ; i < childEntries . size ( ) ; i + + ) { PwEntry cur = childEntries . get ( i ) ; entries . put ( cur . getUUID ( ) , cur ) ; } for ( int i = 0 ; i < childGroups . size ( ) ; i + + ) { PwGroup cur = childGroups . get ( i ) ; 
public boolean canRecycle ( PwGroup group ) { return false ; } 
public boolean canRecycle ( PwEntry entry ) { return false ; } 
public void recycle ( PwEntry entry ) { Assume calls to this are protected by calling inRecyleBin throw new RuntimeException("Call not valid for .kdb databases."); } 
public void undoRecycle ( PwEntry entry , PwGroup origParent ) { throw new RuntimeException ( " Call not valid for .kdb databases. " ) ; } 
public void deleteEntry ( PwEntry entry ) { PwGroup parent = entry . getParent ( ) ; removeEntryFrom ( entry , parent ) ; parent . touch ( false , true ) ; 
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { addEntryTo ( entry , origParent ) ; } 
public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { return group ! = null ; } 
private static boolean isValidFilePath ( String filepath ) { if ( EmptyUtils . isNullOrEmpty ( filepath ) ) { return false ; } File file = new File ( filepath ) ; return file . exists ( ) & & file . canRead ( ) ; } 
public static Uri translate ( Context ctx , Uri uri ) { StorageAF provides nice URIs if (StorageAF.useStorageFramework(ctx) || hasWritableContentUri(uri)) { return uri; } String scheme = uri.getScheme(); if (EmptyUtils.isNullOrEmpty(scheme)) { return uri; } String filepath = null; try { Use content resolver to try and find the file if (scheme.equalsIgnoreCase("content")) { Cursor cursor = ctx.getContentResolver().query(uri, new String[]{android.provider.MediaStore.Images.ImageColumns.DATA}, null, null, null); cursor.moveToFirst(); if (cursor != null) { filepath = cursor.getString(0); cursor.close(); if (!isValidFilePath(filepath)) { filepath = null; } } } Try using the URI path as a straight file if (EmptyUtils.isNullOrEmpty(filepath)) { filepath = uri.getEncodedPath(); if (!isValidFilePath(filepath)) { filepath = null; } } } Fall back to URI if this fails. catch (Exception e) { filepath = null; } Update the file to a file URI if (!EmptyUtils.isNullOrEmpty(filepath)) { Uri.Builder b = new Uri.Builder(); uri = b.scheme("file").authority("").path(filepath).build(); } return uri; } 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { tonListItemClick ( ( ListView ) parent , v , position , id ) ; } 
private void fillData ( ) { } 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tnew AsyncTask < Integer , Void , Void > ( ) { tString fileName ; 
private void refreshList ( ) { ( ( BaseAdapter ) mAdapter ) . notifyDataSetChanged ( ) ; } 
tprotected void onListItemClick ( ListView l , View v , int position , long id ) { tClickView cv = ( ClickView ) mAdapter . getView ( position , null , null ) ; tcv . onClick ( ) ; 
tprotected void styleScrollBars ( ) { tensureCorrectListView ( ) ; tmList . setScrollBarStyle ( View . SCROLLBARS_INSIDE_INSET ) ; tmList . setTextFilterEnabled ( true ) ; 
private void ensureCorrectListView ( ) { tmList = ( ListView ) findViewById ( R . id . group_list ) ; tmList . setOnItemClickListener ( tnew AdapterView . OnItemClickListener ( ) { 
private void toggleSort ( ) { 
private void inflate ( Context context ) { tLayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; tinflater . inflate ( R . layout . group_add_entry , this ) ; 
public void testSaving ( ) throws IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . toByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getSdPath ( " test-out.kdbx " ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , " 12345 " , null ) ; bis . close ( ) ; fos . close ( ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; TestUtil . extractKey ( getContext ( ) , " keyfile.key " , TestUtil . getSdPath ( " key " ) ) ; TestUtil . extractKey ( getContext ( ) , " binary.key " , TestUtil . getSdPath ( " key-binary " ) ) ; } 
public void testComposite ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getSdPath ( " key " ) ) ) ; is . close ( ) ; 
public void testCompositeBinary ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getSdPath ( " key-binary " ) ) ) ; is . close ( ) ; 
public void testKeyfile ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getSdPath ( " key " ) ) ) ; is . close ( ) ; 
public void testFullWrite ( ) throws IOException , PwDbOutputException { tAssetManager am = getContext ( ) . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public static void Launch ( Activity act , String fileName , String keyFile ) throws FileNotFoundException { if ( EmptyUtils . isNullOrEmpty ( fileName ) ) { throw new FileNotFoundException ( ) ; } Uri uri = UriUtil . parseDefaultFile ( fileName ) ; String scheme = uri . getScheme ( ) ; if ( ! EmptyUtils . isNullOrEmpty ( scheme ) & & scheme . equalsIgnoreCase ( " file " ) ) { File dbFile = new File ( uri . getPath ( ) ) ; if ( ! dbFile . exists ( ) ) { throw new FileNotFoundException ( ) ; } } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; } 
tprotected void onStart ( ) { tsuper . onStart ( ) ; tstartFileSelect ( ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, kfIs, status); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, kfIs, status); } loaded = true; } 
public void LoadData ( Context ctx , PwDatabase pm , String password , InputStream keyInputStream , UpdateStatus status ) { if ( pm ! = null ) { passwordEncodingError = ! pm . validatePasswordEncoding ( password ) ; } searchHelper = new SearchDbHelper ( ctx ) ; loaded = true ; } 
public PwGroup Search ( String str ) { if ( searchHelper = = null ) { return null ; } return searchHelper . search ( this , str ) ; } 
public void run ( ) { tif ( mSuccess ) { tif ( mFinish ! = null ) { tmFinish . setFilename ( mKeyfile ) ; } tdismiss ( ) ; } else { tdisplayMessage ( getContext ( ) ) ; } tsuper . run ( ) ; } 
public String generatePassword ( int length , boolean upperCase , boolean lowerCase , boolean digits , boolean minus , boolean underline , boolean space , boolean specials , boolean brackets ) throws IllegalArgumentException { } 
public void run ( ) { tToast . makeText ( mCtx , mText , Toast . LENGTH_LONG ) . show ( ) ; } 
public void run ( ) { } 
public void run ( ) { tsuper . run ( ) ; } 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) throws PwDbOutputException { tCipher cipher ; ttry { tmPM . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) mPM . numKeyEncRounds ) ; tcipher = CipherFactory . getInstance ( mPM . dataCipher , Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { tthrow new PwDbOutputException ( " Invalid algorithm. " , e ) ; } tCipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; treturn cos ; } 
public PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException { tPwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; tsetIVs ( header ) ; tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; ttry { tpho . output ( ) ; } catch ( IOException e ) { tthrow new PwDbOutputException ( " Failed to output the header. " , e ) ; } thashOfHeader = pho . getHashOfHeader ( ) ; treturn header ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tString filename = null ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tfilename = data . getDataString ( ) ; tif ( filename ! = null ) { tif ( filename . startsWith ( " file:EditText fn = (EditText) findViewById(R.id.file_filename); 
public static void takePersistableUriPermission ( ContentResolver resolver , Uri uri , int modeFlags ) { if ( available ) { try { 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tfillData ( ) ; tString filename = null ; tif ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { tfilename = data . getDataString ( ) ; tif ( filename ! = null ) { tif ( filename . startsWith ( " file:EditText fn = (EditText) findViewById(R.id.file_filename); 
public static Cipher getInstance ( UUID uuid , int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { tif ( uuid . equals ( AES_CIPHER ) ) { tCipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , androidOverride ) ; tcipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; treturn cipher ; } else if ( uuid . equals ( TWOFISH_CIPHER ) ) { tCipher cipher ; tif ( opmode = = Cipher . ENCRYPT_MODE ) { tcipher = CipherFactory . getInstance ( " Twofish/CBC/ZeroBytePadding " , androidOverride ) ; } else { tcipher = CipherFactory . getInstance ( " Twofish/CBC/NoPadding " , androidOverride ) ; } tcipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; treturn cipher ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public void output ( ) throws PwDbOutputException { tprepForOutput ( ) ; tPwDbHeader header = outputHeader ( mOS ) ; tbyte [ ] finalKey = getFinalKey ( header ) ; tCipher cipher ; ttry { tif ( mPM . algorithm = = PwEncryptionAlgorithm . Rjindal ) { tcipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; } else if ( mPM . algorithm = = PwEncryptionAlgorithm . Twofish ) { tcipher = CipherFactory . getInstance ( " Twofish/CBC/PKCS7PADDING " ) ; } else { tthrow new Exception ( ) ; } } catch ( Exception e ) { tthrow new PwDbOutputException ( " Algorithm not supported. " ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( finalKey , " AES " ) , new IvParameterSpec ( header . encryptionIV ) ) ; 
public static byte [ ] GetHmacKey64 ( byte [ ] key , long blockIndex ) { MessageDigest hash ; try { hash = MessageDigest . getInstance ( " SHA-512 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } NullOutputStream nos = new NullOutputStream ( ) ; DigestOutputStream dos = new DigestOutputStream ( nos , hash ) ; LEDataOutputStream leos = new LEDataOutputStream ( dos ) ; try { leos . writeLong ( blockIndex ) ; leos . write ( key ) ; leos . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } byte [ ] hashKey = hash . digest ( ) ; assert ( hashKey . length = = 64 ) ; return hashKey ; } 
public void testULongMax ( ) throws Exception { tbyte [ ] ulongBytes = new byte [ 8 ] ; tfor ( int i = 0 ; i < ulongBytes . length ; i + + ) { tulongBytes [ i ] = - 1 ; } tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tLEDataOutputStream leos = new LEDataOutputStream ( bos ) ; tleos . writeLong ( Types . ULONG_MAX_VALUE ) ; tleos . close ( ) ; tbyte [ ] uLongMax = bos . toByteArray ( ) ; tassertArrayEquals ( ulongBytes , uLongMax ) ; } 
public void testCipherFactory ( ) throws InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException { tbyte [ ] key = new byte [ 32 ] ; tbyte [ ] iv = new byte [ 16 ] ; tbyte [ ] plaintext = new byte [ 1024 ] ; trand . nextBytes ( key ) ; trand . nextBytes ( iv ) ; trand . nextBytes ( plaintext ) ; tCipherEngine aes = CipherFactory . getInstance ( AesEngine . CIPHER_UUID ) ; tCipher encrypt = aes . getCipher ( Cipher . ENCRYPT_MODE , key , iv ) ; tCipher decrypt = aes . getCipher ( Cipher . DECRYPT_MODE , key , iv ) ; tbyte [ ] secrettext = encrypt . doFinal ( plaintext ) ; tbyte [ ] decrypttext = decrypt . doFinal ( secrettext ) ; tassertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; } 
public void testCipherStreams ( ) throws InvalidKeyException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidAlgorithmParameterException , IllegalBlockSizeException , BadPaddingException , IOException { tfinal int MESSAGE_LENGTH = 1024 ; tbyte [ ] key = new byte [ 32 ] ; tbyte [ ] iv = new byte [ 16 ] ; tbyte [ ] plaintext = new byte [ MESSAGE_LENGTH ] ; trand . nextBytes ( key ) ; trand . nextBytes ( iv ) ; trand . nextBytes ( plaintext ) ; tCipherEngine aes = CipherFactory . getInstance ( AesEngine . CIPHER_UUID ) ; tCipher encrypt = aes . getCipher ( Cipher . ENCRYPT_MODE , key , iv ) ; tCipher decrypt = aes . getCipher ( Cipher . DECRYPT_MODE , key , iv ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tCipherOutputStream cos = new CipherOutputStream ( bos , encrypt ) ; tcos . write ( plaintext ) ; tcos . close ( ) ; tbyte [ ] secrettext = bos . toByteArray ( ) ; tByteArrayInputStream bis = new ByteArrayInputStream ( secrettext ) ; tBetterCipherInputStream cis = new BetterCipherInputStream ( bis , decrypt ) ; tLEDataInputStream lis = new LEDataInputStream ( cis ) ; tbyte [ ] decrypttext = lis . readBytes ( MESSAGE_LENGTH ) ; tassertArrayEquals ( " Encryption and decryption failed " , plaintext , decrypttext ) ; } 
public void testReadHeader ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; tassertEquals ( 6000 , db . numKeyEncRounds ) ; tassertTrue ( db . dataCipher . equals ( AesEngine . CIPHER_UUID ) ) ; tis . close ( ) ; 
public static CipherEngine getInstance ( UUID uuid ) throws NoSuchAlgorithmException { tif ( uuid . equals ( AesEngine . CIPHER_UUID ) ) { treturn new AesEngine ( ) ; } else if ( uuid . equals ( TwofishEngine . CIPHER_UUID ) ) { treturn new TwofishEngine ( ) ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public static byte [ ] resizeKey ( byte [ ] in , int inOffset , int cbIn , int cbOut ) { if ( cbOut = = 0 ) return new byte [ 0 ] ; byte [ ] hash ; if ( cbOut < = 32 ) { hash = hashSha256 ( in , inOffset , cbIn ) ; } else { hash = hashSha512 ( in , inOffset , cbIn ) ; } if ( cbOut = = hash . length ) { return hash ; } byte [ ] ret = new byte [ cbOut ] ; if ( cbOut < hash . length ) { System . arraycopy ( hash , 0 , ret , 0 , cbOut ) ; } else { int pos = 0 ; long r = 0 ; while ( pos < cbOut ) { Mac hmac ; try { hmac = Mac . getInstance ( " HmacSHA256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } byte [ ] pbR = LEDataOutputStream . writeLongBuf ( r ) ; byte [ ] part = hmac . doFinal ( pbR ) ; int copy = Math . min ( cbOut - pos , part . length ) ; assert ( copy > 0 ) ; System . arraycopy ( part , 0 , ret , pos , copy ) ; pos + = copy ; r + + ; Arrays . fill ( part , ( byte ) 0 ) ; } assert ( pos = = cbOut ) ; } Arrays . fill ( hash , ( byte ) 0 ) ; return ret ; } 
public static byte [ ] hashSha256 ( byte [ ] data ) { return hashSha256 ( data , 0 , data . length ) ; } 
public static byte [ ] hashSha256 ( byte [ ] data , int offset , int count ) { return hashGen ( " SHA-256 " , data , offset , count ) ; } 
public static byte [ ] hashSha512 ( byte [ ] data , int offset , int count ) { return hashGen ( " SHA-512 " , data , offset , count ) ; } 
public static byte [ ] hashGen ( String transform , byte [ ] data , int offset , int count ) { MessageDigest hash ; try { hash = MessageDigest . getInstance ( transform ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } NullOutputStream nos = new NullOutputStream ( ) ; DigestOutputStream dos = new DigestOutputStream ( nos , hash ) ; try { dos . write ( data , offset , count ) ; dos . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return hash . digest ( ) ; } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " , androidOverride ) ; cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher = Cipher . getInstance ( " Chacha " ) ; cipher . init ( opmode , new SecretKeySpec ( key , " ChaCha " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } 
public abstract Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException ; public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { return getCipher ( opmode , key , IV , false ) ; } } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { return getCipher ( opmode , key , IV , false ) ; } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher ; if ( opmode = = Cipher . ENCRYPT_MODE ) { cipher = CipherFactory . getInstance ( " Twofish/CBC/ZeroBytePadding " , androidOverride ) ; } else { cipher = CipherFactory . getInstance ( " Twofish/CBC/NoPadding " , androidOverride ) ; } cipher . init ( opmode , new SecretKeySpec ( key , " AES " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } 
protected static byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , int rounds ) throws IOException { FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . transformMasterKey ( pKeySeed , pKey , rounds ) ; } 
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) throws IOException { tbyte [ ] transformedMasterKey = transformMasterKey ( masterSeed2 , masterKey , numRounds ) ; byte [ ] cmpKey = new byte [ 65 ] ; tSystem . arraycopy ( masterSeed , 0 , cmpKey , 0 , 32 ) ; System . arraycopy ( transformedMasterKey , 0 , cmpKey , 32 , 32 ) ; tfinalKey = CryptoUtil . resizeKey ( cmpKey , 0 , 64 , dataEngine . keyLength ( ) ) ; MessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-512 " ) ; 
public HeaderAndHash loadFromFile ( InputStream is ) throws IOException , InvalidDBVersionException { tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " No SHA-256 implementation " ) ; } tByteArrayOutputStream headerBOS = new ByteArrayOutputStream ( ) ; tCopyInputStream cis = new CopyInputStream ( is , headerBOS ) ; tDigestInputStream dis = new DigestInputStream ( cis , md ) ; tLEDataInputStream lis = new LEDataInputStream ( dis ) ; tint sig1 = lis . readInt ( ) ; tint sig2 = lis . readInt ( ) ; tif ( ! matchesHeader ( sig1 , sig2 ) ) { tthrow new InvalidDBVersionException ( ) ; } tversion = lis . readUInt ( ) ; tif ( ! validVersion ( version ) ) { tthrow new InvalidDBVersionException ( ) ; } tboolean done = false ; twhile ( ! done ) { tdone = readHeaderField ( lis ) ; } tbyte [ ] hash = md . digest ( ) ; treturn new HeaderAndHash ( headerBOS . toByteArray ( ) , hash ) ; } 
private boolean validVersion ( long version ) { treturn ! ( ( version & FILE_VERSION_CRITICAL_MASK ) > ( FILE_VERSION_32_3 & FILE_VERSION_CRITICAL_MASK ) ) ; 
public static byte [ ] computeHeaderHmac ( byte [ ] header , byte [ ] key ) throws IOException { tbyte [ ] headerHmac ; tbyte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , Types . ULONG_MAX_VALUE ) ; tMac hmac ; ttry { thmac = Mac . getInstance ( " HmacSHA256 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " No HmacAlogirthm " ) ; } treturn hmac . doFinal ( header ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tInputStream keyInputStream , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; tPwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; thashOfHeader = hh . hash ; tpbHeader = hh . header ; tdb . setMasterKey ( password , keyInputStream ) ; tdb . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) db . numKeyEncRounds ) ; tInputStream isPlain ; tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { 
public void output ( ) throws IOException { tlos . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; tlos . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; tlos . writeUInt ( PwDbHeaderV4 . FILE_VERSION_32_3 ) ; twriteHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . transformSeed ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; twriteHeaderField ( PwDbHeaderV4Fields . ProtectedStreamKey , header . protectedStreamKey ) ; twriteHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; twriteHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; tlos . flush ( ) ; thashOfHeader = dos . getMessageDigest ( ) . digest ( ) ; } 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) throws PwDbOutputException { tCipher cipher ; tCipherEngine engine ; ttry { tmPM . makeFinalKey ( header . masterSeed , header . transformSeed , ( int ) mPM . numKeyEncRounds ) ; tengine = CipherFactory . getInstance ( mPM . dataCipher ) ; tcipher = engine . getCipher ( Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { tthrow new PwDbOutputException ( " Invalid algorithm. " , e ) ; } tCipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; treturn cos ; } 
public int read ( ) throws IOException { if ( endOfStream ) return - 1 ; if ( bufferPos = = buffer . length ) { if ( ! readSafeBlock ( ) ) return - 1 ; } int output = Types . readUByte ( buffer , bufferPos ) ; bufferPos + + ; return output ; } 
public int read ( byte [ ] outBuffer , int byteOffset , int byteCount ) throws IOException { int remaining = byteCount ; while ( remaining > 0 ) { if ( bufferPos = = buffer . length ) { if ( ! readSafeBlock ( ) ) { return byteCount - remaining ; } } int copy = Math . min ( buffer . length - bufferPos , remaining ) ; assert ( copy > 0 ) ; System . arraycopy ( buffer , bufferPos , outBuffer , byteOffset , copy ) ; byteOffset + = copy ; bufferPos + = copy ; remaining - = copy ; } return byteCount ; } 
public int read ( byte [ ] outBuffer ) throws IOException { return read ( outBuffer , 0 , outBuffer . length ) ; } 
private boolean readSafeBlock ( ) throws IOException { if ( endOfStream ) return false ; byte [ ] storedHmac = baseStream . readBytes ( 32 ) ; if ( storedHmac = = null | | storedHmac . length ! = 32 ) { throw new IOException ( " File corrupted " ) ; } byte [ ] pbBlockIndex = LEDataOutputStream . writeLongBuf ( blockIndex ) ; byte [ ] pbBlockSize = baseStream . readBytes ( 4 ) ; if ( pbBlockSize = = null | | pbBlockSize . length ! = 4 ) { throw new IOException ( " File corrupted " ) ; } int blockSize = LEDataInputStream . readInt ( pbBlockSize , 0 ) ; bufferPos = 0 ; buffer = baseStream . readBytes ( blockSize ) ; if ( verify ) { byte [ ] cmpHmac ; byte [ ] pbBlockKey = HmacBlockStream . GetHmacKey64 ( key , blockIndex ) ; Mac hmac ; try { hmac = Mac . getInstance ( " HmacSHA256 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " Invalid Hmac " ) ; } hmac . update ( pbBlockIndex ) ; hmac . update ( pbBlockSize ) ; if ( buffer . length > 0 ) { hmac . update ( buffer ) ; } cmpHmac = hmac . doFinal ( ) ; Arrays . fill ( pbBlockKey , ( byte ) 0 ) ; if ( ! Arrays . equals ( cmpHmac , storedHmac ) ) { throw new IOException ( " Invalid Hmac " ) ; } } blockIndex + + ; if ( blockSize = = 0 ) { endOfStream = true ; return false ; } return true ; } 
public void close ( ) throws IOException { baseStream . close ( ) ; } 
public long skip ( long byteCount ) throws IOException { return 0 ; } 
public int available ( ) throws IOException { return buffer . length - bufferPos ; } 
boolean equals ( byte type ) { return type = = value ; } 
public static VariantDictionary deserialize ( LEDataInputStream lis ) throws IOException { VariantDictionary d = new VariantDictionary ( ) ; int version = lis . readUShort ( ) ; if ( ( version & VdmCritical ) > ( VdVersion & VdmCritical ) ) { throw new IOException ( " Invalid format " ) ; } while ( true ) { int type = lis . read ( ) ; if ( type < 0 ) { throw new IOException ( ( " Invalid format " ) ) ; } byte bType = ( byte ) type ; if ( VdType . None . equals ( bType ) ) { break ; } int nameLen = lis . readInt ( ) ; byte [ ] nameBuf = lis . readBytes ( nameLen ) ; if ( nameLen ! = nameBuf . length ) { throw new IOException ( " Invalid format " ) ; } String name = new String ( nameBuf , " UTF-8 " ) ; int valueLen = lis . readInt ( ) ; byte [ ] valueBuf = lis . readBytes ( valueLen ) ; if ( valueLen ! = valueBuf . length ) { throw new IOException ( " Invalid format " ) ; } if ( VdType . UInt32 . equals ( bType ) ) { if ( valueLen = = 4 ) { d . setUInt32 ( name , LEDataInputStream . readUInt ( valueBuf , 0 ) ) ; } } else if ( VdType . UInt64 . equals ( bType ) ) { if ( valueLen = = 8 ) { d . setUInt64 ( name , LEDataInputStream . readLong ( valueBuf , 0 ) ) ; } } else if ( VdType . Bool . equals ( bType ) ) { if ( valueLen = = 1 ) { d . setBool ( name , valueBuf [ 0 ] ! = 0 ) ; } } else if ( VdType . Int32 . equals ( bType ) ) { if ( valueLen = = 4 ) { d . setInt32 ( name , LEDataInputStream . readInt ( valueBuf , 0 ) ) ; } } else if ( VdType . Int64 . equals ( bType ) ) { if ( valueLen = = 8 ) { d . setInt64 ( name , LEDataInputStream . readLong ( valueBuf , 0 ) ) ; } } else if ( VdType . String . equals ( bType ) ) { d . setString ( name , new String ( valueBuf , " UTF-8 " ) ) ; } else if ( VdType . ByteArray . equals ( bType ) ) { d . setByteArray ( name , valueBuf ) ; } else { assert ( false ) ; } } return d ; } 
public void copyTo ( VariantDictionary d ) { for ( Map . Entry < String , Object > entry : d . dict . entrySet ( ) ) { String key = entry . getKey ( ) ; 
public static byte [ ] hashSha512 ( byte [ ] data ) { return hashSha512 ( data , 0 , data . length ) ; } 
public static boolean init ( ) { tif ( ! isLoaded ) { ttry { tSystem . loadLibrary ( " final-key " ) ; tSystem . loadLibrary ( " argon2 " ) ; } catch ( UnsatisfiedLinkError e ) { treturn false ; } tisLoaded = true ; tloadSuccess = true ; } treturn loadSuccess ; 
public byte [ ] transformMasterKey ( byte [ ] pKeySeed , byte [ ] pKey , long rounds ) throws IOException { tCipher cipher ; ttry { tcipher = Cipher . getInstance ( " AES/ECB/NoPadding " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " NoSuchAlgorithm: " + e . getMessage ( ) ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " NoSuchPadding: " + e . getMessage ( ) ) ; } ttry { tcipher . init ( Cipher . ENCRYPT_MODE , new SecretKeySpec ( pKeySeed , " AES " ) ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " InvalidPasswordException: " + e . getMessage ( ) ) ; } } 
public abstract byte [ ] transformMasterKey ( byte [ ] seed , byte [ ] key , long rounds ) throws IOException ; } 
public byte [ ] transformMasterKey ( byte [ ] seed , byte [ ] key , long rounds ) throws IOException { tNativeLib . init ( ) ; treturn nTransformMasterKey ( seed , key , rounds ) ; 
private static native byte [ ] nTransformMasterKey ( byte [ ] seed , byte [ ] key , long rounds ) ; } 
public byte [ ] transform ( byte [ ] masterKey , KdfParameters p ) throws IOException { long rounds = p . getUInt64 ( ParamRounds ) ; byte [ ] seed = p . getByteArray ( ParamSeed ) ; if ( masterKey . length ! = 32 ) { masterKey = CryptoUtil . hashSha256 ( masterKey ) ; } if ( seed . length ! = 32 ) { seed = CryptoUtil . hashSha256 ( seed ) ; } FinalKey key = FinalKeyFactory . createFinalKey ( ) ; return key . transformMasterKey ( seed , masterKey , rounds ) ; } 
public void randomize ( KdfParameters p ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] seed = new byte [ 32 ] ; random . nextBytes ( seed ) ; p . setByteArray ( ParamSeed , seed ) ; } 
public byte [ ] transform ( byte [ ] masterKey , KdfParameters p ) throws IOException { byte [ ] salt = p . getByteArray ( ParamSalt ) ; int parallelism = ( int ) p . getUInt32 ( ParamParallelism ) ; long memory = p . getUInt64 ( ParamMemory ) ; long iterations = p . getUInt64 ( ParamIterations ) ; long version = p . getUInt32 ( ParamVersion ) ; byte [ ] secretKey = p . getByteArray ( ParamSecretKey ) ; byte [ ] assocData = p . getByteArray ( ParamAssocData ) ; return Argon2Native . transformKey ( masterKey , salt , parallelism , memory , iterations , secretKey , assocData , version ) ; 
public void randomize ( KdfParameters p ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] salt = new byte [ 32 ] ; random . nextBytes ( salt ) ; p . setByteArray ( ParamSalt , salt ) ; } 
public static byte [ ] transformKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version ) throws IOException { NativeLib . init ( ) ; return nTransformMasterKey ( password , salt , parallelism , memory , iterations , secretKey , associatedData , version ) ; } 
private static native byte [ ] nTransformMasterKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version ) throws IOException ; } 
public abstract byte [ ] transform ( byte [ ] masterKey , KdfParameters p ) throws IOException ; public abstract void randomize ( KdfParameters p ) ; } 
public static KdfEngine get ( UUID uuid ) { for ( KdfEngine engine : kdfList ) { if ( engine . uuid . equals ( uuid ) ) { return engine ; } } return null ; } 
public static KdfParameters deserialize ( byte [ ] data ) throws IOException { ByteArrayInputStream bis = new ByteArrayInputStream ( data ) ; LEDataInputStream lis = new LEDataInputStream ( bis ) ; VariantDictionary d = VariantDictionary . deserialize ( lis ) ; if ( d = = null ) { assert ( false ) ; return null ; } UUID uuid = Types . bytestoUUID ( d . getByteArray ( ParamUUID ) ) ; if ( uuid = = null ) { assert ( false ) ; return null ; } KdfParameters kdfP = new KdfParameters ( uuid ) ; kdfP . copyTo ( d ) ; return kdfP ; 
public ProtectedBinary get ( int key ) { treturn pool . get ( key ) ; } 
public ProtectedBinary put ( int key , ProtectedBinary value ) { treturn pool . put ( key , value ) ; } 
public Set < Entry < Integer , ProtectedBinary > > entrySet ( ) { treturn pool . entrySet ( ) ; } 
private void poolAdd ( ProtectedBinary pb ) { tassert ( pb ! = null ) ; tif ( poolFind ( pb ) ! = - 1 ) return ; tpool . put ( pool . size ( ) , pb ) ; } 
public int poolFind ( ProtectedBinary pb ) { tfor ( Entry < Integer , ProtectedBinary > pair : pool . entrySet ( ) ) { tif ( pair . getValue ( ) . equals ( pb ) ) return pair . getKey ( ) ; } treturn - 1 ; } 
public void makeFinalKey ( byte [ ] masterSeed , byte [ ] masterSeed2 , int numRounds ) throws IOException { tbyte [ ] transformedMasterKey = transformMasterKey ( masterSeed2 , masterKey , numRounds ) ; tbyte [ ] cmpKey = new byte [ 65 ] ; tSystem . arraycopy ( masterSeed , 0 , cmpKey , 0 , 32 ) ; tSystem . arraycopy ( transformedMasterKey , 0 , cmpKey , 32 , 32 ) ; tfinalKey = CryptoUtil . resizeKey ( cmpKey , 0 , 64 , dataEngine . keyLength ( ) ) ; tMessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-512 " ) ; 
public void makeFinalKey ( byte [ ] masterSeed , KdfParameters kdfP ) throws IOException { tKdfEngine kdfEngine = KdfFactory . get ( kdfP . kdfUUID ) ; tif ( kdfEngine = = null ) { tthrow new IOException ( " Unknown key derivation function " ) ; } tbyte [ ] transformedMasterKey = kdfEngine . transform ( masterKey , kdfP ) ; tif ( transformedMasterKey . length ! = 32 ) { ttransformedMasterKey = CryptoUtil . hashSha256 ( transformedMasterKey ) ; } byte [ ] cmpKey = new byte [ 65 ] ; tSystem . arraycopy ( masterSeed , 0 , cmpKey , 0 , 32 ) ; System . arraycopy ( transformedMasterKey , 0 , cmpKey , 32 , 32 ) ; tfinalKey = CryptoUtil . resizeKey ( cmpKey , 0 , 64 , dataEngine . keyLength ( ) ) ; MessageDigest md ; ttry { tmd = MessageDigest . getInstance ( " SHA-512 " ) ; 
private boolean readHeaderField ( LEDataInputStream dis ) throws IOException { tbyte fieldID = ( byte ) dis . read ( ) ; tint fieldSize ; tif ( version < FILE_VERSION_32_4 ) { tfieldSize = dis . readUShort ( ) ; } else { tfieldSize = dis . readInt ( ) ; } tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = dis . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tAesKdf kdfS = new AesKdf ( ) ; tif ( ! db . kdfParameters . kdfUUID . equals ( kdfS . uuid ) ) { tdb . kdfParameters = kdfS . getDefaultParameters ( ) ; } tdb . kdfParameters . setByteArray ( AesKdf . ParamSeed , fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tAesKdf kdfR = new AesKdf ( ) ; tif ( ! db . kdfParameters . kdfUUID . equals ( kdfR . uuid ) ) { tdb . kdfParameters = kdfR . getDefaultParameters ( ) ; } tdb . kdfParameters . setUInt64 ( AesKdf . ParamRounds , LEDataInputStream . readLong ( fieldData , 0 ) ) ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tencryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomstreamKey : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tprotectedStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tstreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tsetRandomStreamID ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . KdfParameters : tdb . kdfParameters = KdfParameters . deserialize ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . PublicCustomData : tdb . publicCustomData = KdfParameters . deserialize ( fieldData ) ; tdefault : tthrow new IOException ( " Invalid header type: " + fieldID ) ; } treturn false ; } 
public void setRandomStreamID ( byte [ ] streamID ) throws IOException { tif ( streamID = = null | | streamID . length ! = 4 ) { tthrow new IOException ( " Invalid stream id. " ) ; } tint id = LEDataInputStream . readInt ( streamID , 0 ) ; tif ( id < 0 | | id > = CrsAlgorithm . count ) { tthrow new IOException ( " Invalid stream id. " ) ; } tinnerRandomStream = CrsAlgorithm . fromId ( id ) ; } 
public static byte [ ] computeHeaderHmac ( byte [ ] header , byte [ ] key ) throws IOException { tbyte [ ] headerHmac ; tbyte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , Types . ULONG_MAX_VALUE ) ; tMac hmac ; ttry { thmac = Mac . getInstance ( " HmacSHA256 " ) ; tSecretKeySpec signingKey = new SecretKeySpec ( blockKey , " HmacSHA256 " ) ; thmac . init ( signingKey ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " No HmacAlogirthm " ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " Invalid Hmac Key " ) ; } treturn hmac . doFinal ( header ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tInputStream keyInputStream , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; tPwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; thashOfHeader = hh . hash ; tpbHeader = hh . header ; tdb . setMasterKey ( password , keyInputStream ) ; tdb . makeFinalKey ( header . masterSeed , db . kdfParameters ) ; tCipherEngine engine ; tCipher cipher ; ttry { tengine = CipherFactory . getInstance ( db . dataCipher ) ; tdb . dataEngine = engine ; tcipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } tInputStream isPlain ; tif ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { tInputStream decrypted = AttachCipherStream ( inStream , cipher ) ; tLEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; tbyte [ ] storedStartBytes = null ; ttry { tstoredStartBytes = dataDecrypted . readBytes ( 32 ) ; tif ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { tthrow new InvalidPasswordException ( ) ; } } catch ( IOException e ) { tthrow new InvalidPasswordException ( ) ; } tif ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { tthrow new InvalidPasswordException ( ) ; } tisPlain = new HashedBlockInputStream ( dataDecrypted ) ; } telse { 
private InputStream AttachCipherStream ( InputStream is , Cipher cipher ) { treturn new BetterCipherInputStream ( is , cipher , 50 * 1024 ) ; } 
private void LoadInnerHeader ( InputStream is , PwDbHeaderV4 header ) throws IOException { tLEDataInputStream lis = new LEDataInputStream ( is ) ; twhile ( true ) { tif ( ! ReadInnerHeader ( lis , header ) ) break ; 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) throws IOException { tbyte fieldId = ( byte ) lis . read ( ) ; tint size = lis . readInt ( ) ; tif ( size < 0 ) throw new IOException ( " Corrupted file " ) ; tbyte [ ] data = new byte [ 0 ] ; tif ( size > 0 ) { tdata = lis . readBytes ( size ) ; } tboolean result = true ; tswitch ( fieldId ) { tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : tresult = false ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . protectedStreamKey = data ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : if ( data . length < 1 ) throw new IOException ( " Invalid binary format " ) ; tbyte flag = data [ 0 ] ; tboolean prot = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = tPwDbHeaderV4 . KdbxBinaryFlags . None ; tbyte [ ] bin = new byte [ data . length - 1 ] ; tSystem . arraycopy ( data , 1 , bin , 0 , data . length - 1 ) ; tProtectedBinary pb = new ProtectedBinary ( prot , bin ) ; tif ( prot ) { tArrays . fill ( data , ( byte ) 0 ) ; } tbreak ; tdefault : tassert ( false ) ; tbreak ; } treturn result ; } 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate = null ; tif ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { tbyte [ ] buf = Base64Coder . decode ( sDate ) ; tif ( buf . length ! = 8 ) { tbyte [ ] buf8 = new byte [ 8 ] ; tSystem . arraycopy ( buf , 0 , buf8 , 0 , buf . length ) ; tbuf = buf8 ; } tlong seconds = LEDataInputStream . readLong ( buf , 0 ) ; tutcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { ttry { tutcDate = PwDatabaseV4XML . dateFormat . parse ( sDate ) ; } catch ( ParseException e ) { 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tString ref = xpp . getAttributeValue ( null , AttrRef ) ; tif ( ref ! = null ) { txpp . next ( ) ; } 
public void output ( ) throws IOException { tlos . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; tlos . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; los . writeUInt ( header . version ) ; twriteHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . getTransformSeed ( ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; twriteHeaderField ( PwDbHeaderV4Fields . InnerRandomstreamKey , header . protectedStreamKey ) ; twriteHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; twriteHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; tlos . flush ( ) ; thashOfHeader = dos . getMessageDigest ( ) . digest ( ) ; } 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random ; ttry { trandom = SecureRandom . getInstance ( " SHA1PRNG " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new PwDbOutputException ( " Does not support secure random number generation. " ) ; } trandom . nextBytes ( header . encryptionIV ) ; trandom . nextBytes ( header . masterSeed ) ; treturn random ; } 
public byte [ ] getFinalKey ( PwDbHeader header ) throws PwDbOutputException { ttry { tPwDbHeaderV3 h3 = ( PwDbHeaderV3 ) header ; 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random = super . setIVs ( header ) ; tPwDbHeaderV3 h3 = ( PwDbHeaderV3 ) header ; trandom . nextBytes ( h3 . transformSeed ) ; treturn random ; } 
public void output ( ) throws PwDbOutputException { theader = ( PwDbHeaderV4 ) outputHeader ( mOS ) ; tCipherOutputStream cos = attachStreamEncryptor ( header , mOS ) ; tOutputStream compressed ; ttry { tcos . write ( header . streamStartBytes ) ; 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) throws PwDbOutputException { tCipher cipher ; tCipherEngine engine ; ttry { tmPM . makeFinalKey ( header . masterSeed , header . getTransformSeed ( ) , ( int ) mPM . numKeyEncRounds ) ; tengine = CipherFactory . getInstance ( mPM . dataCipher ) ; tcipher = engine . getCipher ( Cipher . ENCRYPT_MODE , mPM . finalKey , header . encryptionIV ) ; } catch ( Exception e ) { tthrow new PwDbOutputException ( " Invalid algorithm. " , e ) ; } tCipherOutputStream cos = new CipherOutputStream ( os , cipher ) ; treturn cos ; } 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random = super . setIVs ( header ) ; tPwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; trandom . nextBytes ( h . masterSeed ) ; trandom . nextBytes ( h . encryptionIV ) ; tUUID kdfUUID = mPM . kdfParameters . kdfUUID ; tKdfEngine kdf = KdfFactory . get ( kdfUUID ) ; tkdf . randomize ( mPM . kdfParameters ) ; trandom . nextBytes ( h . protectedStreamKey ) ; th . innerRandomStream = CrsAlgorithm . Salsa20 ; trandomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . protectedStreamKey ) ; tif ( randomStream = = null ) { tthrow new PwDbOutputException ( " Invalid random cipher " ) ; } trandom . nextBytes ( h . streamStartBytes ) ; treturn random ; } 
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( key ! = null & & value ! = null ) ; txml . startTag ( null , ElemBinary ) ; txml . startTag ( null , ElemKey ) ; txml . text ( safeXmlString ( key ) ) ; txml . endTag ( null , ElemKey ) ; txml . startTag ( null , ElemValue ) ; tString strRef = null ; tif ( allowRef ) { tint ref = binPool . poolFind ( value ) ; tstrRef = Integer . toString ( ref ) ; } tif ( strRef ! = null ) { txml . attribute ( null , AttrRef , strRef ) ; } telse { tsubWriteValue ( value ) ; } txml . endTag ( null , ElemValue ) ; txml . endTag ( null , ElemBinary ) ; } 
private void writeBinPool ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemBinaries ) ; tfor ( Entry < Integer , ProtectedBinary > pair : binPool . entrySet ( ) ) { txml . startTag ( null , ElemBinary ) ; txml . attribute ( null , AttrId , Integer . toString ( pair . getKey ( ) ) ) ; tsubWriteValue ( pair . getValue ( ) ) ; txml . endTag ( null , ElemBinary ) ; } txml . endTag ( null , ElemBinaries ) ; 
public int read ( byte [ ] outBuffer , int byteOffset , int byteCount ) throws IOException { int remaining = byteCount ; while ( remaining > 0 ) { if ( bufferPos = = buffer . length ) { if ( ! readSafeBlock ( ) ) { int read = byteCount - remaining ; if ( read < = 0 ) { return - 1 ; } else { return byteCount - remaining ; } } } int copy = Math . min ( buffer . length - bufferPos , remaining ) ; assert ( copy > 0 ) ; System . arraycopy ( buffer , bufferPos , outBuffer , byteOffset , copy ) ; byteOffset + = copy ; bufferPos + = copy ; remaining - = copy ; } return byteCount ; } 
private boolean readSafeBlock ( ) throws IOException { if ( endOfStream ) return false ; byte [ ] storedHmac = baseStream . readBytes ( 32 ) ; if ( storedHmac = = null | | storedHmac . length ! = 32 ) { throw new IOException ( " File corrupted " ) ; } byte [ ] pbBlockIndex = LEDataOutputStream . writeLongBuf ( blockIndex ) ; byte [ ] pbBlockSize = baseStream . readBytes ( 4 ) ; if ( pbBlockSize = = null | | pbBlockSize . length ! = 4 ) { throw new IOException ( " File corrupted " ) ; } int blockSize = LEDataInputStream . readInt ( pbBlockSize , 0 ) ; bufferPos = 0 ; buffer = baseStream . readBytes ( blockSize ) ; if ( verify ) { byte [ ] cmpHmac ; byte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , blockIndex ) ; Mac hmac ; try { hmac = Mac . getInstance ( " HmacSHA256 " ) ; SecretKeySpec signingKey = new SecretKeySpec ( blockKey , " HmacSHA256 " ) ; hmac . init ( signingKey ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " Invalid Hmac " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid Hmac " ) ; } hmac . update ( pbBlockIndex ) ; hmac . update ( pbBlockSize ) ; if ( buffer . length > 0 ) { hmac . update ( buffer ) ; } cmpHmac = hmac . doFinal ( ) ; Arrays . fill ( blockKey , ( byte ) 0 ) ; if ( ! Arrays . equals ( cmpHmac , storedHmac ) ) { throw new IOException ( " Invalid Hmac " ) ; } } blockIndex + + ; if ( blockSize = = 0 ) { endOfStream = true ; return false ; } return true ; } 
 public UUID readUUID ( ) throws IOException { byte [ ] buf = readBytes ( 16 ) ; return Types . bytestoUUID ( buf ) ; } 
public static Date convertKDBX4Time ( long seconds ) { return dotNetEpoch . plus ( seconds ) . toDate ( ) ; } 
public static void Launch ( Activity act , String fileName ) throws FileNotFoundException { Launch ( act , fileName , " " ) ; } 
public static void Launch ( Activity act , String fileName , String keyFile ) throws FileNotFoundException { if ( EmptyUtils . isNullOrEmpty ( fileName ) ) { throw new FileNotFoundException ( ) ; } Uri uri = UriUtil . parseDefaultFile ( fileName ) ; String scheme = uri . getScheme ( ) ; if ( ! EmptyUtils . isNullOrEmpty ( scheme ) & & scheme . equalsIgnoreCase ( " file " ) ) { File dbFile = new File ( uri . getPath ( ) ) ; if ( ! dbFile . exists ( ) ) { throw new FileNotFoundException ( ) ; } } Intent i = new Intent ( act , PasswordActivity . class ) ; i . putExtra ( KEY_FILENAME , fileName ) ; i . putExtra ( KEY_KEYFILE , keyFile ) ; act . startActivityForResult ( i , 0 ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); checks if fingerprint is available, will also start listening for fingerprints when available checkAvailability(); } 
private void errorMessage ( int resId ) { Toast . makeText ( this , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
private void initForFingerprint ( ) { TODO implement runtime permissions needed here? TODO double check on lower API levels if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { fingerPrintHelper = new FingerPrintHelper(this, this); 
public void afterTextChanged ( final Editable s ) { final boolean validInput = s . length ( ) > 0 ; encrypt or decrypt mode based on how much input or not confirmationView.setText(validInput ? R.string.store_with_fingerprint : R.string.scanning_fingerprint); mode = validInput ? toggleMode(Cipher.ENCRYPT_MODE) : toggleMode(Cipher.DECRYPT_MODE); 
public void onAuthenticationHelp ( final int helpCode , final CharSequence helpString ) { onException ( ) ; confirmationView . setText ( helpString ) ; } 
public void onAuthenticationSucceeded ( final FingerprintManager . AuthenticationResult result ) { if ( mode = = Cipher . ENCRYPT_MODE ) { 
public void onAuthenticationFailed ( ) { onException ( ) ; } 
private int toggleMode ( final int newMode ) { check if mode is different so we can update fingerprint helper if (mode != newMode) { mode = newMode; fingerPrintHelper.initForMode(mode); return newMode; } remains in current mode return mode; } 
protected void onPause ( ) { super . onPause ( ) ; stop listening when we go in background if (fingerPrintHelper != null) { fingerPrintHelper.stopListening(); 
private void checkAvailability ( ) { fingerprint not supported (by API level or hardware) so keep option hidden if (!fingerPrintHelper.isFingerprintSupported()) { 
public void handleResult ( final String value ) { if ( mode = = Cipher . ENCRYPT_MODE ) { 
public void onInvalidKeyException ( ) { Toast . makeText ( this , R . string . fingerprint_invalid_key , Toast . LENGTH_SHORT ) . show ( ) ; checkAvailability ( ) ; restarts listening } 
public void onException ( ) { Toast . makeText ( this , R . string . fingerprint_error , Toast . LENGTH_SHORT ) . show ( ) ; checkAvailability ( ) ; restarts listening } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . toString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManagerCompat backupManager = new BackupManagerCompat ( PasswordActivity . this ) ; backupManager . dataChanged ( ) ; 
private void loadDatabase ( String pass , String keyfile ) { loadDatabase ( pass , UriUtil . parseDefaultFile ( keyfile ) ) ; } 
private void loadDatabase ( String pass , Uri keyfile ) { if ( pass . length ( ) = = 0 & & ( keyfile = = null | | keyfile . toString ( ) . length ( ) = = 0 ) ) { errorMessage ( R . string . error_nopass ) ; return ; } Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, mDbUri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
private void setEditText ( int resId , String str ) { TextView te = ( TextView ) findViewById ( resId ) ; assert ( te = = null ) ; if ( te ! = null ) { te . setText ( str ) ; 
public void run ( ) { if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( PasswordActivity . this ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
public void startListening ( ) { no need to start listening when not initialised if (!isFingerprintInitialized()) { if (fingerPrintCallback != null) { fingerPrintCallback.onException(); } return; } starts listening for fingerprints with the initialised crypto object cancellationSignal = new CancellationSignal(); fingerprintManager.authenticate( cryptoObject, 
public void stopListening ( ) { if ( ! isFingerprintInitialized ( ) ) { return ; } if ( cancellationSignal ! = null ) { cancellationSignal . cancel ( ) ; 
public void initForMode ( final int mode ) { switch ( mode ) { case Cipher . ENCRYPT_MODE : { 
public boolean isFingerprintInitialized ( ) { return hasEnrolledFingerprints ( ) & & initOk ; } 
public void initEncryptData ( ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } try { createNewKeyIfNeeded ( false ) ; no need to keep deleting existing keys 
public void encryptData ( final String value ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } try { actual do encryption here 
public void initDecryptData ( ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } try { createNewKeyIfNeeded ( false ) ; 
public void decryptData ( final String encryptedValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } try { actual decryption here 
private void createNewKeyIfNeeded ( final boolean allowDeleteExisting ) { if ( ! isFingerprintInitialized ( ) ) { return ; } try { keyStore . load ( null ) ; 
public boolean isHardwareDetected ( ) { return isFingerprintSupported ( ) & & fingerprintManager ! = null 
public boolean hasEnrolledFingerprints ( ) { fingerprint hardware supported and api level OK return isHardwareDetected() fingerprints enrolled 
public boolean isFingerprintSupported ( ) { return Build . VERSION . SDK_INT > = MINIMAL_REQUIRED_SDK_VERSION ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; fingerprintView = findViewById ( R . id . fingerprint ) ; confirmationView = ( TextView ) findViewById ( R . id . fingerprint_label ) ; passwordView = ( EditText ) findViewById ( R . id . password ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
private void initForFingerprint ( ) { if ( fingerPrintHelper . isFingerprintSupported ( ) ) { fingerPrintHelper = new FingerPrintHelper ( this , this ) ; 
public boolean isFingerprintSupported ( ) { return Build . VERSION . SDK_INT > = Build . VERSION_CODES . M ; } 
private void initForFingerprint ( ) { fingerPrintHelper = new FingerPrintHelper ( this , this ) ; if ( fingerPrintHelper . isFingerprintSupported ( ) ) { 
private int toggleMode ( final int newMode ) { check if mode is different so we can update fingerprint helper if (mode != newMode) { mode = newMode; switch (mode) { case Cipher.ENCRYPT_MODE: fingerPrintHelper.initEncryptData(); break; case Cipher.DECRYPT_MODE: final String ivSpecValue = prefs.getString(getPreferenceKeyIvSpec(), null); fingerPrintHelper.initDecryptData(ivSpecValue); break; } return newMode; } remains in current mode return mode; } 
public void handleEncryptedResult ( final String value , final String ivSpec ) { prefs . edit ( ) . putString ( getPreferenceKeyValue ( ) , value ) . putString ( getPreferenceKeyIvSpec ( ) , ivSpec ) . commit ( ) ; and remove visual input to reset UI passwordView.setText(""); confirmationView.setText(R.string.encrypted_value_stored); } 
public void handleDecryptedResult ( final String value ) { on decrypt enter it for the purchase/login action passwordView.setText(value); confirmButton.performClick(); } 
public void initDecryptData ( final String ivSpecValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } try { createNewKeyIfNeeded ( false ) ; 
public void decryptData ( final String encryptedValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } try { actual decryption here 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
private void checkStoragePermission ( ) { Manifest.permission.WRITE_EXTERNAL_STORAGE) 
public void onRequestPermissionsResult ( int requestCode , String permissions [ ] , int [ ] grantResults ) { tswitch ( requestCode ) { tcase MY_PERMISSIONS_REQUEST_EXTERNAL_STORAGE : { 
public void testSavingKDBXV3 ( ) throws IOException , InvalidDBException , PwDbOutputException { testSaving ( " test.kdbx " , " 12345 " , " test-out.kdbx " ) ; } 
public void testSavingKDBXV4 ( ) throws IOException , InvalidDBException , PwDbOutputException { testSaving ( " test-kdbxv4.kdbx " , " 1 " , " test-kdbxv4-out.kdbx " ) ; } 
private void testSaving ( String inputFile , String password , String outputFile ) throws IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( inputFile , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , password , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . toByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getSdPath ( outputFile ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , password , null ) ; bis . close ( ) ; fos . close ( ) ; 
private void putType ( byte type , String name , Object value ) { dict . put ( name , new VdType ( type , value ) ) ; } 
public static VariantDictionary deserialize ( LEDataInputStream lis ) throws IOException { VariantDictionary d = new VariantDictionary ( ) ; int version = lis . readUShort ( ) ; if ( ( version & VdmCritical ) > ( VdVersion & VdmCritical ) ) { throw new IOException ( " Invalid format " ) ; } while ( true ) { int type = lis . read ( ) ; if ( type < 0 ) { throw new IOException ( ( " Invalid format " ) ) ; } byte bType = ( byte ) type ; if ( bType = = VdType . None ) { break ; } int nameLen = lis . readInt ( ) ; byte [ ] nameBuf = lis . readBytes ( nameLen ) ; if ( nameLen ! = nameBuf . length ) { throw new IOException ( " Invalid format " ) ; } String name = new String ( nameBuf , " UTF-8 " ) ; int valueLen = lis . readInt ( ) ; byte [ ] valueBuf = lis . readBytes ( valueLen ) ; if ( valueLen ! = valueBuf . length ) { throw new IOException ( " Invalid format " ) ; } switch ( bType ) { case VdType . UInt32 : if ( valueLen = = 4 ) { d . setUInt32 ( name , LEDataInputStream . readUInt ( valueBuf , 0 ) ) ; } break ; case VdType . UInt64 : if ( valueLen = = 8 ) { d . setUInt64 ( name , LEDataInputStream . readLong ( valueBuf , 0 ) ) ; } break ; case VdType . Bool : if ( valueLen = = 1 ) { d . setBool ( name , valueBuf [ 0 ] ! = 0 ) ; } break ; case VdType . Int32 : if ( valueLen = = 4 ) { d . setInt32 ( name , LEDataInputStream . readInt ( valueBuf , 0 ) ) ; } break ; case VdType . Int64 : if ( valueLen = = 8 ) { d . setInt64 ( name , LEDataInputStream . readLong ( valueBuf , 0 ) ) ; } break ; case VdType . String : d . setString ( name , new String ( valueBuf , " UTF-8 " ) ) ; break ; case VdType . ByteArray : d . setByteArray ( name , valueBuf ) ; break ; default : assert ( false ) ; break ; } } return d ; } 
public static void serialize ( VariantDictionary d , LEDataOutputStream los ) throws IOException { if ( los = = null ) { assert ( false ) ; return ; } los . writeUShort ( VdVersion ) ; for ( Map . Entry < String , VdType > entry : d . dict . entrySet ( ) ) { String name = entry . getKey ( ) ; byte [ ] nameBuf = null ; try { nameBuf = name . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { assert ( false ) ; throw new IOException ( " Couldn't encode parameter name. " ) ; } VdType vd = entry . getValue ( ) ; los . write ( vd . type ) ; los . writeInt ( nameBuf . length ) ; los . write ( nameBuf ) ; byte [ ] buf ; switch ( vd . type ) { case VdType . UInt32 : los . writeInt ( 4 ) ; los . writeUInt ( ( long ) vd . value ) ; break ; case VdType . UInt64 : los . writeInt ( 8 ) ; los . writeLong ( ( long ) vd . value ) ; break ; case VdType . Bool : los . writeInt ( 1 ) ; byte bool = ( boolean ) vd . value ? ( byte ) 1 : ( byte ) 0 ; los . write ( bool ) ; break ; case VdType . Int32 : los . writeInt ( 4 ) ; los . writeInt ( ( int ) vd . value ) ; break ; case VdType . Int64 : los . writeInt ( 8 ) ; los . writeLong ( ( long ) vd . value ) ; break ; case VdType . String : String value = ( String ) vd . value ; buf = value . getBytes ( " UTF-8 " ) ; los . writeInt ( buf . length ) ; los . write ( buf ) ; break ; case VdType . ByteArray : buf = ( byte [ ] ) vd . value ; los . writeInt ( buf . length ) ; los . write ( buf ) ; break ; default : assert ( false ) ; break ; } } los . write ( VdType . None ) ; 
public void copyTo ( VariantDictionary d ) { for ( Map . Entry < String , VdType > entry : d . dict . entrySet ( ) ) { String key = entry . getKey ( ) ; 
public static byte [ ] serialize ( KdfParameters kdf ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; LEDataOutputStream los = new LEDataOutputStream ( bos ) ; KdfParameters . serialize ( kdf , los ) ; return bos . toByteArray ( ) ; } 
public boolean operate ( PwGroup group ) { if ( group = = null ) { treturn true ; } tPwGroupV4 g4 = ( PwGroupV4 ) group ; tif ( g4 . customData . size ( ) > 0 ) { thasCustomData = true ; treturn false ; } treturn true ; } 
public boolean operate ( PwEntry entry ) { if ( entry = = null ) { treturn true ; } tPwEntryV4 e4 = ( PwEntryV4 ) entry ; tif ( e4 . customData . size ( ) > 0 ) { thasCustomData = true ; treturn false ; } treturn true ; } 
private boolean readHeaderField ( LEDataInputStream dis ) throws IOException { tbyte fieldID = ( byte ) dis . read ( ) ; tint fieldSize ; tif ( version < FILE_VERSION_32_4 ) { tfieldSize = dis . readUShort ( ) ; } else { tfieldSize = dis . readInt ( ) ; } tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = dis . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tAesKdf kdfS = new AesKdf ( ) ; tif ( ! db . kdfParameters . kdfUUID . equals ( kdfS . uuid ) ) { tdb . kdfParameters = kdfS . getDefaultParameters ( ) ; } tdb . kdfParameters . setByteArray ( AesKdf . ParamSeed , fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tAesKdf kdfR = new AesKdf ( ) ; tif ( ! db . kdfParameters . kdfUUID . equals ( kdfR . uuid ) ) { tdb . kdfParameters = kdfR . getDefaultParameters ( ) ; } tdb . kdfParameters . setUInt64 ( AesKdf . ParamRounds , LEDataInputStream . readLong ( fieldData , 0 ) ) ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tencryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomstreamKey : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tinnerRandomStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tstreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tsetRandomStreamID ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . KdfParameters : tdb . kdfParameters = KdfParameters . deserialize ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . PublicCustomData : tdb . publicCustomData = KdfParameters . deserialize ( fieldData ) ; tdefault : tthrow new IOException ( " Invalid header type: " + fieldID ) ; } treturn false ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tInputStream keyInputStream , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; header . binaries . clear ( ) ; tPwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; thashOfHeader = hh . hash ; tpbHeader = hh . header ; tdb . setMasterKey ( password , keyInputStream ) ; tdb . makeFinalKey ( header . masterSeed , db . kdfParameters ) ; tCipherEngine engine ; tCipher cipher ; ttry { tengine = CipherFactory . getInstance ( db . dataCipher ) ; tdb . dataEngine = engine ; tcipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } tInputStream isPlain ; tif ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { tInputStream decrypted = AttachCipherStream ( inStream , cipher ) ; tLEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; tbyte [ ] storedStartBytes = null ; ttry { tstoredStartBytes = dataDecrypted . readBytes ( 32 ) ; tif ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { tthrow new InvalidPasswordException ( ) ; } } catch ( IOException e ) { tthrow new InvalidPasswordException ( ) ; } tif ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { tthrow new InvalidPasswordException ( ) ; } tisPlain = new HashedBlockInputStream ( dataDecrypted ) ; } telse { 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) throws IOException { tbyte fieldId = ( byte ) lis . read ( ) ; tint size = lis . readInt ( ) ; tif ( size < 0 ) throw new IOException ( " Corrupted file " ) ; tbyte [ ] data = new byte [ 0 ] ; tif ( size > 0 ) { tdata = lis . readBytes ( size ) ; } tboolean result = true ; tswitch ( fieldId ) { tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : tresult = false ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : if ( data . length < 1 ) throw new IOException ( " Invalid binary format " ) ; tbyte flag = data [ 0 ] ; tboolean prot = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = tPwDbHeaderV4 . KdbxBinaryFlags . None ; tbyte [ ] bin = new byte [ data . length - 1 ] ; tSystem . arraycopy ( data , 1 , bin , 0 , data . length - 1 ) ; tProtectedBinary pb = new ProtectedBinary ( prot , bin ) ; tif ( prot ) { tArrays . fill ( data , ( byte ) 0 ) ; } tbreak ; tdefault : tassert ( false ) ; tbreak ; } treturn result ; } 
public void output ( ) throws IOException { tlos . writeUInt ( PwDbHeader . PWM_DBSIG_1 ) ; tlos . writeUInt ( PwDbHeaderV4 . DBSIG_2 ) ; los . writeUInt ( header . version ) ; twriteHeaderField ( PwDbHeaderV4Fields . CipherID , Types . UUIDtoBytes ( db . dataCipher ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . CompressionFlags , LEDataOutputStream . writeIntBuf ( db . compressionAlgorithm . id ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . MasterSeed , header . masterSeed ) ; tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { twriteHeaderField ( PwDbHeaderV4Fields . TransformSeed , header . getTransformSeed ( ) ) ; twriteHeaderField ( PwDbHeaderV4Fields . TransformRounds , LEDataOutputStream . writeLongBuf ( db . numKeyEncRounds ) ) ; } else { writeHeaderField ( PwDbHeaderV4Fields . KdfParameters , KdfParameters . serialize ( db . kdfParameters ) ) ; } tif ( header . encryptionIV . length > 0 ) { twriteHeaderField ( PwDbHeaderV4Fields . EncryptionIV , header . encryptionIV ) ; } tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { twriteHeaderField ( PwDbHeaderV4Fields . InnerRandomstreamKey , header . innerRandomStreamKey ) ; twriteHeaderField ( PwDbHeaderV4Fields . StreamStartBytes , header . streamStartBytes ) ; twriteHeaderField ( PwDbHeaderV4Fields . InnerRandomStreamID , LEDataOutputStream . writeIntBuf ( header . innerRandomStream . id ) ) ; } tif ( db . publicCustomData . size ( ) > 0 ) { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tLEDataOutputStream los = new LEDataOutputStream ( bos ) ; tVariantDictionary . serialize ( db . publicCustomData , los ) ; twriteHeaderField ( PwDbHeaderV4Fields . PublicCustomData , bos . toByteArray ( ) ) ; } twriteHeaderField ( PwDbHeaderV4Fields . EndOfHeader , EndHeaderValue ) ; tlos . flush ( ) ; thashOfHeader = dos . getMessageDigest ( ) . digest ( ) ; theaderHmac = mos . getMac ( ) ; } 
private void writeHeaderField ( byte fieldId , byte [ ] pbData ) throws IOException { writeHeaderFieldSize(pbData.length); 
private void writeHeaderFieldSize ( int size ) throws IOException { tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { tlos . writeUShort ( size ) ; 
public void output ( ) throws IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : header . binaries ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } byte [ ] binData = bin . getData ( ) ; los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( bin . length ( ) + 1 ) ; los . write ( flag ) ; los . write ( binData ) ; Arrays . fill ( binData , ( byte ) 0 ) ; } los . write ( PwDbInnerHeaderV4Fields . EndOfHeader ) ; los . writeInt ( 0 ) ; } 
public void output ( ) throws PwDbOutputException { try { ttry { 
private void writeMeta ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemMeta ) ; twriteObject ( ElemGenerator , mPM . localizedAppName ) ; tif ( hashOfHeader ! = null ) { twriteObject ( ElemHeaderHash , String . valueOf ( Base64Coder . encode ( hashOfHeader ) ) ) ; } twriteObject ( ElemDbName , mPM . name , true ) ; twriteObject ( ElemDbNameChanged , mPM . nameChanged ) ; twriteObject ( ElemDbDesc , mPM . description , true ) ; twriteObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; twriteObject ( ElemDbDefaultUser , mPM . defaultUserName , true ) ; twriteObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; twriteObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; twriteObject ( ElemDbColor , mPM . color ) ; twriteObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; twriteObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; twriteObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; twriteList ( ElemMemoryProt , mPM . memoryProtection ) ; twriteCustomIconList ( ) ; twriteObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; twriteObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; twriteObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; twriteObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; twriteObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; twriteObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; twriteObject ( ElemHistoryMaxSize , mPM . historyMaxSize ) ; twriteObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; twriteObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { twriteBinPool ( ) ; } twriteList ( ElemCustomData , mPM . customData ) ; txml . endTag ( null , ElemMeta ) ; 
private CipherOutputStream attachStreamEncryptor ( PwDbHeaderV4 header , OutputStream os ) throws PwDbOutputException { tCipher cipher ; ttry { } 
tprotected SecureRandom setIVs ( PwDbHeader header ) throws PwDbOutputException { tSecureRandom random = super . setIVs ( header ) ; tPwDbHeaderV4 h = ( PwDbHeaderV4 ) header ; trandom . nextBytes ( h . masterSeed ) ; tint ivLength = engine . ivLength ( ) ; tif ( ivLength ! = h . encryptionIV . length ) { th . encryptionIV = new byte [ ivLength ] ; } trandom . nextBytes ( h . encryptionIV ) ; tUUID kdfUUID = mPM . kdfParameters . kdfUUID ; tKdfEngine kdf = KdfFactory . get ( kdfUUID ) ; tkdf . randomize ( mPM . kdfParameters ) ; tif ( h . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { th . innerRandomStream = CrsAlgorithm . Salsa20 ; h . innerRandomStreamKey = new byte [ 32 ] ; } else { th . innerRandomStream = CrsAlgorithm . ChaCha20 ; th . innerRandomStreamKey = new byte [ 64 ] ; } trandom . nextBytes ( h . innerRandomStreamKey ) ; trandomStream = PwStreamCipherFactory . getInstance ( h . innerRandomStream , h . innerRandomStreamKey ) ; tif ( randomStream = = null ) { tthrow new PwDbOutputException ( " Invalid random cipher " ) ; } tif ( h . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { trandom . nextBytes ( h . streamStartBytes ) ; } treturn random ; } 
public PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException { tPwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; tsetIVs ( header ) ; tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; ttry { tpho . output ( ) ; } catch ( IOException e ) { tthrow new PwDbOutputException ( " Failed to output the header. " , e ) ; } thashOfHeader = pho . getHashOfHeader ( ) ; theaderHmac = pho . headerHmac ; treturn header ; } 
private void writeObject ( String name , Date value ) throws IllegalArgumentException , IllegalStateException , IOException { tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { twriteObject ( name , PwDatabaseV4XML . dateFormat . format ( value ) ) ; 
public void close ( ) throws IOException { if ( bufferPos = = 0 ) { WriteSafeBlock ( ) ; } else { WriteSafeBlock ( ) ; WriteSafeBlock ( ) ; } baseStream . flush ( ) ; ; baseStream . close ( ) ; } 
public void flush ( ) throws IOException { baseStream . flush ( ) ; } 
public void write ( byte [ ] outBuffer ) throws IOException { write ( outBuffer , 0 , outBuffer . length ) ; } 
public void write ( byte [ ] outBuffer , int offset , int count ) throws IOException { while ( count > 0 ) { if ( bufferPos = = buffer . length ) { 
public void write ( int oneByte ) throws IOException { byte [ ] outByte = new byte [ 1 ] ; write ( outByte , 0 , 1 ) ; } 
private void WriteSafeBlock ( ) throws IOException { byte [ ] bufBlockIndex = LEDataOutputStream . writeLongBuf ( blockIndex ) ; byte [ ] blockSizeBuf = LEDataOutputStream . writeIntBuf ( bufferPos ) ; byte [ ] blockHmac ; byte [ ] blockKey = HmacBlockStream . GetHmacKey64 ( key , blockIndex ) ; Mac hmac ; try { hmac = Mac . getInstance ( " HmacSHA256 " ) ; SecretKeySpec signingKey = new SecretKeySpec ( blockKey , " HmacSHA256 " ) ; hmac . init ( signingKey ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( " Invalid Hmac " ) ; } catch ( InvalidKeyException e ) { throw new IOException ( " Invalid HMAC " ) ; } hmac . update ( bufBlockIndex ) ; hmac . update ( blockSizeBuf ) ; if ( bufferPos > 0 ) { hmac . update ( buffer , 0 , bufferPos ) ; } blockHmac = hmac . doFinal ( ) ; baseStream . write ( blockHmac ) ; baseStream . write ( blockSizeBuf ) ; if ( bufferPos > 0 ) { baseStream . write ( buffer , 0 , bufferPos ) ; } blockIndex + + ; bufferPos = 0 ; } 
public void flush ( ) throws IOException { os . flush ( ) ; } 
public void close ( ) throws IOException { os . close ( ) ; } 
public void write ( int oneByte ) throws IOException { mac . update ( ( byte ) oneByte ) ; os . write ( oneByte ) ; } 
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { mac . update ( buffer , offset , count ) ; os . write ( buffer , offset , count ) ; } 
public void write ( byte [ ] buffer ) throws IOException { mac . update ( buffer , 0 , buffer . length ) ; os . write ( buffer ) ; } 
public static long convertDateToKDBX4Time ( DateTime dt ) { return ( dt . getMillis ( ) / 1000 ) - ( dotNetEpoch . getMillis ( ) / 1000 ) ; } 
protected void advanceCounter ( long diff ) { int hi = ( int ) ( diff > > > 32 ) ; int lo = ( int ) diff ; if ( hi > 0 ) { throw new IllegalStateException ( " attempt to increase counter past 2^32. " ) ; } int oldState = engineState [ 12 ] ; engineState [ 12 ] + = lo ; if ( oldState ! = 0 & & engineState [ 12 ] < oldState ) { 
protected void advanceCounter ( ) { if ( + + engineState [ 12 ] = = 0 ) { 
protected void retreatCounter ( long diff ) { int hi = ( int ) ( diff > > > 32 ) ; int lo = ( int ) diff ; if ( hi ! = 0 ) { throw new IllegalStateException ( " attempt to reduce counter past zero. " ) ; } if ( ( engineState [ 12 ] & 0xffffffffL ) > = ( lo & 0xffffffffL ) ) { 
protected void retreatCounter ( ) { if ( engineState [ 12 ] = = 0 ) { throw new IllegalStateException ( " attempt to reduce counter past zero. " ) ; } - - engineState [ 12 ] ; } 
protected void resetCounter ( ) { engineState [ 12 ] = 0 ; } 
private static int [ ] littleEndianToInt ( byte [ ] bs , int off , int count ) { int [ ] ns = new int [ count ] ; for ( int i = 0 ; i < ns . length ; + + i ) { ns [ i ] = Pack . littleEndianToInt ( bs , off ) ; off + = 4 ; } return ns ; } 
protected void packTauOrSigma ( int keyLength , int [ ] state , int stateOffset ) { int tsOff = ( keyLength - 16 ) / 4 ; state [ stateOffset ] = TAU_SIGMA [ tsOff ] ; state [ stateOffset + 1 ] = TAU_SIGMA [ tsOff + 1 ] ; state [ stateOffset + 2 ] = TAU_SIGMA [ tsOff + 2 ] ; state [ stateOffset + 3 ] = TAU_SIGMA [ tsOff + 3 ] ; } 
protected void generateKeyStream ( byte [ ] output ) { ChaChaEngine . chachaCore ( rounds , engineState , x ) ; Pack . intToLittleEndian ( x , output , 0 ) ; } 
public static CipherEngine getInstance ( UUID uuid ) throws NoSuchAlgorithmException { tif ( uuid . equals ( AesEngine . CIPHER_UUID ) ) { treturn new AesEngine ( ) ; } else if ( uuid . equals ( TwofishEngine . CIPHER_UUID ) ) { treturn new TwofishEngine ( ) ; } else if ( uuid . equals ( ChaCha20Engine . CIPHER_UUID ) ) { treturn new ChaCha20Engine ( ) ; } tthrow new NoSuchAlgorithmException ( " UUID unrecognized. " ) ; } 
public Cipher getCipher ( int opmode , byte [ ] key , byte [ ] IV , boolean androidOverride ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { Cipher cipher = Cipher . getInstance ( " Chacha7539 " , new BouncyCastleProvider ( ) ) ; cipher . init ( opmode , new SecretKeySpec ( key , " ChaCha7539 " ) , new IvParameterSpec ( IV ) ) ; return cipher ; } 
public void onAuthenticationSucceeded ( final FingerprintManagerCompat . AuthenticationResult result ) { if ( mode = = Cipher . ENCRYPT_MODE ) { 
public boolean isFingerprintSupported ( ) { return Build . VERSION . SDK_INT > = BuildCompat . VERSION_CODE_M ; } 
public void handleEncryptedResult ( final String value , final String ivSpec ) { prefs . edit ( ) . putString ( getPreferenceKeyValue ( ) , value ) . putString ( getPreferenceKeyIvSpec ( ) , ivSpec ) . commit ( ) ; and remove visual input to reset UI confirmButton.performClick(); confirmationView.setText(R.string.encrypted_value_stored); } 
public void onException ( boolean showMessage ) { if ( showMessage ) { Toast . makeText ( this , R . string . fingerprint_error , Toast . LENGTH_SHORT ) . show ( ) ; } checkAvailability ( ) ; restarts listening 
public void initDecryptData ( final String ivSpecValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( false ) ; } return ; } try { createNewKeyIfNeeded ( false ) ; 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; prefsNoBackup = getSharedPreferences ( " nobackup " , Context . MODE_PRIVATE ) ; prefsNoBackup . edit ( ) . putString ( " test " , " test " ) . commit ( ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; fingerprintView = findViewById ( R . id . fingerprint ) ; confirmationView = ( TextView ) findViewById ( R . id . fingerprint_label ) ; passwordView = ( EditText ) findViewById ( R . id . password ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
private int toggleMode ( final int newMode ) { check if mode is different so we can update fingerprint helper if (mode != newMode) { mode = newMode; switch (mode) { case Cipher.ENCRYPT_MODE: fingerPrintHelper.initEncryptData(); break; case Cipher.DECRYPT_MODE: final String ivSpecValue = prefsNoBackup.getString(getPreferenceKeyIvSpec(), null); fingerPrintHelper.initDecryptData(ivSpecValue); break; } return newMode; } remains in current mode return mode; } 
public void handleEncryptedResult ( final String value , final String ivSpec ) { prefsNoBackup . edit ( ) . putString ( getPreferenceKeyValue ( ) , value ) . putString ( getPreferenceKeyIvSpec ( ) , ivSpec ) . commit ( ) ; and remove visual input to reset UI confirmButton.performClick(); confirmationView.setText(R.string.encrypted_value_stored); } 
private void checkAvailability ( ) { fingerprint not supported (by API level or hardware) so keep option hidden if (!fingerPrintHelper.isFingerprintSupported()) { setFingerPrintVisibilty(View.GONE); 
private void ensureCorrectListView ( ) { tmList = ( ListView ) findViewById ( R . id . group_list ) ; tif ( mList ! = null ) { tmList . setOnItemClickListener ( 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { tonListItemClick ( ( ListView ) parent , v , position , id ) ; } 
public static AlgorithmParameterSpec build ( String keystoreAlias , int purpose , String blockMode , boolean userAuthReq , String encPadding ) { if ( ! available ) { return null ; } try { Object inst = buildConst . newInstance ( keystoreAlias , purpose ) ; 
public static boolean isKeyguardSecure ( KeyguardManager inst ) { if ( ! available ) { return false ; } try { return ( boolean ) isKeyguardSecure . invoke ( inst , null ) ; 
private void initForFingerprint ( ) { fingerPrintHelper = new FingerPrintHelper ( this , this ) ; if ( fingerPrintHelper . isFingerprintInitialized ( ) ) { 
private void initForFingerprint ( ) { fingerPrintHelper = new FingerPrintHelper ( this , this ) ; if ( fingerPrintHelper . hasEnrolledFingerprints ( ) ) { 
private int toggleMode ( final int newMode ) { check if mode is different so we can update fingerprint helper if (mode != newMode) { mode = newMode; switch (mode) { case Cipher.ENCRYPT_MODE: fingerPrintHelper.initEncryptData(); break; case Cipher.DECRYPT_MODE: final String ivSpecValue = prefsNoBackup.getString(getPreferenceKeyIvSpec(), null); if (ivSpecValue != null) { fingerPrintHelper.initDecryptData(ivSpecValue); } break; } return newMode; } remains in current mode return mode; } 
public void initEncryptData ( ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null & & hasEnrolledFingerprints ( ) ) { fingerPrintCallback . onException ( ) ; } return ; } try { createNewKeyIfNeeded ( false ) ; no need to keep deleting existing keys 
public void encryptData ( final String value ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null & & hasEnrolledFingerprints ( ) ) { fingerPrintCallback . onException ( ) ; } return ; } try { actual do encryption here 
public void initDecryptData ( final String ivSpecValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( false ) ; } return ; } else if ( ! hasEnrolledFingerprints ( ) ) { return ; } try { createNewKeyIfNeeded ( false ) ; 
private void checkAvailability ( ) { fingerprint not supported (by API level or hardware) so keep option hidden if (!fingerPrintHelper.isHardwareDetected()) { setFingerPrintVisibilty(View.GONE); 
protected SimpleDateFormat initialValue ( ) { SimpleDateFormat dateFormat ; dateFormat = new SimpleDateFormat ( " yyyy-MM-dd'T'HH:mm:ss'Z' " ) ; dateFormat . setTimeZone ( TimeZone . getTimeZone ( " UTC " ) ) ; return dateFormat ; } 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate = null ; tif ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { tbyte [ ] buf = Base64Coder . decode ( sDate ) ; tif ( buf . length ! = 8 ) { tbyte [ ] buf8 = new byte [ 8 ] ; tSystem . arraycopy ( buf , 0 , buf8 , 0 , buf . length ) ; tbuf = buf8 ; } tlong seconds = LEDataInputStream . readLong ( buf , 0 ) ; tutcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { ttry { tutcDate = PwDatabaseV4XML . dateFormatter . get ( ) . parse ( sDate ) ; } catch ( ParseException e ) { 
private void writeObject ( String name , Date value ) throws IllegalArgumentException , IllegalStateException , IOException { tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { twriteObject ( name , PwDatabaseV4XML . dateFormatter . get ( ) . format ( value ) ) ; 
private boolean readHeaderField ( LEDataInputStream dis ) throws IOException { tbyte fieldID = ( byte ) dis . read ( ) ; tint fieldSize ; tif ( version < FILE_VERSION_32_4 ) { tfieldSize = dis . readUShort ( ) ; } else { tfieldSize = dis . readInt ( ) ; } tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = dis . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tAesKdf kdfS = new AesKdf ( ) ; tif ( ! db . kdfParameters . kdfUUID . equals ( kdfS . uuid ) ) { tdb . kdfParameters = kdfS . getDefaultParameters ( ) ; } tdb . kdfParameters . setByteArray ( AesKdf . ParamSeed , fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tAesKdf kdfR = new AesKdf ( ) ; tif ( ! db . kdfParameters . kdfUUID . equals ( kdfR . uuid ) ) { tdb . kdfParameters = kdfR . getDefaultParameters ( ) ; } tlong rounds = LEDataInputStream . readLong ( fieldData , 0 ) ; tdb . kdfParameters . setUInt64 ( AesKdf . ParamRounds , rounds ) ; tdb . numKeyEncRounds = rounds ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tencryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomstreamKey : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tinnerRandomStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tstreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tsetRandomStreamID ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . KdfParameters : tdb . kdfParameters = KdfParameters . deserialize ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . PublicCustomData : tdb . publicCustomData = KdfParameters . deserialize ( fieldData ) ; tdefault : tthrow new IOException ( " Invalid header type: " + fieldID ) ; } treturn false ; } 
public Collection < ProtectedBinary > binaries ( ) { treturn pool . values ( ) ; } 
public void poolAdd ( ProtectedBinary pb ) { tassert ( pb ! = null ) ; tif ( poolFind ( pb ) ! = - 1 ) return ; tpool . put ( pool . size ( ) , pb ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tInputStream keyInputStream , UpdateStatus status ) throws IOException , tInvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; db . binPool . clear ( ) ; tPwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; thashOfHeader = hh . hash ; tpbHeader = hh . header ; tdb . setMasterKey ( password , keyInputStream ) ; tdb . makeFinalKey ( header . masterSeed , db . kdfParameters ) ; tCipherEngine engine ; tCipher cipher ; ttry { tengine = CipherFactory . getInstance ( db . dataCipher ) ; tdb . dataEngine = engine ; tcipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } tInputStream isPlain ; tif ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { tInputStream decrypted = AttachCipherStream ( inStream , cipher ) ; tLEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; tbyte [ ] storedStartBytes = null ; ttry { tstoredStartBytes = dataDecrypted . readBytes ( 32 ) ; tif ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { tthrow new InvalidPasswordException ( ) ; } } catch ( IOException e ) { tthrow new InvalidPasswordException ( ) ; } tif ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { tthrow new InvalidPasswordException ( ) ; } tisPlain = new HashedBlockInputStream ( dataDecrypted ) ; } telse { 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) throws IOException { tbyte fieldId = ( byte ) lis . read ( ) ; tint size = lis . readInt ( ) ; tif ( size < 0 ) throw new IOException ( " Corrupted file " ) ; tbyte [ ] data = new byte [ 0 ] ; tif ( size > 0 ) { tdata = lis . readBytes ( size ) ; } tboolean result = true ; tswitch ( fieldId ) { tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : tresult = false ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : if ( data . length < 1 ) throw new IOException ( " Invalid binary format " ) ; tbyte flag = data [ 0 ] ; tboolean prot = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = tPwDbHeaderV4 . KdbxBinaryFlags . None ; tbyte [ ] bin = new byte [ data . length - 1 ] ; tSystem . arraycopy ( data , 1 , bin , 0 , data . length - 1 ) ; tProtectedBinary pb = new ProtectedBinary ( prot , bin ) ; tdb . binPool . poolAdd ( pb ) ; tif ( prot ) { tArrays . fill ( data , ( byte ) 0 ) ; } tbreak ; tdefault : tassert ( false ) ; tbreak ; } treturn result ; } 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tString ref = xpp . getAttributeValue ( null , AttrRef ) ; tif ( ref ! = null ) { txpp . next ( ) ; } 
public void output ( ) throws IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : db . binPool . binaries ( ) ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } byte [ ] binData = bin . getData ( ) ; los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( bin . length ( ) + 1 ) ; los . write ( flag ) ; los . write ( binData ) ; Arrays . fill ( binData , ( byte ) 0 ) ; } los . write ( PwDbInnerHeaderV4Fields . EndOfHeader ) ; los . writeInt ( 0 ) ; } 
private void outputDatabase ( OutputStream os ) throws IllegalArgumentException , IllegalStateException , IOException { txml = Xml . newSerializer ( ) ; txml . setOutput ( os , " UTF-8 " ) ; txml . startDocument ( " UTF-8 " , true ) ; txml . startTag ( null , ElemDocNode ) ; twriteMeta ( ) ; tPwGroupV4 root = ( PwGroupV4 ) mPM . rootGroup ; txml . startTag ( null , ElemRoot ) ; tstartGroup ( root ) ; tStack < PwGroupV4 > groupStack = new Stack < PwGroupV4 > ( ) ; tgroupStack . push ( root ) ; tif ( ! root . preOrderTraverseTree ( new GroupWriter ( groupStack ) , new EntryWriter ( ) ) ) throw new RuntimeException ( " Writing groups failed " ) ; twhile ( groupStack . size ( ) > 1 ) { txml . endTag ( null , ElemGroup ) ; tgroupStack . pop ( ) ; } tendGroup ( ) ; twriteList ( ElemDeletedObjects , mPM . deletedObjects ) ; txml . endTag ( null , ElemRoot ) ; txml . endTag ( null , ElemDocNode ) ; txml . endDocument ( ) ; 
private void writeObject ( String key , ProtectedBinary value , boolean allowRef ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( key ! = null & & value ! = null ) ; txml . startTag ( null , ElemBinary ) ; txml . startTag ( null , ElemKey ) ; txml . text ( safeXmlString ( key ) ) ; txml . endTag ( null , ElemKey ) ; txml . startTag ( null , ElemValue ) ; tString strRef = null ; tif ( allowRef ) { tint ref = mPM . binPool . poolFind ( value ) ; tstrRef = Integer . toString ( ref ) ; } tif ( strRef ! = null ) { txml . attribute ( null , AttrRef , strRef ) ; } telse { tsubWriteValue ( value ) ; } txml . endTag ( null , ElemValue ) ; txml . endTag ( null , ElemBinary ) ; } 
private void writeBinPool ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemBinaries ) ; tfor ( Entry < Integer , ProtectedBinary > pair : mPM . binPool . entrySet ( ) ) { txml . startTag ( null , ElemBinary ) ; txml . attribute ( null , AttrId , Integer . toString ( pair . getKey ( ) ) ) ; tsubWriteValue ( pair . getValue ( ) ) ; txml . endTag ( null , ElemBinary ) ; } txml . endTag ( null , ElemBinaries ) ; 
private void passUrisAsInputStreams ( Context ctx , Uri uri , String password , Uri keyfile , UpdateStatus status , boolean debug , long roundsFix ) throws IOException , FileNotFoundException , InvalidDBException { InputStream is , kfIs ; try { is = UriUtil . getUriInputStream ( ctx , uri ) ; } catch ( Exception e ) { Log . e ( " KPD " , " Database::LoadData " , e ) ; throw ContentFileNotFoundException . getInstance ( uri ) ; } try { kfIs = UriUtil . getUriInputStream ( ctx , keyfile ) ; } catch ( Exception e ) { Log . e ( " KPD " , " Database::LoadData " , e ) ; throw ContentFileNotFoundException . getInstance ( keyfile ) ; } LoadData ( ctx , is , password , kfIs , status , debug , roundsFix ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug ) throws IOException , InvalidDBException { LoadData ( ctx , is , password , kfIs , status , debug , 0 ) ; } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug , long roundsFix ) throws IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, kfIs, status, roundsFix); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, kfIs, status); } loaded = true; } 
public void makeFinalKey ( byte [ ] masterSeed , KdfParameters kdfP ) throws IOException { tmakeFinalKey ( masterSeed , kdfP , 0 ) ; } 
public void makeFinalKey ( byte [ ] masterSeed , KdfParameters kdfP , long roundsFix ) tthrows IOException { tKdfEngine kdfEngine = KdfFactory . get ( kdfP . kdfUUID ) ; tif ( kdfEngine = = null ) { tthrow new IOException ( " Unknown key derivation function " ) ; } md = MessageDigest.getInstance("SHA-512"); 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream ) tthrows IOException , InvalidDBException ; public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) tthrows IOException , InvalidDBException ; } 
public abstract PwDatabase openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) tthrows IOException , InvalidDBException ; } 
public PwDatabaseV3 openDatabase ( InputStream inStream , String password , InputStream kfIs ) tthrows IOException , InvalidDBException { treturn openDatabase ( inStream , password , kfIs , new UpdateStatus ( ) , 0 ) ; } 
public PwDatabaseV3Debug openDatabase ( InputStream inStream , String password , tInputStream keyInputStream , UpdateStatus status , long roundsFix ) throws IOException , tInvalidDBException { treturn ( PwDatabaseV3Debug ) super . openDatabase ( inStream , password , keyInputStream , status , troundsFix ) ; 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , tInputStream keyInputStream ) throws IOException , InvalidDBException { treturn openDatabase ( inStream , password , keyInputStream , new UpdateStatus ( ) , 0 ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) throws IOException , InvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; db . binPool . clear ( ) ; tPwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; thashOfHeader = hh . hash ; tpbHeader = hh . header ; tdb . setMasterKey ( password , keyInputStream ) ; tdb . makeFinalKey ( header . masterSeed , db . kdfParameters , roundsFix ) ; tCipherEngine engine ; tCipher cipher ; ttry { tengine = CipherFactory . getInstance ( db . dataCipher ) ; tdb . dataEngine = engine ; tcipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } tInputStream isPlain ; tif ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { tInputStream decrypted = AttachCipherStream ( inStream , cipher ) ; tLEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; tbyte [ ] storedStartBytes = null ; ttry { tstoredStartBytes = dataDecrypted . readBytes ( 32 ) ; tif ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { tthrow new InvalidPasswordException ( ) ; } } catch ( IOException e ) { tthrow new InvalidPasswordException ( ) ; } tif ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { tthrow new InvalidPasswordException ( ) ; } tisPlain = new HashedBlockInputStream ( dataDecrypted ) ; } telse { 
public PwDatabaseV4Debug openDatabase ( InputStream inStream , String password , tInputStream keyInputFile , UpdateStatus status , long roundsFix ) throws IOException , tInvalidDBException { treturn ( PwDatabaseV4Debug ) super . openDatabase ( inStream , password , keyInputFile , status , troundsFix ) ; 
protected boolean persistString ( String value ) { try { return persistLong ( Long . valueOf ( value ) ) ; } catch ( NumberFormatException e ) { Toast . makeText ( getContext ( ) , R . string . error_rounds_not_number , Toast . LENGTH_LONG ) . show ( ) ; } return false ; } 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate = null ; tif ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { tbyte [ ] buf = Base64Coder . decode ( sDate ) ; tif ( buf . length ! = 8 ) { tbyte [ ] buf8 = new byte [ 8 ] ; tSystem . arraycopy ( buf , 0 , buf8 , 0 , Math . min ( buf . length , 8 ) ) ; tbuf = buf8 ; } tlong seconds = LEDataInputStream . readLong ( buf , 0 ) ; tutcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { ttry { tutcDate = PwDatabaseV4XML . dateFormatter . get ( ) . parse ( sDate ) ; } catch ( ParseException e ) { 
public static Date convertKDBX4Time ( long seconds ) { DateTime dt = dotNetEpoch . plus ( seconds * 1000L ) ; Switch corrupted dates to a more recent date that won't cause issues on the client if (dt.isBefore(javaEpoch)) { return javaEpoch.toDate(); } return dt.toDate(); } 
public static long convertDateToKDBX4Time ( DateTime dt ) { Seconds secs = Seconds . secondsBetween ( javaEpoch , dt ) ; return secs . getSeconds ( ) + epochOffset ; } 
public static long convertDateToKDBX4Time ( DateTime dt ) { try { Seconds secs = Seconds . secondsBetween ( javaEpoch , dt ) ; 
private void toggleModeOrStartListening ( final int newMode ) { if ( mode = = newMode ) { fingerPrintHelper . startListening ( ) ; 
private int toggleMode ( final int newMode ) { mode = newMode ; switch ( mode ) { case Cipher . ENCRYPT_MODE : fingerPrintHelper . initEncryptData ( ) ; break ; case Cipher . DECRYPT_MODE : final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; if ( ivSpecValue ! = null ) { fingerPrintHelper . initDecryptData ( ivSpecValue ) ; } break ; } return mode ; } 
public void onException ( boolean showMessage ) { if ( showMessage ) { Toast . makeText ( this , R . string . fingerprint_error , Toast . LENGTH_SHORT ) . show ( ) ; 
public void onAuthenticationError ( final int errorCode , final CharSequence errString ) { if ( errorCode ! = 5 ) { FINGERPRINT_ERROR_CANCELLED (not defined in support library) onException(errString); 
public void onAuthenticationFailed ( ) { onException ( R . string . fingerprint_notrecognized ) ; } 
private int toggleMode ( final int newMode ) { if ( mode ! = newMode ) { mode = newMode ; switch ( mode ) { case Cipher . ENCRYPT_MODE : fingerPrintHelper . initEncryptData ( ) ; break ; case Cipher . DECRYPT_MODE : final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; if ( ivSpecValue ! = null ) { fingerPrintHelper . initDecryptData ( ivSpecValue ) ; } break ; } } else { fingerPrintHelper . stopListening ( ) ; fingerPrintHelper . startListening ( ) ; } return mode ; } 
public void onInvalidKeyException ( ) { Toast . makeText ( this , R . string . fingerprint_invalid_key , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onException ( boolean showMessage ) { if ( showMessage ) { onException ( R . string . fingerprint_error ) ; 
public void onException ( int resId ) { Toast . makeText ( this , resId , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onException ( CharSequence message ) { Toast . makeText ( this , message , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onKeyInvalidated ( ) { prefsNoBackup . edit ( ) . remove ( getPreferenceKeyValue ( ) ) . remove ( getPreferenceKeyIvSpec ( ) ) . commit ( ) ; confirmationView . setText ( R . string . fingerprint_key_invalidated ) ; } 
public void startListening ( ) { no need to start listening when not initialised if (!isFingerprintInitialized()) { if (fingerPrintCallback != null) { fingerPrintCallback.onException(); } return; } if (!cryptoInitOk) { Crypto key didn't initialize correctly, don't start listening return; } starts listening for fingerprints with the initialised crypto object cancellationSignal = new CancellationSignal(); fingerprintManager.authenticate( cryptoObject, 
public void initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null & & hasEnrolledFingerprints ( ) ) { fingerPrintCallback . onException ( ) ; } return ; } try { initEncryptKey ( false ) ; 
private void initEncryptKey ( boolean deleteExistingKey ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; cryptoInitOk = true ; stopListening ( ) ; startListening ( ) ; } 
public void initDecryptData ( final String ivSpecValue ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( false ) ; } return ; } else if ( ! hasEnrolledFingerprints ( ) ) { return ; } try { initDecryptKey ( ivSpecValue , false ) ; 
private void initDecryptKey ( final String ivSpecValue , boolean deleteExistingKey ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64Coder.decode(ivSpecValue); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; stopListening(); startListening(); } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Intent i = getIntent ( ) ; prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; prefsNoBackup = getSharedPreferences ( " nobackup " , Context . MODE_PRIVATE ) ; mRememberKeyfile = prefs . getBoolean ( getString ( R . string . keyfile_key ) , getResources ( ) . getBoolean ( R . bool . keyfile_default ) ) ; setContentView ( R . layout . password ) ; confirmButton = ( Button ) findViewById ( R . id . pass_ok ) ; fingerprintView = findViewById ( R . id . fingerprint ) ; confirmationView = ( TextView ) findViewById ( R . id . fingerprint_label ) ; passwordView = ( EditText ) findViewById ( R . id . password ) ; new InitTask ( ) . execute ( i ) ; initForFingerprint ( ) ; } 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE); 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . toString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; EditorCompat . apply ( editor ) ; BackupManager backupManager = new BackupManager ( PasswordActivity . this ) ; backupManager . dataChanged ( ) ; 
private static boolean supportedOnThisDevice ( ) { 
private static void applyOpenSSLFix ( ) throws SecurityException { if ( ( sdkVersion < Build . VERSION_CODES . JELLY_BEAN ) | | ( sdkVersion > Build . VERSION_CODES . JELLY_BEAN_MR2 ) ) { No need to apply the fix return; } try { Mix in the device- and invocation-specific seed. 
public static boolean supportsStorageFramework ( ) { return Build . VERSION . SDK_INT > = Build . VERSION_CODES . KITKAT ; } 
private void toggleSort ( ) { 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . toString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( KEY_DEFAULT_FILENAME , newDefaultFileName ) ; editor . apply ( ) ; BackupManager backupManager = new BackupManager ( PasswordActivity . this ) ; backupManager . dataChanged ( ) ; 
private void saveList ( String keyprefix , List < String > list ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; SharedPreferences . Editor edit = prefs . edit ( ) ; int size = list . size ( ) ; edit . putInt ( keyprefix , size ) ; for ( int i = 0 ; i < size ; i + + ) { edit . putString ( keyprefix + " _ " + i , list . get ( i ) ) ; } edit . apply ( ) ; ; } 
private void loadDatabase ( String pass , String keyfile ) { loadDatabase ( pass , UriUtil . parseDefaultFile ( keyfile ) ) ; } 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = db . getScheme ( ) . equals ( " file " ) | | keyfile . getScheme ( ) . equals ( " file " ) ; if ( ! hasFileUri ) return true ; boolean hasRead = ContextCompat . checkSelfPermission ( this , Manifest . permission . READ_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; boolean hasWrite = ContextCompat . checkSelfPermission ( this , Manifest . permission . WRITE_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; if ( ! hasRead | | ! hasWrite ) { ActivityCompat . requestPermissions ( this , READ_WRITE_PERMISSIONS , PERMISSION_REQUEST_ID ) ; return false ; } return true ; 
public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { if ( requestCode = = PERMISSION_REQUEST_ID & & grantResults [ 0 ] = = PackageManager . PERMISSION_GRANTED & & 
private void loadDatabase ( String pass , Uri keyfile ) { if ( pass . length ( ) = = 0 & & ( keyfile = = null | | keyfile . toString ( ) . length ( ) = = 0 ) ) { errorMessage ( R . string . error_nopass ) ; return ; } storedPassword = pass ; storedKeyUri = keyfile ; if ( checkFilePermissions ( mDbUri , keyfile ) ) { loadDatabaseWithPermission ( ) ; 
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Clear before we load Database db = App.getDB(); db.clear(); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, mDbUri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
private void testKeyfile ( String dbAsset , String keyAsset , String password ) throws Exception { tContext ctx = getContext ( ) ; tFile sdcard = Environment . getExternalStorageDirectory ( ) ; tString keyPath = ctx . getFilesDir ( ) . getAbsolutePath ( ) + " /key " ; tTestUtil . extractKey ( ctx , keyAsset , keyPath ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; timporter . openDatabase ( is , password , TestUtil . getKeyFileInputStream ( ctx , keyPath ) ) ; tis . close ( ) ; } 
public void testParsing ( ) throws IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
private void testSaving ( String inputFile , String password , String outputFile ) throws IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( inputFile , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; PwDatabaseV4 db = importer . openDatabase ( is , password , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . toByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getAppPath ( ctx , outputFile ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ) ; db = importer . openDatabase ( bis , password , null ) ; bis . close ( ) ; fos . close ( ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; ctx = getContext ( ) ; TestUtil . extractKey ( getContext ( ) , " keyfile.key " , TestUtil . getAppPath ( ctx , " key " ) ) ; TestUtil . extractKey ( getContext ( ) , " binary.key " , TestUtil . getAppPath ( ctx , " key-binary " ) ) ; 
public void testComposite ( ) throws IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key " ) ) ) ; is . close ( ) ; 
public void testCompositeBinary ( ) throws IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key-binary " ) ) ) ; is . close ( ) ; 
public void testKeyfile ( ) throws IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key " ) ) ) ; is . close ( ) ; 
public void testFullWrite ( ) throws IOException , PwDbOutputException { tAssetManager am = getContext ( ) . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
private static void staticInit ( ) { tmIsStaticInit = true ; } 
public static void createChannels ( Context ctx ) { if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . O ) { 
tprotected void onResume ( ) { tsuper . onResume ( ) ; } 
public static boolean equalsDefaultfile ( Uri left , String right ) { if ( left = = null | | right = = null ) { return false ; } left = parseDefaultFile ( left ) ; Uri uriRight = parseDefaultFile ( right ) ; return left . equals ( uriRight ) ; } 
private boolean hasFileUri ( Uri uri ) { try { if ( uri = = null ) { return false ; } 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return true ; boolean hasRead = ContextCompat . checkSelfPermission ( this , Manifest . permission . READ_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; boolean hasWrite = ContextCompat . checkSelfPermission ( this , Manifest . permission . WRITE_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; if ( ! hasRead | | ! hasWrite ) { ActivityCompat . requestPermissions ( this , READ_WRITE_PERMISSIONS , PERMISSION_REQUEST_ID ) ; return false ; } return true ; 
public void undoDeleteEntry ( PwEntry entry , PwGroup origParent ) { tsuper . undoDeleteEntry ( entry , origParent ) ; tdeletedObjects . remove ( new PwDeletedObject ( entry . getUUID ( ) ) ) ; } 
private boolean readHeaderField ( LEDataInputStream dis ) throws IOException { tbyte fieldID = ( byte ) dis . read ( ) ; tint fieldSize ; tif ( version < FILE_VERSION_32_4 ) { tfieldSize = dis . readUShort ( ) ; } else { tfieldSize = dis . readInt ( ) ; } tbyte [ ] fieldData = null ; tif ( fieldSize > 0 ) { tfieldData = new byte [ fieldSize ] ; tint readSize = dis . read ( fieldData ) ; tif ( readSize ! = fieldSize ) { tthrow new IOException ( " Header ended early. " ) ; } } tswitch ( fieldID ) { tcase PwDbHeaderV4Fields . EndOfHeader : treturn true ; tcase PwDbHeaderV4Fields . CipherID : tsetCipher ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . CompressionFlags : tsetCompressionFlags ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . MasterSeed : tmasterSeed = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . TransformSeed : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tAesKdf kdfS = new AesKdf ( ) ; tif ( ! db . kdfParameters . kdfUUID . equals ( kdfS . uuid ) ) { tdb . kdfParameters = kdfS . getDefaultParameters ( ) ; } tdb . kdfParameters . setByteArray ( AesKdf . ParamSeed , fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . TransformRounds : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tAesKdf kdfR = new AesKdf ( ) ; tif ( ! db . kdfParameters . kdfUUID . equals ( kdfR . uuid ) ) { tdb . kdfParameters = kdfR . getDefaultParameters ( ) ; } tlong rounds = LEDataInputStream . readLong ( fieldData , 0 ) ; tdb . kdfParameters . setUInt64 ( AesKdf . ParamRounds , rounds ) ; tdb . numKeyEncRounds = rounds ; tbreak ; tcase PwDbHeaderV4Fields . EncryptionIV : tencryptionIV = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomstreamKey : assert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tinnerRandomStreamKey = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . StreamStartBytes : tstreamStartBytes = fieldData ; tbreak ; tcase PwDbHeaderV4Fields . InnerRandomStreamID : tassert ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) ; tsetRandomStreamID ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . KdfParameters : tdb . kdfParameters = KdfParameters . deserialize ( fieldData ) ; tbreak ; tcase PwDbHeaderV4Fields . PublicCustomData : tdb . publicCustomData = KdfParameters . deserialize ( fieldData ) ; tbreak ; tdefault : tthrow new IOException ( " Invalid header type: " + fieldID ) ; } treturn false ; } 
public static boolean matchesHeader ( int sig1 , int sig2 ) { treturn ( sig1 = = PWM_DBSIG_1 ) & & ( ( sig2 = = DBSIG_PRE2 ) | | ( sig2 = = DBSIG_2 ) ) ; } 
public abstract void setLastAccessTime ( Date date ) ; public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } public boolean isContainedIn ( PwGroup container ) { tPwGroup cur = this ; twhile ( cur ! = null ) { tif ( cur = = container ) { treturn true ; } tcur = cur . getParent ( ) ; } treturn false ; } public void touch ( boolean modified , boolean touchParents ) { tDate now = new Date ( ) ; tsetLastAccessTime ( now ) ; tif ( modified ) { tsetLastModificationTime ( now ) ; } tPwGroup parent = getParent ( ) ; tif ( touchParents & & parent ! = null ) { tparent . touch ( modified , true ) ; } } public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { tif ( sp = = null ) { return ; } tif ( listStorage = = null ) { return ; } tList < String > terms = StrUtil . splitSearchTerms ( sp . searchString ) ; tif ( terms . size ( ) < = 1 | | sp . regularExpression ) { tsearchEntriesSingle ( sp , listStorage ) ; treturn ; } }} 
public abstract void setLastModificationTime ( Date date ) ; public void sortEntriesByName ( ) { tCollections . sort ( childEntries , new PwEntry . EntryNameComparator ( ) ) ; } public void initNewGroup ( String nm , PwGroupId newId ) { tsetId ( newId ) ; tname = nm ; } public boolean isContainedIn ( PwGroup container ) { tPwGroup cur = this ; twhile ( cur ! = null ) { tif ( cur = = container ) { treturn true ; } tcur = cur . getParent ( ) ; } treturn false ; } public void touch ( boolean modified , boolean touchParents ) { tDate now = new Date ( ) ; tsetLastAccessTime ( now ) ; tif ( modified ) { tsetLastModificationTime ( now ) ; } tPwGroup parent = getParent ( ) ; tif ( touchParents & & parent ! = null ) { tparent . touch ( modified , true ) ; } } public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { tif ( sp = = null ) { return ; } tif ( listStorage = = null ) { return ; } tList < String > terms = StrUtil . splitSearchTerms ( sp . searchString ) ; tif ( terms . size ( ) < = 1 | | sp . regularExpression ) { tsearchEntriesSingle ( sp , listStorage ) ; treturn ; } }} 
public void searchEntries ( SearchParameters sp , List < PwEntry > listStorage ) { tif ( sp = = null ) { return ; } tif ( listStorage = = null ) { return ; } tList < String > terms = StrUtil . splitSearchTerms ( sp . searchString ) ; tif ( terms . size ( ) < = 1 | | sp . regularExpression ) { tsearchEntriesSingle ( sp , listStorage ) ; treturn ; } sp.searchString = fullSearch; 
private void ReadUnknown ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tassert ( false ) ; tif ( xpp . isEmptyElementTag ( ) ) return ; tString unknownName = xpp . getName ( ) ; tProcessNode ( xpp ) ; twhile ( xpp . next ( ) ! = XmlPullParser . END_DOCUMENT ) { tif ( xpp . getEventType ( ) = = XmlPullParser . END_TAG ) break ; tif ( xpp . getEventType ( ) = = XmlPullParser . START_TAG ) continue ; tReadUnknown ( xpp ) ; } tassert ( xpp . getName ( ) . equals ( unknownName ) ) ; 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) throws IOException { tbyte fieldId = ( byte ) lis . read ( ) ; tint size = lis . readInt ( ) ; tif ( size < 0 ) throw new IOException ( " Corrupted file " ) ; tbyte [ ] data = new byte [ 0 ] ; tif ( size > 0 ) { tif ( fieldId ! = PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary ) tdata = lis . readBytes ( size ) ; } tboolean result = true ; tswitch ( fieldId ) { tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : tresult = false ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : tbyte flag = lis . readBytes ( 1 ) [ 0 ] ; tboolean protectedFlag = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = tPwDbHeaderV4 . KdbxBinaryFlags . None ; } 
public void readBytes ( int length , ActionReadBytes actionReadBytes ) throws IOException { tbyte [ ] buffer = new byte [ 1024 ] ; tint offset = 0 ; tint read = 0 ; twhile ( offset < length & & read ! = - 1 ) { 
tvoid doAction ( byte [ ] buffer ) throws IOException ; } public static int readUShort ( InputStream is ) throws IOException { byte [ ] buf = new byte [ 2 ] ; is . read ( buf , 0 , 2 ) ; return readUShort ( buf , 0 ) ; } public int readUShort ( ) throws IOException { treturn readUShort ( baseStream ) ; } public static int readInt ( byte buf [ ] , int offset ) { return ( buf [ offset + 0 ] & 0xFF ) + ( ( buf [ offset + 1 ] & 0xFF ) < < 8 ) + ( ( buf [ offset + 2 ] & 0xFF ) < < 16 ) + ( ( buf [ offset + 3 ] & 0xFF ) < < 24 ) ; } public UUID readUUID ( ) throws IOException { byte [ ] buf = readBytes ( 16 ) ; return Types . bytestoUUID ( buf ) ; } } 
public void LoadData ( Context ctx , InputStream is , String password , InputStream kfIs , UpdateStatus status , boolean debug , long roundsFix ) throws IOException , InvalidDBException { BufferedInputStream bis = new BufferedInputStream ( is ) ; if ( ! bis . markSupported ( ) ) { throw new IOException ( " Input stream does not support mark. " ) ; } We'll end up reading 8 bytes to identify the header. Might as well use two extra. bis.mark(10); Importer imp = ImporterFactory.createImporter(bis, ctx.getFilesDir(), debug); bis.reset(); Return to the start pm = imp.openDatabase(bis, password, kfIs, status, roundsFix); if ( pm != null ) { PwGroup root = pm.rootGroup; pm.populateGlobals(root); LoadData(ctx, pm, password, kfIs, status); } loaded = true; } 
public void clear ( Context context ) { dirty . clear ( ) ; drawFactory . clear ( ) ; Delete the cache of the database if present if (pm != null) pm.clearCache(); In all cases, delete all the files in the temp dir try { FileUtils.cleanDirectory(context.getFilesDir()); } catch (IOException e) { Log.e(TAG, "Unable to clear the directory cache.", e); } pm = null; mUri = null; loaded = false; passwordEncodingError = false; } 
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Clear before we load Database db = App.getDB(); db.clear(getApplicationContext()); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, PasswordActivity.this, mDbUri, pass, keyfile, new AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database); pt.run(); } 
public void run ( ) { } 
public void onTerminate ( ) { tif ( db ! = null ) { tdb . clear ( getApplicationContext ( ) ) ; } tsuper . onTerminate ( ) ; } 
public void clear ( ) { for ( Entry < Integer , ProtectedBinary > entry : pool . entrySet ( ) ) entry . getValue ( ) . clear ( ) ; tpool . clear ( ) ; } 
public int findUnusedKey ( ) { int unusedKey = pool . size ( ) ; while ( get ( unusedKey ) ! = null ) unusedKey + + ; return unusedKey ; } 
public abstract void initNew ( String dbPath ) ; public abstract void clearCache ( ) ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { public void clearCache() {}} 
public void copyHeader ( PwDbHeaderV3 header ) { public void clearCache() {}} 
public static Importer createImporter ( InputStream is , File streamDir ) throws InvalidDBSignatureException , IOException { treturn createImporter ( is , streamDir , false ) ; } 
public static Importer createImporter ( InputStream is , File streamDir , boolean debug ) throws InvalidDBSignatureException , IOException { tint sig1 = LEDataInputStream . readInt ( is ) ; tint sig2 = LEDataInputStream . readInt ( is ) ; tif ( PwDbHeaderV3 . matchesHeader ( sig1 , sig2 ) ) { tif ( debug ) { treturn new ImporterV3Debug ( ) ; } treturn new ImporterV3 ( ) ; } else if ( PwDbHeaderV4 . matchesHeader ( sig1 , sig2 ) ) { treturn new ImporterV4 ( streamDir ) ; } tthrow new InvalidDBSignatureException ( ) ; 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) throws IOException { tbyte fieldId = ( byte ) lis . read ( ) ; tint size = lis . readInt ( ) ; tif ( size < 0 ) throw new IOException ( " Corrupted file " ) ; tbyte [ ] data = new byte [ 0 ] ; tif ( size > 0 ) { tif ( fieldId ! = PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary ) tdata = lis . readBytes ( size ) ; } tboolean result = true ; tswitch ( fieldId ) { tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : tresult = false ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : tbyte flag = lis . readBytes ( 1 ) [ 0 ] ; tboolean protectedFlag = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = tPwDbHeaderV4 . KdbxBinaryFlags . None ; } 
public void doAction ( byte [ ] buffer ) throws IOException { outputStream . write ( buffer ) ; } 
public void output ( ) throws IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : db . binPool . binaries ( ) ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( ( int ) bin . length ( ) + 1 ) ; los . write ( flag ) ; byte [ ] buffer = new byte [ 3 * 256 ] ; InputStream fileInputStream = bin . getData ( ) ; To create the last buffer who is smaller long numberOfFullBuffer = bin.length() / buffer.length; long sizeOfFullBuffers = numberOfFullBuffer * buffer.length; int read = 0; if (protectedBinary.length() > 0) { while (read < bin.length()) { Create the last smaller buffer if (read >= sizeOfFullBuffers) buffer = new byte[(int) (bin.length() % buffer.length)]; read += fileInputStream.read(buffer, 0, buffer.length); los.write(buffer); } } los.write(PwDbInnerHeaderV4Fields.EndOfHeader); los.writeInt(0); } 
private void subWriteValue ( ProtectedBinary value ) throws IllegalArgumentException , IllegalStateException , IOException { tint valLength = ( int ) value . length ( ) ; tif ( valLength > 0 ) { tbyte [ ] buffer = new byte [ valLength ] ; 
public long length ( ) { tif ( data ! = null ) treturn data . length ; tif ( dataFile ! = null ) treturn size ; treturn 0 ; } 
public InputStream getData ( ) throws IOException { tif ( data ! = null ) treturn new ByteArrayInputStream ( data ) ; 
public void clear ( ) { tdata = null ; tif ( dataFile ! = null & & ! dataFile . delete ( ) ) tLog . e ( TAG , " Unable to delete temp file " + dataFile . getAbsolutePath ( ) ) ; 
public boolean equals ( ProtectedBinary o ) { return this = = o | | o ! = null & & getClass ( ) = = o . getClass ( ) 
public void readBytes ( int length , ActionReadBytes actionReadBytes ) throws IOException { tint bufferSize = 256 * 3 ; tbyte [ ] buffer = new byte [ bufferSize ] ; tint offset = 0 ; tint read = 0 ; twhile ( offset < length & & read ! = - 1 ) { 
protected void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); checks if fingerprint is available, only starts listening for fingerprints when available & auto start configured checkFingerprintAvailability(false); } 
public void onClick ( View view ) { checkFingerprintAvailability ( true ) ; } 
private int toggleMode ( final int newMode , final boolean startListening ) { if ( mode ! = newMode ) { mode = newMode ; switch ( mode ) { case Cipher . ENCRYPT_MODE : fingerPrintHelper . initEncryptData ( startListening ) ; break ; case Cipher . DECRYPT_MODE : final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; if ( ivSpecValue ! = null ) { fingerPrintHelper . initDecryptData ( ivSpecValue , startListening ) ; } break ; } } else { fingerPrintHelper . stopListening ( ) ; if ( startListening ) fingerPrintHelper . startListening ( ) ; } return mode ; } 
private void checkFingerprintAvailability ( final boolean forceAutoStart ) { fingerprint not supported (by API level or hardware) so keep option hidden if (!fingerPrintHelper.isHardwareDetected()) { setFingerPrintVisibilty(View.GONE); 
public void initEncryptData ( final boolean startListening ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null & & hasEnrolledFingerprints ( ) ) { fingerPrintCallback . onException ( ) ; } return ; } try { initEncryptKey ( false , startListening ) ; 
private void initEncryptKey ( final boolean deleteExistingKey , final boolean startListening ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; cryptoInitOk = true ; stopListening ( ) ; if ( startListening ) startListening ( ) ; } 
public void initDecryptData ( final String ivSpecValue , final boolean startListening ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( false ) ; } return ; } else if ( ! hasEnrolledFingerprints ( ) ) { return ; } try { initDecryptKey ( ivSpecValue , false , startListening ) ; 
private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey , final boolean startListening ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64Coder.decode(ivSpecValue); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; stopListening(); if( startListening ) startListening(); } 
public void testDetection ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; Importer importer = ImporterFactory . createImporter ( is , ctx . getFilesDir ( ) ) ; assertTrue ( importer instanceof ImporterV4 ) ; is . close ( ) ; 
public void testParsing ( ) throws IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
private void testSaving ( String inputFile , String password , String outputFile ) throws IOException , InvalidDBException , PwDbOutputException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( inputFile , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; PwDatabaseV4 db = importer . openDatabase ( is , password , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . toByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getAppPath ( ctx , outputFile ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; db = importer . openDatabase ( bis , password , null ) ; bis . close ( ) ; fos . close ( ) ; 
public void testComposite ( ) throws IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key " ) ) ) ; is . close ( ) ; 
public void testCompositeBinary ( ) throws IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " keyfile-binary.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key-binary " ) ) ) ; is . close ( ) ; 
public void testKeyfile ( ) throws IOException , InvalidDBException { AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " key-only.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " " , TestUtil . getKeyFileInputStream ( ctx , TestUtil . getAppPath ( ctx , " key " ) ) ) ; is . close ( ) ; 
public void testNoGzip ( ) throws IOException , InvalidDBException { Context ctx = getContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
public void testReadHeader ( ) throws Exception { tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; tassertEquals ( 6000 , db . numKeyEncRounds ) ; tassertTrue ( db . dataCipher . equals ( AesEngine . CIPHER_UUID ) ) ; tis . close ( ) ; 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tContext ctx = getContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; tdb = importer . openDatabase ( is , " 12345 " , null ) ; tis . close ( ) ; tspr = SprEngine . getInstance ( db ) ; } 
public void testEncryption ( ) throws Exception { byte [ ] input = new byte [ 4096 ] ; Random random = new Random ( ) ; random . nextBytes ( input ) ; File dir = getContext ( ) . getFilesDir ( ) ; File temp = new File ( dir , " 1 " ) ; ProtectedBinary pb = new ProtectedBinary ( true , temp , input . length ) ; OutputStream os = pb . getOutputStream ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; Util . copyStream ( bais , os ) ; os . close ( ) ; InputStream is = pb . getData ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Util . copyStream ( is , baos ) ; byte [ ] output = baos . toByteArray ( ) ; assertArrayEquals ( input , output ) ; 
private boolean ReadInnerHeader ( LEDataInputStream lis , PwDbHeaderV4 header ) throws IOException { tbyte fieldId = ( byte ) lis . read ( ) ; tint size = lis . readInt ( ) ; tif ( size < 0 ) throw new IOException ( " Corrupted file " ) ; tbyte [ ] data = new byte [ 0 ] ; tif ( size > 0 ) { tif ( fieldId ! = PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary ) tdata = lis . readBytes ( size ) ; } tboolean result = true ; tswitch ( fieldId ) { tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . EndOfHeader : tresult = false ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomStreamID : header . setRandomStreamID ( data ) ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . InnerRandomstreamKey : header . innerRandomStreamKey = data ; tbreak ; tcase PwDbHeaderV4 . PwDbInnerHeaderV4Fields . Binary : tbyte flag = lis . readBytes ( 1 ) [ 0 ] ; tboolean protectedFlag = ( flag & PwDbHeaderV4 . KdbxBinaryFlags . Protected ) ! = tPwDbHeaderV4 . KdbxBinaryFlags . None ; } 
public void output ( ) throws IOException { los . write ( PwDbInnerHeaderV4Fields . InnerRandomStreamID ) ; los . writeInt ( 4 ) ; los . writeInt ( header . innerRandomStream . id ) ; int streamKeySize = header . innerRandomStreamKey . length ; los . write ( PwDbInnerHeaderV4Fields . InnerRandomstreamKey ) ; los . writeInt ( streamKeySize ) ; los . write ( header . innerRandomStreamKey ) ; for ( ProtectedBinary bin : db . binPool . binaries ( ) ) { byte flag = KdbxBinaryFlags . None ; if ( bin . isProtected ( ) ) { flag | = KdbxBinaryFlags . Protected ; } los . write ( PwDbInnerHeaderV4Fields . Binary ) ; los . writeInt ( ( int ) bin . length ( ) + 1 ) ; los . write ( flag ) ; InputStream inputStream = bin . getData ( ) ; int binLength = bin . length ( ) ; Util . copyStream ( inputStream , los ) ; } los . write ( PwDbInnerHeaderV4Fields . EndOfHeader ) ; los . writeInt ( 0 ) ; } 
public Cipher initCipher ( int mode ) { Cipher cipher ; ttry { tcipher = CipherFactory . getInstance ( " AES/CBC/PKCS5Padding " ) ; tcipher . init ( mode , keySpec , ivSpec ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IllegalStateException ( e ) ; } catch ( NoSuchPaddingException e ) { tthrow new IllegalStateException ( e ) ; } catch ( InvalidKeyException e ) { tthrow new IllegalStateException ( e ) ; } catch ( InvalidAlgorithmParameterException e ) { tthrow new IllegalStateException ( e ) ; } treturn cipher ; } 
public void setupEnc ( File file ) { tbyte [ ] iv = new byte [ 16 ] ; tbyte [ ] key = new byte [ 32 ] ; tsecureRandom . nextBytes ( key ) ; tsecureRandom . nextBytes ( iv ) ; tkeySpec = new SecretKeySpec ( key , " AES " ) ; tivSpec = new IvParameterSpec ( ( iv ) ) ; tCipher cipherOut = initCipher ( Cipher . ENCRYPT_MODE ) ; tFileOutputStream fos ; ttry { tfos = new FileOutputStream ( file ) ; } catch ( FileNotFoundException e ) { tthrow new IllegalStateException ( e ) ; } tcos = new CipherOutputStream ( fos , cipherOut ) ; } 
public int length ( ) { tif ( data ! = null ) treturn data . length ; tif ( dataFile ! = null ) treturn size ; treturn 0 ; } 
public static void copyStream ( InputStream in , OutputStream out ) throws IOException { tbyte [ ] buf = new byte [ MAX_BUF_SIZE ] ; tint read ; twhile ( ( read = in . read ( buf ) ) ! = - 1 ) { tout . write ( buf , 0 , read ) ; 
public static int copyStream ( InputStream in , OutputStream out , int maxBytes ) throws IOException { if ( maxBytes < = 0 ) return 0 ; tint bufSize = Math . min ( maxBytes , MAX_BUF_SIZE ) ; tbyte [ ] buf = new byte [ bufSize ] ; tint origMax = maxBytes ; tint read ; tdo { tassert ( maxBytes > 0 ) ; tif ( maxBytes > = buf . length ) { tread = in . read ( buf ) ; } else { tread = in . read ( buf , 0 , maxBytes ) ; } tif ( read = = - 1 ) { break ; } tout . write ( buf , 0 , read ) ; tmaxBytes - = read ; } while ( maxBytes > 0 ) ; } 
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { onListItemClick ( ( ListView ) parent , v , position , id ) ; } 
public void onClick ( View v ) { String fileName = Util . getEditText ( FileSelectActivity . this , R . id . file_filename ) ; try { PasswordActivity . Launch ( FileSelectActivity . this , fileName ) ; 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . this , R . id . file_filename ) ; Make sure file name exists if (filename.length() == 0) { Toast .makeText(FileSelectActivity.this, R.string.error_filename_required, Toast.LENGTH_LONG).show(); return; } Try to create the file File file = new File(filename); try { if (file.exists()) { Toast.makeText(FileSelectActivity.this, R.string.error_database_exists, Toast.LENGTH_LONG).show(); return; } File parent = file.getParentFile(); if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) { Toast.makeText(FileSelectActivity.this, R.string.error_invalid_path, Toast.LENGTH_LONG).show(); return; } if ( ! parent.exists() ) { Create parent dircetory if ( ! parent.mkdirs() ) { Toast.makeText(FileSelectActivity.this, R.string.error_could_not_create_parent, Toast.LENGTH_LONG).show(); return; } } file.createNewFile(); } catch (IOException e) { Toast.makeText( FileSelectActivity.this, getText(R.string.error_file_not_create) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show(); return; } Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( FileSelectActivity . this ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( FileSelectActivity . this , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( FileSelectActivity . this ) ; diag . show ( ) ; } 
public void run ( ) { if ( mSuccess ) { Add to recent files 
public void run ( ) { SetPasswordDialog password = new SetPasswordDialog ( FileSelectActivity . this , mOnFinish ) ; password . show ( ) ; } 
private void fillData ( ) { Set the initial value of the filename EditText filename = (EditText) findViewById(R.id.file_filename); filename.setText(Environment.getExternalStorageDirectory().getAbsolutePath() + getString(R.string.default_file_path)); mAdapter = new ArrayAdapter<String>(this, R.layout.file_row, R.id.file_filename, fileHistory.getDbList()); mList.setAdapter(mAdapter); } 
protected void onListItemClick ( ListView l , View v , int position , long id ) { new AsyncTask < Integer , Void , Void > ( ) { String fileName ; 
protected Void doInBackground ( Integer . . . args ) { int position = args [ 0 ] ; fileName = fileHistory . getDatabaseAt ( position ) ; keyFile = fileHistory . getKeyfileAt ( position ) ; return null ; } 
protected void onPostExecute ( Void v ) { try { PasswordActivity . Launch ( FileSelectActivity . this , fileName , keyFile ) ; 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( ( requestCode = = GET_CONTENT | | requestCode = = OPEN_DOC ) & & resultCode = = RESULT_OK ) { if ( data ! = null ) { Uri uri = data . getData ( ) ; if ( uri ! = null ) { if ( StorageAF . useStorageFramework ( this ) ) { try { try to persist read and write permissions ContentResolver resolver = getContentResolver(); ContentResolverCompat.takePersistableUriPermission(resolver, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION); ContentResolverCompat.takePersistableUriPermission(resolver, uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION); } catch (Exception e) { nop } } if (requestCode == GET_CONTENT) { uri = UriUtil.translate(this, uri); } filename = uri.toString(); } } } if (filename != null) { EditText fn = (EditText) findViewById(R.id.file_filename); 
protected void onResume ( ) { super . onResume ( ) ; Check to see if we need to change modes if ( fileHistory.hasRecentFiles() != recentMode ) { Restart the activity Intent intent = getIntent(); startActivity(intent); finish(); } FileNameView fnv = (FileNameView) findViewById(R.id.file_select); fnv.updateExternalStorageWarning(); } 
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . fileselect , menu ) ; return true ; } 
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { super . onCreateContextMenu ( menu , v , menuInfo ) ; menu . add ( 0 , CMENU_CLEAR , 0 , R . string . remove_from_filelist ) ; } 
protected java . lang . Void doInBackground ( String . . . args ) { String filename = args [ 0 ] ; fileHistory . deleteFile ( Uri . parse ( args [ 0 ] ) ) ; return null ; } 
protected void onPostExecute ( Void v ) { refreshList ( ) ; } 
private void refreshList ( ) { ( ( BaseAdapter ) mAdapter ) . notifyDataSetChanged ( ) ; } 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return true ; return PermissionUtil . checkAndRequest ( this , PERMISSION_REQUEST_ID ) ; } 
private void createFile ( String filename ) { Try to create the file File file = new File(filename); try { if (file.exists()) { Toast.makeText(FileSelectActivity.this, R.string.error_database_exists, Toast.LENGTH_LONG).show(); return; } File parent = file.getParentFile(); if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) { Toast.makeText(FileSelectActivity.this, R.string.error_invalid_path, Toast.LENGTH_LONG).show(); return; } if ( ! parent.exists() ) { Create parent dircetory if ( ! parent.mkdirs() ) { Toast.makeText(FileSelectActivity.this, R.string.error_could_not_create_parent, Toast.LENGTH_LONG).show(); return; } } file.createNewFile(); } catch (IOException e) { Toast.makeText( FileSelectActivity.this, getText(R.string.error_file_not_create) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show(); return; } Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
public void onClick ( View v ) { String filename = Util . getEditText ( FileSelectActivity . this , R . id . file_filename ) ; Make sure file name exists if (filename.length() == 0) { Toast .makeText(FileSelectActivity.this, R.string.error_filename_required, Toast.LENGTH_LONG).show(); return; } if (PermissionUtil.checkAndRequest(FileSelectActivity.this, PERMISSION_REQUEST_ID)) { createFile(filename); 
public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { if ( requestCode = = PERMISSION_REQUEST_ID & & grantResults [ 0 ] = = PackageManager . PERMISSION_GRANTED & & 
public static boolean checkAndRequest ( Activity act , int reqId ) { boolean hasRead = ContextCompat . checkSelfPermission ( act , Manifest . permission . READ_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; boolean hasWrite = ContextCompat . checkSelfPermission ( act , Manifest . permission . WRITE_EXTERNAL_STORAGE ) = = PackageManager . PERMISSION_GRANTED ; if ( ! hasRead | | ! hasWrite ) { ActivityCompat . requestPermissions ( act , READ_WRITE_PERMISSIONS , reqId ) ; return false ; } return true ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tfileHistory = new RecentFileHistory ( this ) ; tPRNGFixes . apply ( ) ; tmIntentReceiver = new BroadcastReceiver ( ) { @Override public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( Intents . TIMEOUT ) ) { ttimeout ( context ) ; } } } ; tIntentFilter filter = new IntentFilter ( ) ; tfilter . addAction ( Intents . TIMEOUT ) ; tregisterReceiver ( mIntentReceiver , filter ) ; } 
public void onReceive ( Context context , Intent intent ) { tString action = intent . getAction ( ) ; tif ( action . equals ( Intents . TIMEOUT ) ) { ttimeout ( context ) ; 
private void timeout ( Context context ) { tLog . d ( TAG , " Timeout " ) ; tApp . setShutdown ( ) ; tNotificationManager nm = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; tnm . cancelAll ( ) ; } 
public void onTerminate ( ) { tif ( db ! = null ) { tdb . clear ( getApplicationContext ( ) ) ; } tunregisterReceiver ( mIntentReceiver ) ; tsuper . onTerminate ( ) ; } 
public static void start ( Context ctx ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tString sTimeout = prefs . getString ( ctx . getString ( R . string . app_timeout_key ) , ctx . getString ( R . string . clipboard_timeout_default ) ) ; tlong timeout ; ttry { ttimeout = Long . parseLong ( sTimeout ) ; } catch ( NumberFormatException e ) { ttimeout = DEFAULT_TIMEOUT ; } tif ( timeout = = - 1 ) { } 
public void testOpen ( ) { ttry { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; 
public void setUp ( ) throws Exception { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tmPE = ( PwEntryV3 ) TestData . GetTest1 ( ctx ) . entries . get ( 0 ) ; 
public void setUp ( ) throws Exception { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tmPG = ( PwGroupV3 ) TestData . GetTest1 ( ctx ) . getGroups ( ) . get ( 0 ) ; 
public void setUp ( ) throws Exception { tmRand = new Random ( ) ; } 
public void testDelete ( ) { tDatabase db ; tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; ttry { tdb = TestData . GetDb ( ctx , ASSET , PASSWORD , KEYFILE , FILENAME ) ; } catch ( Exception e ) { tassertTrue ( " Failed to open database: " + e . getMessage ( ) , false ) ; treturn ; } tPwDatabaseV3 pm = ( PwDatabaseV3 ) db . pm ; tPwGroup group1 = getGroup ( pm , GROUP1_NAME ) ; tassertNotNull ( " Could not find group1 " , group1 ) ; 
private void testKeyfile ( String dbAsset , String keyAsset , String password ) throws Exception { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tFile sdcard = Environment . getExternalStorageDirectory ( ) ; tString keyPath = ctx . getFilesDir ( ) . getAbsolutePath ( ) + " /key " ; tTestUtil . extractKey ( ctx , keyAsset , keyPath ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( dbAsset , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; timporter . openDatabase ( is , password , TestUtil . getKeyFileInputStream ( ctx , keyPath ) ) ; tis . close ( ) ; } 
public void testReadTwofish ( ) throws Exception { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " twofish.kdb " , AssetManager . ACCESS_STREAMING ) ; tImporterV3 importer = new ImporterV3 ( ) ; tPwDatabaseV3 db = importer . openDatabase ( is , " 12345 " , null ) ; tassertTrue ( db . algorithm = = PwEncryptionAlgorithm . Twofish ) ; tis . close ( ) ; 
public void testDetection ( ) throws IOException , InvalidDBException { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; Importer importer = ImporterFactory . createImporter ( is , ctx . getFilesDir ( ) ) ; assertTrue ( importer instanceof ImporterV4 ) ; is . close ( ) ; 
private void testSaving ( String inputFile , String password , String outputFile ) throws IOException , InvalidDBException , PwDbOutputException { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( inputFile , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; PwDatabaseV4 db = importer . openDatabase ( is , password , null ) ; is . close ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PwDbV4Output output = ( PwDbV4Output ) PwDbOutput . getInstance ( db , bos ) ; output . output ( ) ; byte [ ] data = bos . toByteArray ( ) ; FileOutputStream fos = new FileOutputStream ( TestUtil . getAppPath ( ctx , outputFile ) , false ) ; InputStream bis = new ByteArrayInputStream ( data ) ; bis = new CopyInputStream ( bis , fos ) ; importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; db = importer . openDatabase ( bis , password , null ) ; bis . close ( ) ; fos . close ( ) ; 
public void setUp ( ) throws Exception { ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; TestUtil . extractKey ( ctx , " keyfile.key " , TestUtil . getAppPath ( ctx , " key " ) ) ; TestUtil . extractKey ( ctx , " binary.key " , TestUtil . getAppPath ( ctx , " key-binary " ) ) ; 
public void testNoGzip ( ) throws IOException , InvalidDBException { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; AssetManager am = ctx . getAssets ( ) ; InputStream is = am . open ( " no-encrypt.kdbx " , AssetManager . ACCESS_STREAMING ) ; ImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; importer . openDatabase ( is , " 12345 " , null ) ; is . close ( ) ; 
public void testReadHeader ( ) throws Exception { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; tPwDatabaseV4 db = importer . openDatabase ( is , " 12345 " , null ) ; tassertEquals ( 6000 , db . numKeyEncRounds ) ; tassertTrue ( db . dataCipher . equals ( AesEngine . CIPHER_UUID ) ) ; tis . close ( ) ; 
public void testEncryption ( ) throws Exception { byte [ ] input = new byte [ 4096 ] ; Random random = new Random ( ) ; random . nextBytes ( input ) ; Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; File dir = ctx . getFilesDir ( ) ; File temp = new File ( dir , " 1 " ) ; ProtectedBinary pb = new ProtectedBinary ( true , temp , input . length ) ; OutputStream os = pb . getOutputStream ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; Util . copyStream ( bais , os ) ; os . close ( ) ; InputStream is = pb . getData ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Util . copyStream ( is , baos ) ; byte [ ] output = baos . toByteArray ( ) ; assertArrayEquals ( input , output ) ; 
public void setUp ( ) throws Exception { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test.kdbx " , AssetManager . ACCESS_STREAMING ) ; tImporterV4 importer = new ImporterV4 ( ctx . getFilesDir ( ) ) ; tdb = importer . openDatabase ( is , " 12345 " , null ) ; tis . close ( ) ; tspr = SprEngine . getInstance ( db ) ; } 
public void setUp ( ) throws Exception { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; mPM = TestData . GetTest1 ( ctx ) ; } 
public void testFinalKey ( ) throws PwDbOutputException { tByteArrayOutputStream bActual = new ByteArrayOutputStream ( ) ; PwDbV3Output pActual = new PwDbV3OutputDebug ( mPM , bActual , true ) ; PwDbHeader hActual = pActual . outputHeader ( bActual ) ; byte [ ] finalKey = pActual . getFinalKey ( hActual ) ; assertArrayEquals ( " Keys mismatched " , mPM . finalKey , finalKey ) ; 
public void testFullWrite ( ) throws IOException , PwDbOutputException { Context ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tAssetManager am = ctx . getAssets ( ) ; tInputStream is = am . open ( " test1.kdb " ) ; assertArrayEquals("Databases do not match.", bExpected.toByteArray(), bActual.toByteArray()); 
public void setUp ( ) throws Exception { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tmDb = TestData . GetDb1 ( ctx , true ) ; } 
private void updateOmitSetting ( boolean setting ) { tContext ctx = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; tSharedPreferences . Editor editor = prefs . edit ( ) ; teditor . putBoolean ( ctx . getString ( R . string . omitbackup_key ) , setting ) ; teditor . commit ( ) ; 
private boolean launchUrl ( int resId ) { try { Util . gotoUrl ( this , resId ) ; } catch ( ActivityNotFoundException e ) { Toast . makeText ( this , R . string . error_failed_to_launch_link , Toast . LENGTH_LONG ) . show ( ) ; return false ; } return true ; } 
protected void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . password_activity ) ; } 
private boolean isBiometricSupported ( ) { int auth = biometricManager . canAuthenticate ( ) ; return ( auth = = BiometricManager . BIOMETRIC_SUCCESS | | auth = = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) & & KeyguardManagerCompat . isKeyguardSecure ( keyguardManager ) ; 
public boolean isFingerprintInitialized ( ) { return initOk ; } 
public void initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( fingerPrintCallback ! = null ) { fingerPrintCallback . onException ( ) ; } return ; } try { initEncryptKey ( false ) ; 
private void initEncryptKey ( final boolean deleteExistingKey ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; cryptoInitOk = true ; 
public void initDecryptData ( final String ivSpecValue ) { cryptoInitOk = false ; try { initDecryptKey ( ivSpecValue , false ) ; 
private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64Coder.decode(ivSpecValue); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; 
private void createNewKeyIfNeeded ( final boolean allowDeleteExisting ) { try { keyStore . load ( null ) ; 
public void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; } 
public View onCreateView ( @NonNull LayoutInflater inflater , @Nullable ViewGroup container , @Nullable Bundle savedInstanceState ) { return inflater . inflate ( R . layout . password , container , false ) ; } 
public void onClick ( View v ) { initDecryptData ( ) ; Cipher cipher = fingerprintHelper . getCipher ( ) ; if cipher == null biometricOpenPrompt.authenticate(loadPrompt, new BiometricPrompt.CryptoObject(cipher)); } 
public void onClick ( View v ) { clearStoredCredentials ( ) ; setFingerPrintVisibilty ( ) ; } 
public void onCreateOptionsMenu ( @NonNull Menu menu , @NonNull MenuInflater inflater ) { super . onCreateOptionsMenu ( menu , inflater ) ; MenuInflater inflate = getActivity ( ) . getMenuInflater ( ) ; inflate . inflate ( R . menu . password , menu ) ; } 
private void biometricOpenUpdateVisibility ( ) { int visibility ; if ( biometricsAvailable ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); } 
public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; GroupActivity . Launch ( getActivity ( ) ) ; } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); fingerprintHelper.encryptData(password); GroupActivity.Launch(getActivity()); 
public void onAuthenticationError ( int errorCode , @NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; if ( ! canceledBiometricAuth ( errorCode ) ) { Toast . makeText ( context , R . string . biometric_auth_error , Toast . LENGTH_LONG ) . show ( ) ; } GroupActivity . Launch ( getActivity ( ) ) ; } 
public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( context , R . string . biometric_auth_failed , Toast . LENGTH_LONG ) . show ( ) ; } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; retrieve the encrypted value from preferences final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null); if (encryptedValue != null) { fingerprintHelper.decryptData(encryptedValue); 
public void onAuthenticationError ( int errorCode , @NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; if ( ! canceledBiometricAuth ( errorCode ) ) { Toast . makeText ( context , R . string . biometric_auth_error , Toast . LENGTH_LONG ) . show ( ) ; 
private boolean canceledBiometricAuth ( int errorCode ) { switch ( errorCode ) { case BiometricPrompt . ERROR_CANCELED : 
private void initDecryptData ( ) { final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; fingerprintHelper . initDecryptData ( ivSpecValue ) ; } 
public void onActivityCreated ( @Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; Intent i = getActivity ( ) . getIntent ( ) ; new InitTask ( ) . execute ( i ) ; } 
public void onActivityResult ( int requestCode , int resultCode , @Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; Activity activity = getActivity ( ) ; View view = getView ( ) ; switch ( requestCode ) { 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) getView().findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(getActivity()); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS || auth == BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED){ 
public void onRequestPermissionsResult ( int requestCode , @NonNull String [ ] permissions , @NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode = = PERMISSION_REQUEST_ID & & grantResults [ 0 ] = = PackageManager . PERMISSION_GRANTED & & 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) view . findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( getActivity ( ) ) ; diag . show ( ) ; } 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { String newDefaultFileName ; if ( isChecked ) { newDefaultFileName = mDbUri . toString ( ) ; } else { newDefaultFileName = " " ; } SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putString ( PasswordActivity . KEY_DEFAULT_FILENAME , newDefaultFileName ) ; editor . apply ( ) ; BackupManager backupManager = new BackupManager ( getContext ( ) ) ; backupManager . dataChanged ( ) ; 
private void errorMessage ( int resId ) { Toast . makeText ( getActivity ( ) , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
private void setEditText ( int resId , String str ) { TextView te = ( TextView ) getView ( ) . findViewById ( resId ) ; assert ( te = = null ) ; if ( te ! = null ) { te . setText ( str ) ; 
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Activity activity = getActivity ( ) ; Clear before we load Database db = App.getDB(); db.clear(activity.getApplicationContext()); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, activity, mDbUri, pass, keyfile, new PasswordFragment.AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(activity, task, R.string.loading_database); pt.run(); } 
public void run ( ) { final Activity activity = getActivity ( ) ; if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( activity ) ; } 
public void onClick ( View view ) { String pass = getEditText ( R . id . password ) ; String key = getEditText ( R . id . pass_keyfile ) ; loadDatabase ( pass , key ) ; } 
private void clearStoredCredentials ( ) { prefsNoBackup . edit ( ) . remove ( getPreferenceKeyValue ( ) ) 
public void handleEncryptedResult ( String value , String ivSpec ) { prefsNoBackup . edit ( ) . putString ( getPreferenceKeyValue ( ) , value ) . putString ( getPreferenceKeyIvSpec ( ) , ivSpec ) . commit ( ) ; and remove visual input to reset UI Toast.makeText(getContext(), R.string.encrypted_value_stored, Toast.LENGTH_SHORT).show(); 
public void handleDecryptedResult ( String value ) { on decrypt enter it for the purchase/login action passwordView.setText(value); confirmButton.performClick(); } 
public void onInvalidKeyException ( ) { Toast . makeText ( getContext ( ) , R . string . fingerprint_invalid_key , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onException ( boolean showWarningMessage ) { if ( showWarningMessage ) { onException ( R . string . fingerprint_error ) ; 
public void onException ( CharSequence message ) { Toast . makeText ( getContext ( ) , message , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onException ( int resId ) { Toast . makeText ( getContext ( ) , resId , Toast . LENGTH_SHORT ) . show ( ) ; } 
public void onKeyInvalidated ( ) { clearStoredCredentials ( ) ; Toast . makeText ( getContext ( ) , R . string . fingerprint_key_invalidated , Toast . LENGTH_LONG ) . show ( ) ; } 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return true ; return PermissionUtil . checkAndRequest ( this . getActivity ( ) , PERMISSION_REQUEST_ID ) ; } 
public void initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return ; } try { initEncryptKey ( false ) ; 
public void encryptData ( final String value ) { if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return ; } try { actual do encryption here 
public void decryptData ( final String encryptedValue ) { if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return ; } try { actual decryption here 
public void onClick ( View v ) { initDecryptData ( ) ; Cipher cipher = biometricHelper . getCipher ( ) ; if cipher == null biometricOpenPrompt.authenticate(loadPrompt, new BiometricPrompt.CryptoObject(cipher)); } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(getActivity()); 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; retrieve the encrypted value from preferences final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null); if (encryptedValue != null) { biometricHelper.decryptData(encryptedValue); 
private void initDecryptData ( ) { final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; biometricHelper . initDecryptData ( ivSpecValue ) ; } 
public void onException ( boolean showWarningMessage ) { if ( showWarningMessage ) { onException ( R . string . biometric_error ) ; 
public void onKeyInvalidated ( ) { clearStoredCredentials ( ) ; Toast . makeText ( getContext ( ) , R . string . biometric_invalidated , Toast . LENGTH_LONG ) . show ( ) ; } 
public boolean equals ( ProtectedBinary o ) { return ( this = = o ) | | ( o ! = null ) & & ( getClass ( ) = = o . getClass ( ) ) 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . settings ) ; tgetSupportFragmentManager ( ) . beginTransaction ( ) 
public static void Launch ( Context ctx ) { tIntent i = new Intent ( ctx , AppSettingsFragement . class ) ; tctx . startActivity ( i ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tBoolean value = ( Boolean ) newValue ; tif ( ! value . booleanValue ( ) ) { tApp . getFileHistory ( ) . deleteAllKeys ( ) ; } treturn true ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { tBoolean value = ( Boolean ) newValue ; tif ( value = = null ) { tvalue = true ; } tif ( ! value ) { tApp . getFileHistory ( ) . deleteAll ( ) ; } treturn true ; } 
public void onStop ( ) { tbackupManager . dataChanged ( ) ; tsuper . onStop ( ) ; } 
public static void Launch ( Context ctx ) { tIntent i = new Intent ( ctx , DBSettingsFragement . class ) ; tctx . startActivity ( i ) ; } 
public Dialog onCreateDialog ( Bundle savedInstanceState ) { return super . onCreateDialog ( savedInstanceState ) ; } 
public static void Launch ( Context ctx ) { tIntent i = new Intent ( ctx , MainSettingsFragement . class ) ; tctx . startActivity ( i ) ; } 
public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { taddPreferencesFromResource ( R . xml . preferences ) ; tDatabase db = App . getDB ( ) ; tif ( ! ( db . Loaded ( ) & & db . pm . appSettingsEnabled ( ) ) ) { tPreference dbSettings = findPreference ( getString ( R . string . db_key ) ) ; 
tprotected void onBindDialogView ( View view ) { tsuper . onBindDialogView ( view ) ; tmEditText = view . findViewById ( android . R . id . edit ) ; tmEditText . setInputType ( InputType . TYPE_CLASS_NUMBER | InputType . TYPE_NUMBER_VARIATION_NORMAL ) ; tDatabase db = App . getDB ( ) ; tmPM = db . pm ; tmEditText . setText ( Long . toString ( db . pm . getNumRounds ( ) ) ) ; 
public static RoundsPreferenceFragment newInstance ( String key ) { tfinal RoundsPreferenceFragment tfragment = new RoundsPreferenceFragment ( ) ; tfinal Bundle b = new Bundle ( 1 ) ; tb . putString ( ARG_KEY , key ) ; tfragment . setArguments ( b ) ; treturn fragment ; } 
public void onDialogClosed ( boolean positiveResult ) { EditTextPreference pref = ( EditTextPreference ) getPreference ( ) ; tif ( positiveResult ) { tint rounds ; 
public void run ( ) { tif ( mSuccess ) { tPreference preference = getPreference ( ) ; tPreference . OnPreferenceChangeListener listner = preference . getOnPreferenceChangeListener ( ) ; tif ( listner ! = null ) { tlistner . onPreferenceChange ( preference , null ) ; } } else { tdisplayMessage ( mCtx ) ; tmPM . setNumRounds ( mOldRounds ) ; } tsuper . run ( ) ; } 
public boolean equals ( ProtectedBinary o ) { return ( this = = o ) | | ( ( o ! = null ) & & ( getClass ( ) = = o . getClass ( ) ) 
private void biometricOpenUpdateVisibility ( ) { int visibility ; BiometricManager biometricManager = BiometricManager . from ( getActivity ( ) ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( biometricsAvailable & & auth ! = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); } 
protected void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . password_activity ) ; Toolbar toolbar = ( Toolbar ) findViewById ( R . id . toolbar ) ; setSupportActionBar ( toolbar ) ; } 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; tswitch ( resultCode ) { 
tprotected void onActivityResult ( int requestCode , int resultCode , Intent data ) { tsuper . onActivityResult ( requestCode , resultCode , data ) ; tswitch ( resultCode ) { 
public void onClick ( View v ) { clearStoredCredentials ( ) ; } 
private void clearStoredCredentials ( ) { prefsNoBackup . edit ( ) . remove ( getPreferenceKeyValue ( ) ) . remove ( getPreferenceKeyIvSpec ( ) ) . commit ( ) ; setFingerPrintVisibilty ( ) ; } 
private void query ( String query ) { tmGroup = mDb . Search ( query ) ; tif ( mGroup = = null | | mGroup . childEntries . size ( ) < 1 ) { tsetContentView ( new GroupEmptyView ( this ) ) ; } else { tsetContentView ( new GroupViewOnlyView ( this ) ) ; } tToolbar toolbar = ( Toolbar ) findViewById ( R . id . toolbar ) ; tsetSupportActionBar ( toolbar ) ; tsetGroupTitle ( ) ; tsetListAdapter ( new PwGroupListAdapter ( this , mGroup ) ) ; } 
private UUID decodeUUID ( String encoded ) { tif ( encoded = = null | | encoded . length ( ) = = 0 ) { treturn PwDatabaseV4 . UUID_ZERO ; } tbyte [ ] buf = Base64 . decode ( encoded , Base64 . DEFAULT ) ; treturn Types . bytestoUUID ( buf ) ; } 
private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64.decode(ivSpecValue, Base64.DEFAULT); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate = null ; tif ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { tbyte [ ] buf = Base64 . decode ( sDate , Base64 . DEFAULT ) ; tif ( buf . length ! = 8 ) { tbyte [ ] buf8 = new byte [ 8 ] ; tSystem . arraycopy ( buf , 0 , buf8 , 0 , Math . min ( buf . length , 8 ) ) ; tbuf = buf8 ; } tlong seconds = LEDataInputStream . readLong ( buf , 0 ) ; tutcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { ttry { tutcDate = PwDatabaseV4XML . dateFormatter . get ( ) . parse ( sDate ) ; } catch ( ParseException e ) { 
private UUID ReadUuid ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString encoded = ReadString ( xpp ) ; tif ( encoded = = null | | encoded . length ( ) = = 0 ) { treturn PwDatabaseV4 . UUID_ZERO ; } tbyte [ ] buf = Base64 . decode ( encoded , Base64 . DEFAULT ) ; treturn Types . bytestoUUID ( buf ) ; } 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tString ref = xpp . getAttributeValue ( null , AttrRef ) ; tif ( ref ! = null ) { txpp . next ( ) ; } 
private void writeMeta ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemMeta ) ; twriteObject ( ElemGenerator , mPM . localizedAppName ) ; tif ( hashOfHeader ! = null ) { twriteObject ( ElemHeaderHash , Base64 . encodeToString ( hashOfHeader , Base64 . DEFAULT ) ) ; } twriteObject ( ElemDbName , mPM . name , true ) ; twriteObject ( ElemDbNameChanged , mPM . nameChanged ) ; twriteObject ( ElemDbDesc , mPM . description , true ) ; twriteObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; twriteObject ( ElemDbDefaultUser , mPM . defaultUserName , true ) ; twriteObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; twriteObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; twriteObject ( ElemDbColor , mPM . color ) ; twriteObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; twriteObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; twriteObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; twriteList ( ElemMemoryProt , mPM . memoryProtection ) ; twriteCustomIconList ( ) ; twriteObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; twriteObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; twriteObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; twriteObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; twriteObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; twriteObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; twriteObject ( ElemHistoryMaxSize , mPM . historyMaxSize ) ; twriteObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; twriteObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { twriteBinPool ( ) ; } twriteList ( ElemCustomData , mPM . customData ) ; txml . endTag ( null , ElemMeta ) ; 
private void writeObject ( String name , UUID uuid ) throws IllegalArgumentException , IllegalStateException , IOException { tbyte [ ] data = Types . UUIDtoBytes ( uuid ) ; twriteObject ( name , Base64 . encodeToString ( data , Base64 . DEFAULT ) ) ; } 
private void writeObject ( String key , ProtectedString value , boolean isEntryString ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( key ! = null & & value ! = null ) ; txml . startTag ( null , ElemString ) ; txml . startTag ( null , ElemKey ) ; txml . text ( safeXmlString ( key ) ) ; txml . endTag ( null , ElemKey ) ; txml . startTag ( null , ElemValue ) ; tboolean protect = value . isProtected ( ) ; tif ( isEntryString ) { tif ( key . equals ( PwDefsV4 . TITLE_FIELD ) ) { tprotect = mPM . memoryProtection . protectTitle ; } telse if ( key . equals ( PwDefsV4 . USERNAME_FIELD ) ) { tprotect = mPM . memoryProtection . protectUserName ; } telse if ( key . equals ( PwDefsV4 . PASSWORD_FIELD ) ) { tprotect = mPM . memoryProtection . protectPassword ; } telse if ( key . equals ( PwDefsV4 . URL_FIELD ) ) { tprotect = mPM . memoryProtection . protectUrl ; } telse if ( key . equals ( PwDefsV4 . NOTES_FIELD ) ) { tprotect = mPM . memoryProtection . protectNotes ; } } tif ( protect ) { txml . attribute ( null , AttrProtected , ValTrue ) ; tbyte [ ] data = value . toString ( ) . getBytes ( " UTF-8 " ) ; tint valLength = data . length ; tif ( valLength > 0 ) { tbyte [ ] encoded = new byte [ valLength ] ; trandomStream . processBytes ( data , 0 , valLength , encoded , 0 ) ; txml . text ( Base64 . encodeToString ( encoded , Base64 . DEFAULT ) ) ; } } telse { txml . text ( safeXmlString ( value . toString ( ) ) ) ; } txml . endTag ( null , ElemValue ) ; txml . endTag ( null , ElemString ) ; 
private void writeCustomIconList ( ) throws IllegalArgumentException , IllegalStateException , IOException { tList < PwIconCustom > customIcons = mPM . customIcons ; tif ( customIcons . size ( ) = = 0 ) return ; txml . startTag ( null , ElemCustomIcons ) ; tfor ( PwIconCustom icon : customIcons ) { txml . startTag ( null , ElemCustomIconItem ) ; twriteObject ( ElemCustomIconItemID , icon . uuid ) ; twriteObject ( ElemCustomIconItemData , Base64 . encodeToString ( icon . imageData , Base64 . DEFAULT ) ) ; txml . endTag ( null , ElemCustomIconItem ) ; } txml . endTag ( null , ElemCustomIcons ) ; } 
public boolean initEncryptData ( ) { cryptoInitOk = false ; if ( ! isFingerprintInitialized ( ) ) { if ( biometricCallback ! = null ) { biometricCallback . onException ( ) ; } return false ; } try { initEncryptKey ( false ) ; return true ; } catch ( final InvalidKeyException invalidKeyException ) { try { biometricCallback . onKeyInvalidated ( ) ; initEncryptKey ( true ) ; } catch ( InvalidKeyException e ) { biometricCallback . onInvalidKeyException ( ) ; } catch ( Exception e ) { biometricCallback . onException ( ) ; ; } } catch ( final Exception e ) { biometricCallback . onException ( ) ; } return false ; } 
public boolean initDecryptData ( final String ivSpecValue ) { cryptoInitOk = false ; try { initDecryptKey ( ivSpecValue , false ) ; return true ; } catch ( final InvalidKeyException invalidKeyException ) { Key was invalidated (maybe all registered fingerprints were changed) Retry with new key try { biometricCallback.onKeyInvalidated(); initDecryptKey(ivSpecValue, true); } catch (InvalidKeyException e) { biometricCallback.onInvalidKeyException(); } catch (Exception e) { biometricCallback.onException(); } } catch (final Exception e) { biometricCallback.onException(); } return false; } 
public void onClick ( View v ) { if ( ! initDecryptData ( ) ) { return ; } Cipher cipher = biometricHelper . getCipher ( ) ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; } 
private boolean initDecryptData ( ) { final String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; return biometricHelper . initDecryptData ( ivSpecValue ) ; } 
public View onCreateView ( @NonNull LayoutInflater inflater , @Nullable ViewGroup container , @Nullable Bundle savedInstanceState ) { super . onCreateView ( inflater , container , savedInstanceState ) ; mView = inflater . inflate ( R . layout . password , container , false ) ; return mView ; } 
public void onActivityResult ( int requestCode , int resultCode , @Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; Activity activity = getActivity ( ) ; switch ( requestCode ) { 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) mView.findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(getActivity()); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS || auth == BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED){ 
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) { TextView password = ( TextView ) mView . findViewById ( R . id . password ) ; if ( isChecked ) { password . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ) ; 
private void setEditText ( int resId , String str ) { TextView te = ( TextView ) mView . findViewById ( resId ) ; assert ( te = = null ) ; if ( te ! = null ) { te . setText ( str ) ; 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) mView.findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(getActivity()); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS){ initBiometrics(); 
public void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; setRetainInstance ( true ) ; } 
public void onClick ( View v ) { if ( ! initDecryptData ( ) ) { return ; } biometricCheck . setChecked ( false ) ; Cipher cipher = biometricHelper . getCipher ( ) ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; } 
private UUID decodeUUID ( String encoded ) { tif ( encoded = = null | | encoded . length ( ) = = 0 ) { treturn PwDatabaseV4 . UUID_ZERO ; } tbyte [ ] buf = Base64 . decode ( encoded , Base64 . NO_WRAP ) ; treturn Types . bytestoUUID ( buf ) ; } 
private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; important to restore spec here that was used for decryption final byte[] iv = Base64.decode(ivSpecValue, Base64.NO_WRAP); final IvParameterSpec spec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, key, spec); cryptoInitOk = true; 
private Date ReadTime ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString sDate = ReadString ( xpp ) ; tDate utcDate = null ; tif ( version > = PwDbHeaderV4 . FILE_VERSION_32_4 ) { tbyte [ ] buf = Base64 . decode ( sDate , Base64 . NO_WRAP ) ; tif ( buf . length ! = 8 ) { tbyte [ ] buf8 = new byte [ 8 ] ; tSystem . arraycopy ( buf , 0 , buf8 , 0 , Math . min ( buf . length , 8 ) ) ; tbuf = buf8 ; } tlong seconds = LEDataInputStream . readLong ( buf , 0 ) ; tutcDate = DateUtil . convertKDBX4Time ( seconds ) ; } else { ttry { tutcDate = PwDatabaseV4XML . dateFormatter . get ( ) . parse ( sDate ) ; } catch ( ParseException e ) { 
private UUID ReadUuid ( XmlPullParser xpp ) throws IOException , XmlPullParserException { tString encoded = ReadString ( xpp ) ; tif ( encoded = = null | | encoded . length ( ) = = 0 ) { treturn PwDatabaseV4 . UUID_ZERO ; } tbyte [ ] buf = Base64 . decode ( encoded , Base64 . NO_WRAP ) ; treturn Types . bytestoUUID ( buf ) ; } 
private ProtectedBinary ReadProtectedBinary ( XmlPullParser xpp ) throws XmlPullParserException , IOException { tString ref = xpp . getAttributeValue ( null , AttrRef ) ; tif ( ref ! = null ) { txpp . next ( ) ; } 
private void writeMeta ( ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemMeta ) ; twriteObject ( ElemGenerator , mPM . localizedAppName ) ; tif ( hashOfHeader ! = null ) { twriteObject ( ElemHeaderHash , Base64 . encodeToString ( hashOfHeader , Base64 . NO_WRAP ) ) ; } twriteObject ( ElemDbName , mPM . name , true ) ; twriteObject ( ElemDbNameChanged , mPM . nameChanged ) ; twriteObject ( ElemDbDesc , mPM . description , true ) ; twriteObject ( ElemDbDescChanged , mPM . descriptionChanged ) ; twriteObject ( ElemDbDefaultUser , mPM . defaultUserName , true ) ; twriteObject ( ElemDbDefaultUserChanged , mPM . defaultUserNameChanged ) ; twriteObject ( ElemDbMntncHistoryDays , mPM . maintenanceHistoryDays ) ; twriteObject ( ElemDbColor , mPM . color ) ; twriteObject ( ElemDbKeyChanged , mPM . keyLastChanged ) ; twriteObject ( ElemDbKeyChangeRec , mPM . keyChangeRecDays ) ; twriteObject ( ElemDbKeyChangeForce , mPM . keyChangeForceDays ) ; twriteList ( ElemMemoryProt , mPM . memoryProtection ) ; twriteCustomIconList ( ) ; twriteObject ( ElemRecycleBinEnabled , mPM . recycleBinEnabled ) ; twriteObject ( ElemRecycleBinUuid , mPM . recycleBinUUID ) ; twriteObject ( ElemRecycleBinChanged , mPM . recycleBinChanged ) ; twriteObject ( ElemEntryTemplatesGroup , mPM . entryTemplatesGroup ) ; twriteObject ( ElemEntryTemplatesGroupChanged , mPM . entryTemplatesGroupChanged ) ; twriteObject ( ElemHistoryMaxItems , mPM . historyMaxItems ) ; twriteObject ( ElemHistoryMaxSize , mPM . historyMaxSize ) ; twriteObject ( ElemLastSelectedGroup , mPM . lastSelectedGroup ) ; twriteObject ( ElemLastTopVisibleGroup , mPM . lastTopVisibleGroup ) ; tif ( header . version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { twriteBinPool ( ) ; } twriteList ( ElemCustomData , mPM . customData ) ; txml . endTag ( null , ElemMeta ) ; 
private void writeObject ( String name , UUID uuid ) throws IllegalArgumentException , IllegalStateException , IOException { tbyte [ ] data = Types . UUIDtoBytes ( uuid ) ; twriteObject ( name , Base64 . encodeToString ( data , Base64 . NO_WRAP ) ) ; } 
private void writeObject ( String key , ProtectedString value , boolean isEntryString ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( key ! = null & & value ! = null ) ; txml . startTag ( null , ElemString ) ; txml . startTag ( null , ElemKey ) ; txml . text ( safeXmlString ( key ) ) ; txml . endTag ( null , ElemKey ) ; txml . startTag ( null , ElemValue ) ; tboolean protect = value . isProtected ( ) ; tif ( isEntryString ) { tif ( key . equals ( PwDefsV4 . TITLE_FIELD ) ) { tprotect = mPM . memoryProtection . protectTitle ; } telse if ( key . equals ( PwDefsV4 . USERNAME_FIELD ) ) { tprotect = mPM . memoryProtection . protectUserName ; } telse if ( key . equals ( PwDefsV4 . PASSWORD_FIELD ) ) { tprotect = mPM . memoryProtection . protectPassword ; } telse if ( key . equals ( PwDefsV4 . URL_FIELD ) ) { tprotect = mPM . memoryProtection . protectUrl ; } telse if ( key . equals ( PwDefsV4 . NOTES_FIELD ) ) { tprotect = mPM . memoryProtection . protectNotes ; } } tif ( protect ) { txml . attribute ( null , AttrProtected , ValTrue ) ; tbyte [ ] data = value . toString ( ) . getBytes ( " UTF-8 " ) ; tint valLength = data . length ; tif ( valLength > 0 ) { tbyte [ ] encoded = new byte [ valLength ] ; trandomStream . processBytes ( data , 0 , valLength , encoded , 0 ) ; txml . text ( Base64 . encodeToString ( encoded , Base64 . NO_WRAP ) ) ; } } telse { txml . text ( safeXmlString ( value . toString ( ) ) ) ; } txml . endTag ( null , ElemValue ) ; txml . endTag ( null , ElemString ) ; 
private void writeCustomIconList ( ) throws IllegalArgumentException , IllegalStateException , IOException { tList < PwIconCustom > customIcons = mPM . customIcons ; tif ( customIcons . size ( ) = = 0 ) return ; txml . startTag ( null , ElemCustomIcons ) ; tfor ( PwIconCustom icon : customIcons ) { txml . startTag ( null , ElemCustomIconItem ) ; twriteObject ( ElemCustomIconItemID , icon . uuid ) ; twriteObject ( ElemCustomIconItemData , Base64 . encodeToString ( icon . imageData , Base64 . NO_WRAP ) ) ; txml . endTag ( null , ElemCustomIconItem ) ; } txml . endTag ( null , ElemCustomIcons ) ; } 
public void onCreate ( @Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; setRetainInstance ( true ) ; afterOnCreateBeforeEndOfOnResume = true ; } 
public void onClick ( View v ) { biometricLogin ( ) ; } 
private void biometricLogin ( ) { if ( ! initDecryptData ( ) ) { return ; } biometricCheck . setChecked ( false ) ; Cipher cipher = biometricHelper . getCipher ( ) ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; } 
private void biometricOpenUpdateVisibility ( ) { int visibility ; boolean autoOpen = false ; BiometricManager biometricManager = BiometricManager . from ( getActivity ( ) ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( biometricsAvailable & & auth ! = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; autoOpen = prefs.getBoolean(getString(R.string.biometric_autoscan_key), getResources().getBoolean(R.bool.biometric_autoscan)) && afterOnCreateBeforeEndOfOnResume; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); if (autoOpen) { Thread delayThread = new Thread() { 
public void run ( ) { biometricLogin ( ) ; } 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) mView.findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(getActivity()); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS){ initBiometrics(); } else { biometricsAvailable = false; setFingerPrintVisibilty(); } afterOnCreateBeforeEndOfOnResume = false; } 
public void run ( ) { tif ( ( mPd ! = null ) & & mPd . isShowing ( ) ) { tmPd . dismiss ( ) ; 
tprotected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . settings ) ; tif ( savedInstanceState = = null ) { tgetSupportFragmentManager ( ) 
public void onCreate ( @Nullable Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetRetainInstance ( true ) ; } 
public void onCreateOptionsMenu ( @NonNull Menu menu , @NonNull MenuInflater inflater ) { super . onCreateOptionsMenu ( menu , inflater ) ; MenuInflater inflate = mActivity . getMenuInflater ( ) ; inflate . inflate ( R . menu . password , menu ) ; } 
public void onAttach ( @NonNull Context context ) { super . onAttach ( context ) ; if ( context instanceof Activity ) { mActivity = ( Activity ) context ; 
public void onDetach ( ) { super . onDetach ( ) ; mActivity = null ; } 
public void onDestroy ( ) { super . onDestroy ( ) ; mActivity = null ; } 
private void biometricOpenUpdateVisibility ( ) { int visibility ; boolean autoOpen = false ; BiometricManager biometricManager = BiometricManager . from ( mActivity ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( biometricsAvailable & & auth ! = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; autoOpen = prefs.getBoolean(getString(R.string.biometric_autoscan_key), getResources().getBoolean(R.bool.biometric_autoscan)) && afterOnCreateBeforeEndOfOnResume; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); if (autoOpen) { Thread delayThread = new Thread() { 
public void run ( ) { try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { Ignore } mActivity.runOnUiThread(new Runnable() { @Override 
private void initBiometrics ( ) { final Context context = getContext ( ) ; biometricsAvailable = true ; biometricHelper = new BiometricHelper ( context , this ) ; Executor executor = ContextCompat . getMainExecutor ( context ) ; BiometricPrompt . AuthenticationCallback saveCallback = new BiometricPrompt . AuthenticationCallback ( ) { @Override public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; GroupActivity . Launch ( mActivity ) ; } @Override public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(mActivity); } @Override public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) { super.onAuthenticationError(errorCode, errString); if (!canceledBiometricAuth(errorCode)) { Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show(); } GroupActivity.Launch(mActivity); } }; BiometricPrompt.AuthenticationCallback openCallback = new BiometricPrompt.AuthenticationCallback() { @Override public void onAuthenticationFailed() { super.onAuthenticationFailed(); Toast.makeText(context, R.string.biometric_auth_failed, Toast.LENGTH_LONG).show(); } @Override public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) { super.onAuthenticationSucceeded(result); retrieve the encrypted value from preferences final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null); if (encryptedValue != null) { biometricHelper.decryptData(encryptedValue); } } @Override public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) { super.onAuthenticationError(errorCode, errString); if (!canceledBiometricAuth(errorCode)) { Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show(); } } }; biometricSavePrompt = new BiometricPrompt(this, executor, saveCallback); BiometricPrompt.PromptInfo.Builder saveBuilder = new BiometricPrompt.PromptInfo.Builder(); savePrompt = saveBuilder.setDescription(getString(R.string.biometric_auth_to_store)) .setConfirmationRequired(false) .setTitle(getString(R.string.biometric_save_password)) .setNegativeButtonText(getString(android.R.string.cancel)) .build(); biometricOpenPrompt = new BiometricPrompt(this, executor, openCallback); BiometricPrompt.PromptInfo.Builder openBuilder = new BiometricPrompt.PromptInfo.Builder(); loadPrompt = openBuilder.setDescription(getString(R.string.biometric_auth_to_open)) .setConfirmationRequired(false) .setTitle(getString(R.string.biometric_open_db)) .setNegativeButtonText(getString(android.R.string.cancel)) .build(); setFingerPrintVisibilty(); } 
public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; GroupActivity . Launch ( mActivity ) ; } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(mActivity); 
public void onAuthenticationError ( int errorCode , @NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; if ( ! canceledBiometricAuth ( errorCode ) ) { Toast . makeText ( context , R . string . biometric_auth_error , Toast . LENGTH_LONG ) . show ( ) ; } GroupActivity . Launch ( mActivity ) ; } 
public void onActivityCreated ( @Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; Intent i = mActivity . getIntent ( ) ; new InitTask ( ) . execute ( i ) ; } 
public void onActivityResult ( int requestCode , int resultCode , @Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; Activity activity = mActivity ; switch ( requestCode ) { 
public void onResume ( ) { super . onResume ( ) ; If the application was shutdown make sure to clear the password field, if it was saved in the instance state if (App.isShutdown()) { TextView password = (TextView) mView.findViewById(R.id.password); password.setText(""); } Clear the shutdown flag App.clearShutdown(); BiometricManager biometricManager = BiometricManager.from(mActivity); int auth = biometricManager.canAuthenticate(); if (auth == BiometricManager.BIOMETRIC_SUCCESS){ initBiometrics(); } else { biometricsAvailable = false; setFingerPrintVisibilty(); } afterOnCreateBeforeEndOfOnResume = false; } 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( mActivity ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( mActivity , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( mActivity ) ; diag . show ( ) ; } 
private void errorMessage ( int resId ) { Toast . makeText ( mActivity , resId , Toast . LENGTH_LONG ) . show ( ) ; } 
private void loadDatabaseWithPermission ( ) { String pass = storedPassword ; storedPassword = null ; Uri keyfile = storedKeyUri ; storedKeyUri = null ; Activity activity = mActivity ; Clear before we load Database db = App.getDB(); db.clear(activity.getApplicationContext()); Clear the shutdown flag App.clearShutdown(); Handler handler = new Handler(); LoadDB task = new LoadDB(db, activity, mDbUri, pass, keyfile, new PasswordFragment.AfterLoad(handler, db)); ProgressTask pt = new ProgressTask(activity, task, R.string.loading_database); pt.run(); } 
public void run ( ) { final Activity activity = mActivity ; if ( db . passwordEncodingError ) { PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper ( ) ; 
private boolean checkFilePermissions ( Uri db , Uri keyfile ) { boolean hasFileUri = hasFileUri ( db ) | | hasFileUri ( keyfile ) ; if ( ! hasFileUri ) return true ; return PermissionUtil . checkAndRequest ( this . mActivity , PERMISSION_REQUEST_ID ) ; } 
private void biometricOpenUpdateVisibility ( ) { int visibility ; boolean autoOpen = false ; BiometricManager biometricManager = BiometricManager . from ( mActivity ) ; int auth = biometricManager . canAuthenticate ( ) ; if ( biometricsAvailable & & auth ! = BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) { String encryptedValue = prefsNoBackup . getString ( getPreferenceKeyValue ( ) , null ) ; String ivSpecValue = prefsNoBackup . getString ( getPreferenceKeyIvSpec ( ) , null ) ; boolean hasStoredKey = encryptedValue ! = null & & ivSpecValue ! = null ; if ( hasStoredKey ) { Check key value visibility = View.VISIBLE; autoOpen = prefs.getBoolean(getString(R.string.biometric_autoscan_key), getResources().getBoolean(R.bool.biometric_autoscan)) && afterOnCreateBeforeEndOfOnResume; } else { visibility = View.GONE; } } else { visibility = View.GONE; } biometricOpen.setVisibility(visibility); biometricClear.setVisibility(visibility); divider3.setVisibility(visibility); if (autoOpen) { biometricLogin(); 
public void onActivityCreated ( @Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; Intent i = mActivity . getIntent ( ) ; InitTask task = new InitTask ( ) ; task . onPostExecute ( task . doInBackground ( i ) ) ; } 
public void run ( ) { tActivity act = mPd . getOwnerActivity ( ) ; tif ( act ! = null & & act . isFinishing ( ) ) { treturn ; } tif ( ( mPd ! = null ) & & mPd . isShowing ( ) ) { tmPd . dismiss ( ) ; 
tprotected void displayMessage ( Context ctx ) { tif ( ctx ! = null & & mMessage ! = null & & mMessage . length ( ) > 0 ) { tToast . makeText ( ctx , mMessage , Toast . LENGTH_LONG ) . show ( ) ; 
public void onClick ( DialogInterface dialog , int which ) { GroupActivity . Launch ( mActivity ) ; } 
private String fillRefPlaceholders ( String text , SprContextV4 ctx , int recursionLevel ) { tif ( ctx . db = = null ) { return text ; } tint offset = 0 ; tfor ( int i = 0 ; i < 20 ; + + i ) { ttext = fillRefsUsingCache ( text , ctx ) ; tint start = StrUtil . indexOfIgnoreCase ( text , STR_REF_START , offset , Locale . ENGLISH ) ; tif ( start < 0 ) { break ; } tint end = StrUtil . indexOfIgnoreCase ( text , STR_REF_END , start + 1 , Locale . ENGLISH ) ; tif ( end < = start ) { break ; } tString fullRef = text . substring ( start , end + 1 ) ; tTargetResult result = findRefTarget ( fullRef , ctx ) ; tif ( result ! = null ) { PwEntryV4 found = result . entry ; char wanted = result . wanted ; if ( found ! = null ) { tString data ; tswitch ( wanted ) { tcase 'T' : tdata = found . getTitle ( ) ; tbreak ; tcase 'U' : tdata = found . getUsername ( ) ; tbreak ; tcase 'A' : tdata = found . getUrl ( ) ; tbreak ; tcase 'P' : tdata = found . getPassword ( ) ; tbreak ; tcase 'N' : tdata = found . getNotes ( ) ; tbreak ; tcase 'I' : tdata = found . getUUID ( ) . toString ( ) ; tbreak ; tdefault : toffset = start + 1 ; tcontinue ; } tSprContextV4 subCtx = ( SprContextV4 ) ctx . clone ( ) ; tsubCtx . entry = found ; tString innerContent = compileInternal ( data , subCtx , recursionLevel + 1 ) ; taddRefsToCache ( fullRef , innerContent , ctx ) ; ttext = fillRefsUsingCache ( text , ctx ) ; } else { toffset = start + 1 ; tcontinue ; } } } treturn text ; } 
public TargetResult findRefTarget ( String fullRef , SprContextV4 ctx ) { tif ( fullRef = = null ) { return null ; } tfullRef = fullRef . toUpperCase ( Locale . ENGLISH ) ; tif ( ! fullRef . startsWith ( STR_REF_START ) | | ! fullRef . endsWith ( STR_REF_END ) ) { treturn null ; } tString ref = fullRef . substring ( STR_REF_START . length ( ) , fullRef . length ( ) - STR_REF_END . length ( ) ) ; tif ( ref . length ( ) < = 4 ) { return null ; } tif ( ref . charAt ( 1 ) ! = '@' ) { return null ; } tif ( ref . charAt ( 3 ) ! = ':' ) { return null ; } tchar scan = Character . MIN_VALUE ; tchar wanted = Character . MIN_VALUE ; tscan = Character . toUpperCase ( ref . charAt ( 2 ) ) ; twanted = Character . toUpperCase ( ref . charAt ( 0 ) ) ; tSearchParametersV4 sp = new SearchParametersV4 ( ) ; tsp . setupNone ( ) ; tsp . searchString = ref . substring ( 4 ) ; tif ( scan = = 'T' ) { sp . searchInTitles = true ; } telse if ( scan = = 'U' ) { sp . searchInUserNames = true ; } telse if ( scan = = 'A' ) { sp . searchInUrls = true ; } telse if ( scan = = 'P' ) { sp . searchInPasswords = true ; } telse if ( scan = = 'N' ) { sp . searchInNotes = true ; } telse if ( scan = = 'I' ) { sp . searchInUUIDs = true ; } telse if ( scan = = 'O' ) { sp . searchInOther = true ; } telse { return null ; } tList < PwEntry > list = new ArrayList < PwEntry > ( ) ; tctx . db . rootGroup . searchEntries ( sp , list ) ; tif ( list . size ( ) > 0 ) { treturn new TargetResult ( ( PwEntryV4 ) list . get ( 0 ) , wanted ) ; } treturn null ; } 
public void run ( ) { tActivity act = mPd . getOwnerActivity ( ) ; tif ( act ! = null & & act . isFinishing ( ) ) { treturn ; } tboolean isDestroyed = false ; tif ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . JELLY_BEAN_MR1 ) { isDestroyed = mAct . isDestroyed ( ) ; } tif ( ( mPd ! = null ) & & mPd . isShowing ( ) & & ! isDestroyed ) { tmPd . dismiss ( ) ; 
private void trimLists ( ) { int size = databases . size ( ) ; for ( int i = FileDbHelper . MAX_FILES ; i < size ; i + + ) { if ( i < databases . size ( ) ) { 
public static byte [ ] readBytes ( InputStream is , int length ) throws IOException { tbyte [ ] buf = new byte [ length ] ; tint count = 0 ; twhile ( count < length ) { tint read = is . read ( buf , count , length - count ) ; } 
public byte [ ] readBytes ( int length ) throws IOException { treturn readBytes ( baseStream , length ) ; } 
public static int readUShort ( InputStream is ) throws IOException { byte [ ] buf = readBytes ( is , 2 ) ; return readUShort ( buf , 0 ) ; } 
public static int readInt ( InputStream is ) throws IOException { byte [ ] buf = readBytes ( is , 4 ) ; return readInt ( buf , 0 ) ; } 
public static int readUShort ( InputStream is ) throws IOException { byte [ ] buf = readBytes ( is , 2 ) ; buf = padOut ( buf , 2 ) ; return readUShort ( buf , 0 ) ; } 
public static int readInt ( InputStream is ) throws IOException { byte [ ] buf = readBytes ( is , 4 ) ; buf = padOut ( buf , 4 ) ; return readInt ( buf , 0 ) ; } 
public static byte [ ] padOut ( byte [ ] input , int length ) { tif ( input = = null | | input . length < length ) { tbyte [ ] output = new byte [ 4 ] ; tif ( input = = null ) { treturn output ; } tfor ( int i = 0 ; i < input . length ; i + + ) { toutput [ i ] = input [ i ] ; } treturn output ; } treturn input ; } 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(mActivity); passwordView.setText(""); 
public void testParseVersion ( ) { tlong ver1 = Types . parseVersion ( " 1.00 " ) ; tassertEquals ( " Version 1.00 doesn't match " , ver1 , 0x0001000000000000L ) ; tlong ver2 = Types . parseVersion ( " 2.00 " ) ; tassertEquals ( " Version 2.00 doesn't match " , ver2 , 0x0002000000000000L ) ; } 
private byte [ ] decodeKey ( String value , long version ) { tif ( version = = 0x0001000000000000L ) { treturn Base64 . decode ( value , Base64 . NO_WRAP ) ; 
private byte [ ] decodeKeyV2 ( String value ) { tif ( value = = null ) { treturn null ; } tint len = value . length ( ) ; tif ( ( len & 1 ) ! = 0 ) { treturn null ; } tbyte [ ] pb = new byte [ len / 2 ] ; tfor ( int i = 0 ; i < len ; i + = 2 ) { tchar ch = value . charAt ( i ) ; tbyte bt ; tbt = hexToByte ( ch ) ; tbt < < = 4 ; tch = value . charAt ( ( i + 1 ) ) ; tbyte bt2 = hexToByte ( ch ) ; tbt | = bt2 ; tpb [ i > > 1 ] = bt ; } treturn pb ; 
private byte hexToByte ( char ch ) { byte bt ; tif ( ( ch > = '0' ) & & ( ch < = '9' ) ) { tbt = ( byte ) ( ch - '0' ) ; } else if ( ( ch > = 'a' ) & & ( ch < = 'f' ) ) { tbt = ( byte ) ( ch - 'a' + 10 ) ; } else if ( ( ch > = 'A' ) & & ( ch < = 'F' ) ) { tbt = ( byte ) ( ch - 'A' + 10 ) ; } else { tbt = 0 ; } treturn bt ; } 
public static long parseVersion ( String ver ) { tif ( ver = = null ) { treturn 0 ; } tString [ ] verArray = ver . split ( " [.,] " ) ; tint len = verArray . length ; tif ( len < = 0 ) { treturn 0 ; } ttry { tint part = Integer . parseInt ( verArray [ 0 ] . trim ( ) ) ; 
private void setEditText ( int resId , String str ) { TextView te = ( TextView ) mView . findViewById ( resId ) ; assert ( te ! = null ) ; if ( te ! = null ) { te . setText ( str ) ; 
public byte [ ] transform ( byte [ ] masterKey , KdfParameters p ) throws IOException { byte [ ] salt = p . getByteArray ( ParamSalt ) ; int parallelism = ( int ) p . getUInt32 ( ParamParallelism ) ; long memory = p . getUInt64 ( ParamMemory ) ; long iterations = p . getUInt64 ( ParamIterations ) ; long version = p . getUInt32 ( ParamVersion ) ; byte [ ] secretKey = p . getByteArray ( ParamSecretKey ) ; byte [ ] assocData = p . getByteArray ( ParamAssocData ) ; return Argon2Native . transformKey ( masterKey , salt , parallelism , memory , iterations , secretKey , assocData , version , type . value ( ) ) ; 
public static byte [ ] transformKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version , int type ) throws IOException { NativeLib . init ( ) ; return nTransformMasterKey ( password , salt , parallelism , memory , iterations , secretKey , associatedData , version , type ) ; } 
private static native byte [ ] nTransformMasterKey ( byte [ ] password , byte [ ] salt , int parallelism , long memory , long iterations , byte [ ] secretKey , byte [ ] associatedData , long version , int type ) throws IOException ; } 
public String put ( String key , String value , Date last ) { lastMod . put ( key , last ) ; return put ( key , value ) ; } 
public boolean operate ( PwGroup group ) { if ( group = = null ) { treturn true ; } tPwGroupV4 g4 = ( PwGroupV4 ) group ; if ( g4 . tags . length ( ) > 0 ) { tminVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4_1 ) ; } tif ( g4 . customData . size ( ) > 0 ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4 ) ; } treturn true ; } 
public boolean operate ( PwEntry entry ) { if ( entry = = null ) { treturn true ; } tPwEntryV4 e4 = ( PwEntryV4 ) entry ; if ( e4 . qualityCheck ) { tminVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4_1 ) ; } tif ( e4 . customData . size ( ) > 0 ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4 ) ; } treturn true ; } 
private void startGroup ( PwGroupV4 group ) throws IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , ElemGroup ) ; twriteObject ( ElemUuid , group . uuid ) ; twriteObject ( ElemName , group . name ) ; twriteObject ( ElemNotes , group . notes ) ; twriteObject ( ElemIcon , group . icon . iconId ) ; tif ( ! group . customIcon . equals ( PwIconCustom . ZERO ) ) { twriteObject ( ElemCustomIconID , group . customIcon . uuid ) ; } twriteList ( ElemTimes , group ) ; twriteObject ( ElemIsExpanded , group . isExpanded ) ; twriteObject ( ElemGroupDefaultAutoTypeSeq , group . defaultAutoTypeSequence ) ; twriteObject ( ElemEnableAutoType , group . enableAutoType ) ; twriteObject ( ElemEnableSearching , group . enableSearching ) ; twriteObject ( ElemLastTopVisibleEntry , group . lastTopVisibleEntry ) ; tif ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 ) { tif ( ! group . prevParentGroup . equals ( PwDatabaseV4 . UUID_ZERO ) ) { 
private void writeEntry ( PwEntryV4 entry , boolean isHistory ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( entry ! = null ) ; txml . startTag ( null , ElemEntry ) ; twriteObject ( ElemUuid , entry . uuid ) ; twriteObject ( ElemIcon , entry . icon . iconId ) ; tif ( ! entry . customIcon . equals ( PwIconCustom . ZERO ) ) { twriteObject ( ElemCustomIconID , entry . customIcon . uuid ) ; } twriteObject ( ElemFgColor , entry . foregroundColor ) ; twriteObject ( ElemBgColor , entry . backgroupColor ) ; twriteObject ( ElemOverrideUrl , entry . overrideURL ) ; tif ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 & & ! entry . qualityCheck ) { twriteObject ( ElemQualityCheck , false ) ; } twriteObject ( ElemTags , entry . tags ) ; tif ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 & & ! entry . prevParentGroup . equals ( PwDatabaseV4 . UUID_ZERO ) ) { twriteObject ( ElemPreviousParentGroup , entry . prevParentGroup ) ; } twriteList ( ElemTimes , entry ) ; twriteList ( entry . strings , true ) ; twriteList ( entry . binaries ) ; twriteList ( ElemAutoType , entry . autoType ) ; tif ( ! isHistory ) { twriteList ( ElemHistory , entry . history , true ) ; } else { tassert ( entry . history . size ( ) = = 0 ) ; } txml . endTag ( null , ElemEntry ) ; } 
private void writeObject ( String name , String keyName , String keyValue , String valueName , String valueValue , Date lastMod ) tthrows IllegalArgumentException , IllegalStateException , IOException { txml . startTag ( null , name ) ; txml . startTag ( null , keyName ) ; txml . text ( safeXmlString ( keyValue ) ) ; txml . endTag ( null , keyName ) ; txml . startTag ( null , valueName ) ; txml . text ( safeXmlString ( valueValue ) ) ; txml . endTag ( null , valueName ) ; tif ( lastMod ! = null ) { twriteObject ( ElemLastModTime , lastMod ) ; } txml . endTag ( null , name ) ; } 
private void writeList ( String name , AutoType autoType ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & autoType ! = null ) ; txml . startTag ( null , name ) ; twriteObject ( ElemAutoTypeEnabled , autoType . enabled ) ; twriteObject ( ElemAutoTypeObfuscation , autoType . obfuscationOptions ) ; tif ( autoType . defaultSequence . length ( ) > 0 ) { twriteObject ( ElemAutoTypeDefaultSeq , autoType . defaultSequence , true ) ; } tfor ( Entry < String , String > pair : autoType . entrySet ( ) ) { twriteObject ( ElemAutoTypeItem , ElemWindow , pair . getKey ( ) , ElemKeystrokeSequence , tpair . getValue ( ) , null ) ; } txml . endTag ( null , name ) ; 
private void writeList ( String name , PwCustomData customData ) throws IllegalArgumentException , IllegalStateException , IOException { tassert ( name ! = null & & customData ! = null ) ; txml . startTag ( null , name ) ; tfor ( Entry < String , String > pair : customData . entrySet ( ) ) { tString key = pair . getKey ( ) ; tDate lastMod = null ; tif ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 ) { tlastMod = customData . getLastMod ( key ) ; } twriteObject ( ElemStringDictExItem , ElemKey , key , ElemValue , pair . getValue ( ) , lastMod ) ; } txml . endTag ( null , name ) ; 
private void writeCustomIconList ( ) throws IllegalArgumentException , IllegalStateException , IOException { tList < PwIconCustom > customIcons = mPM . customIcons ; tif ( customIcons . size ( ) = = 0 ) return ; txml . startTag ( null , ElemCustomIcons ) ; tfor ( PwIconCustom icon : customIcons ) { txml . startTag ( null , ElemCustomIconItem ) ; twriteObject ( ElemCustomIconItemID , icon . uuid ) ; twriteObject ( ElemCustomIconItemData , Base64 . encodeToString ( icon . imageData , Base64 . NO_WRAP ) ) ; tif ( header . version > = PwDbHeaderV4 . FILE_VERSION_32_4_1 ) { tif ( ! EmptyUtils . isNullOrEmpty ( icon . name ) ) { twriteObject ( ElemName , icon . name , true ) ; } tif ( icon . lastMod ! = null ) { twriteObject ( ElemLastModTime , icon . lastMod ) ; } } txml . endTag ( null , ElemCustomIconItem ) ; } txml . endTag ( null , ElemCustomIcons ) ; } 
public boolean operate ( PwEntry entry ) { if ( entry = = null ) { treturn true ; } tPwEntryV4 e4 = ( PwEntryV4 ) entry ; if ( ! e4 . qualityCheck ) { tminVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4_1 ) ; } tif ( e4 . customData . size ( ) > 0 ) { minVer = Math . max ( minVer , PwDbHeaderV4 . FILE_VERSION_32_4 ) ; } treturn true ; } 
public PwDbHeader outputHeader ( OutputStream os ) throws PwDbOutputException { tPwDbHeaderV4 header = new PwDbHeaderV4 ( mPM ) ; theader . version = mPM . getMinKdbxVersion ( ) ; tsetIVs ( header ) ; tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4 ( mPM , header , os ) ; ttry { tpho . output ( ) ; } catch ( IOException e ) { tthrow new PwDbOutputException ( " Failed to output the header. " , e ) ; } thashOfHeader = pho . getHashOfHeader ( ) ; theaderHmac = pho . headerHmac ; treturn header ; } 
public static KdfParameters deserialize ( byte [ ] data ) throws IOException { ByteArrayInputStream bis = new ByteArrayInputStream ( data ) ; LEDataInputStream lis = new LEDataInputStream ( bis ) ; VariantDictionary d = VariantDictionary . deserialize ( lis ) ; if ( d = = null ) { assert ( false ) ; return null ; } byte [ ] uuidBytes = d . getByteArray ( ( ParamUUID ) ) ; UUID uuid ; if ( uuidBytes ! = null ) { uuid = Types . bytestoUUID ( uuidBytes ) ; } else { Correct issue where prior versions were writing empty UUIDs for AES uuid = AesKdf.CIPHER_UUID; } if (uuid == null) { assert(false); return null; } KdfParameters kdfP = new KdfParameters(uuid); kdfP.copyTo(d); return kdfP; 
private void createFile ( String filename ) { Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
public void onClick ( View v ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; i . addCategory ( Intent . CATEGORY_OPENABLE ) ; i . setType ( " */* " ) ; i . setFlags ( Intent . FLAG_GRANT_READ_URI_PERMISSION | Intent . FLAG_GRANT_WRITE_URI_PERMISSION | Intent . FLAG_GRANT_PERSISTABLE_URI_PERMISSION ) ; Uri initialUri = Uri . parse ( " content:com.android.externalstorage.documents/document/primary:keepass " ) ; i . putExtra ( DocumentsContract . EXTRA_INITIAL_URI , initialUri ) ; startActivityForResult ( i , OPEN_DOC ) ; } 
public void onClick ( View v ) { Intent i = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; i . addCategory ( Intent . CATEGORY_OPENABLE ) ; i . setType ( " */* " ) ; i . setFlags ( Intent . FLAG_GRANT_READ_URI_PERMISSION | Intent . FLAG_GRANT_WRITE_URI_PERMISSION | Intent . FLAG_GRANT_PERSISTABLE_URI_PERMISSION ) ; Uri initialUri = Uri . parse ( " content:com.android.externalstorage.documents/document/primary:keepass " ) ; i . putExtra ( DocumentsContract . EXTRA_INITIAL_URI , initialUri ) ; startActivityForResult ( i , CREATE_DOC ) ; } 
private void fillData ( ) { mAdapter = new ArrayAdapter < String > ( this , R . layout . file_row , R . id . file_filename , fileHistory . getDbList ( ) ) ; mList . setAdapter ( mAdapter ) ; } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; 
private void createFile ( String filename ) { Try to create the file File file = new File(filename); try { if (file.exists()) { Toast.makeText(FileSelectActivity.this, R.string.error_database_exists, Toast.LENGTH_LONG).show(); return; } File parent = file.getParentFile(); if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) { Toast.makeText(FileSelectActivity.this, R.string.error_invalid_path, Toast.LENGTH_LONG).show(); return; } if ( ! parent.exists() ) { Create parent dircetory if ( ! parent.mkdirs() ) { Toast.makeText(FileSelectActivity.this, R.string.error_could_not_create_parent, Toast.LENGTH_LONG).show(); return; } } file.createNewFile(); } catch (IOException e) { Toast.makeText( FileSelectActivity.this, getText(R.string.error_file_not_create) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show(); return; } createDB(filename); } 
private void createFile ( Uri fileURI ) { String filename = fileURI . toString ( ) ; createDB ( filename ) ; } 
private void createDB ( String filename ) { Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
public void onClick ( View v ) { if ( supportsDirectFile ) { String fileName = Util . getEditText ( FileSelectActivity . this , 
public void onClick ( View v ) { if ( supportsDirectFile ) { String filename = Util . getEditText ( FileSelectActivity . this , 
public void onClick ( View v ) { if ( StorageAF . useStorageFramework ( FileSelectActivity . this ) ) { Intent i = new Intent ( StorageAF . ACTION_OPEN_DOCUMENT ) ; 
private void lookForOpenIntentsFilePicker ( ) { if ( Interaction . isIntentAvailable ( FileSelectActivity . this , Intents . OPEN_INTENTS_FILE_BROWSE ) ) { Intent i = new Intent ( Intents . OPEN_INTENTS_FILE_BROWSE ) ; 
private void showBrowserDialog ( ) { BrowserDialog diag = new BrowserDialog ( FileSelectActivity . this ) ; diag . show ( ) ; } 
public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode = = PERMISSION_REQUEST_ID & & grantResults [ 0 ] = = PackageManager . PERMISSION_GRANTED & & 
private void fillData ( ) { if ( supportsDirectFile ) { Set the initial value of the filename EditText filename = (EditText) findViewById(R.id.file_filename); filename.setText(Environment.getExternalStorageDirectory().getAbsolutePath() + getString(R.string.default_file_path)); } mAdapter = new ArrayAdapter<String>(this, R.layout.file_row, R.id.file_filename, fileHistory.getDbList()); mList.setAdapter(mAdapter); } 
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; fillData ( ) ; String filename = null ; if ( requestCode = = FILE_BROWSE & & resultCode = = RESULT_OK ) { filename = data . getDataString ( ) ; if ( filename ! = null ) { if ( filename . startsWith ( " file: " ) ) { filename = filename . substring ( 7 ) ; } filename = URLDecoder . decode ( filename ) ; } } else if ( ( requestCode = = GET_CONTENT | | requestCode = = OPEN_DOC | | requestCode = = CREATE_DOC ) & & resultCode = = RESULT_OK ) { if ( data ! = null ) { Uri uri = data . getData ( ) ; if ( uri ! = null ) { if ( StorageAF . useStorageFramework ( this ) ) { try { try to persist read and write permissions ContentResolver resolver = getContentResolver(); ContentResolverCompat.takePersistableUriPermission(resolver, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION); ContentResolverCompat.takePersistableUriPermission(resolver, uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION); } catch (Exception e) { nop } } if (requestCode == GET_CONTENT) { uri = UriUtil.translate(this, uri); } filename = uri.toString(); if (requestCode == CREATE_DOC) { createFile(uri); } else { try { PasswordActivity.Launch(FileSelectActivity.this, filename); } catch (ContentFileNotFoundException e) { Toast.makeText(FileSelectActivity.this, R.string.file_not_found_content, Toast.LENGTH_LONG).show(); } catch (FileNotFoundException e) { Toast.makeText(FileSelectActivity.this, R.string.FileNotFound, Toast.LENGTH_LONG).show(); } } } } } if (supportsDirectFile && filename != null) { EditText fn = (EditText) findViewById(R.id.file_filename); 
public abstract void initNew ( String name ) ; public abstract void clearCache ( ) ; } 
public void copyEncrypted ( byte [ ] buf , int offset , int size ) { public void clearCache() {}} 
public void copyHeader ( PwDbHeaderV3 header ) { public void clearCache() {}} 
public void initNew ( String name ) { talgorithm = PwEncryptionAlgorithm . Rjindal ; tnumKeyEncRounds = DEFAULT_ENCRYPTION_ROUNDS ; tif ( EmptyUtils . isNullOrEmpty ( name ) ) { tname = " KeePass Password Manager " ; } } 
public void initNew ( String name ) { trootGroup = new PwGroupV4 ( true , true , name , iconFactory . getIcon ( PwIconStandard . FOLDER ) ) ; tgroups . put ( rootGroup . getId ( ) , rootGroup ) ; } 
private void populateView ( ) { String db = ( mDbUri = = null ) ? " " : mDbUri . toString ( ) ; setEditText ( R . id . filename , db ) ; String displayName = UriUtil . getFileName ( mDbUri , getContext ( ) ) ; TextView displayNameView = mView . findViewById ( R . id . filename_display ) ; if ( displayNameView ! = null ) { if ( EmptyUtils . isNullOrEmpty ( displayName ) ) { displayNameView . setVisibility ( View . GONE ) ; } else { displayNameView . setText ( UriUtil . getFileName ( mDbUri , getContext ( ) ) ) ; } } String key = ( mKeyUri = = null ) ? " " : mKeyUri . toString ( ) ; setEditText ( R . id . pass_keyfile , key ) ; } 
private void timeoutCopyToClipboard ( String label , String text ) { ttimeoutCopyToClipboard ( label , text , false ) ; } 
private void timeoutCopyToClipboard ( String label , String text , boolean sensitive ) { ttry { tUtil . copyToClipboard ( this , label , text , sensitive ) ; } catch ( SamsungClipboardException e ) { tshowSamsungDialog ( ) ; treturn ; } tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; tString sClipClear = prefs . getString ( getString ( R . string . clipboard_timeout_key ) , getString ( R . string . clipboard_timeout_default ) ) ; tlong clipClearTime = Long . parseLong ( sClipClear ) ; tif ( clipClearTime > 0 ) { tmTimer . schedule ( new ClearClipboardTask ( this , text ) , clipClearTime ) ; 
public static void markSensitive ( ClipData clipData ) { try { Object extras = persistableBundle . newInstance ( ) ; 
public static void copyToClipboard ( Context context , String label , String text ) throws SamsungClipboardException { tcopyToClipboard ( context , label , text , false ) ; } 
public static void copyToClipboard ( Context context , String label , String text , boolean sensitive ) throws SamsungClipboardException { tClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; tClipData clip = ClipData . newPlainText ( label , text ) ; tif ( sensitive ) { tClipDataCompat . markSensitive ( clip ) ; } ttry { tclipboard . setPrimaryClip ( clip ) ; 
public void run ( ) { } 
private void createFile ( String filename ) { Try to create the file File file = new File(filename); try { if (file.exists()) { Toast.makeText(FileSelectActivity.this, R.string.error_database_exists, Toast.LENGTH_LONG).show(); return; } File parent = file.getParentFile(); if ( parent == null || (parent.exists() && ! parent.isDirectory()) ) { Toast.makeText(FileSelectActivity.this, R.string.error_invalid_path, Toast.LENGTH_LONG).show(); return; } if ( ! parent.exists() ) { Create parent dircetory if ( ! parent.mkdirs() ) { Toast.makeText(FileSelectActivity.this, R.string.error_could_not_create_parent, Toast.LENGTH_LONG).show(); return; } } file.createNewFile(); } catch (IOException e) { Toast.makeText( FileSelectActivity.this, getText(R.string.error_file_not_create) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show(); return; } createDB(filename, file.getName()); } 
private void createFile ( Uri fileURI ) { String filename = fileURI . toString ( ) ; createDB ( filename , UriUtil . getFileName ( fileURI , this ) ) ; } 
private void createDB ( String filename , String dbName ) { Prep an object to collect a password once the database has been created CollectPassword password = new CollectPassword( new LaunchGroupActivity(filename)); Create the new database CreateDB create = new CreateDB(FileSelectActivity.this, filename, dbName, password, true); ProgressTask createTask = new ProgressTask( FileSelectActivity.this, create, R.string.progress_create); createTask.run(); 
private void biometricLogin ( ) { if ( ! initDecryptData ( ) ) { return ; } biometricCheck . setChecked ( false ) ; Cipher cipher = biometricHelper . getCipher ( ) ; biometricMode = BIOMETRIC_LOAD ; biometricOpenPrompt . authenticate ( loadPrompt , new BiometricPrompt . CryptoObject ( cipher ) ) ; } 
private void initBiometrics ( ) { final Context context = getContext ( ) ; biometricsAvailable = true ; biometricHelper = new BiometricHelper ( context , this ) ; Executor executor = ContextCompat . getMainExecutor ( context ) ; BiometricPrompt . AuthenticationCallback biometricCallback = new BiometricPrompt . AuthenticationCallback ( ) { @Override public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; if ( biometricMode = = BIOMETRIC_SAVE ) { Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; GroupActivity . Launch ( mActivity ) ; } else if ( biometricMode = = BIOMETRIC_LOAD ) { Toast . makeText ( context , R . string . biometric_auth_failed , Toast . LENGTH_LONG ) . show ( ) ; } } @Override public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; if ( biometricMode = = BIOMETRIC_SAVE ) { newly store the entered password in encrypted way final String password = passwordView.getText().toString(); biometricHelper.encryptData(password); GroupActivity.Launch(mActivity); passwordView.setText(""); } else if (biometricMode == BIOMETRIC_LOAD) { retrieve the encrypted value from preferences final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null); if (encryptedValue != null) { biometricHelper.decryptData(encryptedValue); } } } @Override public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) { super.onAuthenticationError(errorCode, errString); if (!canceledBiometricAuth(errorCode)) { Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show(); } if (biometricMode == BIOMETRIC_SAVE) { GroupActivity.Launch(mActivity); } } }; biometricSavePrompt = new BiometricPrompt(this, executor, biometricCallback); BiometricPrompt.PromptInfo.Builder saveBuilder = new BiometricPrompt.PromptInfo.Builder(); savePrompt = saveBuilder.setDescription(getString(R.string.biometric_auth_to_store)) .setConfirmationRequired(false) .setTitle(getString(R.string.biometric_save_password)) .setNegativeButtonText(getString(android.R.string.cancel)) .build(); biometricOpenPrompt = new BiometricPrompt(this, executor, biometricCallback); BiometricPrompt.PromptInfo.Builder openBuilder = new BiometricPrompt.PromptInfo.Builder(); loadPrompt = openBuilder.setDescription(getString(R.string.biometric_auth_to_open)) .setConfirmationRequired(false) .setTitle(getString(R.string.biometric_open_db)) .setNegativeButtonText(getString(android.R.string.cancel)) .build(); setFingerPrintVisibilty(); } 
public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; if ( biometricMode = = BIOMETRIC_SAVE ) { Toast . makeText ( context , R . string . biometric_auth_failed_store , Toast . LENGTH_LONG ) . show ( ) ; 
public void onAuthenticationSucceeded ( @NonNull BiometricPrompt . AuthenticationResult result ) { super . onAuthenticationSucceeded ( result ) ; if ( biometricMode = = BIOMETRIC_SAVE ) { newly store the entered password in encrypted way 
public void onAuthenticationError ( int errorCode , @NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; if ( ! canceledBiometricAuth ( errorCode ) ) { Toast . makeText ( context , R . string . biometric_auth_error , Toast . LENGTH_LONG ) . show ( ) ; } if ( biometricMode = = BIOMETRIC_SAVE ) { GroupActivity . Launch ( mActivity ) ; 
boolean showAndroid11Warning ( String filename ) { Uri fileUri = Uri . parse ( filename ) ; String scheme = fileUri . getScheme ( ) ; return fileUri . getScheme ( ) . equals ( " file " ) & & ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . R ) ; 
public void onClick ( DialogInterface dialogInterface , int i ) { dialogInterface . dismiss ( ) ; } 
private static PendingIntent buildIntent ( Context ctx ) { tIntent intent = new Intent ( Intents . TIMEOUT ) ; tintent . setPackage ( " com.android.keepass " ) ; tint flags = PendingIntent . FLAG_CANCEL_CURRENT ; tif ( Build . VERSION . SDK_INT > = 23 ) { tflags | = PendingIntent . FLAG_IMMUTABLE ; } tPendingIntent sender = PendingIntent . getBroadcast ( ctx , REQUEST_ID , intent , flags ) ; treturn sender ; } 
public void SaveData ( Context ctx ) throws IOException , FileUriException , PwDbOutputException { SaveData ( ctx , mUri ) ; } 
private void saveFile ( File db ) throws IOException , PwDbOutputException { FileOutputStream fos = new FileOutputStream ( db ) ; PwDbOutput pmo = PwDbOutput . getInstance ( pm , fos ) ; pmo . output ( ) ; fos . close ( ) ; Force data to disk before continuing try { fos.getFD().sync(); 
public void run ( ) { tif ( mSuccess ) { tif ( mFinish ! = null ) { tmFinish . setFilename ( mKeyfile ) ; } tdismiss ( ) ; } else { tdisplayMessage ( ( AppCompatActivity ) getOwnerActivity ( ) ) ; } tsuper . run ( ) ; } 
public void run ( ) { try { mDb . LoadData ( mCtx , mUri , mPass , mKey , mStatus ) ; saveFileData ( mUri , mKey ) ; } catch ( ArcFourException e ) { finish ( false , mCtx . getString ( R . string . error_arc4 ) ) ; return ; } catch ( InvalidPasswordException e ) { finish ( false , mCtx . getString ( R . string . InvalidPassword ) ) ; return ; } catch ( ContentFileNotFoundException e ) { finish ( false , mCtx . getString ( R . string . file_not_found_content ) ) ; return ; } catch ( FileNotFoundException e ) { if ( mUri ! = null & & Android11WarningFragment . showAndroid11Warning ( mUri ) ) { finish ( false , new Android11WarningFragment ( ) ) ; return ; } finish ( false , mCtx . getString ( R . string . FileNotFound ) ) ; return ; } catch ( IOException e ) { finish ( false , e . getMessage ( ) ) ; return ; } catch ( KeyFileEmptyException e ) { finish ( false , mCtx . getString ( R . string . keyfile_is_empty ) ) ; return ; } catch ( InvalidAlgorithmException e ) { finish ( false , mCtx . getString ( R . string . invalid_algorithm ) ) ; return ; } catch ( InvalidKeyFileException e ) { finish ( false , mCtx . getString ( R . string . keyfile_does_not_exist ) ) ; return ; } catch ( InvalidDBSignatureException e ) { finish ( false , mCtx . getString ( R . string . invalid_db_sig ) ) ; return ; } catch ( InvalidDBVersionException e ) { finish ( false , mCtx . getString ( R . string . unsupported_db_version ) ) ; return ; } catch ( InvalidDBException e ) { finish ( false , mCtx . getString ( R . string . error_invalid_db ) ) ; return ; } catch ( OutOfMemoryError e ) { finish ( false , mCtx . getString ( R . string . error_out_of_memory ) ) ; return ; } finish ( true ) ; } 
tprotected void displayMessage ( AppCompatActivity ctx ) { tif ( ctx = = null ) { return ; } tdisplayMessage ( ctx , ctx . getSupportFragmentManager ( ) ) ; } 
tprotected void displayMessage ( Context ctx , FragmentManager fm ) { tif ( ctx ! = null & & mMessage ! = null & & mMessage . length ( ) > 0 ) { tToast . makeText ( ctx , mMessage , Toast . LENGTH_LONG ) . show ( ) ; 
tprotected void finish ( boolean result , DialogFragment dialogFragment ) { tif ( mFinish ! = null ) { tmFinish . setResult ( result , dialogFragment ) ; 
public void run ( ) { tif ( ! mDontSave ) { ttry { tmDb . SaveData ( mCtx ) ; } catch ( IOException e ) { tfinish ( false , e . getMessage ( ) ) ; treturn ; } catch ( FileUriException e ) { tif ( Android11WarningFragment . showAndroid11WarningOnThisVersion ( ) ) { tfinish ( false , new Android11WarningFragment ( R . string . Android11SaveFailed ) ) ; } else { tfinish ( false , e . getMessage ( ) ) ; } treturn ; } catch ( PwDbOutputException e ) { tthrow new RuntimeException ( e ) ; } } tfinish ( true ) ; } 
public static boolean showAndroid11Warning ( String filename ) { Uri fileUri = Uri . parse ( filename ) ; return showAndroid11Warning ( fileUri ) ; } 
public static boolean showAndroid11Warning ( Uri fileUri ) { String scheme = fileUri . getScheme ( ) ; return fileUri . getScheme ( ) . equals ( " file " ) & & showAndroid11WarningOnThisVersion ( ) ; } 
public static boolean showAndroid11WarningOnThisVersion ( ) { return ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . R ) ; } 
public void onAttach ( @NonNull Context context ) { super . onAttach ( context ) ; if ( context instanceof AppCompatActivity ) { mActivity = ( AppCompatActivity ) context ; 
public void run ( ) { tif ( mSuccess ) { tPreference preference = getPreference ( ) ; tPreference . OnPreferenceChangeListener listner = preference . getOnPreferenceChangeListener ( ) ; tif ( listner ! = null ) { tlistner . onPreferenceChange ( preference , null ) ; } } else { tdisplayMessage ( mCtx , mFm ) ; tmPM . setNumRounds ( mOldRounds ) ; } tsuper . run ( ) ; } 
public static boolean showAndroid11Warning ( String filename ) { if ( EmptyUtils . isNullOrEmpty ( filename ) ) { return false ; } Uri fileUri = Uri . parse ( filename ) ; return showAndroid11Warning ( fileUri ) ; } 
public static boolean showAndroid11Warning ( Uri fileUri ) { if ( fileUri = = null ) { return false ; } String scheme = fileUri . getScheme ( ) ; return fileUri . getScheme ( ) . equals ( " file " ) & & showAndroid11WarningOnThisVersion ( ) ; } 
public PwDatabaseV4 openDatabase ( InputStream inStream , String password , InputStream keyInputStream , UpdateStatus status , long roundsFix ) throws IOException , InvalidDBException { tdb = createDB ( ) ; tPwDbHeaderV4 header = new PwDbHeaderV4 ( db ) ; db . binPool . clear ( ) ; tPwDbHeaderV4 . HeaderAndHash hh = header . loadFromFile ( inStream ) ; version = header . version ; tdb . version = version ; thashOfHeader = hh . hash ; tpbHeader = hh . header ; tdb . setMasterKey ( password , keyInputStream ) ; tdb . makeFinalKey ( header . masterSeed , db . kdfParameters , roundsFix ) ; tCipherEngine engine ; tCipher cipher ; ttry { tengine = CipherFactory . getInstance ( db . dataCipher ) ; tdb . dataEngine = engine ; tcipher = engine . getCipher ( Cipher . DECRYPT_MODE , db . finalKey , header . encryptionIV ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( NoSuchPaddingException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidKeyException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } catch ( InvalidAlgorithmParameterException e ) { tthrow new IOException ( " Invalid algorithm. " ) ; } tInputStream isPlain ; tif ( version < PwDbHeaderV4 . FILE_VERSION_32_4 ) { tInputStream decrypted = AttachCipherStream ( inStream , cipher ) ; tLEDataInputStream dataDecrypted = new LEDataInputStream ( decrypted ) ; tbyte [ ] storedStartBytes = null ; ttry { tstoredStartBytes = dataDecrypted . readBytes ( 32 ) ; tif ( storedStartBytes = = null | | storedStartBytes . length ! = 32 ) { tthrow new InvalidPasswordException ( ) ; } } catch ( IOException e ) { tthrow new InvalidPasswordException ( ) ; } tif ( ! Arrays . equals ( storedStartBytes , header . streamStartBytes ) ) { tthrow new InvalidPasswordException ( ) ; } tisPlain = new HashedBlockInputStream ( dataDecrypted ) ; } telse { 
public static boolean showAndroid11Warning ( Uri fileUri ) { if ( fileUri = = null ) { return false ; } String scheme = fileUri . getScheme ( ) ; if ( scheme = = null ) { return true ; } return scheme . equals ( " file " ) & & showAndroid11WarningOnThisVersion ( ) ; } 
public void deleteFile ( Uri uri , boolean save ) { init ( ) ; String uriName = uri . toString ( ) ; String fileName = uri . getPath ( ) ; for ( int i = 0 ; i < databases . size ( ) ; i + + ) { String entry = databases . get ( i ) ; boolean delete ; delete = ( uriName ! = null & & uriName . equals ( ( entry ) ) | | ( fileName ! = null & & fileName . equals ( entry ) ) ) ; if ( delete ) { databases . remove ( i ) ; keyfiles . remove ( i ) ; break ; } } if ( save ) { savePrefs ( ) ; 
