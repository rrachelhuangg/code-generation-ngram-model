private static boolean stdoutHasNativeAnsiSupport ( ) { tString os = System . getProperty ( " os.name " ) ; tif ( os . startsWith ( " Windows " ) ) { treturn false ; } } 
private static PrintStream createAnsiConsoleOut ( ) { tif ( stdoutHasNativeAnsiSupport ( ) ) { treturn system_out ; } } 
public static boolean systemInstall ( ) { tif ( ! installed & & System . out ! = out ) { ttry { tField field = System . class . getField ( " out " ) ; tfield . setAccessible ( true ) ; tfield . set ( null , out ) ; tinstalled = true ; treturn true ; } catch ( Throwable e ) { } } treturn false ; } 
public static boolean systemUninstall ( ) { tif ( installed ) { ttry { tField field = System . class . getField ( " out " ) ; tfield . setAccessible ( true ) ; tfield . set ( null , system_out ) ; tinstalled = false ; treturn true ; } catch ( Throwable e ) { } } treturn false ; } 
public void write ( int data ) throws IOException { tswitch ( state ) { tcase LOOKING_FOR_FIRST_ESC_CHAR : tif ( data = = FIRST_ESC_CHAR ) { tbuffer [ pos + + ] = ( byte ) data ; tstate = LOOKING_FOR_SECOND_ESC_CHAR ; } else { tout . write ( data ) ; } tbreak ; tcase LOOKING_FOR_SECOND_ESC_CHAR : tbuffer [ pos + + ] = ( byte ) data ; tif ( data = = SECOND_ESC_CHAR ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tbuffer [ pos + + ] = ( byte ) data ; treset ( ) ; } tbreak ; tcase LOOKING_FOR_NEXT_ARG : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' = = data ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { toptions . add ( null ) ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } tbreak ; tcase LOOKING_FOR_INT_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( ! ( '0' < = data & & data < = '9' ) ) { tInteger value = new Integer ( new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } } } tbreak ; tcase LOOKING_FOR_STR_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' ! = data ) { tString value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } } tbreak ; } reset(); 
private void reset ( ) throws IOException { tif ( pos > 0 ) { tout . write ( buffer , 0 , pos ) ; } tpos = 0 ; tstartOfValue = 0 ; toptions . clear ( ) ; tstate = LOOKING_FOR_FIRST_ESC_CHAR ; } 
tprotected void processRestoreCursorPosition ( ) { } tprotected void processSaveCursorPosition ( ) { } tprotected void processScrollDown ( int optionInt ) { } tprotected void processScrollUp ( int optionInt ) { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 2 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processSaveCursorPosition ( ) { } tprotected void processScrollDown ( int optionInt ) { } tprotected void processScrollUp ( int optionInt ) { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 2 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processScrollDown ( int optionInt ) { } tprotected void processScrollUp ( int optionInt ) { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 2 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processScrollUp ( int optionInt ) { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 2 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processSetAttribute ( int attribute ) throws IOException { } tprotected static final int BLACK = 0 ; tprotected static final int RED = 1 ; tprotected static final int GREEN = 2 ; tprotected static final int YELLOW = 3 ; tprotected static final int BLUE = 4 ; tprotected static final int MAGENTA = 5 ; tprotected static final int CYAN = 6 ; tprotected static final int WHITE = 7 ; tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { } tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { } tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { } tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { } tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { } tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { } tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { } tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processCursorDownLine ( int count ) throws IOException { } tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processCursorRight ( int count ) throws IOException { } tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } } 
private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } 
private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } 
tint SetConsoleTextAttribute ( Pointer consoleOutput , short attributes ) ; public static class COORD extends Structure { tstatic public class ByValue extends COORD implements Structure . ByValue { } tstatic public class ByReference extends COORD implements Structure . ByReference { } public short x ; public short y ; public ByValue copy ( ) { tByValue copy = new ByValue ( ) ; tcopy . x = x ; tcopy . y = y ; treturn copy ; } } int SetConsoleCursorPosition(Pointer consoleOutput, COORD.ByValue cursorPosition);} 
public ByValue copy ( ) { tByValue copy = new ByValue ( ) ; tcopy . x = x ; tcopy . y = y ; treturn copy ; } 
tint CloseHandle ( Pointer handle ) ; public static final int FORMAT_MESSAGE_FROM_SYSTEM = 0x1000 ; int SetConsoleCursorPosition(Pointer consoleOutput, COORD.ByValue cursorPosition);} 
tint FormatMessageW ( int flags , Pointer source , int messageId , tint languageId , Memory buffer , int size , Object . . . arguments ) ; int SetConsoleCursorPosition(Pointer consoleOutput, COORD.ByValue cursorPosition);} 
tint GetConsoleScreenBufferInfo ( Pointer consoleOutput , CONSOLE_SCREEN_BUFFER_INFO . ByReference consoleScreenBufferInfo ) ; tstatic final int STD_INPUT_HANDLE = - 10 ; tstatic final int STD_OUTPUT_HANDLE = - 11 ; tstatic final int STD_ERROR_HANDLE = - 12 ; int SetConsoleCursorPosition(Pointer consoleOutput, COORD.ByValue cursorPosition);} 
tPointer GetStdHandle ( int stdHandle ) ; int SetConsoleCursorPosition(Pointer consoleOutput, COORD.ByValue cursorPosition);} 
tint SetConsoleCursorPosition ( Pointer consoleOutput , COORD . ByValue cursorPosition ) ; } 
private void getConsoleInfo ( ) throws IOException { tout . flush ( ) ; tif ( KERNEL32 . GetConsoleScreenBufferInfo ( console , info ) = = 0 ) { tthrow new IOException ( " Could not get the screen info: " + WindowsSupport . getLastErrorMessage ( ) ) ; } tif ( negative ) { tinfo . attributes = invertAttributeColors ( info . attributes ) ; 
private void applyAttribute ( ) throws IOException { tout . flush ( ) ; tshort attributes = info . attributes ; tif ( negative ) { tattributes = invertAttributeColors ( attributes ) ; } tif ( KERNEL32 . SetConsoleTextAttribute ( console , attributes ) = = 0 ) { tthrow new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
private short invertAttributeColors ( short attibutes ) { } 
private void applyCursorPosition ( ) throws IOException { tif ( KERNEL32 . SetConsoleCursorPosition ( console , info . cursorPosition . copy ( ) ) = = 0 ) { tthrow new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
tprotected void processCursorLeft ( int count ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . x = ( short ) Math . max ( 0 , info . cursorPosition . x - count ) ; tapplyCursorPosition ( ) ; } 
tprotected void processCursorRight ( int count ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . x = ( short ) Math . min ( info . maximumWindowSize . x , info . cursorPosition . x + count ) ; tapplyCursorPosition ( ) ; } 
tprotected void processCursorDown ( int count ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . y = ( short ) Math . min ( info . maximumWindowSize . y , info . cursorPosition . y + count ) ; tapplyCursorPosition ( ) ; } 
tprotected void processCursorUp ( int count ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . y = ( short ) Math . max ( 0 , info . cursorPosition . y - count ) ; tapplyCursorPosition ( ) ; } 
tprotected void processSetForegroundColor ( int color ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x0007 ) | ANSI_FOREGROUND_COLOR_MAP [ color ] ) ; tapplyAttribute ( ) ; } 
tprotected void processSetBackgroundColor ( int color ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x0070 ) | ANSI_BACKGROUND_COLOR_MAP [ color ] ) ; tapplyAttribute ( ) ; } 
tprotected void processAttributeRest ( ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x00FF ) | FOREGROUND_WHITE | BACKGROUND_BLACK ) ; tapplyAttribute ( ) ; } 
tprotected void processSetAttribute ( int attribute ) throws IOException { tswitch ( attribute ) { tcase ATTRIBUTE_INTENSITY_BOLD : 
public static void main ( String [ ] args ) throws IOException { PrintStream out = AnsiConsole . out ; FileInputStream f = new FileInputStream ( " src/test/resources/smi-ar.ans " ) ; int c ; while ( ( c = f . read ( ) ) > = 0 ) { tout . write ( c ) ; } f . close ( ) ; } 
private static PrintStream createAnsiConsoleOut ( ) { tif ( stdoutHasNativeAnsiSupport ( ) ) { treturn system_out ; } } 
tprotected Field getOutField ( ) throws NoSuchFieldException { tField field = System . class . getField ( " out " ) ; tfield . setAccessible ( true ) ; treturn field ; } 
public void install ( ) throws Exception { tgetOutField ( ) . set ( null , out ) ; } 
public void uninstall ( ) throws Exception { tgetOutField ( ) . set ( null , system_out ) ; } 
private static SystemOutInstaller creatInstaller ( ) { } 
public static boolean systemInstall ( ) { tif ( ! installed & & System . out ! = out ) { ttry { tSystemOutInstaller installer = creatInstaller ( ) ; tinstaller . install ( ) ; tinstalled = true ; treturn true ; } catch ( Throwable e ) { } } treturn false ; } 
public static boolean systemUninstall ( ) { tif ( installed ) { ttry { tSystemOutInstaller installer = creatInstaller ( ) ; tinstaller . uninstall ( ) ; tinstalled = false ; treturn true ; } catch ( Throwable e ) { } } treturn false ; } 
tprotected void processRestoreCursorPosition ( ) { } tprotected void processSaveCursorPosition ( ) { } tprotected void processScrollDown ( int optionInt ) { } tprotected void processScrollUp ( int optionInt ) { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 2 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processSaveCursorPosition ( ) { } tprotected void processScrollDown ( int optionInt ) { } tprotected void processScrollUp ( int optionInt ) { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 2 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processScrollDown ( int optionInt ) { } tprotected void processScrollUp ( int optionInt ) { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 2 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processScrollUp ( int optionInt ) { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 2 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processEraseScreen ( int eraseOption ) { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 2 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processEraseLine ( int eraseOption ) { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processSetAttribute ( int attribute ) throws IOException { } tprotected static final int BLACK = 0 ; tprotected static final int RED = 1 ; tprotected static final int GREEN = 2 ; tprotected static final int YELLOW = 3 ; tprotected static final int BLUE = 4 ; tprotected static final int MAGENTA = 5 ; tprotected static final int CYAN = 6 ; tprotected static final int WHITE = 7 ; tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { }} 
tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { }} 
tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { }} 
tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { }} 
tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { }} 
tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { }} 
tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { }} 
tprotected void processCursorDownLine ( int count ) throws IOException { out.write(''); 
tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { }} 
tprotected void processCursorRight ( int count ) throws IOException { out.write(' '); 
private FieldAccessor getOutFieldAccessor ( ) tthrows NoSuchFieldException , IllegalAccessException { tField field = getOutField ( ) ; tField modifiersField = Field . class . getDeclaredField ( " modifiers " ) ; tmodifiersField . setAccessible ( true ) ; tint modifiers = modifiersField . getInt ( field ) ; } 
public void install ( ) throws Exception { tgetOutFieldAccessor ( ) . set ( null , AnsiConsole . out ) ; } 
public void uninstall ( ) throws Exception { tgetOutFieldAccessor ( ) . set ( null , AnsiConsole . system_out ) ; } 
public static void main ( String [ ] args ) throws IOException { tAnsiConsole . systemInstall ( ) ; PrintStream out = System . out ; FileInputStream f = new FileInputStream ( " src/test/resources/smi-ar.ans " ) ; int c ; while ( ( c = f . read ( ) ) > = 0 ) { tout . write ( c ) ; } f . close ( ) ; } 
public static void main ( String [ ] args ) throws IOException { tAnsiConsole . systemInstall ( ) ; PrintStream out = System . out ; FileInputStream f = new FileInputStream ( " src/test/resources/jansi.ans " ) ; int c ; while ( ( c = f . read ( ) ) > = 0 ) { tout . write ( c ) ; } f . close ( ) ; } 
public void write ( int data ) throws IOException { tswitch ( state ) { tcase LOOKING_FOR_FIRST_ESC_CHAR : tif ( data = = FIRST_ESC_CHAR ) { tbuffer [ pos + + ] = ( byte ) data ; tstate = LOOKING_FOR_SECOND_ESC_CHAR ; } else { tout . write ( data ) ; } tbreak ; tcase LOOKING_FOR_SECOND_ESC_CHAR : tbuffer [ pos + + ] = ( byte ) data ; tif ( data = = SECOND_ESC_CHAR ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tbuffer [ pos + + ] = ( byte ) data ; treset ( ) ; } tbreak ; tcase LOOKING_FOR_NEXT_ARG : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' = = data ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { toptions . add ( null ) ; } else if ( '?' = = data ) { toptions . add ( new Character ( '?' ) ) ; } else if ( '=' = = data ) { toptions . add ( new Character ( '=' ) ) ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } tbreak ; tcase LOOKING_FOR_INT_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( ! ( '0' < = data & & data < = '9' ) ) { tInteger value = new Integer ( new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } } } tbreak ; tcase LOOKING_FOR_STR_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' ! = data ) { tString value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } } tbreak ; } reset(); 
public void install ( ) throws Exception { tgetOutFieldAccessor ( ) . set ( null , new_out ) ; } 
public void uninstall ( ) throws Exception { tgetOutFieldAccessor ( ) . set ( null , old_out ) ; } 
public void install ( ) throws Exception { tgetOutField ( ) . set ( null , new_out ) ; } 
public void uninstall ( ) throws Exception { tgetOutField ( ) . set ( null , old_out ) ; } 
public void dump ( StringBuilder builder ) { tprevious . dump ( builder ) ; tbuilder . append ( data ) ; } 
tstatic void dumpEscapeSequence ( StringBuilder builder , char command , Object . . . options ) { tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tint size = options . length ; tfor ( int i = 0 ; i < size ; i + + ) { tif ( i ! = 0 ) { tbuilder . append ( ';' ) ; } tbuilder . append ( options [ i ] ) ; } tbuilder . append ( command ) ; } 
public void dump ( StringBuilder builder ) { tprevious . dump ( builder ) ; tdumpEscapeSequence ( builder , 'm' , options . toArray ( ) ) ; } 
public Ansi cursor ( final int x , final int y ) { treturn new SimpleAnsi ( this ) { @Override 
public void dump ( StringBuilder builder ) { tprevious . dump ( builder ) ; tdumpEscapeSequence ( builder , 'H' , x , y ) ; } 
public Ansi cursorUp ( final int y ) { treturn new SimpleAnsi ( this ) { @Override 
public void dump ( StringBuilder builder ) { tprevious . dump ( builder ) ; tdumpEscapeSequence ( builder , 'A' , y ) ; } 
public Ansi cursorDown ( final int y ) { treturn new SimpleAnsi ( this ) { @Override 
public void dump ( StringBuilder builder ) { tprevious . dump ( builder ) ; tdumpEscapeSequence ( builder , 'B' , y ) ; } 
public Ansi cursorRight ( final int x ) { treturn new SimpleAnsi ( this ) { @Override 
public void dump ( StringBuilder builder ) { tprevious . dump ( builder ) ; tdumpEscapeSequence ( builder , 'C' , x ) ; } 
public Ansi cursorLeft ( final int x ) { treturn new SimpleAnsi ( this ) { @Override 
public void dump ( StringBuilder builder ) { tprevious . dump ( builder ) ; tdumpEscapeSequence ( builder , 'D' , x ) ; } 
public Ansi fg ( Color color ) { tAttributeAnsi rc = ( AttributeAnsi ) ( isAttributeAnsi ( ) ? this : new AttributeAnsi ( this ) ) ; trc . options . add ( color . fg ( ) ) ; treturn rc ; } 
public Ansi bg ( Color color ) { tAttributeAnsi rc = ( AttributeAnsi ) ( isAttributeAnsi ( ) ? this : new AttributeAnsi ( this ) ) ; trc . options . add ( color . bg ( ) ) ; treturn rc ; } 
public Ansi a ( Attribute attribute ) { tAttributeAnsi rc = ( AttributeAnsi ) ( isAttributeAnsi ( ) ? this : new AttributeAnsi ( this ) ) ; trc . options . add ( attribute . value ( ) ) ; treturn rc ; } 
public Ansi a ( String value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( boolean value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( char value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( char [ ] value , int offset , int len ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value , offset , len ) ; treturn rc ; } 
public Ansi a ( char [ ] value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( CharSequence value , int start , int end ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value , start , end ) ; treturn rc ; } 
public Ansi a ( CharSequence value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( double value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( float value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( int value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( long value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( Object value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public Ansi a ( StringBuffer value ) { tStringBuilderAnsi rc = ( StringBuilderAnsi ) ( isStringBuilderAnsi ( ) ? this : new StringBuilderAnsi ( this ) ) ; trc . data . append ( value ) ; treturn rc ; } 
public void dump ( StringBuilder builder ) { } @Override public String toString ( ) { tStringBuilder sb = new StringBuilder ( ) ; tdump ( sb ) ; treturn sb . toString ( ) ; } public Ansi ( ) { } public static Ansi ansi ( ) { treturn ansi ( ) ; } } 
public String toString ( ) { tStringBuilder sb = new StringBuilder ( ) ; tdump ( sb ) ; treturn sb . toString ( ) ; } 
public void testAnsi ( ) { tString expected = " Hello World: " + ESC + " 34;40m125 " ; tString actual = ansi ( ) . a ( " Hello " ) . a ( " World: " ) . fg ( BLUE ) . bg ( BLACK ) . a ( 125L ) . toString ( ) ; tassertEquals ( expected , actual ) ; } 
public void dump ( StringBuilder builder ) { } @Override public String toString ( ) { tStringBuilder sb = new StringBuilder ( ) ; tdump ( sb ) ; treturn sb . toString ( ) ; } public Ansi ( ) { } public static Ansi ansi ( ) { treturn new Ansi ( ) ; } } 
private static boolean stdoutHasNativeAnsiSupport ( ) { tString os = System . getProperty ( " os.name " ) ; tif ( os . startsWith ( " Windows " ) ) { treturn false ; } treturn CLIBRARY . isatty ( CLibrary . STDOUT_FILENO ) ! = 0 ; } 
private static PrintStream createAnsiConsoleOut ( ) { tif ( stdoutHasNativeAnsiSupport ( ) ) { treturn system_out ; } ttry { treturn new PrintStream ( new WindowsAnsiOutputStream ( system_out ) ) ; } catch ( NoClassDefFoundError ignore ) { } 
tsynchronized static public void systemInstall ( ) { tinstalled + + ; tif ( installed = = 1 ) { tSystem . setOut ( out ) ; 
tsynchronized public static void systemUninstall ( ) { tinstalled - - ; tif ( installed = = 0 ) { tSystem . setOut ( out ) ; 
tprotected void processCursorTo ( int x , int y ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . y = ( short ) Math . max ( 0 , Math . min ( info . maximumWindowSize . y , y - 1 ) ) ; tinfo . cursorPosition . x = ( short ) Math . max ( 0 , Math . min ( info . maximumWindowSize . x , x - 1 ) ) ; tapplyCursorPosition ( ) ; } 
tprotected void processEraseScreen ( int eraseOption ) { }} 
public static OutputStream wrapOutputStream ( OutputStream system_out ) { tString os = System . getProperty ( " os.name " ) ; tif ( os . startsWith ( " Windows " ) ) { } 
public void dump ( StringBuilder builder ) { tprevious . dump ( builder ) ; builder.append(FIRST_ESC_CHAR); 
public static Ansi ansi ( StringBuilder builder ) { treturn new Ansi ( builder ) ; } 
public Ansi fg ( Color color ) { tattributeOptions . add ( color . fg ( ) ) ; treturn this ; } 
public Ansi bg ( Color color ) { tattributeOptions . add ( color . bg ( ) ) ; treturn this ; } 
public Ansi a ( Attribute attribute ) { tattributeOptions . add ( attribute . value ( ) ) ; treturn this ; } 
public Ansi cursor ( final int x , final int y ) { treturn appendEscapeSequence ( 'H' , x , y ) ; } 
public Ansi cursorUp ( final int y ) { treturn appendEscapeSequence ( 'A' , y ) ; } 
public Ansi cursorDown ( final int y ) { treturn appendEscapeSequence ( 'B' , y ) ; } 
public Ansi cursorRight ( final int x ) { treturn appendEscapeSequence ( 'C' , x ) ; } 
public Ansi cursorLeft ( final int x ) { treturn appendEscapeSequence ( 'D' , x ) ; } 
public Ansi eraseScreen ( final Erase kind ) { treturn appendEscapeSequence ( 'J' , kind . value ( ) ) ; } 
public Ansi eraseLine ( final Erase kind ) { treturn appendEscapeSequence ( 'K' , kind . value ( ) ) ; } 
public Ansi scrollUp ( final int rows ) { treturn appendEscapeSequence ( 'S' , rows ) ; } 
public Ansi scrollDown ( final int rows ) { treturn appendEscapeSequence ( 'T' , rows ) ; } 
public Ansi saveCursorPosition ( ) { treturn appendEscapeSequence ( 's' ) ; } 
public Ansi restorCursorPosition ( ) { treturn appendEscapeSequence ( 'u' ) ; } 
public Ansi a ( String value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( boolean value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( char value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( char [ ] value , int offset , int len ) { tfushAtttributes ( ) ; tbuilder . append ( value , offset , len ) ; treturn this ; } 
public Ansi a ( char [ ] value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( CharSequence value , int start , int end ) { tfushAtttributes ( ) ; tbuilder . append ( value , start , end ) ; treturn this ; } 
public Ansi a ( CharSequence value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( double value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( float value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( int value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( long value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( Object value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( StringBuffer value ) { tfushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public String toString ( ) { tfushAtttributes ( ) ; treturn builder . toString ( ) ; } 
private Ansi appendEscapeSequence ( char command ) { tfushAtttributes ( ) ; tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( command ) ; treturn this ; } 
private Ansi appendEscapeSequence ( char command , int option ) { tfushAtttributes ( ) ; tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( option ) ; tbuilder . append ( command ) ; treturn this ; } 
private Ansi appendEscapeSequence ( char command , Object . . . options ) { tfushAtttributes ( ) ; treturn _appendEscapeSequence ( command , options ) ; } 
private void fushAtttributes ( ) { tif ( attributeOptions . isEmpty ( ) ) treturn ; tif ( attributeOptions . size ( ) = = 1 & & attributeOptions . get ( 0 ) = = 0 ) { tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( 'm' ) ; } else { t_appendEscapeSequence ( 'm' , attributeOptions . toArray ( ) ) ; } tattributeOptions . clear ( ) ; } 
private Ansi _appendEscapeSequence ( char command , Object . . . options ) { tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tint size = options . length ; tfor ( int i = 0 ; i < size ; i + + ) { tif ( i ! = 0 ) { tbuilder . append ( ';' ) ; } tif ( options [ i ] ! = null ) { tbuilder . append ( options [ i ] ) ; } } tbuilder . append ( command ) ; treturn this ; } 
tprotected void processRestoreCursorPosition ( ) throws IOException { } tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; }} 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { tgetConsoleInfo ( ) ; tswitch ( eraseOption ) { tcase ERASE_SCREEN : 
tint SetConsoleTextAttribute ( Pointer consoleOutput , short attributes ) ; public static class COORD extends Structure { tstatic public class ByValue extends COORD implements Structure . ByValue { } tstatic public class ByReference extends COORD implements Structure . ByReference { } public short x ; public short y ; public ByValue copy ( ) { tByValue copy = new ByValue ( ) ; tcopy . x = x ; tcopy . y = y ; treturn copy ; } } int FillConsoleOutputCharacter(Pointer consoleOutput, int character, int length, COORD.ByValue dwWriteCoord, IntByReference numberOfCharsWritten);} 
tint CloseHandle ( Pointer handle ) ; public static final int FORMAT_MESSAGE_FROM_SYSTEM = 0x1000 ; int FillConsoleOutputCharacter(Pointer consoleOutput, int character, int length, COORD.ByValue dwWriteCoord, IntByReference numberOfCharsWritten);} 
tint FormatMessageW ( int flags , Pointer source , int messageId , tint languageId , Memory buffer , int size , Object . . . arguments ) ; int FillConsoleOutputCharacter(Pointer consoleOutput, int character, int length, COORD.ByValue dwWriteCoord, IntByReference numberOfCharsWritten);} 
tint GetConsoleScreenBufferInfo ( Pointer consoleOutput , CONSOLE_SCREEN_BUFFER_INFO . ByReference consoleScreenBufferInfo ) ; tstatic final int STD_INPUT_HANDLE = - 10 ; tstatic final int STD_OUTPUT_HANDLE = - 11 ; tstatic final int STD_ERROR_HANDLE = - 12 ; int FillConsoleOutputCharacter(Pointer consoleOutput, int character, int length, COORD.ByValue dwWriteCoord, IntByReference numberOfCharsWritten);} 
tPointer GetStdHandle ( int stdHandle ) ; int FillConsoleOutputCharacter(Pointer consoleOutput, int character, int length, COORD.ByValue dwWriteCoord, IntByReference numberOfCharsWritten);} 
tint SetConsoleCursorPosition ( Pointer consoleOutput , COORD . ByValue cursorPosition ) ; tint FillConsoleOutputCharacter ( Pointer consoleOutput , int character , int length , COORD . ByValue dwWriteCoord , IntByReference numberOfCharsWritten ) ; } 
tint FillConsoleOutputCharacter ( Pointer consoleOutput , int character , int length , COORD . ByValue dwWriteCoord , IntByReference numberOfCharsWritten ) ; } 
public Ansi eraseScreen ( ) { treturn appendEscapeSequence ( 'J' , Erase . ALL . value ( ) ) ; } 
tint SetConsoleTextAttribute ( Pointer consoleOutput , short attributes ) ; public static class COORD extends Structure { tstatic public class ByValue extends COORD implements Structure . ByValue { } tstatic public class ByReference extends COORD implements Structure . ByReference { } public short x ; public short y ; public ByValue copy ( ) { tByValue copy = new ByValue ( ) ; tcopy . x = x ; tcopy . y = y ; treturn copy ; } } int FillConsoleOutputCharacterW(Pointer consoleOutput, char character, int length, COORD.ByValue writeCoord, IntByReference numberOfCharsWritten);} 
tint CloseHandle ( Pointer handle ) ; public static final int FORMAT_MESSAGE_FROM_SYSTEM = 0x1000 ; int FillConsoleOutputCharacterW(Pointer consoleOutput, char character, int length, COORD.ByValue writeCoord, IntByReference numberOfCharsWritten);} 
tint FormatMessageW ( int flags , Pointer source , int messageId , tint languageId , Memory buffer , int size , Object . . . arguments ) ; int FillConsoleOutputCharacterW(Pointer consoleOutput, char character, int length, COORD.ByValue writeCoord, IntByReference numberOfCharsWritten);} 
tint GetConsoleScreenBufferInfo ( Pointer consoleOutput , CONSOLE_SCREEN_BUFFER_INFO . ByReference consoleScreenBufferInfo ) ; tstatic final int STD_INPUT_HANDLE = - 10 ; tstatic final int STD_OUTPUT_HANDLE = - 11 ; tstatic final int STD_ERROR_HANDLE = - 12 ; int FillConsoleOutputCharacterW(Pointer consoleOutput, char character, int length, COORD.ByValue writeCoord, IntByReference numberOfCharsWritten);} 
tPointer GetStdHandle ( int stdHandle ) ; int FillConsoleOutputCharacterW(Pointer consoleOutput, char character, int length, COORD.ByValue writeCoord, IntByReference numberOfCharsWritten);} 
tint SetConsoleCursorPosition ( Pointer consoleOutput , COORD . ByValue cursorPosition ) ; tint FillConsoleOutputCharacterW ( Pointer consoleOutput , char character , int length , COORD . ByValue writeCoord , IntByReference numberOfCharsWritten ) ; } 
tint FillConsoleOutputCharacterW ( Pointer consoleOutput , char character , int length , COORD . ByValue writeCoord , IntByReference numberOfCharsWritten ) ; } 
public void write ( int data ) throws IOException { tswitch ( state ) { tcase LOOKING_FOR_FIRST_ESC_CHAR : tif ( data = = FIRST_ESC_CHAR ) { tbuffer [ pos + + ] = ( byte ) data ; tstate = LOOKING_FOR_SECOND_ESC_CHAR ; } else { tout . write ( data ) ; } tbreak ; tcase LOOKING_FOR_SECOND_ESC_CHAR : tbuffer [ pos + + ] = ( byte ) data ; tif ( data = = SECOND_ESC_CHAR ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tbuffer [ pos + + ] = ( byte ) data ; treset ( ) ; } tbreak ; tcase LOOKING_FOR_NEXT_ARG : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' = = data ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { toptions . add ( null ) ; } else if ( '?' = = data ) { toptions . add ( new Character ( '?' ) ) ; } else if ( '=' = = data ) { toptions . add ( new Character ( '=' ) ) ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } tbreak ; tcase LOOKING_FOR_INT_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( ! ( '0' < = data & & data < = '9' ) ) { tString strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; tInteger value = new Integer ( strValue ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } } tbreak ; tcase LOOKING_FOR_STR_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' ! = data ) { tString value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { tif ( processEscapeCommand ( options , data ) ) { tpos = 0 ; } treset ( ) ; } } tbreak ; } reset(); 
tprotected void processCursorRight ( int count ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . x = ( short ) Math . min ( info . window . width ( ) , info . cursorPosition . x + count ) ; tapplyCursorPosition ( ) ; } 
tprotected void processCursorDown ( int count ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . y = ( short ) Math . min ( info . size . y , info . cursorPosition . y + count ) ; tapplyCursorPosition ( ) ; } 
tprotected void processCursorUp ( int count ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . y = ( short ) Math . max ( info . window . top , info . cursorPosition . y - count ) ; tapplyCursorPosition ( ) ; } 
tprotected void processCursorTo ( int x , int y ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . y = ( short ) Math . max ( info . window . top , Math . min ( info . size . y , info . window . top + y - 1 ) ) ; tinfo . cursorPosition . x = ( short ) Math . max ( 0 , Math . min ( info . window . width ( ) , x - 1 ) ) ; tapplyCursorPosition ( ) ; } 
tint SetConsoleTextAttribute ( Pointer consoleOutput , short attributes ) ; public static class COORD extends Structure { tstatic public class ByValue extends COORD implements Structure . ByValue { } tstatic public class ByReference extends COORD implements Structure . ByReference { } public short x ; public short y ; public ByValue copy ( ) { tByValue copy = new ByValue ( ) ; tcopy . x = x ; tcopy . y = y ; treturn copy ; } } int FillConsoleOutputCharacterW(Pointer consoleOutput, char character, int length, COORD.ByValue writeCoord, IntByReference numberOfCharsWritten);} 
public void close ( ) throws IOException { out . flush ( ) ; tinfo . attributes = originalColors ; tthis . negative = false ; tapplyAttribute ( ) ; tsuper . close ( ) ; } 
tprotected void processAttributeRest ( ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x00FF ) | originalColors ) ; applyAttribute ( ) ; } 
public static OutputStream wrapOutputStream ( final OutputStream stream ) { tString os = System . getProperty ( " os.name " ) ; tif ( os . startsWith ( " Windows " ) ) { } 
tsynchronized public static void systemUninstall ( ) { tinstalled - - ; tif ( installed = = 0 ) { tSystem . setOut ( system_out ) ; 
public Ansi format ( String pattern , Object . . . args ) { fushAtttributes ( ) ; builder . append ( String . format ( pattern , args ) ) ; return this ; } 
private static boolean detect ( ) { return ! Boolean . getBoolean ( DISABLE ) ; } 
protected Boolean initialValue ( ) { return detect ( ) ; } 
public static boolean isEnabled ( ) { return holder . get ( ) ; } 
public static Ansi ansi ( ) { if ( isEnabled ( ) ) { return new Ansi ( ) ; 
public Ansi fg ( Color color ) { return this ; } 
public Ansi bg ( Color color ) { return this ; } 
public Ansi a ( Attribute attribute ) { return this ; } 
public Ansi cursor ( int x , int y ) { return this ; } 
public Ansi cursorUp ( int y ) { return this ; } 
public Ansi cursorRight ( int x ) { return this ; } 
public Ansi cursorDown ( int y ) { return this ; } 
public Ansi cursorLeft ( int x ) { return this ; } 
public Ansi eraseScreen ( Erase kind ) { return this ; } 
public Ansi eraseLine ( Erase kind ) { return this ; } 
public Ansi scrollUp ( int rows ) { return this ; } 
public Ansi scrollDown ( int rows ) { return this ; } 
public Ansi saveCursorPosition ( ) { return this ; } 
public Ansi restorCursorPosition ( ) { return this ; } 
public void write ( final String s ) { if ( AnsiRenderer . test ( s ) ) { super . write ( renderer . render ( s ) ) ; 
public PrintWriter format ( final String format , final Object . . . args ) { print ( String . format ( format , args ) ) ; return this ; } 
public PrintWriter format ( final Locale l , final String format , final Object . . . args ) { print ( String . format ( l , format , args ) ) ; return this ; } 
public String render ( final String input ) throws IllegalArgumentException { StringBuffer buff = new StringBuffer ( ) ; int i = 0 ; int j , k ; while ( true ) { j = input . indexOf ( BEGIN_TOKEN , i ) ; 
private String render ( final String text , final String . . . codes ) { org . fusesource . jansi . Ansi ansi = Ansi . ansi ( ) ; for ( String name : codes ) { Code code = Code . valueOf ( name . toUpperCase ( ) ) ; if ( code . isColor ( ) ) { if ( code . isBackground ( ) ) { ansi = ansi . bg ( code . getColor ( ) ) ; } else { ansi = ansi . fg ( code . getColor ( ) ) ; } } else if ( code . isAttribute ( ) ) { ansi = ansi . a ( code . getAttribute ( ) ) ; } } return ansi . a ( text ) . reset ( ) . toString ( ) ; } 
public static boolean test ( final String text ) { return text ! = null & & text . contains ( BEGIN_TOKEN ) ; } 
public boolean isColor ( ) { return instanceof Ansi . Color ; } 
public boolean isAttribute ( ) { return instanceof Attribute ; } 
public boolean isBackground ( ) { return background ; } 
private CharSequence chew ( final CharSequence str ) { assert str ! = null ; ByteArrayOutputStream buff = new ByteArrayOutputStream ( ) ; AnsiOutputStream out = new AnsiOutputStream ( buff ) ; try { out . write ( str . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return new String ( buff . toByteArray ( ) ) ; } 
public char charAt ( final int index ) { return getEncoded ( ) . charAt ( index ) ; } 
public CharSequence subSequence ( final int start , final int end ) { return getEncoded ( ) . subSequence ( start , end ) ; } 
public boolean equals ( final Object obj ) { return getEncoded ( ) . equals ( obj ) ; } 
public int hashCode ( ) { return getEncoded ( ) . hashCode ( ) ; } 
public String toString ( ) { return getEncoded ( ) . toString ( ) ; } 
public void tearDown ( ) { out = null ; baos = null ; } 
public void testRenderNothing ( ) { out . print ( " foo " ) ; out . flush ( ) ; String result = new String ( baos . toByteArray ( ) ) ; assertEquals ( " foo " , result ) ; } 
public void testTest ( ) throws Exception { assertFalse ( AnsiRenderer . test ( " foo " ) ) ; assertTrue ( AnsiRenderer . test ( " @|foo| " ) ) ; assertTrue ( AnsiRenderer . test ( " @|foo " ) ) ; } 
public void testRender ( ) { String str = renderer . render ( " @|bold foo|@ " ) ; System . out . println ( str ) ; assertEquals ( Ansi . ansi ( ) . a ( Ansi . Attribute . INTENSITY_BOLD ) . a ( " foo " ) . reset ( ) . toString ( ) , str ) ; } 
public void testRender2 ( ) { String str = renderer . render ( " @|bold,red foo|@ " ) ; System . out . println ( str ) ; assertEquals ( Ansi . ansi ( ) . a ( Ansi . Attribute . INTENSITY_BOLD ) . fg ( Ansi . Color . RED ) . a ( " foo " ) . reset ( ) . toString ( ) , str ) ; } 
public void testRender3 ( ) { String str = renderer . render ( " @|bold,red foo bar baz|@ " ) ; System . out . println ( str ) ; assertEquals ( Ansi . ansi ( ) . a ( Ansi . Attribute . INTENSITY_BOLD ) . fg ( Ansi . Color . RED ) . a ( " foo bar baz " ) . reset ( ) . toString ( ) , str ) ; } 
public void testRender4 ( ) { String str = renderer . render ( " @|bold,red foo bar baz|@ ick @|bold,red foo bar baz|@ " ) ; System . out . println ( str ) ; assertEquals ( Ansi . ansi ( ) . a ( Ansi . Attribute . INTENSITY_BOLD ) . fg ( Ansi . Color . RED ) . a ( " foo bar baz " ) . reset ( ) 
public void testRenderNothing ( ) { assertEquals ( " foo " , renderer . render ( " foo " ) ) ; } 
public void testRenderInvalidMissingEnd ( ) { String str = renderer . render ( " @|bold foo " ) ; assertEquals ( " @|bold foo " , str ) ; } 
public void testRenderInvalidMissingText ( ) { String str = renderer . render ( " @|bold|@ " ) ; assertEquals ( " @|bold|@ " , str ) ; } 
public void testNotEncoded ( ) throws Exception { AnsiString as = new AnsiString ( " foo " ) ; assertEquals ( " foo " , as . getEncoded ( ) ) ; assertEquals ( " foo " , as . getPlain ( ) ) ; assertEquals ( 3 , as . length ( ) ) ; } 
public void testEncoded ( ) throws Exception { AnsiString as = new AnsiString ( Ansi . ansi ( ) . a ( Ansi . Attribute . INTENSITY_BOLD ) . a ( " foo " ) . reset ( ) . toString ( ) ) ; assertEquals ( " foo " , as . getPlain ( ) ) ; assertEquals ( 3 , as . length ( ) ) ; } 
public void testSetEnabled ( ) throws Exception { Ansi . setEnabled ( false ) ; new Thread ( ) { @Override public void run ( ) { assertEquals ( false , Ansi . isEnabled ( ) ) ; } } . run ( ) ; Ansi . setEnabled ( true ) ; new Thread ( ) { 
public void run ( ) { assertEquals ( false , Ansi . isEnabled ( ) ) ; } 
public void run ( ) { assertEquals ( true , Ansi . isEnabled ( ) ) ; } 
public Boolean call ( ) throws Exception { return ! Boolean . getBoolean ( DISABLE ) ; } 
public static boolean isDetected ( ) { try { return detector . call ( ) ; 
protected Boolean initialValue ( ) { return isDetected ( ) ; } 
public Ansi a ( String value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( boolean value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( char value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( char [ ] value , int offset , int len ) { tflushAtttributes ( ) ; tbuilder . append ( value , offset , len ) ; treturn this ; } 
public Ansi a ( char [ ] value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( CharSequence value , int start , int end ) { tflushAtttributes ( ) ; tbuilder . append ( value , start , end ) ; treturn this ; } 
public Ansi a ( CharSequence value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( double value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( float value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( int value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( long value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( Object value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( StringBuffer value ) { tflushAtttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi format ( String pattern , Object . . . args ) { flushAtttributes ( ) ; builder . append ( String . format ( pattern , args ) ) ; return this ; } 
public Ansi render ( final String text ) { a ( AnsiRenderer . render ( text ) ) ; return this ; } 
public Ansi render ( final String text , Object . . . args ) { a ( String . format ( AnsiRenderer . render ( text ) , args ) ) ; return this ; } 
public String toString ( ) { tflushAtttributes ( ) ; treturn builder . toString ( ) ; } 
private Ansi appendEscapeSequence ( char command ) { tflushAtttributes ( ) ; tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( command ) ; treturn this ; } 
private Ansi appendEscapeSequence ( char command , int option ) { tflushAtttributes ( ) ; tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( option ) ; tbuilder . append ( command ) ; treturn this ; } 
private Ansi appendEscapeSequence ( char command , Object . . . options ) { tflushAtttributes ( ) ; treturn _appendEscapeSequence ( command , options ) ; } 
private void flushAtttributes ( ) { tif ( attributeOptions . isEmpty ( ) ) treturn ; tif ( attributeOptions . size ( ) = = 1 & & attributeOptions . get ( 0 ) = = 0 ) { tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( 'm' ) ; } else { t_appendEscapeSequence ( 'm' , attributeOptions . toArray ( ) ) ; } tattributeOptions . clear ( ) ; } 
public void write ( final String s ) { if ( test ( s ) ) { super . write ( render ( s ) ) ; 
static public String render ( final String input ) throws IllegalArgumentException { StringBuffer buff = new StringBuffer ( ) ; int i = 0 ; int j , k ; while ( true ) { j = input . indexOf ( BEGIN_TOKEN , i ) ; 
static private String render ( final String text , final String . . . codes ) { Ansi ansi = Ansi . ansi ( ) ; for ( String name : codes ) { Code code = Code . valueOf ( name . toUpperCase ( ) ) ; if ( code . isColor ( ) ) { if ( code . isBackground ( ) ) { ansi = ansi . bg ( code . getColor ( ) ) ; } else { ansi = ansi . fg ( code . getColor ( ) ) ; } } else if ( code . isAttribute ( ) ) { ansi = ansi . a ( code . getAttribute ( ) ) ; } } return ansi . a ( text ) . reset ( ) . toString ( ) ; } 
tprotected void processAttributeRest ( ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x00FF ) | originalColors ) ; tapplyAttribute ( ) ; } 
public void testTest ( ) throws Exception { assertFalse ( test ( " foo " ) ) ; assertTrue ( test ( " @|foo| " ) ) ; assertTrue ( test ( " @|foo " ) ) ; } 
public void testRender ( ) { String str = render ( " @|bold foo|@ " ) ; System . out . println ( str ) ; assertEquals ( ansi ( ) . a ( INTENSITY_BOLD ) . a ( " foo " ) . reset ( ) . toString ( ) , str ) ; } 
public void testRender2 ( ) { String str = render ( " @|bold,red foo|@ " ) ; System . out . println ( str ) ; assertEquals ( Ansi . ansi ( ) . a ( INTENSITY_BOLD ) . fg ( RED ) . a ( " foo " ) . reset ( ) . toString ( ) , str ) ; } 
public void testRender3 ( ) { String str = render ( " @|bold,red foo bar baz|@ " ) ; System . out . println ( str ) ; assertEquals ( ansi ( ) . a ( INTENSITY_BOLD ) . fg ( RED ) . a ( " foo bar baz " ) . reset ( ) . toString ( ) , str ) ; } 
public void testRender4 ( ) { String str = render ( " @|bold,red foo bar baz|@ ick @|bold,red foo bar baz|@ " ) ; System . out . println ( str ) ; assertEquals ( ansi ( ) . a ( INTENSITY_BOLD ) . fg ( RED ) . a ( " foo bar baz " ) . reset ( ) 
public void testRender5 ( ) { Check the ansi() render method. String str = ansi().render("@|bold Hello|@").toString(); System.out.println(str); assertEquals(ansi().a(INTENSITY_BOLD).a("Hello").reset().toString(), str); } 
public void testRenderNothing ( ) { assertEquals ( " foo " , render ( " foo " ) ) ; } 
public void testRenderInvalidMissingEnd ( ) { String str = render ( " @|bold foo " ) ; assertEquals ( " @|bold foo " , str ) ; } 
public void testRenderInvalidMissingText ( ) { String str = render ( " @|bold|@ " ) ; assertEquals ( " @|bold|@ " , str ) ; } 
public Ansi newline ( ) { flushAtttributes ( ) ; tbuilder . append ( System . getProperty ( " line.separator " ) ) ; treturn this ; } 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { tgetConsoleInfo ( ) ; tIntByReference written = new IntByReference ( ) ; tswitch ( eraseOption ) { tcase ERASE_SCREEN : 
tprotected void processEraseLine ( int eraseOption ) throws IOException { tgetConsoleInfo ( ) ; tIntByReference written = new IntByReference ( ) ; tswitch ( eraseOption ) { tcase ERASE_LINE : 
tprotected void processCursorToColumn ( int x ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . x = ( short ) Math . max ( 0 , Math . min ( info . window . width ( ) , x - 1 ) ) ; tapplyCursorPosition ( ) ; } 
tprotected void processRestoreCursorPosition ( ) throws IOException { } tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetAttribute ( int attribute ) throws IOException { } tprotected static final int BLACK = 0 ; tprotected static final int RED = 1 ; tprotected static final int GREEN = 2 ; tprotected static final int YELLOW = 3 ; tprotected static final int BLUE = 4 ; tprotected static final int MAGENTA = 5 ; tprotected static final int CYAN = 6 ; tprotected static final int WHITE = 7 ; tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorTo ( int x , int y ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } 
static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; 
tprotected void processAttributeRest ( ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x00FF ) | originalColors ) ; this . negative = false ; tapplyAttribute ( ) ; } 
public static OutputStream wrapOutputStream ( final OutputStream stream ) { tString os = System . getProperty ( " os.name " ) ; tif ( os . startsWith ( " Windows " ) ) { @Override 
 public void close ( ) throws IOException { write ( AnsiOutputStream . REST_CODE ) ; flush ( ) ; super . close ( ) ; } 
public static OutputStream wrapOutputStream ( final OutputStream stream ) { tString os = System . getProperty ( " os.name " ) ; tif ( os . startsWith ( " Windows " ) ) { @Override 
private void getConsoleInfo ( ) throws IOException { tout . flush ( ) ; tif ( GetConsoleScreenBufferInfo ( console , info ) = = 0 ) { tthrow new IOException ( " Could not get the screen info: " + WindowsSupport . getLastErrorMessage ( ) ) ; } tif ( negative ) { tinfo . attributes = invertAttributeColors ( info . attributes ) ; 
private void applyAttribute ( ) throws IOException { tout . flush ( ) ; tshort attributes = info . attributes ; tif ( negative ) { tattributes = invertAttributeColors ( attributes ) ; } tif ( SetConsoleTextAttribute ( console , attributes ) = = 0 ) { tthrow new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
private void applyCursorPosition ( ) throws IOException { tif ( SetConsoleCursorPosition ( console , info . cursorPosition . copy ( ) ) = = 0 ) { tthrow new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { tgetConsoleInfo ( ) ; tint [ ] written = new int [ 1 ] ; tswitch ( eraseOption ) { tcase ERASE_SCREEN : 
tprotected void processEraseLine ( int eraseOption ) throws IOException { tgetConsoleInfo ( ) ; tint [ ] written = new int [ 1 ] ; tswitch ( eraseOption ) { tcase ERASE_LINE : 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } ) public static int STDIN_FILENO ; @JniField ( flags = { CONSTANT } ) public static int STDOUT_FILENO ; @JniField ( flags = { CONSTANT } ) public static int STDERR_FILENO ; @JniField ( flags = { CONSTANT } , accessor = " 1 " , conditional = " defined(HAVE_ISATTY) " ) public static boolean HAVE_ISATTY ; @JniMethod ( conditional = " defined(HAVE_ISATTY) " ) public static final native int isatty ( int fd ) ; } 
public static final native long malloc ( @JniArg ( cast = " size_t " ) long size ) ; public static final native void free ( @JniArg ( cast = " void * " ) long ptr ) ; public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) byte[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) char[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) short[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) int[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}, pointer=FALSE) long[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) float[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) double[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) byte[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) char[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) short[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) int[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}, pointer=FALSE) long[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) float[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) double[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) byte[] dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) char[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) int[] dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) byte[] src, @JniArg(cast="size_t") long size); @JniMethod(cast="void *") public static final native long memset ( @JniArg(cast="void *") long buffer, int c, @JniArg(cast="size_t") long num); public static final native int strlen( @JniArg(cast="char *")long s); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) foo src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) foo dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native int FillConsoleOutputCharacterW( @JniArg(cast="HANDLE", pointer=TRUE) long consoleOutput, char character, int length, @JniArg(flags={BY_VALUE}) COORD writeCoord, int[] numberOfCharsWritten); } 
public static final native void free ( @JniArg ( cast = " void * " ) long ptr ) ; public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) byte[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) char[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) short[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) int[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}, pointer=FALSE) long[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) float[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) double[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) byte[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) char[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) short[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) int[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}, pointer=FALSE) long[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) float[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) double[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) byte[] dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) char[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) int[] dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) byte[] src, @JniArg(cast="size_t") long size); @JniMethod(cast="void *") public static final native long memset ( @JniArg(cast="void *") long buffer, int c, @JniArg(cast="size_t") long num); public static final native int strlen( @JniArg(cast="char *")long s); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) foo src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) foo dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native int FillConsoleOutputCharacterW( @JniArg(cast="HANDLE", pointer=TRUE) long consoleOutput, char character, int length, @JniArg(flags={BY_VALUE}) COORD writeCoord, int[] numberOfCharsWritten); } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(SMALL_RECT) " ) public static int SIZEOF ; @JniField ( accessor = " Left " ) public short left ; @JniField ( accessor = " Top " ) public short top ; @JniField ( accessor = " Right " ) public short right ; @JniField ( accessor = " Bottom " ) public short bottom ; public short width ( ) { return ( short ) ( right - left ) ; } public short height ( ) { return ( short ) ( bottom - top ) ; } } public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public short width ( ) { return ( short ) ( right - left ) ; } 
public short height ( ) { return ( short ) ( bottom - top ) ; } 
public static final native int SetConsoleTextAttribute ( @JniArg ( cast = " HANDLE " ) long consoleOutput , short attributes ) ; @JniClass ( flags = { ClassFlag . STRUCT , TYPEDEF } , conditional = " defined(_WIN32) || defined(_WIN64) " ) public static class COORD { static { LIBRARY . load ( ) ; init ( ) ; } @JniMethod ( flags = { CONSTANT_INITIALIZER } ) private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(COORD) " ) public static int SIZEOF ; @JniField ( accessor = " X " ) public short x ; @JniField ( accessor = " Y " ) public short y ; public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } } public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(COORD) " ) public static int SIZEOF ; @JniField ( accessor = " X " ) public short x ; @JniField ( accessor = " Y " ) public short y ; public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } } public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(CONSOLE_SCREEN_BUFFER_INFO) " ) public static int SIZEOF ; @JniField ( accessor = " dwSize " ) public COORD size = new COORD ( ) ; @JniField ( accessor = " dwCursorPosition " ) public COORD cursorPosition = new COORD ( ) ; @JniField ( accessor = " wAttributes " ) public short attributes ; @JniField ( accessor = " srWindow " ) public SMALL_RECT window = new SMALL_RECT ( ) ; @JniField ( accessor = " dwMaximumWindowSize " ) public COORD maximumWindowSize = new COORD ( ) ; } public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int CloseHandle ( @JniArg ( cast = " HANDLE " ) long handle ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int GetLastError ( ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int FormatMessageW ( int flags , @JniArg ( cast = " void * " ) long source , int messageId , int languageId , @JniArg ( cast = " void * " , flags = { NO_IN , CRITICAL } ) byte [ ] buffer , int size , @JniArg ( cast = " void * " , flags = { NO_IN , CRITICAL , SENTINEL } ) long [ ] args ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int GetConsoleScreenBufferInfo ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , CONSOLE_SCREEN_BUFFER_INFO consoleScreenBufferInfo ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native long GetStdHandle ( int stdHandle ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int SetConsoleCursorPosition ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , @JniArg ( flags = { BY_VALUE } ) COORD cursorPosition ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , pointer = TRUE ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native long malloc ( @JniArg ( cast = " size_t " ) long size ) ; public static final native void free ( @JniArg ( cast = " void * " ) long ptr ) ; public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) byte[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) char[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) short[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) int[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}, pointer=FALSE) long[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) float[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) double[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) byte[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) char[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) short[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) int[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}, pointer=FALSE) long[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) float[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) double[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) byte[] dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) char[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) int[] dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) byte[] src, @JniArg(cast="size_t") long size); @JniMethod(cast="void *") public static final native long memset ( @JniArg(cast="void *") long buffer, int c, @JniArg(cast="size_t") long num); public static final native int strlen( @JniArg(cast="char *")long s); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) foo src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) foo dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native int FillConsoleOutputCharacterW( @JniArg(cast="HANDLE", flags={POINTER_ARG}) long consoleOutput, char character, int length, @JniArg(flags={BY_VALUE}) COORD writeCoord, int[] numberOfCharsWritten); } 
public static final native void free ( @JniArg ( cast = " void * " ) long ptr ) ; public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) byte[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) char[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) short[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) int[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}, pointer=FALSE) long[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) float[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) double[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) byte[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) char[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) short[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) int[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}, pointer=FALSE) long[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) float[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) double[] dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) byte[] dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) char[] src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) int[] dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) byte[] src, @JniArg(cast="size_t") long size); @JniMethod(cast="void *") public static final native long memset ( @JniArg(cast="void *") long buffer, int c, @JniArg(cast="size_t") long num); public static final native int strlen( @JniArg(cast="char *")long s); public static final native void memmove ( @JniArg(cast="void *") long dest, @JniArg(cast="const void *", flags={NO_OUT, CRITICAL}) foo src, @JniArg(cast="size_t") long size); public static final native void memmove ( @JniArg(cast="void *", flags={NO_IN, CRITICAL}) foo dest, @JniArg(cast="const void *") long src, @JniArg(cast="size_t") long size); public static final native int FillConsoleOutputCharacterW( @JniArg(cast="HANDLE", flags={POINTER_ARG}) long consoleOutput, char character, int length, @JniArg(flags={BY_VALUE}) COORD writeCoord, int[] numberOfCharsWritten); } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(SMALL_RECT) " ) public static int SIZEOF ; @JniField ( accessor = " Left " ) public short left ; @JniField ( accessor = " Top " ) public short top ; @JniField ( accessor = " Right " ) public short right ; @JniField ( accessor = " Bottom " ) public short bottom ; public short width ( ) { return ( short ) ( right - left ) ; } public short height ( ) { return ( short ) ( bottom - top ) ; } } public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int SetConsoleTextAttribute ( @JniArg ( cast = " HANDLE " ) long consoleOutput , short attributes ) ; @JniClass ( flags = { ClassFlag . STRUCT , TYPEDEF } , conditional = " defined(_WIN32) || defined(_WIN64) " ) public static class COORD { static { LIBRARY . load ( ) ; init ( ) ; } @JniMethod ( flags = { CONSTANT_INITIALIZER } ) private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(COORD) " ) public static int SIZEOF ; @JniField ( accessor = " X " ) public short x ; @JniField ( accessor = " Y " ) public short y ; public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } } public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(COORD) " ) public static int SIZEOF ; @JniField ( accessor = " X " ) public short x ; @JniField ( accessor = " Y " ) public short y ; public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } } public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(CONSOLE_SCREEN_BUFFER_INFO) " ) public static int SIZEOF ; @JniField ( accessor = " dwSize " ) public COORD size = new COORD ( ) ; @JniField ( accessor = " dwCursorPosition " ) public COORD cursorPosition = new COORD ( ) ; @JniField ( accessor = " wAttributes " ) public short attributes ; @JniField ( accessor = " srWindow " ) public SMALL_RECT window = new SMALL_RECT ( ) ; @JniField ( accessor = " dwMaximumWindowSize " ) public COORD maximumWindowSize = new COORD ( ) ; } public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int CloseHandle ( @JniArg ( cast = " HANDLE " ) long handle ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int GetLastError ( ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int FormatMessageW ( int flags , @JniArg ( cast = " void * " ) long source , int messageId , int languageId , @JniArg ( cast = " void * " , flags = { NO_IN , CRITICAL } ) byte [ ] buffer , int size , @JniArg ( cast = " void * " , flags = { NO_IN , CRITICAL , SENTINEL } ) long [ ] args ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int GetConsoleScreenBufferInfo ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , CONSOLE_SCREEN_BUFFER_INFO consoleScreenBufferInfo ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native long GetStdHandle ( int stdHandle ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int SetConsoleCursorPosition ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , @JniArg ( flags = { BY_VALUE } ) COORD cursorPosition ) ; public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(SMALL_RECT) " ) public static int SIZEOF ; @JniField ( accessor = " Left " ) public short left ; @JniField ( accessor = " Top " ) public short top ; @JniField ( accessor = " Right " ) public short right ; @JniField ( accessor = " Bottom " ) public short bottom ; public short width ( ) { return ( short ) ( right - left ) ; } public short height ( ) { return ( short ) ( bottom - top ) ; } } public static final native int getch ( ) ; } 
public static final native int SetConsoleTextAttribute ( @JniArg ( cast = " HANDLE " ) long consoleOutput , short attributes ) ; @JniClass ( flags = { ClassFlag . STRUCT , TYPEDEF } , conditional = " defined(_WIN32) || defined(_WIN64) " ) public static class COORD { static { LIBRARY . load ( ) ; init ( ) ; } @JniMethod ( flags = { CONSTANT_INITIALIZER } ) private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(COORD) " ) public static int SIZEOF ; @JniField ( accessor = " X " ) public short x ; @JniField ( accessor = " Y " ) public short y ; public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } } public static final native int getch ( ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(COORD) " ) public static int SIZEOF ; @JniField ( accessor = " X " ) public short x ; @JniField ( accessor = " Y " ) public short y ; public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } } public static final native int getch ( ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(CONSOLE_SCREEN_BUFFER_INFO) " ) public static int SIZEOF ; @JniField ( accessor = " dwSize " ) public COORD size = new COORD ( ) ; @JniField ( accessor = " dwCursorPosition " ) public COORD cursorPosition = new COORD ( ) ; @JniField ( accessor = " wAttributes " ) public short attributes ; @JniField ( accessor = " srWindow " ) public SMALL_RECT window = new SMALL_RECT ( ) ; @JniField ( accessor = " dwMaximumWindowSize " ) public COORD maximumWindowSize = new COORD ( ) ; public int windowWidth ( ) { return window . width ( ) + 1 ; } public int windowHeight ( ) { return window . height ( ) + 1 ; } } public static final native int getch ( ) ; } 
public int windowWidth ( ) { return window . width ( ) + 1 ; } 
public int windowHeight ( ) { return window . height ( ) + 1 ; } 
public static final native int CloseHandle ( @JniArg ( cast = " HANDLE " ) long handle ) ; public static final native int getch ( ) ; } 
public static final native int GetLastError ( ) ; public static final native int getch ( ) ; } 
public static final native int FormatMessageW ( int flags , @JniArg ( cast = " void * " ) long source , int messageId , int languageId , @JniArg ( cast = " void * " , flags = { NO_IN , CRITICAL } ) byte [ ] buffer , int size , @JniArg ( cast = " void * " , flags = { NO_IN , CRITICAL , SENTINEL } ) long [ ] args ) ; public static final native int getch ( ) ; } 
public static final native int GetConsoleScreenBufferInfo ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , CONSOLE_SCREEN_BUFFER_INFO consoleScreenBufferInfo ) ; public static final native int getch ( ) ; } 
public static final native long GetStdHandle ( int stdHandle ) ; public static final native int getch ( ) ; } 
public static final native int SetConsoleCursorPosition ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , @JniArg ( flags = { BY_VALUE } ) COORD cursorPosition ) ; public static final native int getch ( ) ; } 
public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; public static final native int getch ( ) ; } 
public static final native int GetConsoleMode ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long handle , int [ ] mode ) ; public static final native int getch ( ) ; } 
public static final native int SetConsoleMode ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long handle , int mode ) ; public static final native int getch ( ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(SMALL_RECT) " ) public static int SIZEOF ; @JniField ( accessor = " Left " ) public short left ; @JniField ( accessor = " Top " ) public short top ; @JniField ( accessor = " Right " ) public short right ; @JniField ( accessor = " Bottom " ) public short bottom ; public short width ( ) { return ( short ) ( right - left ) ; } public short height ( ) { return ( short ) ( bottom - top ) ; } } public static final native int _getch ( ) ; } 
public static final native int SetConsoleTextAttribute ( @JniArg ( cast = " HANDLE " ) long consoleOutput , short attributes ) ; @JniClass ( flags = { ClassFlag . STRUCT , TYPEDEF } , conditional = " defined(_WIN32) || defined(_WIN64) " ) public static class COORD { static { LIBRARY . load ( ) ; init ( ) ; } @JniMethod ( flags = { CONSTANT_INITIALIZER } ) private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(COORD) " ) public static int SIZEOF ; @JniField ( accessor = " X " ) public short x ; @JniField ( accessor = " Y " ) public short y ; public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } } public static final native int _getch ( ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(COORD) " ) public static int SIZEOF ; @JniField ( accessor = " X " ) public short x ; @JniField ( accessor = " Y " ) public short y ; public COORD copy ( ) { tCOORD rc = new COORD ( ) ; trc . x = x ; trc . y = y ; treturn rc ; } } public static final native int _getch ( ) ; } 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , accessor = " sizeof(CONSOLE_SCREEN_BUFFER_INFO) " ) public static int SIZEOF ; @JniField ( accessor = " dwSize " ) public COORD size = new COORD ( ) ; @JniField ( accessor = " dwCursorPosition " ) public COORD cursorPosition = new COORD ( ) ; @JniField ( accessor = " wAttributes " ) public short attributes ; @JniField ( accessor = " srWindow " ) public SMALL_RECT window = new SMALL_RECT ( ) ; @JniField ( accessor = " dwMaximumWindowSize " ) public COORD maximumWindowSize = new COORD ( ) ; public int windowWidth ( ) { return window . width ( ) + 1 ; } public int windowHeight ( ) { return window . height ( ) + 1 ; } } public static final native int _getch ( ) ; } 
public static final native int CloseHandle ( @JniArg ( cast = " HANDLE " ) long handle ) ; public static final native int _getch ( ) ; } 
public static final native int GetLastError ( ) ; public static final native int _getch ( ) ; } 
public static final native int FormatMessageW ( int flags , @JniArg ( cast = " void * " ) long source , int messageId , int languageId , @JniArg ( cast = " void * " , flags = { NO_IN , CRITICAL } ) byte [ ] buffer , int size , @JniArg ( cast = " void * " , flags = { NO_IN , CRITICAL , SENTINEL } ) long [ ] args ) ; public static final native int _getch ( ) ; } 
public static final native int GetConsoleScreenBufferInfo ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , CONSOLE_SCREEN_BUFFER_INFO consoleScreenBufferInfo ) ; public static final native int _getch ( ) ; } 
public static final native long GetStdHandle ( int stdHandle ) ; public static final native int _getch ( ) ; } 
public static final native int SetConsoleCursorPosition ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , @JniArg ( flags = { BY_VALUE } ) COORD cursorPosition ) ; public static final native int _getch ( ) ; } 
public static final native int FillConsoleOutputCharacterW ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long consoleOutput , char character , int length , @JniArg ( flags = { BY_VALUE } ) COORD writeCoord , int [ ] numberOfCharsWritten ) ; public static final native int _getch ( ) ; } 
public static final native int GetConsoleMode ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long handle , int [ ] mode ) ; public static final native int _getch ( ) ; } 
public static final native int SetConsoleMode ( @JniArg ( cast = " HANDLE " , flags = { POINTER_ARG } ) long handle , int mode ) ; public static final native int _getch ( ) ; } 
public static OutputStream wrapOutputStream ( final OutputStream stream ) { tString os = System . getProperty ( " os.name " ) ; tif ( os . startsWith ( " Windows " ) ) { @Override 
private static final native void init ( ) ; @JniField ( flags = { CONSTANT } , conditional = " defined(STDIN_FILENO) " ) public static int STDIN_FILENO ; @JniField ( flags = { CONSTANT } , conditional = " defined(STDIN_FILENO) " ) public static int STDOUT_FILENO ; @JniField ( flags = { CONSTANT } , conditional = " defined(STDIN_FILENO) " ) public static int STDERR_FILENO ; @JniField ( flags = { CONSTANT } , accessor = " 1 " , conditional = " defined(HAVE_ISATTY) " ) public static boolean HAVE_ISATTY ; @JniMethod ( conditional = " defined(HAVE_ISATTY) " ) public static final native int isatty ( int fd ) ; } 
tprotected void processSaveCursorPosition ( ) throws IOException { tgetConsoleInfo ( ) ; tsavedX = info . cursorPosition . x ; tsavedY = info . cursorPosition . y ; } 
tprotected void processRestoreCursorPosition ( ) throws IOException { out.flush(); 
tprotected void processRestoreCursorPosition ( ) throws IOException { } tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetAttribute ( int attribute ) throws IOException { } tprotected static final int BLACK = 0 ; tprotected static final int RED = 1 ; tprotected static final int GREEN = 2 ; tprotected static final int YELLOW = 3 ; tprotected static final int BLUE = 4 ; tprotected static final int MAGENTA = 5 ; tprotected static final int CYAN = 6 ; tprotected static final int WHITE = 7 ; tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorTo ( int row , int col ) throws IOException { tgetConsoleInfo ( ) ; tinfo . cursorPosition . y = ( short ) Math . max ( info . window . top , Math . min ( info . size . y , info . window . top + row - 1 ) ) ; tinfo . cursorPosition . x = ( short ) Math . max ( 0 , Math . min ( info . window . width ( ) , col - 1 ) ) ; tapplyCursorPosition ( ) ; } 
public void write ( int data ) throws IOException { tswitch ( state ) { tcase LOOKING_FOR_FIRST_ESC_CHAR : tif ( data = = FIRST_ESC_CHAR ) { tbuffer [ pos + + ] = ( byte ) data ; tstate = LOOKING_FOR_SECOND_ESC_CHAR ; } else { tout . write ( data ) ; } tbreak ; tcase LOOKING_FOR_SECOND_ESC_CHAR : tbuffer [ pos + + ] = ( byte ) data ; tif ( data = = SECOND_ESC_CHAR ) { tstate = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { tstate = LOOKING_FOR_OSC_COMMAND ; } else { treset ( false ) ; } tbreak ; tcase LOOKING_FOR_NEXT_ARG : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' = = data ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { toptions . add ( null ) ; } else if ( '?' = = data ) { toptions . add ( new Character ( '?' ) ) ; } else if ( '=' = = data ) { toptions . add ( new Character ( '=' ) ) ; } else { treset ( processEscapeCommand ( options , data ) ) ; } tbreak ; tcase LOOKING_FOR_INT_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( ! ( '0' < = data & & data < = '9' ) ) { tString strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; tInteger value = new Integer ( strValue ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { treset ( processEscapeCommand ( options , data ) ) ; } } tbreak ; tcase LOOKING_FOR_STR_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' ! = data ) { tString value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { treset ( processEscapeCommand ( options , data ) ) ; } } tbreak ; tcase LOOKING_FOR_OSC_COMMAND : tbuffer [ pos + + ] = ( byte ) data ; tif ( '0' < = data & & data < = '9' ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_OSC_COMMAND_END ; } else { treset ( false ) ; } tbreak ; tcase LOOKING_FOR_OSC_COMMAND_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( ';' = = data ) { tString strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; tInteger value = new Integer ( strValue ) ; toptions . add ( value ) ; tstartOfValue = pos ; tstate = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { reset(false); 
private void reset ( boolean skipBuffer ) throws IOException { tif ( ! skipBuffer ) { tout . write ( buffer , 0 , pos ) ; } tpos = 0 ; tstartOfValue = 0 ; toptions . clear ( ) ; tstate = LOOKING_FOR_FIRST_ESC_CHAR ; } 
private boolean processOperatingSystemCommand ( ArrayList < Object > options ) throws IOException { tint command = optionInt ( options , 0 ) ; tString label = ( String ) options . get ( 1 ) ; } 
tprotected void processRestoreCursorPosition ( ) throws IOException { } tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetAttribute ( int attribute ) throws IOException { } tprotected static final int BLACK = 0 ; tprotected static final int RED = 1 ; tprotected static final int GREEN = 2 ; tprotected static final int YELLOW = 3 ; tprotected static final int BLUE = 4 ; tprotected static final int MAGENTA = 5 ; tprotected static final int CYAN = 6 ; tprotected static final int WHITE = 7 ; tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorLeft ( int count ) throws IOException { } tprotected void processCursorRight ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processCursorDown ( int count ) throws IOException { } tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } tprotected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } tprotected void processChangeIconName ( String label ) { } tprotected void processChangeWindowTitle ( String label ) { } tprotected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
tprotected void processCursorUp ( int count ) throws IOException { } tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } tprotected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } tprotected void processChangeIconName ( String label ) { } tprotected void processChangeWindowTitle ( String label ) { } tprotected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
tprotected void processUnknownExtension ( ArrayList < Object > options , int command ) { } tprotected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } tprotected void processChangeIconName ( String label ) { } tprotected void processChangeWindowTitle ( String label ) { } tprotected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
tprotected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } 
tprotected void processChangeIconName ( String label ) { } tprotected void processChangeWindowTitle ( String label ) { } tprotected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
tprotected void processChangeWindowTitle ( String label ) { } tprotected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
tprotected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { tif ( options . size ( ) < = index ) tthrow new IllegalArgumentException ( ) ; tObject value = options . get ( index ) ; tif ( value = = null ) tthrow new IllegalArgumentException ( ) ; tif ( ! value . getClass ( ) . equals ( Integer . class ) ) tthrow new IllegalArgumentException ( ) ; treturn ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { tif ( options . size ( ) > index ) { tObject value = options . get ( index ) ; tif ( value = = null ) { treturn defaultValue ; } treturn ( ( Integer ) value ) . intValue ( ) ; } treturn defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
tprotected void processChangeWindowTitle ( String label ) { tSetConsoleTitle ( label ) ; } 
public void testClone ( ) throws CloneNotSupportedException { Ansi ansi = Ansi . ansi ( ) . a ( " Some text " ) . bg ( Color . BLACK ) . fg ( Color . WHITE ) ; Ansi clone = new Ansi ( ansi ) ; assertEquals ( ansi . a ( " test " ) . reset ( ) . toString ( ) , clone . a ( " test " ) . reset ( ) . toString ( ) ) ; } 
public Ansi bold ( ) { return a ( Attribute . INTENSITY_BOLD ) ; } 
public Ansi boldOff ( ) { return a ( Attribute . INTENSITY_BOLD_OFF ) ; } 
tprotected void processRestoreCursorPosition ( ) throws IOException { } tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetAttribute ( int attribute ) throws IOException { } tprotected static final int BLACK = 0 ; tprotected static final int RED = 1 ; tprotected static final int GREEN = 2 ; tprotected static final int YELLOW = 3 ; tprotected static final int BLUE = 4 ; tprotected static final int MAGENTA = 5 ; tprotected static final int CYAN = 6 ; tprotected static final int WHITE = 7 ; tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetForegroundColor ( int color ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetBackgroundColor ( int color ) throws IOException { } tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
public void close ( ) throws IOException { tcloseAttributes ( ) ; tsuper . close ( ) ; } 
private void write ( String s ) throws IOException { tsuper . out . write ( s . getBytes ( ) ) ; } 
private void writeAttribute ( String s ) throws IOException { twrite ( " < " + s + " > " ) ; tclosingAttributes . add ( 0 , s . split ( " " , 2 ) [ 0 ] ) ; } 
private void closeAttributes ( ) throws IOException { tfor ( String attr : closingAttributes ) { twrite ( " </ " + attr + " > " ) ; } tclosingAttributes . clear ( ) ; } 
public void writeLine ( byte [ ] buf , int offset , int len ) throws IOException { twrite ( buf , offset , len ) ; tcloseAttributes ( ) ; } 
tprotected void processSetAttribute ( int attribute ) throws IOException { tswitch ( attribute ) { tcase ATTRIBUTE_CONCEAL_ON : 
tprotected void processAttributeRest ( ) throws IOException { tif ( concealOn ) { twrite ( " u001B[0m " ) ; tconcealOn = false ; } tcloseAttributes ( ) ; } 
tprotected void processSetForegroundColor ( int color ) throws IOException { twriteAttribute ( " span style= \" color: " + ANSI_COLOR_MAP [ color ] + " ; \" " ) ; } 
tprotected void processSetBackgroundColor ( int color ) throws IOException { twriteAttribute ( " span style= \" background-color: " + ANSI_COLOR_MAP [ color ] + " ; \" " ) ; } 
public void testNoMarkup ( ) throws IOException { tassertEquals ( colorize ( " line " ) , " line " ) ; } 
public void testClear ( ) throws IOException { tassertEquals ( colorize ( " [0m[K " ) , " " ) ; tassertEquals ( colorize ( " [0mhello world " ) , " hello world " ) ; } 
public void testBold ( ) throws IOException { tassertEquals ( colorize ( " [1mhello world " ) , " <b>hello world</b> " ) ; } 
public void testGreen ( ) throws IOException { tassertEquals ( colorize ( " [32mhello world " ) , " <span style= \" color: green; \" >hello world</span> " ) ; 
public void testGreenOnWhite ( ) throws IOException { tassertEquals ( colorize ( " [47;32mhello world " ) , " <span style= \" background-color: white; \" ><span style= \" color: green; \" >hello world</span></span> " ) ; 
public void testResetOnOpen ( ) throws IOException { tassertEquals ( colorize ( " [0;31;49mred[0m " ) , " <span style= \" color: red; \" >red</span> " ) ; 
private String colorize ( String text ) throws IOException { thos . write ( text . getBytes ( ) ) ; thos . close ( ) ; treturn os . toString ( ) ; } 
public void tearDown ( ) { hos = null ; os = null ; } 
public void write ( int data ) throws IOException { tswitch ( data ) { tcase 34 : " 
public void testNoMarkup ( ) throws IOException { tassertEquals ( " line " , colorize ( " line " ) ) ; } 
public void testClear ( ) throws IOException { tassertEquals ( " " , colorize ( " [0m[K " ) ) ; tassertEquals ( " hello world " , colorize ( " [0mhello world " ) ) ; } 
public void testBold ( ) throws IOException { tassertEquals ( " <b>hello world</b> " , colorize ( " [1mhello world " ) ) ; } 
public void testGreen ( ) throws IOException { tassertEquals ( " <span style= \" color: green; \" >hello world</span> " , tcolorize ( " [32mhello world " ) ) ; 
public void testGreenOnWhite ( ) throws IOException { tassertEquals ( " <span style= \" background-color: white; \" ><span style= \" color: green; \" >hello world</span></span> " , tcolorize ( " [47;32mhello world " ) ) ; 
public void testEscapeHtml ( ) throws IOException { tassertEquals ( " &quot; " , colorize ( " \" " ) ) ; tassertEquals ( " &amp; " , colorize ( " & " ) ) ; tassertEquals ( " &lt; " , colorize ( " < " ) ) ; tassertEquals ( " &gt; " , colorize ( " > " ) ) ; tassertEquals ( " &quot;&amp;&lt;&gt; " , colorize ( " \" &<> " ) ) ; } 
public void testResetOnOpen ( ) throws IOException { tassertEquals ( " <span style= \" color: red; \" >red</span> " , tcolorize ( " [0;31;49mred[0m " ) ) ; 
public void testUTF8Character ( ) throws IOException { tassertEquals ( " <b> u3053 u3093 u306b u3061 u306f</b> " , tcolorize ( " [1m u3053 u3093 u306b u3061 u306f " ) ) ; 
private String colorize ( String text ) throws IOException { tByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; tHtmlAnsiOutputStream hos = new HtmlAnsiOutputStream ( os ) ; thos . write ( text . getBytes ( ) ) ; thos . close ( ) ; treturn os . toString ( ) ; } 
public Ansi fgBright ( Color color ) { return this ; } 
public Ansi bgBright ( Color color ) { return this ; } 
public Ansi fgBright ( Color color ) { attributeOptions . add ( color . fgBright ( ) ) ; return this ; } 
public Ansi bgBright ( Color color ) { attributeOptions . add ( color . bgBright ( ) ) ; return this ; } 
private String colorize ( String text ) throws IOException { tByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; tHtmlAnsiOutputStream hos = new HtmlAnsiOutputStream ( os ) ; thos . write ( text . getBytes ( " UTF-8 " ) ) ; thos . close ( ) ; treturn new String ( os . toByteArray ( ) , " UTF-8 " ) ; } 
static private String render ( final String text , final String . . . codes ) { Ansi ansi = Ansi . ansi ( ) ; for ( String name : codes ) { Code code = Code . valueOf ( name . toUpperCase ( Locale . ENGLISH ) ) ; if ( code . isColor ( ) ) { if ( code . isBackground ( ) ) { ansi = ansi . bg ( code . getColor ( ) ) ; } else { ansi = ansi . fg ( code . getColor ( ) ) ; } } else if ( code . isAttribute ( ) ) { ansi = ansi . a ( code . getAttribute ( ) ) ; } } return ansi . a ( text ) . reset ( ) . toString ( ) ; } 
public Ansi fg ( Color color ) { attributeOptions . add ( color . fg ( ) ) ; return this ; } 
public Ansi fgBlue ( ) { return this . fg ( Color . BLUE ) ; } 
public Ansi fgCyan ( ) { return this . fg ( Color . CYAN ) ; } 
public Ansi fgDefault ( ) { return this . fg ( Color . DEFAULT ) ; } 
public Ansi fgGreen ( ) { return this . fg ( Color . GREEN ) ; } 
public Ansi fgMagenta ( ) { return this . fg ( Color . MAGENTA ) ; } 
public Ansi fgRed ( ) { return this . fg ( Color . RED ) ; } 
public Ansi fgYellow ( ) { return this . fg ( Color . YELLOW ) ; } 
public Ansi bgCyan ( ) { return this . fg ( Color . CYAN ) ; } 
public Ansi bgDefault ( ) { return this . bg ( Color . DEFAULT ) ; } 
public Ansi bgGreen ( ) { return this . bg ( Color . GREEN ) ; } 
public Ansi bgMagenta ( ) { return this . bg ( Color . MAGENTA ) ; } 
public Ansi bgRed ( ) { return this . bg ( Color . RED ) ; } 
public Ansi bgYellow ( ) { return this . bg ( Color . YELLOW ) ; } 
public Ansi fgBrightBlack ( ) { return this . fgBright ( Color . BLACK ) ; } 
public Ansi fgBrightBlue ( ) { return this . fgBright ( Color . BLUE ) ; } 
public Ansi fgBrightCyan ( ) { return this . fgBright ( Color . CYAN ) ; } 
public Ansi fgBrightDefault ( ) { return this . fgBright ( Color . DEFAULT ) ; } 
public Ansi fgBrightGreen ( ) { return this . fgBright ( Color . GREEN ) ; } 
public Ansi fgBrightMagenta ( ) { return this . fgBright ( Color . MAGENTA ) ; } 
public Ansi fgBrightRed ( ) { return this . fgBright ( Color . RED ) ; } 
public Ansi fgBrightYellow ( ) { return this . fgBright ( Color . YELLOW ) ; } 
public Ansi bgBrightCyan ( ) { return this . fgBright ( Color . CYAN ) ; } 
public Ansi bgBrightDefault ( ) { return this . bgBright ( Color . DEFAULT ) ; } 
public Ansi bgBrightGreen ( ) { return this . bgBright ( Color . GREEN ) ; } 
public Ansi bgBrightMagenta ( ) { return this . bg ( Color . MAGENTA ) ; } 
public Ansi bgBrightRed ( ) { return this . bgBright ( Color . RED ) ; } 
public Ansi bgBrightYellow ( ) { return this . bgBright ( Color . YELLOW ) ; } 
public void testRender ( ) { String str = render ( " @|bold foo|@ " ) ; System . out . println ( str ) ; assertEquals ( ansi ( ) . a ( INTENSITY_BOLD ) . a ( " foo " ) . reset ( ) . toString ( ) , str ) ; assertEquals ( ansi ( ) . bold ( ) . a ( " foo " ) . reset ( ) . toString ( ) , str ) ; } 
public void testRender2 ( ) { String str = render ( " @|bold,red foo|@ " ) ; System . out . println ( str ) ; assertEquals ( Ansi . ansi ( ) . a ( INTENSITY_BOLD ) . fg ( RED ) . a ( " foo " ) . reset ( ) . toString ( ) , str ) ; assertEquals ( Ansi . ansi ( ) . bold ( ) . fgRed ( ) . a ( " foo " ) . reset ( ) . toString ( ) , str ) ; } 
public void testRender3 ( ) { String str = render ( " @|bold,red foo bar baz|@ " ) ; System . out . println ( str ) ; assertEquals ( ansi ( ) . a ( INTENSITY_BOLD ) . fg ( RED ) . a ( " foo bar baz " ) . reset ( ) . toString ( ) , str ) ; assertEquals ( ansi ( ) . bold ( ) . fgRed ( ) . a ( " foo bar baz " ) . reset ( ) . toString ( ) , str ) ; } 
public Ansi cursorToColumn ( int x ) { return this ; } 
public Ansi cursorDownLine ( ) { return this ; } 
public Ansi cursorDownLine ( final int ) { return this ; } 
public Ansi cursorUpLine ( final int ) { return this ; } 
public Ansi cursorToColumn ( final int x ) { return appendEscapeSequence ( 'G' , x ) ; } 
public Ansi cursorDownLine ( ) { return appendEscapeSequence ( 'E' ) ; } 
public Ansi cursorDownLine ( final int ) { return appendEscapeSequence ( 'E' , ) ; } 
public Ansi cursorUpLine ( ) { return appendEscapeSequence ( 'F' ) ; } 
public Ansi cursorUpLine ( final int ) { return appendEscapeSequence ( 'F' , ) ; } 
tprotected void processDefaultTextColor ( ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x000F ) | ( originalColors & 0xF ) ) ; tapplyAttribute ( ) ; } 
tprotected void processDefaultBackgroundColor ( ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x00F0 ) | ( originalColors & 0xF0 ) ) ; tapplyAttribute ( ) ; } 
public Ansi restoreCursorPosition ( ) { return this ; } 
public Ansi restoreCursorPosition ( ) { treturn appendEscapeSequence ( 'u' ) ; } 
public Ansi a ( String value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( boolean value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( char value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( char [ ] value , int offset , int len ) { tflushAttributes ( ) ; tbuilder . append ( value , offset , len ) ; treturn this ; } 
public Ansi a ( char [ ] value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( CharSequence value , int start , int end ) { tflushAttributes ( ) ; tbuilder . append ( value , start , end ) ; treturn this ; } 
public Ansi a ( CharSequence value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( double value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( float value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( int value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( long value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( Object value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi a ( StringBuffer value ) { tflushAttributes ( ) ; tbuilder . append ( value ) ; treturn this ; } 
public Ansi newline ( ) { flushAttributes ( ) ; tbuilder . append ( System . getProperty ( " line.separator " ) ) ; treturn this ; } 
public Ansi format ( String pattern , Object . . . args ) { flushAttributes ( ) ; builder . append ( String . format ( pattern , args ) ) ; return this ; } 
public String toString ( ) { tflushAttributes ( ) ; treturn builder . toString ( ) ; } 
private Ansi appendEscapeSequence ( char command ) { tflushAttributes ( ) ; tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( command ) ; treturn this ; } 
private Ansi appendEscapeSequence ( char command , int option ) { tflushAttributes ( ) ; tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( option ) ; tbuilder . append ( command ) ; treturn this ; } 
private Ansi appendEscapeSequence ( char command , Object . . . options ) { tflushAttributes ( ) ; treturn _appendEscapeSequence ( command , options ) ; } 
private void flushAttributes ( ) { tif ( attributeOptions . isEmpty ( ) ) treturn ; tif ( attributeOptions . size ( ) = = 1 & & attributeOptions . get ( 0 ) = = 0 ) { tbuilder . append ( FIRST_ESC_CHAR ) ; tbuilder . append ( SECOND_ESC_CHAR ) ; tbuilder . append ( 'm' ) ; } else { t_appendEscapeSequence ( 'm' , attributeOptions . toArray ( ) ) ; } tattributeOptions . clear ( ) ; } 
private short invertAttributeColors ( short attributes ) { } 
public static OutputStream wrapOutputStream ( final OutputStream stream ) { treturn wrapOutputStream ( stream , STDOUT_FILENO ) ; } 
tprotected void processRestoreCursorPosition ( ) throws IOException { } tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetAttribute ( int attribute ) throws IOException { } tprotected static final int BLACK = 0 ; tprotected static final int RED = 1 ; tprotected static final int GREEN = 2 ; tprotected static final int YELLOW = 3 ; tprotected static final int BLUE = 4 ; tprotected static final int MAGENTA = 5 ; tprotected static final int CYAN = 6 ; tprotected static final int WHITE = 7 ; tprotected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } tprotected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } tprotected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetForegroundColor ( int color , boolean bright ) throws IOException { twriteAttribute ( " span style= \" color: " + ANSI_COLOR_MAP [ color ] + " ; \" " ) ; } 
tprotected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { twriteAttribute ( " span style= \" background-color: " + ANSI_COLOR_MAP [ color ] + " ; \" " ) ; } 
tprotected void processSetForegroundColor ( int color , boolean bright ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x0007 ) | ANSI_FOREGROUND_COLOR_MAP [ color ] ) ; tapplyAttribute ( ) ; } 
tprotected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { tinfo . attributes = ( short ) ( ( info . attributes & ~ 0x0070 ) | ANSI_BACKGROUND_COLOR_MAP [ color ] ) ; tapplyAttribute ( ) ; } 
tprotected void processRestoreCursorPosition ( ) throws IOException { } tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSaveCursorPosition ( ) throws IOException { } tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollDown ( int optionInt ) throws IOException { } tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processScrollUp ( int optionInt ) throws IOException { } tprotected static final int ERASE_SCREEN_TO_END = 0 ; tprotected static final int ERASE_SCREEN_TO_BEGINING = 1 ; tprotected static final int ERASE_SCREEN = 2 ; tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseScreen ( int eraseOption ) throws IOException { } tprotected static final int ERASE_LINE_TO_END = 0 ; tprotected static final int ERASE_LINE_TO_BEGINING = 1 ; tprotected static final int ERASE_LINE = 2 ; tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processEraseLine ( int eraseOption ) throws IOException { } tprotected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetAttribute ( int attribute ) throws IOException { } tprotected static final int BLACK = 0 ; tprotected static final int RED = 1 ; tprotected static final int GREEN = 2 ; tprotected static final int YELLOW = 3 ; tprotected static final int BLUE = 4 ; tprotected static final int MAGENTA = 5 ; tprotected static final int CYAN = 6 ; tprotected static final int WHITE = 7 ; tprotected void processSetForegroundColor ( int color ) throws IOException { tprocessSetForegroundColor ( color , false ) ; } tprotected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { tprocessSetBackgroundColor ( color , false ) ; } tprotected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetForegroundColor ( int color ) throws IOException { tprocessSetForegroundColor ( color , false ) ; } 
tprotected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } tprotected void processSetBackgroundColor ( int color ) throws IOException { tprocessSetBackgroundColor ( color , false ) ; } tprotected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } tprotected void processDefaultTextColor ( ) throws IOException { } tprotected void processDefaultBackgroundColor ( ) throws IOException { } tprotected void processAttributeRest ( ) throws IOException { } tprotected void processCursorTo ( int row , int col ) throws IOException { } tprotected void processCursorToColumn ( int x ) throws IOException { } tprotected void processCursorUpLine ( int count ) throws IOException { } tprotected void processCursorDownLine ( int count ) throws IOException { static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
tprotected void processSetBackgroundColor ( int color ) throws IOException { tprocessSetBackgroundColor ( color , false ) ; } 
private static boolean isCygwin ( ) { tString term = System . getenv ( " TERM " ) ; treturn term ! = null & & term . equals ( " xterm " ) ; } 
public void write ( int data ) throws IOException { tswitch ( state ) { tcase LOOKING_FOR_FIRST_ESC_CHAR : tif ( data = = FIRST_ESC_CHAR ) { tbuffer [ pos + + ] = ( byte ) data ; tstate = LOOKING_FOR_SECOND_ESC_CHAR ; } else { tout . write ( data ) ; } tbreak ; tcase LOOKING_FOR_SECOND_ESC_CHAR : tbuffer [ pos + + ] = ( byte ) data ; tif ( data = = SECOND_ESC_CHAR ) { tstate = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { tstate = LOOKING_FOR_OSC_COMMAND ; } else { treset ( false ) ; } tbreak ; tcase LOOKING_FOR_NEXT_ARG : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' = = data ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { toptions . add ( null ) ; } else if ( '?' = = data ) { toptions . add ( new Character ( '?' ) ) ; } else if ( '=' = = data ) { toptions . add ( new Character ( '=' ) ) ; } else { treset ( processEscapeCommand ( options , data ) ) ; } tbreak ; tdefault : tbreak ; tcase LOOKING_FOR_INT_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( ! ( '0' < = data & & data < = '9' ) ) { tString strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; tInteger value = new Integer ( strValue ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { treset ( processEscapeCommand ( options , data ) ) ; } } tbreak ; tcase LOOKING_FOR_STR_ARG_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( '"' ! = data ) { tString value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; toptions . add ( value ) ; tif ( data = = ';' ) { tstate = LOOKING_FOR_NEXT_ARG ; } else { treset ( processEscapeCommand ( options , data ) ) ; } } tbreak ; tcase LOOKING_FOR_OSC_COMMAND : tbuffer [ pos + + ] = ( byte ) data ; tif ( '0' < = data & & data < = '9' ) { tstartOfValue = pos - 1 ; tstate = LOOKING_FOR_OSC_COMMAND_END ; } else { treset ( false ) ; } tbreak ; tcase LOOKING_FOR_OSC_COMMAND_END : tbuffer [ pos + + ] = ( byte ) data ; tif ( ';' = = data ) { tString strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; tInteger value = new Integer ( strValue ) ; toptions . add ( value ) ; tstartOfValue = pos ; tstate = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { reset(false); 
public int fgBright ( ) { return value + 90 ; } 
public int bgBright ( ) { return value + 100 ; } 
public static Ansi ansi ( StringBuilder builder ) { return new Ansi ( builder ) ; } 
public static Ansi ansi ( int size ) { return new Ansi ( size ) ; } 
public Ansi fgDefault ( ) { return this . fg ( Color . DEFAULT ) ; } 
public Ansi fgMagenta ( ) { return this . fg ( Color . MAGENTA ) ; } 
public Ansi fgYellow ( ) { return this . fg ( Color . YELLOW ) ; } 
public Ansi bg ( Color color ) { attributeOptions . add ( color . bg ( ) ) ; return this ; } 
public Ansi bgDefault ( ) { return this . bg ( Color . DEFAULT ) ; } 
public Ansi bgMagenta ( ) { return this . bg ( Color . MAGENTA ) ; } 
public Ansi bgYellow ( ) { return this . bg ( Color . YELLOW ) ; } 
public Ansi fgBrightBlue ( ) { return this . fgBright ( Color . BLUE ) ; } 
public Ansi fgBrightCyan ( ) { return this . fgBright ( Color . CYAN ) ; } 
public Ansi fgBrightDefault ( ) { return this . fgBright ( Color . DEFAULT ) ; } 
public Ansi fgBrightGreen ( ) { return this . fgBright ( Color . GREEN ) ; } 
public Ansi fgBrightMagenta ( ) { return this . fgBright ( Color . MAGENTA ) ; } 
public Ansi fgBrightRed ( ) { return this . fgBright ( Color . RED ) ; } 
public Ansi fgBrightYellow ( ) { return this . fgBright ( Color . YELLOW ) ; } 
public Ansi bgBrightCyan ( ) { return this . fgBright ( Color . CYAN ) ; } 
public Ansi bgBrightDefault ( ) { return this . bgBright ( Color . DEFAULT ) ; } 
public Ansi bgBrightGreen ( ) { return this . bgBright ( Color . GREEN ) ; } 
public Ansi bgBrightMagenta ( ) { return this . bg ( Color . MAGENTA ) ; } 
public Ansi bgBrightRed ( ) { return this . bgBright ( Color . RED ) ; } 
public Ansi bgBrightYellow ( ) { return this . bgBright ( Color . YELLOW ) ; } 
public Ansi a ( Attribute attribute ) { attributeOptions . add ( attribute . value ( ) ) ; return this ; } 
public Ansi cursor ( final int x , final int y ) { return appendEscapeSequence ( 'H' , x , y ) ; } 
public Ansi cursorUp ( final int y ) { return appendEscapeSequence ( 'A' , y ) ; } 
public Ansi cursorDown ( final int y ) { return appendEscapeSequence ( 'B' , y ) ; } 
public Ansi cursorRight ( final int x ) { return appendEscapeSequence ( 'C' , x ) ; } 
public Ansi cursorLeft ( final int x ) { return appendEscapeSequence ( 'D' , x ) ; } 
public Ansi eraseScreen ( ) { return appendEscapeSequence ( 'J' , Erase . ALL . value ( ) ) ; } 
public Ansi eraseScreen ( final Erase kind ) { return appendEscapeSequence ( 'J' , kind . value ( ) ) ; } 
public Ansi eraseLine ( ) { return appendEscapeSequence ( 'K' ) ; } 
public Ansi eraseLine ( final Erase kind ) { return appendEscapeSequence ( 'K' , kind . value ( ) ) ; } 
public Ansi scrollUp ( final int rows ) { return appendEscapeSequence ( 'S' , rows ) ; } 
public Ansi scrollDown ( final int rows ) { return appendEscapeSequence ( 'T' , rows ) ; } 
public Ansi saveCursorPosition ( ) { return appendEscapeSequence ( 's' ) ; } 
public Ansi restorCursorPosition ( ) { return appendEscapeSequence ( 'u' ) ; } 
public Ansi restoreCursorPosition ( ) { return appendEscapeSequence ( 'u' ) ; } 
public Ansi a ( String value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( boolean value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( char value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( char [ ] value , int offset , int len ) { flushAttributes ( ) ; builder . append ( value , offset , len ) ; return this ; } 
public Ansi a ( char [ ] value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( CharSequence value , int start , int end ) { flushAttributes ( ) ; builder . append ( value , start , end ) ; return this ; } 
public Ansi a ( CharSequence value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( double value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( float value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( int value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( long value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( Object value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi a ( StringBuffer value ) { flushAttributes ( ) ; builder . append ( value ) ; return this ; } 
public Ansi newline ( ) { flushAttributes ( ) ; builder . append ( System . getProperty ( " line.separator " ) ) ; return this ; } 
public String toString ( ) { flushAttributes ( ) ; return builder . toString ( ) ; } 
private Ansi appendEscapeSequence ( char command ) { flushAttributes ( ) ; builder . append ( FIRST_ESC_CHAR ) ; builder . append ( SECOND_ESC_CHAR ) ; builder . append ( command ) ; return this ; } 
private Ansi appendEscapeSequence ( char command , int option ) { flushAttributes ( ) ; builder . append ( FIRST_ESC_CHAR ) ; builder . append ( SECOND_ESC_CHAR ) ; builder . append ( option ) ; builder . append ( command ) ; return this ; } 
private Ansi appendEscapeSequence ( char command , Object . . . options ) { flushAttributes ( ) ; return _appendEscapeSequence ( command , options ) ; } 
private void flushAttributes ( ) { if ( attributeOptions . isEmpty ( ) ) return ; if ( attributeOptions . size ( ) = = 1 & & attributeOptions . get ( 0 ) = = 0 ) { builder . append ( FIRST_ESC_CHAR ) ; builder . append ( SECOND_ESC_CHAR ) ; builder . append ( 'm' ) ; } else { _appendEscapeSequence ( 'm' , attributeOptions . toArray ( ) ) ; } attributeOptions . clear ( ) ; } 
private Ansi _appendEscapeSequence ( char command , Object . . . options ) { builder . append ( FIRST_ESC_CHAR ) ; builder . append ( SECOND_ESC_CHAR ) ; int size = options . length ; for ( int i = 0 ; i < size ; i + + ) { if ( i ! = 0 ) { builder . append ( ';' ) ; } if ( options [ i ] ! = null ) { builder . append ( options [ i ] ) ; } } builder . append ( command ) ; return this ; } 
public static OutputStream wrapOutputStream ( final OutputStream stream ) { return wrapOutputStream ( stream , STDOUT_FILENO ) ; } 
public void close ( ) throws IOException { write ( AnsiOutputStream . REST_CODE ) ; flush ( ) ; super . close ( ) ; } 
private static boolean isCygwin ( ) { String term = System . getenv ( " TERM " ) ; return term ! = null & & term . equals ( " xterm " ) ; } 
synchronized static public void systemInstall ( ) { installed + + ; if ( installed = = 1 ) { System . setOut ( out ) ; 
synchronized public static void systemUninstall ( ) { installed - - ; if ( installed = = 0 ) { System . setOut ( system_out ) ; 
public void write ( int data ) throws IOException { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; } else { out . write ( data ) ; } break ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( new Character ( '?' ) ) ; } else if ( '=' = = data ) { options . add ( new Character ( '=' ) ) ; } else { reset ( processEscapeCommand ( options , data ) ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, "UTF-8"); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, "UTF-8"); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
private void reset ( boolean skipBuffer ) throws IOException { if ( ! skipBuffer ) { out . write ( buffer , 0 , pos ) ; } pos = 0 ; startOfValue = 0 ; options . clear ( ) ; state = LOOKING_FOR_FIRST_ESC_CHAR ; } 
private boolean processOperatingSystemCommand ( ArrayList < Object > options ) throws IOException { int command = optionInt ( options , 0 ) ; String label = ( String ) options . get ( 1 ) ; for command > 2 label could be composed (i.e. contain ';'), but we'll leave it to processUnknownOperatingSystemCommand implementations to handle that try { switch (command) { case 0: processChangeIconNameAndWindowTitle(label); return true; case 1: processChangeIconName(label); return true; case 2: processChangeWindowTitle(label); return true; default: not exactly unknown, but not supported through dedicated process methods: processUnknownOperatingSystemCommand(command, label); return true; } } catch (IllegalArgumentException ignore) { } return false; } 
protected void processRestoreCursorPosition ( ) throws IOException { } protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetAttribute ( int attribute ) throws IOException { } protected static final int BLACK = 0 ; protected static final int RED = 1 ; protected static final int GREEN = 2 ; protected static final int YELLOW = 3 ; protected static final int BLUE = 4 ; protected static final int MAGENTA = 5 ; protected static final int CYAN = 6 ; protected static final int WHITE = 7 ; protected void processSetForegroundColor ( int color ) throws IOException { processSetForegroundColor ( color , false ) ; } protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetForegroundColor ( int color ) throws IOException { processSetForegroundColor ( color , false ) ; } 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); 
protected void processCursorLeft ( int count ) throws IOException { } protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); 
protected void processCursorDown ( int count ) throws IOException { } protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( ( Integer ) value ) . intValue ( ) ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( ( Integer ) value ) . intValue ( ) ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( ( Integer ) value ) . intValue ( ) ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } 
protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( ( Integer ) value ) . intValue ( ) ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( ( Integer ) value ) . intValue ( ) ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( ( Integer ) value ) . intValue ( ) ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( ( Integer ) value ) . intValue ( ) ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( ( Integer ) value ) . intValue ( ) ; } 
private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( ( Integer ) value ) . intValue ( ) ; } return defaultValue ; } 
public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } 
static private String render ( final String text , final String . . . codes ) { Ansi ansi = Ansi . ansi ( ) ; for ( String name : codes ) { Code code = Code . valueOf ( name . toUpperCase ( Locale . ENGLISH ) ) ; if ( code . isColor ( ) ) { if ( code . isBackground ( ) ) { ansi = ansi . bg ( code . getColor ( ) ) ; } else { ansi = ansi . fg ( code . getColor ( ) ) ; } } else if ( code . isAttribute ( ) ) { ansi = ansi . a ( code . getAttribute ( ) ) ; } } return ansi . a ( text ) . reset ( ) . toString ( ) ; } 
private CharSequence chew ( final CharSequence str ) { assert str ! = null ; ByteArrayOutputStream buff = new ByteArrayOutputStream ( ) ; AnsiOutputStream out = new AnsiOutputStream ( buff ) ; try { out . write ( str . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return new String ( buff . toByteArray ( ) ) ; } 
public void close ( ) throws IOException { closeAttributes ( ) ; super . close ( ) ; } 
private void write ( String s ) throws IOException { super . out . write ( s . getBytes ( ) ) ; } 
private void writeAttribute ( String s ) throws IOException { write ( " < " + s + " > " ) ; closingAttributes . add ( 0 , s . split ( " " , 2 ) [ 0 ] ) ; } 
private void closeAttributes ( ) throws IOException { for ( String attr : closingAttributes ) { write ( " </ " + attr + " > " ) ; } closingAttributes . clear ( ) ; } 
public void write ( int data ) throws IOException { switch ( data ) { case 34 : " 
public void writeLine ( byte [ ] buf , int offset , int len ) throws IOException { write ( buf , offset , len ) ; closeAttributes ( ) ; } 
protected void processSetAttribute ( int attribute ) throws IOException { switch ( attribute ) { case ATTRIBUTE_CONCEAL_ON : 
protected void processAttributeRest ( ) throws IOException { if ( concealOn ) { write ( " u001B[0m " ) ; concealOn = false ; } closeAttributes ( ) ; } 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { writeAttribute ( " span style= \" color: " + ANSI_COLOR_MAP [ color ] + " ; \" " ) ; } 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { writeAttribute ( " span style= \" background-color: " + ANSI_COLOR_MAP [ color ] + " ; \" " ) ; } 
private void getConsoleInfo ( ) throws IOException { out . flush ( ) ; if ( GetConsoleScreenBufferInfo ( console , info ) = = 0 ) { throw new IOException ( " Could not get the screen info: " + WindowsSupport . getLastErrorMessage ( ) ) ; } if ( negative ) { info . attributes = invertAttributeColors ( info . attributes ) ; 
private void applyAttribute ( ) throws IOException { out . flush ( ) ; short attributes = info . attributes ; if ( negative ) { attributes = invertAttributeColors ( attributes ) ; } if ( SetConsoleTextAttribute ( console , attributes ) = = 0 ) { throw new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
private short invertAttributeColors ( short attributes ) { Swap the the Foreground and Background bits. int fg = 0x000F & attributes; fg <<= 8; int bg = 0X00F0 * attributes; bg >>= 8; attributes = (short) ((attributes & 0xFF00) | fg | bg); return attributes; } 
private void applyCursorPosition ( ) throws IOException { if ( SetConsoleCursorPosition ( console , info . cursorPosition . copy ( ) ) = = 0 ) { throw new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
protected void processEraseScreen ( int eraseOption ) throws IOException { getConsoleInfo ( ) ; int [ ] written = new int [ 1 ] ; switch ( eraseOption ) { case ERASE_SCREEN : 
protected void processEraseLine ( int eraseOption ) throws IOException { getConsoleInfo ( ) ; int [ ] written = new int [ 1 ] ; switch ( eraseOption ) { case ERASE_LINE : 
protected void processCursorLeft ( int count ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . x = ( short ) Math . max ( 0 , info . cursorPosition . x - count ) ; applyCursorPosition ( ) ; } 
protected void processCursorRight ( int count ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . x = ( short ) Math . min ( info . window . width ( ) , info . cursorPosition . x + count ) ; applyCursorPosition ( ) ; } 
protected void processCursorDown ( int count ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . y = ( short ) Math . min ( info . size . y , info . cursorPosition . y + count ) ; applyCursorPosition ( ) ; } 
protected void processCursorUp ( int count ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . y = ( short ) Math . max ( info . window . top , info . cursorPosition . y - count ) ; applyCursorPosition ( ) ; } 
protected void processCursorTo ( int row , int col ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . y = ( short ) Math . max ( info . window . top , Math . min ( info . size . y , info . window . top + row - 1 ) ) ; info . cursorPosition . x = ( short ) Math . max ( 0 , Math . min ( info . window . width ( ) , col - 1 ) ) ; applyCursorPosition ( ) ; } 
protected void processCursorToColumn ( int x ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . x = ( short ) Math . max ( 0 , Math . min ( info . window . width ( ) , x - 1 ) ) ; applyCursorPosition ( ) ; } 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x0007 ) | ANSI_FOREGROUND_COLOR_MAP [ color ] ) ; applyAttribute ( ) ; } 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x0070 ) | ANSI_BACKGROUND_COLOR_MAP [ color ] ) ; applyAttribute ( ) ; } 
protected void processDefaultTextColor ( ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x000F ) | ( originalColors & 0xF ) ) ; applyAttribute ( ) ; } 
protected void processDefaultBackgroundColor ( ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x00F0 ) | ( originalColors & 0xF0 ) ) ; applyAttribute ( ) ; } 
protected void processAttributeRest ( ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x00FF ) | originalColors ) ; this . negative = false ; applyAttribute ( ) ; } 
protected void processSetAttribute ( int attribute ) throws IOException { switch ( attribute ) { case ATTRIBUTE_INTENSITY_BOLD : 
protected void processSaveCursorPosition ( ) throws IOException { getConsoleInfo ( ) ; savedX = info . cursorPosition . x ; savedY = info . cursorPosition . y ; } 
protected void processRestoreCursorPosition ( ) throws IOException { restore only if there was a save operation first if (savedX != -1 && savedY != -1) { out.flush(); 
protected void processChangeWindowTitle ( String label ) { SetConsoleTitle ( label ) ; } 
public void testSetEnabled ( ) throws Exception { Ansi . setEnabled ( false ) ; new Thread ( ) { @Override public void run ( ) { assertEquals ( false , Ansi . isEnabled ( ) ) ; } } . run ( ) ; Ansi . setEnabled ( true ) ; new Thread ( ) { @Override 
public void testNoMarkup ( ) throws IOException { assertEquals ( " line " , colorize ( " line " ) ) ; } 
public void testClear ( ) throws IOException { assertEquals ( " " , colorize ( " [0m[K " ) ) ; assertEquals ( " hello world " , colorize ( " [0mhello world " ) ) ; } 
public void testBold ( ) throws IOException { assertEquals ( " <b>hello world</b> " , colorize ( " [1mhello world " ) ) ; } 
public void testGreen ( ) throws IOException { assertEquals ( " <span style= \" color: green; \" >hello world</span> " , colorize ( " [32mhello world " ) ) ; 
public void testGreenOnWhite ( ) throws IOException { assertEquals ( " <span style= \" background-color: white; \" ><span style= \" color: green; \" >hello world</span></span> " , colorize ( " [47;32mhello world " ) ) ; 
public void testEscapeHtml ( ) throws IOException { assertEquals ( " &quot; " , colorize ( " \" " ) ) ; assertEquals ( " &amp; " , colorize ( " & " ) ) ; assertEquals ( " &lt; " , colorize ( " < " ) ) ; assertEquals ( " &gt; " , colorize ( " > " ) ) ; assertEquals ( " &quot;&amp;&lt;&gt; " , colorize ( " \" &<> " ) ) ; } 
public void testResetOnOpen ( ) throws IOException { assertEquals ( " <span style= \" color: red; \" >red</span> " , colorize ( " [0;31;49mred[0m " ) ) ; 
public void testUTF8Character ( ) throws IOException { assertEquals ( " <b> u3053 u3093 u306b u3061 u306f</b> " , colorize ( " [1m u3053 u3093 u306b u3061 u306f " ) ) ; 
private String colorize ( String text ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; HtmlAnsiOutputStream hos = new HtmlAnsiOutputStream ( os ) ; hos . write ( text . getBytes ( " UTF-8 " ) ) ; hos . close ( ) ; return new String ( os . toByteArray ( ) , " UTF-8 " ) ; } 
public static Ansi ansi ( StringBuilder builder ) { if ( isEnabled ( ) ) { return new Ansi ( builder ) ; 
public static Ansi ansi ( int size ) { if ( isEnabled ( ) ) { return new Ansi ( size ) ; 
private static boolean isXterm ( ) { return " xterm " . equals ( System . getenv ( " TERM " ) ) ; } 
public static void main ( String [ ] args ) { AnsiConsole . systemInstall ( ) ; System . out . println ( ansi ( ) . eraseScreen ( ) . fg ( RED ) . a ( " Hello " ) . fg ( GREEN ) . a ( " World " ) . reset ( ) ) ; AnsiConsole . systemUninstall ( ) ; } 
private static boolean isXterm ( ) { String term = System . getenv ( " TERM " ) ; return term ! = null & & term . startsWith ( " xterm " ) ; } 
public static OutputStream wrapOutputStream ( final OutputStream stream ) { try { return wrapOutputStream ( stream , STDOUT_FILENO ) ; 
public static OutputStream wrapErrorOutputStream ( final OutputStream stream ) { try { return wrapOutputStream ( stream , STDERR_FILENO ) ; 
protected void processCursorDown ( int count ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . y = ( short ) Math . min ( Math . max ( 0 , info . size . y - 1 ) , info . cursorPosition . y + count ) ; applyCursorPosition ( ) ; } 
private int getNextOptionInt ( Iterator < Object > optionsIterator ) throws IOException { for ( ; ; ) { if ( ! optionsIterator . hasNext ( ) ) 
protected void processRestoreCursorPosition ( ) throws IOException { } protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetAttribute ( int attribute ) throws IOException { } protected static final int BLACK = 0 ; protected static final int RED = 1 ; protected static final int GREEN = 2 ; protected static final int YELLOW = 3 ; protected static final int BLUE = 4 ; protected static final int MAGENTA = 5 ; protected static final int CYAN = 6 ; protected static final int WHITE = 7 ; protected void processSetForegroundColor ( int color ) throws IOException { processSetForegroundColor ( color , false ) ; } protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
static public String render ( final String input ) throws IllegalArgumentException { try { return render ( input , new StringBuilder ( ) ) . toString ( ) ; 
static public Appendable render ( final String input , Appendable target ) throws IOException { int i = 0 ; int j , k ; while ( true ) { j = input . indexOf ( BEGIN_TOKEN , i ) ; 
static public String render ( final String text , final String . . . codes ) { Ansi ansi = Ansi . ansi ( ) ; for ( String name : codes ) { Code code = Code . valueOf ( name . toUpperCase ( Locale . ENGLISH ) ) ; if ( code . isColor ( ) ) { if ( code . isBackground ( ) ) { ansi = ansi . bg ( code . getColor ( ) ) ; } else { ansi = ansi . fg ( code . getColor ( ) ) ; } } else if ( code . isAttribute ( ) ) { ansi = ansi . a ( code . getAttribute ( ) ) ; } } return ansi . a ( text ) . reset ( ) . toString ( ) ; } 
protected void processRestoreCursorPosition ( ) throws IOException { } protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return ((Integer) value).intValue(); } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return ((Integer) value).intValue(); } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
public void write ( int data ) throws IOException { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; } else { out . write ( data ) ; } break ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( '?' ) ; } else if ( '=' = = data ) { options . add ( '=' ) ; } else { reset ( processEscapeCommand ( options , data ) ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , " UTF-8 " ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, "UTF-8"); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, "UTF-8"); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
protected void processRestoreCursorPosition ( ) throws IOException { } protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetAttribute ( int attribute ) throws IOException { } protected static final int BLACK = 0 ; protected static final int RED = 1 ; protected static final int GREEN = 2 ; protected static final int YELLOW = 3 ; protected static final int BLUE = 4 ; protected static final int MAGENTA = 5 ; protected static final int CYAN = 6 ; protected static final int WHITE = 7 ; protected void processSetForegroundColor ( int color ) throws IOException { processSetForegroundColor ( color , false ) ; } protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorLeft ( int count ) throws IOException { } protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(REST_CODE); flush(); super.close(); } static private byte[] resetCode() { try { return new Ansi().reset().toString().getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }} 
protected void processCursorDown ( int count ) throws IOException { } protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } 
private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } 
public static String render ( final String input ) throws IllegalArgumentException { try { return render ( input , new StringBuilder ( ) ) . toString ( ) ; 
public static Appendable render ( final String input , Appendable target ) throws IOException { int i = 0 ; int j , k ; while ( true ) { j = input . indexOf ( BEGIN_TOKEN , i ) ; 
public static String render ( final String text , final String . . . codes ) { Ansi ansi = Ansi . ansi ( ) ; for ( String name : codes ) { Code code = Code . valueOf ( name . toUpperCase ( Locale . ENGLISH ) ) ; if ( code . isColor ( ) ) { if ( code . isBackground ( ) ) { ansi = ansi . bg ( code . getColor ( ) ) ; } else { ansi = ansi . fg ( code . getColor ( ) ) ; } } else if ( code . isAttribute ( ) ) { ansi = ansi . a ( code . getAttribute ( ) ) ; } } return ansi . a ( text ) . reset ( ) . toString ( ) ; } 
public static void main ( String [ ] args ) throws IOException { System . out . println ( " Platform: " + System . getProperty ( " os.name " ) ) ; System . out . println ( " Platform encoding: " + Charset . defaultCharset ( ) ) ; System . out . println ( " System.out: " + NON_ASCII ) ; AnsiConsole . out . println ( " AnsiConsole.out: " + NON_ASCII ) ; } 
public static String render ( final String text , final String . . . codes ) { return render ( Ansi . ansi ( ) , codes ) . a ( text ) . reset ( ) . toString ( ) ; 
public static String renderCodes ( final String . . . codes ) { return render ( Ansi . ansi ( ) , codes ) . toString ( ) ; } 
public static String renderCodes ( final String codes ) { return renderCodes ( codes . split ( " \\ s " ) ) ; } 
private static Ansi render ( Ansi ansi , String . . . names ) { for ( String name : names ) { render ( ansi , name ) ; } return ansi ; } 
private static Ansi render ( Ansi ansi , String name ) { Code code = Code . valueOf ( name . toUpperCase ( Locale . ENGLISH ) ) ; if ( code . isColor ( ) ) { if ( code . isBackground ( ) ) { ansi . bg ( code . getColor ( ) ) ; } else { ansi . fg ( code . getColor ( ) ) ; } } else if ( code . isAttribute ( ) ) { ansi . a ( code . getAttribute ( ) ) ; } return ansi ; } 
public void testRenderCodes ( ) { String str = renderCodes ( " bold red " ) ; System . out . println ( str ) ; assertEquals ( ansi ( ) . bold ( ) . fg ( Color . RED ) . toString ( ) , str ) ; } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processChangeIconName ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( REST_CODE ) ; flush ( ) ; super . close ( ) ; } static private byte [ ] resetCode ( ) { try { return new Ansi ( ) . reset ( ) . toString ( ) . getBytes ( " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x0007 ) | ANSI_FOREGROUND_COLOR_MAP [ color ] ) ; info . attributes = ( short ) ( ( info . attributes & ~ FOREGROUND_INTENSITY ) | ( bright ? FOREGROUND_INTENSITY : 0 ) ) ; applyAttribute ( ) ; } 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x0070 ) | ANSI_BACKGROUND_COLOR_MAP [ color ] ) ; info . attributes = ( short ) ( ( info . attributes & ~ BACKGROUND_INTENSITY ) | ( bright ? BACKGROUND_INTENSITY : 0 ) ) ; applyAttribute ( ) ; } 
protected void processDefaultTextColor ( ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x000F ) | ( originalColors & 0xF ) ) ; info . attributes = ( short ) ( info . attributes & ~ FOREGROUND_INTENSITY ) ; applyAttribute ( ) ; } 
protected void processDefaultBackgroundColor ( ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x00F0 ) | ( originalColors & 0xF0 ) ) ; info . attributes = ( short ) ( info . attributes & ~ BACKGROUND_INTENSITY ) ; applyAttribute ( ) ; } 
public void write ( int data ) throws IOException { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; } else { out . write ( data ) ; } break ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( '?' ) ; } else if ( '=' = = data ) { options . add ( '=' ) ; } else { reset ( processEscapeCommand ( options , data ) ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
public void close ( ) throws IOException { write ( AnsiOutputStream . RESET_CODE ) ; flush ( ) ; super . close ( ) ; } 
protected void processRestoreCursorPosition ( ) throws IOException { } protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processSaveCursorPosition ( ) throws IOException { } protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processScrollDown ( int optionInt ) throws IOException { } protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processScrollUp ( int optionInt ) throws IOException { } protected static final int ERASE_SCREEN_TO_END = 0 ; protected static final int ERASE_SCREEN_TO_BEGINING = 1 ; protected static final int ERASE_SCREEN = 2 ; protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processEraseScreen ( int eraseOption ) throws IOException { } protected static final int ERASE_LINE_TO_END = 0 ; protected static final int ERASE_LINE_TO_BEGINING = 1 ; protected static final int ERASE_LINE = 2 ; protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processEraseLine ( int eraseOption ) throws IOException { } protected static final int ATTRIBUTE_INTENSITY_BOLD = 1 ; conceal off protected void processSetAttribute(int attribute) throws IOException { } protected static final int BLACK = 0; protected static final int RED = 1; protected static final int GREEN = 2; protected static final int YELLOW = 3; protected static final int BLUE = 4; protected static final int MAGENTA = 5; protected static final int CYAN = 6; protected static final int WHITE = 7; protected void processSetForegroundColor(int color) throws IOException { processSetForegroundColor(color, false); } protected void processSetForegroundColor(int color, boolean bright) throws IOException { } protected void processSetForegroundColorExt(int paletteIndex) throws IOException { } protected void processSetForegroundColorExt(int r, int g, int b) throws IOException { } protected void processSetBackgroundColor(int color) throws IOException { processSetBackgroundColor(color, false); } protected void processSetBackgroundColor(int color, boolean bright) throws IOException { } protected void processSetBackgroundColorExt(int paletteIndex) throws IOException { } protected void processSetBackgroundColorExt(int r, int g, int b) throws IOException { } protected void processDefaultTextColor() throws IOException { } protected void processDefaultBackgroundColor() throws IOException { } protected void processAttributeRest() throws IOException { } protected void processCursorTo(int row, int col) throws IOException { } protected void processCursorToColumn(int x) throws IOException { } protected void processCursorUpLine(int count) throws IOException { } protected void processCursorDownLine(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processSetAttribute ( int attribute ) throws IOException { } protected static final int BLACK = 0 ; protected static final int RED = 1 ; protected static final int GREEN = 2 ; protected static final int YELLOW = 3 ; protected static final int BLUE = 4 ; protected static final int MAGENTA = 5 ; protected static final int CYAN = 6 ; protected static final int WHITE = 7 ; protected void processSetForegroundColor ( int color ) throws IOException { processSetForegroundColor ( color , false ) ; } protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { } protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { } protected void processSetBackgroundColor ( int color ) throws IOException { processSetBackgroundColor ( color , false ) ; } protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { } protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { } protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { } protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processDefaultTextColor ( ) throws IOException { } protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processDefaultBackgroundColor ( ) throws IOException { } protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processAttributeRest ( ) throws IOException { } protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processCursorTo ( int row , int col ) throws IOException { } protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processCursorToColumn ( int x ) throws IOException { } protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processCursorUpLine ( int count ) throws IOException { } protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); } } protected void processCursorLeft(int count) throws IOException { } protected void processCursorRight(int count) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processCursorLeft ( int count ) throws IOException { } protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); } } protected void processCursorDown(int count) throws IOException { } protected void processCursorUp(int count) throws IOException { } protected void processUnknownExtension(ArrayList<Object> options, int command) { } protected void processChangeIconNameAndWindowTitle(String label) { processChangeIconName(label); processChangeWindowTitle(label); } protected void processChangeIconName(String label) { } protected void processChangeWindowTitle(String label) { } protected void processUnknownOperatingSystemCommand(int command, String param) { } private int optionInt(ArrayList<Object> options, int index) { if (options.size() <= index) throw new IllegalArgumentException(); Object value = options.get(index); if (value == null) throw new IllegalArgumentException(); if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException(); return (Integer) value; } private int optionInt(ArrayList<Object> options, int index, int defaultValue) { if (options.size() > index) { Object value = options.get(index); if (value == null) { return defaultValue; } return (Integer) value; } return defaultValue; } @Override public void close() throws IOException { write(RESET_CODE); flush(); super.close(); }} 
protected void processCursorDown ( int count ) throws IOException { } protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processChangeIconNameAndWindowTitle ( String label ) { processChangeIconName ( label ) ; processChangeWindowTitle ( label ) ; } protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processChangeIconName ( String label ) { } protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } 
public synchronized void write ( int data ) throws IOException { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; } else { out . write ( data ) ; } break ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( '?' ) ; } else if ( '=' = = data ) { options . add ( '=' ) ; } else { reset ( processEscapeCommand ( options , data ) ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
private short invertAttributeColors ( short attributes ) { Swap the the Foreground and Background bits. int fg = 0x000F & attributes; fg <<= 4; int bg = 0X00F0 & attributes; bg >>= 4; attributes = (short) ((attributes & 0xFF00) | fg | bg); return attributes; } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processChangeIconName ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processInsertLine ( int optionInt ) throws IOException { getConsoleInfo ( ) ; SMALL_RECT scroll = info . window . copy ( ) ; scroll . top = info . cursorPosition . y ; COORD org = new COORD ( ) ; org . x = 0 ; org . y = ( short ) ( info . cursorPosition . y + optionInt ) ; CHAR_INFO info = new CHAR_INFO ( ) ; info . attributes = originalColors ; info . unicodeChar = ' ' ; if ( ScrollConsoleScreenBuffer ( console , scroll , scroll , org , info ) = = 0 ) { throw new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
protected void processDeleteLine ( int optionInt ) throws IOException { getConsoleInfo ( ) ; SMALL_RECT scroll = info . window . copy ( ) ; scroll . top = info . cursorPosition . y ; COORD org = new COORD ( ) ; org . x = 0 ; org . y = ( short ) ( info . cursorPosition . y - optionInt ) ; CHAR_INFO info = new CHAR_INFO ( ) ; info . attributes = originalColors ; info . unicodeChar = ' ' ; if ( ScrollConsoleScreenBuffer ( console , scroll , scroll , org , info ) = = 0 ) { throw new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
private static String getPomPropertiesVersion ( String path ) throws IOException { InputStream in = AnsiMain . class . getResourceAsStream ( " /META-INF/maven/ " + path + " /pom.properties " ) ; if ( in = = null ) { return null ; } try { Properties p = new Properties ( ) ; 
private static void printJansiLogoDemo ( ) throws IOException { Reader in = new InputStreamReader ( AnsiMain . class . getResourceAsStream ( " jansi.txt " ) , " UTF-8 " ) ; try { char [ ] buf = new char [ 1024 ] ; 
private static void writeFileContent ( File f ) throws IOException { InputStream in = new FileInputStream ( f ) ; try { byte [ ] buf = new byte [ 1024 ] ; 
private static void closeQuietly ( Closeable c ) { try { c . close ( ) ; 
public synchronized void write ( int data ) throws IOException { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; } else { out . write ( data ) ; } break ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else if ( data = = SECOND_CHARSET0_CHAR ) { options . add ( new Integer ( '0' ) ) ; state = LOOKING_FOR_CHARSET ; } else if ( data = = SECOND_CHARSET1_CHAR ) { options . add ( new Integer ( '1' ) ) ; state = LOOKING_FOR_CHARSET ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( '?' ) ; } else if ( '=' = = data ) { options . add ( '=' ) ; } else { reset ( processEscapeCommand ( options , data ) ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(new Character((char) data)); reset(processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processChangeIconName ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processChangeWindowTitle ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } 
protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { write ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
public void testResetCharacterSet ( ) throws IOException { assertEquals ( colorize ( " ( 033(0) " ) , " () " ) ; assertEquals ( colorize ( " ( 033)0) " ) , " () " ) ; } 
private static void diagnoseTty ( boolean stderr ) { int fd = stderr ? CLibrary . STDERR_FILENO : CLibrary . STDOUT_FILENO ; int isatty = isatty ( fd ) ; System . out . println ( " isatty(STD " + ( stderr ? " ERR " : " OUT " ) + " _FILENO)= " + isatty + " , System. " + ( stderr ? " err " : " out " ) + " " + ( ( isatty = = 0 ) ? " is *NOT* " : " is " ) + " a terminal " ) ; 
private static void testAnsi ( boolean stderr ) { @SuppressWarnings ( " resource " ) PrintStream s = stderr ? System . err : System . out ; s . print ( " test on System. " + ( stderr ? " err " : " out " ) + " : " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bright: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . fgBright ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bold: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . bold ( ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; } 
public static PrintStream wrapSystemOut ( final PrintStream ps ) { try { return wrapPrintStream ( ps , STDOUT_FILENO ) ; 
public static PrintStream wrapSystemErr ( final PrintStream ps ) { try { return wrapPrintStream ( ps , STDERR_FILENO ) ; 
public void close ( ) { ps . print ( AnsiPrintStream . RESET_CODE ) ; ps . flush ( ) ; super . close ( ) ; } 
protected boolean filter ( int data ) { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; return false ; } return true ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( '?' ) ; } else if ( '=' = = data ) { options . add ( '=' ) ; } else { reset ( processEscapeCommand ( options , data ) ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , Charset . defaultCharset ( ) ) ; Integer value = new Integer ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; } Is it just too long? if (pos >= buffer.length) { reset(false); } return false; } 
private void reset ( boolean skipBuffer ) { if ( ! skipBuffer ) { ps . write ( buffer , 0 , pos ) ; } pos = 0 ; startOfValue = 0 ; options . clear ( ) ; state = LOOKING_FOR_FIRST_ESC_CHAR ; } 
private boolean processOperatingSystemCommand ( ArrayList < Object > options ) { int command = optionInt ( options , 0 ) ; String label = ( String ) options . get ( 1 ) ; for command > 2 label could be composed (i.e. contain ';'), but we'll leave it to processUnknownOperatingSystemCommand implementations to handle that try { switch (command) { case 0: processChangeIconNameAndWindowTitle(label); return true; case 1: processChangeIconName(label); return true; case 2: processChangeWindowTitle(label); return true; default: not exactly unknown, but not supported through dedicated process methods: processUnknownOperatingSystemCommand(command, label); return true; } } catch (IllegalArgumentException ignore) { } return false; } 
protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { print(''); 
protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { print(' '); 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { ps . print ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { ps . print ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processChangeIconName ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { ps . print ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { ps . print ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { ps . print ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } } 
public void close ( ) { ps . print ( RESET_CODE ) ; flush ( ) ; super . close ( ) ; } 
public void write ( int b ) throws IOException { throw new RuntimeException ( " Direct OutputStream use forbidden: must go through delegate PrintStream " ) ; } 
public void write ( int data ) { if ( filter ( data ) ) { 
public void write ( byte [ ] buf , int off , int len ) { for ( int i = 0 ; i < len ; i + + ) { 
public boolean checkError ( ) { return super . checkError ( ) | | ps . checkError ( ) ; } 
public void close ( ) { super . close ( ) ; ps . close ( ) ; } 
public void flush ( ) { super . flush ( ) ; ps . flush ( ) ; } 
private void write ( char buf [ ] ) { for ( char c : buf ) { 
private void write ( String s ) { char [ ] buf = new char [ s . length ( ) ] ; s . getChars ( 0 , s . length ( ) , buf , 0 ) ; write ( buf ) ; } 
public void print ( boolean b ) { write ( b ? " true " : " false " ) ; } 
public void print ( float f ) { write ( String . valueOf ( f ) ) ; } 
public void print ( double d ) { write ( String . valueOf ( d ) ) ; } 
public void print ( String s ) { if ( s = = null ) { s = " null " ; } write ( s ) ; } 
public void print ( Object obj ) { write ( String . valueOf ( obj ) ) ; } 
public void println ( boolean x ) { synchronized ( this ) { print ( x ) ; 
public void println ( char x ) { synchronized ( this ) { print ( x ) ; 
public void println ( int x ) { synchronized ( this ) { print ( x ) ; 
public void println ( long x ) { synchronized ( this ) { print ( x ) ; 
public void println ( float x ) { synchronized ( this ) { print ( x ) ; 
public void println ( double x ) { synchronized ( this ) { print ( x ) ; 
public void println ( char x [ ] ) { synchronized ( this ) { print ( x ) ; 
public void println ( String x ) { synchronized ( this ) { print ( x ) ; 
public void println ( Object x ) { String s = String . valueOf ( x ) ; synchronized ( this ) { print ( s ) ; 
private void getConsoleInfo ( ) throws IOException { ps . flush ( ) ; if ( GetConsoleScreenBufferInfo ( console , info ) = = 0 ) { throw new IOException ( " Could not get the screen info: " + WindowsSupport . getLastErrorMessage ( ) ) ; } if ( negative ) { info . attributes = invertAttributeColors ( info . attributes ) ; 
private void applyAttribute ( ) throws IOException { ps . flush ( ) ; short attributes = info . attributes ; if ( negative ) { attributes = invertAttributeColors ( attributes ) ; } if ( SetConsoleTextAttribute ( console , attributes ) = = 0 ) { throw new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
protected void processRestoreCursorPosition ( ) throws IOException { restore only if there was a save operation first if (savedX != -1 && savedY != -1) { ps.flush(); 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x0007 ) | ANSI_FOREGROUND_COLOR_MAP [ color ] ) ; if ( bright ) { info . attributes | = FOREGROUND_INTENSITY ; } applyAttribute ( ) ; } 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x0070 ) | ANSI_BACKGROUND_COLOR_MAP [ color ] ) ; if ( bright ) { info . attributes | = BACKGROUND_INTENSITY ; } applyAttribute ( ) ; } 
public synchronized void write ( int data ) throws IOException { expected diff with AnsiPrintStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; } else { expected diff with AnsiPrintStream.java out.write(data); expected diff with AnsiPrintStream.java } break; expected diff with AnsiPrintStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(new Integer('0')); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(new Integer('1')); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(new Character((char) data)); reset(processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
private void reset ( boolean skipBuffer ) throws IOException { expected diff with AnsiPrintStream.java if (!skipBuffer) { out.write(buffer, 0, pos); expected diff with AnsiPrintStream.java } pos = 0; startOfValue = 0; options.clear(); state = LOOKING_FOR_FIRST_ESC_CHAR; } 
private boolean processOperatingSystemCommand ( ArrayList < Object > options ) throws IOException { expected diff with AnsiPrintStream.java int command = optionInt(options, 0); String label = (String) options.get(1); for command > 2 label could be composed (i.e. contain ';'), but we'll leave it to processUnknownOperatingSystemCommand implementations to handle that try { switch (command) { case 0: processChangeIconNameAndWindowTitle(label); return true; case 1: processChangeIconName(label); return true; case 2: processChangeWindowTitle(label); return true; default: not exactly unknown, but not supported through dedicated process methods: processUnknownOperatingSystemCommand(command, label); return true; } } catch (IllegalArgumentException ignore) { } return false; } 
protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(''); expected diff with AnsiPrintStream.java 
protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { out.write(' '); expected diff with AnsiPrintStream.java 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processChangeIconName ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processChangeWindowTitle ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) throws IOException { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); } 
protected boolean filter ( int data ) { expected diff with AnsiOutputStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; return false; expected diff with AnsiOutputStream.java } return true; expected diff with AnsiOutputStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; } Is it just too long? if (pos >= buffer.length) { reset(false); } return false; expected diff with AnsiOutputStream.java } 
private void reset ( boolean skipBuffer ) { expected diff with AnsiOutputStream.java if (!skipBuffer) { ps.write(buffer, 0, pos); expected diff with AnsiOutputStream.java } pos = 0; startOfValue = 0; options.clear(); state = LOOKING_FOR_FIRST_ESC_CHAR; } 
private boolean processOperatingSystemCommand ( ArrayList < Object > options ) { expected diff with AnsiOutputStream.java int command = optionInt(options, 0); String label = (String) options.get(1); for command > 2 label could be composed (i.e. contain ';'), but we'll leave it to processUnknownOperatingSystemCommand implementations to handle that try { switch (command) { case 0: processChangeIconNameAndWindowTitle(label); return true; case 1: processChangeIconName(label); return true; case 2: processChangeWindowTitle(label); return true; default: not exactly unknown, but not supported through dedicated process methods: processUnknownOperatingSystemCommand(command, label); return true; } } catch (IllegalArgumentException ignore) { } return false; } 
protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { print(''); expected diff with AnsiOutputStream.java 
protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { print(' '); expected diff with AnsiOutputStream.java 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processChangeIconName ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); } 
private void getConsoleInfo ( ) throws IOException { out . flush ( ) ; expected diff with WindowsAnsiPrintStream.java if (GetConsoleScreenBufferInfo(console, info) == 0) { throw new IOException("Could not get the screen info: " + WindowsSupport.getLastErrorMessage()); } if (negative) { info.attributes = invertAttributeColors(info.attributes); 
private void applyAttribute ( ) throws IOException { out . flush ( ) ; expected diff with WindowsAnsiPrintStream.java short attributes = info.attributes; if (negative) { attributes = invertAttributeColors(attributes); } if (SetConsoleTextAttribute(console, attributes) == 0) { throw new IOException(WindowsSupport.getLastErrorMessage()); 
protected void processRestoreCursorPosition ( ) throws IOException { restore only if there was a save operation first if (savedX != -1 && savedY != -1) { out.flush(); expected diff with WindowsAnsiPrintStream.java 
private void getConsoleInfo ( ) throws IOException { ps . flush ( ) ; expected diff with WindowsAnsiOutputStream.java if (GetConsoleScreenBufferInfo(console, info) == 0) { throw new IOException("Could not get the screen info: " + WindowsSupport.getLastErrorMessage()); } if (negative) { info.attributes = invertAttributeColors(info.attributes); 
private void applyAttribute ( ) throws IOException { ps . flush ( ) ; expected diff with WindowsAnsiOutputStream.java short attributes = info.attributes; if (negative) { attributes = invertAttributeColors(attributes); } if (SetConsoleTextAttribute(console, attributes) == 0) { throw new IOException(WindowsSupport.getLastErrorMessage()); 
protected void processRestoreCursorPosition ( ) throws IOException { restore only if there was a save operation first if (savedX != -1 && savedY != -1) { ps.flush(); expected diff with WindowsAnsiOutputStream.java 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processChangeIconName ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processChangeWindowTitle ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } 
protected boolean filter ( int data ) { expected diff with AnsiOutputStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; return false; expected diff with AnsiOutputStream.java } return true; expected diff with AnsiOutputStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(new Integer('0')); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(new Integer('1')); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(new Character((char) data)); reset(processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); } return false; expected diff with AnsiOutputStream.java } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processChangeIconName ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processChangeWindowTitle ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java ps.print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
public synchronized void write ( int data ) throws IOException { expected diff with AnsiPrintStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; } else { expected diff with AnsiPrintStream.java out.write(data); expected diff with AnsiPrintStream.java } break; expected diff with AnsiPrintStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(Integer.valueOf(0)); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(Integer.valueOf(1)); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(Character.valueOf((char) data)); reset(processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
protected boolean filter ( int data ) { expected diff with AnsiOutputStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; return false; expected diff with AnsiOutputStream.java } return true; expected diff with AnsiOutputStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(Integer.valueOf(0)); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(Integer.valueOf(1)); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(Character.valueOf((char) data)); reset(processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); } return false; expected diff with AnsiOutputStream.java } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processChangeIconName ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processChangeWindowTitle ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); } 
protected synchronized boolean filter ( int data ) { expected diff with AnsiOutputStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; return false; expected diff with AnsiOutputStream.java } return true; expected diff with AnsiOutputStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(Integer.valueOf(0)); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(Integer.valueOf(1)); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = new Integer(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(Character.valueOf((char) data)); reset(processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); } return false; expected diff with AnsiOutputStream.java } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processChangeIconName ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processChangeWindowTitle ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) throws IOException { expected diff with AnsiPrintStream.java write(RESET_CODE); expected diff with AnsiPrintStream.java flush(); super.close(); }} 
protected void processCursorUp ( int count ) throws IOException { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processChangeIconName ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processChangeWindowTitle ( String label ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } protected void processCharsetSelect ( int set , char seq ) { } private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } private int optionInt ( ArrayList < Object > options , int index , int defaultValue ) { if ( options . size ( ) > index ) { Object value = options . get ( index ) ; if ( value = = null ) { return defaultValue ; } return ( Integer ) value ; } return defaultValue ; } @Override public void close ( ) { expected diff with AnsiOutputStream.java print(RESET_CODE); expected diff with AnsiOutputStream.java flush(); super.close(); }} 
private static void diagnoseTty ( boolean stderr ) { int fd = stderr ? CLibrary . STDERR_FILENO : CLibrary . STDOUT_FILENO ; int isatty = isatty ( fd ) ; System . out . println ( " isatty(STD " + ( stderr ? " ERR " : " OUT " ) + " _FILENO): " + isatty + " , System. " + ( stderr ? " err " : " out " ) + " " + ( ( isatty = = 0 ) ? " is *NOT* " : " is " ) + " a terminal " ) ; 
protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { ps.write(''); expected diff with AnsiOutputStream.java 
protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { ps.write(' '); expected diff with AnsiOutputStream.java 
public Ansi cursor ( int row , int column ) { return this ; } 
public Ansi cursor ( final int row , final int column ) { return appendEscapeSequence ( 'H' , row , column ) ; } 
public void testNotEncoded ( ) { AnsiString as = new AnsiString ( " foo " ) ; assertEquals ( " foo " , as . getEncoded ( ) ) ; assertEquals ( " foo " , as . getPlain ( ) ) ; assertEquals ( 3 , as . length ( ) ) ; } 
public void testEncoded ( ) { AnsiString as = new AnsiString ( Ansi . ansi ( ) . a ( Ansi . Attribute . INTENSITY_BOLD ) . a ( " foo " ) . reset ( ) . toString ( ) ) ; assertEquals ( " foo " , as . getPlain ( ) ) ; assertEquals ( 3 , as . length ( ) ) ; } 
public void testCursorPosition ( ) { Ansi ansi = Ansi . ansi ( ) . cursor ( 3 , 6 ) . reset ( ) ; assertEquals ( " u001B[3;6H u001B[m " , ansi . toString ( ) ) ; } 
public void testSetEnabled ( ) throws InterruptedException { Ansi . setEnabled ( false ) ; Thread threadDisabled = new Thread ( ) { @Override public void run ( ) { System . out . println ( Ansi . ansi ( ) . fgRed ( ) . a ( " ANSI disabled " ) . reset ( ) ) ; assertFalse ( Ansi . isEnabled ( ) ) ; } } ; Ansi . setEnabled ( true ) ; Thread threadEnabled = new Thread ( ) { @Override public void run ( ) { System . out . println ( Ansi . ansi ( ) . fgBlue ( ) . a ( " ANSI enabled " ) . reset ( ) ) ; assertTrue ( Ansi . isEnabled ( ) ) ; } } ; Ansi . setEnabled ( false ) ; System . out . println ( Ansi . ansi ( ) . fgBlue ( ) . a ( " Ansi test thread start " ) . reset ( ) ) ; threadDisabled . start ( ) ; threadEnabled . start ( ) ; threadEnabled . join ( ) ; threadDisabled . join ( ) ; } 
public void run ( ) { System . out . println ( Ansi . ansi ( ) . fgRed ( ) . a ( " ANSI disabled " ) . reset ( ) ) ; assertFalse ( Ansi . isEnabled ( ) ) ; } 
public void run ( ) { System . out . println ( Ansi . ansi ( ) . fgBlue ( ) . a ( " ANSI enabled " ) . reset ( ) ) ; assertTrue ( Ansi . isEnabled ( ) ) ; } 
public void testClone ( ) { Ansi ansi = Ansi . ansi ( ) . a ( " Some text " ) . bg ( Color . BLACK ) . fg ( Color . WHITE ) ; Ansi clone = new Ansi ( ansi ) ; assertEquals ( ansi . a ( " test " ) . reset ( ) . toString ( ) , clone . a ( " test " ) . reset ( ) . toString ( ) ) ; } 
public void testErrorMessage ( ) { assumeTrue ( AnsiConsole . IS_WINDOWS ) ; String msg = WindowsSupport . getErrorMessage ( 500 ) ; assertEquals ( msg , " User profile cannot be loaded. " ) ; } 
public synchronized void write ( int data ) throws IOException { expected diff with AnsiPrintStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; } else { expected diff with AnsiPrintStream.java out.write(data); expected diff with AnsiPrintStream.java } break; expected diff with AnsiPrintStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(Integer.valueOf(0)); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(Integer.valueOf(1)); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(Character.valueOf((char) data)); reset(processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
protected synchronized boolean filter ( int data ) { expected diff with AnsiOutputStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; return false; expected diff with AnsiOutputStream.java } return true; expected diff with AnsiOutputStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(Integer.valueOf(0)); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(Integer.valueOf(1)); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(Character.valueOf((char) data)); reset(processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); } return false; expected diff with AnsiOutputStream.java } 
public static String render ( final String input ) throws IllegalArgumentException { try { return render ( input , new StringBuilder ( input . length ( ) ) ) . toString ( ) ; 
private CharSequence chew ( final CharSequence str ) { assert str ! = null ; ByteArrayOutputStream buff = new ByteArrayOutputStream ( str . length ( ) ) ; AnsiOutputStream out = new AnsiOutputStream ( buff ) ; try { out . write ( str . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return new String ( buff . toByteArray ( ) ) ; } 
private void write ( String s ) { char [ ] buf = ( s . length ( ) < strToCharBuffer . length ) ? strToCharBuffer : new char [ s . length ( ) ] ; s . getChars ( 0 , s . length ( ) , buf , 0 ) ; write ( buf ) ; } 
public void print ( char c ) { optim for: write(String.valueOf(c)); if (filter(c)) { 
private void write ( char buf [ ] , int len ) { for ( char c : buf ) { 
private void write ( String s ) { int len = s . length ( ) ; char [ ] buf = ( len < strToCharBuffer . length ) ? strToCharBuffer : new char [ len ] ; s . getChars ( 0 , len , buf , 0 ) ; write ( buf , len ) ; } 
private boolean processOperatingSystemCommand ( ArrayList < Object > options ) throws IOException { expected diff with AnsiPrintStream.java int command = optionInt(options, 0); String label = (String) options.get(1); for command > 2 label could be composed (i.e. contain ';'), but we'll leave it to processUnknownOperatingSystemCommand implementations to handle that try { switch (command) { case 0: ap.processChangeIconNameAndWindowTitle(label); return true; case 1: ap.processChangeIconName(label); return true; case 2: ap.processChangeWindowTitle(label); return true; default: not exactly unknown, but not supported through dedicated process methods: ap.processUnknownOperatingSystemCommand(command, label); return true; } } catch (IllegalArgumentException ignore) { } return false; } 
private boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; ap . processCharsetSelect ( set , seq ) ; return true ; } 
private boolean processOperatingSystemCommand ( ArrayList < Object > options ) { expected diff with AnsiOutputStream.java int command = optionInt(options, 0); String label = (String) options.get(1); for command > 2 label could be composed (i.e. contain ';'), but we'll leave it to processUnknownOperatingSystemCommand implementations to handle that try { switch (command) { case 0: ap.processChangeIconNameAndWindowTitle(label); return true; case 1: ap.processChangeIconName(label); return true; case 2: ap.processChangeWindowTitle(label); return true; default: not exactly unknown, but not supported through dedicated process methods: ap.processUnknownOperatingSystemCommand(command, label); return true; } } catch (IllegalArgumentException ignore) { } return false; } 
protected void processCursorDownLine ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { os.write(''); 
protected void processCursorRight ( int count ) throws IOException { Poor mans impl.. for (int i = 0; i < count; i++) { os.write(' '); 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processChangeIconName ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processSetAttribute ( int attribute ) throws IOException { switch ( attribute ) { case ATTRIBUTE_CONCEAL_ON : 
protected void processAttributeRest ( ) throws IOException { if ( concealOn ) { haos . write ( " u001B[0m " ) ; concealOn = false ; } haos . closeAttributes ( ) ; } 
protected void processSetForegroundColor ( int color , boolean bright ) throws IOException { haos . writeAttribute ( " span style= \" color: " + ANSI_COLOR_MAP [ color ] + " ; \" " ) ; } 
protected void processSetBackgroundColor ( int color , boolean bright ) throws IOException { haos . writeAttribute ( " span style= \" background-color: " + ANSI_COLOR_MAP [ color ] + " ; \" " ) ; } 
private void getConsoleInfo ( ) throws IOException { os . flush ( ) ; if ( GetConsoleScreenBufferInfo ( console , info ) = = 0 ) { throw new IOException ( " Could not get the screen info: " + WindowsSupport . getLastErrorMessage ( ) ) ; } if ( negative ) { info . attributes = invertAttributeColors ( info . attributes ) ; 
private void applyAttribute ( ) throws IOException { os . flush ( ) ; short attributes = info . attributes ; if ( negative ) { attributes = invertAttributeColors ( attributes ) ; } if ( SetConsoleTextAttribute ( console , attributes ) = = 0 ) { throw new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
protected void processRestoreCursorPosition ( ) throws IOException { restore only if there was a save operation first if (savedX != -1 && savedY != -1) { os.flush(); 
public synchronized void write ( int data ) throws IOException { expected diff with AnsiPrintStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; } else { expected diff with AnsiPrintStream.java out.write(data); expected diff with AnsiPrintStream.java } break; expected diff with AnsiPrintStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(Integer.valueOf(0)); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(Integer.valueOf(1)); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(ap.processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(ap.processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(ap.processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(Character.valueOf((char) data)); reset(ap.processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
protected synchronized boolean filter ( int data ) { expected diff with AnsiOutputStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; return false; expected diff with AnsiOutputStream.java } return true; expected diff with AnsiOutputStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(Integer.valueOf(0)); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(Integer.valueOf(1)); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add(Character.valueOf((char) data)); reset(ap.processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); } return false; expected diff with AnsiOutputStream.java } 
private boolean processEscapeCommand ( ArrayList < Object > options , int command ) { expected diff with AnsiOutputStream.java try { expected diff with AnsiOutputStream.java return ap.processEscapeCommand(options, command); expected diff with AnsiOutputStream.java } catch (IOException ioe) { expected diff with AnsiOutputStream.java setError(); expected diff with AnsiOutputStream.java } expected diff with AnsiOutputStream.java return false; expected diff with AnsiOutputStream.java } expected diff with AnsiOutputStream.java 
protected boolean processOperatingSystemCommand ( ArrayList < Object > options ) { expected diff with AnsiOutputStream.java int command = optionInt(options, 0); String label = (String) options.get(1); for command > 2 label could be composed (i.e. contain ';'), but we'll leave it to processUnknownOperatingSystemCommand implementations to handle that try { switch (command) { case 0: processChangeIconNameAndWindowTitle(label); return true; case 1: processChangeIconName(label); return true; case 2: processChangeWindowTitle(label); return true; default: not exactly unknown, but not supported through dedicated process methods: processUnknownOperatingSystemCommand(command, label); return true; } } catch (IllegalArgumentException ignore) { } return false; } 
protected boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( ( Character ) options . get ( 1 ) ) . charValue ( ) ; processCharsetSelect ( set , seq ) ; return true ; } 
public Ansi bgBrightCyan ( ) { return this . bgBright ( Color . CYAN ) ; } 
public Ansi bgBrightMagenta ( ) { return this . bgBright ( Color . MAGENTA ) ; } 
public synchronized void write ( int data ) throws IOException { expected diff with AnsiPrintStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; } else { expected diff with AnsiPrintStream.java out.write(data); expected diff with AnsiPrintStream.java } break; expected diff with AnsiPrintStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(0); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(1); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(ap.processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(ap.processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(ap.processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add((char) data); reset(ap.processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
protected synchronized boolean filter ( int data ) { expected diff with AnsiOutputStream.java switch (state) { case LOOKING_FOR_FIRST_ESC_CHAR: if (data == FIRST_ESC_CHAR) { buffer[pos++] = (byte) data; state = LOOKING_FOR_SECOND_ESC_CHAR; return false; expected diff with AnsiOutputStream.java } return true; expected diff with AnsiOutputStream.java case LOOKING_FOR_SECOND_ESC_CHAR: buffer[pos++] = (byte) data; if (data == SECOND_ESC_CHAR) { state = LOOKING_FOR_NEXT_ARG; } else if (data == SECOND_OSC_CHAR) { state = LOOKING_FOR_OSC_COMMAND; } else if (data == SECOND_CHARSET0_CHAR) { options.add(Integer.valueOf(0)); state = LOOKING_FOR_CHARSET; } else if (data == SECOND_CHARSET1_CHAR) { options.add(Integer.valueOf(1)); state = LOOKING_FOR_CHARSET; } else { reset(false); } break; case LOOKING_FOR_NEXT_ARG: buffer[pos++] = (byte) data; if ('"' == data) { startOfValue = pos - 1; state = LOOKING_FOR_STR_ARG_END; } else if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_INT_ARG_END; } else if (';' == data) { options.add(null); } else if ('?' == data) { options.add('?'); } else if ('=' == data) { options.add('='); } else { reset(processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } break; default: break; case LOOKING_FOR_INT_ARG_END: buffer[pos++] = (byte) data; if (!('0' <= data && data <= '9')) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } } break; case LOOKING_FOR_STR_ARG_END: buffer[pos++] = (byte) data; if ('"' != data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); if (data == ';') { state = LOOKING_FOR_NEXT_ARG; } else { reset(processEscapeCommand(options, data)); expected diff with AnsiOutputStream.java } } break; case LOOKING_FOR_OSC_COMMAND: buffer[pos++] = (byte) data; if ('0' <= data && data <= '9') { startOfValue = pos - 1; state = LOOKING_FOR_OSC_COMMAND_END; } else { reset(false); } break; case LOOKING_FOR_OSC_COMMAND_END: buffer[pos++] = (byte) data; if (';' == data) { String strValue = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); Integer value = Integer.valueOf(strValue); options.add(value); startOfValue = pos; state = LOOKING_FOR_OSC_PARAM; } else if ('0' <= data && data <= '9') { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, Charset.defaultCharset()); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, Charset.defaultCharset()); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add((char) data); reset(ap.processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); } return false; expected diff with AnsiOutputStream.java } 
protected boolean processCharsetSelect ( ArrayList < Object > options ) { int set = optionInt ( options , 0 ) ; char seq = ( Character ) options . get ( 1 ) ; processCharsetSelect ( set , seq ) ; return true ; } 
private static PrintStream optimize ( PrintStream original , PrintStream wrapped ) { try { OutputStream out = original ; while ( out instanceof FilterOutputStream ) { out = field ( FilterOutputStream . class , out , " out " ) ; } if ( wrapped instanceof AnsiPrintStream ) { AnsiProcessor ap = field ( AnsiPrintStream . class , wrapped , " ap " ) ; out = new AnsiNoSyncOutputStream ( new BufferedNoSyncOutputStream ( out ) , ap ) ; } grab charset OutputStreamWriter charOut = field(PrintStream.class, original, "charOut"); Object se = field(OutputStreamWriter.class, charOut, "se"); Charset cs = field(se.getClass(), se, "cs"); create print stream wrapped = new PrintStream(new BufferedOutputStream(out), true, cs.name()) { @Override public void close() { write(AnsiNoSyncOutputStream.RESET_CODE, 0, AnsiNoSyncOutputStream.RESET_CODE.length); super.close(); } }; } catch (Exception e) { ignore } return wrapped; } 
public void close ( ) { write ( AnsiNoSyncOutputStream . RESET_CODE , 0 , AnsiNoSyncOutputStream . RESET_CODE . length ) ; super . close ( ) ; } 
private static < T , O > T field ( Class < O > oClass , Object obj , String name ) throws Exception { Field f = oClass . getDeclaredField ( name ) ; f . setAccessible ( true ) ; return ( T ) f . get ( obj ) ; } 
public void write ( int data ) throws IOException { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; } else { out . write ( data ) ; } break ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else if ( data = = SECOND_CHARSET0_CHAR ) { options . add ( 0 ) ; state = LOOKING_FOR_CHARSET ; } else if ( data = = SECOND_CHARSET1_CHAR ) { options . add ( 1 ) ; state = LOOKING_FOR_CHARSET ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( '?' ) ; } else if ( '=' = = data ) { options . add ( '=' ) ; } else { reset ( ap . processEscapeCommand ( options , data ) ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue ) ; Integer value = Integer . valueOf ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( ap . processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( ap . processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue ) ; Integer value = Integer . valueOf ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add((char) data); reset(ap.processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
public void write ( int b ) throws IOException { if ( count > = buf . length ) { flushBuffer ( ) ; } buf [ count + + ] = ( byte ) b ; } 
public void write ( byte b [ ] , int off , int len ) throws IOException { if ( len > = buf . length ) { flushBuffer ( ) ; out . write ( b , off , len ) ; return ; } if ( len > buf . length - count ) { flushBuffer ( ) ; } System . arraycopy ( b , off , buf , count , len ) ; count + = len ; } 
private void flushBuffer ( ) throws IOException { if ( count > 0 ) { out . write ( buf , 0 , count ) ; 
public void flush ( ) throws IOException { flushBuffer ( ) ; out . flush ( ) ; } 
private static PrintStream newPrintStream ( OutputStream out , String enc ) { return newPrintStream ( out , enc , null ) ; } 
private static PrintStream newPrintStream ( OutputStream out , String enc , byte [ ] reset ) { if ( enc ! = null ) { try { return new ResetAtClosePrintStream ( out , enc , reset ) ; } catch ( UnsupportedEncodingException e ) { } } return new ResetAtClosePrintStream ( out , reset ) ; } 
public void close ( ) { if ( reset ! = null ) { write ( reset , 0 , reset . length ) ; } super . close ( ) ; } 
public void write ( int data ) throws IOException { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; } else { out . write ( data ) ; } break ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else if ( data = = SECOND_CHARSET0_CHAR ) { options . add ( 0 ) ; state = LOOKING_FOR_CHARSET ; } else if ( data = = SECOND_CHARSET1_CHAR ) { options . add ( 1 ) ; state = LOOKING_FOR_CHARSET ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( '?' ) ; } else if ( '=' = = data ) { options . add ( '=' ) ; } else { reset ( ap . processEscapeCommand ( options , data ) ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue ) ; Integer value = Integer . valueOf ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( ap . processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , cs ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { reset ( ap . processEscapeCommand ( options , data ) ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue ) ; Integer value = Integer . valueOf ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, cs); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, cs); options.add(value); reset(ap.processOperatingSystemCommand(options)); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add((char) data); reset(ap.processCharsetSelect(options)); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
protected void processChangeWindowTitle ( String label ) { newLabel . set ( label ) ; } 
private static native void init ( ) ; public static int STDOUT_FILENO = 1 ; public static int STDERR_FILENO = 2 ; public static boolean HAVE_ISATTY ; public static boolean HAVE_TTYNAME ; public static int TCSANOW ; public static int TCSADRAIN ; public static int TCSAFLUSH ; public static long TIOCGETA ; public static long TIOCSETA ; public static long TIOCGETD ; public static long TIOCSETD ; public static long TIOCGWINSZ ; public static long TIOCSWINSZ ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int isatty ( int fd ) ; public static native String ttyname ( int filedes ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native String ttyname ( int filedes ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int openpty ( int [ ] amaster , int [ ] aslave , byte [ ] name , Termios termios , WinSize winsize ) ; public static native int tcgetattr ( int filedes , Termios termios ) ; public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int tcgetattr ( int filedes , Termios termios ) ; public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int ioctl ( int filedes , long request , int [ ] params ) ; public static native int ioctl ( int filedes , long request , WinSize params ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int ioctl ( int filedes , long request , WinSize params ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
private static native void init ( ) ; public static int SIZEOF ; public short ws_row ; public short ws_col ; public short ws_xpixel ; public short ws_ypixel ; public WinSize ( ) { } public WinSize ( short ws_row , short ws_col ) { this . ws_row = ws_row ; this . ws_col = ws_col ; } } public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static synchronized boolean initialize ( ) { only cleanup before the first extract if (!extracted) { cleanup(); } try { loadJansiNativeLibrary(); } catch (Exception e) { throw new RuntimeException("Unable to load jansi native library", e); } return extracted; } 
static void cleanup ( ) { String tempFolder = getTempDir ( ) . getAbsolutePath ( ) ; File dir = new File ( tempFolder ) ; File [ ] nativeLibFiles = dir . listFiles ( new FilenameFilter ( ) { private final String searchPattern = " jansi- " + getVersion ( ) ; public boolean accept ( File dir , String name ) { return name . startsWith ( searchPattern ) & & ! name . endsWith ( " .lck " ) ; } } ) ; if ( nativeLibFiles ! = null ) { for ( File nativeLibFile : nativeLibFiles ) { 
public boolean accept ( File dir , String name ) { return name . startsWith ( searchPattern ) & & ! name . endsWith ( " .lck " ) ; } 
private static boolean contentsEquals ( InputStream in1 , InputStream in2 ) throws IOException { byte [ ] buffer1 = new byte [ 8192 ] ; byte [ ] buffer2 = new byte [ 8192 ] ; int numRead1 = 0 ; int numRead2 = 0 ; while ( true ) { numRead1 = in1 . read ( buffer1 ) ; 
private static boolean extractAndLoadLibraryFile ( String libFolderForCurrentOS , String libraryFileName , String targetFolder ) { String nativeLibraryFilePath = libFolderForCurrentOS + " / " + libraryFileName ; Include architecture name in temporary filename in order to avoid conflicts when multiple JVMs with different architectures running at the same time String uuid = UUID.randomUUID().toString(); String extractedLibFileName = String.format("jansi-%s-%s-%s", getVersion(), uuid, libraryFileName); String extractedLckFileName = extractedLibFileName + ".lck"; File extractedLibFile = new File(targetFolder, extractedLibFileName); File extractedLckFile = new File(targetFolder, extractedLckFileName); try { Extract a native library file into the target directory InputStream in = JansiLoader.class.getResourceAsStream(nativeLibraryFilePath); try { if (!extractedLckFile.exists()) { new FileOutputStream(extractedLckFile).close(); } OutputStream out = new BufferedOutputStream(new FileOutputStream(extractedLibFile)); try { copy(in, out); } finally { out.close(); } } finally { Delete the extracted lib file on JVM exit. extractedLibFile.deleteOnExit(); extractedLckFile.deleteOnExit(); in.close(); } Set executable (x) flag to enable Java to load the native library extractedLibFile.setReadable(true); extractedLibFile.setWritable(true, true); extractedLibFile.setExecutable(true); Check whether the contents are properly copied from the resource folder InputStream nativeIn = JansiLoader.class.getResourceAsStream(nativeLibraryFilePath); try { InputStream extractedLibIn = new FileInputStream(extractedLibFile); try { if (!contentsEquals(nativeIn, extractedLibIn)) { throw new RuntimeException(String.format("Failed to write a native library file at %s", extractedLibFile)); } } finally { extractedLibIn.close(); } } finally { nativeIn.close(); } Load library if (loadNativeLibrary(extractedLibFile)) { nativeLibrarySourceUrl = JansiLoader.class.getResource(nativeLibraryFilePath).toExternalForm(); return true; } } catch (IOException e) { System.err.println(e.getMessage()); } return false; } 
private static void copy ( InputStream in , OutputStream out ) throws IOException { byte [ ] buf = new byte [ 8192 ] ; int ; while ( ( = in . read ( buf ) ) > 0 ) { out . write ( buf , 0 , ) ; 
private static boolean loadNativeLibrary ( File libPath ) { if ( libPath . exists ( ) ) { 
private static void loadJansiNativeLibrary ( ) throws Exception { if ( extracted ) { return ; } List < String > triedPaths = new LinkedList < String > ( ) ; Try loading library from library.jansi.path library path */ String jansiNativeLibraryPath = System.getProperty("library.jansi.path"); String jansiNativeLibraryName = System.getProperty("library.jansi.name"); if (jansiNativeLibraryName == null) { jansiNativeLibraryName = System.mapLibraryName("jansi"); if (jansiNativeLibraryName != null && jansiNativeLibraryName.endsWith(".dylib")) { jansiNativeLibraryName = jansiNativeLibraryName.replace(".dylib", ".jnilib"); } } if (jansiNativeLibraryPath != null) { String withOs = jansiNativeLibraryPath + "/" + OSInfo.getNativeLibFolderPathForCurrentOS(); if (loadNativeLibrary(new File(withOs, jansiNativeLibraryName))) { extracted = true; return; } else { triedPaths.add(withOs); } if (loadNativeLibrary(new File(jansiNativeLibraryPath, jansiNativeLibraryName))) { extracted = true; return; } else { triedPaths.add(jansiNativeLibraryPath); } } Load the os-dependent library from the jar file String packagePath = JansiLoader.class.getPackage().getName().replace('.', '/'); jansiNativeLibraryPath = String.format("/%s/native/%s", packagePath, OSInfo.getNativeLibFolderPathForCurrentOS()); boolean hasNativeLib = hasResource(jansiNativeLibraryPath + "/" + jansiNativeLibraryName); if (hasNativeLib) { temporary library folder String tempFolder = getTempDir().getAbsolutePath(); Try extracting the library from jar if (extractAndLoadLibraryFile(jansiNativeLibraryPath, jansiNativeLibraryName, tempFolder)) { extracted = true; return; } else { triedPaths.add(jansiNativeLibraryPath); } } As a last resort try from java.library.path String javaLibraryPath = System.getProperty("java.library.path", ""); for (String ldPath : javaLibraryPath.split(File.pathSeparator)) { if (ldPath.isEmpty()) { continue; } if (loadNativeLibrary(new File(ldPath, jansiNativeLibraryName))) { extracted = true; return; } else { triedPaths.add(ldPath); } } extracted = false; throw new Exception(String.format("No native library found for os.name=%s, os.arch=%s, paths=[%s]", OSInfo.getOSName(), OSInfo.getArchName(), join(triedPaths, File.pathSeparator))); 
private static boolean hasResource ( String path ) { return JansiLoader . class . getResource ( path ) ! = null ; } 
private static String join ( List < String > list , String separator ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = true ; for ( String item : list ) { if ( first ) first = false ; else sb . append ( separator ) ; sb . append ( item ) ; } return sb . toString ( ) ; } 
public short width ( ) { return ( short ) ( right - left ) ; } 
public short height ( ) { return ( short ) ( bottom - top ) ; } 
public SMALL_RECT copy ( ) { SMALL_RECT rc = new SMALL_RECT ( ) ; rc . left = left ; rc . top = top ; rc . right = right ; rc . bottom = bottom ; return rc ; } 
public COORD copy ( ) { COORD rc = new COORD ( ) ; rc . x = x ; rc . y = y ; return rc ; } 
public static native int GetConsoleMode ( long handle , int [ ] mode ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleMode ( long handle , int mode ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int _getch ( ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleTitle ( String title ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int GetConsoleOutputCP ( ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleOutputCP ( int codePageID ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public short attributes ; public char unicodeChar ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int ScrollConsoleScreenBuffer ( long consoleOutput , SMALL_RECT scrollRectangle , SMALL_RECT clipRectangle , COORD destinationOrigin , CHAR_INFO fill ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public static int CAPSLOCK_ON ; public static int NUMLOCK_ON ; public static int SCROLLLOCK_ON ; public static int ENHANCED_KEY ; public static int LEFT_ALT_PRESSED ; public static int LEFT_CTRL_PRESSED ; public static int RIGHT_ALT_PRESSED ; public static int RIGHT_CTRL_PRESSED ; public static int SHIFT_PRESSED ; public boolean keyDown ; public short repeatCount ; public short keyCode ; public short scanCode ; public char uchar ; public int controlKeyState ; public String toString ( ) { return " KEY_EVENT_RECORD{ " + " keyDown= " + keyDown + " , repeatCount= " + repeatCount + " , keyCode= " + keyCode + " , scanCode= " + scanCode + " , uchar= " + uchar + " , controlKeyState= " + controlKeyState + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public String toString ( ) { return " KEY_EVENT_RECORD{ " + " keyDown= " + keyDown + 
private static native void init ( ) ; public static int SIZEOF ; public static int FROM_LEFT_1ST_BUTTON_PRESSED ; public static int FROM_LEFT_2ND_BUTTON_PRESSED ; public static int FROM_LEFT_3RD_BUTTON_PRESSED ; public static int FROM_LEFT_4TH_BUTTON_PRESSED ; public static int RIGHTMOST_BUTTON_PRESSED ; public static int CAPSLOCK_ON ; public static int NUMLOCK_ON ; public static int SCROLLLOCK_ON ; public static int ENHANCED_KEY ; public static int LEFT_ALT_PRESSED ; public static int LEFT_CTRL_PRESSED ; public static int RIGHT_ALT_PRESSED ; public static int RIGHT_CTRL_PRESSED ; public static int SHIFT_PRESSED ; public static int DOUBLE_CLICK ; public static int MOUSE_HWHEELED ; public static int MOUSE_MOVED ; public static int MOUSE_WHEELED ; public COORD mousePosition = new COORD ( ) ; public int buttonState ; public int controlKeyState ; public int eventFlags ; public String toString ( ) { return " MOUSE_EVENT_RECORD{ " + " mousePosition= " + mousePosition + " , buttonState= " + buttonState + " , controlKeyState= " + controlKeyState + " , eventFlags= " + eventFlags + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public String toString ( ) { return " MOUSE_EVENT_RECORD{ " + " mousePosition= " + mousePosition + 
private static native void init ( ) ; public static int SIZEOF ; public COORD size = new COORD ( ) ; public String toString ( ) { return " WINDOW_BUFFER_SIZE_RECORD{size= " + size + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public String toString ( ) { return " WINDOW_BUFFER_SIZE_RECORD{size= " + size + '}' ; } 
private static native void init ( ) ; public static int SIZEOF ; public boolean setFocus ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public int commandId ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public static short KEY_EVENT ; public static short MOUSE_EVENT ; public static short WINDOW_BUFFER_SIZE_EVENT ; public static short FOCUS_EVENT ; public static short MENU_EVENT ; public short eventType ; public KEY_EVENT_RECORD keyEvent = new KEY_EVENT_RECORD ( ) ; public MOUSE_EVENT_RECORD mouseEvent = new MOUSE_EVENT_RECORD ( ) ; public WINDOW_BUFFER_SIZE_RECORD windowBufferSizeEvent = new WINDOW_BUFFER_SIZE_RECORD ( ) ; public MENU_EVENT_RECORD menuEvent = new MENU_EVENT_RECORD ( ) ; public FOCUS_EVENT_RECORD focusEvent = new FOCUS_EVENT_RECORD ( ) ; public static native void memmove ( INPUT_RECORD dest , long src , long size ) ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native void memmove ( INPUT_RECORD dest , long src , long size ) ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native int ReadConsoleInputW ( long handle , long inputRecord , int length , int [ ] eventsCount ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native int PeekConsoleInputW ( long handle , long inputRecord , int length , int [ ] eventsCount ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int GetNumberOfConsoleInputEvents ( long handle , int [ ] numberOfEvents ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int FlushConsoleInputBuffer ( long handle ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static INPUT_RECORD [ ] readConsoleInputHelper ( long handle , int count , boolean peek ) throws IOException { int [ ] length = new int [ 1 ] ; int res ; long inputRecordPtr = 0 ; try { inputRecordPtr = malloc ( INPUT_RECORD . SIZEOF * count ) ; 
public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full 
public static void main ( String [ ] args ) { if ( args . length > = 1 ) { if ( " --os " . equals ( args [ 0 ] ) ) { System . out . print ( getOSName ( ) ) ; return ; } else if ( " --arch " . equals ( args [ 0 ] ) ) { System . out . print ( getArchName ( ) ) ; return ; } } System . out . print ( getNativeLibFolderPathForCurrentOS ( ) ) ; } 
public static boolean isAndroid ( ) { return System . getProperty ( " java.runtime.name " , " " ) . toLowerCase ( ) . contains ( " android " ) ; } 
public static boolean isAlpine ( ) { try { Process p = Runtime . getRuntime ( ) . exec ( " cat /etc/os-release | grep ^ID " ) ; 
private static String readFully ( InputStream in ) throws IOException { int readLen = 0 ; ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; byte [ ] buf = new byte [ 32 ] ; while ( ( readLen = in . read ( buf , 0 , buf . length ) ) > = 0 ) { b . write ( buf , 0 , readLen ) ; } return b . toString ( ) ; } 
static String translateOSNameToFolderName ( String osName ) { if ( osName . contains ( " Windows " ) ) { return " Windows " ; 
static String translateArchNameToFolderName ( String archName ) { return archName . replaceAll ( " \\ W " , " " ) ; } 
public static int writeConsole ( String msg ) { long hConsole = GetStdHandle ( STD_OUTPUT_HANDLE ) ; if ( hConsole = = INVALID_HANDLE_VALUE ) return 0 ; char [ ] chars = msg . toCharArray ( ) ; int [ ] written = new int [ 1 ] ; if ( WriteConsoleW ( hConsole , chars , chars . length , written , 0 ) ! = 0 ) { return written [ 0 ] ; 
public static INPUT_RECORD [ ] readConsoleInput ( int count , int dwMilliseconds ) throws IOException { long hConsole = GetStdHandle ( STD_INPUT_HANDLE ) ; if ( hConsole = = INVALID_HANDLE_VALUE ) return null ; if ( WaitForSingleObject ( hConsole , dwMilliseconds ) ! = 0 ) return null ; return readConsoleInputHelper ( hConsole , count , false ) ; } 
public static INPUT_RECORD [ ] readConsoleInput ( int count ) throws IOException { long hConsole = GetStdHandle ( STD_INPUT_HANDLE ) ; if ( hConsole = = INVALID_HANDLE_VALUE ) return null ; return readConsoleInputHelper ( hConsole , count , false ) ; } 
public static INPUT_RECORD [ ] peekConsoleInput ( int count , int dwMilliseconds ) throws IOException { long hConsole = GetStdHandle ( STD_INPUT_HANDLE ) ; if ( hConsole = = INVALID_HANDLE_VALUE ) return null ; if ( WaitForSingleObject ( hConsole , dwMilliseconds ) ! = 0 ) return null ; return readConsoleInputHelper ( hConsole , count , true ) ; } 
public static INPUT_RECORD [ ] peekConsoleInput ( int count ) throws IOException { long hConsole = GetStdHandle ( STD_INPUT_HANDLE ) ; if ( hConsole = = INVALID_HANDLE_VALUE ) return null ; return readConsoleInputHelper ( hConsole , count , true ) ; } 
public static void flushConsoleInputBuffer ( ) { long hConsole = GetStdHandle ( STD_INPUT_HANDLE ) ; if ( hConsole = = INVALID_HANDLE_VALUE ) return ; FlushConsoleInputBuffer ( hConsole ) ; } 
public void testLoadJansi ( ) { JansiLoader . initialize ( ) ; } 
private static int readNBytes ( InputStream in , byte [ ] b ) throws IOException { int = 0 ; int len = b . length ; while ( < len ) { int count = in . read ( b , , len - ) ; if ( count < = 0 ) break ; + = count ; } return ; } 
private static String contentsEquals ( InputStream in1 , InputStream in2 ) throws IOException { byte [ ] buffer1 = new byte [ 8192 ] ; byte [ ] buffer2 = new byte [ 8192 ] ; int numRead1 ; int numRead2 ; while ( true ) { numRead1 = readNBytes ( in1 , buffer1 ) ; 
private static boolean extractAndLoadLibraryFile ( String libFolderForCurrentOS , String libraryFileName , String targetFolder ) { String nativeLibraryFilePath = libFolderForCurrentOS + " / " + libraryFileName ; Include architecture name in temporary filename in order to avoid conflicts when multiple JVMs with different architectures running at the same time String uuid = UUID.randomUUID().toString(); String extractedLibFileName = String.format("jansi-%s-%s-%s", getVersion(), uuid, libraryFileName); String extractedLckFileName = extractedLibFileName + ".lck"; File extractedLibFile = new File(targetFolder, extractedLibFileName); File extractedLckFile = new File(targetFolder, extractedLckFileName); try { Extract a native library file into the target directory InputStream in = JansiLoader.class.getResourceAsStream(nativeLibraryFilePath); try { if (!extractedLckFile.exists()) { new FileOutputStream(extractedLckFile).close(); } OutputStream out = new FileOutputStream(extractedLibFile); try { copy(in, out); } finally { out.close(); } } finally { Delete the extracted lib file on JVM exit. extractedLibFile.deleteOnExit(); extractedLckFile.deleteOnExit(); in.close(); } Set executable (x) flag to enable Java to load the native library extractedLibFile.setReadable(true); extractedLibFile.setWritable(true, true); extractedLibFile.setExecutable(true); Check whether the contents are properly copied from the resource folder InputStream nativeIn = JansiLoader.class.getResourceAsStream(nativeLibraryFilePath); try { InputStream extractedLibIn = new FileInputStream(extractedLibFile); try { String eq = contentsEquals(nativeIn, extractedLibIn); if (eq != null) { throw new RuntimeException(String.format("Failed to write a native library file at %s because %s", extractedLibFile, eq)); } } finally { extractedLibIn.close(); } } finally { nativeIn.close(); } Load library if (loadNativeLibrary(extractedLibFile)) { nativeLibrarySourceUrl = JansiLoader.class.getResource(nativeLibraryFilePath).toExternalForm(); return true; } } catch (IOException e) { System.err.println(e.getMessage()); } return false; } 
protected boolean processOperatingSystemCommand ( ArrayList < Object > options ) { int command = optionInt ( options , 0 ) ; String label = ( String ) options . get ( 1 ) ; for command > 2 label could be composed (i.e. contain ';'), but we'll leave it to processUnknownOperatingSystemCommand implementations to handle that try { switch (command) { case 0: processChangeIconNameAndWindowTitle(label); return true; case 1: processChangeIconName(label); return true; case 2: processChangeWindowTitle(label); return true; default: not exactly unknown, but not supported through dedicated process methods: processUnknownOperatingSystemCommand(command, label); return true; } } catch (IllegalArgumentException ignore) { } return false; } 
public static PrintStream out ( ) { initStreams ( ) ; return out ; } 
public static PrintStream err ( ) { initStreams ( ) ; return err ; } 
synchronized static public void systemInstall ( ) { installed + + ; if ( installed = = 1 ) { initStreams ( ) ; 
synchronized static public void systemReinstall ( ) { if ( installed > 0 ) { initialized = false ; 
synchronized static void initStreams ( ) { if ( ! initialized ) { 
public Ansi cursorToColumn ( final int x ) { return x > = 0 ? appendEscapeSequence ( 'G' , x ) : this ; } 
public Ansi cursorDown ( final int y ) { return y > 0 ? appendEscapeSequence ( 'B' , y ) : this ; } 
public Ansi cursorRight ( final int x ) { return x > 0 ? appendEscapeSequence ( 'C' , x ) : this ; } 
public Ansi cursorLeft ( final int x ) { return x > 0 ? appendEscapeSequence ( 'D' , x ) : this ; } 
public Ansi cursorDownLine ( final int ) { return > 0 ? appendEscapeSequence ( 'E' , ) : this ; } 
public Ansi cursorUpLine ( final int ) { return > 0 ? appendEscapeSequence ( 'F' , ) : this ; } 
public Ansi scrollUp ( final int rows ) { return rows > 0 ? appendEscapeSequence ( 'S' , rows ) : this ; } 
public Ansi scrollDown ( final int rows ) { return rows > 0 ? appendEscapeSequence ( 'T' , rows ) : this ; } 
public Ansi append ( CharSequence csq ) { builder . append ( csq ) ; return this ; } 
public Ansi append ( CharSequence csq , int start , int end ) { builder . append ( csq , start , end ) ; return this ; } 
public Ansi append ( char c ) { builder . append ( c ) ; return this ; } 
protected void processCursorUpLine ( int count ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . x = 0 ; info . cursorPosition . y = ( short ) Math . max ( info . window . top , info . cursorPosition . y - count ) ; applyCursorPosition ( ) ; } 
protected void processCursorDownLine ( int count ) throws IOException { getConsoleInfo ( ) ; info . cursorPosition . x = 0 ; info . cursorPosition . y = ( short ) Math . max ( info . window . top , info . cursorPosition . y + count ) ; applyCursorPosition ( ) ; } 
private static boolean extractAndLoadLibraryFile ( String libFolderForCurrentOS , String libraryFileName , String targetFolder ) { String nativeLibraryFilePath = libFolderForCurrentOS + " / " + libraryFileName ; Include architecture name in temporary filename in order to avoid conflicts when multiple JVMs with different architectures running at the same time String uuid = randomUUID(); String extractedLibFileName = String.format("jansi-%s-%s-%s", getVersion(), uuid, libraryFileName); String extractedLckFileName = extractedLibFileName + ".lck"; File extractedLibFile = new File(targetFolder, extractedLibFileName); File extractedLckFile = new File(targetFolder, extractedLckFileName); try { Extract a native library file into the target directory InputStream in = JansiLoader.class.getResourceAsStream(nativeLibraryFilePath); try { if (!extractedLckFile.exists()) { new FileOutputStream(extractedLckFile).close(); } OutputStream out = new FileOutputStream(extractedLibFile); try { copy(in, out); } finally { out.close(); } } finally { Delete the extracted lib file on JVM exit. extractedLibFile.deleteOnExit(); extractedLckFile.deleteOnExit(); in.close(); } Set executable (x) flag to enable Java to load the native library extractedLibFile.setReadable(true); extractedLibFile.setWritable(true, true); extractedLibFile.setExecutable(true); Check whether the contents are properly copied from the resource folder InputStream nativeIn = JansiLoader.class.getResourceAsStream(nativeLibraryFilePath); try { InputStream extractedLibIn = new FileInputStream(extractedLibFile); try { String eq = contentsEquals(nativeIn, extractedLibIn); if (eq != null) { throw new RuntimeException(String.format("Failed to write a native library file at %s because %s", extractedLibFile, eq)); } } finally { extractedLibIn.close(); } } finally { nativeIn.close(); } Load library if (loadNativeLibrary(extractedLibFile)) { nativeLibrarySourceUrl = JansiLoader.class.getResource(nativeLibraryFilePath).toExternalForm(); return true; } } catch (IOException e) { System.err.println(e.getMessage()); } return false; } 
private static String randomUUID ( ) { return Long . toHexString ( new Random ( ) . nextLong ( ) ) ; } 
public void write ( int data ) throws IOException { switch ( state ) { case LOOKING_FOR_FIRST_ESC_CHAR : if ( data = = FIRST_ESC_CHAR ) { buffer [ pos + + ] = ( byte ) data ; state = LOOKING_FOR_SECOND_ESC_CHAR ; } else { out . write ( data ) ; } break ; case LOOKING_FOR_SECOND_ESC_CHAR : buffer [ pos + + ] = ( byte ) data ; if ( data = = SECOND_ESC_CHAR ) { state = LOOKING_FOR_NEXT_ARG ; } else if ( data = = SECOND_OSC_CHAR ) { state = LOOKING_FOR_OSC_COMMAND ; } else if ( data = = SECOND_CHARSET0_CHAR ) { options . add ( 0 ) ; state = LOOKING_FOR_CHARSET ; } else if ( data = = SECOND_CHARSET1_CHAR ) { options . add ( 1 ) ; state = LOOKING_FOR_CHARSET ; } else { reset ( false ) ; } break ; case LOOKING_FOR_NEXT_ARG : buffer [ pos + + ] = ( byte ) data ; if ( '"' = = data ) { startOfValue = pos - 1 ; state = LOOKING_FOR_STR_ARG_END ; } else if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_INT_ARG_END ; } else if ( ';' = = data ) { options . add ( null ) ; } else if ( '?' = = data ) { options . add ( '?' ) ; } else if ( '=' = = data ) { options . add ( '=' ) ; } else { processEscapeCommand ( data ) ; } break ; default : break ; case LOOKING_FOR_INT_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( ! ( '0' < = data & & data < = '9' ) ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue ) ; Integer value = Integer . valueOf ( strValue ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { processEscapeCommand ( data ) ; } } break ; case LOOKING_FOR_STR_ARG_END : buffer [ pos + + ] = ( byte ) data ; if ( '"' ! = data ) { String value = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue , cs ) ; options . add ( value ) ; if ( data = = ';' ) { state = LOOKING_FOR_NEXT_ARG ; } else { processEscapeCommand ( data ) ; } } break ; case LOOKING_FOR_OSC_COMMAND : buffer [ pos + + ] = ( byte ) data ; if ( '0' < = data & & data < = '9' ) { startOfValue = pos - 1 ; state = LOOKING_FOR_OSC_COMMAND_END ; } else { reset ( false ) ; } break ; case LOOKING_FOR_OSC_COMMAND_END : buffer [ pos + + ] = ( byte ) data ; if ( ';' = = data ) { String strValue = new String ( buffer , startOfValue , ( pos - 1 ) - startOfValue ) ; Integer value = Integer . valueOf ( strValue ) ; options . add ( value ) ; startOfValue = pos ; state = LOOKING_FOR_OSC_PARAM ; } else if ( '0' < = data & & data < = '9' ) { already pushed digit to buffer, just keep looking } else { oops, did not expect this reset(false); } break; case LOOKING_FOR_OSC_PARAM: buffer[pos++] = (byte) data; if (BEL == data) { String value = new String(buffer, startOfValue, (pos - 1) - startOfValue, cs); options.add(value); processOperatingSystemCommand(); } else if (FIRST_ESC_CHAR == data) { state = LOOKING_FOR_ST; } else { just keep looking while adding text } break; case LOOKING_FOR_ST: buffer[pos++] = (byte) data; if (SECOND_ST_CHAR == data) { String value = new String(buffer, startOfValue, (pos - 2) - startOfValue, cs); options.add(value); processOperatingSystemCommand(); } else { state = LOOKING_FOR_OSC_PARAM; } break; case LOOKING_FOR_CHARSET: options.add((char) data); processCharsetSelect(); break; } Is it just too long? if (pos >= buffer.length) { reset(false); 
private void processCharsetSelect ( ) throws IOException { try { reset ( ap . processCharsetSelect ( options ) ) ; 
private void processOperatingSystemCommand ( ) throws IOException { try { reset ( ap . processOperatingSystemCommand ( options ) ) ; 
private void processEscapeCommand ( int data ) throws IOException { try { reset ( ap . processEscapeCommand ( options , data ) ) ; 
private static void printJansiLogoDemo ( ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( AnsiMain . class . getResourceAsStream ( " jansi.txt " ) , " UTF-8 " ) ) ; try { String l ; 
protected void processAttributeReset ( ) throws IOException { info . attributes = ( short ) ( ( info . attributes & ~ 0x00FF ) | originalColors ) ; this . negative = false ; applyAttribute ( ) ; } 
synchronized public static boolean isInstalled ( ) { return installed > 0 ; } 
public static void main ( String [ ] args ) { print ( System . out , " Lorem ipsum " ) ; print ( System . err , " dolor sit amet " ) ; AnsiConsole . systemInstall ( ) ; print ( System . out , " consectetur adipiscing elit " ) ; print ( System . err , " sed do eiusmod " ) ; AnsiConsole . out ( ) . setAnsiMode ( AnsiMode . Strip ) ; AnsiConsole . err ( ) . setAnsiMode ( AnsiMode . Strip ) ; print ( System . out , " tempor incididunt ut " ) ; print ( System . err , " labore et dolore " ) ; AnsiConsole . systemUninstall ( ) ; print ( System . out , " magna aliqua. " ) ; print ( System . err , " Ut enim ad " ) ; } 
private static void print ( PrintStream stream , String text ) { int half = text . length ( ) / 2 ; stream . print ( text . substring ( 0 , half ) ) ; stream . println ( Ansi . ansi ( ) . fg ( Ansi . Color . GREEN ) . a ( text . substring ( half ) ) . reset ( ) ) ; } 
public void run ( ) throws IOException { virtualProcessing + + ; SetConsoleMode ( console , mode [ 0 ] | ENABLE_VIRTUAL_TERMINAL_PROCESSING ) ; } 
public void run ( ) throws IOException { if ( - - virtualProcessing = = 0 ) { SetConsoleMode ( console , mode [ 0 ] ) ; 
private static AnsiPrintStream newPrintStream ( AnsiOutputStream out , String enc ) { if ( enc ! = null ) { try { return new AnsiPrintStream ( out , true , enc ) ; } catch ( UnsupportedEncodingException e ) { } } return new AnsiPrintStream ( out , true ) ; } 
public static AnsiPrintStream out ( ) { initStreams ( ) ; return out ; } 
public static PrintStream sysOut ( ) { return system_out ; } 
public static AnsiPrintStream err ( ) { initStreams ( ) ; return err ; } 
public static PrintStream sysErr ( ) { return system_err ; } 
synchronized public static void systemUninstall ( ) { installed - - ; if ( installed = = 0 ) { try { 
private static void diagnoseTty ( boolean stderr ) { int fd = stderr ? CLibrary . STDERR_FILENO : CLibrary . STDOUT_FILENO ; int isatty = CLibrary . isatty ( fd ) ; System . out . println ( " isatty(STD " + ( stderr ? " ERR " : " OUT " ) + " _FILENO): " + isatty + " , System. " + ( stderr ? " err " : " out " ) + " " + ( ( isatty = = 0 ) ? " is *NOT* " : " is " ) + " a terminal " ) ; 
public boolean isResetAtUninstall ( ) { return resetAtUninstall ; } 
private void processCharsetSelect ( ) throws IOException { try { reset ( ap ! = null & & ap . processCharsetSelect ( options ) ) ; 
private void processOperatingSystemCommand ( ) throws IOException { try { reset ( ap ! = null & & ap . processOperatingSystemCommand ( options ) ) ; 
private void processEscapeCommand ( int data ) throws IOException { try { reset ( ap ! = null & & ap . processEscapeCommand ( options , data ) ) ; 
public void install ( ) throws IOException { if ( installer ! = null ) { installer . run ( ) ; 
public void uninstall ( ) throws IOException { if ( resetAtUninstall & & processorType ! = AnsiProcessorType . Redirected & & processorType ! = AnsiProcessorType . Unsupported ) { setAnsiMode ( AnsiMode . Default ) ; write ( RESET_CODE ) ; flush ( ) ; } if ( uninstaller ! = null ) { uninstaller . run ( ) ; 
public void close ( ) throws IOException { uninstall ( ) ; super . close ( ) ; } 
public boolean isResetAtUninstall ( ) { return getOut ( ) . isResetAtUninstall ( ) ; } 
public void install ( ) throws IOException { getOut ( ) . install ( ) ; } 
public void uninstall ( ) throws IOException { getOut ( ) . uninstall ( ) ; } 
public String toString ( ) { return " AnsiPrintStream{ " + " type= " + getProcessorType ( ) 
private static void loadJansiNativeLibrary ( ) throws Exception { if ( extracted ) { return ; } List < String > triedPaths = new LinkedList < String > ( ) ; Try loading library from library.jansi.path library path */ String jansiNativeLibraryPath = System.getProperty("library.jansi.path"); String jansiNativeLibraryName = System.getProperty("library.jansi.name"); if (jansiNativeLibraryName == null) { jansiNativeLibraryName = System.mapLibraryName("jansi"); assert jansiNativeLibraryName != null; if (jansiNativeLibraryName.endsWith(".dylib")) { jansiNativeLibraryName = jansiNativeLibraryName.replace(".dylib", ".jnilib"); } } if (jansiNativeLibraryPath != null) { String withOs = jansiNativeLibraryPath + "/" + OSInfo.getNativeLibFolderPathForCurrentOS(); if (loadNativeLibrary(new File(withOs, jansiNativeLibraryName))) { extracted = true; return; } else { triedPaths.add(withOs); } if (loadNativeLibrary(new File(jansiNativeLibraryPath, jansiNativeLibraryName))) { extracted = true; return; } else { triedPaths.add(jansiNativeLibraryPath); } } Load the os-dependent library from the jar file String packagePath = JansiLoader.class.getPackage().getName().replace('.', '/'); jansiNativeLibraryPath = String.format("/%s/native/%s", packagePath, OSInfo.getNativeLibFolderPathForCurrentOS()); boolean hasNativeLib = hasResource(jansiNativeLibraryPath + "/" + jansiNativeLibraryName); if (hasNativeLib) { temporary library folder String tempFolder = getTempDir().getAbsolutePath(); Try extracting the library from jar if (extractAndLoadLibraryFile(jansiNativeLibraryPath, jansiNativeLibraryName, tempFolder)) { extracted = true; return; } else { triedPaths.add(jansiNativeLibraryPath); } } As a last resort try from java.library.path String javaLibraryPath = System.getProperty("java.library.path", ""); for (String ldPath : javaLibraryPath.split(File.pathSeparator)) { if (ldPath.isEmpty()) { continue; } if (loadNativeLibrary(new File(ldPath, jansiNativeLibraryName))) { extracted = true; return; } else { triedPaths.add(ldPath); } } extracted = false; throw new Exception(String.format("No native library found for os.name=%s, os.arch=%s, paths=[%s]", OSInfo.getOSName(), OSInfo.getArchName(), join(triedPaths, File.pathSeparator))); 
public String toString ( ) { return " AnsiPrintStream{ " + " type= " + getType ( ) 
public void uninstall ( ) throws IOException { if ( resetAtUninstall & & type ! = AnsiType . Redirected & & type ! = AnsiType . Unsupported ) { setMode ( AnsiMode . Default ) ; write ( RESET_CODE ) ; flush ( ) ; } if ( uninstaller ! = null ) { uninstaller . run ( ) ; 
public static void main ( String [ ] args ) { print ( System . out , " Lorem ipsum " ) ; print ( System . err , " dolor sit amet " ) ; AnsiConsole . systemInstall ( ) ; print ( System . out , " consectetur adipiscing elit " ) ; print ( System . err , " sed do eiusmod " ) ; AnsiConsole . out ( ) . setMode ( AnsiMode . Strip ) ; AnsiConsole . err ( ) . setMode ( AnsiMode . Strip ) ; print ( System . out , " tempor incididunt ut " ) ; print ( System . err , " labore et dolore " ) ; AnsiConsole . systemUninstall ( ) ; print ( System . out , " magna aliqua. " ) ; print ( System . err , " Ut enim ad " ) ; } 
public Ansi fg ( int color ) { attributeOptions . add ( 38 ) ; attributeOptions . add ( 5 ) ; attributeOptions . add ( color & 0xff ) ; return this ; } 
public Ansi fgRgb ( int color ) { return fgRgb ( color > > 16 , color > > 8 , color ) ; } 
public Ansi fgRgb ( int r , int g , int b ) { attributeOptions . add ( 38 ) ; attributeOptions . add ( 2 ) ; attributeOptions . add ( r & 0xff ) ; attributeOptions . add ( g & 0xff ) ; attributeOptions . add ( b & 0xff ) ; return this ; } 
public Ansi bg ( int color ) { attributeOptions . add ( 48 ) ; attributeOptions . add ( 5 ) ; attributeOptions . add ( color & 0xff ) ; return this ; } 
public Ansi bgRgb ( int color ) { return bgRgb ( color > > 16 , color > > 8 , color ) ; } 
public Ansi bgRgb ( int r , int g , int b ) { attributeOptions . add ( 48 ) ; attributeOptions . add ( 2 ) ; attributeOptions . add ( r & 0xff ) ; attributeOptions . add ( g & 0xff ) ; attributeOptions . add ( b & 0xff ) ; return this ; } 
private static void testAnsi ( boolean stderr ) { @SuppressWarnings ( " resource " ) PrintStream s = stderr ? System . err : System . out ; s . print ( " test on System. " + ( stderr ? " err " : " out " ) + " : " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bright: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . fgBright ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bold: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . bold ( ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; Ansi ansi = ansi ( ) ; ansi . a ( " 256 colors: " ) ; for ( int i = 0 ; i < 6 * 6 * 6 ; i + + ) { if ( i > 0 & & i % 36 = = 0 ) { ansi . reset ( ) ; ansi . newline ( ) ; ansi . a ( " " ) ; } else if ( i > 0 & & i % 6 = = 0 ) { ansi . reset ( ) ; ansi . a ( " " ) ; } int a0 = i % 6 ; int a1 = ( i / 6 ) % 6 ; int a2 = i / 36 ; ansi . bg ( 16 + a0 + a2 * 6 + a1 * 36 ) . a ( ' ' ) ; } ansi . reset ( ) ; s . println ( ansi ) ; ansi = ansi ( ) ; ansi . a ( " truecolor: " ) ; for ( int i = 0 ; i < 256 ; i + + ) { if ( i > 0 & & i % 48 = = 0 ) { ansi . reset ( ) ; ansi . newline ( ) ; ansi . a ( " " ) ; } int r = 255 - i ; int g = i * 2 > 255 ? 255 - 2 * i : 2 * i ; int b = i ; ansi . bgRgb ( r , g , b ) . fgRgb ( 255 - r , 255 - g , 255 - b ) . a ( i % 2 = = 0 ? '/' : '\\' ) ; } ansi . reset ( ) ; s . println ( ansi ) ; } 
protected int getNextOptionInt ( Iterator < Object > optionsIterator ) throws IOException { for ( ; ; ) { if ( ! optionsIterator . hasNext ( ) ) 
public static int roundColor ( int col , int max ) { if ( col > = max ) { int c = DEFAULT_COLORS_256 [ col ] ; col = roundColor ( c , DEFAULT_COLORS_256 , max ) ; } return col ; } 
public static int roundRgbColor ( int r , int g , int b , int max ) { return roundColor ( ( r < < 16 ) + ( g < < 8 ) + b , DEFAULT_COLORS_256 , max ) ; } 
private static int roundColor ( int color , int [ ] colors , int max ) { double best_distance = Integer . MAX_VALUE ; int best_index = Integer . MAX_VALUE ; for ( int idx = 0 ; idx < max ; idx + + ) { double d = cie76 ( color , colors [ idx ] ) ; if ( d < = best_distance ) { best_index = idx ; best_distance = d ; } } return best_index ; } 
private static double cie76 ( int c1 , int c2 ) { return scalar ( rgb2cielab ( c1 ) , rgb2cielab ( c2 ) ) ; } 
private static double scalar ( double [ ] c1 , double [ ] c2 ) { return sqr ( c1 [ 0 ] - c2 [ 0 ] ) + sqr ( c1 [ 1 ] - c2 [ 1 ] ) 
private static double [ ] rgb ( int color ) { int r = ( color > > 16 ) & 0xFF ; int g = ( color > > 8 ) & 0xFF ; int b = ( color > > 0 ) & 0xFF ; return new double [ ] { r / 255.0 , g / 255.0 , b / 255.0 } ; } 
private static double [ ] rgb2cielab ( int color ) { return rgb2cielab ( rgb ( color ) ) ; } 
private static double [ ] rgb2cielab ( double [ ] rgb ) { return xyz2lab ( rgb2xyz ( rgb ) ) ; } 
private static double [ ] rgb2xyz ( double [ ] rgb ) { double vr = pivotRgb ( rgb [ 0 ] ) ; double vg = pivotRgb ( rgb [ 1 ] ) ; double vb = pivotRgb ( rgb [ 2 ] ) ; http:www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html double x = vr * 0.4124564 + vg * 0.3575761 + vb * 0.1804375; double y = vr * 0.2126729 + vg * 0.7151522 + vb * 0.0721750; double z = vr * 0.0193339 + vg * 0.1191920 + vb * 0.9503041; return new double[] { x, y, z }; } 
private static double pivotRgb ( double ) { return > 0.04045 ? Math . pow ( ( + 0.055 ) / 1.055 , 2.4 ) : / 12.92 ; } 
private static double [ ] xyz2lab ( double [ ] xyz ) { double fx = pivotXyz ( xyz [ 0 ] ) ; double fy = pivotXyz ( xyz [ 1 ] ) ; double fz = pivotXyz ( xyz [ 2 ] ) ; double l = 116.0 * fy - 16.0 ; double a = 500.0 * ( fx - fy ) ; double b = 200.0 * ( fy - fz ) ; return new double [ ] { l , a , b } ; } 
private static double pivotXyz ( double ) { return > epsilon ? Math . cbrt ( ) : ( kappa * + 16 ) / 116 ; } 
protected boolean processEscapeCommand ( ArrayList < Object > options , int command ) throws IOException { if ( command = = 'm' & & ( colors = = AnsiColors . Colors256 | | colors = = AnsiColors . Colors16 ) ) { Validate all options are ints... 
protected boolean processOperatingSystemCommand ( ArrayList < Object > options ) { return false ; } 
protected boolean processCharsetSelect ( ArrayList < Object > options ) { return false ; } 
protected void processSetForegroundColorExt ( int paletteIndex ) throws IOException { int round = Colors . roundColor ( paletteIndex , 16 ) ; processSetForegroundColor ( round > = 8 ? round - 8 : round , round > = 8 ) ; } 
protected void processSetForegroundColorExt ( int r , int g , int b ) throws IOException { int round = Colors . roundRgbColor ( r , g , b , 16 ) ; processSetForegroundColor ( round > = 8 ? round - 8 : round , round > = 8 ) ; } 
protected void processSetBackgroundColorExt ( int paletteIndex ) throws IOException { int round = Colors . roundColor ( paletteIndex , 16 ) ; processSetBackgroundColor ( round > = 8 ? round - 8 : round , round > = 8 ) ; } 
protected void processSetBackgroundColorExt ( int r , int g , int b ) throws IOException { int round = Colors . roundRgbColor ( r , g , b , 16 ) ; processSetBackgroundColor ( round > = 8 ? round - 8 : round , round > = 8 ) ; } 
private static void testAnsi ( boolean stderr ) { @SuppressWarnings ( " resource " ) PrintStream s = stderr ? System . err : System . out ; s . print ( " test on System. " + ( stderr ? " err " : " out " ) + " : " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bright: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . fgBright ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bold: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . bold ( ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " faint: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . a ( Attribute . INTENSITY_FAINT ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bold+faint: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . bold ( ) . a ( Attribute . INTENSITY_FAINT ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; Ansi ansi = ansi ( ) ; ansi . a ( " 256 colors: " ) ; for ( int i = 0 ; i < 6 * 6 * 6 ; i + + ) { if ( i > 0 & & i % 36 = = 0 ) { ansi . reset ( ) ; ansi . newline ( ) ; ansi . a ( " " ) ; } else if ( i > 0 & & i % 6 = = 0 ) { ansi . reset ( ) ; ansi . a ( " " ) ; } int a0 = i % 6 ; int a1 = ( i / 6 ) % 6 ; int a2 = i / 36 ; ansi . bg ( 16 + a0 + a2 * 6 + a1 * 36 ) . a ( ' ' ) ; } ansi . reset ( ) ; s . println ( ansi ) ; ansi = ansi ( ) ; ansi . a ( " truecolor: " ) ; for ( int i = 0 ; i < 256 ; i + + ) { if ( i > 0 & & i % 48 = = 0 ) { ansi . reset ( ) ; ansi . newline ( ) ; ansi . a ( " " ) ; } int r = 255 - i ; int g = i * 2 > 255 ? 255 - 2 * i : 2 * i ; int b = i ; ansi . bgRgb ( r , g , b ) . fgRgb ( 255 - r , 255 - g , 255 - b ) . a ( i % 2 = = 0 ? '/' : '\\' ) ; } ansi . reset ( ) ; s . println ( ansi ) ; } 
public static AnsiPrintStream out ( ) { initStreams ( ) ; return ( AnsiPrintStream ) out ; } 
public static AnsiPrintStream err ( ) { initStreams ( ) ; return ( AnsiPrintStream ) err ; } 
public static native int GetConsoleMode ( long handle , int [ ] mode ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleMode ( long handle , int mode ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int _getch ( ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleTitle ( String title ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int GetConsoleOutputCP ( ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleOutputCP ( int codePageID ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public short attributes ; public char unicodeChar ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int ScrollConsoleScreenBuffer ( long consoleOutput , SMALL_RECT scrollRectangle , SMALL_RECT clipRectangle , COORD destinationOrigin , CHAR_INFO fill ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public static int CAPSLOCK_ON ; public static int NUMLOCK_ON ; public static int SCROLLLOCK_ON ; public static int ENHANCED_KEY ; public static int LEFT_ALT_PRESSED ; public static int LEFT_CTRL_PRESSED ; public static int RIGHT_ALT_PRESSED ; public static int RIGHT_CTRL_PRESSED ; public static int SHIFT_PRESSED ; public boolean keyDown ; public short repeatCount ; public short keyCode ; public short scanCode ; public char uchar ; public int controlKeyState ; public String toString ( ) { return " KEY_EVENT_RECORD{ " + " keyDown= " + keyDown + " , repeatCount= " + repeatCount + " , keyCode= " + keyCode + " , scanCode= " + scanCode + " , uchar= " + uchar + " , controlKeyState= " + controlKeyState + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public static int FROM_LEFT_1ST_BUTTON_PRESSED ; public static int FROM_LEFT_2ND_BUTTON_PRESSED ; public static int FROM_LEFT_3RD_BUTTON_PRESSED ; public static int FROM_LEFT_4TH_BUTTON_PRESSED ; public static int RIGHTMOST_BUTTON_PRESSED ; public static int CAPSLOCK_ON ; public static int NUMLOCK_ON ; public static int SCROLLLOCK_ON ; public static int ENHANCED_KEY ; public static int LEFT_ALT_PRESSED ; public static int LEFT_CTRL_PRESSED ; public static int RIGHT_ALT_PRESSED ; public static int RIGHT_CTRL_PRESSED ; public static int SHIFT_PRESSED ; public static int DOUBLE_CLICK ; public static int MOUSE_HWHEELED ; public static int MOUSE_MOVED ; public static int MOUSE_WHEELED ; public COORD mousePosition = new COORD ( ) ; public int buttonState ; public int controlKeyState ; public int eventFlags ; public String toString ( ) { return " MOUSE_EVENT_RECORD{ " + " mousePosition= " + mousePosition + " , buttonState= " + buttonState + " , controlKeyState= " + controlKeyState + " , eventFlags= " + eventFlags + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public COORD size = new COORD ( ) ; public String toString ( ) { return " WINDOW_BUFFER_SIZE_RECORD{size= " + size + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public boolean setFocus ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public int commandId ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public static short KEY_EVENT ; public static short MOUSE_EVENT ; public static short WINDOW_BUFFER_SIZE_EVENT ; public static short FOCUS_EVENT ; public static short MENU_EVENT ; public short eventType ; public KEY_EVENT_RECORD keyEvent = new KEY_EVENT_RECORD ( ) ; public MOUSE_EVENT_RECORD mouseEvent = new MOUSE_EVENT_RECORD ( ) ; public WINDOW_BUFFER_SIZE_RECORD windowBufferSizeEvent = new WINDOW_BUFFER_SIZE_RECORD ( ) ; public MENU_EVENT_RECORD menuEvent = new MENU_EVENT_RECORD ( ) ; public FOCUS_EVENT_RECORD focusEvent = new FOCUS_EVENT_RECORD ( ) ; public static native void memmove ( INPUT_RECORD dest , long src , long size ) ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native void memmove ( INPUT_RECORD dest , long src , long size ) ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native int ReadConsoleInputW ( long handle , long inputRecord , int length , int [ ] eventsCount ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native int PeekConsoleInputW ( long handle , long inputRecord , int length , int [ ] eventsCount ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int GetNumberOfConsoleInputEvents ( long handle , int [ ] numberOfEvents ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int FlushConsoleInputBuffer ( long handle ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public Ansi apply ( Consumer fun ) { fun . apply ( this ) ; return this ; } 
public void testApply ( ) { assertEquals ( " test " , Ansi . ansi ( ) . apply ( new Ansi . Consumer ( ) { public void apply ( Ansi ansi ) { 
public void apply ( Ansi ansi ) { ansi . a ( " test " ) ; } 
public Ansi cursorUp ( final int y ) { return y > 0 ? appendEscapeSequence ( 'A' , y ) : y < 0 ? cursorDown ( - y ) : this ; } 
public Ansi cursorDown ( final int y ) { return y > 0 ? appendEscapeSequence ( 'B' , y ) : y < 0 ? cursorUp ( - y ) : this ; } 
public Ansi cursorRight ( final int x ) { return x > 0 ? appendEscapeSequence ( 'C' , x ) : x < 0 ? cursorLeft ( - x ) : this ; } 
public Ansi cursorLeft ( final int x ) { return x > 0 ? appendEscapeSequence ( 'D' , x ) : x < 0 ? cursorRight ( - x ) : this ; } 
public Ansi cursorMove ( final int x , final int y ) { return cursorRight ( x ) . cursorDown ( y ) ; } 
public Ansi cursorDownLine ( final int ) { return > 0 ? appendEscapeSequence ( 'E' , ) : < 0 ? cursorUpLine ( - ) : this ; } 
public Ansi cursorUpLine ( final int ) { return > 0 ? appendEscapeSequence ( 'F' , ) : < 0 ? cursorDownLine ( - ) : this ; } 
public void testCursor ( int x , int y , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursor ( x , y ) ) ; } 
public void testCursorToColumn ( int x , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursorToColumn ( x ) ) ; } 
public void testCursorUp ( int y , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursorUp ( y ) ) ; } 
public void testCursorDown ( int y , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursorDown ( y ) ) ; } 
public void testCursorRight ( int x , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursorRight ( x ) ) ; } 
public void testCursorLeft ( int x , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursorLeft ( x ) ) ; } 
public void testCursorMove ( int x , int y , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursorMove ( x , y ) ) ; } 
public void testCursorDownLine ( ) { assertAnsi ( " ESC[E " , new Ansi ( ) . cursorDownLine ( ) ) ; } 
public void testCursorDownLine ( int , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursorDownLine ( ) ) ; } 
public void testCursorUpLine ( ) { assertAnsi ( " ESC[F " , new Ansi ( ) . cursorUpLine ( ) ) ; } 
public void testCursorUpLine ( int , String expected ) { assertAnsi ( expected , new Ansi ( ) . cursorUpLine ( ) ) ; } 
private static void assertAnsi ( String expected , Ansi actual ) { assertEquals ( expected . replace ( " ESC " , " 033 " ) , actual . toString ( ) ) ; } 
public Ansi cursor ( final int row , final int column ) { return appendEscapeSequence ( 'H' , Math . max ( 1 , row ) , Math . max ( 1 , column ) ) ; } 
public Ansi cursorToColumn ( final int x ) { return appendEscapeSequence ( 'G' , Math . max ( 1 , x ) ) ; } 
public Ansi cursorDownLine ( final int ) { return < 0 ? cursorUpLine ( - ) : appendEscapeSequence ( 'E' , ) ; } 
public Ansi cursorUpLine ( final int ) { return < 0 ? cursorDownLine ( - ) : appendEscapeSequence ( 'F' , ) ; } 
public Ansi scrollUp ( final int rows ) { return rows > 0 ? appendEscapeSequence ( 'S' , rows ) : rows < 0 ? scrollDown ( - rows ) : this ; } 
public Ansi scrollDown ( final int rows ) { return rows > 0 ? appendEscapeSequence ( 'T' , rows ) : rows < 0 ? scrollUp ( - rows ) : this ; } 
void canHandleSgrsWithMultipleOptions ( ) throws IOException { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final AnsiOutputStream ansiOutput = new AnsiOutputStream ( baos , AnsiMode . Strip , null , AnsiType . Emulation , AnsiColors . TrueColor , Charset . forName ( " UTF-8 " ) , null , null , false ) ; ansiOutput . write ( " u001B[33mbanana_1 | u001B[0m 19:59:14.353 u001B[0;38m [debug] Lager installed handler {lager_file_backend, \" banana.log \" } into lager_event u001B[0m " . getBytes ( ) ) ; assertEquals ( " banana_1 | 19:59:14.353 [debug] Lager installed handler {lager_file_backend, \" banana.log \" } into lager_event " , baos . toString ( ) ) ; } 
private static Ansi render ( Ansi ansi , String . . . names ) { for ( String name : names ) { Code code = Code . valueOf ( name . toUpperCase ( Locale . ENGLISH ) ) ; if ( code . isColor ( ) ) { if ( code . isBackground ( ) ) { ansi . bg ( code . getColor ( ) ) ; } else { ansi . fg ( code . getColor ( ) ) ; } } else if ( code . isAttribute ( ) ) { ansi . a ( code . getAttribute ( ) ) ; } } return ansi ; } 
void canHandleSgrsWithMultipleOptions ( ) throws IOException { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final AnsiOutputStream ansiOutput = new AnsiOutputStream ( baos , null , AnsiMode . Strip , null , AnsiType . Emulation , AnsiColors . TrueColor , Charset . forName ( " UTF-8 " ) , null , null , false ) ; ansiOutput . write ( ( " u001B[33mbanana_1 | u001B[0m 19:59:14.353 u001B[0;38m [debug] A message u001B[0m " ) . getBytes ( ) ) ; assertEquals ( " banana_1 | 19:59:14.353 [debug] A message " , baos . toString ( ) ) ; } 
private static native void init ( ) ; public static int STDOUT_FILENO = 1 ; public static int STDERR_FILENO = 2 ; public static boolean HAVE_ISATTY ; public static boolean HAVE_TTYNAME ; public static int TCSANOW ; public static int TCSADRAIN ; public static int TCSAFLUSH ; public static long TIOCGETA ; public static long TIOCSETA ; public static long TIOCGETD ; public static long TIOCSETD ; public static long TIOCGWINSZ ; public static long TIOCSWINSZ ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
public static native int isatty ( int fd ) ; public static native String ttyname ( int filedes ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
public static native String ttyname ( int filedes ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
public static native int openpty ( int [ ] amaster , int [ ] aslave , byte [ ] name , Termios termios , WinSize winsize ) ; public static native int tcgetattr ( int filedes , Termios termios ) ; public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
public static native int tcgetattr ( int filedes , Termios termios ) ; public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
public static native int ioctl ( int filedes , long request , int [ ] params ) ; public static native int ioctl ( int filedes , long request , WinSize params ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
public static native int ioctl ( int filedes , long request , WinSize params ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
private static native void init ( ) ; public static int SIZEOF ; public short ws_row ; public short ws_col ; public short ws_xpixel ; public short ws_ypixel ; public WinSize ( ) { } public WinSize ( short ws_row , short ws_col ) { this . ws_row = ws_row ; this . ws_col = ws_col ; } } public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
public static native int setenv ( String name , String value ) ; public static native int chdir ( String path ) ; } 
void testChdir ( ) { File d = new File ( " target/tstDir " ) ; d . mkdirs ( ) ; CLibrary . chdir ( d . getAbsolutePath ( ) ) ; } 
void testSetenv ( ) { CLibrary . setenv ( " MY_NAME " , " myValue " ) ; } 
public void uninstall ( ) throws IOException { If the system output stream has been closed, out should be null, so avoid a NPE AnsiOutputStream out = getOut(); if (out != null) { out.uninstall(); 
public Ansi fgRgb ( int r , int g , int b ) { return this ; } 
public Ansi bgRgb ( int r , int g , int b ) { return this ; } 
public void testColorDisabled ( ) { Ansi . setEnabled ( false ) ; try { assertEquals ( " test " , Ansi . ansi ( ) . fg ( 32 ) . a ( " " ) . fgRgb ( 0 ) . a ( " e " ) . bg ( 24 ) . a ( " s " ) . bgRgb ( 100 ) . a ( " " ) . toString ( ) ) ; 
private static void diagnoseTty ( boolean stderr ) { int fd = stderr ? CLibrary . STDERR_FILENO : CLibrary . STDOUT_FILENO ; int isatty = CLibrary . LOADED ? CLibrary . isatty ( fd ) : 0 ; System . out . println ( " isatty(STD " + ( stderr ? " ERR " : " OUT " ) + " _FILENO): " + isatty + " , System. " + ( stderr ? " err " : " out " ) + " " + ( ( isatty = = 0 ) ? " is *NOT* " : " is " ) + " a terminal " ) ; 
private static native void init ( ) ; Constants public static int STDOUT_FILENO = 1; public static int STDERR_FILENO = 2; public static boolean HAVE_ISATTY; public static boolean HAVE_TTYNAME; public static int TCSANOW; public static int TCSADRAIN; public static int TCSAFLUSH; public static long TIOCGETA; public static long TIOCSETA; public static long TIOCGETD; public static long TIOCSETD; public static long TIOCGWINSZ; public static long TIOCSWINSZ; public static class Termios { static { JansiLoader.initialize(); init(); } private static native void init(); public static int SIZEOF; public long c_iflag; public long c_oflag; public long c_cflag; public long c_lflag; public byte[] c_cc = new byte[32]; public long c_ispeed; public long c_ospeed; }} 
public static synchronized boolean initialize ( ) { only cleanup before the first extract if (!loaded) { cleanup(); } try { loadJansiNativeLibrary(); } catch (Exception e) { throw new RuntimeException("Unable to load jansi native library. You may want set the `jansi.graceful` system property to true to be able to use Jansi on your platform", e); } return loaded; } 
private static void loadJansiNativeLibrary ( ) throws Exception { if ( loaded ) { return ; } List < String > triedPaths = new LinkedList < String > ( ) ; Try loading library from library.jansi.path library path */ String jansiNativeLibraryPath = System.getProperty("library.jansi.path"); String jansiNativeLibraryName = System.getProperty("library.jansi.name"); if (jansiNativeLibraryName == null) { jansiNativeLibraryName = System.mapLibraryName("jansi"); assert jansiNativeLibraryName != null; if (jansiNativeLibraryName.endsWith(".dylib")) { jansiNativeLibraryName = jansiNativeLibraryName.replace(".dylib", ".jnilib"); } } if (jansiNativeLibraryPath != null) { String withOs = jansiNativeLibraryPath + "/" + OSInfo.getNativeLibFolderPathForCurrentOS(); if (loadNativeLibrary(new File(withOs, jansiNativeLibraryName))) { loaded = true; return; } else { triedPaths.add(withOs); } if (loadNativeLibrary(new File(jansiNativeLibraryPath, jansiNativeLibraryName))) { loaded = true; return; } else { triedPaths.add(jansiNativeLibraryPath); } } Load the os-dependent library from the jar file String packagePath = JansiLoader.class.getPackage().getName().replace('.', '/'); jansiNativeLibraryPath = String.format("/%s/native/%s", packagePath, OSInfo.getNativeLibFolderPathForCurrentOS()); boolean hasNativeLib = hasResource(jansiNativeLibraryPath + "/" + jansiNativeLibraryName); if (hasNativeLib) { temporary library folder String tempFolder = getTempDir().getAbsolutePath(); Try extracting the library from jar if (extractAndLoadLibraryFile(jansiNativeLibraryPath, jansiNativeLibraryName, tempFolder)) { loaded = true; return; } else { triedPaths.add(jansiNativeLibraryPath); } } As a last resort try from java.library.path String javaLibraryPath = System.getProperty("java.library.path", ""); for (String ldPath : javaLibraryPath.split(File.pathSeparator)) { if (ldPath.isEmpty()) { continue; } if (loadNativeLibrary(new File(ldPath, jansiNativeLibraryName))) { loaded = true; return; } else { triedPaths.add(ldPath); } } throw new Exception(String.format("No native library found for os.name=%s, os.arch=%s, paths=[%s]", OSInfo.getOSName(), OSInfo.getArchName(), join(triedPaths, File.pathSeparator))); 
private static boolean loadNativeLibrary ( File libPath ) { if ( libPath . exists ( ) ) { try { 
synchronized static public void systemInstall ( ) { if ( installed = = 0 ) { initStreams ( ) ; try { ( ( AnsiPrintStream ) out ) . install ( ) ; ( ( AnsiPrintStream ) err ) . install ( ) ; } catch ( IOException e ) { throw new IOError ( e ) ; } System . setOut ( out ) ; System . setErr ( err ) ; } installed + + ; } 
private void flushAttributes ( ) { if ( attributeOptions . isEmpty ( ) ) return ; if ( attributeOptions . size ( ) = = 1 & & attributeOptions . get ( 0 ) = = 0 ) { builder . append ( FIRST_ESC_CHAR ) ; builder . append ( SECOND_ESC_CHAR ) ; builder . append ( 'm' ) ; } else { _appendEscapeSequence ( 'm' , attributeOptions . toArray ( ) ) ; } attributeOptions . clear ( ) ; } 
public static synchronized void systemInstall ( ) { if ( installed = = 0 ) { initStreams ( ) ; try { ( ( AnsiPrintStream ) out ) . install ( ) ; ( ( AnsiPrintStream ) err ) . install ( ) ; } catch ( IOException e ) { throw new IOError ( e ) ; } System . setOut ( out ) ; System . setErr ( err ) ; } installed + + ; } 
public static synchronized boolean isInstalled ( ) { return installed > 0 ; } 
public static synchronized void systemUninstall ( ) { installed - - ; if ( installed = = 0 ) { try { 
static synchronized void initStreams ( ) { if ( ! initialized ) { out = ansiStream ( true ) ; 
private static void diagnoseTty ( boolean stderr ) { int fd = stderr ? CLibrary . STDERR_FILENO : CLibrary . STDOUT_FILENO ; int isatty = CLibrary . LOADED ? CLibrary . isatty ( fd ) : 0 ; System . out . println ( " isatty(STD " + ( stderr ? " ERR " : " OUT " ) + " _FILENO): " + isatty + " , System. " + ( stderr ? " err " : " out " ) + " " + ( ( isatty = = 0 ) ? " is *NOT* " : " is " ) + " a terminal " ) ; 
private static void testAnsi ( boolean stderr ) { @SuppressWarnings ( " resource " ) PrintStream s = stderr ? System . err : System . out ; s . print ( " test on System. " + ( stderr ? " err " : " out " ) + " : " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bright: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . fgBright ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bold: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . bold ( ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " faint: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . a ( Attribute . INTENSITY_FAINT ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; s . print ( " bold+faint: " ) ; for ( Ansi . Color c : Ansi . Color . values ( ) ) { s . print ( " " + ansi ( ) . bold ( ) . a ( Attribute . INTENSITY_FAINT ) . fg ( c ) + c + ansi ( ) . reset ( ) ) ; } s . println ( ) ; Ansi ansi = ansi ( ) ; ansi . a ( " 256 colors: " ) ; for ( int i = 0 ; i < 6 * 6 * 6 ; i + + ) { if ( i > 0 & & i % 36 = = 0 ) { ansi . reset ( ) ; ansi . newline ( ) ; ansi . a ( " " ) ; } else if ( i > 0 & & i % 6 = = 0 ) { ansi . reset ( ) ; ansi . a ( " " ) ; } int a0 = i % 6 ; int a1 = ( i / 6 ) % 6 ; int a2 = i / 36 ; ansi . bg ( 16 + a0 + a2 * 6 + a1 * 36 ) . a ( ' ' ) ; } ansi . reset ( ) ; s . println ( ansi ) ; ansi = ansi ( ) ; ansi . a ( " truecolor: " ) ; for ( int i = 0 ; i < 256 ; i + + ) { if ( i > 0 & & i % 48 = = 0 ) { ansi . reset ( ) ; ansi . newline ( ) ; ansi . a ( " " ) ; } int r = 255 - i ; int g = i * 2 > 255 ? 255 - 2 * i : 2 * i ; int b = i ; ansi . bgRgb ( r , g , b ) . fgRgb ( 255 - r , 255 - g , 255 - b ) . a ( i % 2 = = 0 ? '/' : '\\' ) ; } ansi . reset ( ) ; s . println ( ansi ) ; } 
private static void printJansiLogoDemo ( ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( AnsiMain . class . getResourceAsStream ( " jansi.txt " ) , " UTF-8 " ) ) ; try { String l ; 
public static String render ( final String text , final String . . . codes ) { return render ( Ansi . ansi ( ) , codes ) . a ( text ) . reset ( ) . toString ( ) ; } 
private static native void init ( ) ; Constants public static int STDOUT_FILENO = 1; public static int STDERR_FILENO = 2; public static boolean HAVE_ISATTY; public static boolean HAVE_TTYNAME; public static int TCSANOW; public static int TCSADRAIN; public static int TCSAFLUSH; public static long TIOCGETA; public static long TIOCSETA; public static long TIOCGETD; public static long TIOCSETD; public static long TIOCGWINSZ; public static long TIOCSWINSZ; public static class Termios { static { JansiLoader.initialize(); init(); } private static native void init(); public static int SIZEOF; public long c_iflag; public long c_oflag; public long c_cflag; public long c_lflag; public byte[] c_cc = new byte[32]; public long c_ispeed; public long c_ospeed; }} 
public static native int isatty ( int fd ) ; public static native String ttyname ( int filedes ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native String ttyname ( int filedes ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int openpty ( int [ ] amaster , int [ ] aslave , byte [ ] name , Termios termios , WinSize winsize ) ; public static native int tcgetattr ( int filedes , Termios termios ) ; public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int tcgetattr ( int filedes , Termios termios ) ; public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int tcsetattr ( int filedes , int optional_actions , Termios termios ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int ioctl ( int filedes , long request , int [ ] params ) ; public static native int ioctl ( int filedes , long request , WinSize params ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
public static native int ioctl ( int filedes , long request , WinSize params ) ; public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
private static native void init ( ) ; public static int SIZEOF ; public short ws_row ; public short ws_col ; public short ws_xpixel ; public short ws_ypixel ; public WinSize ( ) { } public WinSize ( short ws_row , short ws_col ) { this . ws_row = ws_row ; this . ws_col = ws_col ; } } public static class Termios { static { JansiLoader . initialize ( ) ; init ( ) ; } private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
private static native void init ( ) ; public static int SIZEOF ; public long c_iflag ; public long c_oflag ; public long c_cflag ; public long c_lflag ; public byte [ ] c_cc = new byte [ 32 ] ; public long c_ispeed ; public long c_ospeed ; } } 
private static int readNBytes ( InputStream in , byte [ ] b ) throws IOException { int = 0 ; int len = b . length ; while ( < len ) { int count = in . read ( b , , len - ) ; if ( count < = 0 ) break ; + = count ; } return ; } 
private static void loadJansiNativeLibrary ( ) throws Exception { if ( loaded ) { return ; } List < String > triedPaths = new LinkedList < String > ( ) ; Try loading library from library.jansi.path library path */ String jansiNativeLibraryPath = System.getProperty("library.jansi.path"); String jansiNativeLibraryName = System.getProperty("library.jansi.name"); if (jansiNativeLibraryName == null) { jansiNativeLibraryName = System.mapLibraryName("jansi"); assert jansiNativeLibraryName != null; if (jansiNativeLibraryName.endsWith(".dylib")) { jansiNativeLibraryName = jansiNativeLibraryName.replace(".dylib", ".jnilib"); } } if (jansiNativeLibraryPath != null) { String withOs = jansiNativeLibraryPath + "/" + OSInfo.getNativeLibFolderPathForCurrentOS(); if (loadNativeLibrary(new File(withOs, jansiNativeLibraryName))) { loaded = true; return; } else { triedPaths.add(withOs); } if (loadNativeLibrary(new File(jansiNativeLibraryPath, jansiNativeLibraryName))) { loaded = true; return; } else { triedPaths.add(jansiNativeLibraryPath); } } Load the os-dependent library from the jar file String packagePath = JansiLoader.class.getPackage().getName().replace('.', '/'); jansiNativeLibraryPath = String.format("/%s/native/%s", packagePath, OSInfo.getNativeLibFolderPathForCurrentOS()); boolean hasNativeLib = hasResource(jansiNativeLibraryPath + "/" + jansiNativeLibraryName); if (hasNativeLib) { temporary library folder String tempFolder = getTempDir().getAbsolutePath(); Try extracting the library from jar if (extractAndLoadLibraryFile(jansiNativeLibraryPath, jansiNativeLibraryName, tempFolder)) { loaded = true; return; } else { triedPaths.add(jansiNativeLibraryPath); } } As a last resort try from java.library.path String javaLibraryPath = System.getProperty("java.library.path", ""); for (String ldPath : javaLibraryPath.split(File.pathSeparator)) { if (ldPath.isEmpty()) { continue; } if (loadNativeLibrary(new File(ldPath, jansiNativeLibraryName))) { loaded = true; return; } else { triedPaths.add(ldPath); } } throw new Exception(String.format( "No native library found for os.name=%s, os.arch=%s, paths=[%s]", 
private static String join ( List < String > list , String separator ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = true ; for ( String item : list ) { if ( first ) first = false ; else sb . append ( separator ) ; sb . append ( item ) ; } return sb . toString ( ) ; } 
public static native int FillConsoleOutputAttribute ( long consoleOutput , short attribute , int length , COORD writeCoord , int [ ] numberOfAttrsWritten ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int WriteConsoleW ( long consoleOutput , char [ ] buffer , int numberOfCharsToWrite , int [ ] numberOfCharsWritten , long reserved ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int GetConsoleMode ( long handle , int [ ] mode ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleMode ( long handle , int mode ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int _getch ( ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleTitle ( String title ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int GetConsoleOutputCP ( ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int SetConsoleOutputCP ( int codePageID ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public short attributes ; public char unicodeChar ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int ScrollConsoleScreenBuffer ( long consoleOutput , SMALL_RECT scrollRectangle , SMALL_RECT clipRectangle , COORD destinationOrigin , CHAR_INFO fill ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public static int CAPSLOCK_ON ; public static int NUMLOCK_ON ; public static int SCROLLLOCK_ON ; public static int ENHANCED_KEY ; public static int LEFT_ALT_PRESSED ; public static int LEFT_CTRL_PRESSED ; public static int RIGHT_ALT_PRESSED ; public static int RIGHT_CTRL_PRESSED ; public static int SHIFT_PRESSED ; public boolean keyDown ; public short repeatCount ; public short keyCode ; public short scanCode ; public char uchar ; public int controlKeyState ; public String toString ( ) { return " KEY_EVENT_RECORD{ " + " keyDown= " + keyDown + " , repeatCount= " + repeatCount + " , keyCode= " + keyCode + " , scanCode= " + scanCode + " , uchar= " + uchar + " , controlKeyState= " + controlKeyState + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public String toString ( ) { return " KEY_EVENT_RECORD{ " + " keyDown= " + keyDown + " , repeatCount= " 
private static native void init ( ) ; public static int SIZEOF ; public static int FROM_LEFT_1ST_BUTTON_PRESSED ; public static int FROM_LEFT_2ND_BUTTON_PRESSED ; public static int FROM_LEFT_3RD_BUTTON_PRESSED ; public static int FROM_LEFT_4TH_BUTTON_PRESSED ; public static int RIGHTMOST_BUTTON_PRESSED ; public static int CAPSLOCK_ON ; public static int NUMLOCK_ON ; public static int SCROLLLOCK_ON ; public static int ENHANCED_KEY ; public static int LEFT_ALT_PRESSED ; public static int LEFT_CTRL_PRESSED ; public static int RIGHT_ALT_PRESSED ; public static int RIGHT_CTRL_PRESSED ; public static int SHIFT_PRESSED ; public static int DOUBLE_CLICK ; public static int MOUSE_HWHEELED ; public static int MOUSE_MOVED ; public static int MOUSE_WHEELED ; public COORD mousePosition = new COORD ( ) ; public int buttonState ; public int controlKeyState ; public int eventFlags ; public String toString ( ) { return " MOUSE_EVENT_RECORD{ " + " mousePosition= " + mousePosition + " , buttonState= " + buttonState + " , controlKeyState= " + controlKeyState + " , eventFlags= " + eventFlags + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public String toString ( ) { return " MOUSE_EVENT_RECORD{ " + " mousePosition= " + mousePosition + " , buttonState= " 
private static native void init ( ) ; public static int SIZEOF ; public COORD size = new COORD ( ) ; public String toString ( ) { return " WINDOW_BUFFER_SIZE_RECORD{size= " + size + '}' ; } } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public boolean setFocus ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public int commandId ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native void init ( ) ; public static int SIZEOF ; public static short KEY_EVENT ; public static short MOUSE_EVENT ; public static short WINDOW_BUFFER_SIZE_EVENT ; public static short FOCUS_EVENT ; public static short MENU_EVENT ; public short eventType ; public KEY_EVENT_RECORD keyEvent = new KEY_EVENT_RECORD ( ) ; public MOUSE_EVENT_RECORD mouseEvent = new MOUSE_EVENT_RECORD ( ) ; public WINDOW_BUFFER_SIZE_RECORD windowBufferSizeEvent = new WINDOW_BUFFER_SIZE_RECORD ( ) ; public MENU_EVENT_RECORD menuEvent = new MENU_EVENT_RECORD ( ) ; public FOCUS_EVENT_RECORD focusEvent = new FOCUS_EVENT_RECORD ( ) ; public static native void memmove ( INPUT_RECORD dest , long src , long size ) ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native void memmove ( INPUT_RECORD dest , long src , long size ) ; } public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native int ReadConsoleInputW ( long handle , long inputRecord , int length , int [ ] eventsCount ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
private static native int PeekConsoleInputW ( long handle , long inputRecord , int length , int [ ] eventsCount ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int GetNumberOfConsoleInputEvents ( long handle , int [ ] numberOfEvents ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static native int FlushConsoleInputBuffer ( long handle ) ; public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full of mouse events. INPUT_RECORD[] evts = readConsoleInputHelper(handle, count, peek); int keyEvtCount = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) keyEvtCount++; } if (keyEvtCount > 0) { INPUT_RECORD[] res = new INPUT_RECORD[keyEvtCount]; int i = 0; for (INPUT_RECORD evt : evts) { if (evt.eventType == INPUT_RECORD.KEY_EVENT) { res[i++] = evt; } } return res; } } }} 
public static INPUT_RECORD [ ] readConsoleInputHelper ( long handle , int count , boolean peek ) throws IOException { int [ ] length = new int [ 1 ] ; int res ; long inputRecordPtr = 0 ; try { inputRecordPtr = malloc ( INPUT_RECORD . SIZEOF * count ) ; 
public static INPUT_RECORD [ ] readConsoleKeyInput ( long handle , int count , boolean peek ) throws IOException { while ( true ) { read events until we have keyboard events, the queue could be full 
public void uninstall ( ) throws IOException { if ( resetAtUninstall & & type ! = AnsiType . Redirected & & type ! = AnsiType . Unsupported ) { setMode ( AnsiMode . Default ) ; write ( RESET_CODE ) ; flush ( ) ; } if ( uninstaller ! = null ) { uninstaller . run ( ) ; 
protected int getNextOptionInt ( Iterator < Object > optionsIterator ) throws IOException { for ( ; ; ) { if ( ! optionsIterator . hasNext ( ) ) throw new IllegalArgumentException ( ) ; 
private int optionInt ( ArrayList < Object > options , int index ) { if ( options . size ( ) < = index ) throw new IllegalArgumentException ( ) ; Object value = options . get ( index ) ; if ( value = = null ) throw new IllegalArgumentException ( ) ; if ( ! value . getClass ( ) . equals ( Integer . class ) ) throw new IllegalArgumentException ( ) ; return ( Integer ) value ; } 
protected void processCursorUp ( int count ) throws IOException { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processUnknownExtension ( ArrayList < Object > options , int command ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processChangeIconName ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processChangeWindowTitle ( String label ) { } protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
protected void processUnknownOperatingSystemCommand ( int command , String param ) { } protected void processCharsetSelect ( int set , char seq ) { } } 
private static double scalar ( double [ ] c1 , double [ ] c2 ) { return sqr ( c1 [ 0 ] - c2 [ 0 ] ) + sqr ( c1 [ 1 ] - c2 [ 1 ] ) + sqr ( c1 [ 2 ] - c2 [ 2 ] ) ; } 
private static double [ ] rgb ( int color ) { int r = ( color > > 16 ) & 0xFF ; int g = ( color > > 8 ) & 0xFF ; int b = ( color > > 0 ) & 0xFF ; return new double [ ] { r / 255.0 , g / 255.0 , b / 255.0 } ; } 
private static double [ ] rgb2xyz ( double [ ] rgb ) { double vr = pivotRgb ( rgb [ 0 ] ) ; double vg = pivotRgb ( rgb [ 1 ] ) ; double vb = pivotRgb ( rgb [ 2 ] ) ; http:www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html double x = vr * 0.4124564 + vg * 0.3575761 + vb * 0.1804375; double y = vr * 0.2126729 + vg * 0.7151522 + vb * 0.0721750; double z = vr * 0.0193339 + vg * 0.1191920 + vb * 0.9503041; return new double[] {x, y, z}; } 
private static double [ ] xyz2lab ( double [ ] xyz ) { double fx = pivotXyz ( xyz [ 0 ] ) ; double fy = pivotXyz ( xyz [ 1 ] ) ; double fz = pivotXyz ( xyz [ 2 ] ) ; double l = 116.0 * fy - 16.0 ; double a = 500.0 * ( fx - fy ) ; double b = 200.0 * ( fy - fz ) ; return new double [ ] { l , a , b } ; } 
protected void processInsertLine ( int optionInt ) throws IOException { getConsoleInfo ( ) ; SMALL_RECT scroll = info . window . copy ( ) ; scroll . top = info . cursorPosition . y ; COORD org = new COORD ( ) ; org . x = 0 ; org . y = ( short ) ( info . cursorPosition . y + optionInt ) ; CHAR_INFO info = new CHAR_INFO ( ) ; info . attributes = originalColors ; info . unicodeChar = ' ' ; if ( ScrollConsoleScreenBuffer ( console , scroll , scroll , org , info ) = = 0 ) { throw new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
protected void processDeleteLine ( int optionInt ) throws IOException { getConsoleInfo ( ) ; SMALL_RECT scroll = info . window . copy ( ) ; scroll . top = info . cursorPosition . y ; COORD org = new COORD ( ) ; org . x = 0 ; org . y = ( short ) ( info . cursorPosition . y - optionInt ) ; CHAR_INFO info = new CHAR_INFO ( ) ; info . attributes = originalColors ; info . unicodeChar = ' ' ; if ( ScrollConsoleScreenBuffer ( console , scroll , scroll , org , info ) = = 0 ) { throw new IOException ( WindowsSupport . getLastErrorMessage ( ) ) ; 
public void testRender4 ( ) { String str = render ( " @|bold,red foo bar baz|@ ick @|bold,red foo bar baz|@ " ) ; System . out . println ( str ) ; assertEquals ( ansi ( ) . a ( INTENSITY_BOLD ) 
public void testCursorPosition ( ) { Ansi ansi = Ansi . ansi ( ) . cursor ( 3 , 6 ) . reset ( ) ; assertEquals ( " u001B[3;6H u001B[m " , ansi . toString ( ) ) ; } 
public void testApply ( ) { assertEquals ( " test " , 
public void apply ( Ansi ansi ) { ansi . a ( " test " ) ; } 
public void testColorDisabled ( ) { Ansi . setEnabled ( false ) ; try { assertEquals ( 
protected void processChangeWindowTitle ( String label ) { newLabel . set ( label ) ; } 
void canHandleSgrsWithMultipleOptions ( ) throws IOException { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final AnsiOutputStream ansiOutput = new AnsiOutputStream ( baos , null , AnsiMode . Strip , null , AnsiType . Emulation , AnsiColors . TrueColor , Charset . forName ( " UTF-8 " ) , null , null , false ) ; ansiOutput . write ( ( " u001B[33mbanana_1 | u001B[0m 19:59:14.353 u001B[0;38m [debug] A message u001B[0m " ) . getBytes ( ) ) ; assertEquals ( " banana_1 | 19:59:14.353 [debug] A message " , baos . toString ( ) ) ; } 
public void testRenderInvalidEndBeforeStart ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > render ( " @|@ " ) ) ; } 
public Ansi scrollUp ( final int rows ) { if ( rows = = Integer . MIN_VALUE ) { return scrollDown ( Integer . MAX_VALUE ) ; } return rows > 0 ? appendEscapeSequence ( 'S' , rows ) : rows < 0 ? scrollDown ( - rows ) : this ; } 
public Ansi scrollDown ( final int rows ) { if ( rows = = Integer . MIN_VALUE ) { return scrollUp ( Integer . MAX_VALUE ) ; } return rows > 0 ? appendEscapeSequence ( 'T' , rows ) : rows < 0 ? scrollUp ( - rows ) : this ; } 
public void testScrollUp ( int x , String expected ) { assertAnsi ( expected , Ansi . ansi ( ) . scrollUp ( x ) ) ; } 
public void testScrollDown ( int x , String expected ) { assertAnsi ( expected , Ansi . ansi ( ) . scrollDown ( x ) ) ; } 
public Ansi restorCursorPosition ( ) { return restoreCursorPosition ( ) ; } 
public Ansi saveCursorPosition ( ) { saveCursorPositionSCO ( ) ; return saveCursorPositionDEC ( ) ; } 
public Ansi saveCursorPositionSCO ( ) { return appendEscapeSequence ( 's' ) ; } 
public Ansi saveCursorPositionDEC ( ) { builder . append ( FIRST_ESC_CHAR ) ; builder . append ( '7' ) ; return this ; } 
public Ansi restoreCursorPosition ( ) { restoreCursorPositionSCO ( ) ; return restoreCursorPositionDEC ( ) ; } 
public Ansi restoreCursorPositionSCO ( ) { return appendEscapeSequence ( 'u' ) ; } 
public Ansi restoreCursorPositionDEC ( ) { builder . append ( FIRST_ESC_CHAR ) ; builder . append ( '8' ) ; return this ; } 
private static void diagnoseTty ( boolean stderr ) { int isatty ; int width ; if ( AnsiConsole . IS_WINDOWS ) { long console = Kernel32 . GetStdHandle ( stderr ? Kernel32 . STD_ERROR_HANDLE : Kernel32 . STD_OUTPUT_HANDLE ) ; int [ ] mode = new int [ 1 ] ; isatty = Kernel32 . GetConsoleMode ( console , mode ) ; if ( ( AnsiConsole . IS_CONEMU | | AnsiConsole . IS_CYGWIN | | AnsiConsole . IS_MSYSTEM ) & & isatty = = 0 ) { MingwSupport mingw = new MingwSupport ( ) ; String name = mingw . getConsoleName ( ! stderr ) ; if ( name ! = null & & ! name . isEmpty ( ) ) { isatty = 1 ; width = mingw . getTerminalWidth ( name ) ; } else { isatty = 0 ; width = 0 ; } } else { Kernel32 . CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32 . CONSOLE_SCREEN_BUFFER_INFO ( ) ; GetConsoleScreenBufferInfo ( console , info ) ; width = info . windowWidth ( ) ; } } else { int fd = stderr ? CLibrary . STDERR_FILENO : CLibrary . STDOUT_FILENO ; isatty = CLibrary . LOADED ? CLibrary . isatty ( fd ) : 0 ; CLibrary . WinSize ws = new CLibrary . WinSize ( ) ; CLibrary . ioctl ( fd , CLibrary . TIOCGWINSZ , ws ) ; width = ws . ws_col ; } System . out . println ( " isatty(STD " + ( stderr ? " ERR " : " OUT " ) + " _FILENO): " + isatty + " , System. " + ( stderr ? " err " : " out " ) + " " + ( ( isatty = = 0 ) ? " is *NOT* " : " is " ) + " a terminal " ) ; System . out . println ( " width(STD " + ( stderr ? " ERR " : " OUT " ) + " _FILENO): " + width ) ; } 
private ProcessBuilder . Redirect getRedirect ( FileDescriptor fd ) throws ReflectiveOperationException { This is not really allowed, but this is the only way to redirect the output or error stream to the input. This is definitely not something you'd usually want to do, but in the case of the `tty` utility, it provides a way to get Class<?> rpi = Class.forName("java.lang.ProcessBuilder$RedirectPipeImpl"); Constructor<?> cns = rpi.getDeclaredConstructor(); cns.setAccessible(true); ProcessBuilder.Redirect input = (ProcessBuilder.Redirect) cns.newInstance(); Field f = rpi.getDeclaredField("fd"); f.setAccessible(true); f.set(input, fd); return input; } 
private static void printJansiLogoDemo ( ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( AnsiMain . class . getResourceAsStream ( " jansi.txt " ) , UTF_8 ) ) ; try { String l ; 
public static boolean isAlpine ( ) { try { for ( String line : Files . readAllLines ( Paths . get ( " /etc/os-release " ) ) ) { if ( line . startsWith ( " ID " ) & & line . toLowerCase ( Locale . ROOT ) . contains ( " alpine " ) ) { return true ; } } } catch ( Throwable ignored ) { } return false ; } 
public void testSetEnabled ( ) throws Exception { Ansi . setEnabled ( false ) ; new Thread ( ( ) - > assertFalse ( Ansi . isEnabled ( ) ) ) . run ( ) ; Ansi . setEnabled ( true ) ; new Thread ( ( ) - > assertTrue ( Ansi . isEnabled ( ) ) ) . run ( ) ; } 
public void testApply ( ) { assertEquals ( " test " , Ansi . ansi ( ) . apply ( ansi - > ansi . a ( " test " ) ) . toString ( ) ) ; } 
void canHandleSgrsWithMultipleOptions ( ) throws IOException { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final AnsiOutputStream ansiOutput = new AnsiOutputStream ( baos , null , AnsiMode . Strip , null , AnsiType . Emulation , AnsiColors . TrueColor , StandardCharsets . UTF_8 , null , null , false ) ; ansiOutput . write ( ( " u001B[33mbanana_1 | u001B[0m 19:59:14.353 u001B[0;38m [debug] A message u001B[0m " ) . getBytes ( ) ) ; assertEquals ( " banana_1 | 19:59:14.353 [debug] A message " , baos . toString ( ) ) ; } 
private void getConsoleInfo ( ) throws IOException { os . flush ( ) ; if ( GetConsoleScreenBufferInfo ( console , info ) = = 0 ) { throw new IOException ( " Could not get the screen info: " + Kernel32 . getLastErrorMessage ( ) ) ; } if ( negative ) { info . attributes = invertAttributeColors ( info . attributes ) ; 
private void applyAttribute ( ) throws IOException { os . flush ( ) ; short attributes = info . attributes ; if ( negative ) { attributes = invertAttributeColors ( attributes ) ; } if ( SetConsoleTextAttribute ( console , attributes ) = = 0 ) { throw new IOException ( Kernel32 . getLastErrorMessage ( ) ) ; 
private void applyCursorPosition ( ) throws IOException { if ( SetConsoleCursorPosition ( console , info . cursorPosition . copy ( ) ) = = 0 ) { throw new IOException ( Kernel32 . getLastErrorMessage ( ) ) ; 
protected void processInsertLine ( int optionInt ) throws IOException { getConsoleInfo ( ) ; SMALL_RECT scroll = info . window . copy ( ) ; scroll . top = info . cursorPosition . y ; COORD org = new COORD ( ) ; org . x = 0 ; org . y = ( short ) ( info . cursorPosition . y + optionInt ) ; CHAR_INFO info = new CHAR_INFO ( ) ; info . attributes = originalColors ; info . unicodeChar = ' ' ; if ( ScrollConsoleScreenBuffer ( console , scroll , scroll , org , info ) = = 0 ) { throw new IOException ( Kernel32 . getLastErrorMessage ( ) ) ; 
protected void processDeleteLine ( int optionInt ) throws IOException { getConsoleInfo ( ) ; SMALL_RECT scroll = info . window . copy ( ) ; scroll . top = info . cursorPosition . y ; COORD org = new COORD ( ) ; org . x = 0 ; org . y = ( short ) ( info . cursorPosition . y - optionInt ) ; CHAR_INFO info = new CHAR_INFO ( ) ; info . attributes = originalColors ; info . unicodeChar = ' ' ; if ( ScrollConsoleScreenBuffer ( console , scroll , scroll , org , info ) = = 0 ) { throw new IOException ( Kernel32 . getLastErrorMessage ( ) ) ; 
public void testErrorMessage ( ) { String msg = Kernel32 . getErrorMessage ( 500 ) ; assertEquals ( msg , " User profile cannot be loaded. " ) ; } 
