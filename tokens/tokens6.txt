public void moveto ( double x , double y ) { elements . add ( new PathElement ( PathElement . COMMAND_MOVETO , x , y ) ) ; dirty = true ; } 
public void lineto ( double x , double y ) { elements . add ( new PathElement ( PathElement . COMMAND_LINETO , x , y ) ) ; dirty = true ; } 
public void curveto ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { elements . add ( new PathElement ( PathElement . COMMAND_CURVETO , x1 , y1 , x2 , y2 , x3 , y3 ) ) ; dirty = true ; } 
public void close ( ) { elements . add ( new PathElement ( PathElement . COMMAND_CLOSE ) ) ; dirty = true ; } 
public void rect ( double x , double y , double width , double height ) { moveto ( x , y ) ; lineto ( x + width , y ) ; lineto ( x + width , y + height ) ; lineto ( x , y + height ) ; close ( ) ; } 
public void roundedRect ( double x , double y , double width , double height , double roundness ) { double cv = width < height ? width * roundness : height * roundness ; moveto ( x , y + cv ) ; curveto ( x , y , x , y , x + cv , y ) ; lineto ( x + width - cv , y ) ; curveto ( x + width , y + height , x + width , y + height , x + width - cv , y + height ) ; lineto ( x + cv , y + height ) ; curveto ( x , y + height , x , y + height , x , y + height - cv ) ; close ( ) ; } 
public void oval ( double x , double y , double width , double height ) { double hdiff = width / 2 * KAPPA ; double vdiff = height / 2 * KAPPA ; moveto ( x + width / 2 , y + height ) ; curveto ( x + width / 2 - hdiff , y + height , x , y + height / 2 + vdiff , x , y + height / 2 ) ; curveto ( x , y + height / 2 - vdiff , x + width / 2 - hdiff , y , x + width / 2 , y ) ; curveto ( x + width / 2 + hdiff , y , x + width , y + height / 2 - vdiff , x + width , y + height / 2 ) ; curveto ( x + width , y + height / 2 + vdiff , x + width / 2 + hdiff , y + height , 
public void line ( double x1 , double y1 , double x2 , double y2 ) { moveto ( x1 , y1 ) ; lineto ( x2 , y2 ) ; } 
public void append ( PathElement el ) { elements . add ( el ) ; } 
public Rect bounds ( ) { return new Rect ( awtPath ( ) . getBounds2D ( ) ) ; } 
public void draw ( Context ctx ) { } @Override public Grob clone ( ) { BezierPath p = new BezierPath ( ) ; p . elements = ( ArrayList < PathElement > ) elements . clone ( ) ; p . filled = filled ; p . fillColor = fillColor . clone ( ) ; p . stroked = stroked ; p . strokeColor = strokeColor . clone ( ) ; p . strokeWidth = strokeWidth ; return p ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof BezierPath ) ) return false ; BezierPath p = ( BezierPath ) o ; TODO: equality should incorporate color as well. return elements.equals(p.elements); } @Override public String toString() { StringBuffer sb = new StringBuffer("BezierPath("); for (PathElement el : elements) { sb.append(el.toString()); sb.append(", "); } sb.append(")"); return sb.toString(); }} 
public Grob clone ( ) { BezierPath p = new BezierPath ( ) ; p . elements = ( ArrayList < PathElement > ) elements . clone ( ) ; p . filled = filled ; p . fillColor = fillColor . clone ( ) ; p . stroked = stroked ; p . strokeColor = strokeColor . clone ( ) ; p . strokeWidth = strokeWidth ; return p ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof BezierPath ) ) return false ; BezierPath p = ( BezierPath ) o ; TODO: equality should incorporate color as well. return elements.equals(p.elements); } 
public String toString ( ) { StringBuffer sb = new StringBuffer ( " BezierPath( " ) ; for ( PathElement el : elements ) { sb . append ( el . toString ( ) ) ; sb . append ( " , " ) ; } sb . append ( " ) " ) ; return sb . toString ( ) ; } 
public List < Grob > elements ( ) { return new ArrayList < Grob > ( elements ) ; } 
public Rect bounds ( ) { if ( elements . isEmpty ( ) ) { return new Rect ( ) ; TODO: We're running bounds() twice on the first element } Rect r = elements.get(0).bounds(); for (Grob g : elements) { r = r.united(g.bounds()); } return r; } 
public Grob clone ( ) { Canvas c = new Canvas ( width , height ) ; c . elements = ( ArrayList < Grob > ) elements . clone ( ) ; return c ; } 
public void draw ( Context ctx ) { throw new UnsupportedOperationException ( " Not supported yet. " ) ; } 
public void save ( File file ) { throw new UnsupportedOperationException ( " Not supported yet. " ) ; 
public Rect bounds ( ) ; public Grob clone ( ) ; public void draw ( Context ctx ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof PathElement ) ) return false ; PathElement el = ( PathElement ) o ; return command = = el . command & & point . equals ( el . point ) & & 
public String toString ( ) { switch ( command ) { case COMMAND_MOVETO : return " PathElement(COMMAND_MOVETO, " + getX ( ) + " , " + getY ( ) + " ) " ; case COMMAND_LINETO : return " PathElement(COMMAND_LINETO, " + getX ( ) + " , " + getY ( ) + " ) " ; case COMMAND_CURVETO : return " PathElement(COMMAND_CURVETO, " + getControl1 ( ) . getX ( ) + " , " + getControl1 ( ) . getY ( ) + " , " + getControl2 ( ) . getX ( ) + " , " + getControl2 ( ) . getY ( ) + " , " + getX ( ) + " , " + getY ( ) + " ) " ; case COMMAND_CLOSE : return " PathElement(COMMAND_CLOSE) " ; } throw new AssertionError ( " Invalid PathElement command " + command ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Point ) ) return false ; Point p = ( Point ) o ; return x = = p . x & & y = = p . y ; } 
public String toString ( ) { return " Point( " + x + " , " + y + " ) " ; } 
public boolean isEmpty ( ) { Rect = normalized ( ) ; return . width < = 0 | | . height < = 0 ; } 
public Rect normalized ( ) { Rect r = new Rect ( this ) ; if ( r . width < 0 ) { r . x + = r . width ; r . width = - r . width ; } if ( r . height < 0 ) { r . y + = r . height ; r . height = - r . height ; } return r ; } 
public Rect united ( Rect r ) { Rect r1 = normalized ( ) ; Rect r2 = r . normalized ( ) ; Rect u = new Rect ( ) ; u . x = Math . min ( r1 . x , r2 . x ) ; u . y = Math . min ( r1 . y , r2 . y ) ; u . width = Math . max ( r1 . x + r1 . width , r2 . x + r2 . width ) - u . x ; u . height = Math . max ( r1 . y + r1 . height , r2 . y + r2 . height ) - u . y ; return u ; } 
public boolean intersects ( Rect r ) { Rect r1 = normalized ( ) ; Rect r2 = r . normalized ( ) ; return Math . max ( r1 . x , r1 . y ) < Math . min ( r1 . x + r1 . width , r2 . width ) & & Math . max ( r1 . y , r2 . y ) < Math . min ( r1 . y + r1 . height , r2 . y + r2 . height ) ; 
public boolean contains ( Point p ) { Rect r = normalized ( ) ; return p . getX ( ) > = r . x & & p . getX ( ) < = r . x + r . width & & p . getY ( ) > = r . y & & p . getY ( ) < = r . y + r . height ; 
public boolean contains ( Rect r ) { Rect r1 = normalized ( ) ; Rect r2 = r . normalized ( ) ; return r2 . x > = r1 . x & & r2 . x + r2 . width < = r1 . x + r1 . width & & r2 . y > = r1 . y & & r2 . y + r2 . height < = r1 . y + r1 . height ; 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Rect ) ) return false ; Rect r = ( Rect ) o ; return x = = r . x & & y = = r . y & & width = = r . width & & height = = r . height ; } 
public String toString ( ) { return " Rect( " + x + " , " + y + " , " + width + " , " + height + " ) " ; } 
private void markDirtyDownstream ( ) { getInputNode ( ) . markDirty ( ) ; } 
private void update ( ) { TODO: implement throw new UnsupportedOperationException("Not yet implemented"); } 
public int asInt ( int channel ) { Object value = evaluateForChannel ( channel ) ; if ( value instanceof Number ) { return ( Integer ) value ; 
public double asFloat ( int channel ) { Object value = evaluateForChannel ( channel ) ; if ( value instanceof Number ) { return ( Double ) value ; 
public String asString ( int channel ) { Object value = evaluateForChannel ( channel ) ; if ( value instanceof String ) { return ( String ) value ; 
public Object asData ( int channel ) { return evaluateForChannel ( channel ) ; } 
public Object evaluate ( ) { return MVEL . executeExpression ( compiledExpression ) ; } 
public Object evaluateForChannel ( int channel ) { return MVEL . executeExpression ( compiledExpression ) ; } 
public boolean remove ( Node node ) { assert ( node ! = null ) ; if ( ! contains ( node ) ) { return false ; } node . markDirty ( ) ; TODO: disconnect node from the old network. node.disconnect(); nodes.remove(node.getName()); if (node == renderedNode) { setRenderedNode(null); } TODO: notify return true; } 
public boolean contains ( Node node ) { return nodes . containsValue ( node ) ; } 
public boolean contains ( String nodeName ) { return nodes . containsKey ( nodeName ) ; } 
protected void process ( ) { if ( renderedNode = = null ) { throw new ProcessingError ( this , " No node to render " ) ; } assert ( contains ( renderedNode ) ) ; renderedNode . update ( ) ; TODO: Channel support _setOutput(renderedNode.outputAsData()); } 
public void _setNetwork ( Network network ) { this . network = network ; } 
public String defaultName ( ) { return getClass ( ) . getSimpleName ( ) . toLowerCase ( ) ; } 
public static boolean validName ( String name ) { Pattern nodeNamePattern = Pattern . compile ( " ^[a-z_][a-z0-9_]{0,29}$ " ) ; Pattern doubleUnderScorePattern = Pattern . compile ( " ^__.*$ " ) ; Matcher m1 = nodeNamePattern . matcher ( name ) ; Matcher m2 = doubleUnderScorePattern . matcher ( name ) ; return m1 . matches ( ) & & ! m2 . matches ( ) ; } 
public void _setName ( String name ) { if ( validName ( name ) ) { this . name = name ; 
public Parameter addParameter ( String name , String type ) { if ( hasParameter ( name ) ) { throw new Parameter . InvalidName ( null , name , " There is already a parameter called \" " + name + " \" for this node. " ) ; } Parameter p = new Parameter ( this , name , type ) ; parameters . put ( name , p ) ; markDirty ( ) ; return p ; } 
public boolean hasParameter ( String name ) { return parameters . containsKey ( name ) ; } 
public int asInt ( String name ) { return getParameter ( name ) . asInt ( ) ; } 
public int asInt ( String name , int channel ) { return getParameter ( name ) . asInt ( channel ) ; } 
public double asFloat ( String name ) { return getParameter ( name ) . asFloat ( ) ; } 
public double asFloat ( String name , int channel ) { return getParameter ( name ) . asFloat ( channel ) ; } 
public String asString ( String name ) { return getParameter ( name ) . asString ( ) ; } 
public String asString ( String name , int channel ) { return getParameter ( name ) . asString ( channel ) ; } 
public Object asData ( String name ) { return getParameter ( name ) . asData ( ) ; 
public Object asData ( String name , int channel ) { return getParameter ( name ) . asData ( channel ) ; } 
public int outputAsInt ( ) { return outputParameter . asInt ( ) ; } 
public int outputAsInt ( int channel ) { return outputParameter . asInt ( channel ) ; } 
public double outputAsFloat ( ) { return outputParameter . asFloat ( ) ; } 
public double outputAsFloat ( int channel ) { return outputParameter . asFloat ( channel ) ; } 
public String outputAsString ( ) { return outputParameter . asString ( ) ; } 
public String outputAsString ( int channel ) { return outputParameter . asString ( channel ) ; } 
public Object outputAsData ( ) { return outputParameter . asData ( ) ; } 
public Object outputAsData ( int channel ) { return outputParameter . asData ( channel ) ; } 
public void set ( String name , int value ) { getParameter ( name ) . set ( value ) ; } 
public void set ( String name , int value , int channel ) { getParameter ( name ) . set ( value , channel ) ; } 
public void set ( String name , double value ) { getParameter ( name ) . set ( value ) ; } 
public void set ( String name , double value , int channel ) { getParameter ( name ) . set ( value , channel ) ; } 
public void set ( String name , String value ) { getParameter ( name ) . set ( value ) ; } 
public void set ( String name , String value , int channel ) { getParameter ( name ) . set ( value , channel ) ; } 
public void set ( String name , Object value ) { getParameter ( name ) . set ( value ) ; } 
public void set ( String name , Object value , int channel ) { getParameter ( name ) . set ( value , channel ) ; } 
public void markDirty ( ) { if ( dirty ) { return ; } dirty = true ; for ( Connection c : downstreams ) { c . getInputNode ( ) . markDirty ( ) ; } if ( inNetwork ( ) & & ! network . isDirty ( ) ) { TODO: this is not ideal, since only changes to the rendered node should make the network dirty. 
public void update ( ) { if ( dirty ) { for ( Parameter p : parameters . values ( ) ) { p . update ( ) ; } } process ( ) ; dirty = false ; } 
public boolean isOutputConnected ( ) { return downstreams . size ( ) > 0 ; } 
public void _setOutput ( int value ) { outputParameter . set ( value ) ; } 
public void _setOutput ( int value , int channel ) { outputParameter . set ( value , channel ) ; } 
public void _setOutput ( double value ) { outputParameter . set ( value ) ; } 
public void _setOutput ( double value , int channel ) { outputParameter . set ( value , channel ) ; } 
public void _setOutput ( String value ) { outputParameter . set ( value ) ; } 
public void _setOutput ( String value , int channel ) { outputParameter . set ( value , channel ) ; } 
public void _setOutput ( Object value ) { outputParameter . set ( value ) ; } 
public void _setOutput ( Object value , int channel ) { outputParameter . set ( value , channel ) ; } 
protected void process ( ) { This space intentionally left blank. } Connection public boolean isConnected() { Check upstream connections for (Parameter p : parameters.values()) { if (p.isConnected()) { return true; } } Check downstream connections return !downstreams.isEmpty(); } public void disconnect() { Disconnect upstream for (Parameter p : parameters.values()) { p.disconnect(); } Disconnect downstream outputParameter.disconnect(); } public void _addDownstream(Connection connection) { TODO: Check if the connection/parameter is already in the list. assert (connection != null); assert (connection.getOutputNode() == this); assert (connection.getInputNode() != this); downstreams.add(connection); } public void _removeDownstream(Connection connection) { if (!downstreams.remove(connection)) { Logger.getLogger(LOG_NODE).log(Level.WARNING, "Could not remove connection " + connection + " on node " + name); assert (false); } } Output @Override public String toString() { return "Node(" + name + ")"; }} 
public boolean isConnected ( ) { Check upstream connections for (Parameter p : parameters.values()) { if (p.isConnected()) { return true; } } Check downstream connections return !downstreams.isEmpty(); } 
public void disconnect ( ) { Disconnect upstream for (Parameter p : parameters.values()) { p.disconnect(); } Disconnect downstream outputParameter.disconnect(); } 
public void _addDownstream ( Connection connection ) { TODO: Check if the connection/parameter is already in the list. assert (connection != null); assert (connection.getOutputNode() == this); assert (connection.getInputNode() != this); downstreams.add(connection); } 
public void _removeDownstream ( Connection connection ) { if ( ! downstreams . remove ( connection ) ) { Logger . getLogger ( LOG_NODE ) . log ( Level . WARNING , " Could not remove connection " + connection + " on node " + name ) ; 
public String toString ( ) { return " Node( " + name + " ) " ; } 
public static Version parseVersionString ( String s ) { throw new RuntimeException ( " Not yet implemented " ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Version ) ) return false ; Version v = ( Version ) o ; return major = = v . major & & minor = = v . minor & & 
public String toString ( ) { return major + " . " + minor + " . " + revision ; } 
public String versionAsString ( ) { return version . toString ( ) ; } 
private LibraryType detectType ( ) { File javaLibrary = new File ( getJavaLibraryPath ( ) ) ; if ( javaLibrary . exists ( ) ) { type = LibraryType . JAVA ; return type ; } File pythonLibrary = new File ( getPythonLibraryPath ( ) ) ; if ( pythonLibrary . exists ( ) ) { type = LibraryType . PYTHON ; return type ; } type = LibraryType . UNKNOWN ; return type ; } 
public void addSearchPath ( String searchPath ) throws IOException { File f = new File ( searchPath ) ; addSearchPath ( f ) ; } 
public void addSearchPath ( File searchPath ) throws IOException { if ( ! searchPath . isDirectory ( ) ) { throw new IOException ( " The given search path \" " + searchPath + " \" is not a directory. " ) ; } this . searchPaths . add ( searchPath ) ; } 
public NodeLibrary loadLatestVersion ( String libraryName ) { throw new AssertionError ( " Not implemented yet. " ) ; } 
private void lookForLibraries ( ) { } private NodeLibrary directoryNameToLibrary ( String searchPath , String directoryName ) { searchPath.split("-") throw new AssertionError("Not implemented yet."); }} 
private NodeLibrary directoryNameToLibrary ( String searchPath , String directoryName ) { searchPath.split("-") throw new AssertionError("Not implemented yet."); } 
public boolean isInputParameter ( ) { return direction = = DIRECTION_IN ; } 
public boolean isOutputParameter ( ) { return direction = = DIRECTION_OUT ; } 
public static boolean validName ( String name ) { Pattern nodeNamePattern = Pattern . compile ( " ^[a-z_][a-z0-9_]{0,29}$ " ) ; Pattern doubleUnderScorePattern = Pattern . compile ( " ^__.*$ " ) ; Pattern reservedPattern = Pattern . compile ( " ^(node|name)$ " ) ; Matcher m1 = nodeNamePattern . matcher ( name ) ; Matcher m2 = doubleUnderScorePattern . matcher ( name ) ; Matcher m3 = reservedPattern . matcher ( name ) ; return m1 . matches ( ) & & ! m2 . matches ( ) & & ! m3 . matches ( ) ; } 
public boolean valueCorrectForBounds ( double value ) { if ( boundingType ! = BOUNDING_HARD ) { return true ; } if ( value > = minimum & & value < = maximum ) { return true ; } return false ; } 
private void clampToBounds ( ) { if ( coreType = = CORE_TYPE_INT ) { for ( int i = 0 ; i < channelCount ; i + + ) { 
public int asInt ( int channel ) { if ( coreType = = CORE_TYPE_INT ) { return ( Integer ) channels [ channel ] ; 
public double asFloat ( int channel ) { if ( coreType = = CORE_TYPE_FLOAT ) { return ( Double ) channels [ channel ] ; 
public String asString ( int channel ) { if ( coreType = = CORE_TYPE_STRING ) { return ( String ) channels [ channel ] ; 
public Object asData ( int channel ) { return channels [ channel ] ; } 
public void set ( int value , int channel ) { if ( channel < 0 | | channel > channelCount ) { throw new ValueError ( " Invalid channel " + channel ) ; } if ( coreType ! = CORE_TYPE_INT ) { throw new ValueError ( " Tried setting integer value on parameter with type " + type ) ; } if ( ! valueCorrectForBounds ( value ) ) { throw new ValueError ( " Value is out of bounds " ) ; } TODO: lazy setting preSet(); channels[channel] = value; postSet(); } 
public void set ( double value , int channel ) { if ( channel < 0 | | channel > = channelCount ) { throw new ValueError ( " Invalid channel " + channel ) ; } if ( coreType ! = CORE_TYPE_FLOAT ) { throw new ValueError ( " Tried setting float value on parameter with type " + type ) ; } if ( ! valueCorrectForBounds ( value ) ) { throw new ValueError ( " Value is out of bounds " ) ; } TODO: lazy setting preSet(); channels[channel] = value; postSet(); } 
public void set ( String value , int channel ) { if ( channel < 0 | | channel > channelCount ) { throw new ValueError ( " Invalid channel " + channel ) ; } if ( coreType ! = CORE_TYPE_STRING ) { throw new ValueError ( " Tried setting string value on parameter with type " + type ) ; } TODO: lazy setting preSet(); channels[channel] = value; postSet(); } 
public void set ( Object value , int channel ) { if ( channel < 0 | | channel > channelCount ) { throw new ValueError ( " Invalid channel " + channel ) ; } if ( coreType ! = CORE_TYPE_DATA ) { throw new ValueError ( " Tried setting object value on parameter with type " + type ) ; } TODO: lazy setting preSet(); channels[channel] = value; postSet(); } 
public boolean hasExpression ( ) { return expression ! = null ; } 
public boolean canConnectTo ( Node node ) { if ( isOutputParameter ( ) ) { return false ; } return node . getOutputParameter ( ) . getType ( ) . equals ( getType ( ) ) ; } 
public Connection connect ( Node outputNode ) { if ( ! isInputParameter ( ) ) { throw new ConnectionError ( outputNode , this , " Can only connect input nodes " ) ; } if ( this . node = = outputNode ) { throw new ConnectionError ( outputNode , this , " Cannot connect to myself " ) ; } if ( ! canConnectTo ( outputNode ) ) { throw new ConnectionError ( outputNode , this , " Cannot connect to " + outputNode . getName ( ) ) ; } disconnect ( ) ; connection = new Connection ( outputNode . getOutputParameter ( ) , this ) ; outputNode . _addDownstream ( connection ) ; getNode ( ) . markDirty ( ) ; TODO: notify return connection; } 
public boolean disconnect ( ) { TODO: also support disconnecting output parameters. assert (isInputParameter()); if (!isConnected()) { return false; } if (connection.hasOutput()) { assert (connection.getOutputNode().isOutputConnectedTo(this)); connection.getOutputNode()._removeDownstream(connection); } connection = null; revertToDefault(); node.markDirty(); TODO: notify return true; } 
public boolean isConnected ( ) { return connection ! = null ; } 
public boolean isConnectedTo ( Node node ) { if ( ! isConnected ( ) ) { return false ; 
public void update ( ) { The connection takes precedence over the expression. if (isConnected()) { connection.getOutputNode().update(); 
public void revertToDefault ( ) { for ( int i = 0 ; i < channelCount ; i + + ) { if ( coreType = = CORE_TYPE_INT ) { 
protected void preSet ( ) { TODO: validate } protected void postSet() { node.markDirty(); }} 
public static String humanizeName ( String name ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] tokens = name . split ( " _ " ) ; for ( String : tokens ) { if ( . length ( ) = = 0 ) continue ; sb . append ( . substring ( 0 , 1 ) . toUpperCase ( ) ) ; sb . append ( . substring ( 1 ) ) ; sb . append ( " " ) ; } return sb . toString ( ) . trim ( ) ; } 
public void testSize ( ) { BezierPath p = new BezierPath ( ) ; assertEquals ( 0 , p . size ( ) ) ; p . moveto ( 0 , 0 ) ; assertEquals ( 1 , p . size ( ) ) ; p . lineto ( 100 , 100 ) ; assertEquals ( 2 , p . size ( ) ) ; p . clear ( ) ; assertEquals ( 0 , p . size ( ) ) ; } 
public void testClone ( ) { BezierPath p1 = new BezierPath ( ) ; p1 . moveto ( 0 , 0 ) ; p1 . lineto ( 100 , 100 ) ; assertEquals ( 2 , p1 . size ( ) ) ; BezierPath p2 = ( BezierPath ) p1 . clone ( ) ; assertEquals ( 2 , p2 . size ( ) ) ; p1 . clear ( ) ; assertEquals ( 0 , p1 . size ( ) ) ; assertEquals ( 2 , p2 . size ( ) ) ; } 
public void testElements ( ) { BezierPath p = new BezierPath ( ) ; p . moveto ( 1 , 2 ) ; p . lineto ( 3 , 4 ) ; p . close ( ) ; assertEquals ( 3 , p . size ( ) ) ; assertEquals ( new PathElement ( PathElement . COMMAND_MOVETO , 1 , 2 ) , p . getElementAt ( 0 ) ) ; assertEquals ( new PathElement ( PathElement . COMMAND_LINETO , 3 , 4 ) , p . getElementAt ( 1 ) ) ; assertEquals ( new PathElement ( PathElement . COMMAND_CLOSE ) , p . getElementAt ( 2 ) ) ; } 
public void testEquality ( ) { BezierPath p1 = new BezierPath ( ) ; assertEquals ( p1 , p1 ) ; BezierPath p2 = new BezierPath ( ) ; assertEquals ( p1 , p2 ) ; BezierPath p3 = new BezierPath ( ) ; p1 . moveto ( 1 , 2 ) ; p2 . moveto ( 1 , 2 ) ; assertEquals ( p1 , p2 ) ; assertNotSame ( p1 , p3 ) ; p1 . lineto ( 3 , 4 ) ; assertNotSame ( p1 , p2 ) ; assertNotSame ( p1 , p3 ) ; } 
public void testBounds ( ) { BezierPath p1 = new BezierPath ( ) ; p1 . rect ( 20 , 30 , 40 , 50 ) ; assertEquals ( new Rect ( 20 , 30 , 40 , 50 ) , p1 . bounds ( ) ) ; BezierPath p2 = new BezierPath ( ) ; p2 . rect ( 60 , 70 , 80 , 90 ) ; assertEquals ( new Rect ( 60 , 70 , 80 , 90 ) , p2 . bounds ( ) ) ; } 
public void testEmpty ( ) { assertFalse ( new Rect ( 100 , 100 , 100 , 100 ) . isEmpty ( ) ) ; assertFalse ( new Rect ( 1 , 1 , 1 , 1 ) . isEmpty ( ) ) ; assertFalse ( new Rect ( 0 , 0 , 1 , 1 ) . isEmpty ( ) ) ; assertFalse ( new Rect ( 0 , 0 , - 100 , - 200 ) . isEmpty ( ) ) ; assertTrue ( new Rect ( 0 , 0 , 0 , 0 ) . isEmpty ( ) ) ; assertTrue ( new Rect ( - 10 , 0 , 0 , 10 ) . isEmpty ( ) ) ; assertTrue ( new Rect ( - 10 , 0 , 200 , 0 ) . isEmpty ( ) ) ; assertTrue ( new Rect ( 20 , 30 , 10 , 0 ) . isEmpty ( ) ) ; } 
public void testIntersects ( ) { assertFalse ( new Rect ( 0 , 0 , 20 , 20 ) . intersects ( new Rect ( 100 , 100 , 20 , 20 ) ) ) ; assertTrue ( new Rect ( 0 , 0 , 20 , 20 ) . intersects ( new Rect ( 0 , 0 , 20 , 20 ) ) ) ; } 
public void testUnited ( ) { Rect r1 = new Rect ( 10 , 20 , 30 , 40 ) ; Rect r2 = new Rect ( 40 , 10 , 50 , 30 ) ; assertEquals ( new Rect ( 10 , 10 , 80 , 50 ) , r1 . united ( r2 ) ) ; } 
public void testContains ( ) { Rect r = new Rect ( 10 , 20 , 30 , 40 ) ; assertTrue ( r . contains ( new Point ( 10 , 20 ) ) ) ; assertTrue ( r . contains ( new Point ( 11 , 22 ) ) ) ; assertTrue ( r . contains ( new Point ( 40 , 60 ) ) ) ; assertFalse ( r . contains ( new Point ( 0 , 0 ) ) ) ; assertFalse ( r . contains ( new Point ( - 11 , - 22 ) ) ) ; assertFalse ( r . contains ( new Point ( 100 , 200 ) ) ) ; assertFalse ( r . contains ( new Point ( 15 , 200 ) ) ) ; assertFalse ( r . contains ( new Point ( 200 , 25 ) ) ) ; assertTrue ( r . contains ( new Rect ( 10 , 20 , 30 , 40 ) ) ) ; assertTrue ( r . contains ( new Rect ( 15 , 25 , 5 , 5 ) ) ) ; assertFalse ( r . contains ( new Rect ( 15 , 25 , 30 , 40 ) ) ) ; assertFalse ( r . contains ( new Rect ( 1 , 2 , 3 , 4 ) ) ) ; assertFalse ( r . contains ( new Rect ( 15 , 25 , 300 , 400 ) ) ) ; assertFalse ( r . contains ( new Rect ( 15 , 25 , 5 , 400 ) ) ) ; assertFalse ( r . contains ( new Rect ( 15 , 25 , 400 , 5 ) ) ) ; } 
public void testDirty ( ) { NumberGenerator ng = new NumberGenerator ( ) ; assertTrue ( ng . isDirty ( ) ) ; ng . update ( ) ; assertFalse ( ng . isDirty ( ) ) ; assertEquals ( 0 , ng . outputAsInt ( ) ) ; ng . set ( " number " , 12 ) ; assertTrue ( ng . isDirty ( ) ) ; Asking for the output value doesn't update the node implicitly. assertEquals(0, ng.outputAsInt()); You have to explicitly update the node to get the new output value. ng.update(); assertFalse(ng.isDirty()); assertEquals(12, ng.outputAsInt()); } 
public void testConnect ( ) { NumberGenerator ng = new NumberGenerator ( ) ; Multiplier m = new Multiplier ( ) ; assertFalse ( m . getParameter ( " number " ) . isConnected ( ) ) ; assertFalse ( m . getParameter ( " number " ) . isConnectedTo ( ng ) ) ; assertFalse ( ng . isOutputConnected ( ) ) ; assertFalse ( ng . isOutputConnectedTo ( m ) ) ; assertFalse ( ng . isOutputConnectedTo ( m . getParameter ( " number " ) ) ) ; assertTrue ( m . getParameter ( " number " ) . canConnectTo ( ng ) ) ; assertTrue ( m . getParameter ( " multiplier " ) . canConnectTo ( ng ) ) ; assertFalse ( m . getParameter ( " somestring " ) . canConnectTo ( ng ) ) ; Connection conn = m . getParameter ( " number " ) . connect ( ng ) ; assertTrue ( m . getParameter ( " number " ) . isConnected ( ) ) ; assertTrue ( m . getParameter ( " number " ) . isConnectedTo ( ng ) ) ; assertTrue ( ng . isOutputConnected ( ) ) ; assertTrue ( ng . isOutputConnectedTo ( m ) ) ; assertTrue ( ng . isOutputConnectedTo ( m . getParameter ( " number " ) ) ) ; assertEquals ( m . getParameter ( " number " ) , conn . getInputParameter ( ) ) ; assertEquals ( ng . getOutputParameter ( ) , conn . getOutputParameter ( ) ) ; assertEquals ( m , conn . getInputNode ( ) ) ; assertEquals ( ng , conn . getOutputNode ( ) ) ; assertConnectionError ( m , " somestring " , ng , " Somestring is of the wrong type and should not be connectable to NumberGenerator's output. " ) ; } 
public void testCycles ( ) { NumberGenerator ng = new NumberGenerator ( ) ; assertConnectionError ( ng , " number " , ng , " Nodes cannot connect to themselves. " ) ; TODO: more complex cyclic checks (A->B->A) 
public void testDirtyPropagation ( ) { NumberGenerator ng = new NumberGenerator ( ) ; Multiplier m = new Multiplier ( ) ; Nodes start out dirty assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating makes them clean ng.update(); m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Connecting the multiplier to another node makes it dirty. The output node doesn't become dirty. m.getParameter("number").connect(ng); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(ng.isDirty()); This shouldn't have changed. assertFalse(m.isDirty()); A change to the upstream node should make downstream nodes dirty. ng.set("number", 12); assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating the downstream node should make all upstreams clean, because their output values are needed to calculate the downstream. m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Changes to the downstream node don't affect upstreams. m.set("multiplier", 1); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); Disconnecting makes the downstream dirty. m.getParameter("number").disconnect(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); Check is disconnected nodes still propagate. ng.update(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); ng.set("number", 12); assertTrue(ng.isDirty()); assertFalse(m.isDirty()); } 
public void testValuePropagation ( ) { NumberGenerator ng = new NumberGenerator ( ) ; Multiplier m = new Multiplier ( ) ; m . set ( " multiplier " , 2 ) ; m . getParameter ( " number " ) . connect ( ng ) ; assertEquals ( 0 , m . outputAsInt ( ) ) ; ng . set ( " number " , 3 ) ; assertTrue ( m . isDirty ( ) ) ; assertEquals ( 0 , m . outputAsInt ( ) ) ; Updating the NumberGenerator node has no effect on the multiplier node. ng.update(); assertTrue(m.isDirty()); assertEquals(0, m.outputAsInt()); m.update(); assertFalse(m.isDirty()); assertEquals(6, m.outputAsInt()); Test if value stops propagating after disconnection. m.getParameter("number").disconnect(); assertTrue(m.isDirty()); assertFalse(ng.isDirty()); ng.set("number", 3); m.update(); assertEquals(0, m.outputAsInt()); } 
public void testDisconnect ( ) { NumberGenerator ng = new NumberGenerator ( ) ; Multiplier m = new Multiplier ( ) ; m . set ( " multiplier " , 2 ) ; ng . set ( " number " , 5 ) ; m . getParameter ( " number " ) . connect ( ng ) ; assertTrue ( m . getParameter ( " number " ) . isConnected ( ) ) ; assertTrue ( ng . isOutputConnected ( ) ) ; m . update ( ) ; assertEquals ( 5 , m . asInt ( " number " ) ) ; assertEquals ( 10 , m . outputAsInt ( ) ) ; m . getParameter ( " number " ) . disconnect ( ) ; assertTrue ( m . isDirty ( ) ) ; assertFalse ( ng . isDirty ( ) ) ; assertFalse ( m . getParameter ( " number " ) . isConnected ( ) ) ; assertFalse ( ng . isOutputConnected ( ) ) ; Numbers reverts to default after disconnection m.update(); assertEquals(0, m.outputAsInt()); } 
private void assertConnectionError ( Node inputNode , String inputParameter , Node outputNode , String message ) { try { inputNode . getParameter ( inputParameter ) . connect ( outputNode ) ; 
protected void process ( ) { int number = asInt ( " number " ) ; _setOutput ( number ) ; } 
protected void process ( ) { int number = asInt ( " number " ) ; int multiplier = asInt ( " multiplier " ) ; _setOutput ( number * multiplier ) ; } 
public void testSimple ( ) { Node = new Node ( Parameter . TYPE_INT ) ; Parameter p1 = . addParameter ( " p1 " , Parameter . TYPE_INT ) ; Expression e = new Expression ( p1 , " 1 + 2 " ) ; assertEquals ( 3 , e . asInt ( ) ) ; } 
public void testNaming ( ) { Node = new Node ( Parameter . TYPE_INT ) ; assertEquals ( . defaultName ( ) , " node " ) ; assertEquals ( . getName ( ) , " node " ) ; } 
public void testParameters ( ) { Node = new Node ( Parameter . TYPE_INT ) ; try { . getParameter ( " p1 " ) ; fail ( " Should have thrown Parameter.NotFound " ) ; } catch ( Parameter . NotFound e ) { } Parameter p1 = . addParameter ( " p1 " , Parameter . TYPE_INT ) ; assertTrue ( . hasParameter ( " p1 " ) ) ; try { . getParameter ( " p1 " ) ; } catch ( Parameter . NotFound e ) { fail ( " Should not have thrown Parameter.NotFound " ) ; } assertEquals ( . getParameter ( " p1 " ) , p1 ) ; try { . getParameter ( " x " ) ; 
public void testNodeNaming ( ) { Node = new Node ( Parameter . TYPE_INT ) ; checkInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; TODO: are there reserved words in node naming? checkInvalidName(n, "UPPERCASE", "names cannot be in uppercase."); checkInvalidName(n, "uPpercase", "names cannot contain uppercase letters"); checkInvalidName(n, "__reserved", "names cannot start with double underscores"); checkInvalidName(n, "what!", "Only lowercase, numbers and underscore are allowed"); checkInvalidName(n, "$-#34", "Only lowercase, numbers and underscore are allowed"); checkInvalidName(n, "", "names cannot be empty"); checkInvalidName(n, "very_very_very_very_very_very_long_name", "names cannot be longer than 30 characters"); checkValidName(n, "radius"); checkValidName(n, "_test"); checkValidName(n, "_"); checkValidName(n, "_1234"); checkValidName(n, "a1234"); } 
public void testDirty ( ) { Node = new Node ( Parameter . TYPE_INT ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . addParameter ( " test " , Parameter . TYPE_INT ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . set ( " test " , 12 ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . getParameter ( " test " ) . set ( 13 ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; } 
private void checkInvalidName ( Node , String newName , String reason ) { try { . setName ( newName ) ; 
private void checkValidName ( Node , String newName ) { try { . setName ( newName ) ; 
public void testNaming ( ) { Node = new Node ( Parameter . TYPE_INT ) ; Parameter p = . addParameter ( " test " , Parameter . TYPE_INT ) ; checkInvalidName ( p , " 1234 " , " names cannot start with a digit. " ) ; checkInvalidName ( p , " node " , " names can not be one of the reserved words. " ) ; checkInvalidName ( p , " name " , " names can not be one of the reserved words. " ) ; checkInvalidName ( p , " UPPERCASE " , " names cannot be in uppercase. " ) ; checkInvalidName ( p , " uPpercase " , " names cannot contain uppercase letters " ) ; checkInvalidName ( p , " __reserved " , " names cannot start with double underscores " ) ; checkInvalidName ( p , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( p , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( p , " " , " names cannot be empty " ) ; checkInvalidName ( p , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; checkValidName ( p , " radius " ) ; checkValidName ( p , " _test " ) ; checkValidName ( p , " _ " ) ; checkValidName ( p , " _1234 " ) ; checkValidName ( p , " a1234 " ) ; TODO: Right now, these names are accepted, although they will conflict with the internal node attributes. checkValidName(p, "x"); checkValidName(p, "y"); checkValidName(p, "dirty"); checkValidName(p, "process"); } 
public void testInvalidName ( ) { Node = new Node ( Parameter . TYPE_INT ) ; Parameter pAlice = . addParameter ( " alice " , Parameter . TYPE_FLOAT ) ; Parameter pBob = . addParameter ( " bob " , Parameter . TYPE_FLOAT ) ; assertEquals ( pAlice . getName ( ) , " alice " ) ; assertEquals ( pBob . getName ( ) , " bob " ) ; checkValidName ( pBob , " joe " ) ; assertEquals ( pBob . getName ( ) , " joe " ) ; assertFalse ( . hasParameter ( " bob " ) ) ; assertTrue ( . hasParameter ( " joe " ) ) ; checkParameterNotFound ( , " bob " ) ; assertEquals ( pBob , . getParameter ( " joe " ) ) ; checkInvalidName ( pBob , " alice " , " Can not take the name of an existing parameter. " ) ; assertEquals ( pBob , . getParameter ( " joe " ) ) ; Check the previous setName hasn't affected the current name. } 
public void testLabel ( ) { Node = new Node ( Parameter . TYPE_INT ) ; Parameter p1 = . addParameter ( " width " , Parameter . TYPE_FLOAT ) ; assertEquals ( " Width " , p1 . getLabel ( ) ) ; Parameter p2 = . addParameter ( " a_somewhat_longer_parameter " , Parameter . TYPE_FLOAT ) ; assertEquals ( " A Somewhat Longer Parameter " , p2 . getLabel ( ) ) ; Parameter p3 = . addParameter ( " double__underscores__everywhere " , Parameter . TYPE_FLOAT ) ; assertEquals ( " Double Underscores Everywhere " , p3 . getLabel ( ) ) ; } 
public void testValues ( ) { ValueNode = new ValueNode ( ) ; assertEquals ( Parameter . TYPE_INT , . pInt . getType ( ) ) ; assertEquals ( Parameter . TYPE_FLOAT , . pFloat . getType ( ) ) ; assertEquals ( Parameter . TYPE_STRING , . pString . getType ( ) ) ; assertEquals ( 0 , . pInt . asInt ( ) ) ; assertEquals ( 0.0 , . pFloat . asFloat ( ) ) ; assertEquals ( " " , . pString . asString ( ) ) ; . pInt . set ( 12 ) ; . pFloat . set ( 0.5 ) ; . pString . set ( " hello " ) ; assertEquals ( 12 , . pInt . asInt ( ) ) ; assertEquals ( 0.5 , . pFloat . asFloat ( ) ) ; assertEquals ( " hello " , . pString . asString ( ) ) ; } 
public void testChannels ( ) { Node = new Node ( Parameter . TYPE_INT ) ; Parameter color = . addParameter ( " color " , Parameter . TYPE_COLOR ) ; assertEquals ( 4 , color . channelCount ( ) ) ; checkValidSet ( color , 0.2 , 0 ) ; checkValidSet ( color , 0.4 , 1 ) ; checkValidSet ( color , 0.7 , 2 ) ; checkValidSet ( color , 1.0 , 3 ) ; checkInvalidSet ( color , 0.5 , 4 ) ; checkInvalidSet ( color , 0.5 , - 1 ) ; } 
public void testBounding ( ) { Node = new Node ( Parameter . TYPE_INT ) ; Parameter angle = . addParameter ( " angle " , Parameter . TYPE_ANGLE ) ; angle . setBoundingType ( Parameter . BOUNDING_SOFT ) ; angle . setMinimum ( - 100.0 ) ; angle . setMaximum ( 100.0 ) ; checkValidSet ( angle , 0.0 ) ; checkValidSet ( angle , 1000.0 ) ; checkValidSet ( angle , - 1000.0 ) ; angle . setBoundingType ( Parameter . BOUNDING_HARD ) ; assertEquals ( - 100.0 , angle . asFloat ( ) ) ; Setting the bounding type to hard clamped the value checkInvalidSet(angle, 500.0); angle.setBoundingType(Parameter.BOUNDING_NONE); checkValidSet(angle, 300.0); angle.setBoundingType(Parameter.BOUNDING_HARD); assertEquals(100.0, angle.asFloat()); } 
private void checkInvalidName ( Parameter p , String newName , String reason ) { try { p . setName ( newName ) ; 
private void checkValidName ( Parameter p , String newName ) { try { p . setName ( newName ) ; 
private void checkParameterNotFound ( Node , String name ) { try { . getParameter ( name ) ; 
private void checkValidSet ( Parameter p , double value ) { checkValidSet ( p , value , 0 ) ; } 
private void checkValidSet ( Parameter p , double value , int channel ) { try { p . set ( value , channel ) ; 
private void checkInvalidSet ( Parameter p , double value ) { checkInvalidSet ( p , value , 0 ) ; } 
private void checkInvalidSet ( Parameter p , double value , int channel ) { try { p . set ( value , channel ) ; 
public static void main ( String [ ] args ) { System . out . println ( " Maijn method goes here. " ) ; } 
public static void main ( String [ ] args ) { PythonInterpreter interp = new PythonInterpreter ( ) ; interp . exec ( " import sys " ) ; interp . exec ( " print sys " ) ; interp . set ( " a " , new PyInteger ( 42 ) ) ; interp . exec ( " print a " ) ; interp . exec ( " x = 2+2 " ) ; PyObject x = interp . get ( " x " ) ; System . out . println ( " x: " + x ) ; System . out . println ( " Main method goes here. " ) ; } 
public boolean hasOutputNode ( ) { return outputNode ! = null ; } 
public void markDirtyDownstream ( ) { getInputNode ( ) . markDirty ( ) ; } 
public static void validateName ( String name ) { Matcher m1 = NODE_NAME_PATTERN . matcher ( name ) ; Matcher m2 = DOUBLE_UNDERSCORE_PATTERN . matcher ( name ) ; if ( ! m1 . matches ( ) ) { throw new ValueError ( " Name does contain other characters than a-z0-9 or underscore, or is longer than 29 characters. " ) ; } if ( m2 . matches ( ) ) { throw new ValueError ( " Names starting with double underscore are reserved for internal use. " ) ; 
public int parameterSize ( ) { return parameters . size ( ) ; } 
public boolean hasParameter ( String name ) { return parameterMap . containsKey ( name ) ; } 
public Parameter addParameter ( String name , String type ) { Parameter p = new Parameter ( this , name , type ) ; parameterMap . put ( name , p ) ; parameters . add ( p ) ; return p ; } 
public Parameter addParameter ( String name , String type , ParameterGroup g ) { Parameter p = new Parameter ( this , name , type ) ; parameterMap . put ( name , p ) ; g . addParameter ( p ) ; return p ; } 
public boolean isRendered ( ) { return inNetwork ( ) & & network . getRenderedNode ( ) = = this ; } 
public Object asData ( String name ) { return getParameter ( name ) . asData ( ) ; } 
public boolean isInputConnected ( int port ) { if ( upstreams . isEmpty ( ) ) return false ; return getInputConnection ( port ) ! = null ; } 
public boolean disconnectInput ( int port ) { Connection c = getInputConnection ( port ) ; if ( c = = null ) return false ; upstreams . remove ( c ) ; c . getOutputNode ( ) . downstreams . remove ( c ) ; setChanged ( ) ; notifyObservers ( ) ; return true ; } 
public boolean disconnect ( ) { boolean removedSomething = false ; Disconnect all my inputs. for (Connection c : upstreams) { removedSomething = disconnectInput(c.getInputPort()) | removedSomething; } Disconnect all my outputs. for (Connection c : downstreams) { removedSomething = c.getInputNode().disconnectInput(c.getInputPort()) | removedSomething; } return removedSomething; } 
public boolean isConnected ( ) { return ! upstreams . isEmpty ( ) | | ! downstreams . isEmpty ( ) ; } 
protected boolean evaluate ( ProcessingContext ctx ) { return true ; } 
public String toString ( ) { return " < " + getClass ( ) . getSimpleName ( ) + " : " + name + " > " ; } 
public static void validateName ( String name ) { TODO: implement re. Matcher m1 = NODE_NAME_PATTERN.matcher(name); Matcher m2 = DOUBLE_UNDERSCORE_PATTERN.matcher(name); if (!m1.matches()) { throw new ValueError("Name does contain other characters than a-z0-9 or underscore, or is longer than 29 characters."); } if (m2.matches()) { throw new ValueError("Names starting with double underscore are reserved for internal use."); 
public void addParameter ( String name , String type ) { ParameterType p = new ParameterType ( this , name , type ) ; parameterTypes . add ( p ) ; } 
public ParameterType get ( int index ) { return parameterTypes . get ( index ) ; } 
public Iterator < ParameterType > iterator ( ) { return parameterTypes . iterator ( ) ; } 
public Node createNode ( String name ) { return new Node ( this , name ) ; } 
public boolean validName ( String name ) { Check if another parameter has the same name. if (node.getParameter(name) != this) return false; Pattern nodeNamePattern = Pattern.compile("^[a-z_][a-z0-9_]{0,29}$"); Pattern doubleUnderScorePattern = Pattern.compile("^__.*$"); Pattern reservedPattern = Pattern.compile("^(node|name)$"); Matcher m1 = nodeNamePattern.matcher(name); Matcher m2 = doubleUnderScorePattern.matcher(name); Matcher m3 = reservedPattern.matcher(name); return m1.matches() && !m2.matches() && !m3.matches(); } 
private void addExpressionDependency ( Parameter parameter ) { expressionDependencies . addObserver ( parameter ) ; } 
public boolean hasExpressionDependencies ( ) { return expressionDependencies . countObservers ( ) > 0 ; } 
public void update ( Observable o , Object arg ) { node . markDirty ( ) ; } 
public void evaluate ( ) { if ( expressionEnabled ) { } 
public void update ( ) { if ( expressionEnabled ) { TODO: Currently, the expression runs for each channel. 
public boolean addParameter ( Parameter parameter ) { if ( parameters . contains ( parameter ) ) return false ; return parameters . add ( parameter ) ; } 
public boolean removeParameter ( Parameter parameter ) { return parameters . remove ( parameter ) ; } 
private void changeType ( String type ) { TODO: This is actually a setter for type, but it is not made public yet. It has repercussions for all instantiated nodes which we don't handle yet. if (this.type.equals(type)) return; this.type = type; TypeTemplate t = TYPE_REGISTRY.get(type); this.coreType = t.coreType; this.channels = t.channels; } 
public boolean isInputParameter ( ) { return direction = = Direction . IN ; } 
public boolean isOutputParameter ( ) { return direction = = Direction . OUT ; } 
public boolean isCompatible ( Node node ) { return type . equals ( node . getNodeType ( ) . getOutputParameterType ( ) . getType ( ) ) ; } 
public boolean isCompatible ( NodeType nodeType ) { return type . equals ( nodeType . getOutputParameterType ( ) . getType ( ) ) ; } 
public boolean isCompatible ( Parameter parameter ) { return type . equals ( parameter . getParameterType ( ) . getType ( ) ) ; } 
public boolean isCompatible ( ParameterType parameterType ) { return type . equals ( parameterType . getType ( ) ) ; } 
public void validate ( Object value ) { TODO: test for list-likeness? } Parsing public Object parseSingleValue(String value) { switch (coreType) { case INT: return Integer.parseInt(value); case FLOAT: return Float.parseFloat(value); case STRING: return value; default: return value; } } Instance creation public Parameter createParameter(Node node) { if (isInputParameter()) { return new Parameter(this, node); } else { return new OutputParameter(this, node); } }} 
public Object parseSingleValue ( String value ) { switch ( coreType ) { case INT : 
public Parameter createParameter ( Node node ) { if ( isInputParameter ( ) ) { return new Parameter ( this , node ) ; 
public static String join ( List items , String separator ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < items . size ( ) ; i + + ) { boolean lastItem = i = = items . size ( ) - 1 ; sb . append ( items . get ( i ) ) ; if ( ! lastItem ) { sb . append ( separator ) ; } } return sb . toString ( ) ; } 
public static void main ( String [ ] args ) { System . out . println ( " Main method goes here. " ) ; } 
public void deselectAll ( ) { for ( Iterator < Selectable > selectionIter = selection . iterator ( ) ; selectionIter . hasNext ( ) ; ) { Selectable s = selectionIter . next ( ) ; assert s . isSelected ( ) ; s . setSelected ( false ) ; } selection . clear ( ) ; firePropertyChange ( SELECT_PROPERTY , selection , null ) ; } 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; Node = new RectNode ( ) ; ParameterPanel p = new ParameterPanel ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } 
public void setSelected ( boolean s ) ; public boolean isSelected ( ) ; } 
public void nodeAdded ( NetworkEvent e ) { } public void renderedNodeChanged ( NetworkEvent e ) { } } 
public void nodeRemoved ( NetworkEvent e ) { } public void renderedNodeChanged ( NetworkEvent e ) { } } 
public void connectionAdded ( NetworkEvent e ) { } public void renderedNodeChanged ( NetworkEvent e ) { } } 
public void connectionRemoved ( NetworkEvent e ) { } public void renderedNodeChanged ( NetworkEvent e ) { } } 
public void nodeRenamed ( NetworkEvent e ) { } public void renderedNodeChanged ( NetworkEvent e ) { } } 
public void nodeAdded ( NetworkEvent e ) ; public void renderedNodeChanged ( NetworkEvent e ) ; } 
public void nodeRemoved ( NetworkEvent e ) ; public void renderedNodeChanged ( NetworkEvent e ) ; } 
public void connectionAdded ( NetworkEvent e ) ; public void renderedNodeChanged ( NetworkEvent e ) ; } 
public void connectionRemoved ( NetworkEvent e ) ; public void renderedNodeChanged ( NetworkEvent e ) ; } 
public void nodeRenamed ( NetworkEvent e ) ; public void renderedNodeChanged ( NetworkEvent e ) ; } 
public void startProcessing ( Network network ) ; public void endProcessing ( Network network ) ; } 
public int asInt ( ) { Object value = evaluate ( ) ; if ( value instanceof Number ) { return ( Integer ) value ; 
public double asFloat ( ) { Object value = evaluate ( ) ; if ( value instanceof Number ) { return ( Double ) value ; 
public String asString ( ) { Object value = evaluate ( ) ; if ( value instanceof String ) { return ( String ) value ; 
public Color asColor ( ) { Object value = evaluate ( ) ; if ( value instanceof Color ) { return ( Color ) value ; 
protected boolean process ( ProcessingContext ctx ) { if ( renderedNode = = null ) { addError ( " No node to render " ) ; return false ; } assert ( contains ( renderedNode ) ) ; renderedNode . update ( ) ; TODO: place output of rendered node into network output. return true; } 
public synchronized void addNetworkListener ( NetworkListener l ) { listenerList . add ( NetworkListener . class , l ) ; } 
public synchronized void removeNetworkListener ( NetworkListener l ) { listenerList . remove ( NetworkListener . class , l ) ; } 
protected void fireNodeAdded ( Node node ) { Object [ ] listeners = listenerList . getListenerList ( ) ; NetworkEvent e = new NetworkEvent ( this , node ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NetworkListener.class) { 
protected void fireNodeRemoved ( Node node ) { Object [ ] listeners = listenerList . getListenerList ( ) ; NetworkEvent e = new NetworkEvent ( this , node ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NetworkListener.class) { 
protected void fireConnectionAdded ( Parameter input , Parameter output ) { Object [ ] listeners = listenerList . getListenerList ( ) ; NetworkEvent e = new NetworkEvent ( this , input , output ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NetworkListener.class) { 
protected void fireConnectionRemoved ( Parameter input , Parameter output ) { Object [ ] listeners = listenerList . getListenerList ( ) ; NetworkEvent e = new NetworkEvent ( this , input , output ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NetworkListener.class) { 
protected void fireNodeRenamed ( Node node , String oldName , String newName ) { Object [ ] listeners = listenerList . getListenerList ( ) ; NetworkEvent e = new NetworkEvent ( this , node , oldName , newName ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NetworkListener.class) { 
protected void fireRenderedNodeChanged ( Node oldNode , Node newNode ) { Object [ ] listeners = listenerList . getListenerList ( ) ; NetworkEvent e = new NetworkEvent ( this , oldNode , newNode ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NetworkListener.class) { 
public synchronized void addProcessingListener ( ProcessingListener l ) { listenerList . add ( ProcessingListener . class , l ) ; } 
public synchronized void removeProcessingListener ( ProcessingListener l ) { listenerList . remove ( ProcessingListener . class , l ) ; } 
public synchronized ProcessingListener [ ] geProcessingListeners ( ) { return ( ProcessingListener [ ] ) listenerList . getListeners ( ProcessingListener . class ) ; 
protected void fireStartProcessing ( Network network ) { Object [ ] listeners = listenerList . getListenerList ( ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == ProcessingListener.class) { 
protected void fireEndProcessing ( Network network ) { Object [ ] listeners = listenerList . getListenerList ( ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == ProcessingListener.class) { 
public synchronized void addDirtyListener ( DirtyListener l ) { listenerList . add ( DirtyListener . class , l ) ; } 
public synchronized void removeDirtyListener ( DirtyListener l ) { listenerList . remove ( DirtyListener . class , l ) ; } 
protected void fireNetworkDirty ( Network network ) { Object [ ] listeners = listenerList . getListenerList ( ) ; Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == DirtyListener.class) { 
public void markDirty ( ) { super . markDirty ( ) ; fireNetworkDirty ( this ) ; } 
public boolean isDebug ( ) { return level = = MessageLevel . DEBUG ; } 
public boolean isInfo ( ) { return level = = MessageLevel . INFO ; } 
public boolean isWarning ( ) { return level = = MessageLevel . WARNING ; } 
public boolean isError ( ) { return level = = MessageLevel . ERROR ; } 
public void validateName ( String name ) { Matcher m1 = NODE_NAME_PATTERN . matcher ( name ) ; Matcher m2 = DOUBLE_UNDERSCORE_PATTERN . matcher ( name ) ; if ( ! m1 . matches ( ) ) { throw new InvalidName ( this , name , " Name does contain other characters than a-z0-9 or underscore, or is longer than 29 characters. " ) ; } if ( m2 . matches ( ) ) { throw new InvalidName ( this , name , " Names starting with double underscore are reserved for internal use. " ) ; 
public void setName ( String name ) throws InvalidName { if ( inNetwork ( ) ) { network . rename ( this , name ) ; 
protected void _setName ( String name ) { this . name = name ; setChanged ( ) ; } 
public Parameter addParameter ( String name , Parameter . Type type ) { Parameter p = new Parameter ( this , name , type ) ; parameters . put ( name , p ) ; return p ; } 
public void renameParameter ( Parameter parameter , String name ) { String oldName = parameter . getName ( ) ; if ( oldName . equals ( name ) ) return ; if ( hasParameter ( oldName ) ) { parameters . remove ( oldName ) ; 
protected void _setNetwork ( Network network ) { this . network = network ; } 
public void setNetwork ( Network network ) throws InvalidName { if ( inNetwork ( ) & & this . network ! = network ) { network . remove ( this ) ; } if ( network ! = null ) { Network.add checks if this node was already added in the network, 
public Color asColor ( String name ) { return getParameter ( name ) . asColor ( ) ; } 
public void set ( String name , Color value ) { getParameter ( name ) . set ( value ) ; } 
protected void setOutputValue ( Object value ) throws ValueError { outputParameter . setValue ( value ) ; } 
public boolean connectTo ( Node inputNode , String parameterName ) { Parameter p = inputNode . getParameter ( parameterName ) ; Connection c = new Connection ( this , inputNode , p ) ; downstreams . add ( c ) ; inputNode . upstreams . put ( p , c ) ; return true ; } 
public boolean isInputConnected ( String parameterName ) { Parameter p = getParameter ( parameterName ) ; return isInputConnected ( p ) ; } 
public boolean isInputConnected ( Parameter p ) { if ( upstreams . isEmpty ( ) ) return false ; return getInputConnection ( p ) ! = null ; } 
public boolean disconnectInput ( String parameterName ) { return disconnectInput ( getParameter ( parameterName ) ) ; } 
public boolean disconnectInput ( Parameter parameter ) { Connection c = getInputConnection ( parameter ) ; if ( c = = null ) return false ; upstreams . remove ( parameter ) ; c . getOutputNode ( ) . downstreams . remove ( c ) ; setChanged ( ) ; return true ; } 
public boolean disconnect ( ) { boolean removedSomething = false ; Disconnect all my inputs. for (Connection c : upstreams.values()) { removedSomething = disconnectInput(c.getInputParameter()) | removedSomething; } Disconnect all my outputs. for (Connection c : downstreams) { removedSomething = c.getInputNode().disconnectInput(c.getInputParameter()) | removedSomething; } return removedSomething; } 
public void addDebug ( String msg ) { messages . add ( new Message ( MessageLevel . DEBUG , msg ) ) ; } 
public void addInfo ( String msg ) { messages . add ( new Message ( MessageLevel . DEBUG , msg ) ) ; } 
public void addWarning ( String msg ) { messages . add ( new Message ( MessageLevel . DEBUG , msg ) ) ; } 
public void addError ( String msg ) { messages . add ( new Message ( MessageLevel . DEBUG , msg ) ) ; } 
public boolean hasError ( ) { for ( Message msg : messages ) { if ( msg . isError ( ) ) return true ; } return false ; } 
public boolean hasWarning ( ) { for ( Message msg : messages ) { if ( msg . isWarning ( ) ) return true ; } return false ; } 
public boolean update ( ) { return update ( new ProcessingContext ( ) ) ; } 
public boolean update ( ProcessingContext ctx ) { if ( ! dirty ) return true ; for ( Parameter p : parameters . values ( ) ) { p . update ( ) ; } messages . clear ( ) ; boolean success = process ( ctx ) ; dirty = false ; return success ; } 
public boolean validName ( String name ) { Check if another parameter has the same name. if (node.hasParameter(name) && node.getParameter(name) != this) return false; Pattern nodeNamePattern = Pattern.compile("^[a-z_][a-z0-9_]{0,29}$"); Pattern doubleUnderScorePattern = Pattern.compile("^__.*$"); Pattern reservedPattern = Pattern.compile("^(node|name)$"); Matcher m1 = nodeNamePattern.matcher(name); Matcher m2 = doubleUnderScorePattern.matcher(name); Matcher m3 = reservedPattern.matcher(name); return m1.matches() && !m2.matches() && !m3.matches(); } 
public void _setName ( String name ) { this . name = name ; } 
public boolean valueCorrectForBounds ( double value ) { if ( boundingMethod ! = BoundingMethod . HARD ) { return true ; } if ( value > = minimum & & value < = maximum ) { return true ; } return false ; } 
private void clampToBounds ( ) { if ( coreType = = CoreType . INT ) { int v = ( Integer ) value ; 
public void addMenuItem ( String key , String label ) { menuItems . add ( new MenuEntry ( key , label ) ) ; node . setChanged ( ) ; } 
public int asInt ( ) { if ( coreType = = CoreType . INT ) { return ( Integer ) value ; 
public double asFloat ( ) { if ( coreType = = CoreType . FLOAT ) { return ( Double ) value ; 
public String asString ( ) { if ( coreType = = CoreType . STRING ) { return ( String ) value ; 
public Color asColor ( ) { if ( coreType = = CoreType . COLOR ) { return ( Color ) value ; 
public void set ( int value ) { if ( coreType ! = CoreType . INT ) { throw new ValueError ( " Tried setting integer value on parameter with type " + type ) ; } if ( ! valueCorrectForBounds ( value ) ) { throw new ValueError ( " Value is out of bounds " ) ; } if ( asInt ( ) = = value ) return ; this . value = value ; markDirty ( ) ; } 
public void set ( double value ) { if ( coreType ! = CoreType . FLOAT ) { throw new ValueError ( " Tried setting float value on parameter with type " + type ) ; } if ( ! valueCorrectForBounds ( value ) ) { throw new ValueError ( " Value is out of bounds " ) ; } if ( asFloat ( ) = = value ) return ; this . value = value ; markDirty ( ) ; } 
public void set ( String value ) { if ( value = = null ) return ; if ( coreType ! = CoreType . STRING ) { throw new ValueError ( " Tried setting string value on parameter with type " + type ) ; } if ( asString ( ) . equals ( value ) ) return ; this . value = value ; markDirty ( ) ; } 
public void set ( Color value ) { if ( value = = null ) return ; if ( coreType ! = CoreType . COLOR ) { throw new ValueError ( " Tried setting color value on parameter with type " + type ) ; } if ( asColor ( ) . equals ( value ) ) return ; this . value = value ; markDirty ( ) ; } 
public void setValue ( Object value ) throws ValueError { if ( value = = null ) return ; if ( coreType = = CoreType . INT ) { if ( value instanceof Integer ) { 
public Object parseValue ( String value ) { switch ( coreType ) { case INT : 
private void addExpressionDependency ( Parameter parameter ) { addObserver ( parameter ) ; } 
public boolean hasExpressionDependencies ( ) { return countObservers ( ) > 0 ; } 
public void update ( Observable o , Object arg ) { markDirty ( ) ; } 
public void update ( ) { if ( expressionEnabled ) { setValue ( expression . evaluate ( ) ) ; 
public void revertToDefault ( ) { this . value = this . defaultValue ; markDirty ( ) ; } 
public void markDirty ( ) { node . markDirty ( ) ; setChanged ( ) ; notifyObservers ( ) ; clearChanged ( ) ; } 
protected boolean process ( ProcessingContext ctx ) { Canvas c = new Canvas ( ) ; BezierPath p = new BezierPath ( ) ; p . rect ( pX . asFloat ( ) , pY . asFloat ( ) , pWidth . asFloat ( ) , pHeight . asFloat ( ) ) ; c . append ( p ) ; TODO: Set fill/stroke color outputValue = c; return true; } 
public void testType ( ) { CanvasNode = new CanvasNode ( ) ; assertEquals ( Parameter . Type . CANVAS , . getOutputParameter ( ) . getType ( ) ) ; } 
public void testDirty ( ) { NumberGenerator ng = new NumberGenerator ( ) ; assertTrue ( ng . isDirty ( ) ) ; ng . update ( ) ; assertFalse ( ng . isDirty ( ) ) ; assertEquals ( 0 , ng . getOutputValue ( ) ) ; ng . set ( " number " , 12 ) ; assertTrue ( ng . isDirty ( ) ) ; Asking for the output value doesn't update the node implicitly. assertEquals(0, ng.getOutputValue()); You have to explicitly update the node to get the new output value. ng.update(); assertFalse(ng.isDirty()); assertEquals(12, ng.getOutputValue()); } 
public void testCycles ( ) { NumberGenerator ng = new NumberGenerator ( ) ; assertConnectionError(ng, "number", ng, "Nodes cannot connect to themselves."); 
public void testDirtyPropagation ( ) { NumberGenerator ng = new NumberGenerator ( ) ; Multiplier m = new Multiplier ( ) ; Nodes start out dirty assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating makes them clean ng.update(); m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Connecting the multiplier to another node makes it dirty. The output node doesn't become dirty. ng.connectTo(m, "number"); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(ng.isDirty()); This shouldn't have changed. assertFalse(m.isDirty()); A change to the upstream node should make downstream nodes dirty. ng.set("number", 12); assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating the downstream node should make all upstreams clean, because their output values are needed to calculate the downstream. m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Changes to the downstream node don't affect upstreams. m.set("multiplier", 1); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); Disconnecting makes the downstream dirty. m.disconnectInput("number"); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); Check is disconnected nodes still propagate. ng.update(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); ng.set("number", 12); assertTrue(ng.isDirty()); assertFalse(m.isDirty()); } 
protected boolean process ( ProcessingContext ctx ) { setOutputValue ( asInt ( " number " ) ) ; return true ; } 
protected boolean process ( ProcessingContext ctx ) { setOutputValue ( asInt ( " number " ) * asInt ( " multiplier " ) ) ; return true ; } 
public void testSimple ( ) { Node = new TestNode ( ) ; Parameter p1 = . addParameter ( " p1 " , Parameter . Type . INT ) ; Expression e = new Expression ( p1 , " 1 + 2 " ) ; assertEquals ( 3 , e . asInt ( ) ) ; } 
public void testNaming ( ) { Node = new TestNode ( ) ; assertEquals ( . defaultName ( ) , " testnode " ) ; assertEquals ( . getName ( ) , " testnode " ) ; } 
public void testParameters ( ) { Node = new TestNode ( ) ; try { . getParameter ( " p1 " ) ; fail ( " Should have thrown Parameter.NotFound " ) ; } catch ( Parameter . NotFound e ) { } Parameter p1 = . addParameter ( " p1 " , Parameter . Type . INT ) ; assertTrue ( . hasParameter ( " p1 " ) ) ; try { . getParameter ( " p1 " ) ; } catch ( Parameter . NotFound e ) { fail ( " Should not have thrown Parameter.NotFound " ) ; } assertEquals ( . getParameter ( " p1 " ) , p1 ) ; try { . getParameter ( " x " ) ; 
public void testNodeNaming ( ) { Node = new TestNode ( ) ; checkInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; TODO: are there reserved words in node naming? checkInvalidName(n, "UPPERCASE", "names cannot be in uppercase."); checkInvalidName(n, "uPpercase", "names cannot contain uppercase letters"); checkInvalidName(n, "__reserved", "names cannot start with double underscores"); checkInvalidName(n, "what!", "Only lowercase, numbers and underscore are allowed"); checkInvalidName(n, "$-#34", "Only lowercase, numbers and underscore are allowed"); checkInvalidName(n, "", "names cannot be empty"); checkInvalidName(n, "very_very_very_very_very_very_long_name", "names cannot be longer than 30 characters"); checkValidName(n, "radius"); checkValidName(n, "_test"); checkValidName(n, "_"); checkValidName(n, "_1234"); checkValidName(n, "a1234"); } 
public void testDirty ( ) { Node = new TestNode ( ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . addParameter ( " test " , Parameter . Type . INT ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . set ( " test " , 12 ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . getParameter ( " test " ) . set ( 13 ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; } 
public void testNaming ( ) { Node = new TestNode ( ) ; Parameter p = . addParameter ( " test " , Parameter . Type . INT ) ; checkInvalidName ( p , " 1234 " , " names cannot start with a digit. " ) ; checkInvalidName ( p , " node " , " names can not be one of the reserved words. " ) ; checkInvalidName ( p , " name " , " names can not be one of the reserved words. " ) ; checkInvalidName ( p , " UPPERCASE " , " names cannot be in uppercase. " ) ; checkInvalidName ( p , " uPpercase " , " names cannot contain uppercase letters " ) ; checkInvalidName ( p , " __reserved " , " names cannot start with double underscores " ) ; checkInvalidName ( p , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( p , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( p , " " , " names cannot be empty " ) ; checkInvalidName ( p , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; checkValidName ( p , " radius " ) ; checkValidName ( p , " _test " ) ; checkValidName ( p , " _ " ) ; checkValidName ( p , " _1234 " ) ; checkValidName ( p , " a1234 " ) ; TODO: Right now, these names are accepted, although they will conflict with the internal node attributes. checkValidName(p, "x"); checkValidName(p, "y"); checkValidName(p, "dirty"); checkValidName(p, "process"); } 
public void testInvalidName ( ) { Node = new TestNode ( ) ; Parameter pAlice = . addParameter ( " alice " , Parameter . Type . FLOAT ) ; Parameter pBob = . addParameter ( " bob " , Parameter . Type . FLOAT ) ; assertEquals ( pAlice . getName ( ) , " alice " ) ; assertEquals ( pBob . getName ( ) , " bob " ) ; checkValidName ( pBob , " joe " ) ; assertEquals ( pBob . getName ( ) , " joe " ) ; assertFalse ( . hasParameter ( " bob " ) ) ; assertTrue ( . hasParameter ( " joe " ) ) ; checkParameterNotFound ( , " bob " ) ; assertEquals ( pBob , . getParameter ( " joe " ) ) ; checkInvalidName ( pBob , " alice " , " Can not take the name of an existing parameter. " ) ; assertEquals ( pBob , . getParameter ( " joe " ) ) ; Check the previous setName hasn't affected the current name. } 
public void testLabel ( ) { Node = new TestNode ( ) ; Parameter p1 = . addParameter ( " width " , Parameter . Type . FLOAT ) ; assertEquals ( " Width " , p1 . getLabel ( ) ) ; Parameter p2 = . addParameter ( " a_somewhat_longer_parameter " , Parameter . Type . FLOAT ) ; assertEquals ( " A Somewhat Longer Parameter " , p2 . getLabel ( ) ) ; Parameter p3 = . addParameter ( " double__underscores__everywhere " , Parameter . Type . FLOAT ) ; assertEquals ( " Double Underscores Everywhere " , p3 . getLabel ( ) ) ; } 
public void testValues ( ) { ValueNode = new ValueNode ( ) ; assertEquals ( Parameter . Type . INT , . pInt . getType ( ) ) ; assertEquals ( Parameter . Type . FLOAT , . pFloat . getType ( ) ) ; assertEquals ( Parameter . Type . STRING , . pString . getType ( ) ) ; assertEquals ( 0 , . pInt . asInt ( ) ) ; assertEquals ( 0.0 , . pFloat . asFloat ( ) ) ; assertEquals ( " " , . pString . asString ( ) ) ; . pInt . set ( 12 ) ; . pFloat . set ( 0.5 ) ; . pString . set ( " hello " ) ; assertEquals ( 12 , . pInt . asInt ( ) ) ; assertEquals ( 0.5 , . pFloat . asFloat ( ) ) ; assertEquals ( " hello " , . pString . asString ( ) ) ; } 
public void testBounding ( ) { Node = new TestNode ( ) ; Parameter angle = . addParameter ( " angle " , Parameter . Type . ANGLE ) ; angle . setBoundingMethod ( Parameter . BoundingMethod . SOFT ) ; angle . setMinimum ( - 100.0 ) ; angle . setMaximum ( 100.0 ) ; checkValidSet ( angle , 0.0 ) ; checkValidSet ( angle , 1000.0 ) ; checkValidSet ( angle , - 1000.0 ) ; angle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; assertEquals ( - 100.0 , angle . asFloat ( ) ) ; Setting the bounding type to hard clamped the value checkInvalidSet(angle, 500.0); angle.setBoundingMethod(Parameter.BoundingMethod.NONE); checkValidSet(angle, 300.0); angle.setBoundingMethod(Parameter.BoundingMethod.HARD); assertEquals(100.0, angle.asFloat()); } 
public void testType ( ) { Node = new TestNode ( ) ; Parameter angle = . addParameter ( " angle " , Parameter . Type . ANGLE ) ; assertEquals ( Parameter . CoreType . FLOAT , angle . getCoreType ( ) ) ; } 
private void checkValidSet ( Parameter p , double value ) { try { p . set ( value ) ; 
private void checkInvalidSet ( Parameter p , double value ) { try { p . set ( value ) ; 
protected boolean process ( ProcessingContext ctx ) { setOutputValue ( 42 ) ; return true ; } 
protected boolean process ( ProcessingContext ctx ) { setOutputValue ( 42 ) ; return true ; } 
public boolean hasOutputNode ( ) { return outputParameter ! = null ; } 
public void send ( ) { try { method . invoke ( object ) ; 
public static void removeAllReceivers ( ) { receivers . clear ( ) ; } 
public static boolean connect ( Object object , String methodName , String signal ) { return connect ( object , methodName , signal , null ) ; } 
public static boolean connect ( Object object , String methodName , String signal , Object sender ) { Method m ; try { m = object . getClass ( ) . getMethod ( methodName ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; return false ; } return connect ( object , m , signal , sender ) ; } 
public static boolean connect ( Object object , Method method , String signal ) { return connect ( object , method , signal , null ) ; } 
public static boolean connect ( Object object , Method method , String signal , Object sender ) { Receiver r = new Receiver ( object , method , signal , sender ) ; if ( getReceiver ( object , method , signal , sender ) ! = null ) return false ; return receivers . add ( r ) ; } 
public static boolean disconnect ( Object object , String methodName , String signal ) { return disconnect ( object , methodName , signal , null ) ; } 
public static boolean disconnect ( Object object , String methodName , String signal , Object sender ) { Method m ; try { m = object . getClass ( ) . getMethod ( methodName ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; return false ; } return disconnect ( object , m , signal , sender ) ; } 
public static boolean disconnect ( Object object , Method method , String signal ) { return disconnect ( object , method , signal , null ) ; } 
public static boolean disconnect ( Object object , Method method , String signal , Object sender ) { Receiver r = getReceiver ( object , method , signal , sender ) ; if ( r = = null ) return false ; return receivers . remove ( r ) ; } 
public static void send ( String signal ) { List < Receiver > tmp = getReceivers ( signal ) ; for ( Receiver r : tmp ) { r . send ( ) ; 
public static void send ( String signal , Object sender ) { List < Receiver > tmp = getReceivers ( signal , sender ) ; for ( Receiver r : tmp ) { r . send ( ) ; 
public boolean disconnect ( ) { boolean removedSomething = false ; Disconnect all my inputs. for (Parameter p : parameters.values()) { removedSomething = p.disconnect() | removedSomething; } Disconnect all my outputs. Copy the list of downstreams, since you will be removing elements from it while iterating. List<Connection> downstreamConnections = new ArrayList<Connection>(getOutputParameter().getDownstreamConnections()); for (Connection c : downstreamConnections) { removedSomething = c.getInputParameter().disconnect() | removedSomething; } return removedSomething; } 
public boolean isConnected ( ) { Check parameters for upstream connections. for (Parameter p : parameters.values()) { if (p.isConnected()) return true; } Check output parameter for downstream connections. return getOutputParameter().isConnected(); } 
public boolean isOutputConnected ( ) { return getOutputParameter ( ) . isConnected ( ) ; } 
public boolean update ( ProcessingContext ctx ) { if ( ! dirty ) return true ; for ( Parameter p : parameters . values ( ) ) { p . update ( ctx ) ; } messages . clear ( ) ; boolean success = process ( ctx ) ; dirty = false ; return success ; } 
public boolean addDownstreamConnection ( Connection connection ) { return downstreams . add ( connection ) ; } 
public boolean removeDownstreamConnection ( Connection connection ) { return downstreams . remove ( connection ) ; } 
public void markDirtyDownstream ( ) { for ( Connection c : downstreams ) { c . markDirtyDownstream ( ) ; 
public Connection connect ( Node outputNode ) { throw new ConnectionError ( outputNode , this , " You can only connect from an input parameter. " ) ; } 
public boolean disconnect ( ) { throw new ConnectionError ( getNode ( ) , this , " You can only disconnect from an input parameter. " ) ; } 
public void validate ( Object value ) { throw new AssertionError ( " Code should never validate output parameters. " ) ; } 
public boolean isConnected ( ) { return ! downstreams . isEmpty ( ) ; } 
public boolean isConnectedTo ( Parameter inputParameter ) { Output paramters can only be connected to input parameters. if (inputParameter instanceof OutputParameter) return false; for (Connection c : downstreams) { if (c.getInputParameter() == inputParameter) return true; } return false; } 
public boolean canConnectTo ( Parameter parameter ) { Output paramters can only be connected to input parameters. if (parameter instanceof OutputParameter) return false; return parameter.getCoreType() == getCoreType(); } 
public boolean isConnectedTo ( Node node ) { for ( Connection c : downstreams ) { if ( c . getInputNode ( ) = = node ) return true ; } return false ; } 
public boolean valueCorrectForBounds ( double value ) { if ( boundingMethod ! = BoundingMethod . HARD ) { return true ; } return value > = minimumValue & & value < = maximumValue ; } 
public boolean isCompatible ( Node outputNode ) { return outputNode . getOutputParameter ( ) . getType ( ) . equals ( getType ( ) ) ; } 
public boolean isConnectedTo ( Parameter parameter ) { if ( ! isConnected ( ) ) return false ; Parameters can only be connected to output parameters. if (!(parameter instanceof OutputParameter)) return false; return connection.getOutputParameter() == parameter; } 
public boolean isConnectedTo ( Node node ) { if ( ! isConnected ( ) ) return false ; return connection . getOutputParameter ( ) = = node . getOutputParameter ( ) ; } 
public boolean canConnectTo ( Parameter parameter ) { Parameters can only be connected to output parameters. if (!(parameter instanceof OutputParameter)) return false; return parameter.getCoreType() == getCoreType(); } 
public boolean canConnectTo ( Node node ) { return node . getOutputParameter ( ) . getCoreType ( ) = = getCoreType ( ) ; } 
public boolean disconnect ( ) { if ( ! isConnected ( ) ) return false ; Node outputNode = connection . getOutputNode ( ) ; boolean downstreamRemoved = outputNode . getOutputParameter ( ) . getDownstreamConnections ( ) . remove ( connection ) ; assert ( downstreamRemoved ) ; connection = null ; revertToDefault ( ) ; Dispatcher . send ( Node . SIGNAL_PARAMETER_DISCONNECTED , this ) ; return true ; } 
public void update ( ProcessingContext ctx ) { if ( isConnected ( ) ) { connection . getOutputNode ( ) . update ( ctx ) ; Object outputValue = connection . getOutputNode ( ) . getOutputValue ( ) ; TODO: validate value = outputValue; } if (hasExpression()) { for (Connection c : expressionConnections) { 
public void testDirtyPropagation ( ) { NumberGenerator ng = new NumberGenerator ( ) ; Multiplier m = new Multiplier ( ) ; Nodes start out dirty assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating makes them clean ng.update(); m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Connecting the multiplier to another node makes it dirty. The output node doesn't become dirty. m.getParameter("number").connect(ng); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(ng.isDirty()); This shouldn't have changed. assertFalse(m.isDirty()); A change to the upstream node should make downstream nodes dirty. ng.set("number", 12); assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating the downstream node should make all upstreams clean, because their output values are needed to calculate the downstream. m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Changes to the downstream node don't affect upstreams. m.set("multiplier", 1); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); Disconnecting makes the downstream dirty. m.getParameter("number").disconnect(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); Check is disconnected nodes still propagate. ng.update(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); ng.set("number", 13); assertTrue(ng.isDirty()); assertFalse(m.isDirty()); } 
public void testValuePropagation ( ) { NumberGenerator ng = new NumberGenerator ( ) ; Multiplier m = new Multiplier ( ) ; m . set ( " multiplier " , 2 ) ; m . getParameter ( " number " ) . connect ( ng ) ; assertEquals ( 0 , m . getOutputValue ( ) ) ; ng . set ( " number " , 3 ) ; assertTrue ( m . isDirty ( ) ) ; assertEquals ( 0 , m . getOutputValue ( ) ) ; Updating the NumberGenerator node has no effect on the multiplier node. ng.update(); assertTrue(m.isDirty()); assertEquals(0, m.getOutputValue()); m.update(); assertFalse(m.isDirty()); assertEquals(6, m.getOutputValue()); Test if value stops propagating after disconnection. m.getParameter("number").disconnect(); assertTrue(m.isDirty()); assertFalse(ng.isDirty()); ng.set("number", 3); m.update(); assertEquals(0, m.getOutputValue()); } 
public void testDisconnect ( ) { NumberGenerator ng = new NumberGenerator ( ) ; Multiplier m = new Multiplier ( ) ; m . set ( " multiplier " , 2 ) ; ng . set ( " number " , 5 ) ; m . getParameter ( " number " ) . connect ( ng ) ; assertTrue ( m . getParameter ( " number " ) . isConnected ( ) ) ; assertTrue ( ng . isOutputConnected ( ) ) ; m . update ( ) ; assertEquals ( 5 , m . asInt ( " number " ) ) ; assertEquals ( 10 , m . getOutputValue ( ) ) ; m . getParameter ( " number " ) . disconnect ( ) ; assertTrue ( m . isDirty ( ) ) ; assertFalse ( ng . isDirty ( ) ) ; assertFalse ( m . getParameter ( " number " ) . isConnected ( ) ) ; assertFalse ( ng . isOutputConnected ( ) ) ; Numbers reverts to default after disconnection m.update(); assertEquals(0, m.getOutputValue()); } 
public void testNoObject ( ) { Dispatcher . connect ( this , " countAccess " , " hello " , null ) ; assertEquals ( 0 , accessCounter ) ; Dispatcher . send ( " hello " ) ; assertEquals ( 1 , accessCounter ) ; Send signal from some object, should be received. Dispatcher.send("hello", "someObject"); assertEquals(2, accessCounter); Disconnect the signal and see if this has effect. Dispatcher.disconnect(this, "countAccess", "hello", null); Dispatcher.send("hello"); assertEquals(2, accessCounter); 
public void testObject ( ) { String someObject = " someObject " ; String otherObject = " otherObject " ; Dispatcher . connect ( this , " countAccess " , " hello " , someObject ) ; assertEquals ( 0 , accessCounter ) ; Send from "everybody"; should not dispatch Dispatcher.send("hello", null); assertEquals(0, accessCounter); Try to send from another object; should not dispatch countAccess. Dispatcher.send("hello", otherObject); assertEquals(0, accessCounter); Send from the correct object. Dispatcher.send("hello", someObject); assertEquals(1, accessCounter); } 
public void testDisconnect ( ) { } public void tearDown ( ) { Dispatcher . removeAllReceivers ( ) ; } public void countAccess ( ) { accessCounter + + ; } } 
public void tearDown ( ) { Dispatcher . removeAllReceivers ( ) ; } 
public void testBounding ( ) { Node = new TestNode ( ) ; Parameter angle = . addParameter ( " angle " , Parameter . Type . ANGLE ) ; angle . setBoundingMethod ( Parameter . BoundingMethod . SOFT ) ; angle . setMinimumValue ( - 100.0 ) ; angle . setMaximumValue ( 100.0 ) ; checkValidSet ( angle , 0.0 ) ; checkValidSet ( angle , 1000.0 ) ; checkValidSet ( angle , - 1000.0 ) ; angle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; assertEquals ( - 100.0 , angle . asFloat ( ) ) ; Setting the bounding type to hard clamped the value checkInvalidSet(angle, 500.0); angle.setBoundingMethod(Parameter.BoundingMethod.NONE); checkValidSet(angle, 300.0); angle.setBoundingMethod(Parameter.BoundingMethod.HARD); assertEquals(100.0, angle.asFloat()); } 
public void removeDocument ( Document document ) { documents . remove ( document ) ; } 
public Document createNewDocument ( ) { Document doc = new Document ( ) ; doc . setVisible ( true ) ; documents . add ( doc ) ; currentDocument = doc ; return doc ; } 
public static void main ( String [ ] args ) { new Application(); }} 
public void updateBounds ( ) { double x0 = connection . getOutputNode ( ) . getX ( ) ; double y0 = connection . getOutputNode ( ) . getY ( ) ; double x1 = connection . getInputNode ( ) . getX ( ) ; double y1 = connection . getInputNode ( ) . getY ( ) ; Rect bounds = new Rect ( x0 , y0 , x1 - x0 , y1 - y0 ) ; bounds = bounds . normalized ( ) ; setBounds ( bounds . getRectangle2D ( ) ) ; } 
public void invalidateLayout ( ) { super . invalidateLayout ( ) ; updatePath ( ) ; } 
public void updatePath ( ) { reset ( ) ; float x0 = NodeView . NODE_WIDTH / 2 ; float y0 = NodeView . NODE_HEIGHT ; float x1 = ( float ) getWidth ( ) ; float y1 = ( float ) getHeight ( ) ; float dx = Math . abs ( x1 - x0 ) / 2 ; moveTo ( x0 , y0 ) ; curveTo ( x0 , y0 + dx , x1 , y1 - dx , x1 , y1 ) ; } 
public void propertyChange ( PropertyChangeEvent evt ) { invalidateLayout ( ) ; repaint ( ) ; } 
public void nodeMovedEvent ( ) { updateBounds ( ) ; updatePath ( ) ; } 
public void addObserver ( Observer o ) { documentObservable . addObserver ( o ) ; } 
public void removeObserver ( Observer o ) { documentObservable . deleteObserver ( o ) ; } 
public boolean readFromFile ( File file ) { FileInputStream fis = null ; try { Load the document fis = new FileInputStream(file); InputSource source = new InputSource(fis); Setup the parser SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); TODO: Parsing return true; } catch (ParserConfigurationException e) { logger.log(Level.SEVERE, "Error during configuration", e); } catch (IOException e) { logger.log(Level.SEVERE, "Error while reading " + file, e); } catch (SAXException e) { logger.log(Level.SEVERE, "Error while parsing" + file, e); } return false; } 
public boolean shouldClose ( ) { if ( isChanged ( ) ) { SaveDialog sd = new SaveDialog ( ) ; int retVal = sd . show ( this ) ; if ( retVal = = JOptionPane . YES_OPTION ) { return save ( ) ; } else if ( retVal = = JOptionPane . NO_OPTION ) { return true ; } else if ( retVal = = JOptionPane . CANCEL_OPTION ) { return false ; } } return true ; } 
public boolean save ( ) { if ( documentFile = = null ) { return saveAs ( ) ; 
public boolean saveAs ( ) { File chosenFile = FileUtils . showSaveDialog ( this , lastFilePath , " pna " , " PNA File " ) ; if ( chosenFile ! = null ) { lastFilePath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; setDocumentFile ( chosenFile ) ; return saveToFile ( documentFile ) ; } return false ; } 
public boolean saveToFile ( File file ) { try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( rootNetwork . toXml ( ) . getBytes ( ) ) ; fos . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , " An error occurred while saving the file. " , " MainController " , JOptionPane . ERROR_MESSAGE ) ; logger . log ( Level . SEVERE , " An error occurred while saving the file. " , e ) ; return false ; } documentChanged = false ; updateTitle ( ) ; return true ; 
public boolean exportToFile ( File file ) { todo: file export only works on grobs. try { return PdfWriter.writeGrob(file, (Grob) network.getOutput()); 
public void markChanged ( ) { if ( ! documentChanged ) { documentChanged = true ; 
public void updateTitle ( ) { String postfix = " " ; if ( true | | ! PlatformUtils . onMac ( ) ) { todo: mac only code postfix = (documentChanged ? " *" : "") + " - PNA"; } if (documentFile == null) { setTitle("Untitled" + postfix); 
public boolean export ( ) { File chosenFile = FileUtils . showSaveDialog ( this , lastExportPath , " pdf " , " PDF file " ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; return exportToFile ( chosenFile ) ; } return false ; } 
public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . createNewDocument ( ) ; } 
public void actionPerformed ( ActionEvent e ) { PnaDocumentFrame requester = getCurrentDocument(); File chosenFile = FileUtils.showOpenDialog(Document.this, lastFilePath, "pna", "PNA File"); if (chosenFile != null) { lastFilePath = chosenFile.getParentFile().getAbsolutePath(); 
public void actionPerformed ( ActionEvent e ) { save ( ) ; } 
public void actionPerformed ( ActionEvent e ) { saveAs ( ) ; } 
public void actionPerformed ( ActionEvent e ) { } } public class ExportAction extends AbstractAction { public ExportAction ( ) { putValue ( NAME , " Export " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_E ) ) ; } public void actionPerformed ( ActionEvent e ) { export ( ) ; } } public class QuitAction extends AbstractAction { public QuitAction ( ) { putValue ( NAME , " Quit " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Q ) ) ; } public void actionPerformed ( ActionEvent e ) { boolean allClosed = true ; Because documents will disappear from the list once they are closed, make a copy of the list. java.util.List<Document> documents = new ArrayList<Document>(Application.getInstance().getDocuments()); for (Document d : documents) { allClosed = allClosed && d.shouldClose(); } if (allClosed) { System.exit(0); } } }} 
public void actionPerformed ( ActionEvent e ) { export ( ) ; } 
public void actionPerformed ( ActionEvent e ) { boolean allClosed = true ; Because documents will disappear from the list once they are closed, make a copy of the list. java.util.List<Document> documents = new ArrayList<Document>(Application.getInstance().getDocuments()); for (Document d : documents) { allClosed = allClosed && d.shouldClose(); } if (allClosed) { System.exit(0); 
public static File showOpenDialog ( Frame owner , String pathName , String extensions , String description ) { return showFileDialog ( owner , pathName , extensions , description , FileDialog . LOAD ) ; } 
public static File showSaveDialog ( Frame owner , String pathName , String extensions , String description ) { return showFileDialog ( owner , pathName , extensions , description , FileDialog . SAVE ) ; } 
private static File showFileDialog ( Frame owner , String pathName , String extensions , String description , int fileDialogType ) { FileDialog fileDialog = new FileDialog ( owner , pathName , fileDialogType ) ; fileDialog . setFilenameFilter ( new FileExtensionFilter ( extensions , description ) ) ; fileDialog . setVisible ( true ) ; String chosenFile = fileDialog . getFile ( ) ; String dir = fileDialog . getDirectory ( ) ; if ( chosenFile ! = null ) { return new File ( dir + chosenFile ) ; 
public static String [ ] parseExtensions ( String extensions ) { StringTokenizer st = new StringTokenizer ( extensions , " , " ) ; String [ ] ext = new String [ st . countTokens ( ) ] ; int i = 0 ; while ( st . hasMoreTokens ( ) ) { ext [ i + + ] = st . nextToken ( ) ; } return ext ; } 
public boolean accept ( File f ) { if ( f . isDirectory ( ) ) return true ; return accept ( null , f . getName ( ) ) ; } 
public boolean accept ( File f , String s ) { String extension = FileUtils . getExtension ( s ) ; if ( extension ! = null ) { for ( int i = 0 ; i < extensions . length ; i + + ) { if ( extensions [ i ] . equalsIgnoreCase ( extension ) ) { return true ; } } } return false ; } 
public void actionPerformed ( ActionEvent e ) { if ( node instanceof Network ) { pane . getDocument ( ) . setActiveNetwork ( ( Network ) node ) ; 
public Pane clone ( ) { return new NetworkPane ( getDocument ( ) ) ; } 
public void activeNetworkChangedEvent ( Network activeNetwork ) { setNetwork ( activeNetwork ) ; } 
public void deselectAll ( ) { for ( Iterator < Selectable > selectionIter = selection . iterator ( ) ; selectionIter . hasNext ( ) ; ) { Selectable s = selectionIter . next ( ) ; assert s . isSelected ( ) ; s . setSelected ( false ) ; } selection . clear ( ) ; firePropertyChange ( SELECT_PROPERTY , selection , null ) ; } 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; Node = new RectNode ( ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } 
public void processEvent ( final PInputEvent evt , final int i ) { if ( evt . isMouseWheelEvent ( ) ) { double currentScale = evt . getCamera ( ) . getViewScale ( ) ; 
private void initPopupMenu ( ) { popup = new JPopupMenu ( ) ; popup . add ( new RemoveNodeAction ( ) ) ; 
public void nodeMovedEvent ( ) { System . out . println ( " something moved " ) ; } 
public void select ( Selectable v ) { if ( v = = null ) return ; selection . add ( v ) ; v . setSelected ( true ) ; firePropertyChange ( SELECT_PROPERTY , null , v ) ; } 
public void deselect ( Selectable v ) { if ( v = = null ) return ; selection . remove ( v ) ; v . setSelected ( false ) ; firePropertyChange ( SELECT_PROPERTY , v , null ) ; } 
protected void paint ( PPaintContext c ) { Graphics2D g = c . getGraphics ( ) ; g . setColor ( new Color ( 200 , 200 , 200 , 100 ) ) ; PBounds b = getBounds ( ) ; g . fill ( b ) ; g . setColor ( new Color ( 100 , 100 , 100 , 100 ) ) ; g . draw ( b ) ; } 
public void mouseClicked ( PInputEvent e ) { if ( e . getButton ( ) ! = MouseEvent . BUTTON1 ) return ; deselectAll ( ) ; } 
public void mousePressed ( PInputEvent e ) { if ( e . getButton ( ) ! = MouseEvent . BUTTON1 ) return ; Point2D p = e . getPosition ( ) ; selectionMarker = new SelectionMarker ( p ) ; getLayer ( ) . addChild ( selectionMarker ) ; } 
public void mouseDragged ( PInputEvent e ) { if ( selectionMarker = = null ) return ; deselectAll ( ) ; Point2D prev = selectionMarker . getOffset ( ) ; Point2D p = e . getPosition ( ) ; selectionMarker . setWidth ( p . getX ( ) - prev . getX ( ) ) ; selectionMarker . setHeight ( p . getY ( ) - prev . getY ( ) ) ; ListIterator childIter = getLayer ( ) . getChildrenIterator ( ) ; while ( childIter . hasNext ( ) ) { Object o = childIter . next ( ) ; 
public void mouseReleased ( PInputEvent pInputEvent ) { if ( selectionMarker = = null ) return ; getLayer ( ) . removeChild ( selectionMarker ) ; selectionMarker = null ; } 
public void mousePressed ( MouseEvent e ) { evaluatePopup ( e ) ; } 
public void mouseReleased ( MouseEvent e ) { evaluatePopup ( e ) ; } 
private void evaluatePopup ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { Point p = e . getPoint ( ) ; 
public void actionPerformed ( ActionEvent e ) { } } } 
protected void paintBorder ( Graphics2D g2 ) { Color borderColor ; if ( selected ) { borderColor = Theme . getInstance ( ) . getActionColor ( ) ; } else { borderColor = Color . BLACK ; } g2 . setColor ( borderColor ) ; int x = ( int ) getX ( ) ; int y = ( int ) getY ( ) ; int width = ( int ) getWidth ( ) ; int height = ( int ) getHeight ( ) ; g2 . drawRect ( x , y , width - 1 , height - 1 ) ; g2.setColor(new Color(88, 87, 96)); 
public void mouseDragged ( PInputEvent e ) { if ( isDraggingNode ) { Point2D pt = e . getPosition ( ) ; double x = pt . getX ( ) - dragPoint . getX ( ) ; double y = pt . getY ( ) - dragPoint . getY ( ) ; setOffset ( x , y ) ; } e . setHandled ( true ) ; } 
public void mouseReleased ( PInputEvent event ) { isDraggingNode = false ; } 
public void activeNetworkChangedEvent ( Network activeNetwork ) { } public void activeNodeChangedEvent ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; int sz = ( orientation = = JSplitPane . VERTICAL_SPLIT ? getWidth ( ) : getHeight ( ) ) / 2 ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setDividerLocation ( sz ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } } 
public void activeNodeChangedEvent ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; int sz = ( orientation = = JSplitPane . VERTICAL_SPLIT ? getWidth ( ) : getHeight ( ) ) / 2 ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setDividerLocation ( sz ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } } 
public void splitTopBottom ( ) { split ( JSplitPane . VERTICAL_SPLIT ) ; } 
public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } 
private void split ( int orientation ) { Dimension d = getSize ( ) ; int sz = ( orientation = = JSplitPane . VERTICAL_SPLIT ? getWidth ( ) : getHeight ( ) ) / 2 ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setDividerLocation ( sz ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } 
public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . setColor ( Theme . getInstance ( ) . getBorderColor ( ) ) ; g . drawLine ( x , y + height - 1 , x + width , y + height - 1 ) ; } 
public boolean isBorderOpaque ( ) { return true ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { if ( e . getX ( ) < this . getWidth ( ) - 20 ) return ; paneMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override public void paint ( Graphics g ) { super . paint ( g ) ; Theme . getInstance ( ) . getArrowIcon ( ) . paintIcon ( this , g , getWidth ( ) - 15 , 8 ) ; } } 
public void mousePressed ( MouseEvent e ) { if ( e . getX ( ) < this . getWidth ( ) - 20 ) return ; paneMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override public void paint ( Graphics g ) { super . paint ( g ) ; Theme . getInstance ( ) . getArrowIcon ( ) . paintIcon ( this , g , getWidth ( ) - 15 , 8 ) ; } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override public void paint ( Graphics g ) { super . paint ( g ) ; Theme . getInstance ( ) . getArrowIcon ( ) . paintIcon ( this , g , getWidth ( ) - 15 , 8 ) ; } } 
public void mouseExited ( MouseEvent e ) { } @Override public void paint ( Graphics g ) { super . paint ( g ) ; Theme . getInstance ( ) . getArrowIcon ( ) . paintIcon ( this , g , getWidth ( ) - 15 , 8 ) ; } } 
public void paint ( Graphics g ) { super . paint ( g ) ; Theme . getInstance ( ) . getArrowIcon ( ) . paintIcon ( this , g , getWidth ( ) - 15 , 8 ) ; } 
public void actionPerformed ( ActionEvent e ) { getPane ( ) . changePaneType ( paneType ) ; 
public void actionPerformed ( ActionEvent e ) { getPane ( ) . splitTopBottom ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getPane ( ) . splitLeftRight ( ) ; } 
public Pane clone ( ) { return new ParameterPane ( getDocument ( ) ) ; } 
public void activeNodeChangedEvent ( Node activeNode ) { setNode ( activeNode ) ; } 
public static boolean onMac ( ) { return current_platform = = MAC ; } 
public static boolean onWindows ( ) { return current_platform = = WIN ; } 
public static boolean onOther ( ) { return current_platform = = OTHER ; } 
public static Border createLineBorder ( ) { if ( platformLineBorder = = null ) { Color borderColor ; if ( onWindows ( ) ) { borderColor = new Color ( 100 , 100 , 100 ) ; } else if ( onMac ( ) ) { borderColor = new Color ( 200 , 200 , 200 ) ; } else { borderColor = new Color ( 200 , 200 , 200 ) ; } platformLineBorder = BorderFactory . createLineBorder ( borderColor ) ; } return platformLineBorder ; } 
private void initInterface ( ) { setLayout ( new BorderLayout ( ) ) ; Icon dialogIcon = PnaClient . getImageIcon ( ) ; JLabel iconLabel = new JLabel ( dialogIcon ) ; iconLabel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 ) ) ; JPanel contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new GridLayout ( 3 , 1 , 10 , 0 ) ) ; contentPanel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 ) ) ; JLabel messageLabel = new JLabel ( " Do you want to save changes to this document before closing? " ) ; messageLabel . setFont ( messageFont ) ; contentPanel . add ( messageLabel ) ; JLabel infoLabel = new JLabel ( " If you don't save, your changes will be lost. " ) ; infoLabel . setFont ( infoFont ) ; contentPanel . add ( infoLabel ) ; JPanel buttonPanel = new JPanel ( ) ; buttonPanel . setLayout ( new FlowLayout ( FlowLayout . RIGHT ) ) ; dontSaveButton = new JButton ( dontSaveAction ) ; cancelButton = new JButton ( cancelAction ) ; saveButton = new JButton ( saveAction ) ; buttonPanel . add ( dontSaveButton ) ; buttonPanel . add ( cancelButton ) ; buttonPanel . add ( saveButton ) ; contentPanel . add ( buttonPanel ) ; add ( iconLabel , BorderLayout . WEST ) ; add ( contentPanel , BorderLayout . CENTER ) ; setSize ( 400 , 250 ) ; } 
public int show ( JFrame frame ) { dialog = new JDialog ( frame , " Save Changes " , true ) ; Container contentPane = dialog . getContentPane ( ) ; contentPane . setLayout ( new BorderLayout ( ) ) ; contentPane . add ( this , BorderLayout . CENTER ) ; dialog . setResizable ( false ) ; dialog . pack ( ) ; dialog . setLocationRelativeTo ( frame ) ; dialog . getRootPane ( ) . setDefaultButton ( saveButton ) ; dialog . setVisible ( true ) ; dialog . dispose ( ) ; return selectedValue ; } 
public void actionPerformed ( ActionEvent e ) { selectedValue = JOptionPane . NO_OPTION ; dialog . setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { selectedValue = JOptionPane . YES_OPTION ; dialog . setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { selectedValue = JOptionPane . CANCEL_OPTION ; dialog . setVisible ( false ) ; } 
public void paintIcon ( Component c , Graphics g , int x , int y ) { g . setColor ( Theme . getInstance ( ) . getForegroundColor ( ) ) ; g . drawLine ( x + 1 , y , x + 1 , y ) ; g . drawLine ( x + 1 , y + 1 , x + 2 , y + 1 ) ; g . drawLine ( x + 1 , y + 2 , x + 3 , y + 2 ) ; g . drawLine ( x + 1 , y + 3 , x + 4 , y + 3 ) ; g . drawLine ( x + 1 , y + 4 , x + 3 , y + 4 ) ; g . drawLine ( x + 1 , y + 5 , x + 2 , y + 5 ) ; g . drawLine ( x + 1 , y + 6 , x + 1 , y + 6 ) ; } 
public void moveto ( double x , double y ) { elements . add ( new PathElement ( PathElement . MOVETO , x , y ) ) ; dirty = true ; } 
public void lineto ( double x , double y ) { elements . add ( new PathElement ( PathElement . LINETO , x , y ) ) ; dirty = true ; } 
public void curveto ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { elements . add ( new PathElement ( PathElement . CURVETO , x1 , y1 , x2 , y2 , x3 , y3 ) ) ; dirty = true ; } 
public void close ( ) { elements . add ( new PathElement ( PathElement . CLOSE ) ) ; dirty = true ; } 
public void addElement ( PathElement el ) { elements . add ( el . clone ( ) ) ; } 
public void addRect ( Rect r ) { addRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) ) ; } 
public void addRect ( double x , double y , double width , double height ) { moveto ( x , y ) ; lineto ( x + width , y ) ; lineto ( x + width , y + height ) ; lineto ( x , y + height ) ; close ( ) ; } 
public void addRoundedRect ( Rect r , double rx , double ry ) { addRoundedRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , rx , ry ) ; } 
public void addRoundedRect ( double x , double y , double width , double height , double rx , double ry ) { double dx = rx ; double dy = ry ; rx/ry cannot be greater than half of the width of the rectangle (required by SVG spec) dx = Math.min(dx, width * 0.5); dy = Math.min(dy, height * 0.5); moveto(x + dx, y); if (dx < width * 0.5) lineto(x + width - rx, y); curveto(x + width - dx * ONE_MINUS_QUARTER, y, x + width, y + dy * ONE_MINUS_QUARTER, x + width, y + dy); if (dy < height * 0.5) lineto(x + width, y + height - dy); curveto(x + width, y + height - dy * ONE_MINUS_QUARTER, x + width - dx * ONE_MINUS_QUARTER, y + height, x + width - dx, y + height); if (dx < width * 0.5) lineto(x + dx, y + height); curveto(x + dx * ONE_MINUS_QUARTER, y + height, x, y + height - dy * ONE_MINUS_QUARTER, x, y + height - dy); if (dy < height * 0.5) lineto(x, y + dy); curveto(x, y + dy * ONE_MINUS_QUARTER, x + dx * ONE_MINUS_QUARTER, y, x + dx, y); close(); } 
public void addEllipse ( double x , double y , double width , double height ) { double hdiff = width / 2 * KAPPA ; double vdiff = height / 2 * KAPPA ; moveto ( x + width / 2 , y + height ) ; curveto ( x + width / 2 - hdiff , y + height , x , y + height / 2 + vdiff , x , y + height / 2 ) ; curveto ( x , y + height / 2 - vdiff , x + width / 2 - hdiff , y , x + width / 2 , y ) ; curveto ( x + width / 2 + hdiff , y , x + width , y + height / 2 - vdiff , x + width , y + height / 2 ) ; curveto ( x + width , y + height / 2 + vdiff , x + width / 2 + hdiff , y + height , 
public void addLine ( double x1 , double y1 , double x2 , double y2 ) { moveto ( x1 , y1 ) ; lineto ( x2 , y2 ) ; } 
public boolean contains ( Point p ) { return getGeneralPath ( ) . contains ( p . getPoint2D ( ) ) ; } 
public boolean contains ( double x , double y ) { return getGeneralPath ( ) . contains ( x , y ) ; } 
public boolean contains ( Rect r ) { return getGeneralPath ( ) . contains ( r . getRectangle2D ( ) ) ; } 
public boolean intersects ( Rect r ) { return getGeneralPath ( ) . intersects ( r . getRectangle2D ( ) ) ; } 
public boolean intersects ( BezierPath p ) { Area a1 = new Area ( getGeneralPath ( ) ) ; Area a2 = new Area ( p . getGeneralPath ( ) ) ; a1 . intersect ( a2 ) ; return ! a1 . isEmpty ( ) ; } 
public BezierPath intersected ( BezierPath p ) { Area a1 = new Area ( getGeneralPath ( ) ) ; Area a2 = new Area ( p . getGeneralPath ( ) ) ; a1 . intersect ( a2 ) ; return new BezierPath ( a1 ) ; } 
public BezierPath subtracted ( BezierPath p ) { Area a1 = new Area ( getGeneralPath ( ) ) ; Area a2 = new Area ( p . getGeneralPath ( ) ) ; a1 . subtract ( a2 ) ; return new BezierPath ( a1 ) ; } 
public BezierPath united ( BezierPath p ) { Area a1 = new Area ( getGeneralPath ( ) ) ; Area a2 = new Area ( p . getGeneralPath ( ) ) ; a1 . add ( a2 ) ; return new BezierPath ( a1 ) ; } 
public void draw ( Graphics2D g ) { if ( fillColor ! = null & & fillColor . isVisible ( ) ) { g . setColor ( fillColor . getAwtColor ( ) ) ; g . fill ( getGeneralPath ( ) ) ; } if ( strokeColor ! = null & & strokeColor . isVisible ( ) ) { g . setColor ( strokeColor . getAwtColor ( ) ) ; 
public Grob clone ( ) { BezierPath p = new BezierPath ( ) ; p . elements = ( ArrayList < PathElement > ) elements . clone ( ) ; p . fillColor = fillColor = = null ? null : fillColor . clone ( ) ; p . strokeColor = strokeColor = = null ? null : strokeColor . clone ( ) ; p . strokeWidth = strokeWidth ; return p ; } 
public void save ( File file ) { throw new UnsupportedOperationException ( " Not supported yet. " ) ; } 
public String toString ( ) { return " < " + getClass ( ) . getSimpleName ( ) + " : " + width + " , " + height + " > " ; } 
public static double clamp ( double v ) { return Math . max ( 0.0 , Math . min ( 1.0 , v ) ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { this . transform = ctx . getTransform ( ) . clone ( ) ; } 
public void translate ( double tx , double ty ) { transform . translate ( tx , ty ) ; } 
public void rotate ( double degrees ) { transform . rotate ( degrees ) ; } 
public void scale ( double scale ) { transform . scale ( scale ) ; } 
public void scale ( double sx , double sy ) { transform . scale ( sx , sy ) ; } 
public void skew ( double skew ) { transform . skew ( skew ) ; } 
public void skew ( double kx , double ky ) { transform . skew ( kx , ky ) ; } 
public void draw ( Graphics2D g ) { AffineTransform = g . getTransform ( ) ; getTransform ( ) . apply ( g , getBounds ( ) ) ; for ( Grob grob : grobs ) { grob . draw ( g ) ; } g . setTransform ( ) ; } 
public Grob clone ( ) { Group newGroup = new Group ( ) ; newGroup . setTransform ( getTransform ( ) . clone ( ) ) ; for ( Grob g : grobs ) { newGroup . add ( g . clone ( ) ) ; } return newGroup ; } 
public String toString ( ) { return " < " + getClass ( ) . getSimpleName ( ) + " > " ; } 
public void draw ( Graphics2D g ) { float srcW = image . getWidth ( ) ; float srcH = image . getHeight ( ) ; Width or height given if (desiredWidth != 0 || desiredHeight != 0) { double factor; 
public String toString ( ) { switch ( command ) { case MOVETO : return " PathElement(Command.MOVETO, " + getX ( ) + " , " + getY ( ) + " ) " ; case LINETO : return " PathElement(Command.LINETO, " + getX ( ) + " , " + getY ( ) + " ) " ; case CURVETO : return " PathElement(Command.CURVETO, " + getControl1 ( ) . getX ( ) + " , " + getControl1 ( ) . getY ( ) + " , " + getControl2 ( ) . getX ( ) + " , " + getControl2 ( ) . getY ( ) + " , " + getX ( ) + " , " + getY ( ) + " ) " ; case CLOSE : return " PathElement(Command.CLOSE) " ; } throw new AssertionError ( " Invalid PathElement command " + command ) ; } 
public PathElement clone ( ) { PathElement pe = new PathElement ( ) ; pe . command = command ; pe . point = point . clone ( ) ; pe . control1 = control1 . clone ( ) ; pe . control2 = control2 . clone ( ) ; return pe ; } 
public void translate ( double tx , double ty ) { affineTransform . translate ( tx , ty ) ; } 
public void rotate ( double degrees ) { affineTransform . rotate ( degrees ) ; } 
public void scale ( double scale ) { affineTransform . scale ( scale , scale ) ; } 
public void scale ( double sx , double sy ) { affineTransform . scale ( sx , sy ) ; } 
public void skew ( double kx , double ky ) { kx = Math . PI * kx / 180.0 ; ky = Math . PI * ky / 180.0 ; affineTransform . preConcatenate ( new AffineTransform ( 1 , Math . tan ( ky ) , - Math . tan ( kx ) , 1 , 0 , 0 ) ) ; } 
public boolean invert ( ) { try { affineTransform = affineTransform . createInverse ( ) ; 
public void append ( Transform ) { affineTransform . concatenate ( . affineTransform ) ; } 
public void prepend ( Transform ) { affineTransform . preConcatenate ( . affineTransform ) ; } 
public Point map ( Point p ) { Point2D . Double p2 = new Point2D . Double ( ) ; affineTransform . transform ( p . getPoint2D ( ) , p2 ) ; return new Point ( p2 ) ; } 
public Rect map ( Rect r ) { TODO: The size conversion might be incorrect. (using deltaTransform) In that case, make topLeft and bottomRight points. Point2D origin = new Point2D.Double(r.getX(), r.getY()); Point2D size = new Point2D.Double(r.getWidth(), r.getHeight()); Point2D transformedOrigin = new Point2D.Double(); Point2D transformedSize = new Point2D.Double(); affineTransform.transform(origin, transformedOrigin); affineTransform.deltaTransform(size, transformedSize); return new Rect(transformedOrigin.getX(), transformedOrigin.getY(), transformedSize.getX(), transformedSize.getY()); } 
public BezierPath map ( BezierPath p ) { TODO: Implement return p; } 
public Rect convertBoundsToFrame ( Rect bounds ) { AffineTransform = fullTransform ( bounds ) ; Point2D transformedOrigin = new Point2D . Double ( ) ; Point2D transformedSize = new Point2D . Double ( ) ; . transform ( new Point2D . Double ( bounds . getX ( ) , bounds . getY ( ) ) , transformedOrigin ) ; . deltaTransform ( new Point2D . Double ( bounds . getWidth ( ) , bounds . getHeight ( ) ) , transformedOrigin ) ; return new Rect ( transformedOrigin . getX ( ) , transformedOrigin . getY ( ) , transformedSize . getX ( ) , transformedSize . getY ( ) ) ; } 
private AffineTransform fullTransform ( Rect bounds ) { double cx = bounds . getX ( ) + bounds . getWidth ( ) / 2 ; double cy = bounds . getY ( ) + bounds . getHeight ( ) / 2 ; AffineTransform = new AffineTransform ( ) ; . translate ( cx , cy ) ; . preConcatenate ( affineTransform ) ; . translate ( - cx , - cy ) ; return ; } 
protected Transform clone ( ) { return new Transform ( affineTransform ) ; } 
public void apply ( Graphics2D g , Rect bounds ) { AffineTransform = fullTransform ( bounds ) ; g . transform ( ) ; } 
public Node create ( Class nodeClass ) { assert ( nodeClass . isAssignableFrom ( Node . class ) ) ; try { Node newNode = ( Node ) nodeClass . newInstance ( ) ; 
protected boolean process ( ProcessingContext ctx ) { Canvas c = new Canvas ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( pFillColor . asColor ( ) ) ; p . setStrokeColor ( pStrokeColor . asColor ( ) ) ; p . setStrokeWidth ( pStrokeWidth . asFloat ( ) ) ; p . addEllipse ( pX . asFloat ( ) , pY . asFloat ( ) , pWidth . asFloat ( ) , pHeight . asFloat ( ) ) ; c . add ( p ) ; outputValue = c ; return true ; } 
protected boolean process ( ProcessingContext ctx ) { Canvas c = new Canvas ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( pFillColor . asColor ( ) ) ; p . setStrokeColor ( pStrokeColor . asColor ( ) ) ; p . setStrokeWidth ( pStrokeWidth . asFloat ( ) ) ; p . addRect ( pX . asFloat ( ) , pY . asFloat ( ) , pWidth . asFloat ( ) , pHeight . asFloat ( ) ) ; c . add ( p ) ; outputValue = c ; return true ; } 
public void testElements ( ) { BezierPath p = new BezierPath ( ) ; p . moveto ( 1 , 2 ) ; p . lineto ( 3 , 4 ) ; p . close ( ) ; assertEquals ( 3 , p . size ( ) ) ; assertEquals ( new PathElement ( PathElement . MOVETO , 1 , 2 ) , p . getElementAt ( 0 ) ) ; assertEquals ( new PathElement ( PathElement . LINETO , 3 , 4 ) , p . getElementAt ( 1 ) ) ; assertEquals ( new PathElement ( PathElement . CLOSE ) , p . getElementAt ( 2 ) ) ; } 
public void testBounds ( ) { BezierPath p1 = new BezierPath ( ) ; p1 . addRect ( 20 , 30 , 40 , 50 ) ; assertEquals ( new Rect ( 20 , 30 , 40 , 50 ) , p1 . getBounds ( ) ) ; BezierPath p2 = new BezierPath ( ) ; p2 . addRect ( 60 , 70 , 80 , 90 ) ; assertEquals ( new Rect ( 60 , 70 , 80 , 90 ) , p2 . getBounds ( ) ) ; } 
public void testType ( ) { CanvasNetwork = new CanvasNetwork ( ) ; assertEquals ( Parameter . Type . GROB_CANVAS , . getOutputParameter ( ) . getType ( ) ) ; } 
public void testCreate ( ) { TestNetwork net = new TestNetwork ( ) ; Node testNode = net . create ( TestNode . class ) ; assertTrue ( net . contains ( testNode ) ) ; assertTrue ( testNode . inNetwork ( ) ) ; assertEquals ( net , testNode . getNetwork ( ) ) ; } 
public boolean saveToFile ( File file ) { try { FileOutputStream fos = new FileOutputStream ( file ) ; TODO: Implement the toXml() fos.write(rootNetwork.toXml().getBytes()); fos.close(); } catch (IOException e) { JOptionPane.showMessageDialog(this, "An error occurred while saving the file.", "MainController", JOptionPane.ERROR_MESSAGE); logger.log(Level.SEVERE, "An error occurred while saving the file.", e); return false; } documentChanged = false; updateTitle(); return true; 
public BasicSplitPaneDivider createDefaultDivider ( ) { return new PaneSpliterDivider ( this ) ; } 
private void initInterface ( ) { setLayout ( new BorderLayout ( ) ) ; Icon dialogIcon = Application.getInstance().getImageIcon(); JLabel iconLabel = new JLabel(dialogIcon); iconLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); JPanel contentPanel = new JPanel(); contentPanel.setLayout(new GridLayout(3, 1, 10, 0)); contentPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); JLabel messageLabel = new JLabel("Do you want to save changes to this document before closing?"); messageLabel.setFont(messageFont); contentPanel.add(messageLabel); JLabel infoLabel = new JLabel("If you don't save, your changes will be lost."); infoLabel.setFont(infoFont); contentPanel.add(infoLabel); JPanel buttonPanel = new JPanel(); buttonPanel.setLayout(new FlowLayout(FlowLayout.RIGHT)); dontSaveButton = new JButton(dontSaveAction); cancelButton = new JButton(cancelAction); saveButton = new JButton(saveAction); buttonPanel.add(dontSaveButton); buttonPanel.add(cancelButton); buttonPanel.add(saveButton); contentPanel.add(buttonPanel); add(iconLabel, BorderLayout.WEST); add(contentPanel, BorderLayout.CENTER); setSize(400, 250); } 
public void addDocumentFocusListener ( DocumentFocusListener l ) { documentFocusListeners . add ( DocumentFocusListener . class , l ) ; } 
public void removeDocumentFocusListener ( DocumentFocusListener l ) { documentFocusListeners . remove ( DocumentFocusListener . class , l ) ; } 
public void activeNetworkChanged ( Network activeNetwork ) ; public void activeNodeChanged ( Node activeNode ) ; } 
public void activeNetworkChanged ( Network activeNetwork ) { setNetwork ( activeNetwork ) ; } 
public void activeNodeChanged ( Node activeNode ) { networkView . setHighlight ( activeNode ) ; } 
public void nodeAdded ( Network source , Node node ) { NodeView nv = new NodeView ( this , node ) ; getLayer ( ) . addChild ( nv ) ; } 
public void nodeRemoved ( Network source , Node node ) { NodeView nv = getNodeView ( node ) ; if ( nv = = null ) return ; getLayer ( ) . removeChild ( nv ) ; } 
public void connectionAdded ( Network source , Connection connection ) { ConnectionView cv = new ConnectionView ( this , connection ) ; getLayer ( ) . addChild ( cv ) ; } 
public void connectionRemoved ( Network source , Connection connection ) { ConnectionView cv = getConnectionView ( connection ) ; if ( cv = = null ) return ; getLayer ( ) . removeChild ( cv ) ; } 
public void nodeChanged ( Network source , Node node ) { NodeView nv = getNodeView ( node ) ; TODO: Should set position in other networks. nv.setOffset(node.getX(), node.getY()); nv.repaint(); } 
public void renderedNodeChanged ( Network source , Node node ) { repaint ( ) ; } 
public abstract Pane clone ( ) ; public void activeNetworkChanged ( Network activeNetwork ) { } public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; int sz = ( orientation = = JSplitPane . VERTICAL_SPLIT ? getWidth ( ) : getHeight ( ) ) / 2 ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setDividerLocation ( sz ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } } 
public void activeNetworkChanged ( Network activeNetwork ) { } public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; int sz = ( orientation = = JSplitPane . VERTICAL_SPLIT ? getWidth ( ) : getHeight ( ) ) / 2 ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setDividerLocation ( sz ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } } 
public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; int sz = ( orientation = = JSplitPane . VERTICAL_SPLIT ? getWidth ( ) : getHeight ( ) ) / 2 ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setDividerLocation ( sz ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } } 
public void activeNodeChanged ( Node activeNode ) { setNode ( activeNode ) ; } 
public Pane clone ( ) { return new ViewerPane ( getDocument ( ) ) ; } 
public boolean remove ( Node node ) { assert ( node ! = null ) ; if ( ! contains ( node ) ) { return false ; } node . markDirty ( ) ; TODO: disconnect node from the old network. node.disconnect(); nodes.remove(node.getName()); if (node == renderedNode) { setRenderedNode(null); } fireNodeRemoved(node); return true; } 
public void addNetworkEventListener ( NetworkEventListener l ) { listeners . add ( NetworkEventListener . class , l ) ; } 
public void removeNetworkEventListener ( NetworkEventListener l ) { listeners . remove ( NetworkEventListener . class , l ) ; } 
public void fireNodeAdded ( Node node ) { for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . nodeAdded ( this , node ) ; 
public void fireNodeRemoved ( Node node ) { for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . nodeRemoved ( this , node ) ; 
public void fireConnectionAdded ( Connection connection ) { for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . connectionAdded ( this , connection ) ; 
public void fireConnectionRemoved ( Connection connection ) { for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . connectionRemoved ( this , connection ) ; 
public void fireRenderedNodeChanged ( Node node ) { for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . renderedNodeChanged ( this , node ) ; 
public void fireNodeChanged ( Node node ) { for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . nodeChanged ( this , node ) ; 
public void addNetworkDirtyListener ( NetworkDirtyListener l ) { listeners . add ( NetworkDirtyListener . class , l ) ; } 
public void removeNetworkDirtyListener ( NetworkDirtyListener l ) { listeners . remove ( NetworkDirtyListener . class , l ) ; } 
public void fireNetworkDirty ( ) { for ( EventListener l : listeners . getListeners ( NetworkDirtyListener . class ) ) ( ( NetworkDirtyListener ) l ) . networkDirty ( this ) ; 
public void nodeAdded ( Network source , Node node ) ; public void nodeChanged ( Network source , Node node ) ; } 
public void nodeRemoved ( Network source , Node node ) ; public void nodeChanged ( Network source , Node node ) ; } 
public void connectionAdded ( Network source , Connection connection ) ; public void nodeChanged ( Network source , Node node ) ; } 
public void connectionRemoved ( Network source , Connection connection ) ; public void nodeChanged ( Network source , Node node ) ; } 
public void renderedNodeChanged ( Network source , Node node ) ; public void nodeChanged ( Network source , Node node ) ; } 
public void setName ( String name ) throws InvalidName { Since the network does the rename, fireNodeChanged() will be called from the network. if (inNetwork()) { network.rename(this, name); 
protected void _setName ( String name ) { this . name = name ; } 
public Parameter addParameter ( String name , Parameter . Type type ) { Parameter p = new Parameter ( this , name , type ) ; parameters . put ( name , p ) ; fireNodeChanged ( ) ; return p ; } 
public void fireNodeChanged ( ) { if ( inNetwork ( ) ) getNetwork ( ) . fireNodeChanged ( this ) ; 
public void addMenuItem ( String key , String label ) { menuItems . add ( new MenuEntry ( key , label ) ) ; node . fireNodeChanged ( ) ; } 
public boolean disconnect ( ) { if ( ! isConnected ( ) ) return false ; Node outputNode = connection . getOutputNode ( ) ; boolean downstreamRemoved = outputNode . getOutputParameter ( ) . getDownstreamConnections ( ) . remove ( connection ) ; assert ( downstreamRemoved ) ; Connection oldConnection = connection ; connection = null ; revertToDefault ( ) ; if ( getNode ( ) . inNetwork ( ) ) getNode ( ) . getNetwork ( ) . fireConnectionRemoved ( oldConnection ) ; return true ; } 
private void initMenu ( ) { JMenuBar menuBar = new JMenuBar ( ) ; File menu JMenu fileMenu = new JMenu("File"); fileMenu.add(new JMenuItem(newAction)); fileMenu.add(new JMenuItem(openAction)); fileMenu.addSeparator(); fileMenu.add(new JMenuItem(closeAction)); fileMenu.add(new JMenuItem(saveAction)); fileMenu.add(new JMenuItem(saveAsAction)); fileMenu.add(new JMenuItem(revertAction)); fileMenu.addSeparator(); fileMenu.add(new JMenuItem(exportAction)); if (!PlatformUtils.onMac()) { fileMenu.addSeparator(); fileMenu.add(new JMenuItem(quitAction)); } menuBar.add(fileMenu); Edit menu JMenu editMenu = new JMenu("Edit"); editMenu.add(new JMenuItem(undoAction)); editMenu.add(new JMenuItem(redoAction)); editMenu.addSeparator(); editMenu.add(new JMenuItem(cutAction)); editMenu.add(new JMenuItem(copyAction)); editMenu.add(new JMenuItem(pasteAction)); editMenu.addSeparator(); editMenu.add(new JMenuItem(deleteAction)); menuBar.add(editMenu); setJMenuBar(menuBar); } 
public void actionPerformed ( ActionEvent e ) { } } public class ExportAction extends AbstractAction { public ExportAction ( ) { putValue ( NAME , " Export " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_E ) ) ; } public void actionPerformed ( ActionEvent e ) { export ( ) ; } } public class QuitAction extends AbstractAction { public QuitAction ( ) { putValue ( NAME , " Quit " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Q ) ) ; } public void actionPerformed ( ActionEvent e ) { boolean allClosed = true ; Because documents will disappear from the list once they are closed, make a copy of the list. java.util.List<Document> documents = new ArrayList<Document>(Application.getInstance().getDocuments()); for (Document d : documents) { allClosed = allClosed && d.shouldClose(); } if (allClosed) { System.exit(0); } } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } }} 
public void actionPerformed ( ActionEvent e ) { try { undo . undo ( ) ; } catch ( CannotUndoException ex ) { logger . log ( Level . WARNING , " Unable to undo. " , ex ) ; } update ( ) ; redoAction . update ( ) ; } 
public void update ( ) { if ( undo . canUndo ( ) ) { setEnabled ( true ) ; 
public void actionPerformed ( ActionEvent e ) { try { undo . redo ( ) ; } catch ( CannotRedoException ex ) { logger . log ( Level . WARNING , " Unable to redo. " , ex ) ; } update ( ) ; undoAction . update ( ) ; } 
public void update ( ) { if ( undo . canRedo ( ) ) { setEnabled ( true ) ; 
public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } }} 
public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } }} 
public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } }} 
public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } }} 
public abstract Pane clone ( ) ; public void activeNetworkChanged ( Network activeNetwork ) { } public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } } 
public void activeNetworkChanged ( Network activeNetwork ) { } public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } } 
public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; parent . validate ( ) ; } } 
private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } 
public void markDirty ( ) { super . markDirty ( ) ; fireNetworkDirty ( ) ; } 
public void fireNodeAdded ( Node node ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . nodeAdded ( this , node ) ; 
public void fireNodeRemoved ( Node node ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . nodeRemoved ( this , node ) ; 
public void fireConnectionAdded ( Connection connection ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . connectionAdded ( this , connection ) ; 
public void fireConnectionRemoved ( Connection connection ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . connectionRemoved ( this , connection ) ; 
public void fireRenderedNodeChanged ( Node node ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . renderedNodeChanged ( this , node ) ; 
public void fireNodeChanged ( Node node ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . nodeChanged ( this , node ) ; 
public void fireNetworkDirty ( ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkDirtyListener . class ) ) ( ( NetworkDirtyListener ) l ) . networkDirty ( this ) ; 
public void markDirty ( ) { if ( dirty ) return ; dirty = true ; getOutputParameter ( ) . markDirtyDownstream ( ) ; if ( inNetwork ( ) & & ! network . isDirty ( ) ) { Only changes to the rendered node should make the network dirty. 
public void nodeAdded ( Network source , Node node ) { } public void nodeChanged ( Network source , Node node ) { } } 
public void nodeRemoved ( Network source , Node node ) { } public void nodeChanged ( Network source , Node node ) { } } 
public void connectionAdded ( Network source , Connection connection ) { } public void nodeChanged ( Network source , Node node ) { } } 
public void connectionRemoved ( Network source , Connection connection ) { } public void nodeChanged ( Network source , Node node ) { } } 
public void renderedNodeChanged ( Network source , Node node ) { } public void nodeChanged ( Network source , Node node ) { } } 
public void networkDirty ( Network network ) { System . out . println ( " networkDirty " + network . getName ( ) ) ; if ( network ! = activeNetwork ) return ; activeNetwork . update ( ) ; } 
public void networkUpdated ( Network network ) { System . out . println ( " networkUpdated " ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( getNetwork ( ) = = null ) return ; Object outputValue = getNetwork ( ) . getOutputValue ( ) ; System . out . println ( " outputValue = " + outputValue ) ; if ( outputValue instanceof Grob ) { ( ( Grob ) outputValue ) . draw ( g2 ) ; 
public Grob get ( int index ) { try { return grobs . get ( index ) ; 
public void markDirty ( ) { if ( isDirty ( ) ) return ; super . markDirty ( ) ; fireNetworkDirty ( ) ; } 
public boolean update ( ProcessingContext ctx ) { boolean success = super . update ( ctx ) ; fireNetworkUpdated ( ) ; return success ; } 
protected boolean updateRenderedNode ( ProcessingContext ctx ) { if ( renderedNode = = null ) { addError ( " No node to render " ) ; return false ; } assert ( contains ( renderedNode ) ) ; return renderedNode . update ( ctx ) ; } 
protected boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { setOutputValue ( renderedNode . getOutputValue ( ) ) ; } else { If there is nothing to render, set the output to a sane default. getOutputParameter().revertToDefault(); } return success; } 
public void addNetworkDataListener ( NetworkDataListener l ) { listeners . add ( NetworkDataListener . class , l ) ; } 
public void removeNetworkDataListener ( NetworkDataListener l ) { listeners . remove ( NetworkDataListener . class , l ) ; } 
public void fireNetworkDirty ( ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkDataListener . class ) ) ( ( NetworkDataListener ) l ) . networkDirty ( this ) ; 
public void fireNetworkUpdated ( ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkDataListener . class ) ) ( ( NetworkDataListener ) l ) . networkUpdated ( this ) ; 
public void networkDirty ( Network network ) ; public void networkUpdated ( Network network ) ; } 
public void addInfo ( String msg ) { messages . add ( new Message ( MessageLevel . INFO , msg ) ) ; } 
public void addWarning ( String msg ) { messages . add ( new Message ( MessageLevel . WARNING , msg ) ) ; } 
public void addError ( String msg ) { messages . add ( new Message ( MessageLevel . ERROR , msg ) ) ; } 
public void set ( int value ) { if ( coreType ! = CoreType . INT ) { throw new ValueError ( " Tried setting integer value on parameter with type " + type ) ; } if ( ! valueCorrectForBounds ( value ) ) { throw new ValueError ( " Value is out of bounds " ) ; } if ( asInt ( ) = = value ) return ; this . value = value ; valueSet = true ; markDirty ( ) ; } 
public void set ( double value ) { if ( coreType ! = CoreType . FLOAT ) { throw new ValueError ( " Tried setting float value on parameter with type " + type ) ; } if ( ! valueCorrectForBounds ( value ) ) { throw new ValueError ( " Value is out of bounds " ) ; } if ( asFloat ( ) = = value ) return ; this . value = value ; valueSet = true ; markDirty ( ) ; } 
public void set ( String value ) { if ( value = = null ) return ; if ( coreType ! = CoreType . STRING ) { throw new ValueError ( " Tried setting string value on parameter with type " + type ) ; } if ( asString ( ) . equals ( value ) ) return ; this . value = value ; valueSet = true ; markDirty ( ) ; } 
public void set ( Color value ) { if ( value = = null ) return ; if ( coreType ! = CoreType . COLOR ) { throw new ValueError ( " Tried setting color value on parameter with type " + type ) ; } if ( asColor ( ) . equals ( value ) ) return ; this . value = value ; valueSet = true ; markDirty ( ) ; } 
public void set ( Grob value ) { if ( value = = null ) return ; if ( coreType ! = CoreType . GROB_SHAPE & & coreType ! = CoreType . GROB_CANVAS & & coreType ! = CoreType . GROB_IMAGE ) { throw new ValueError ( " Tried setting grob value on parameter with type " + type ) ; } this . value = value ; valueSet = true ; markDirty ( ) ; } 
protected boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Canvas c = new Canvas ( pWidth . asFloat ( ) , pHeight . asFloat ( ) ) ; Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { c . add ( ( Grob ) outputValue ) ; } else { throw new AssertionError ( getName ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } setOutputValue ( c ) ; } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
protected boolean process ( ProcessingContext ctx ) { Canvas c = new Canvas ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( pFillColor . asColor ( ) ) ; p . setStrokeColor ( pStrokeColor . asColor ( ) ) ; p . setStrokeWidth ( pStrokeWidth . asFloat ( ) ) ; p . addEllipse ( pX . asFloat ( ) , pY . asFloat ( ) , pWidth . asFloat ( ) , pHeight . asFloat ( ) ) ; c . add ( p ) ; setOutputValue ( c ) ; return true ; } 
protected boolean process ( ProcessingContext ctx ) { Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( pFillColor . asColor ( ) ) ; p . setStrokeColor ( pStrokeColor . asColor ( ) ) ; p . setStrokeWidth ( pStrokeWidth . asFloat ( ) ) ; p . addRect ( pX . asFloat ( ) , pY . asFloat ( ) , pWidth . asFloat ( ) , pHeight . asFloat ( ) ) ; g . add ( p ) ; setOutputValue ( g ) ; return true ; } 
protected boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g . translate ( pTx . asFloat ( ) , pTy . asFloat ( ) ) ; g . scale ( pSx . asFloat ( ) , pSy . asFloat ( ) ) ; setOutputValue ( g ) ; } else { throw new AssertionError ( getName ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public void networkDirty ( Network network ) { + + dirtyCounter ; } 
public void networkUpdated ( Network network ) { + + updatedCounter ; } 
public void testDataEvent ( ) { TestDataListener l = new TestDataListener ( ) ; TestNetwork net = new TestNetwork ( ) ; net . addNetworkDataListener ( l ) ; Node n1 = net . create ( TestNode . class ) ; Node n2 = net . create ( TestNode . class ) ; assertEquals ( 0 , l . dirtyCounter ) ; assertEquals ( 0 , l . updatedCounter ) ; n1 . setRendered ( ) ; Network was already dirty from the start, counter is not updated. assertEquals(0, l.dirtyCounter); assertEquals(0, l.updatedCounter); net.update(); assertEquals(0, l.dirtyCounter); assertEquals(1, l.updatedCounter); n2.setRendered(); assertEquals(1, l.dirtyCounter); assertEquals(1, l.updatedCounter); net.update(); assertEquals(1, l.dirtyCounter); assertEquals(2, l.updatedCounter); } 
public void testBasicProcessing ( ) { TestNetwork net = new TestNetwork ( ) ; Node v1 = net . create ( TestNode . class ) ; net . update ( ) ; assertTrue ( net . hasError ( ) ) ; assertEquals ( 0 , net . getOutputValue ( ) ) ; v1 . setRendered ( ) ; net . update ( ) ; assertFalse ( net . hasError ( ) ) ; assertEquals ( 42 , net . getOutputValue ( ) ) ; } 
public void testRectNode ( ) { RectNode r = new RectNode ( ) ; r . update ( ) ; Object outputValue = r . getOutputValue ( ) ; if ( ! ( outputValue instanceof Group ) ) fail ( " Output value is not a Group, but " + outputValue ) ; Group group = ( Group ) outputValue ; assertEquals ( 1 , group . size ( ) ) ; BezierPath p = ( BezierPath ) group . get ( 0 ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , p . getBounds ( ) ) ; } 
public void testVectorNetwork ( ) { VectorNetwork net = new VectorNetwork ( ) ; Node rect1 = net . create ( RectNode . class ) ; net . update ( ) ; } 
public void appendTransform ( Transform transform ) { this . transform . append ( transform ) ; } 
public Grob asGrob ( ) { if ( coreType = = CoreType . GROB_SHAPE | | coreType = = CoreType . GROB_CANVAS | | coreType = = CoreType . GROB_IMAGE ) { return ( Grob ) value ; 
private void doCopy ( Group outputGroup , double tx , double ty ) { Set up the transform Transform t = new Transform(); t.translate(tx, ty); Loop through the number of copies for (int i = pCopies.asInt(); i > 0; i--) { 
public void testMacro ( ) { VectorNetwork towerMacro = new VectorNetwork ( ) ; myCopyMacro.setDescription("Gets an image and makes points out of it."); Parameter pFloorHeight = towerMacro.addParameter("floorHeight", Parameter.Type.FLOAT); pFloorHeight.setLabel("Height of Floor"); Parameter pSize = towerMacro.addParameter("buildingHeight", Parameter.Type.INT); pSize.setLabel("Building Height (in floors)"); Inner nodes Node rect1 = towerMacro.create(RectNode.class); Node copy1 = towerMacro.create(CopyNode.class); rect1.getParameter("width").set(50.0); rect1.getParameter("height").setExpression("network.floorHeight"); copy1.getParameter("shape").connect(rect1); copy1.getParameter("copies").setExpression("network.buildingHeight"); copy1.getParameter("ty").setExpression("network.floorHeight"); copy1.setRendered(); Execute the macro. towerMacro.setValue("floorHeight", 20.0); towerMacro.setValue("buildingHeight", 8); towerMacro.update(); Grob g = (Grob) towerMacro.getOutputValue(); assertEquals(new Rect(0, 0, 50.0, 160.0), g.getBounds()); } 
public Object evaluate ( ) { ProxyResolverFactory prf = new ProxyResolverFactory ( parameter . getNode ( ) ) ; try { return MVEL . executeExpression ( compiledExpression , prf ) ; 
public VariableResolver createVariable ( String name , Object value ) { throw new CompileException ( " Variable assignment is not supported. " ) ; } 
public VariableResolver createVariable ( String name , Object value , Class < ? > type ) { throw new CompileException ( " Variable assignment is not supported. " ) ; } 
public boolean isResolveable ( String name ) { return ( variableResolvers ! = null & & variableResolvers . containsKey ( name ) ) | | ( proxy . containsKey ( name ) ) 
public boolean isTarget ( String name ) { return variableResolvers ! = null & & variableResolvers . containsKey ( name ) ; } 
public boolean containsKey ( Object key ) { if ( key = = null ) return false ; if ( ! ( key instanceof String ) ) return false ; return keySet . contains ( ( String ) key ) ; } 
public boolean containsValue ( Object value ) { throw new NotImplementedException ( ) ; } 
public Object put ( Object key , Object value ) { throw new AssertionError ( " You cannot change the node access proxy. " ) ; } 
public Object remove ( Object key ) { throw new AssertionError ( " You cannot change the node access proxy. " ) ; } 
public void putAll ( Map ) { throw new AssertionError ( " You cannot change the node access proxy. " ) ; } 
public void clear ( ) { throw new AssertionError ( " You cannot change the node access proxy. " ) ; } 
public Collection values ( ) { throw new NotImplementedException ( ) ; } 
public Set entrySet ( ) { throw new NotImplementedException ( ) ; } 
public void testNodeLocal ( ) { Node = new TestNode ( ) ; Parameter p1 = . addParameter ( " p1 " , Parameter . Type . INT ) ; Parameter p2 = . addParameter ( " p2 " , Parameter . Type . INT ) ; p2 . setDefaultValue ( 12 ) ; assertExpressionEquals ( 12 , p1 , " p2 " ) ; } 
public void xtestCycles ( ) { Node = new TestNode ( ) ; Parameter p1 = . addParameter ( " p1 " , Parameter . Type . INT ) ; assertExpressionInvalid ( p1 , " p1 " ) ; } 
public void testNetworkLocal ( ) { Network = new TestNetwork ( ) ; Parameter pn = . addParameter ( " pn " , Parameter . Type . INT ) ; pn . setDefaultValue ( 33 ) ; Node test1 = . create ( TestNode . class ) ; assertEquals ( " test1 " , test1 . getName ( ) ) ; Parameter p1 = test1 . addParameter ( " p1 " , Parameter . Type . INT ) ; Node test2 = . create ( TestNode . class ) ; assertEquals ( " test2 " , test2 . getName ( ) ) ; Parameter p2 = test2 . addParameter ( " p2 " , Parameter . Type . INT ) ; p2 . setDefaultValue ( 12 ) ; Try to access p2 directly. Should fail, since p2 is on another node. assertExpressionInvalid(p1, "p2"); Access p2 through the node name. assertExpressionEquals(12, p1, "test2.p2"); Access p2 through the network. assertExpressionEquals(12, p1, "network.test2.p2"); Access the pn Parameter on the network. assertExpressionEquals(33, p1, "network.pn"); } 
public void assertExpressionEquals ( Object expected , Parameter p , String expression ) { p . setExpression ( expression ) ; p . update ( new ProcessingContext ( ) ) ; assertEquals ( expected , p . getValue ( ) ) ; } 
public void assertExpressionInvalid ( Parameter p , String expression ) { p . setExpression ( expression ) ; try { p . update ( new ProcessingContext ( ) ) ; 
public void testNaming ( ) { Node = new TestNode ( ) ; assertEquals ( . defaultName ( ) , " test " ) ; assertEquals ( . getName ( ) , " test " ) ; } 
public void testBasicCopy ( ) { RectNode rect = new RectNode ( ) ; CopyNode copy = new CopyNode ( ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , g . getBounds ( ) ) ; copy . setValue ( " ty " , 100.0 ) ; copy . setValue ( " copies " , 5 ) ; copy . update ( ) ; g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 500 ) , g . getBounds ( ) ) ; } 
private ParameterControl constructControl ( Class controlClass , Parameter p ) { try { Constructor constructor = controlClass . getConstructor ( Parameter . class ) ; 
public double clamp ( double value , double minimum , double maximum ) { return Math . max ( minimum , Math . min ( maximum , value ) ) ; } 
protected boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g . translate ( pTx . asFloat ( ) , pTy . asFloat ( ) ) ; g . rotate ( pR . asFloat ( ) ) ; g . scale ( pSx . asFloat ( ) , pSy . asFloat ( ) ) ; setOutputValue ( g ) ; } else { throw new AssertionError ( getName ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public Rect united ( Rect r ) { Rect r1 = normalized ( ) ; Rect r2 = r . normalized ( ) ; Rect u = new Rect ( ) ; u . x = Math . min ( r1 . x , r2 . x ) ; u . y = Math . min ( r1 . y , r2 . y ) ; u . width = Math . max ( r1 . x + r1 . width , r2 . x + r2 . width ) - u . x ; u . height = Math . max ( r1 . y + r1 . width , r2 . y + r2 . height ) - u . y ; return u ; } 
public Rect convertBoundsToFrame ( Rect bounds ) { AffineTransform = fullTransform ( bounds ) ; Point2D transformedOrigin = new Point2D . Double ( ) ; Point2D transformedSize = new Point2D . Double ( ) ; . transform ( new Point2D . Double ( bounds . getX ( ) , bounds . getY ( ) ) , transformedOrigin ) ; . deltaTransform ( new Point2D . Double ( bounds . getWidth ( ) , bounds . getHeight ( ) ) , transformedSize ) ; return new Rect ( transformedOrigin . getX ( ) , transformedOrigin . getY ( ) , transformedSize . getX ( ) , transformedSize . getY ( ) ) ; } 
public Grob clone ( ) { return new TestGrob ( x , y , width , height ) ; } 
public void testFrame ( ) { TestGrob tg = new TestGrob ( 1 , 2 , 3 , 4 ) ; assertEquals ( new Rect ( 1 , 2 , 3 , 4 ) , tg . getBounds ( ) ) ; tg . translate ( 200 , 300 ) ; Bounds don't change, but frame does. assertEquals(new Rect(1, 2, 3, 4), tg.getBounds()); assertEquals(new Rect(201, 302, 3, 4), tg.getFrame()); 
public void testBounds ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . addRect ( 10 , 20 , 30 , 40 ) ; Group g1 = new Group ( ) ; g1 . add ( r1 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 40 ) , g1 . getBounds ( ) ) ; } 
public void testTransformedBounds ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . addRect ( 10 , 20 , 30 , 40 ) ; r1 . translate ( 200 , 300 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; assertEquals ( new Rect ( 210 , 320 , 30 , 40 ) , g . getBounds ( ) ) ; } 
public void testTransformedElements ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . addRect ( 10 , 20 , 30 , 40 ) ; BezierPath r2 = new BezierPath ( ) ; r2 . addRect ( 10 , 120 , 30 , 40 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; g . add ( r2 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 120 + 40 ) , g . getBounds ( ) ) ; } 
public void testUnited ( ) { Rect r1 = new Rect ( 10 , 20 , 30 , 40 ) ; Rect r2 = new Rect ( 40 , 30 , 50 , 30 ) ; assertEquals ( new Rect ( 10 , 20 , 80 , 90 ) , r1 . united ( r2 ) ) ; Rect r3 = new Rect ( 10 , 20 , 30 , 40 ) ; Rect r4 = new Rect ( 10 , 120 , 30 , 40 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 120 + 40 ) , r3 . united ( r4 ) ) ; } 
public void testTranslate ( ) { Transform = new Transform ( ) ; . translate ( 0 , 0 ) ; Point p = new Point ( 1 , 2 ) ; assertEquals ( new Point ( 1 , 2 ) , . map ( p ) ) ; . translate ( 0 , 100 ) ; assertEquals ( new Point ( 1 , 102 ) , . map ( p ) ) ; . translate ( 0 , 100 ) ; assertEquals ( new Point ( 1 , 202 ) , . map ( p ) ) ; } 
public void paintIcon ( Component component , Graphics g , int x , int y ) { g . setColor ( color ) ; g . translate ( x , y ) ; if ( direction = = NORTH ) { } else if ( direction = = SOUTH ) { g . drawLine ( 0 , 1 , 14 , 1 ) ; g . drawLine ( 1 , 2 , 13 , 2 ) ; g . drawLine ( 2 , 3 , 4 , 3 ) ; g . drawLine ( 6 , 3 , 8 , 3 ) ; g . drawLine ( 10 , 3 , 12 , 3 ) ; g . drawLine ( 3 , 4 , 3 , 4 ) ; g . drawLine ( 7 , 4 , 7 , 4 ) ; g . drawLine ( 11 , 4 , 11 , 4 ) ; } g . translate ( - x , - y ) ; } 
public void paintIcon ( Component component , Graphics g , int x , int y ) { g . setColor ( color ) ; g . translate ( x , y ) ; if ( direction = = NORTH ) { } else if ( direction = = EAST ) { g . drawLine ( 1 , 0 , 1 , 6 ) ; g . drawLine ( 2 , 1 , 2 , 5 ) ; g . drawLine ( 3 , 2 , 3 , 4 ) ; g . drawLine ( 4 , 3 , 4 , 3 ) ; } else if ( direction = = SOUTH ) { g . drawLine ( 0 , 1 , 6 , 1 ) ; g . drawLine ( 1 , 2 , 5 , 2 ) ; g . drawLine ( 2 , 3 , 4 , 3 ) ; g . drawLine ( 3 , 4 , 3 , 4 ) ; } else if ( direction = = WEST ) { g . drawLine ( 4 , 0 , 4 , 6 ) ; g . drawLine ( 3 , 1 , 3 , 5 ) ; g . drawLine ( 2 , 2 , 2 , 4 ) ; g . drawLine ( 1 , 3 , 1 , 3 ) ; } g . translate ( - x , - y ) ; 
public void networkDirty ( Network network ) { if ( network ! = activeNetwork ) return ; activeNetwork . update ( ) ; } 
public void actionPerformed ( ActionEvent e ) { try { setValue ( Double . parseDouble ( numberField . getText ( ) ) ) ; content . remove ( numberField ) ; content . add ( numberLabel , BorderLayout . CENTER ) ; validate ( ) ; } catch ( NumberFormatException ex ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; } fireActionPerformed ( ) ; } 
public void focusLost ( FocusEvent e ) { content . remove ( numberField ) ; content . add ( numberLabel , BorderLayout . CENTER ) ; repaint ( ) ; } 
public void mousePressed ( MouseEvent e ) { sourceX = prevX = e . getX ( ) ; sourceX = prevY = e . getY ( ) ; oldValue = getValue ( ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( oldValue ! = value ) fireActionPerformed ( ) ; 
public synchronized void addActionListener ( ActionListener l ) { listenerList . add ( ActionListener . class , l ) ; } 
public synchronized void removeActionListener ( ActionListener l ) { listenerList . remove ( ActionListener . class , l ) ; } 
protected void fireActionPerformed ( ) { Guaranteed to return a non-null array Object[] listeners = listenerList.getListenerList(); int modifiers = 0; AWTEvent currentEvent = EventQueue.getCurrentEvent(); if (currentEvent instanceof InputEvent) { modifiers = ((InputEvent) currentEvent).getModifiers(); } else if (currentEvent instanceof ActionEvent) { modifiers = ((ActionEvent) currentEvent).getModifiers(); } todo: could use lightweight event here? ActionEvent e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, Double.toString(value), EventQueue.getMostRecentEventTime(), modifiers); Process the listeners last to first, notifying those that are interested in this event for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == ActionListener.class) { 
public void addChangeListener ( ChangeListener l ) { listenerList . add ( ChangeListener . class , l ) ; } 
public void removeChangeListener ( ChangeListener l ) { listenerList . remove ( ChangeListener . class , l ) ; } 
protected void fireStateChanged ( ) { Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i > = 0 ; i - = 2 ) { if ( listeners [ i ] = = ChangeListener . class ) { 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( getNetwork ( ) = = null ) return ; Object outputValue = getNetwork ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { ( ( Grob ) outputValue ) . draw ( g2 ) ; 
public void stateChanged ( ChangeEvent e ) { setValueFromControl ( ) ; } 
public void actionPerformed ( ActionEvent e ) { setValueFromControl ( ) ; } 
Parameter getParameter ( ) ; void setValueForControl ( Object v ) ; } 
public boolean containsValue ( Object value ) { throw new RuntimeException ( " Not implemented " ) ; } 
public Collection values ( ) { throw new RuntimeException ( " Not implemented " ) ; } 
public Set entrySet ( ) { throw new RuntimeException ( " Not implemented " ) ; } 
public Node create ( Class nodeClass ) { assert ( Node . class . isAssignableFrom ( nodeClass ) ) ; try { Node newNode = ( Node ) nodeClass . newInstance ( ) ; 
public void addSelection ( Connection connection ) { selections . add ( connection ) ; } 
public void removeSelection ( Connection connection ) { selections . remove ( connection ) ; } 
private Rectangle2D boundsForConnection ( Connection c ) { double x0 = c . getOutputNode ( ) . getX ( ) ; double y0 = c . getOutputNode ( ) . getY ( ) ; double x1 = c . getInputNode ( ) . getX ( ) ; double y1 = c . getInputNode ( ) . getY ( ) ; Rect bounds = new Rect ( x0 , y0 , x1 - x0 , y1 - y0 ) ; bounds = bounds . normalized ( ) ; return bounds . getRectangle2D ( ) ; } 
public void updatePath ( ) { reset ( ) ; float x0 = NodeView . NODE_WIDTH / 2 ; float y0 = NodeView . NODE_HEIGHT ; float x1 = ( float ) getWidth ( ) ; float y1 = ( float ) getHeight ( ) ; float dx = Math . abs ( x1 - x0 ) / 2 ; moveTo ( x0 , y0 ) ; curveTo ( x0 , y0 + dx , x1 , y1 - dx , x1 , y1 ) ; repaint ( ) ; } 
public void nodeMovedEvent ( ) { updateBounds(); updatePath(); } 
public void update ( Observable o , Object arg ) { setValueForControl ( parameter . getValue ( ) ) ; } 
public Grob clone ( ) { BezierPath p = new BezierPath ( ) ; p . setTransform ( getTransform ( ) . clone ( ) ) ; p . elements = ( ArrayList < PathElement > ) elements . clone ( ) ; p . fillColor = fillColor = = null ? null : fillColor . clone ( ) ; p . strokeColor = strokeColor = = null ? null : strokeColor . clone ( ) ; p . strokeWidth = strokeWidth ; return p ; } 
protected boolean process ( ProcessingContext ctx ) { Grob g = ( Grob ) pShape . getValue ( ) ; Grob outGrob = g . clone ( ) ; Transform = new Transform ( ) ; . translate ( pTx . asFloat ( ) , pTy . asFloat ( ) ) ; . rotate ( pR . asFloat ( ) ) ; . scale ( pSx . asFloat ( ) , pSy . asFloat ( ) ) ; outGrob . appendTransform ( ) ; setOutputValue ( outGrob ) ; return true ; } 
public void toXml ( StringBuffer xml , String spaces ) { xml . append ( spaces ) ; xml . append ( " <edge " ) ; xml . append ( " outputNode= \" " ) . append ( getOutputNode ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " inputNode= \" " ) . append ( getInputNode ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " inputParameter= \" " ) . append ( getInputParameter ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " /> " ) ; } 
public String toXml ( ) { StringBuffer xml = new StringBuffer ( ) ; Build the header xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"); xml.append("<ndbx type=\"file\" formatversion=\"0.8\">"); toXml(xml, " "); xml.append("</ndbx>"); return xml.toString(); } 
public void toXml ( StringBuffer xml , String spaces ) { Build the node xml.append(spaces).append("<node "); xml.append("name=\""); xml.append(getName()); xml.append("\" "); xml.append("type=\""); xml.append(getClass().getName()); xml.append("\" "); xml.append("x=\""); xml.append(getX()); xml.append("\" "); xml.append("y=\""); xml.append(getY()); xml.append("\" "); if (isRendered()) xml.append("rendered=\"true\" "); xml.append(">"); xml.append(spaces); xml.append(" <data>"); Build the parameter list dataToXml(xml, spaces); End the node xml.append(spaces); xml.append(" </data>"); xml.append(spaces); xml.append("</node>"); } 
public boolean isPrimitive ( ) { return ( coreType = = CoreType . INT | | coreType = = CoreType . FLOAT | | coreType = = CoreType . STRING | | coreType = = CoreType . COLOR ) ; } 
public void toXml ( StringBuffer xml , String spaces ) { Don't do non-primitive parameters. if (!isPrimitive()) return; Write parameter name xml.append(spaces).append("<key>").append(getName()).append("</key>"); if (hasExpression()) { xml.append(spaces).append("<expression>").append(getExpression()).append("</expression>"); 
public void testPersistence ( ) { CanvasNetwork rootNetwork = new CanvasNetwork ( " root " ) ; Network vector1 = ( Network ) rootNetwork . create ( VectorNetwork . class ) ; vector1 . setPosition ( 10 , 10 ) ; vector1 . setRendered ( ) ; Node ellipse1 = vector1 . create ( EllipseNode . class ) ; ellipse1 . setRendered ( ) ; ellipse1 . setPosition ( 100 , 30 ) ; Node transform1 = vector1 . create ( TransformNode . class ) ; transform1 . setPosition ( 40 , 80 ) ; transform1 . setRendered ( ) ; transform1 . getParameter ( " shape " ) . connect ( ellipse1 ) ; System . out . println ( " rootNetwork.toXml() " + rootNetwork . toXml ( ) ) ; } 
protected Transform clone ( ) { return new Transform ( ( AffineTransform ) affineTransform . clone ( ) ) ; } 
public void testTransformedElements ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . addRect ( 10 , 20 , 30 , 40 ) ; BezierPath r2 = new BezierPath ( ) ; r2 . addRect ( 10 , 120 , 30 , 40 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; g . add ( r2 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 120 + 40 - 20 ) , g . getBounds ( ) ) ; } 
public void testUnited ( ) { Rect r1 = new Rect ( 10 , 20 , 30 , 40 ) ; Rect r2 = new Rect ( 40 , 30 , 50 , 30 ) ; assertEquals ( new Rect ( 10 , 20 , 40 + 50 - 10 , 30 + 30 - 20 ) , r1 . united ( r2 ) ) ; Rect r3 = new Rect ( 10 , 20 , 30 , 40 ) ; Rect r4 = new Rect ( 10 , 120 , 30 , 40 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 120 + 40 - 20 ) , r3 . united ( r4 ) ) ; } 
public void toXml ( StringBuffer xml , String spaces ) { xml . append ( spaces ) ; xml . append ( " <connection " ) ; xml . append ( " outputNode= \" " ) . append ( getOutputNode ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " inputNode= \" " ) . append ( getInputNode ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " inputParameter= \" " ) . append ( getInputParameter ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " /> " ) ; } 
public String toXml ( ) { StringBuffer xml = new StringBuffer ( ) ; Build the header xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"); xml.append("<ndbx type=\"file\" formatVersion=\"0.8\">"); toXml(xml, " "); xml.append("</ndbx>"); return xml.toString(); } 
public static Network load ( NodeManager nodeManager , String s ) throws RuntimeException { StringReader reader = new StringReader ( s ) ; return load ( nodeManager , new InputSource ( reader ) ) ; } 
public static Network load ( NodeManager nodeManager , File file ) throws RuntimeException { Load the document FileInputStream fis; try { fis = new FileInputStream(file); } catch (FileNotFoundException e) { logger.log(Level.SEVERE, "Could not read file " + file, e); throw new RuntimeException("Could not read file " + file, e); } return load(nodeManager, new InputSource(fis)); } 
private static Network load ( NodeManager nodeManager , InputSource source ) throws RuntimeException { Setup the parser SAXParserFactory factory = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. try { factory.setFeature("http:xml.org/sax/features/validation", false); factory.setFeature("http:xml.org/sax/features/external-parameter-entities", false); factory.setFeature("http:xml.org/sax/features/external-general-entities", false); factory.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); } catch (Exception e) { logger.log(Level.SEVERE, "Parsing feature not supported.", e); throw new RuntimeException("Parsing feature not supported.", e); } SAXParser parser; try { parser = factory.newSAXParser(); } catch (Exception e) { logger.log(Level.SEVERE, "Could not create parser.", e); throw new RuntimeException("Could not create parser.", e); } Parse the document XmlHandler handler = new XmlHandler(nodeManager); try { parser.parse(source, handler); } catch (Exception e) { logger.log(Level.SEVERE, "Error during parsing.", e); throw new RuntimeException("Error during parsing.", e); } return handler.getNetwork(); 
public static Version parseVersionString ( String s ) { return new Version ( s ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Version ) ) return false ; Version v = ( Version ) o ; return major = = v . major & & minor = = v . minor ; 
public boolean largerThan ( Version other ) { if ( major > other . major ) return true ; return major = = other . major & & minor > other . minor ; } 
public boolean largerOrEqualThan ( Version other ) { if ( largerThan ( other ) ) return true ; return major = = other . major & & minor = = other . minor ; } 
public boolean smallerOrEqualThan ( Version other ) { return ! largerThan ( other ) ; } 
public boolean smallerThan ( Version other ) { return ! largerOrEqualThan ( other ) ; } 
public String toString ( ) { return major + " . " + minor ; } 
public Object clone ( ) { return new Version ( major , minor ) ; } 
public Parameter getParameter ( String name ) throws NotFound { if ( hasParameter ( name ) ) { return parameters . get ( name ) ; 
public void toXml ( StringBuffer xml , String spaces ) { Build the node xml.append(spaces).append("<node"); xml.append(" name=\"").append(getName()).append("\""); xml.append(" type=\"").append(getTypeName()).append("\""); xml.append(" version=\"").append(getVersion()).append("\""); xml.append(" x=\"").append(getX()).append("\""); xml.append(" y=\"").append(getY()).append("\""); if (isRendered()) xml.append(" rendered=\"true\""); xml.append(">"); xml.append(spaces); xml.append(" <data>"); Build the parameter list dataToXml(xml, spaces); End the node xml.append(spaces); xml.append(" </data>"); xml.append(spaces); xml.append("</node>"); } 
public boolean matches ( Node . Version version ) { return false ; } 
public boolean matches ( int major , int minor ) { return matches ( new Node . Version ( major , minor ) ) ; } 
public void addNode ( Node node ) { Node . Version newVersion = node . getVersion ( ) ; int i = 0 ; for ( ; i < nodes . size ( ) ; i + + ) { Node = nodes . get ( i ) ; if ( . getVersion ( ) . smallerThan ( newVersion ) ) break ; } nodes . add ( i , node ) ; } 
public void addNode ( Node ) { VersionedNodeList nodeList = nodeMap . get ( . getTypeName ( ) ) ; if ( nodeList = = null ) { nodeList = new VersionedNodeList ( ) ; nodeMap . put ( . getTypeName ( ) , nodeList ) ; } nodeList . addNode ( ) ; } 
public Node getNode ( String qualifiedName ) throws NodeNotFound { VersionedNodeList nodeList = nodeMap . get ( qualifiedName ) ; if ( nodeList = = null ) throw new NodeNotFound ( qualifiedName ) ; return nodeList . getLatestVersion ( ) ; } 
public Object parseValue ( String value ) throws NumberFormatException { switch ( coreType ) { case INT : 
public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( qName . equals ( " ndbx " ) ) { Make sure we use the correct format and file type. 
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( qName . equals ( " ndbx " ) ) { Top level element -- parsing finished. 
public void characters ( char [ ] ch , int start , int length ) throws SAXException { TODO: Characters can be called multiple times for long value ranges. Use temp var. switch (state) { case IN_KEY: 
private void createNetwork ( Attributes attributes ) throws SAXException { Network newNetwork ; try { newNetwork = ( Network ) lookupNode ( attributes ) ; } catch ( ClassCastException e ) { throw new SAXException ( " Node " + attributes . getValue ( " type " ) + " is not a network. " ) ; } if ( currentNetwork = = null ) { rootNetwork = newNetwork ; } else { currentNetwork . add ( newNetwork ) ; } currentNode = currentNetwork = newNetwork ; parseNodeFlags ( currentNetwork , attributes ) ; } 
private void createNode ( Attributes attributes ) throws SAXException { currentNode = lookupNode ( attributes ) ; currentNetwork . add ( currentNode ) ; parseNodeFlags ( currentNode , attributes ) ; } 
private Node lookupNode ( Attributes attributes ) throws SAXException { Node newNode ; String qualifiedName = attributes . getValue ( " type " ) ; String version = attributes . getValue ( " version " ) ; try { if ( version = = null ) { newNode = nodeManager . getNode ( qualifiedName ) ; } else { newNode = nodeManager . getNode ( qualifiedName , new Node . Version ( version ) ) ; } } catch ( NodeManager . NodeNotFound e ) { throw new SAXException ( " A node with type " + qualifiedName + " and version " + version + " does not exist. " ) ; } String name = attributes . getValue ( " name " ) ; if ( name ! = null ) { newNode . setName ( name ) ; } String x = attributes . getValue ( " x " ) ; if ( x ! = null ) { try { newNode . setX ( Double . parseDouble ( x ) ) ; } catch ( NumberFormatException e ) { logger . log ( Level . WARNING , " Could not parse x attribute for node " + name + " [ " + qualifiedName + " ] value= " + x ) ; } } String y = attributes . getValue ( " y " ) ; if ( y ! = null ) { try { newNode . setY ( Double . parseDouble ( y ) ) ; } catch ( NumberFormatException e ) { logger . log ( Level . WARNING , " Could not parse y attribute for node " + name + " [ " + qualifiedName + " ] value= " + y ) ; } } return newNode ; } 
private void parseNodeFlags ( Node node , Attributes attributes ) { String rendered = attributes . getValue ( " rendered " ) ; if ( " true " . equals ( rendered ) ) { node . setRendered ( ) ; 
private void createConnection ( Attributes attributes ) throws SAXException { String outputNodeName = attributes . getValue ( " outputNode " ) ; String inputNodeName = attributes . getValue ( " inputNode " ) ; String inputParameterName = attributes . getValue ( " inputParameter " ) ; if ( outputNodeName = = null ) throw new SAXException ( " Connection does not have an outputNode attribute set. " ) ; if ( inputNodeName = = null ) throw new SAXException ( " Connection does not have an inputNode attribute set. " ) ; if ( inputParameterName = = null ) throw new SAXException ( " Connection does not have an inputParameter attribute set. " ) ; Node outputNode = currentNetwork . getNode ( outputNodeName ) ; if ( outputNode = = null ) throw new SAXException ( " Node ' " + outputNodeName + " ' does not exist in the current network " + currentNetwork + " . " ) ; Node inputNode = currentNetwork . getNode ( inputNodeName ) ; if ( inputNode = = null ) throw new SAXException ( " Node ' " + inputNodeName + " ' does not exist in the current network " + currentNetwork + " . " ) ; Parameter inputParameter = inputNode . getParameter ( inputParameterName ) ; if ( inputParameter = = null ) throw new SAXException ( " Node ' " + inputNodeName + " ' does not have a parameter named " + inputParameterName + " . " ) ; inputParameter . connect ( outputNode ) ; } 
private void setValue ( String parameterName , String valueAsString ) throws SAXException { if ( currentNode = = null ) throw new SAXException ( " There is no current node. " ) ; Parameter parameter = null ; try { parameter = currentNode . getParameter ( parameterName ) ; } catch ( Parameter . NotFound e ) { throw new SAXException ( " Node " + currentNode . getName ( ) + " has no parameter ' " + parameterName + " ' " , e ) ; } Object value = null ; try { value = parameter . parseValue ( valueAsString ) ; } catch ( NumberFormatException e ) { throw new SAXException ( parameter . getAbsolutePath ( ) + " : could not parse value ' " + valueAsString + " ' " , e ) ; } try { parameter . setValue ( value ) ; 
private void setExpression ( String parameterName , String expression ) throws SAXException { Parameter parameter = currentNode . getParameter ( parameterName ) ; if ( parameter = = null ) throw new SAXException ( " Node " + currentNode . getName ( ) + " has no parameter ' " + parameterName + " ' " ) ; parameter . setExpression ( expression ) ; } 
public void testPersistence ( ) { NodeManager manager = new NodeManager ( ) ; Create network CanvasNetwork rootNetwork = new CanvasNetwork("root"); Network vector1 = (Network) rootNetwork.create(VectorNetwork.class); vector1.setPosition(10, 10); vector1.setRendered(); Node ellipse1 = vector1.create(EllipseNode.class); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node transform1 = vector1.create(TransformNode.class); transform1.setPosition(40, 80); transform1.setRendered(); transform1.getParameter("shape").connect(ellipse1); Write network String xmlString = rootNetwork.toXml(); Read network Network newNetwork = Network.load(manager, xmlString); TODO: Equals tests for identity. We need to correctly test this. assertEquals(rootNetwork, newNetwork); } 
public void testVersionedNodeList ( ) { TestNode tn_0_8 = new TestNode ( ) ; tn_0_8 . setVersion ( 0 , 8 ) ; TestNode tn_1_0 = new TestNode ( ) ; TestNode tn_2_0 = new TestNode ( ) ; tn_2_0 . setVersion ( 2 , 0 ) ; TestNode tn_2_1 = new TestNode ( ) ; tn_2_1 . setVersion ( 2 , 1 ) ; Setup the correct order (newest nodes come first) List<Node> orderedNodes = new ArrayList<Node>(); orderedNodes.add(tn_2_1); orderedNodes.add(tn_2_0); orderedNodes.add(tn_1_0); orderedNodes.add(tn_0_8); Add the nodes in semi-random order. NodeManager.VersionedNodeList vnl = new NodeManager.VersionedNodeList(); vnl.addNode(tn_2_0); vnl.addNode(tn_0_8); vnl.addNode(tn_1_0); vnl.addNode(tn_2_1); assertEquals(orderedNodes, vnl.getNodes()); Add the nodes in another order. vnl = new NodeManager.VersionedNodeList(); vnl.addNode(tn_0_8); vnl.addNode(tn_1_0); vnl.addNode(tn_2_0); vnl.addNode(tn_2_1); assertEquals(orderedNodes, vnl.getNodes()); assertEquals(tn_2_1, vnl.getLatestVersion()); } 
public void testBasicLoading ( ) { NodeManager m = new NodeManager ( ) ; Node = m . getNode ( " net.nodebox.node.vector.RectNode " ) ; assertNotNull ( ) ; assertTrue ( RectNode . class . isAssignableFrom ( . getClass ( ) ) ) ; } 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; Node = new RectType ( new NodeManager ( ) ) . createNode ( ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } 
public void valueChanged ( Parameter source , Object newValue ) { setValueForControl ( newValue ) ; } 
public void setMethod ( Method m ) throws NoSuchMethodException { setMethod ( m . getDeclaringClass ( ) , m . getName ( ) ) ; } 
public Node create ( NodeType nodeType ) { Node newNode = nodeType . createNode ( ) ; setUniqueNodeName ( newNode ) ; add ( newNode ) ; return newNode ; } 
public boolean process ( ProcessingContext ctx ) { TODO: this method does NOT get overridden by the different network types! boolean success = updateRenderedNode(ctx); if (success) { setOutputValue(renderedNode.getOutputValue()); } else { If there is nothing to render, set the output to a sane default. getOutputParameter().revertToDefault(); } return success; } 
public String toXml ( ) { StringBuffer xml = new StringBuffer ( ) ; Build the header xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"); xml.append("<ndbx type=\"file\" formatVersion=\"0.8\">"); toXml(xml, " "); xml.append("</ndbx>"); return xml.toString(); } 
public void setName ( String name ) throws InvalidNameException { Since the network does the rename, fireNodeChanged() will be called from the network. if (inNetwork()) { network.rename(this, name); 
public int parameterCount ( ) { return parameters . size ( ) ; } 
public Parameter getParameter ( String name ) throws NotFoundException { if ( hasParameter ( name ) ) { return parameters . get ( name ) ; 
public void setNetwork ( Network network ) throws InvalidNameException { if ( inNetwork ( ) & & this . network ! = network ) { network . remove ( this ) ; } if ( network ! = null ) { Network.add checks if this node was already added in the network, 
public Grob asGrob ( String name ) { return getParameter ( name ) . asGrob ( ) ; } 
public void setOutputValue ( Object value ) throws ValueError { outputParameter . setValue ( value ) ; } 
public boolean process ( ProcessingContext ctx ) { try { return getNodeType ( ) . process ( this , ctx ) ; 
public void toXml ( StringBuffer xml , String spaces ) { Build the node xml.append(spaces).append("<node"); xml.append(" name=\"").append(getName()).append("\""); xml.append(" type=\"").append(getNodeType().getIdentifier()).append("\""); xml.append(" version=\"").append(getNodeType().getVersionAsString()).append("\""); xml.append(" x=\"").append(getX()).append("\""); xml.append(" y=\"").append(getY()).append("\""); if (isRendered()) xml.append(" rendered=\"true\""); xml.append(">"); xml.append(spaces); xml.append(" <data>"); Build the parameter list dataToXml(xml, spaces); End the node xml.append(spaces); xml.append(" </data>"); xml.append(spaces); xml.append("</node>"); } 
public boolean matches ( NodeType . Version version ) { TODO: implement return false; } 
public boolean matches ( int major , int minor ) { return matches ( new NodeType . Version ( major , minor ) ) ; } 
public void addNodeType ( NodeType nodeType ) { NodeType . Version newVersion = nodeType . getVersion ( ) ; int i = 0 ; for ( ; i < nodeTypes . size ( ) ; i + + ) { NodeType nt = nodeTypes . get ( i ) ; if ( nt . getVersion ( ) . smallerThan ( newVersion ) ) break ; } nodeTypes . add ( i , nodeType ) ; } 
public void addNodeType ( NodeType ) { VersionedNodeTypeList nodeTypeList = nodeTypeMap . get ( . getIdentifier ( ) ) ; if ( nodeTypeList = = null ) { nodeTypeList = new VersionedNodeTypeList ( ) ; nodeTypeMap . put ( . getIdentifier ( ) , nodeTypeList ) ; } nodeTypeList . addNodeType ( ) ; } 
public NodeType getNodeType ( String identifier ) throws NotFoundException { VersionedNodeTypeList nodeTypeList = nodeTypeMap . get ( identifier ) ; if ( nodeTypeList = = null ) throw new NotFoundException ( this , identifier , " The node manager cannot find node type ' " + identifier + " '. " ) ; return nodeTypeList . getLatestVersion ( ) ; } 
public static void validateName ( String name ) throws InvalidNameException { Matcher m1 = NODE_NAME_PATTERN . matcher ( name ) ; Matcher m2 = DOUBLE_UNDERSCORE_PATTERN . matcher ( name ) ; Matcher m3 = RESERVED_WORD_PATTERN . matcher ( name ) ; if ( ! m1 . matches ( ) ) { throw new InvalidNameException ( null , name , " Name does contain other characters than a-z0-9 or underscore, or is longer than 29 characters. " ) ; } if ( m2 . matches ( ) ) { throw new InvalidNameException ( null , name , " Names starting with double underscore are reserved for internal use. " ) ; } if ( m3 . matches ( ) ) { throw new InvalidNameException ( null , name , " Names cannot be a reserved word (network, node, root). " ) ; 
public ParameterType addParameterType ( String name , ParameterType . Type type ) { ParameterType p = new ParameterType ( this , name , type ) ; parameterTypes . add ( p ) ; return p ; } 
public ParameterType getParameterType ( String name ) throws NotFoundException { for ( ParameterType pt : parameterTypes ) { if ( pt . getName ( ) . equals ( name ) ) return pt ; } throw new NotFoundException ( this , name , " Node type " + getIdentifier ( ) + " does not have a parameter type ' " + name + " ' " ) ; } 
public boolean hasParameterType ( String name ) { for ( ParameterType pt : parameterTypes ) { if ( pt . getName ( ) . equals ( name ) ) return true ; } return false ; } 
public void setValue ( Object value ) throws ValueError { getParameterType ( ) . validate ( value ) ; this . value = value ; fireValueChanged ( ) ; } 
public boolean isPrimitive ( ) { return parameterType . isPrimitive ( ) ; } 
public void boundingChanged ( ParameterType source ) { if ( source . getBoundingMethod ( ) = = ParameterType . BoundingMethod . HARD ) clampToBounds ( ) ; 
public Grob asGrob ( ) { if ( getCoreType ( ) = = ParameterType . CoreType . GROB_SHAPE | | getCoreType ( ) = = ParameterType . CoreType . GROB_CANVAS 
public void setValue ( Object value ) throws ValueError { if ( isConnected ( ) ) { throw new ValueError ( " The parameter is connected. " ) ; } if ( hasExpression ( ) ) { throw new ValueError ( " The parameter has an expression set. " ) ; } parameterType . validate ( value ) ; this . value = value ; fireValueChanged ( ) ; } 
private void clearDependencies ( ) { for ( Parameter p : dependencies ) { p . removeDependent ( this ) ; } dependencies . clear ( ) ; } 
private void addDependent ( Parameter parameter ) { assert ( ! dependents . contains ( parameter ) ) ; dependents . add ( this ) ; } 
private void removeDependent ( Parameter parameter ) { assert ( dependents . contains ( parameter ) ) ; dependents . remove ( this ) ; } 
protected void fireValueChanged ( ) { for ( Parameter p : dependents ) { p . dependencyValueChanged ( this ) ; } for ( ParameterDataListener l : listeners ) { l . valueChanged ( this , value ) ; } getNode ( ) . markDirty ( ) ; } 
private void dependencyValueChanged ( Parameter parameter ) { getNode ( ) . markDirty ( ) ; } 
public void update ( ProcessingContext ctx ) { if ( isConnected ( ) ) { connection . getOutputNode ( ) . update ( ctx ) ; Object outputValue = connection . getOutputNode ( ) . getOutputValue ( ) ; validate ( outputValue ) ; value = outputValue ; } if ( hasExpression ( ) ) { for ( Connection c : expressionConnections ) { 
public void nullAllowedChanged ( ParameterType source ) { if ( ! parameterType . isNullAllowed ( ) & & value = = null ) { value = parameterType . getDefaultValue ( ) ; 
public void revertToDefault ( ) { this . value = parameterType . getDefaultValue ( ) ; fireValueChanged ( ) ; } 
public Object parseValue ( String valueAsString ) { return getParameterType ( ) . parseValue ( valueAsString ) ; } 
public void validate ( Object value ) { getParameterType ( ) . validate ( value ) ; } 
public void addDataListener ( ParameterDataListener listener ) { listeners . add ( listener ) ; } 
public void removeDataListener ( ParameterDataListener listener ) { listeners . remove ( listener ) ; } 
public void addMenuItem ( String key , String label ) { menuItems . add ( new MenuEntry ( key , label ) ) ; TODO: fireMenuChanged(); 
public void addParameterTypeListener ( ParameterTypeListener l ) { listeners . add ( ParameterTypeListener . class , l ) ; } 
public void removeParameterTypeListener ( ParameterTypeListener l ) { listeners . remove ( ParameterTypeListener . class , l ) ; } 
private void fireTypeChanged ( ) { assert ( listeners ! = null ) ; for ( EventListener l : listeners . getListeners ( ParameterTypeListener . class ) ) ( ( ParameterTypeListener ) l ) . typeChanged ( this ) ; 
private void fireBoundingChanged ( ) { assert ( listeners ! = null ) ; for ( EventListener l : listeners . getListeners ( ParameterTypeListener . class ) ) ( ( ParameterTypeListener ) l ) . boundingChanged ( this ) ; 
private void fireDisplayLevelChanged ( ) { assert ( listeners ! = null ) ; for ( EventListener l : listeners . getListeners ( ParameterTypeListener . class ) ) ( ( ParameterTypeListener ) l ) . displayLevelChanged ( this ) ; 
private void fireNullAllowedChanged ( ) { assert ( listeners ! = null ) ; for ( EventListener l : listeners . getListeners ( ParameterTypeListener . class ) ) ( ( ParameterTypeListener ) l ) . nullAllowedChanged ( this ) ; 
public ParameterType clone ( NodeType nodeType ) { ParameterType newType = new ParameterType ( nodeType , getName ( ) , getType ( ) , getDirection ( ) ) ; newType . label = getLabel ( ) ; newType . description = getDescription ( ) ; TODO: Does this actually make copies of the values? check! newType.defaultValue = getDefaultValue(); newType.nullAllowed = isNullAllowed(); newType.boundingMethod = getBoundingMethod(); TODO: Does this actually make copies of the values? check! newType.minimumValue = getMinimumValue(); newType.maximumValue = getMaximumValue(); newType.displayLevel = getDisplayLevel(); newType.menuItems = new ArrayList<MenuEntry>(menuItems); return newType; } 
public void typeChanged ( ParameterType source ) ; public void nullAllowedChanged ( ParameterType source ) ; } 
public void boundingChanged ( ParameterType source ) ; public void nullAllowedChanged ( ParameterType source ) ; } 
public void displayLevelChanged ( ParameterType source ) ; public void nullAllowedChanged ( ParameterType source ) ; } 
private Node lookupNode ( Attributes attributes ) throws SAXException { NodeType nodeType ; Node newNode ; String identifier = attributes . getValue ( " type " ) ; String version = attributes . getValue ( " version " ) ; try { if ( version = = null ) { nodeType = nodeManager . getNodeType ( identifier ) ; } else { nodeType = nodeManager . getNodeType ( identifier , new NodeType . Version ( version ) ) ; } } catch ( NotFoundException e ) { throw new SAXException ( " A node with type " + identifier + " and version " + version + " does not exist. " ) ; } newNode = nodeType . createNode ( ) ; String name = attributes . getValue ( " name " ) ; if ( name ! = null ) { newNode . setName ( name ) ; } String x = attributes . getValue ( " x " ) ; if ( x ! = null ) { try { newNode . setX ( Double . parseDouble ( x ) ) ; } catch ( NumberFormatException e ) { logger . log ( Level . WARNING , " Could not parse x attribute for node " + name + " [ " + identifier + " ] value= " + x ) ; } } String y = attributes . getValue ( " y " ) ; if ( y ! = null ) { try { newNode . setY ( Double . parseDouble ( y ) ) ; } catch ( NumberFormatException e ) { logger . log ( Level . WARNING , " Could not parse y attribute for node " + name + " [ " + identifier + " ] value= " + y ) ; } } return newNode ; } 
private void setValue ( String parameterName , String valueAsString ) throws SAXException { if ( currentNode = = null ) throw new SAXException ( " There is no current node. " ) ; Parameter parameter ; try { parameter = currentNode . getParameter ( parameterName ) ; } catch ( NotFoundException e ) { throw new SAXException ( " Node " + currentNode . getName ( ) + " has no parameter ' " + parameterName + " ' " , e ) ; } Object value ; try { value = parameter . parseValue ( valueAsString ) ; } catch ( NumberFormatException e ) { throw new SAXException ( parameter . getAbsolutePath ( ) + " : could not parse value ' " + valueAsString + " ' " , e ) ; } try { parameter . setValue ( value ) ; 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Canvas c = new Canvas ( asFloat ( " width " ) , asFloat ( " height " ) ) ; Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { c . add ( ( Grob ) outputValue ) ; setOutputValue ( c ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public boolean process ( Node node , ProcessingContext ctx ) { throw new AssertionError ( " Nodes created by CanvasNetworkType should not reach this point. " ) ; } 
public Node createNode ( ) { return new CanvasNetworkExtender ( this ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . asGrob ( " template " ) ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) ; double sy = node . asFloat ( " sy " ) ; if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } node.setOutputValue(outputGroup); return true; } 
private void doCopy ( Group outputGroup , Grob shape , double startx , double starty , int copies , double tx , double ty , double r , double sx , double sy ) { Set up the transform Transform t = new Transform(); t.translate(startx, starty); Loop through the number of copies for (int i = copies; i > 0; i--) { 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( node . asColor ( " fill " ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; p . addEllipse ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; g . add ( p ) ; node . setOutputValue ( g ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( node . asColor ( " fill " ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; p . addRect ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; g . add ( p ) ; node . setOutputValue ( g ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Grob g = node . asGrob ( " shape " ) ; Grob outGrob = g . clone ( ) ; Transform = new Transform ( ) ; . translate ( node . asFloat ( " tx " ) , node . asFloat ( " ty " ) ) ; . rotate ( node . asFloat ( " r " ) ) ; . scale ( node . asFloat ( " sx " ) , node . asFloat ( " sy " ) ) ; outGrob . appendTransform ( ) ; node . setOutputValue ( outGrob ) ; return true ; } 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g . translate ( asFloat ( " tx " ) , asFloat ( " ty " ) ) ; g . rotate ( asFloat ( " r " ) ) ; g . scale ( asFloat ( " sx " ) , asFloat ( " sy " ) ) ; setOutputValue ( g ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public Node createNode ( ) { return new VectorNetworkExtender ( this ) ; } 
public void testDirty ( ) { Node ng = numberType . createNode ( ) ; assertTrue ( ng . isDirty ( ) ) ; ng . update ( ) ; assertFalse ( ng . isDirty ( ) ) ; assertEquals ( 0 , ng . getOutputValue ( ) ) ; ng . set ( " value " , 12 ) ; assertTrue ( ng . isDirty ( ) ) ; Asking for the output value doesn't update the node implicitly. assertEquals(0, ng.getOutputValue()); You have to explicitly update the node to get the new output value. ng.update(); assertFalse(ng.isDirty()); assertEquals(12, ng.getOutputValue()); } 
public void testConnect ( ) { Node ng = numberType . createNode ( ) ; Node m = multiplyType . createNode ( ) ; assertFalse ( m . getParameter ( " v1 " ) . isConnected ( ) ) ; assertFalse ( m . getParameter ( " v1 " ) . isConnectedTo ( ng ) ) ; assertFalse ( ng . isOutputConnected ( ) ) ; assertFalse ( ng . isOutputConnectedTo ( m ) ) ; assertFalse ( ng . isOutputConnectedTo ( m . getParameter ( " v1 " ) ) ) ; assertTrue ( m . getParameter ( " v1 " ) . canConnectTo ( ng ) ) ; assertTrue ( m . getParameter ( " v2 " ) . canConnectTo ( ng ) ) ; assertFalse ( m . getParameter ( " somestring " ) . canConnectTo ( ng ) ) ; Connection conn = m . getParameter ( " v1 " ) . connect ( ng ) ; assertTrue ( m . getParameter ( " v1 " ) . isConnected ( ) ) ; assertTrue ( m . getParameter ( " v1 " ) . isConnectedTo ( ng ) ) ; assertTrue ( ng . isOutputConnected ( ) ) ; assertTrue ( ng . isOutputConnectedTo ( m ) ) ; assertTrue ( ng . isOutputConnectedTo ( m . getParameter ( " v1 " ) ) ) ; assertEquals ( m . getParameter ( " v1 " ) , conn . getInputParameter ( ) ) ; assertEquals ( ng . getOutputParameter ( ) , conn . getOutputParameter ( ) ) ; assertEquals ( m , conn . getInputNode ( ) ) ; assertEquals ( ng , conn . getOutputNode ( ) ) ; assertConnectionError ( m , " somestring " , ng , " Somestring is of the wrong type and should not be connectable to NumberGenerator's output. " ) ; } 
public void testCycles ( ) { Node ng = numberType . createNode ( ) ; assertConnectionError(ng, "number", ng, "Nodes cannot connect to themselves."); 
public void testDirtyPropagation ( ) { Node ng = numberType . createNode ( ) ; Node m = multiplyType . createNode ( ) ; Nodes start out dirty assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating makes them clean ng.update(); m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Connecting the multiplier to another node makes it dirty. The output node doesn't become dirty. m.getParameter("v1").connect(ng); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(ng.isDirty()); This shouldn't have changed. assertFalse(m.isDirty()); A change to the upstream node should make downstream nodes dirty. ng.set("value", 12); assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating the downstream node should make all upstreams clean, because their output values are needed to calculate the downstream. m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Changes to the downstream node don't affect upstreams. m.set("v2", 1); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); Disconnecting makes the downstream dirty. m.getParameter("v1").disconnect(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); Check is disconnected nodes still propagate. ng.update(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); ng.set("value", 13); assertTrue(ng.isDirty()); assertFalse(m.isDirty()); } 
public void testValuePropagation ( ) { Node ng = numberType . createNode ( ) ; Node m = multiplyType . createNode ( ) ; m . set ( " v2 " , 2 ) ; m . getParameter ( " v1 " ) . connect ( ng ) ; assertEquals ( 0 , m . getOutputValue ( ) ) ; ng . set ( " value " , 3 ) ; assertTrue ( m . isDirty ( ) ) ; assertEquals ( 0 , m . getOutputValue ( ) ) ; Updating the NumberGenerator node has no effect on the multiplier node. ng.update(); assertTrue(m.isDirty()); assertEquals(0, m.getOutputValue()); m.update(); assertFalse(m.isDirty()); assertEquals(6, m.getOutputValue()); Test if value stops propagating after disconnection. m.getParameter("v1").disconnect(); assertTrue(m.isDirty()); assertFalse(ng.isDirty()); ng.set("value", 3); m.update(); assertEquals(0, m.getOutputValue()); } 
public void testDisconnect ( ) { Node ng = numberType . createNode ( ) ; Node m = multiplyType . createNode ( ) ; m . set ( " v2 " , 2 ) ; ng . set ( " value " , 5 ) ; m . getParameter ( " v1 " ) . connect ( ng ) ; assertTrue ( m . getParameter ( " v1 " ) . isConnected ( ) ) ; assertTrue ( ng . isOutputConnected ( ) ) ; m . update ( ) ; assertEquals ( 5 , m . asInt ( " v1 " ) ) ; assertEquals ( 10 , m . getOutputValue ( ) ) ; m . getParameter ( " v1 " ) . disconnect ( ) ; assertTrue ( m . isDirty ( ) ) ; assertFalse ( ng . isDirty ( ) ) ; assertFalse ( m . getParameter ( " v1 " ) . isConnected ( ) ) ; assertFalse ( ng . isOutputConnected ( ) ) ; Numbers reverts to default after disconnection m.update(); assertEquals(0, m.getOutputValue()); } 
public void testSimple ( ) { Node = numberType . createNode ( ) ; Parameter pValue = . getParameter ( " value " ) ; Expression e = new Expression ( pValue , " 1 + 2 " ) ; assertEquals ( 3 , e . asInt ( ) ) ; } 
public void testNodeLocal ( ) { Node multiply = multiplyType . createNode ( ) ; Parameter p1 = multiply . getParameter ( " v1 " ) ; Parameter p2 = multiply . getParameter ( " v2 " ) ; p2 . setValue ( 12 ) ; assertExpressionEquals ( 12 , p1 , " v2 " ) ; } 
public void xtestCycles ( ) { Node = numberType . createNode ( ) ; Parameter pValue = . getParameter ( " value " ) ; assertExpressionInvalid ( pValue , " value " ) ; } 
public void testNetworkLocal ( ) { NodeType netType = testNetworkType . clone ( ) ; ParameterType pn = netType . addParameterType ( " pn " , ParameterType . Type . INT ) ; pn . setDefaultValue ( 33 ) ; Network net = ( Network ) netType . createNode ( ) ; Node number1 = net . create ( numberType ) ; Parameter pValue1 = number1 . getParameter ( " value " ) ; pValue1 . set ( 84 ) ; assertEquals ( " number1 " , number1 . getName ( ) ) ; Parameter p1 = test1.addParameter("p1", Parameter.Type.INT); Node number2 = net.create(numberType); assertEquals("number2", number2.getName()); Parameter p2 = number2.addParameter("p2", Parameter.Type.INT); Parameter pValue2 = number2.getParameter("value"); pValue2.set(12); Trying to retrieve the value of number2 by just using the expression "value" is impossible, since it will retrieve the value parameter of number1. assertExpressionEquals(84, pValue1, "value"); Access p2 through the node name. assertExpressionEquals(12, pValue1, "number2.value"); Access p2 through the network. assertExpressionEquals(12, pValue1, "network.number2.value"); Access the pn Parameter on the network. assertExpressionEquals(33, pValue1, "network.pn"); } 
protected void setUp ( ) throws Exception { manager = new TestManager ( ) ; testNetworkType = manager . getNodeType ( " net.nodebox.node.test.network " ) ; numberType = manager . getNodeType ( " net.nodebox.node.test.number " ) ; } 
public void testCreate ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node testNode = net . create ( numberType ) ; assertTrue ( net . contains ( testNode ) ) ; assertTrue ( testNode . inNetwork ( ) ) ; assertEquals ( net , testNode . getNetwork ( ) ) ; } 
public void testDataEvent ( ) { TestDataListener l = new TestDataListener ( ) ; Network net = ( Network ) testNetworkType . createNode ( ) ; net . addNetworkDataListener ( l ) ; Node n1 = net . create ( numberType ) ; Node n2 = net . create ( numberType ) ; assertEquals ( 0 , l . dirtyCounter ) ; assertEquals ( 0 , l . updatedCounter ) ; n1 . setRendered ( ) ; Network was already dirty from the start, counter is not updated. assertEquals(0, l.dirtyCounter); assertEquals(0, l.updatedCounter); net.update(); assertEquals(0, l.dirtyCounter); assertEquals(1, l.updatedCounter); n2.setRendered(); assertEquals(1, l.dirtyCounter); assertEquals(1, l.updatedCounter); net.update(); assertEquals(1, l.dirtyCounter); assertEquals(2, l.updatedCounter); } 
public void testBasicProcessing ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node v1 = net . create ( numberType ) ; v1 . setValue ( " value " , 42 ) ; net . update ( ) ; assertTrue ( net . hasError ( ) ) ; assertEquals ( 0 , net . getOutputValue ( ) ) ; v1 . setRendered ( ) ; net . update ( ) ; assertFalse ( net . hasError ( ) ) ; assertEquals ( 42 , net . getOutputValue ( ) ) ; } 
public void testPersistence ( ) { NodeManager manager = new NodeManager ( ) ; Create network Network rootNetwork = (Network) manager.getNodeType("net.nodebox.node.canvas.network").createNode(); Network vector1 = (Network) rootNetwork.create(manager.getNodeType("net.nodebox.node.vector.network")); vector1.setPosition(10, 10); vector1.setRendered(); Node ellipse1 = vector1.create(manager.getNodeType("net.nodebox.node.vector.ellipse")); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node transform1 = vector1.create(manager.getNodeType("net.nodebox.node.vector.transform")); transform1.setPosition(40, 80); transform1.setRendered(); transform1.getParameter("shape").connect(ellipse1); Write network String xmlString = rootNetwork.toXml(); System.out.println("xmlString = " + xmlString); Read network Network newNetwork = Network.load(manager, xmlString); 
public boolean process ( Node node , ProcessingContext ctx ) { return false ; } 
public void testVersionedNodeList ( ) { NodeManager m = new NodeManager ( ) ; TestNodeType tn_0_8 = new TestNodeType ( m ) ; tn_0_8 . setVersion ( 0 , 8 ) ; TestNodeType tn_1_0 = new TestNodeType ( m ) ; TestNodeType tn_2_0 = new TestNodeType ( m ) ; tn_2_0 . setVersion ( 2 , 0 ) ; TestNodeType tn_2_1 = new TestNodeType ( m ) ; tn_2_1 . setVersion ( 2 , 1 ) ; Setup the correct order (newest nodes come first) List<NodeType> orderedNodes = new ArrayList<NodeType>(); orderedNodes.add(tn_2_1); orderedNodes.add(tn_2_0); orderedNodes.add(tn_1_0); orderedNodes.add(tn_0_8); Add the nodes in semi-random order. NodeManager.VersionedNodeTypeList vnl = new NodeManager.VersionedNodeTypeList(); vnl.addNodeType(tn_2_0); vnl.addNodeType(tn_0_8); vnl.addNodeType(tn_1_0); vnl.addNodeType(tn_2_1); assertEquals(orderedNodes, vnl.getNodeTypes()); Add the nodes in another order. vnl = new NodeManager.VersionedNodeTypeList(); vnl.addNodeType(tn_0_8); vnl.addNodeType(tn_1_0); vnl.addNodeType(tn_2_0); vnl.addNodeType(tn_2_1); assertEquals(orderedNodes, vnl.getNodeTypes()); assertEquals(tn_2_1, vnl.getLatestVersion()); } 
public void testBasicLoading ( ) { NodeManager m = new NodeManager ( ) ; NodeType = m . getNodeType ( " net.nodebox.node.vector.rect " ) ; assertNotNull ( ) ; assertTrue ( RectType . class . isAssignableFrom ( . getClass ( ) ) ) ; } 
public void testNaming ( ) { Node = numberType . createNode ( ) ; assertEquals ( . getDefaultName ( ) , " number " ) ; assertEquals ( . getName ( ) , " number " ) ; } 
public void testParameters ( ) { Node = addType . createNode ( ) ; try { . getParameter ( " p1 " ) ; fail ( " Should have thrown NotFoundException " ) ; } catch ( NotFoundException e ) { } assertTrue ( . hasParameter ( " v1 " ) ) ; try { . getParameter ( " v1 " ) ; } catch ( NotFoundException e ) { fail ( " Should not have thrown NotFoundException " ) ; } try { . getParameter ( " x " ) ; 
public void testNodeNaming ( ) { Node = numberType . createNode ( ) ; checkInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; checkInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; checkInvalidName ( , " root " , " names can not be one of the reserved words. " ) ; checkInvalidName ( , " network " , " names can not be one of the reserved words. " ) ; checkInvalidName ( , " UPPERCASE " , " names cannot be in uppercase. " ) ; checkInvalidName ( , " uPpercase " , " names cannot contain uppercase letters " ) ; checkInvalidName ( , " __reserved " , " names cannot start with double underscores " ) ; checkInvalidName ( , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( , " " , " names cannot be empty " ) ; checkInvalidName ( , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; checkValidName ( , " radius " ) ; checkValidName ( , " _test " ) ; checkValidName ( , " _ " ) ; checkValidName ( , " _1234 " ) ; checkValidName ( , " a1234 " ) ; checkValidName ( , " node1 " ) ; } 
public void testDirty ( ) { Node = numberType . createNode ( ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . set ( " value " , 12 ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . getParameter ( " value " ) . set ( 13 ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; manager = new TestManager ( ) ; numberType = manager . getNodeType ( " net.nodebox.node.test.number " ) ; negateType = manager . getNodeType ( " net.nodebox.node.test.negate " ) ; addType = manager . getNodeType ( " net.nodebox.node.test.add " ) ; multiplyType = manager . getNodeType ( " net.nodebox.node.test.multiply " ) ; testNetworkType = manager . getNodeType ( " net.nodebox.node.test.network " ) ; } 
public void testDummy ( ) { This needs to be here, otherwise jUnit complains that there are no tests in this class. }} 
protected void setUp ( ) throws Exception { manager = new TestManager ( ) ; numberType = manager . getNodeType ( " net.nodebox.node.test.number " ) ; negateType = manager . getNodeType ( " net.nodebox.node.test.negate " ) ; addType = manager . getNodeType ( " net.nodebox.node.test.add " ) ; } 
public void testCorrectType ( ) { Node number = numberType . createNode ( ) ; ParameterType valueType = number . getParameter ( " value " ) . getParameterType ( ) ; assertEquals ( ParameterType . Type . INT , valueType . getType ( ) ) ; assertEquals ( ParameterType . CoreType . INT , valueType . getCoreType ( ) ) ; } 
public void testDirectValue ( ) { Node num1 = numberType . createNode ( ) ; assertEquals ( 0 , num1 . getOutputValue ( ) ) ; Node num2 = numberType . createNode ( ) ; num2 . setValue ( " value " , 12 ) ; assertEquals ( 0 , num2 . getOutputValue ( ) ) ; assertFalse ( num2 . getParameter ( " value " ) . hasExpression ( ) ) ; assertFalse ( num2 . getParameter ( " value " ) . isConnected ( ) ) ; } 
public void testNaming ( ) { NodeType nt = new TestManager . Number ( null ) ; checkInvalidName ( nt , " 1234 " , " names cannot start with a digit. " ) ; checkInvalidName ( nt , " node " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " root " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " network " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " UPPERCASE " , " names cannot be in uppercase. " ) ; checkInvalidName ( nt , " uPpercase " , " names cannot contain uppercase letters " ) ; checkInvalidName ( nt , " __reserved " , " names cannot start with double underscores " ) ; checkInvalidName ( nt , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( nt , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( nt , " " , " names cannot be empty " ) ; checkInvalidName ( nt , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; checkValidName ( nt , " radius " ) ; checkValidName ( nt , " _test " ) ; checkValidName ( nt , " _ " ) ; checkValidName ( nt , " _1234 " ) ; checkValidName ( nt , " a1234 " ) ; checkInvalidName ( nt , " radius " , " parameter type names must be unique for the node type " ) ; } 
private void checkInvalidName ( NodeType nt , String newName , String reason ) { try { nt . addParameterType ( newName , ParameterType . Type . INT ) ; 
private void checkValidName ( NodeType nt , String newName ) { try { nt . addParameterType ( newName , ParameterType . Type . INT ) ; 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( process ( node . asInt ( " value " ) ) ) ; return true ; } 
public abstract int process ( int value ) ; } public static abstract class Binary extends NodeType { public Binary ( NodeManager manager , String identifier ) { super ( manager , identifier , ParameterType . Type . INT ) ; addParameterType ( " v1 " , ParameterType . Type . INT ) ; addParameterType ( " v2 " , ParameterType . Type . INT ) ; } public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( process ( node . asInt ( " v1 " ) , node . asInt ( " v2 " ) ) ) ; return true ; } public abstract int process ( int v1 , int v2 ) ; } public static class Number extends Unary { public Number ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.network " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestManager ( ) { addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( process ( node . asInt ( " v1 " ) , node . asInt ( " v2 " ) ) ) ; return true ; } 
public abstract int process ( int v1 , int v2 ) ; } public static class Number extends Unary { public Number ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeManager manager ) { super ( manager , " net.nodebox.node.test.network " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestManager ( ) { addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } } 
public int process ( int value ) { return value ; } 
public int process ( int v1 , int v2 ) { return v1 + v2 ; } 
public int process ( int v1 , int v2 ) { return v1 * v2 ; } 
public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } 
public Node createNode ( ) { return new Network ( this ) ; } 
public void testType ( ) { NodeType canvasNetworkType = manager . getNodeType ( " net.nodebox.node.canvas.network " ) ; Node = canvasNetworkType . createNode ( ) ; Assert . assertEquals ( ParameterType . Type . GROB_CANVAS , . getOutputParameter ( ) . getType ( ) ) ; } 
public void testBasicCopy ( ) { Node rect = manager . getNodeType ( " net.nodebox.node.vector.rect " ) . createNode ( ) ; Node copy = manager . getNodeType ( " net.nodebox.node.vector.copy " ) . createNode ( ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , g . getBounds ( ) ) ; copy . setValue ( " ty " , 100.0 ) ; copy . setValue ( " copies " , 5 ) ; copy . update ( ) ; g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 500 ) , g . getBounds ( ) ) ; } 
public void testRectNode ( ) { Node r = manager . getNodeType ( " net.nodebox.node.vector.rect " ) . createNode ( ) ; r . update ( ) ; Object outputValue = r . getOutputValue ( ) ; if ( ! ( outputValue instanceof Group ) ) fail ( " Output value is not a Group, but " + outputValue ) ; Group group = ( Group ) outputValue ; assertEquals ( 1 , group . size ( ) ) ; BezierPath p = ( BezierPath ) group . get ( 0 ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , p . getBounds ( ) ) ; } 
public void testType ( ) { NodeType vectorNetworkType = manager . getNodeType ( " net.nodebox.node.vector.network " ) ; Node = vectorNetworkType . createNode ( ) ; assertEquals ( ParameterType . Type . GROB_VECTOR , . getOutputParameter ( ) . getType ( ) ) ; } 
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( ! ( obj instanceof BezierPath ) ) return false ; BezierPath other = ( BezierPath ) obj ; return elements . equals ( other . elements ) & & fillColor . equals ( other . fillColor ) 
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( ! ( obj instanceof Canvas ) ) return false ; Canvas other = ( Canvas ) obj ; return width = = other . width & & height = = other . height 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof Color ) ) return false ; Color other = ( Color ) obj ; return r = = other . r & & g = = other . g & & b = = other . b & & a = = other . a ; } 
public abstract Grob clone ( ) ; @Override public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( ! ( obj instanceof Grob ) ) return false ; Grob other = ( Grob ) obj ; return transform . equals ( other . transform ) ; } } 
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( ! ( obj instanceof Grob ) ) return false ; Grob other = ( Grob ) obj ; return transform . equals ( other . transform ) ; } 
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( ! ( obj instanceof Group ) ) return false ; Group other = ( Group ) obj ; return grobs . equals ( other . grobs ) & & super . equals ( other ) ; 
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( ! ( obj instanceof Image ) ) return false ; Image other = ( Image ) obj ; return this . x = = other . x & & this . y = = other . y 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof Transform ) ) return false ; return getAffineTransform ( ) . equals ( ( ( Transform ) obj ) . getAffineTransform ( ) ) ; } 
public void testDefaultValue ( ) { NodeType customType = numberType . clone ( ) ; ParameterType ptInt = customType . addParameterType ( " int " , ParameterType . Type . INT ) ; ParameterType ptFloat = customType . addParameterType ( " float " , ParameterType . Type . FLOAT ) ; ParameterType ptString = customType . addParameterType ( " string " , ParameterType . Type . STRING ) ; ParameterType ptColor = customType . addParameterType ( " color " , ParameterType . Type . COLOR ) ; ParameterType ptCanvas = customType . addParameterType ( " canvas " , ParameterType . Type . GROB_CANVAS ) ; assertEquals ( 0 , ptInt . getDefaultValue ( ) ) ; assertEquals ( 0.0 , ptFloat . getDefaultValue ( ) ) ; assertEquals ( " " , ptString . getDefaultValue ( ) ) ; assertEquals ( new Color ( ) , ptColor . getDefaultValue ( ) ) ; assertEquals ( new Canvas ( ) , ptCanvas . getDefaultValue ( ) ) ; } 
public void testDefaultValue ( ) { NodeType customType = numberType . clone ( ) ; ParameterType ptInt = customType . addParameterType ( " int " , ParameterType . Type . INT ) ; ParameterType ptFloat = customType . addParameterType ( " float " , ParameterType . Type . FLOAT ) ; ParameterType ptString = customType . addParameterType ( " string " , ParameterType . Type . STRING ) ; ParameterType ptColor = customType . addParameterType ( " color " , ParameterType . Type . COLOR ) ; ParameterType ptCanvas = customType . addParameterType ( " canvas " , ParameterType . Type . GROB_CANVAS ) ; ParameterType ptVector = customType . addParameterType ( " vector " , ParameterType . Type . GROB_VECTOR ) ; ParameterType ptImage = customType . addParameterType ( " image " , ParameterType . Type . GROB_IMAGE ) ; assertEquals ( 0 , ptInt . getDefaultValue ( ) ) ; assertEquals ( 0.0 , ptFloat . getDefaultValue ( ) ) ; assertEquals ( " " , ptString . getDefaultValue ( ) ) ; assertEquals ( new Color ( ) , ptColor . getDefaultValue ( ) ) ; assertEquals ( new Canvas ( ) , ptCanvas . getDefaultValue ( ) ) ; assertEquals ( new Group ( ) , ptVector . getDefaultValue ( ) ) ; assertEquals ( new Image ( ) , ptImage . getDefaultValue ( ) ) ; } 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Canvas c = new Canvas ( asFloat ( " width " ) , asFloat ( " height " ) ) ; Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g = g . clone ( ) ; c . add ( g ) ; setOutputValue ( c ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g = g . clone ( ) ; g . translate ( asFloat ( " tx " ) , asFloat ( " ty " ) ) ; g . rotate ( asFloat ( " r " ) ) ; g . scale ( asFloat ( " sx " ) , asFloat ( " sy " ) ) ; setOutputValue ( g ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public void testPersistence ( ) { Create network Network rootNetwork = (Network) manager.getNodeType("net.nodebox.node.canvas.network").createNode(); Network vector1 = (Network) rootNetwork.create(manager.getNodeType("net.nodebox.node.vector.network")); vector1.setPosition(10, 10); vector1.setRendered(); Node ellipse1 = vector1.create(manager.getNodeType("net.nodebox.node.vector.ellipse")); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node transform1 = vector1.create(manager.getNodeType("net.nodebox.node.vector.transform")); transform1.setPosition(40, 80); transform1.setRendered(); transform1.getParameter("shape").connect(ellipse1); Write network String xmlString = rootNetwork.toXml(); Read network Network newNetwork = Network.load(manager, xmlString); 
public void testCopy ( ) { Network vector1 = ( Network ) manager . getNodeType ( " net.nodebox.node.vector.network " ) . createNode ( ) ; Node ellipse1 = vector1 . create ( manager . getNodeType ( " net.nodebox.node.vector.rect " ) ) ; ellipse1 . setRendered ( ) ; vector1 . update ( ) ; assertFalse ( vector1 . getOutputValue ( ) = = ellipse1 . getOutputValue ( ) ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . getParameter ( " template " ) . isConnected ( ) ? node . asGrob ( " template " ) : null ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) ; double sy = node . asFloat ( " sy " ) ; if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } node.setOutputValue(outputGroup); return true; } 
public void testValidate ( ) { NodeType customType = numberType . clone ( ) ; ParameterType ptFloat = customType . addParameterType ( " float " , ParameterType . Type . FLOAT ) ; assertInvalidValue ( ptFloat , " A " ) ; assertInvalidValue ( ptFloat , new Color ( ) ) ; assertInvalidValue ( ptFloat , new Canvas ( ) ) ; assertValidValue ( ptFloat , 1.0 ) ; ParameterType ptColor = customType . addParameterType ( " color " , ParameterType . Type . COLOR ) ; assertInvalidValue ( ptColor , " A " ) ; assertInvalidValue ( ptColor , 2 ) ; assertValidValue ( ptColor , new Color ( ) ) ; Toggle has a hard bounded range between 0 and 1. ParameterType ptToggle = customType.addParameterType("toggle", ParameterType.Type.TOGGLE); assertInvalidValue(ptToggle, "A"); assertInvalidValue(ptToggle, -1); assertInvalidValue(ptToggle, 100); assertValidValue(ptToggle, 0); assertValidValue(ptToggle, 1); } 
private void assertValidValue ( ParameterType pt , Object value ) { try { pt . validate ( value ) ; 
private void assertInvalidValue ( ParameterType pt , Object value ) { try { pt . validate ( value ) ; 
public void rotate ( double degrees ) { double radians = degrees * Math . PI / 180 ; affineTransform . rotate ( radians ) ; } 
public void rotateRadians ( double radians ) { affineTransform . rotate ( radians ) ; } 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Canvas c = new Canvas ( asFloat ( " width " ) , asFloat ( " height " ) ) ; Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g = g . clone ( ) ; c . add ( g ) ; setOutputValue ( c ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public Node createNode ( ) { return new CanvasNetwork ( this ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { network.update(ctx); return true; } 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g = g . clone ( ) ; g . translate ( asFloat ( " tx " ) , asFloat ( " ty " ) ) ; g . rotate ( asFloat ( " r " ) ) ; g . scale ( asFloat ( " sx " ) , asFloat ( " sy " ) ) ; setOutputValue ( g ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public Node createNode ( ) { return new VectorNetwork ( this ) ; } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("net.nodebox.node.vector.network").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("net.nodebox.node.vector.rect")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); }} 
public void connectionAdded ( Network source , Connection connection ) { connectionLayer . repaint ( ) ; } 
public void connectionRemoved ( Network source , Connection connection ) { connectionLayer . repaint ( ) ; } 
protected void paintBorder ( Graphics2D g2 ) { Color borderColor ; if ( connectTarget = = this ) { borderColor = Theme . getInstance ( ) . getBorderHighlightColor ( ) ; } else if ( selected ) { borderColor = Theme . getInstance ( ) . getActionColor ( ) ; } else { borderColor = Color . BLACK ; } g2 . setColor ( borderColor ) ; int x = ( int ) getX ( ) ; int y = ( int ) getY ( ) ; int width = ( int ) getWidth ( ) ; int height = ( int ) getHeight ( ) ; g2 . drawRect ( x , y , width - 1 , height - 1 ) ; g2.setColor(new Color(88, 87, 96)); 
public void mouseEntered ( PInputEvent e ) { if ( isConnecting ) { System . out . println ( " entered " + NodeView . this . getNode ( ) . getName ( ) ) ; 
public void mouseExited ( PInputEvent e ) { if ( isConnecting ) { System . out . println ( " exited " + NodeView . this . getNode ( ) . getName ( ) ) ; 
public void mouseDragged ( PInputEvent e ) { if ( isDragging ) { Point2D pt = e . getPosition ( ) ; double x = pt . getX ( ) - dragPoint . getX ( ) ; double y = pt . getY ( ) - dragPoint . getY ( ) ; setOffset ( x , y ) ; } e . setHandled ( true ) ; } 
public void mouseReleased ( PInputEvent event ) { if ( isConnecting ) { if ( connectTarget ! = null ) connectTarget . repaint ( ) ; NodeView . this . repaint ( ) ; if ( connectSource ! = null & & connectTarget ! = null ) { java . util . List < Parameter > compatibleParameters = connectSource . getNode ( ) . getCompatibleInputs ( connectTarget . getNode ( ) ) ; if ( compatibleParameters . isEmpty ( ) ) { System . out . println ( " No compatible parameters " ) ; } else if ( compatibleParameters . size ( ) = = 1 ) { Only one possible connection, make it now. Parameter inputParameter = compatibleParameters.get(0); inputParameter.connect(connectSource.getNode()); } else { System.out.println("make menu!"); } } } isDragging = false; isConnecting = false; connectSource = null; connectTarget = null; } 
private void addEscapeSupport ( Component c ) { c . addKeyListener ( escapeListener ) ; if ( c instanceof Container ) { Container container = ( Container ) c ; 
private void moveUp ( ) { int index = nodeList . getSelectedIndex ( ) ; index - - ; if ( index < 0 ) { index = nodeList . getModel ( ) . getSize ( ) - 1 ; } nodeList . setSelectedIndex ( index ) ; } 
private void selectAndClose ( ) { selectedNodeType = ( NodeType ) nodeList . getSelectedValue ( ) ; closeDialog ( ) ; } 
public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) = = KeyEvent . VK_ESCAPE ) closeDialog ( ) ; 
public static void centerOnScreen ( Window w ) { Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; Dimension screenSize = toolkit . getScreenSize ( ) ; int x = ( screenSize . width - w . getWidth ( ) ) / 2 ; int y = ( screenSize . height - w . getHeight ( ) ) / 2 ; w . setLocation ( x , y ) ; 
public void paint ( Graphics g ) { g . setColor ( color . getAwtColor ( ) ) ; Rectangle r = g . getClipBounds ( ) ; g . fillRect ( r . x , r . y , r . width , r . height ) ; } 
public void valueChanged ( Parameter source , Object newValue ) { To change body of implemented methods use File | Settings | File Templates. }} 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( new net . nodebox . graphics . Canvas ( ) ) ; return true ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if ( getNetwork ( ) = = null ) return ; Object outputValue = getNetwork ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { ( ( Grob ) outputValue ) . draw ( g2 ) ; 
public void mouseReleased ( PInputEvent event ) { if ( isConnecting ) { if ( connectTarget ! = null ) connectTarget . repaint ( ) ; NodeView . this . repaint ( ) ; if ( connectSource ! = null & & connectTarget ! = null ) { java . util . List < Parameter > compatibleParameters = connectSource . getNode ( ) . getCompatibleInputs ( connectTarget . getNode ( ) ) ; if ( compatibleParameters . isEmpty ( ) ) { System . out . println ( " No compatible parameters " ) ; } else if ( compatibleParameters . size ( ) = = 1 ) { Only one possible connection, make it now. Parameter inputParameter = compatibleParameters.get(0); inputParameter.connect(connectSource.getNode()); } else { JPopupMenu menu = new JPopupMenu("Select input"); for (Parameter p : compatibleParameters) { Action a = new SelectCompatibleParameterAction(connectSource.getNode(), connectTarget.getNode(), p); menu.add(a); } Point pt = getNetworkView().getMousePosition(); menu.show(getNetworkView(), pt.x, pt.y); } } } isDragging = false; isConnecting = false; connectSource = null; connectTarget = null; } 
public void actionPerformed ( ActionEvent e ) { inputParameter . connect ( outputNode ) ; } 
public BezierPath clone ( ) { return new BezierPath ( this ) ; } 
public PathElement clone ( ) { return new PathElement ( this ) ; } 
protected Transform clone ( ) { return new Transform ( this ) ; } 
public void vetoableChange ( PropertyChangeEvent evt ) throws PropertyVetoException { String newValue = textField . getText ( ) ; if ( ! newValue . equals ( parameter . asString ( ) ) ) { parameter . set ( newValue ) ; 
private void addText ( net . nodebox . graphics . Canvas c , Node node , String parameterName , double y ) { c . add ( new Text ( parameterName + " : " + node . asString ( parameterName ) , 10 , 24 + y * 24 ) ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { net . nodebox . graphics . Canvas c = new net . nodebox . graphics . Canvas ( ) ; addText ( c , node , " angle " , 1 ) ; addText ( c , node , " color " , 2 ) ; addText ( c , node , " file " , 3 ) ; addText ( c , node , " float " , 4 ) ; addText ( c , node , " font " , 5 ) ; addText ( c , node , " gradient " , 6 ) ; addText ( c , node , " image " , 7 ) ; addText ( c , node , " int " , 8 ) ; addText ( c , node , " menu " , 9 ) ; addText ( c , node , " seed " , 10 ) ; addText ( c , node , " string " , 11 ) ; addText ( c , node , " text " , 12 ) ; addText ( c , node , " noderef " , 13 ) ; node . setOutputValue ( c ) ; return true ; } 
private String paddedHexString ( int v ) { String s = Integer . toHexString ( v ) ; if ( s . length ( ) = = 1 ) { return " 0 " + s ; 
public String toString ( ) { int r256 = ( int ) Math . round ( r * 255 ) ; int g256 = ( int ) Math . round ( g * 255 ) ; int b256 = ( int ) Math . round ( b * 255 ) ; int a256 = ( int ) Math . round ( a * 255 ) ; return " # " + paddedHexString ( r256 ) 
public void testAsString ( ) { NodeType allControlsType = new NodeType ( null , " " , ParameterType . Type . INT ) { public boolean process ( Node node , ProcessingContext ctx ) { return false ; } } ; allControlsType . addParameterType ( " int " , ParameterType . Type . INT ) ; allControlsType . addParameterType ( " float " , ParameterType . Type . FLOAT ) ; allControlsType . addParameterType ( " string " , ParameterType . Type . STRING ) ; allControlsType . addParameterType ( " color " , ParameterType . Type . COLOR ) ; Node = allControlsType . createNode ( ) ; assertEquals ( " 0 " , . asString ( " int " ) ) ; assertEquals ( " 0.0 " , . asString ( " float " ) ) ; assertEquals ( " " , . asString ( " string " ) ) ; assertEquals ( " #000000ff " , . asString ( " color " ) ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { return false ; } 
public void actionPerformed ( ActionEvent e ) { String newValue = textField . getText ( ) ; if ( ! newValue . equals ( parameter . asString ( ) ) ) { parameter . set ( newValue ) ; 
public void paint ( Graphics g ) { g . setColor ( color . getAwtColor ( ) ) ; Rectangle r = g . getClipBounds ( ) ; g . fillRect ( r . x , r . y , r . width , r . height ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( isDragging ) { colorPicker . setVisible ( false ) ; } isDragging = false ; } 
public void mouseDragged ( MouseEvent e ) { isDragging = true ; JComponent c = ColorWell . this ; Point pt = e . getPoint ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( c ) ; pt = SwingUtilities . convertPoint ( c , pt , frame . getContentPane ( ) ) ; System.out.println("CH e = " + e); MouseEvent newEvent = new MouseEvent(colorPicker, e.getID(), e.getWhen(), e.getModifiers(), (int) pt.getX(), (int) pt.getY(), e.getClickCount(), e.isPopupTrigger(), e.getButton()); colorPicker.dispatchEvent(newEvent); } 
public void mousePressed ( MouseEvent e ) { isDragging = false ; JComponent c = ColorWell . this ; JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( c ) ; if ( frame = = null ) return ; Point pt = c . getLocation ( ) ; pt = SwingUtilities . convertPoint ( c , pt , frame . getContentPane ( ) ) ; Rectangle r = c . getBounds ( ) ; frame . setGlassPane ( colorPicker ) ; colorPicker . setVisible ( true ) ; colorPicker . setPoint ( new Point ( pt . x , pt . y + r . height ) ) ; frame . validate ( ) ; } 
private java . awt . Color colorFromPoint ( int x , int y ) { float h = x / 255.0F ; float s = 1.0F ; float b = 1.0F - ( y / 100.0F ) ; return java . awt . Color . getHSBColor ( h , s , b ) ; } 
public void paint ( Graphics g ) { if ( point = = null ) return ; Graphics2D g2 = (Graphics2D) g; Rectangle r = g.getClipBounds(); g2.setColor(new java.awt.Color(30, 30, 30, 100)); g2.fillRect(r.x, r.y, r.width, r.height); g.setColor(new java.awt.Color(200, 200, 200, 220)); g.fillRect(pickerRect.x, pickerRect.y, pickerRect.width, pickerRect.height); for (int y = 0; y < 100; y++) { for (int x = 0; x < 255; x++) { g.setColor(colorFromPoint(x, y)); g.fillRect(pickerRect.x + x, pickerRect.y + y, 1, 1); } } if (dragPoint == null) return; if (!pickerRect.contains(dragPoint)) return; } 
public void mouseDragged ( MouseEvent e ) { setDragPoint ( e . getPoint ( ) ) ; } 
public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { setVisible ( false ) ; } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } } 
public void mouseReleased ( MouseEvent e ) { setVisible ( false ) ; } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } } 
public void mouseExited ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } } 
public boolean accept ( File f , String s ) { String extension = FileUtils . getExtension ( s ) ; if ( extension ! = null ) { for ( int i = 0 ; i < extensions . length ; i + + ) { if ( extensions [ i ] . equals ( " * " ) | | extensions [ i ] . equalsIgnoreCase ( extension ) ) { return true ; } } } return false ; } 
public static String choosePath ( Network network , String path ) { PathDialog dialog = new PathDialog ( network ) ; dialog . setModal ( true ) ; dialog . setVisible ( true ) ; return dialog . getSelectedPath ( ) ; } 
public boolean isLeaf ( Object node ) { return ! ( node instanceof Network ) ; } 
public String acceptedDescription ( ) { return " All files " ; } 
public void actionPerformed ( ActionEvent e ) { JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( this ) ; File f = FileUtils . showOpenDialog ( frame , parameter . asString ( ) , acceptedExtensions ( ) , acceptedDescription ( ) ) ; if ( f ! = null ) { parameter . setValue ( f . getAbsolutePath ( ) ) ; 
public void actionPerformed ( ActionEvent e ) { Font font = ( Font ) fontChooser . getSelectedItem ( ) ; if ( font = = null ) return ; parameter . setValue ( font . getFontName ( ) ) ; } 
public String acceptedExtensions ( ) { return " png,jpg,jpeg,tiff,gif " ; } 
public String acceptedDescription ( ) { return " Image files " ; } 
public void actionPerformed ( ActionEvent e ) { ParameterType . MenuItem item = ( ParameterType . MenuItem ) menuBox . getSelectedItem ( ) ; parameter . setValue ( item . getKey ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { String newPath = PathDialog . choosePath ( parameter . getNode ( ) . getRootNetwork ( ) , parameter . asString ( ) ) ; parameter . setValue ( newPath ) ; } 
public void actionPerformed ( ActionEvent e ) { parameter . set ( checkBox . isSelected ( ) ? 1 : 0 ) ; } 
public void addMenuItem ( String key , String label ) { menuItems . add ( new MenuItem ( key , label ) ) ; TODO: fireMenuChanged(); 
public ParameterType clone ( NodeType nodeType ) { ParameterType newType = new ParameterType ( nodeType , getName ( ) , getType ( ) , getDirection ( ) ) ; newType . label = getLabel ( ) ; newType . description = getDescription ( ) ; TODO: Does this actually make copies of the values? check! newType.defaultValue = getDefaultValue(); newType.nullAllowed = isNullAllowed(); newType.boundingMethod = getBoundingMethod(); TODO: Does this actually make copies of the values? check! newType.minimumValue = getMinimumValue(); newType.maximumValue = getMaximumValue(); newType.displayLevel = getDisplayLevel(); newType.menuItems = new ArrayList<MenuItem>(menuItems); return newType; } 
private void addString ( String s ) { try { getDocument ( ) . insertString ( getDocument ( ) . getLength ( ) , s , null ) ; 
public void doEnter ( ) { String lastLine = getLastLine ( ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; ByteArrayOutputStream errorStream = new ByteArrayOutputStream ( ) ; interpreter . setOut ( outputStream ) ; interpreter . setErr ( errorStream ) ; interpreter . set ( " document " , pane . getDocument ( ) ) ; Exception pythonException = null ; try { interpreter . exec ( lastLine ) ; } catch ( Exception e ) { pythonException = e ; logger . log ( Level . INFO , " Error on exec " , e ) ; } addString ( " " ) ; String os = outputStream . toString ( ) ; if ( os . length ( ) > 0 ) addString ( os ) ; if ( ! os . endsWith ( " " ) ) addString ( " " ) ; if ( pythonException ! = null ) addString ( pythonException . toString ( ) + " " ) ; newPrompt ( ) ; } 
public void doHistoryUp ( ) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } 
public void doHistoryDown ( ) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } 
public void handleLine ( String string ) { Element [ ] elements = getDocument ( ) . getRootElements ( ) ; } 
public void actionPerformed ( ActionEvent e ) { doEnter ( ) ; } 
public void actionPerformed ( ActionEvent e ) { doHistoryUp ( ) ; } 
public void actionPerformed ( ActionEvent e ) { doHistoryDown ( ) ; } 
public Pane clone ( ) { return new ConsolePane ( getDocument ( ) ) ; } 
public void addLayoutComponent ( String name , Component comp ) { components . add ( comp ) ; } 
public void removeLayoutComponent ( Component comp ) { components . remove ( comp ) ; } 
public Dimension preferredLayoutSize ( Container parent ) { return new Dimension ( 100 , 100 ) ; } 
public Dimension minimumLayoutSize ( Container parent ) { return new Dimension ( 100 , 100 ) ; } 
public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { instance = new Application ( ) ; } 
private void registerForMacOSXEvents ( ) { if ( PlatformUtils . onMac ( ) ) { try { 
private Network createEmptyNetwork ( ) { NodeType canvasNetworkType = nodeManager . getNodeType ( " net.nodebox.node.canvas.network " ) ; return ( Network ) canvasNetworkType . createNode ( ) ; } 
private Network createTestNetwork ( ) { NodeType canvasNetworkType = nodeManager . getNodeType ( " net.nodebox.node.canvas.network " ) ; NodeType vectorNetworkType = nodeManager . getNodeType ( " net.nodebox.node.vector.network " ) ; NodeType imageNetworkType = nodeManager . getNodeType ( " net.nodebox.node.image.network " ) ; NodeType ellipseType = nodeManager . getNodeType ( " net.nodebox.node.vector.ellipse " ) ; NodeType rectType = nodeManager . getNodeType ( " net.nodebox.node.vector.rect " ) ; NodeType transformType = nodeManager . getNodeType ( " net.nodebox.node.vector.transform " ) ; NodeType allControlsType = new AllControlsType ( nodeManager ) ; Network network = ( Network ) canvasNetworkType . createNode ( ) ; Node allControls = network . create ( allControlsType ) ; allControls . setPosition ( 200 , 10 ) ; allControls . setRendered ( ) ; Network vector1 = ( Network ) network . create ( vectorNetworkType ) ; vector1 . setPosition ( 10 , 10 ) ; vector1.setRendered(); Network vector2 = (Network) network.create(vectorNetworkType); vector2.setPosition(10, 110); Network image1 = (Network) network.create(imageNetworkType); image1.setPosition(10, 210); Network image2 = (Network) network.create(imageNetworkType); image2.setPosition(10, 310); Node ellipse1 = vector1.create(ellipseType); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node ellipse2 = vector1.create(ellipseType); ellipse2.setPosition(100, 130); Node transform1 = vector1.create(transformType); transform1.setPosition(300, 230); Node rect1 = vector2.create(rectType); rect1.setPosition(40, 40); rect1.setRendered(); Node transform2 = vector2.create(transformType); transform2.setPosition(40, 80); transform2.setRendered(); transform2.getParameter("shape").connect(rect1); return network; } 
public boolean readFromFile ( String path ) { return readFromFile ( new File ( path ) ) ; } 
public boolean readFromFile ( File file ) { FileInputStream fis ; try { Load the document fis = new FileInputStream(file); InputSource source = new InputSource(fis); Setup the parser SAXParserFactory spf = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. spf.setFeature("http:xml.org/sax/features/validation", false); spf.setFeature("http:xml.org/sax/features/external-parameter-entities", false); spf.setFeature("http:xml.org/sax/features/external-general-entities", false); spf.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); SAXParser parser = spf.newSAXParser(); XmlHandler handler = new XmlHandler(nodeManager); parser.parse(source, handler); The parsed network is now stored in the reader setRootNetwork(handler.getNetwork()); setDocumentFile(file); documentChanged = false; return true; } catch (ParserConfigurationException e) { logger.log(Level.SEVERE, "Error during configuration", e); } catch (IOException e) { logger.log(Level.SEVERE, "Error while reading " + file, e); } catch (SAXException e) { logger.log(Level.SEVERE, "Error while parsing" + file, e); } return false; } 
public void showAbout ( ) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } 
public void showPreferences ( ) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } 
public boolean saveToFile ( File file ) { try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( rootNetwork . toXml ( ) . getBytes ( " UTF-8 " ) ) ; fos . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , " An error occurred while saving the file. " , " MainController " , JOptionPane . ERROR_MESSAGE ) ; logger . log ( Level . SEVERE , " An error occurred while saving the file. " , e ) ; return false ; } documentChanged = false ; updateTitle ( ) ; return true ; 
public void quit ( ) { boolean allClosed = true ; Because documents will disappear from the list once they are closed, make a copy of the list. java.util.List<Document> documents = new ArrayList<Document>(Application.getInstance().getDocuments()); for (Document d : documents) { allClosed = allClosed && d.shouldClose(); } if (allClosed) { System.exit(0); 
public void actionPerformed ( ActionEvent e ) { File chosenFile = FileUtils . showOpenDialog ( Document . this , lastFilePath , " ndbx " , " NodeBox Document " ) ; if ( chosenFile ! = null ) { lastFilePath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; 
public void actionPerformed ( ActionEvent e ) { } } public class ExportAction extends AbstractAction { public ExportAction ( ) { putValue ( NAME , " Export " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_E ) ) ; } public void actionPerformed ( ActionEvent e ) { export ( ) ; } } public class QuitAction extends AbstractAction { public QuitAction ( ) { putValue ( NAME , " Quit " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Q ) ) ; } public void actionPerformed ( ActionEvent e ) { quit ( ) ; } } public class UndoAction extends AbstractAction { public UndoAction ( ) { putValue ( NAME , " Undo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . undo ( ) ; } catch ( CannotUndoException ex ) { logger . log ( Level . WARNING , " Unable to undo. " , ex ) ; } update ( ) ; redoAction . update ( ) ; } public void update ( ) { if ( undo . canUndo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getUndoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Undo " ) ; } } } public class RedoAction extends AbstractAction { public RedoAction ( ) { putValue ( NAME , " Redo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z , Event . SHIFT_MASK ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . redo ( ) ; } catch ( CannotRedoException ex ) { logger . log ( Level . WARNING , " Unable to redo. " , ex ) ; } update ( ) ; undoAction . update ( ) ; } public void update ( ) { if ( undo . canRedo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getRedoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Redo " ) ; } } } public class CutAction extends AbstractAction { public CutAction ( ) { putValue ( NAME , " Cut " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_X ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } }} 
public void actionPerformed ( ActionEvent e ) { quit ( ) ; } 
public boolean callTarget ( Object appleEvent ) { if ( appleEvent ! = null ) { try { Method getFilenameMethod = appleEvent . getClass ( ) . getDeclaredMethod ( " getFilename " , ( Class [ ] ) null ) ; String filename = ( String ) getFilenameMethod . invoke ( appleEvent , ( Object [ ] ) null ) ; this . targetMethod . invoke ( this . targetObject , filename ) ; } catch ( Exception ignored ) { } } return true ; } 
public boolean callTarget ( Object appleEvent ) throws InvocationTargetException , IllegalAccessException { Object result = targetMethod . invoke ( targetObject , ( Object [ ] ) null ) ; return ( result = = null ) | | Boolean . valueOf ( result . toString ( ) ) ; } 
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( isCorrectMethod ( method , args ) ) { boolean handled = callTarget ( args [ 0 ] ) ; setApplicationEventHandled ( args [ 0 ] , handled ) ; } All of the ApplicationListener methods are void; return null regardless of what happens return null; } 
protected boolean isCorrectMethod ( Method method , Object [ ] args ) { return ( targetMethod ! = null & & proxySignature . equals ( method . getName ( ) ) & & args . length = = 1 ) ; } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("net.nodebox.node.vector.network").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("net.nodebox.node.vector.rect")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); }} 
public void testPersistence ( ) { Create network Network rootNetwork = (Network) manager.getNodeType("net.nodebox.node.canvas.network").createNode(); Network vecnet1 = (Network) rootNetwork.create(manager.getNodeType("net.nodebox.node.vector.network")); vecnet1.setPosition(10, 10); assertEquals("vecnet1", vecnet1.getName()); vecnet1.setRendered(); Node ellipse1 = vecnet1.create(manager.getNodeType("net.nodebox.node.vector.ellipse")); assertEquals("ellipse1", ellipse1.getName()); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node transform1 = vecnet1.create(manager.getNodeType("net.nodebox.node.vector.transform")); assertEquals("transform1", transform1.getName()); transform1.setPosition(40, 80); transform1.setRendered(); transform1.getParameter("shape").connect(ellipse1); Write network String xmlString = rootNetwork.toXml(); Read network Network newNetwork = Network.load(manager, xmlString); Perform tests on the network assertEquals(rootNetwork.getName(), newNetwork.getName()); assertTrue(newNetwork.contains("vecnet1")); Network nVector1 = (Network) newNetwork.getNode("vecnet1"); assertTrue(nVector1.contains("ellipse1")); assertTrue(nVector1.contains("transform1")); Node nEllipse1 = nVector1.getNode("ellipse1"); Node nTransform1 = nVector1.getNode("transform1"); assertEquals(ellipse1.getValue("x"), nEllipse1.getValue("x")); assertEquals(ellipse1.getValue("fill"), nEllipse1.getValue("fill")); assertEquals(ellipse1.getValue("stroke"), nEllipse1.getValue("stroke")); assertTrue(nEllipse1.isConnected()); assertTrue(nTransform1.isConnected()); assertTrue(nTransform1.getParameter("shape").isConnectedTo(nEllipse1)); } 
private static void writeRecentFiles ( ArrayList < File > fileList ) { int i = 1 ; for ( File f : fileList ) { try { recentFilesPreferences . put ( String . valueOf ( i ) , f . getCanonicalPath ( ) ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , " Could not get canonical file name " , e ) ; return ; } i + + ; if ( i > 10 ) break ; } try { recentFilesPreferences . flush ( ) ; 
private void initMenu ( ) { JMenuBar menuBar = new JMenuBar ( ) ; File menu JMenu fileMenu = new JMenu("File"); fileMenu.add(new JMenuItem(newAction)); fileMenu.add(new JMenuItem(openAction)); recentFileMenu = new JMenu("Open Recent"); buildRecentFileMenu(); fileMenu.add(recentFileMenu); fileMenu.addSeparator(); fileMenu.add(new JMenuItem(closeAction)); fileMenu.add(new JMenuItem(saveAction)); fileMenu.add(new JMenuItem(saveAsAction)); fileMenu.add(new JMenuItem(revertAction)); fileMenu.addSeparator(); fileMenu.add(new JMenuItem(exportAction)); if (!PlatformUtils.onMac()) { fileMenu.addSeparator(); fileMenu.add(new JMenuItem(quitAction)); } menuBar.add(fileMenu); Edit menu JMenu editMenu = new JMenu("Edit"); editMenu.add(new JMenuItem(undoAction)); editMenu.add(new JMenuItem(redoAction)); editMenu.addSeparator(); editMenu.add(new JMenuItem(cutAction)); editMenu.add(new JMenuItem(copyAction)); editMenu.add(new JMenuItem(pasteAction)); editMenu.addSeparator(); editMenu.add(new JMenuItem(deleteAction)); menuBar.add(editMenu); setJMenuBar(menuBar); } 
public static void open ( File file ) { lastFilePath = file . getParentFile ( ) . getAbsolutePath ( ) ; Document doc = Application . getInstance ( ) . createNewDocument ( ) ; if ( doc . readFromFile ( file ) ) { doc . setDocumentFile ( file ) ; } addRecentFile ( file ) ; } 
public void actionPerformed ( ActionEvent e ) { File chosenFile = FileUtils . showOpenDialog ( Document . this , lastFilePath , " ndbx " , " NodeBox Document " ) ; if ( chosenFile ! = null ) { open ( chosenFile ) ; 
public void actionPerformed ( ActionEvent e ) { open ( file ) ; } 
public void mousePressed ( MouseEvent e ) { JButton b = ( JButton ) e . getSource ( ) ; Point p = e . getPoint ( ) ; b . getComponentPopupMenu ( ) . show ( b , p . x , p . y ) ; } 
public void actionPerformed ( ActionEvent e ) { toggleExpression ( ) ; } 
public void mousePressed ( MouseEvent e ) { JButton b = ( JButton ) e . getSource ( ) ; Point p = e . getPoint ( ) ; b . getComponentPopupMenu ( ) . show ( b , p . x , p . y ) ; } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . setColor ( Color . GRAY ) ; g . fillRect ( x , y + height - 1 , width , 1 ) ; } 
public boolean isBorderOpaque ( ) { return true ; } 
public void componentResized ( ComponentEvent e ) { Dimension controlSize = control . getPreferredSize ( ) ; Rectangle bounds = getBounds ( ) ; label . setBounds ( 0 , TOP_PADDING , 100 , controlSize . height ) ; control . setBounds ( 110 , TOP_PADDING , controlSize . width , controlSize . height ) ; expressionField . setBounds ( 110 , TOP_PADDING , 200 , controlSize . height ) ; popupButton . setBounds ( bounds . width - 30 , TOP_PADDING , 30 , controlSize . height ) ; repaint ( ) ; } 
public void paintComponent ( Graphics g ) { g . setColor ( Color . GRAY ) ; g . fillRect ( 105 , 0 , 1 , getPreferredSize ( ) . height ) ; } 
public void actionPerformed ( ActionEvent e ) { if ( parameter . hasExpression ( ) ) { parameter . setExpression ( null ) ; } else { parameter . setExpression ( parameter . asExpression ( ) ) ; } setExpressionStatus ( ) ; } 
public void actionPerformed ( ActionEvent e ) { parameter . revertToDefault ( ) ; } 
public void actionPerformed ( ActionEvent e ) { parameter . setExpression ( expressionField . getText ( ) ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { net . nodebox . graphics . Canvas c = new net . nodebox . graphics . Canvas ( ) ; addText ( c , node , " angle " , 1 ) ; addText ( c , node , " color " , 2 ) ; addText ( c , node , " file " , 3 ) ; addText ( c , node , " float " , 4 ) ; addText ( c , node , " font " , 5 ) ; addText ( c , node , " gradient " , 6 ) ; addText ( c , node , " image " , 7 ) ; addText ( c , node , " int " , 8 ) ; addText ( c , node , " menu " , 9 ) ; addText ( c , node , " seed " , 10 ) ; addText ( c , node , " string " , 11 ) ; addText ( c , node , " text " , 12 ) ; addText ( c , node , " toggle " , 13 ) ; addText ( c , node , " noderef " , 14 ) ; node . setOutputValue ( c ) ; return true ; } 
public void actionPerformed ( ActionEvent e ) { commitNumberField ( ) ; } 
public void setValueFromString ( String s ) throws NumberFormatException { setValue ( Double . parseDouble ( s ) ) ; } 
public String valueAsString ( ) { return numberFormat . format ( value ) ; } 
private void commitNumberField ( ) { numberField . setVisible ( false ) ; String s = numberField . getText ( ) ; try { setValueFromString ( s ) ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Rectangle r = getBounds(); Rectangle r = g2.getClipBounds(); r.setRect(r.x + 2, r.y + 2, r.width - 8, r.height - 8); g2.setColor(new Color(180, 180, 180)); g2.fillRoundRect(r.x, r.y, r.width, r.height, 5, 5); g2.setColor(new Color(30, 30, 30)); g2.setFont(PlatformUtils.getSmallBoldFont()); paintCenteredString(g2, valueAsString(), r.x + r.width / 2F, r.y + r.height / 2F); Rectangle leftButtonRect = getLeftButtonRect(r); Rectangle rightButtonRect = getRightButtonRect(r); leftIcon.paintIcon(this, g, leftButtonRect.x, leftButtonRect.y + r.height / 2); rightIcon.paintIcon(this, g, rightButtonRect.x, rightButtonRect.y + r.height / 2); } 
private void paintCenteredString ( Graphics2D g2 , String s , float centerX , float centerY ) { FontRenderContext frc = g2 . getFontRenderContext ( ) ; Rectangle2D bounds = g2 . getFont ( ) . getStringBounds ( s , frc ) ; float leftX = centerX - ( float ) bounds . getWidth ( ) / 2 ; LineMetrics lm = g2 . getFont ( ) . getLineMetrics ( s , frc ) ; float baselineY = centerY - lm . getHeight ( ) / 2 + lm . getAscent ( ) ; g2 . drawString ( s , leftX , baselineY ) ; } 
public void componentResized ( ComponentEvent e ) { numberField . setBounds ( 12 , 1 , getWidth ( ) - 24 , getHeight ( ) - 2 ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( oldValue ! = value ) fireActionPerformed ( ) ; 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . getContentPane ( ) . add ( new DraggableNumber ( ) ) ; frame . pack ( ) ; frame . setVisible ( true ) ; } 
public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) = = KeyEvent . VK_ESCAPE ) numberField . setVisible ( false ) ; 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . setColor ( borderColor ) ; g . fillRect ( x , y + height - 1 , width , 1 ) ; } 
public void componentResized ( ComponentEvent e ) { Dimension controlSize = control . getPreferredSize ( ) ; Rectangle bounds = getBounds ( ) ; int h = bounds . height - TOP_PADDING - BOTTOM_PADDING ; label . setBounds ( 0 , TOP_PADDING , 100 , h ) ; control . setBounds ( 110 , TOP_PADDING , controlSize . width , h ) ; expressionField . setBounds ( 110 , TOP_PADDING , 200 , h ) ; popupButton . setBounds ( bounds . width - 30 , TOP_PADDING , 30 , h ) ; repaint ( ) ; } 
public void paintComponent ( Graphics g ) { g . setColor ( borderColor ) ; g . fillRect ( 105 , 0 , 1 , getPreferredSize ( ) . height ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Rectangle r = g2 . getClipBounds ( ) ; r . setRect ( r . x + 2 , r . y + 2 , r . width - 8 , r . height - 8 ) ; g2 . setColor ( new Color ( 180 , 180 , 180 ) ) ; g2 . fillRoundRect ( r . x , r . y , r . width , r . height , 5 , 5 ) ; g2 . setColor ( new Color ( 30 , 30 , 30 ) ) ; g2 . setFont ( PlatformUtils . getSmallBoldFont ( ) ) ; paintCenteredString ( g2 , valueAsString ( ) , r . x + r . width / 2F , r . y + r . height / 2F ) ; TODO: The "-2" at the end is a hack. leftIcon.paintIcon(this, g, r.x + 2, r.y + r.height / 2 - 2); rightIcon.paintIcon(this, g, r.x + r.width - 8, r.y + r.height / 2 - 2); } 
private void initMenu ( ) { JMenuBar menuBar = new JMenuBar ( ) ; File menu JMenu fileMenu = new JMenu("File"); fileMenu.add(newAction); fileMenu.add(openAction); recentFileMenu = new JMenu("Open Recent"); buildRecentFileMenu(); fileMenu.add(recentFileMenu); fileMenu.addSeparator(); fileMenu.add(closeAction); fileMenu.add(saveAction); fileMenu.add(saveAsAction); fileMenu.add(revertAction); fileMenu.addSeparator(); fileMenu.add(exportAction); if (!PlatformUtils.onMac()) { fileMenu.addSeparator(); fileMenu.add(quitAction); } menuBar.add(fileMenu); Edit menu JMenu editMenu = new JMenu("Edit"); editMenu.add(undoAction); editMenu.add(redoAction); editMenu.addSeparator(); editMenu.add(cutAction); editMenu.add(copyAction); editMenu.add(pasteAction); editMenu.addSeparator(); editMenu.add(deleteAction); menuBar.add(editMenu); Window menu JMenu windowMenu = new JMenu("Window"); JMenu layoutMenu = new JMenu("Layout"); layoutMenu.add(new ) windowMenu.add(minimizeAction); windowMenu.add(zoomAction); windowMenu.addSeparator(); windowMenu.add(layoutMenu); windowMenu.addSeparator(); windowMenu.add(bringAllToFrontAction); windowMenu.addSeparator(); menuBar.add(windowMenu); Help menu JMenu helpMenu = new JMenu("Help"); helpMenu.add(nodeboxSiteAction); menuBar.add(helpMenu); setJMenuBar(menuBar); } 
public void actionPerformed ( ActionEvent e ) { } } public class ExportAction extends AbstractAction { public ExportAction ( ) { putValue ( NAME , " Export " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_E ) ) ; } public void actionPerformed ( ActionEvent e ) { export ( ) ; } } public class QuitAction extends AbstractAction { public QuitAction ( ) { putValue ( NAME , " Quit " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Q ) ) ; } public void actionPerformed ( ActionEvent e ) { quit ( ) ; } } public class UndoAction extends AbstractAction { public UndoAction ( ) { putValue ( NAME , " Undo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . undo ( ) ; } catch ( CannotUndoException ex ) { logger . log ( Level . WARNING , " Unable to undo. " , ex ) ; } update ( ) ; redoAction . update ( ) ; } public void update ( ) { if ( undo . canUndo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getUndoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Undo " ) ; } } } public class RedoAction extends AbstractAction { public RedoAction ( ) { putValue ( NAME , " Redo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z , Event . SHIFT_MASK ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . redo ( ) ; } catch ( CannotRedoException ex ) { logger . log ( Level . WARNING , " Unable to redo. " , ex ) ; } update ( ) ; undoAction . update ( ) ; } public void update ( ) { if ( undo . canRedo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getRedoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Redo " ) ; } } } public class CutAction extends AbstractAction { public CutAction ( ) { putValue ( NAME , " Cut " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_X ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { setState ( Frame . ICONIFIED ) ; } 
public void actionPerformed ( ActionEvent e ) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } 
public void apply ( Document document ) { } public void extract ( Document document ) { document . getContentPane ( ) ; } public class Component { } public class Panel extends Component { private Class panelClass ; public Panel ( Class panelClass ) { this . panelClass = panelClass ; } } public class Split extends Component { private Component leftComponent ; private Component rightComponent ; private int direction ; private double position ; public Split ( Component leftComponent , Component rightComponent , int direction , double position ) { this . leftComponent = leftComponent ; this . rightComponent = rightComponent ; this . direction = direction ; this . position = position ; } } } 
public void extract ( Document document ) { document . getContentPane ( ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { method . __call__ ( ) ; return true ; } 
public void updateTitle ( ) { String postfix = " " ; if ( ! PlatformUtils . onMac ( ) ) { todo: mac only code postfix = (documentChanged ? " *" : "") + " - PNA"; } else { getRootPane().putClientProperty("Window.documentModified", Boolean.TRUE); getRootPane().putClientProperty("Window.documentFile", documentFile); } if (documentFile == null) { setTitle("Untitled" + postfix); 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Rectangle r = g2 . getClipBounds ( ) ; int radius = r . height / 2 ; int halfradius = ( radius / 2 ) - 2 ; r . setRect ( r . x + 2 , r . y + 2 , r . width - 8 , r . height - 8 ) ; g2 . setColor ( new Color ( 215 , 215 , 215 ) ) ; g2 . fillRoundRect ( r . x , r . y , r . width , r . height , radius , radius ) ; g2 . setColor ( new Color ( 150 , 150 , 150 ) ) ; g2 . drawRoundRect ( r . x , r . y , r . width , r . height , radius , radius ) ; g2 . setColor ( new Color ( 187 , 187 , 187 ) ) ; g2 . drawLine ( r . x + halfradius , r . y + 1 , r . width - halfradius , r . y + 1 ) ; g2 . setColor ( new Color ( 223 , 223 , 223 ) ) ; g2 . drawLine ( r . x + halfradius , r . y + r . height - 1 , r . width - halfradius , r . y + r . height - 1 ) ; g2 . setColor ( new Color ( 0 , 0 , 0 ) ) ; g2 . setFont ( PlatformUtils . getSmallBoldFont ( ) ) ; paintCenteredString ( g2 , valueAsString ( ) , r . x + r . width / 2F , r . y + r . height / 2F ) ; TODO: The "-2" at the end is a hack. leftIcon.paintIcon(this, g, r.x + 2, r.y + r.height / 2 - 2); rightIcon.paintIcon(this, g, r.x + r.width - 8, r.y + r.height / 2 - 2); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Rectangle r = getBounds ( ) ; int radius = r . height / 2 ; int halfradius = ( radius / 2 ) - 2 ; r . setRect ( r . x + 2 , r . y + 2 , r . width - 8 , r . height - 8 ) ; g2 . setColor ( new Color ( 215 , 215 , 215 ) ) ; g2 . fillRoundRect ( r . x , r . y , r . width , r . height , radius , radius ) ; g2 . setColor ( new Color ( 150 , 150 , 150 ) ) ; g2 . drawRoundRect ( r . x , r . y , r . width , r . height , radius , radius ) ; g2 . setColor ( new Color ( 187 , 187 , 187 ) ) ; g2 . drawLine ( r . x + halfradius , r . y + 1 , r . width - halfradius , r . y + 1 ) ; g2 . setColor ( new Color ( 223 , 223 , 223 ) ) ; g2 . drawLine ( r . x + halfradius , r . y + r . height - 1 , r . width - halfradius , r . y + r . height - 1 ) ; g2 . setColor ( new Color ( 0 , 0 , 0 ) ) ; g2 . setFont ( PlatformUtils . getSmallBoldFont ( ) ) ; paintCenteredString ( g2 , valueAsString ( ) , r . x + r . width / 2F , r . y + r . height / 2F ) ; TODO: The "-2" at the end is a hack. leftIcon.paintIcon(this, g, r.x + 2, r.y + r.height / 2 - 2); rightIcon.paintIcon(this, g, r.x + r.width - 8, r.y + r.height / 2 - 2); } 
public void updateTitle ( ) { String postfix = " " ; if ( ! PlatformUtils . onMac ( ) ) { todo: mac only code postfix = (documentChanged ? " *" : "") + " - PNA"; } else { getRootPane().putClientProperty("Window.documentModified", documentChanged); } if (documentFile == null) { setTitle("Untitled" + postfix); 
public void keyPressed ( KeyEvent e ) { if ( filteredNodeListModel . getSearchString ( ) . equals ( searchField . getText ( ) ) ) return ; filteredNodeListModel . setSearchString ( searchField . getText ( ) ) ; Trigger a model reload. nodeList.setModel(filteredNodeListModel); nodeList.setSelectedIndex(0); repaint(); } 
public void insertUpdate ( DocumentEvent e ) { changedEvent ( ) ; } 
public void removeUpdate ( DocumentEvent e ) { changedEvent ( ) ; } 
public void changedUpdate ( DocumentEvent e ) { changedEvent ( ) ; } 
private void changedEvent ( ) { if ( filteredNodeListModel . getSearchString ( ) . equals ( searchField . getText ( ) ) ) return ; filteredNodeListModel . setSearchString ( searchField . getText ( ) ) ; Trigger a model reload. nodeList.setModel(filteredNodeListModel); nodeList.setSelectedIndex(0); repaint(); } 
public void testValues ( ) { ValueNodeType valueNodeType = new ValueNodeType ( null ) ; Node = valueNodeType . createNode ( ) ; assertEquals ( ParameterType . Type . INT , valueNodeType . pInt . getType ( ) ) ; assertEquals ( ParameterType . Type . FLOAT , valueNodeType . pFloat . getType ( ) ) ; assertEquals ( ParameterType . Type . STRING , valueNodeType . pString . getType ( ) ) ; assertEquals ( 0 , . asInt ( " int " ) ) ; assertEquals ( 0.0 , . asFloat ( " float " ) ) ; assertEquals ( " " , . asString ( " string " ) ) ; . set ( " int " , 12 ) ; . set ( " float " , 0.5 ) ; . set ( " string " , " hello " ) ; assertEquals ( 12 , . asInt ( " int " ) ) ; assertEquals ( 0.5 , . asFloat ( " float " ) ) ; assertEquals ( " hello " , . asString ( " string " ) ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( 42 ) ; return true ; } 
public void testType ( ) { NodeType customType = numberType . clone ( ) ; ParameterType ptAngle = customType . addParameterType ( " angle " , ParameterType . Type . ANGLE ) ; assertEquals ( ParameterType . CoreType . FLOAT , ptAngle . getCoreType ( ) ) ; } 
public void testBounding ( ) { NodeType customType = numberType . clone ( ) ; ParameterType ptAngle = customType . addParameterType ( " angle " , ParameterType . Type . ANGLE ) ; ptAngle . setBoundingMethod ( ParameterType . BoundingMethod . SOFT ) ; ptAngle . setMinimumValue ( - 100.0 ) ; ptAngle . setMaximumValue ( 100.0 ) ; Node = customType . createNode ( ) ; assertValidValue ( , " angle " , 0.0 ) ; assertValidValue ( , " angle " , 1000.0 ) ; assertValidValue ( , " angle " , - 1000.0 ) ; ptAngle . setBoundingMethod ( ParameterType . BoundingMethod . HARD ) ; assertEquals ( - 100.0 , . asFloat ( " angle " ) ) ; Setting the bounding type to hard clamped the value assertInvalidValue(n, "angle", 500.0); ptAngle.setBoundingMethod(ParameterType.BoundingMethod.NONE); assertValidValue(n, "angle", 300.0); ptAngle.setBoundingMethod(ParameterType.BoundingMethod.HARD); assertEquals(100.0, n.asFloat("angle")); } 
private void assertValidValue ( Node , String parameterName , Object value ) { try { . setValue ( parameterName , value ) ; 
private void assertInvalidValue ( Node , String parameterName , Object value ) { try { . setValue ( parameterName , value ) ; 
public void addEllipse ( double x , double y , double width , double height ) { Ellipse2D . Double e = new Ellipse2D . Double ( x , y , width , height ) ; extend ( e ) ; } 
public void extend ( Shape s ) { PathIterator pi = s . getPathIterator ( new AffineTransform ( ) ) ; while ( ! pi . isDone ( ) ) { float [ ] points = new float [ 6 ] ; 
public void draw ( Graphics2D g ) { if ( fillColor ! = null & & fillColor . isVisible ( ) ) { g . setColor ( fillColor . getAwtColor ( ) ) ; g . fill ( getGeneralPath ( ) ) ; } if ( strokeWidth > 0 & & strokeColor ! = null & & strokeColor . isVisible ( ) ) { g . setColor ( strokeColor . getAwtColor ( ) ) ; 
public String toString ( ) { return level + " : " + message ; } 
public boolean matches ( Version version ) { TODO: implement return false; } 
public boolean matches ( int major , int minor ) { return matches ( new Version ( major , minor ) ) ; } 
public void addNodeType ( NodeType nodeType ) { Version newVersion = nodeType . getVersion ( ) ; int i = 0 ; for ( ; i < nodeTypes . size ( ) ; i + + ) { NodeType nt = nodeTypes . get ( i ) ; if ( nt . getVersion ( ) . smallerThan ( newVersion ) ) break ; } nodeTypes . add ( i , nodeType ) ; } 
public static Version parseVersionString ( String s ) throws IllegalArgumentException { return new Version ( s ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Version ) ) return false ; Version v = ( Version ) o ; return major = = v . major & & minor = = v . minor & & 
public boolean largerThan ( Version other ) { if ( major > other . major ) return true ; if ( major = = other . major & & minor > other . minor ) return true ; if ( major = = other . major & & minor = = other . minor & & revision > other . revision ) return true ; return false ; } 
public boolean largerOrEqualThan ( Version other ) { if ( largerThan ( other ) ) return true ; return major = = other . major & & minor = = other . minor & & revision = = other . revision ; } 
public boolean smallerOrEqualThan ( Version other ) { return ! largerThan ( other ) ; } 
public boolean smallerThan ( Version other ) { return ! largerOrEqualThan ( other ) ; } 
public String toString ( ) { return major + " . " + minor + " . " + revision ; } 
public Version clone ( ) { return new Version ( major , minor , revision ) ; } 
private Node lookupNode ( Attributes attributes ) throws SAXException { NodeType nodeType ; Node newNode ; String identifier = attributes . getValue ( " type " ) ; String version = attributes . getValue ( " version " ) ; try { if ( version = = null ) { nodeType = nodeManager . getNodeType ( identifier ) ; } else { nodeType = nodeManager . getNodeType ( identifier , new Version ( version ) ) ; } } catch ( NotFoundException e ) { throw new SAXException ( " A node with type " + identifier + " and version " + version + " does not exist. " ) ; } newNode = nodeType . createNode ( ) ; String name = attributes . getValue ( " name " ) ; if ( name ! = null ) { newNode . setName ( name ) ; } String x = attributes . getValue ( " x " ) ; if ( x ! = null ) { try { newNode . setX ( Double . parseDouble ( x ) ) ; } catch ( NumberFormatException e ) { logger . log ( Level . WARNING , " Could not parse x attribute for node " + name + " [ " + identifier + " ] value= " + x ) ; } } String y = attributes . getValue ( " y " ) ; if ( y ! = null ) { try { newNode . setY ( Double . parseDouble ( y ) ) ; } catch ( NumberFormatException e ) { logger . log ( Level . WARNING , " Could not parse y attribute for node " + name + " [ " + identifier + " ] value= " + y ) ; } } return newNode ; } 
public void testParsing ( ) { assertEquals ( new Version ( 0 , 0 , 0 ) , new Version ( " 0 " ) ) ; assertEquals ( new Version ( 1 , 0 , 0 ) , new Version ( " 1 " ) ) ; assertEquals ( new Version ( 1 , 4 , 0 ) , new Version ( " 1.4 " ) ) ; assertEquals ( new Version ( 0 , 4 , 5 ) , new Version ( " 0.4.5 " ) ) ; assertEquals ( new Version ( 124125 , 421321 , 5123213 ) , new Version ( " 124125.421321.5123213 " ) ) ; assertInvalidVersion ( " " , " no empty strings " ) ; assertInvalidVersion ( " hello " , " only numbers " ) ; assertInvalidVersion ( " 1.2.3.4 " , " too many components " ) ; assertInvalidVersion ( " -12.2.3 " , " no negative numbers " ) ; assertInvalidVersion ( " 1.2.a " , " no letters " ) ; } 
public void testLargerThan ( ) { assertTrue ( new Version ( 1 , 0 , 0 ) . largerThan ( new Version ( 0 , 0 , 0 ) ) ) ; assertTrue ( new Version ( 0 , 0 , 1 ) . largerThan ( new Version ( 0 , 0 , 0 ) ) ) ; assertTrue ( new Version ( 0 , 3 , 1 ) . largerThan ( new Version ( 0 , 2 , 99 ) ) ) ; assertTrue ( new Version ( 4 , 0 , 0 ) . largerThan ( new Version ( 3 , 9 , 9 ) ) ) ; } 
private void assertInvalidVersion ( String verisonString , String reason ) { try { Version . parseVersionString ( verisonString ) ; 
public NodeTypeLibrary loadLatestVersion ( String libraryName ) { throw new AssertionError ( " Not implemented yet. " ) ; } 
private void lookForLibraries ( ) { } private NodeTypeLibrary directoryNameToLibrary ( String searchPath , String directoryName ) { searchPath.split("-") throw new AssertionError("Not implemented yet."); }} 
private NodeTypeLibrary directoryNameToLibrary ( String searchPath , String directoryName ) { searchPath.split("-") throw new AssertionError("Not implemented yet."); } 
public void addNodeType ( NodeType nodeType ) { types . put ( nodeType . getIdentifier ( ) , nodeType ) ; } 
public void load ( ) { if ( isLoaded ( ) ) return ; File name File file = getLibraryDescriptionFile(); Load the document FileInputStream fis; try { fis = new FileInputStream(file); } catch (FileNotFoundException e) { logger.log(Level.SEVERE, "Could not read file " + file, e); throw new RuntimeException("Could not read file " + file, e); } InputSource source = new InputSource(fis); Setup the parser SAXParserFactory factory = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. try { factory.setFeature("http:xml.org/sax/features/validation", false); factory.setFeature("http:xml.org/sax/features/external-parameter-entities", false); factory.setFeature("http:xml.org/sax/features/external-general-entities", false); factory.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); } catch (Exception e) { logger.log(Level.SEVERE, "Parsing feature not supported.", e); throw new RuntimeException("Parsing feature not supported.", e); } SAXParser parser; try { parser = factory.newSAXParser(); } catch (Exception e) { logger.log(Level.SEVERE, "Could not create parser.", e); throw new RuntimeException("Could not create parser.", e); } Parse the document TypesHandler handler = new TypesHandler(this); try { parser.parse(source, handler); 
public static Type parseType ( String typeString ) throws IllegalArgumentException { return Type . valueOf ( typeString . toUpperCase ( ) ) ; } 
public static BoundingMethod parseBoundingMethod ( String boundingMethodString ) throws IllegalArgumentException { return BoundingMethod . valueOf ( boundingMethodString . toUpperCase ( ) ) ; } 
public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( qName . equals ( " library " ) ) { createNodeTypeLibrary ( attributes ) ; 
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( qName . equals ( " library " ) ) { Top level element -- parsing finished. 
public void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( parseState = = ParseState . IN_DESCRIPTION ) { characterBuffer . append ( ch , start , length ) ; 
private void createNodeTypeLibrary ( Attributes attributes ) throws SAXException { Make sure we use the correct format and file type. String formatVersion = requireAttribute("library", attributes, "formatVersion"); if (!formatVersion.equals("0.8")) { throwLibraryException("unknown format version '" + formatVersion + "'"); } String type = requireAttribute("library", attributes, "type"); if (type.equals("python")) { createPythonNodeTypeLibrary(attributes); 
private void createPythonNodeTypeLibrary ( Attributes attributes ) throws SAXException { String moduleName = requireAttribute ( " library " , attributes , " module " ) ; TODO: This is the central versioning problem. To properly handle this, we need several system states. Py.getSystemState().path.add(new PyString(library.getPath())); PyObject module = imp.importName(moduleName.intern(), true); library.setPythonModule(module); } 
private void createNodeType ( Attributes attributes ) throws SAXException { String name = requireAttribute ( " type " , attributes , " name " ) ; String outputTypeName = requireAttribute ( " type " , attributes , " outputType " ) ; String functionName = requireAttribute ( " type " , attributes , " method " ) ; ParameterType . Type outputType = ParameterType . parseType ( outputTypeName ) ; PyObject module = library . getPythonModule ( ) ; PyObject functionObject ; try { functionObject = module . __getattr__ ( functionName . intern ( ) ) ; } catch ( Exception e ) { throwLibraryException ( " the method ' " + name + " ' does not exist in the module " + module ) ; return ; } PyFunction function = null ; try { function = ( PyFunction ) functionObject ; } catch ( ClassCastException e ) { throwLibraryException ( " the module attribute ' " + functionName + " ' is not a Python function. " ) ; } currentNodeType = new PythonNodeType ( null , name , outputType , function ) ; library . addNodeType ( currentNodeType ) ; } 
private void throwLibraryException ( String message ) throws SAXException { throw new SAXException ( " Library " + library . getName ( ) + " : " + message ) ; } 
private void createParameterType ( Attributes attributes ) throws SAXException { String name = requireAttribute ( " parameter " , attributes , " name " ) ; String typeName = requireAttribute ( " parameter " , attributes , " type " ) ; ParameterType . Type type = ParameterType . parseType ( typeName ) ; currentParameterType = currentNodeType . addParameterType ( name , type ) ; String label = attributes . getValue ( " label " ) ; String description = attributes . getValue ( " description " ) ; String defaultValue = attributes . getValue ( " defaultValue " ) ; String boundingMethod = attributes . getValue ( " boundingMethod " ) ; String minimumValue = attributes . getValue ( " minimumValue " ) ; String maximumValue = attributes . getValue ( " maximumValue " ) ; if ( label ! = null ) currentParameterType . setLabel ( label ) ; if ( description ! = null ) currentParameterType . setDescription ( description ) ; if ( defaultValue ! = null ) { Object value = currentParameterType . parseValue ( defaultValue ) ; currentParameterType . setDefaultValue ( value ) ; } if ( boundingMethod ! = null ) currentParameterType . setBoundingMethod ( ParameterType . parseBoundingMethod ( boundingMethod ) ) ; if ( minimumValue ! = null ) { Double value = Double . parseDouble ( minimumValue ) ; currentParameterType . setMinimumValue ( value ) ; } if ( maximumValue ! = null ) { Double value = Double . parseDouble ( maximumValue ) ; 
private void addParameterTypeOption ( Attributes attributes ) throws SAXException { if ( currentParameterType . getType ( ) ! = ParameterType . Type . MENU ) throw new SAXException ( " Option tag can only be set on menu parameter types. " ) ; String key = requireAttribute ( " option " , attributes , " key " ) ; String label = requireAttribute ( " option " , attributes , " label " ) ; currentParameterType . addMenuItem ( key , label ) ; } 
private String requireAttribute ( String qname , Attributes attributes , String name ) throws SAXException { String value = attributes . getValue ( name ) ; if ( value = = null ) throwLibraryException ( " tag " + qname + " : missing required attribute ' " + name + " '. " ) ; return value ; } 
private void initJython ( ) { Properties jythonProperties = new Properties ( ) ; String jythonCacheDir = PlatformUtils . getUserDataDirectory ( ) + PlatformUtils . SEP + " jythoncache " ; jythonProperties . put ( " python.cachedir " , jythonCacheDir ) ; PySystemState . initialize ( System . getProperties ( ) , jythonProperties , new String [ ] { " " } ) ; 
public void testLoading ( ) { TODO: Python initialization should happen lazily somewhere while loading the library. initJython(); Find the "<projectDirectory>/libraries/testlib" library. String projectDirectory = System.getProperty("user.dir"); File testlibPath = new File(projectDirectory + PlatformUtils.SEP + "libraries" + PlatformUtils.SEP + "testlib"); Create a library object. This is normally something handled by the NodeTypeLibraryManager. NodeTypeLibrary library; try { library = new NodeTypeLibrary("testlib", 1, 0, 0, testlibPath); } catch (IOException e) { fail("An exception occurred while loading library:" + e); return; } Load the library. This can throw a multitude of exceptions. library.load(); Check if everything's there. Number node type. NodeType numberType = library.getNodeType("number"); ParameterType ptValue = numberType.getParameterType("value"); assertEquals(ParameterType.Type.INT, ptValue.getType()); Check if the node executes. NodeType negateType = library.getNodeType("negate"); Node negateNode = negateType.createNode(); negateNode.set("value", 42); negateNode.update(); assertEquals(-42, negateNode.getOutputValue()); Check node with multiple parameters. NodeType addType = library.getNodeType("add"); Node addNode = addType.createNode(); addNode.set("v1", 50); addNode.set("v2", 3); addNode.update(); assertEquals(53, addNode.getOutputValue()); } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if ( getNetwork ( ) = = null ) return ; Object outputValue = getNetwork ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { ( ( Grob ) outputValue ) . draw ( g2 ) ; } Draw handle if (handle != null) { GraphicsContext ctx = new GraphicsContext(); 
public void mouseClicked ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseClicked ( e ) ; } 
public void mousePressed ( MouseEvent e ) { if ( handle = = null ) return ; handle . mousePressed ( e ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseReleased ( e ) ; } 
public void mouseEntered ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseEntered ( e ) ; } 
public void mouseExited ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseExited ( e ) ; } 
public void mouseDragged ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseDragged ( e ) ; } 
public void mouseMoved ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseMoved ( e ) ; } 
public void activeNodeChanged ( Node activeNode ) { setActiveNode ( activeNode ) ; } 
public BezierPath rect ( double x , double y , double width , double height ) { BezierPath p = new BezierPath ( ) ; p . addRect ( x , y , width , height ) ; TODO: Inherit from context canvas.add(p); return p; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } 
public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } 
public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } 
public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } } 
private Rectangle createRectangle ( double x , double y ) { int ix = ( int ) x ; int iy = ( int ) y ; return new Rectangle ( ix - HALF_HANDLE_SIZE , iy - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; } 
private void drawDot ( BezierPath p , double x , double y ) { p . addRect ( x - HALF_HANDLE_SIZE , y - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void draw ( GraphicsContext ctx ) { double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; double width = node . asFloat ( " width " ) ; double height = node . asFloat ( " height " ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( HANDLE_COLOR ) ; drawDot ( p , x , y ) ; drawDot ( p , x + width , y ) ; drawDot ( p , x + width , y + height ) ; drawDot ( p , x , y + height ) ; ctx . getCanvas ( ) . add ( p ) ; } 
public void mousePressed ( MouseEvent e ) { Point pt = e . getPoint ( ) ; px = e . getX ( ) ; py = e . getY ( ) ; ox = node . asFloat ( " x " ) ; oy = node . asFloat ( " y " ) ; owidth = node . asFloat ( " width " ) ; oheight = node . asFloat ( " height " ) ; Rectangle topLeft = createRectangle ( ox , oy ) ; Rectangle topRight = createRectangle ( ox + owidth , oy ) ; Rectangle bottomLeft = createRectangle ( ox , oy + oheight ) ; Rectangle bottomRight = createRectangle ( ox + owidth , oy + oheight ) ; Rectangle center = new Rectangle ( ( int ) ox , ( int ) oy , ( int ) owidth , ( int ) oheight ) ; if ( topLeft . contains ( pt ) ) { dragState = DragState . TOP_LEFT ; 
public void mouseDragged ( MouseEvent e ) { if ( dragState = = DragState . NONE ) return ; int x = e . getX ( ) ; int y = e . getY ( ) ; int dx = x - px ; int dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return ; switch ( dragState ) { case TOP_LEFT : 
public void mouseReleased ( MouseEvent e ) { dragState = DragState . NONE ; } 
public Node getNode ( ) ; public void draw ( GraphicsContext ctx ) ; } 
public void testConstructors ( ) { Color c = new Color ( 1 , 0 , 0 ) ; assertTrue ( c . isVisible ( ) ) ; assertEquals ( 1.0 , c . getAlpha ( ) ) ; } 
public void draw ( GraphicsContext ctx ) { double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; double width = node . asFloat ( " width " ) ; double height = node . asFloat ( " height " ) ; BezierPath cornerPath = new BezierPath ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0.0 ) ; drawDot ( cornerPath , x , y ) ; drawDot ( cornerPath , x + width , y ) ; drawDot ( cornerPath , x + width , y + height ) ; drawDot ( cornerPath , x , y + height ) ; ctx . getCanvas ( ) . add ( cornerPath ) ; BezierPath strokePath = new BezierPath ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . addRect ( x , y , width , height ) ; ctx . getCanvas ( ) . add ( strokePath ) ; } 
public void draw ( GraphicsContext ctx ) { double x = node . asFloat ( xName ) ; double y = node . asFloat ( yName ) ; double width = node . asFloat ( widthName ) ; double height = node . asFloat ( heightName ) ; BezierPath cornerPath = new BezierPath ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0.0 ) ; drawDot ( cornerPath , x , y ) ; drawDot ( cornerPath , x + width , y ) ; drawDot ( cornerPath , x + width , y + height ) ; drawDot ( cornerPath , x , y + height ) ; ctx . getCanvas ( ) . add ( cornerPath ) ; BezierPath strokePath = new BezierPath ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . addRect ( x , y , width , height ) ; ctx . getCanvas ( ) . add ( strokePath ) ; } 
public void mousePressed ( MouseEvent e ) { Point pt = e . getPoint ( ) ; px = e . getX ( ) ; py = e . getY ( ) ; ox = node . asFloat ( xName ) ; oy = node . asFloat ( yName ) ; owidth = node . asFloat ( widthName ) ; oheight = node . asFloat ( heightName ) ; Rectangle topLeft = createRectangle ( ox , oy ) ; Rectangle topRight = createRectangle ( ox + owidth , oy ) ; Rectangle bottomLeft = createRectangle ( ox , oy + oheight ) ; Rectangle bottomRight = createRectangle ( ox + owidth , oy + oheight ) ; Rectangle center = new Rectangle ( ( int ) ox , ( int ) oy , ( int ) owidth , ( int ) oheight ) ; if ( topLeft . contains ( pt ) ) { dragState = DragState . TOP_LEFT ; 
public Handle createHandle ( ) { return getNodeType ( ) . createHandle ( this ) ; } 
public Handle createHandle ( Node node ) { return new FourPointHandle ( node ) ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseMoved ( MouseEvent e ) { } Utility methods protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
protected Rectangle createHitRectangle ( double x , double y ) { int ix = ( int ) x ; int iy = ( int ) y ; return new Rectangle ( ix - HALF_HANDLE_SIZE , iy - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void mousePressed ( MouseEvent e ) { Point pt = e . getPoint ( ) ; px = e . getX ( ) ; py = e . getY ( ) ; ox = node . asFloat ( xName ) ; oy = node . asFloat ( yName ) ; owidth = node . asFloat ( widthName ) ; oheight = node . asFloat ( heightName ) ; Rectangle topLeft = createHitRectangle ( ox , oy ) ; Rectangle topRight = createHitRectangle ( ox + owidth , oy ) ; Rectangle bottomLeft = createHitRectangle ( ox , oy + oheight ) ; Rectangle bottomRight = createHitRectangle ( ox + owidth , oy + oheight ) ; Rectangle center = new Rectangle ( ( int ) ox , ( int ) oy , ( int ) owidth , ( int ) oheight ) ; if ( topLeft . contains ( pt ) ) { dragState = DragState . TOP_LEFT ; 
public void draw ( GraphicsContext ctx ) { double x = node . asFloat ( xName ) ; double y = node . asFloat ( yName ) ; BezierPath dot = new BezierPath ( ) ; dot . setFillColor ( HANDLE_COLOR ) ; dot . setStrokeWidth ( 0.0 ) ; dot . addRect ( x - HALF_HANDLE_SIZE , y - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; ctx . getCanvas ( ) . add ( dot ) ; } 
public void mousePressed ( MouseEvent e ) { Point pt = e . getPoint ( ) ; px = e . getX ( ) ; py = e . getY ( ) ; ox = node . asFloat ( xName ) ; oy = node . asFloat ( yName ) ; Rectangle hitRect = createHitRectangle ( ox , oy ) ; if ( hitRect . contains ( pt ) ) { dragging = true ; 
public void mouseDragged ( MouseEvent e ) { if ( ! dragging ) return ; int x = e . getX ( ) ; int y = e . getY ( ) ; int dx = x - px ; int dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return ; node . set ( xName , ox + dx ) ; node . set ( yName , oy + dy ) ; } 
public void mouseReleased ( MouseEvent e ) { dragging = false ; } 
public Handle createHandle ( Node node ) { return new PointHandle ( node , " tx " , " ty " ) ; } 
public void mouseReleased ( PInputEvent event ) { if ( isConnecting ) { if ( connectTarget ! = null ) connectTarget . repaint ( ) ; NodeView . this . repaint ( ) ; if ( connectSource ! = null & & connectTarget ! = null ) { java . util . List < Parameter > compatibleParameters = connectTarget . getNode ( ) . getCompatibleInputs ( connectSource . getNode ( ) ) ; if ( compatibleParameters . isEmpty ( ) ) { System . out . println ( " No compatible parameters " ) ; } else if ( compatibleParameters . size ( ) = = 1 ) { Only one possible connection, make it now. Parameter inputParameter = compatibleParameters.get(0); inputParameter.connect(connectSource.getNode()); } else { JPopupMenu menu = new JPopupMenu("Select input"); for (Parameter p : compatibleParameters) { Action a = new SelectCompatibleParameterAction(connectSource.getNode(), connectTarget.getNode(), p); menu.add(a); } Point pt = getNetworkView().getMousePosition(); menu.show(getNetworkView(), pt.x, pt.y); } } } isDragging = false; isConnecting = false; connectSource = null; connectTarget = null; } 
private boolean smartConnect ( Node activeNode , Node newNode ) { Check if there is an active node. if (activeNode == null) return false; Check if there are compatible parameters on the new node that can be connected to the output of the active node. List<Parameter> compatibles = newNode.getCompatibleInputs(activeNode); if (compatibles.size() == 0) return false; Connect the output of the active node to the first compatible input of the new node. compatibles.get(0).connect(activeNode); Move the node under the active node. newNode.setPosition(activeNode.getX(), activeNode.getY() + 40); Return true to indicate the connection was created successfully. return true; } 
public EditorDocument createNewDocument ( ) { EditorDocument doc = new EditorDocument ( ) ; doc . setVisible ( true ) ; documents . add ( doc ) ; currentDocument = doc ; return doc ; } 
public void run ( ) { instance = new EditorApplication ( ) ; } 
private void initMenu ( ) { JMenuBar menuBar = new JMenuBar ( ) ; JMenu pythonMenu = new JMenu ( " Python " ) ; pythonMenu . add ( new RunAction ( ) ) ; menuBar . add ( pythonMenu ) ; setJMenuBar ( menuBar ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { } } } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; context . getCanvas ( ) . draw ( g2 ) ; } 
private void addString ( String s ) { try { feedbackArea . getDocument ( ) . insertString ( feedbackArea . getDocument ( ) . getLength ( ) , s , null ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("ctx", context); interpreter.set("BezierPath", net.nodebox.graphics.BezierPath.class); interpreter.set("Canvas", net.nodebox.graphics.Canvas.class); interpreter.set("Color", net.nodebox.graphics.Color.class); interpreter.set("GraphicsContext", net.nodebox.graphics.GraphicsContext.class); interpreter.set("Grob", net.nodebox.graphics.Grob.class); interpreter.set("Group", net.nodebox.graphics.Group.class); interpreter.set("Image", net.nodebox.graphics.Image.class); interpreter.set("NodeBoxError", net.nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", net.nodebox.graphics.PathElement.class); interpreter.set("Point", net.nodebox.graphics.Point.class); interpreter.set("Rect", net.nodebox.graphics.Rect.class); interpreter.set("Text", net.nodebox.graphics.Text.class); interpreter.set("Transform", net.nodebox.graphics.Transform.class); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
public void moveto ( double x , double y ) { elements . add ( new PathElement ( PathElement . MOVETO , x , y ) ) ; needsMoveto = false ; dirty = true ; } 
public void lineto ( double x , double y ) { if ( needsMoveto ) throw new NodeBoxError ( " Lineto without first doing moveto. " ) ; elements . add ( new PathElement ( PathElement . LINETO , x , y ) ) ; dirty = true ; } 
public void quadto ( double x1 , double y1 , double x2 , double y2 ) { if ( needsMoveto ) throw new NodeBoxError ( " Quadto without first doing moveto. " ) ; PathElement lastElement = elements . get ( elements . size ( ) - 1 ) ; double lastX = lastElement . getX ( ) ; double lastY = lastElement . getY ( ) ; double c1x = lastX + ( x1 - lastX ) * 2 / 3 ; double c1y = lastY + ( y1 - lastY ) * 2 / 3 ; double c2x = x2 - ( x2 - x1 ) * 2 / 3 ; double c2y = y2 - ( y2 - y1 ) * 2 / 3 ; curveto ( c1x , c1y , c2x , c2y , x2 , y2 ) ; } 
public void curveto ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { if ( needsMoveto ) throw new NodeBoxError ( " Curveto without first doing moveto. " ) ; elements . add ( new PathElement ( PathElement . CURVETO , x1 , y1 , x2 , y2 , x3 , y3 ) ) ; dirty = true ; } 
public void close ( ) { elements . add ( new PathElement ( PathElement . CLOSE ) ) ; After the path is closed, we need a new moveto to start a new path segment. needsMoveto = true; dirty = true; } 
public void addText ( String text , String fontName , double fontSize , double lineHeight , Text . Align align , double x , double y ) { addText ( text , fontName , fontSize , lineHeight , align , x , y , Double . MAX_VALUE , Double . MAX_VALUE ) ; } 
public void addText ( String text , String fontName , double fontSize , double lineHeight , Text . Align align , double x , double y , double width ) { addText ( text , fontName , fontSize , lineHeight , align , x , y , width , Double . MAX_VALUE ) ; } 
public void addText ( String text , String fontName , double fontSize , double lineHeight , Text . Align align , double x , double y , double width , double height ) { Text = new Text ( text , x , y , width , height ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; extend ( . getPath ( ) ) ; } 
public void draw ( Graphics2D g ) { g . setColor ( background . getAwtColor ( ) ) ; g . fillRect ( 0 , 0 , ( int ) width , ( int ) height ) ; Rectangle clip = g . getClipBounds ( ) ; int clipwidth = width > clip . width ? clip . width : ( int ) width ; int clipheight = height > clip . height ? clip . height : ( int ) height ; g . setClip ( clip . x , clip . y , clipwidth , clipheight ) ; super . draw ( g ) ; } 
public void resetContext ( ) { fillColor = new Color ( ) ; strokeColor = null ; strokeWidth = 1.0 ; canvas . setBackground ( new Color ( 1 , 1 , 1 ) ) ; path = null ; transform = new Transform ( ) ; transformStack = new ArrayList < Transform > ( ) ; fontName = " Helvetica " ; fontSize = 24 ; lineHeight = 1.2 ; align = Text . Align . LEFT ; } 
public void size ( double width , double height ) { canvas . setWidth ( width ) ; canvas . setHeight ( height ) ; } 
public BezierPath rect ( double x , double y , double width , double height ) { BezierPath p = new BezierPath ( ) ; p . addRect ( x , y , width , height ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath rect ( double x , double y , double width , double height , double roundness ) { BezierPath p = new BezierPath ( ) ; p . addRoundedRect ( x , y , width , height , roundness , roundness ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath oval ( double x , double y , double width , double height ) { TODO: Deprecation warning return ellipse(x, y, width, height); } 
public BezierPath ellipse ( double x , double y , double width , double height ) { BezierPath p = new BezierPath ( ) ; p . addEllipse ( x , y , width , height ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath line ( double x1 , double y1 , double x2 , double y2 ) { BezierPath p = new BezierPath ( ) ; p . addLine ( x1 , y1 , x2 , y2 ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public void beginPath ( ) { path = new BezierPath ( ) ; pathClosed = false ; } 
public void beginPath ( double x , double y ) { beginPath ( ) ; moveto ( x , y ) ; } 
public void moveto ( double x , double y ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; path . moveto ( x , y ) ; } 
public void lineto ( double x , double y ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; path . lineto ( x , y ) ; } 
public void curveto ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; path . curveto ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } 
public void closePath ( ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; if ( ! pathClosed ) { path . close ( ) ; 
public BezierPath endPath ( boolean draw ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; if ( autoClosePath ) closePath ( ) ; BezierPath p = path ; inheritFromContext ( p ) ; if ( draw ) canvas . add ( p ) ; Initialize a new path path = null; pathClosed = false; return p; } 
public void drawPath ( BezierPath path ) { inheritFromContext ( path ) ; canvas . add ( path ) ; } 
public boolean isAutoClosePath ( ) { return autoClosePath ; } 
public BezierPath findPath ( List < Point > points ) { return findPath ( points , 1 ) ; } 
public BezierPath findPath ( List < Point > points , double curvature ) { throw new RuntimeException ( " Not implemented yet " ) ; } 
public void push ( ) { transformStack . add ( 0 , transform . clone ( ) ) ; } 
public void pop ( ) { if ( transformStack . size ( ) = = 0 ) throw new NodeBoxError ( " Pop: too many pops! " ) ; transform = transformStack . get ( 0 ) ; transformStack . remove ( 0 ) ; } 
public Text text ( String text , double x , double y ) { return text ( text , x , y , Double . MAX_VALUE , Double . MAX_VALUE ) ; } 
public Text text ( String text , double x , double y , double width ) { return text ( text , x , y , width , Double . MAX_VALUE ) ; } 
public Text text ( String text , double x , double y , double width , double height ) { Text = new Text ( text , x , y , width , height ) ; inheritFromContext ( ) ; canvas . add ( ) ; return ; } 
public BezierPath textPath ( String text , double x , double y ) { return textPath ( text , x , y , Double . MAX_VALUE , Double . MAX_VALUE ) ; } 
public BezierPath textPath ( String text , double x , double y , double width ) { return textPath ( text , x , y , width , Double . MAX_VALUE ) ; } 
public BezierPath textPath ( String text , double x , double y , double width , double height ) { BezierPath p = new BezierPath ( ) ; p . addText ( text , fontName , fontSize , lineHeight , align , x , y , width , height ) ; inheritFromContext ( p ) ; return p ; } 
public Rect textMetrics ( String text ) { return textMetrics ( text , Double . MAX_VALUE , Double . MAX_VALUE ) ; } 
public Rect textMetrics ( String text , double width ) { return textMetrics ( text , width , Double . MAX_VALUE ) ; } 
public Rect textMetrics ( String text , double width , double height ) { Text = new Text ( text , 0 , 0 , width , height ) ; inheritFromContext ( ) ; return . getMetrics ( ) ; } 
public Image image ( String path , double x , double y ) { Image img = new Image ( path ) ; img . setX ( x ) ; img . setY ( y ) ; canvas . add ( img ) ; return img ; } 
public Size imageSize ( String path ) { Image img = new Image ( path ) ; return img . getSize ( ) ; } 
private void inheritFromContext ( BezierPath p ) { p . setTransform ( transform ) ; p . setFillColor ( fillColor ) ; p . setStrokeColor ( strokeColor ) ; p . setStrokeWidth ( strokeWidth ) ; } 
private void inheritFromContext ( Text ) { . setTransform ( transform ) ; . setFillColor ( fillColor ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; } 
public void draw ( Graphics2D g ) { double srcW = image . getWidth ( ) ; double srcH = image . getHeight ( ) ; Width or height given if (desiredWidth != 0 || desiredHeight != 0) { double factor; 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Size ) ) return false ; Size sz = ( Size ) o ; return width = = sz . width & & height = = sz . height ; } 
public String toString ( ) { return " Size( " + width + " , " + height + " ) " ; } 
public void draw ( Graphics2D g ) { if ( text = = null | | text . length ( ) = = 0 ) return ; g.setColor(fillColor.getAwtColor()); getTextLayout().draw(g, (float) baseLineX, (float) baseLineY); TextLayoutIterator iterator = new TextLayoutIterator(); while (iterator.hasNext()) { TextLayout layout = iterator.next(); 
public boolean hasNext ( ) { return measurer . getPosition ( ) < text . length ( ) ; } 
public void remove ( ) { throw new AssertionError ( " This operation is not implemented " ) ; } 
public void testInheritFromContext ( ) { GraphicsContext ctx = new GraphicsContext ( ) ; Color c = new Color ( ) ; assertEquals ( c , ctx . getFillColor ( ) ) ; ctx . rect ( 0 , 0 , 100 , 100 ) ; BezierPath p = ( BezierPath ) ctx . getCanvas ( ) . getGrobs ( ) . get ( 0 ) ; assertEquals ( c , p . getFillColor ( ) ) ; Color red = new Color ( 1 , 0 , 0 ) ; ctx . setFillColor ( red ) ; ctx . setAlign ( Text . Align . RIGHT ) ; Text = ctx . text ( " hello " , 20 , 20 ) ; assertEquals ( red , . getFillColor ( ) ) ; assertEquals ( Text . Align . RIGHT , . getAlign ( ) ) ; } 
public void quadto ( double x1 , double y1 , double x2 , double y2 ) { if ( needsMoveto ) throw new NodeBoxError ( " Quadto without first doing moveto. " ) ; PathElement lastElement = elements . get ( elements . size ( ) - 1 ) ; We don't support quads natively, but we accept them and convert them to a cubic bezier. double lastX = lastElement.getX(); double lastY = lastElement.getY(); double c1x = lastX + (x1 - lastX) * 2 / 3; double c1y = lastY + (y1 - lastY) * 2 / 3; double c2x = x2 - (x2 - x1) * 2 / 3; double c2y = y2 - (y2 - y1) * 2 / 3; curveto(c1x, c1y, c2x, c2y, x2, y2); } 
public static double lineLength ( double x0 , double y0 , double x1 , double y1 ) { x0 = Math . abs ( x0 - x1 ) ; x0 * = x0 ; y0 = Math . abs ( y0 - y1 ) ; y0 * = y0 ; return Math . sqrt ( x0 + y0 ) ; } 
public static Point linePoint ( double , double x0 , double y0 , double x1 , double y1 ) { return new Point ( x0 + * ( x1 - x0 ) , 
public static double curveLength ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { return curveLength ( x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 , 20 ) ; } 
public static double curveLength ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 , int ) { double length = 0 ; double xi = x0 ; double yi = x1 ; double ; double px , py ; double tmpX , tmpY ; for ( int i = 0 ; i < ; i + + ) { = ( i + 1 ) / ( double ) ; Point pt = curvePoint ( , x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 ) ; px = pt . getX ( ) ; py = pt . getY ( ) ; tmpX = Math . abs ( xi - px ) ; tmpX * = tmpX ; tmpY = Math . abs ( yi - py ) ; tmpY * = tmpY ; length + = Math . sqrt ( tmpX + tmpY ) ; xi = px ; yi = py ; } return length ; } 
public static Point curvePoint ( double , double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double mint = 1 - ; double x01 = x0 * mint + x1 * ; double y01 = y0 * mint + y1 * ; double x12 = x1 * mint + x2 * ; double y12 = y1 * mint + y2 * ; double x23 = x2 * mint + x3 * ; double y23 = y2 * mint + y3 * ; double out_c1x = x01 * mint + x12 * ; double out_c1y = y01 * mint + y12 * ; double out_c2x = x12 * mint + x23 * ; double out_c2y = y12 * mint + y23 * ; double out_x = out_c1x * mint + out_c2x * ; double out_y = out_c1y * mint + out_c2y * ; return new Point ( out_x , out_y ) ; } 
public double [ ] calculateSegmentLengths ( ) { return calculateSegmentLengths ( 20 ) ; } 
public void removeDocument ( NodeBoxDocument document ) { documents . remove ( document ) ; } 
public NodeBoxDocument createNewDocument ( ) { NodeBoxDocument doc = new NodeBoxDocument ( ) ; doc . setVisible ( true ) ; documents . add ( doc ) ; currentDocument = doc ; return doc ; } 
private void init ( ) { this . setMargin ( new Insets ( 0 , 5 , 0 , 5 ) ) ; setFont ( PlatformUtils . getEditorFont ( ) ) ; setEditorKit ( new PythonEditorKit ( ) ) ; rootElement = getDocument ( ) . getDefaultRootElement ( ) ; todo:this code should be in the kit getInputMap().put(PlatformUtils.getKeyStroke(KeyEvent.VK_UP), DefaultEditorKit.beginAction); getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), PythonEditorKit.returnAction); getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0), PythonEditorKit.tabAction); getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, Event.SHIFT_MASK), PythonEditorKit.dedentAction); getInputMap().put(PlatformUtils.getKeyStroke('['), PythonEditorKit.dedentAction); getInputMap().put(PlatformUtils.getKeyStroke(']'), PythonEditorKit.indentAction); getInputMap().put(PlatformUtils.getKeyStroke(KeyEvent.VK_DOWN), DefaultEditorKit.endAction); getInputMap().put(PlatformUtils.getKeyStroke(KeyEvent.VK_UP, Event.SHIFT_MASK), DefaultEditorKit.selectionBeginAction); getInputMap().put(PlatformUtils.getKeyStroke(KeyEvent.VK_DOWN, Event.SHIFT_MASK), DefaultEditorKit.selectionEndAction); addMouseListener(new DragDetector()); } 
public boolean find ( String text ) { There is a difference between the last searched string and the current find string. The last searched is the last typed find, whereas the current find is either the last typed *or* the selected text. Selected text is not saved as the last find. String selectedText = getSelectedText(); if (text != null && !text.equals(selectedText)) { lastSearchString = text; } currentSearchString = text; return find(text, 0); } 
public boolean findAgain ( ) { return find ( currentSearchString , getCaretPosition ( ) + 1 ) ; } 
public boolean find ( String text , int fromPos ) { int index = getText ( ) . indexOf ( text , fromPos ) ; if ( index > = 0 ) { setCaretPosition ( index - 1 ) ; moveCaretPosition ( index + text . length ( ) - 1 ) ; scrollToPos ( index ) ; return true ; } return false ; } 
public boolean goToLine ( int line ) { int offset = getOffsetForLine ( line ) ; if ( offset > = 0 ) { setCaretPosition ( offset ) ; scrollToPos ( offset ) ; return true ; } return false ; } 
public boolean scrollToPos ( int index ) { try { todo: FIX scrolling to half of view, so line is in the middle of the view. 
public void mouseDragged ( MouseEvent e ) { super . mouseDragged ( e ) ; } 
public void mousePressed ( MouseEvent e ) { if ( ( e . getModifiersEx ( ) & BTN1_CTRL_MASK ) ! = BTN1_CTRL_MASK ) return ; LOG . info ( " mouse pressed at " + e . getPoint ( ) ) ; int index = viewToModel ( e . getPoint ( ) ) ; Returns the correct coordinate. String text = getText(); int[] range = StringUtils.numberRange(text, index); if (range == null) return; int left = range[0]; int right = range[1]; String number = StringUtils.numberForRange(text, range); LOG.info("The number is " + number); try { value = Float.parseFloat(number); } catch (NumberFormatException ex) { LOG.log(Level.WARNING, "parsing gave error: " + number, ex); } try { Get position of rightmost character of the number. 
public void mouseReleased ( MouseEvent e ) { if ( dragWindow . isVisible ( ) ) { dragWindow . setVisible ( false ) ; 
public void mouseDragged ( MouseEvent e ) { int newX = e . getX ( ) ; float delta = newX - prevX ; LOG . info ( " prev " + prevX + " newX " + newX + " delta " + delta ) ; if ((e.getModifiersEx() & BTN1_CTRL_ALT_MASK) == BTN1_CTRL_ALT_MASK) delta /= 100; if ((e.getModifiersEx() & BTN1_CTRL_SHIFT_MASK) == BTN1_CTRL_SHIFT_MASK) delta *= 10; value += delta; dragLabel.setText("" + value); prevX = newX; e.consume(); } 
private void initMenu ( ) { JMenuBar menuBar = new JMenuBar ( ) ; Edit JMenu editMenu = new JMenu("Edit"); editMenu.add(undoAction); editMenu.add(redoAction); editMenu.addSeparator(); menuBar.add(editMenu); Python JMenu pythonMenu = new JMenu("Python"); pythonMenu.add(new RunAction()); menuBar.add(pythonMenu); setJMenuBar(menuBar); } 
public static void open ( File file ) { lastFilePath = file . getParentFile ( ) . getAbsolutePath ( ) ; NodeBoxDocument doc = Application . getInstance ( ) . createNewDocument ( ) ; if ( doc . readFromFile ( file ) ) { doc . setDocumentFile ( file ) ; } addRecentFile ( file ) ; } 
public void quit ( ) { boolean allClosed = true ; Because documents will disappear from the list once they are closed, make a copy of the list. java.util.List<NodeBoxDocument> documents = new ArrayList<NodeBoxDocument>(Application.getInstance().getDocuments()); for (NodeBoxDocument d : documents) { allClosed = allClosed && d.shouldClose(); } if (allClosed) { System.exit(0); 
public void actionPerformed ( ActionEvent e ) { File chosenFile = FileUtils . showOpenDialog ( NodeBoxDocument . this , lastFilePath , " ndbx " , " NodeBox Document " ) ; if ( chosenFile ! = null ) { open ( chosenFile ) ; 
public Document createDefaultDocument ( ) { SyntaxDocument doc = new SyntaxDocument ( ) ; doc . setTokenMarker ( tokenMarker ) ; return doc ; } 
public static String indent ( String line ) { return getIndent ( line ) + FOUR_SPACE + stripIndent ( line ) ; } 
public static void indent ( Document doc , int lineNum ) { String line = getLineForLineNum ( doc , lineNum ) ; int offs = getOffsetForLine ( doc , lineNum ) + getIndentForLine ( doc , lineNum ) . length ( ) ; try { doc . insertString ( offs , FOUR_SPACE , null ) ; 
public static String dedent ( String line ) { int [ ] metrics = getDedentMetrics ( line ) ; String begin = line . substring ( 0 , metrics [ 0 ] ) ; String rest = line . substring ( metrics [ 0 ] + metrics [ 1 ] ) ; return begin + rest ; } 
public static void dedent ( Document doc , int lineNum ) { String line = getLineForLineNum ( doc , lineNum ) ; int [ ] metrics = getDedentMetrics ( line ) ; try { doc . remove ( getOffsetForLine ( doc , lineNum ) + metrics [ 0 ] , metrics [ 1 ] ) ; 
public static String stripIndent ( Document doc , int offs ) { String line = getLineForOffset ( doc , offs ) ; return stripIndent ( line ) ; } 
public static String stripIndent ( String line ) { int i = 0 ; while ( i < line . length ( ) ) { char c = line . charAt ( i ) ; if ( c = = ' ' | | c = = '' ) { i + + ; } else { break ; } } return line . substring ( i ) ; } 
public void actionPerformed ( ActionEvent e ) { JTextComponent target = getTextComponent ( e ) ; boolean beep = true ; if ( ( target ! = null ) & & ( target . isEditable ( ) ) ) { try { Document doc = target . getDocument ( ) ; Caret caret = target . getCaret ( ) ; int dot = caret . getDot ( ) ; int mark = caret . getMark ( ) ; if ( dot ! = mark ) { doc . remove ( Math . min ( dot , mark ) , Math . abs ( dot - mark ) ) ; beep = false ; } else if ( dot > 0 ) { int delChars = 1 ; todo: tab-deletion Find fake tabs and delete them A fake tab is always in the beginning of the line (the indent), so we should be near or inside the indent. Then, if there are four space characters, that's the tab, and you can delete them all. if (dot > 1) { String dotChars = doc.getText(dot - 2, 2); char c0 = dotChars.charAt(0); char c1 = dotChars.charAt(1); if (c0 >= '\uD800' && c0 <= '\uDBFF' && c1 >= '\uDC00' && c1 <= '\uDFFF') { delChars = 2; } } doc.remove(dot - delChars, delChars); beep = false; } } catch (BadLocationException bl) { } } if (beep) { UIManager.getLookAndFeel().provideErrorFeedback(target); 
public void actionPerformed ( ActionEvent e ) { JTextComponent target = getTextComponent ( e ) ; if ( ( target ! = null ) & & ( target . isEditable ( ) ) ) { int offs = target . getCaretPosition ( ) ; 
public void actionPerformed ( ActionEvent e ) { JTextComponent target = getTextComponent ( e ) ; if ( ( target ! = null ) & & ( target . isEditable ( ) ) ) { Document doc = target . getDocument ( ) ; 
public void apply ( NodeBoxDocument document ) { } public void extract ( NodeBoxDocument document ) { document . getContentPane ( ) ; } public class Component { } public class Panel extends Component { private Class panelClass ; public Panel ( Class panelClass ) { this . panelClass = panelClass ; } } public class Split extends Component { private Component leftComponent ; private Component rightComponent ; private int direction ; private double position ; public Split ( Component leftComponent , Component rightComponent , int direction , double position ) { this . leftComponent = leftComponent ; this . rightComponent = rightComponent ; this . direction = direction ; this . position = position ; } } } 
public void extract ( NodeBoxDocument document ) { document . getContentPane ( ) ; } 
public byte lookup ( Segment text , int offset , int length ) { if ( length = = 0 ) return Token . NULL ; Keyword k = map [ getSegmentMapKey ( text , offset , length ) ] ; while ( k ! = null ) { if ( length ! = k . keyword . length ) { k = k . next ; continue ; } if ( SyntaxUtilities . regionMatches ( ignoreCase , text , offset , k . keyword ) ) return k . id ; k = k . next ; } return Token . NULL ; } 
public void add ( String keyword , byte id ) { int key = getStringMapKey ( keyword ) ; map [ key ] = new Keyword ( keyword . toCharArray ( ) , id , map [ key ] ) ; } 
public byte markTokensImpl ( byte token , Segment line , int lineIndex ) { char [ ] array = line . array ; int offset = line . offset ; lastOffset = offset ; lastKeyword = offset ; lastWhitespace = offset - 1 ; int length = line . count + offset ; boolean backslash = false ; loop : for ( int i = offset ; i < length ; i + + ) { int i1 = ( i + 1 ) ; char c = array [ i ] ; if ( c = = '\\' ) { backslash = ! backslash ; continue ; } switch ( token ) { case Token . NULL : switch ( c ) { case '(' : if ( backslash ) { doKeyword ( line , i , c ) ; backslash = false ; } else { if ( doKeyword ( line , i , c ) ) break ; addToken ( lastWhitespace - lastOffset + 1 , token ) ; addToken ( i - lastWhitespace - 1 , Token . METHOD ) ; addToken ( 1 , Token . NULL ) ; token = Token . NULL ; lastOffset = lastKeyword = i1 ; lastWhitespace = i ; } break ; case '#' : if ( backslash ) backslash = false ; else { doKeyword ( line , i , c ) ; addToken ( i - lastOffset , token ) ; addToken ( length - i , Token . COMMENT1 ) ; lastOffset = lastKeyword = length ; break loop ; } break ; case '"' : doKeyword ( line , i , c ) ; if ( backslash ) backslash = false ; else { addToken ( i - lastOffset , token ) ; if ( SyntaxUtilities . regionMatches ( false , line , i1 , " \" \" " ) ) { lastOffset = lastKeyword = i ; i + = 3 ; token = TRIPLEQUOTE1 ; } else { token = Token . LITERAL1 ; lastOffset = lastKeyword = i ; } } break ; case '\'' : doKeyword ( line , i , c ) ; if ( backslash ) backslash = false ; else { addToken ( i - lastOffset , token ) ; if ( SyntaxUtilities . regionMatches ( false , line , i1 , " '' " ) ) { lastOffset = lastKeyword = i ; i + = 3 ; token = TRIPLEQUOTE2 ; } else { token = Token . LITERAL2 ; lastOffset = lastKeyword = i ; } } break ; default : backslash = false ; if ( ! Character . isLetterOrDigit ( c ) & & c ! = '_' ) doKeyword ( line , i , c ) ; if ( METHOD_DELIMITERS . indexOf ( c ) ! = - 1 ) { lastWhitespace = i ; } break ; } break ; case Token . LITERAL1 : if ( backslash ) backslash = false ; else if ( c = = '"' ) { addToken ( i1 - lastOffset , token ) ; token = Token . NULL ; lastOffset = lastKeyword = i1 ; } break ; case Token . LITERAL2 : if ( backslash ) backslash = false ; else if ( c = = '\'' ) { addToken ( i1 - lastOffset , Token . LITERAL1 ) ; token = Token . NULL ; lastOffset = lastKeyword = i1 ; } break ; case TRIPLEQUOTE1 : if ( SyntaxUtilities . regionMatches ( false , line , i , " \" \" \" " ) ) { addToken ( ( i + = 3 ) - lastOffset , Token . LITERAL2 ) ; token = Token . NULL ; lastOffset = lastKeyword = i ; } break ; case TRIPLEQUOTE2 : if ( SyntaxUtilities . regionMatches ( false , line , i , " ''' " ) ) { addToken ( ( i + = 3 ) - lastOffset , Token . LITERAL2 ) ; token = Token . NULL ; lastOffset = lastKeyword = i ; } break ; default : throw new InternalError ( " Invalid state: " + token ) ; } } switch ( token ) { case Token . LITERAL1 : case Token . LITERAL2 : addToken ( length - lastOffset , Token . INVALID ) ; token = Token . NULL ; break ; case TRIPLEQUOTE1 : case TRIPLEQUOTE2 : addToken ( length - lastOffset , Token . LITERAL2 ) ; break ; case Token . NULL : doKeyword ( line , length , '\0' ) ; default : addToken ( length - lastOffset , token ) ; break ; } return token ; } 
private boolean doKeyword ( Segment line , int i , char c ) { int i1 = i + 1 ; int len = i - lastKeyword ; byte id = keywords . lookup ( line , lastKeyword , len ) ; if ( id ! = Token . NULL ) { if ( lastKeyword ! = lastOffset ) addToken ( lastKeyword - lastOffset , Token . NULL ) ; addToken ( len , id ) ; lastOffset = i ; lastWhitespace = i1 ; lastKeyword = i1 ; return true ; } lastKeyword = i1 ; return false ; } 
protected void drawLine ( int lineIndex , Graphics g , int x , int y ) { Document document = getDocument ( ) ; JTextComponent jtc ; int posStart = ( jtc = ( JTextComponent ) getContainer ( ) ) . getSelectionStart ( ) ; int posEnd = jtc . getSelectionEnd ( ) ; Element element = getElement ( ) . getElement ( lineIndex ) ; int beginOfLine = element . getStartOffset ( ) ; int endOfLine = element . getEndOffset ( ) ; g . setColor ( getForeground ( ) ) ; try { document . getText ( beginOfLine , endOfLine - ( beginOfLine + 1 ) , segment ) ; 
public View create ( Element elem ) { return new SyntaxColoredView ( elem ) ; } 
public void tokenizeLines ( ) { tokenizeLines ( 0 , getDefaultRootElement ( ) . getElementCount ( ) ) ; } 
public void tokenizeLines ( int start , int len ) { if ( tokenMarker = = null | | ! tokenMarker . supportsMultilineTokens ( ) ) return ; Segment lineSegment = new Segment ( ) ; Element map = getDefaultRootElement ( ) ; len + = start ; try { for ( int i = start ; i < len ; i + + ) { 
public void beginCompoundEdit ( ) { } 
public void endCompoundEdit ( ) { } 
public void addUndoableEdit ( UndoableEdit edit ) { } protected members protected TokenMarker tokenMarker; 
protected void fireInsertUpdate ( DocumentEvent evt ) { if ( tokenMarker ! = null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch ! = null ) { tokenMarker . insertLines ( ch . getIndex ( ) + 1 , ch . getChildrenAdded ( ) . length - ch . getChildrenRemoved ( ) . length ) ; } } super . fireInsertUpdate ( evt ) ; } 
protected void fireRemoveUpdate ( DocumentEvent evt ) { if ( tokenMarker ! = null ) { DocumentEvent . ElementChange ch = evt . getChange ( getDefaultRootElement ( ) ) ; if ( ch ! = null ) { tokenMarker . deleteLines ( ch . getIndex ( ) + 1 , ch . getChildrenRemoved ( ) . length - ch . getChildrenAdded ( ) . length ) ; } } super . fireRemoveUpdate ( evt ) ; } 
public String toString ( ) { return getClass ( ) . getName ( ) + " [color= " + color + ( italic ? " ,italic " : " " ) + 
public static boolean regionMatches ( boolean ignoreCase , Segment text , int offset , String match ) { int length = offset + match . length ( ) ; char [ ] textArray = text . array ; if ( length > text . offset + text . count ) return false ; for ( int i = offset , j = 0 ; i < length ; i + + , j + + ) { char c1 = textArray [ i ] ; char c2 = match . charAt ( j ) ; if ( ignoreCase ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; } if ( c1 ! = c2 ) return false ; } return true ; } 
public static boolean regionMatches ( boolean ignoreCase , Segment text , int offset , char [ ] match ) { int length = offset + match . length ; char [ ] textArray = text . array ; if ( length > text . offset + text . count ) return false ; for ( int i = offset , j = 0 ; i < length ; i + + , j + + ) { char c1 = textArray [ i ] ; char c2 = match [ j ] ; if ( ignoreCase ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; } if ( c1 ! = c2 ) return false ; } return true ; } 
public static int paintSyntaxLine ( Segment line , Token tokens , SyntaxStyle [ ] styles , TabExpander expander , Graphics gfx , int x , int y ) { Font defaultFont = gfx . getFont ( ) ; Color defaultColor = gfx . getColor ( ) ; int offset = 0 ; for ( ; ; ) { byte id = tokens . id ; if ( id = = Token . END ) break ; int length = tokens . length ; if ( id = = Token . NULL ) { if ( ! defaultColor . equals ( gfx . getColor ( ) ) ) gfx . setColor ( defaultColor ) ; if ( ! defaultFont . equals ( gfx . getFont ( ) ) ) gfx . setFont ( defaultFont ) ; } else styles [ id ] . setGraphicsFlags ( gfx , defaultFont ) ; line . count = length ; x = Utilities . drawTabbedText ( line , x , y , gfx , expander , 0 ) ; line . offset + = length ; offset + = length ; tokens = tokens . next ; } return x ; } 
public String toString ( ) { return " [id= " + id + " ,length= " + length + " ] " ; } 
public Token markTokens ( Segment line , int lineIndex ) { if ( lineIndex > = length ) { throw new IllegalArgumentException ( " Tokenizing invalid line: " + lineIndex ) ; } lastToken = null ; LineInfo info = lineInfo [ lineIndex ] ; LineInfo prev ; if ( lineIndex = = 0 ) prev = null ; else prev = lineInfo [ lineIndex - 1 ] ; byte oldToken = info . token ; byte token = markTokensImpl ( prev = = null ? Token . NULL : prev . token , line , lineIndex ) ; info . token = token ; if ( ! ( lastLine = = lineIndex & & nextLineRequested ) ) nextLineRequested = ( oldToken ! = token ) ; lastLine = lineIndex ; addToken ( 0 , Token . END ) ; return firstToken ; } 
public boolean supportsMultilineTokens ( ) { return true ; } 
public void insertLines ( int index , int lines ) { if ( lines < = 0 ) return ; length + = lines ; ensureCapacity ( length ) ; int len = index + lines ; System . arraycopy ( lineInfo , index , lineInfo , len , lineInfo . length - len ) ; for ( int i = index + lines - 1 ; i > = index ; i - - ) { lineInfo [ i ] = new LineInfo ( ) ; 
public void deleteLines ( int index , int lines ) { if ( lines < = 0 ) return ; int len = index + lines ; length - = lines ; System . arraycopy ( lineInfo , len , lineInfo , index , lineInfo . length - len ) ; 
public boolean isNextLineRequested ( ) { return nextLineRequested ; } 
protected void ensureCapacity ( int index ) { if ( lineInfo = = null ) lineInfo = new LineInfo [ index + 1 ] ; 
protected void addToken ( int length , byte id ) { addToken ( length , id , false ) ; } 
protected void addToken ( int length , byte id , boolean highlightBackground ) { if ( id > = Token . INTERNAL_FIRST & & id < = Token . INTERNAL_LAST ) throw new InternalError ( " Invalid id: " + id ) ; if ( length < = 0 & & id ! = Token . END ) return ; if ( firstToken = = null ) { firstToken = new Token ( length , id ) ; lastToken = firstToken ; } else if ( lastToken = = null ) { lastToken = firstToken ; firstToken . length = length ; firstToken . id = id ; } else if ( lastToken . next = = null ) { lastToken . next = new Token ( length , id ) ; lastToken = lastToken . next ; } else { lastToken = lastToken . next ; lastToken . length = length ; lastToken . id = id ; } lastToken . highlightBackground = highlightBackground ; } 
public static String join ( List items , String separator ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < items . size ( ) ; i + + ) { boolean lastItem = i = = items . size ( ) - 1 ; sb . append ( items . get ( i ) ) ; if ( ! lastItem ) { sb . append ( separator ) ; } } return sb . toString ( ) ; } 
public static int [ ] numberRange ( String text , int index ) { if ( index < 0 | | index > = text . length ( ) ) return null ; if ( ! isNumeric ( text . charAt ( index ) ) ) return null ; int left = index ; int right = index ; Left edge while (left > 0 && isNumeric(text.charAt(left - 1))) { left--; } Right edge while (right < text.length() - 1 && isNumeric(text.charAt(right + 1))) { right++; } return new int[]{left, right}; } 
public static String numberForRange ( String text , int [ ] numberRange ) { substring returns a string that doesn't contain the end character, so add one to the range. return text.substring(numberRange[0], numberRange[1] + 1); } 
public static boolean isNumeric ( char c ) { return c > = '0' & & c < = '9' ; } 
public static double curveLength ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 , int ) { double length = 0 ; double xi = x0 ; double yi = y0 ; double ; double px , py ; double tmpX , tmpY ; for ( int i = 0 ; i < ; i + + ) { = ( i + 1 ) / ( double ) ; Point pt = curvePoint ( , x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 ) ; px = pt . getX ( ) ; py = pt . getY ( ) ; tmpX = Math . abs ( xi - px ) ; tmpX * = tmpX ; tmpY = Math . abs ( yi - py ) ; tmpY * = tmpY ; length + = Math . sqrt ( tmpX + tmpY ) ; xi = px ; yi = py ; } return length ; } 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.resetContext(); context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("ctx", context); interpreter.set("BezierPath", net.nodebox.graphics.BezierPath.class); interpreter.set("Canvas", net.nodebox.graphics.Canvas.class); interpreter.set("Color", net.nodebox.graphics.Color.class); interpreter.set("GraphicsContext", net.nodebox.graphics.GraphicsContext.class); interpreter.set("Grob", net.nodebox.graphics.Grob.class); interpreter.set("Group", net.nodebox.graphics.Group.class); interpreter.set("Image", net.nodebox.graphics.Image.class); interpreter.set("NodeBoxError", net.nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", net.nodebox.graphics.PathElement.class); interpreter.set("Point", net.nodebox.graphics.Point.class); interpreter.set("Rect", net.nodebox.graphics.Rect.class); interpreter.set("Text", net.nodebox.graphics.Text.class); interpreter.set("Transform", net.nodebox.graphics.Transform.class); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; if ( fillColor ! = null & & fillColor . isVisible ( ) ) { g . setColor ( fillColor . getAwtColor ( ) ) ; g . fill ( getGeneralPath ( ) ) ; } if ( strokeWidth > 0 & & strokeColor ! = null & & strokeColor . isVisible ( ) ) { g . setColor ( strokeColor . getAwtColor ( ) ) ; g . setStroke ( new BasicStroke ( ( float ) strokeWidth ) ) ; g . draw ( getGeneralPath ( ) ) ; } restoreTransform ( g ) ; } 
public Image image ( String path , double x , double y ) { Image img = new Image ( path ) ; img . setX ( x ) ; img . setY ( y ) ; inheritFromContext ( img ) ; canvas . add ( img ) ; return img ; } 
private void inheritFromContext ( BezierPath p ) { p . setTransform ( transform . clone ( ) ) ; p . setFillColor ( fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; } 
private void inheritFromContext ( Text ) { . setTransform ( transform . clone ( ) ) ; . setFillColor ( fillColor . clone ( ) ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; } 
private void inheritFromContext ( Image i ) { i . setTransform ( transform . clone ( ) ) ; } 
protected void saveTransform ( Graphics2D g ) { assert ( savedTransform = = null ) ; savedTransform = new AffineTransform ( g . getTransform ( ) ) ; } 
protected void restoreTransform ( Graphics2D g ) { assert ( savedTransform ! = null ) ; g . setTransform ( savedTransform ) ; savedTransform = null ; } 
protected void setupTransform ( Graphics2D g ) { saveTransform ( g ) ; AffineTransform trans = g . getTransform ( ) ; trans . concatenate ( getCenteredTransform ( ) . getAffineTransform ( ) ) ; g . setTransform ( trans ) ; } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; for ( Grob grob : grobs ) { grob . draw ( g ) ; } restoreTransform ( g ) ; } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; You can only position an image using an affine transformation. We use the transformation to translate the image to the specified position, and scale it according to the given width and height. Transform imageTrans = new Transform(); Move to the image position imageTrans.translate(x, y); Scaling only applies to image that have their desired width and/or height set. However, getScaleFactor return 1 if height/width are not set, in effect negating the effect of the scale. imageTrans.scale(getScaleFactor()); g.drawRenderedImage(image, imageTrans.getAffineTransform()); restoreTransform(g); } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; if ( text = = null | | text . length ( ) = = 0 ) return ; TextLayoutIterator iterator = new TextLayoutIterator ( ) ; while ( iterator . hasNext ( ) ) { TextLayout layout = iterator . next ( ) ; layout . draw ( g , iterator . getX ( ) , iterator . getY ( ) ) ; } restoreTransform ( g ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if ( getNetwork ( ) = = null ) return ; Object outputValue = getNetwork ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { ( ( Grob ) outputValue ) . draw ( g2 ) ; } Draw handle if (handle != null) { Create a canvas with a transparent background 
public void rect ( Rect r ) { rect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) ) ; } 
public void rect ( Rect r , double roundness ) { roundedRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , roundness ) ; } 
public void rect ( Rect r , double rx , double ry ) { roundedRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , rx , ry ) ; } 
public void rect ( double x , double y , double width , double height , double r ) { roundedRect ( x , y , width , height , r ) ; } 
public void rect ( double x , double y , double width , double height , double rx , double ry ) { roundedRect ( x , y , width , height , rx , ry ) ; } 
public void roundedRect ( Rect r , double roundness ) { roundedRect ( r , roundness , roundness ) ; } 
public void roundedRect ( Rect r , double rx , double ry ) { roundedRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , rx , ry ) ; } 
public void roundedRect ( double x , double y , double width , double height , double r ) { roundedRect ( x , y , width , height , r , r ) ; } 
public void roundedRect ( double x , double y , double width , double height , double rx , double ry ) { double dx = rx ; double dy = ry ; rx/ry cannot be greater than half of the width of the rectangle (required by SVG spec) dx = Math.min(dx, width * 0.5); dy = Math.min(dy, height * 0.5); moveto(x + dx, y); if (dx < width * 0.5) lineto(x + width - rx, y); curveto(x + width - dx * ONE_MINUS_QUARTER, y, x + width, y + dy * ONE_MINUS_QUARTER, x + width, y + dy); if (dy < height * 0.5) lineto(x + width, y + height - dy); curveto(x + width, y + height - dy * ONE_MINUS_QUARTER, x + width - dx * ONE_MINUS_QUARTER, y + height, x + width - dx, y + height); if (dx < width * 0.5) lineto(x + dx, y + height); curveto(x + dx * ONE_MINUS_QUARTER, y + height, x, y + height - dy * ONE_MINUS_QUARTER, x, y + height - dy); if (dy < height * 0.5) lineto(x, y + dy); curveto(x, y + dy * ONE_MINUS_QUARTER, x + dx * ONE_MINUS_QUARTER, y, x + dx, y); close(); } 
public void ellipse ( double x , double y , double width , double height ) { Ellipse2D . Double e = new Ellipse2D . Double ( x , y , width , height ) ; extend ( e ) ; } 
public void text ( String text , String fontName , double fontSize , double lineHeight , Text . Align align , double x , double y ) { text ( text , fontName , fontSize , lineHeight , align , x , y , Double . MAX_VALUE , Double . MAX_VALUE ) ; } 
public void text ( String text , String fontName , double fontSize , double lineHeight , Text . Align align , double x , double y , double width ) { text ( text , fontName , fontSize , lineHeight , align , x , y , width , Double . MAX_VALUE ) ; } 
public void text ( String text , String fontName , double fontSize , double lineHeight , Text . Align align , double x , double y , double width , double height ) { Text = new Text ( text , x , y , width , height ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; extend ( . getPath ( ) ) ; } 
public BezierPath rect ( Rect r ) { BezierPath p = new BezierPath ( ) ; p . rect ( r ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath rect ( double x , double y , double width , double height ) { BezierPath p = new BezierPath ( ) ; p . rect ( x , y , width , height ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath rect ( Rect r , double roundness ) { BezierPath p = new BezierPath ( ) ; p . rect ( r , roundness ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath rect ( double x , double y , double width , double height , double roundness ) { BezierPath p = new BezierPath ( ) ; p . rect ( x , y , width , height , roundness ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath rect ( double x , double y , double width , double height , double rx , double ry ) { BezierPath p = new BezierPath ( ) ; p . rect ( x , y , width , height , rx , ry ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath ellipse ( double x , double y , double width , double height ) { BezierPath p = new BezierPath ( ) ; p . ellipse ( x , y , width , height ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath line ( double x1 , double y1 , double x2 , double y2 ) { BezierPath p = new BezierPath ( ) ; p . ellipse ( x1 , y1 , x2 , y2 ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath textPath ( String text , double x , double y , double width , double height ) { BezierPath p = new BezierPath ( ) ; p . text ( text , fontName , fontSize , lineHeight , align , x , y , width , height ) ; inheritFromContext ( p ) ; return p ; } 
private void inheritFromContext ( BezierPath p ) { p . setTransform ( transform . clone ( ) ) ; p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; } 
private void inheritFromContext ( Text ) { . setTransform ( transform . clone ( ) ) ; . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; } 
private void drawDot ( BezierPath p , double x , double y ) { p . rect ( x - HALF_HANDLE_SIZE , y - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void draw ( GraphicsContext ctx ) { double x = node . asFloat ( xName ) ; double y = node . asFloat ( yName ) ; double width = node . asFloat ( widthName ) ; double height = node . asFloat ( heightName ) ; BezierPath cornerPath = new BezierPath ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0.0 ) ; drawDot ( cornerPath , x , y ) ; drawDot ( cornerPath , x + width , y ) ; drawDot ( cornerPath , x + width , y + height ) ; drawDot ( cornerPath , x , y + height ) ; ctx . getCanvas ( ) . add ( cornerPath ) ; BezierPath strokePath = new BezierPath ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . rect ( x , y , width , height ) ; ctx . getCanvas ( ) . add ( strokePath ) ; } 
public void draw ( GraphicsContext ctx ) { double x = node . asFloat ( xName ) ; double y = node . asFloat ( yName ) ; BezierPath dot = new BezierPath ( ) ; dot . setFillColor ( HANDLE_COLOR ) ; dot . setStrokeWidth ( 0.0 ) ; dot . rect ( x - HALF_HANDLE_SIZE , y - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; ctx . getCanvas ( ) . add ( dot ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( node . asColor ( " fill " ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; p . ellipse ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; g . add ( p ) ; node . setOutputValue ( g ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( node . asColor ( " fill " ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; p . rect ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; g . add ( p ) ; node . setOutputValue ( g ) ; return true ; } 
public void testBounds ( ) { BezierPath p1 = new BezierPath ( ) ; p1 . rect ( 20 , 30 , 40 , 50 ) ; assertEquals ( new Rect ( 20 , 30 , 40 , 50 ) , p1 . getBounds ( ) ) ; BezierPath p2 = new BezierPath ( ) ; p2 . rect ( 60 , 70 , 80 , 90 ) ; assertEquals ( new Rect ( 60 , 70 , 80 , 90 ) , p2 . getBounds ( ) ) ; } 
public void testBounds ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Group g1 = new Group ( ) ; g1 . add ( r1 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 40 ) , g1 . getBounds ( ) ) ; } 
public void testTransformedBounds ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; r1 . translate ( 200 , 300 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; assertEquals ( new Rect ( 210 , 320 , 30 , 40 ) , g . getBounds ( ) ) ; } 
public void testTransformedElements ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; BezierPath r2 = new BezierPath ( ) ; r2 . rect ( 10 , 120 , 30 , 40 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; g . add ( r2 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 120 + 40 - 20 ) , g . getBounds ( ) ) ; } 
public void load ( ) { if ( isLoaded ( ) ) return ; File name File file = getLibraryDescriptionFile(); Load the document FileInputStream fis; try { fis = new FileInputStream(file); } catch (FileNotFoundException e) { logger.log(Level.SEVERE, "Could not read file " + file, e); throw new RuntimeException("Could not read file " + file, e); } InputSource source = new InputSource(fis); Setup the parser SAXParserFactory factory = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. try { factory.setFeature("http:xml.org/sax/features/validation", false); factory.setFeature("http:xml.org/sax/features/external-parameter-entities", false); factory.setFeature("http:xml.org/sax/features/external-general-entities", false); factory.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); } catch (Exception e) { logger.log(Level.SEVERE, "Parsing feature not supported.", e); throw new RuntimeException("Parsing feature not supported.", e); } SAXParser parser; try { parser = factory.newSAXParser(); } catch (Exception e) { logger.log(Level.SEVERE, "Could not create parser.", e); throw new RuntimeException("Could not create parser.", e); } Parse the document TypesHandler handler = new TypesHandler(this); try { parser.parse(source, handler); } catch (Exception e) { logger.log(Level.SEVERE, "Error during parsing.", e); throw new RuntimeException("Error during parsing.", e); } Set the loaded flag loaded = true; } 
public NodeTypeLibrary loadLatestVersion ( String libraryName ) { if ( ! lookedForLibraries ) lookForLibraries ( ) ; TODO: Only one version of a library can be stored at the moment. return nodeLibraryMap.get(libraryName); } 
private void lookForLibraries ( ) { for ( File searchPath : searchPaths ) { for ( File f : searchPath . listFiles ( ) ) { 
public static NodeTypeLibrary pathToLibrary ( String searchPath , String path ) throws RuntimeException { if ( path = = null | | path . trim ( ) . length ( ) = = 0 ) throw new RuntimeException ( " Empty paths are not accepted. " ) ; String [ ] pathSplit = path . split ( " - " ) ; String libraryName ; String versionString ; assert ( pathSplit . length > 0 ) ; if ( pathSplit . length = = 1 ) { No version information libraryName = pathSplit[0]; versionString = "0.0.0"; } else if (pathSplit.length == 2) { libraryName = pathSplit[0]; versionString = pathSplit[1]; } else { throw new RuntimeException("Only one dash excepted (e.g. \"vector-1.2.3\"): " + path); } Version v = new Version(versionString); try { return new NodeTypeLibrary(libraryName, v.getMajor(), v.getMinor(), v.getRevision(), new File(searchPath, path)); 
public void testLoad ( ) { initJython ( ) ; NodeTypeLibraryManager manager = new NodeTypeLibraryManager ( ) ; try { manager . addSearchPath ( getLibrariesDirectory ( ) ) ; } catch ( IOException e ) { fail ( " Failed with IOException: " + e ) ; } Load the test library NodeTypeLibrary testlib = manager.loadLatestVersion("testlib"); assertEquals("testlib", testlib.getName()); assertEquals("0.0.0", testlib.getVersion().toString()); assertFalse(testlib.isLoaded()); Retrieve a type from the library. NodeType negateType = testlib.getNodeType("negate"); Retrieving a type implicitly loads the library. assertTrue(testlib.isLoaded()); assertEquals("negate", negateType.getIdentifier()); Try it out Node node = negateType.createNode(); node.set("value", 42); assertTrue(node.update()); assertEquals(-42, node.getOutputValue()); } 
public void testPathToLibrary ( ) { NodeTypeLibrary lib1 = NodeTypeLibraryManager . pathToLibrary ( " test " , " testlib " ) ; assertEquals ( " testlib " , lib1 . getName ( ) ) ; assertEquals ( " 0.0.0 " , lib1 . getVersion ( ) . toString ( ) ) ; assertInvalidLibraryPath ( " " , " empty paths should not be accepted " ) ; assertInvalidLibraryPath ( " bobby-1.2.3-alpha-beta " , " there are too many components " ) ; assertInvalidLibraryPath ( " bobby-a.b.c " , " version specifiers are not numbers " ) ; NodeTypeLibrary lib2 = NodeTypeLibraryManager . pathToLibrary ( " test " , " vector-1.2.3 " ) ; assertEquals ( " vector " , lib2 . getName ( ) ) ; assertEquals ( " 1.2.3 " , lib2 . getVersion ( ) . toString ( ) ) ; } 
private void assertInvalidLibraryPath ( String path , String reason ) { try { NodeTypeLibraryManager . pathToLibrary ( " test " , path ) ; 
protected void initJython ( ) { Properties jythonProperties = new Properties ( ) ; String jythonCacheDir = PlatformUtils . getUserDataDirectory ( ) + PlatformUtils . SEP + " jythoncache " ; jythonProperties . put ( " python.cachedir " , jythonCacheDir ) ; PySystemState . initialize ( System . getProperties ( ) , jythonProperties , new String [ ] { " " } ) ; } 
public void testDummy ( ) { This needs to be here, otherwise jUnit complains that there are no tests in this class. }} 
private LibraryType detectType ( ) { Read the description file. Instead of parsing the entire file, we load the first line and look for the type="python" pattern to determine the library type. File descriptionFile = getLibraryDescriptionFile(); try { FileInputStream fis = new FileInputStream(descriptionFile); BufferedReader reader = new BufferedReader(new InputStreamReader(fis, "UTF-8"), 200); String firstLine = reader.readLine(); Matcher m = TYPE_PATTERN.matcher(firstLine); if (!m.matches()) throw new AssertionError("File does not contain type specifier."); String typeName = m.group(1); type = LibraryType.valueOf(typeName.toUpperCase()); } catch (Exception e) { logger.log(Level.WARNING, "Cannot read library description file " + descriptionFile, e); type = LibraryType.UNKNOWN; } return type; } 
public void addNodeType ( NodeType nodeType ) { throw new AssertionError ( " You cannot add types to the builtin library. " ) ; } 
public void load ( ) { Builtin library is already loaded. } @Override public boolean isLoaded() { return true; } }} 
public boolean matches ( Version version ) { TODO: implement return false; } 
public boolean matches ( int major , int minor ) { return matches ( new Version ( major , minor ) ) ; } 
public void testDetectType ( ) throws IOException { File testlibPath = new File ( getLibrariesDirectory ( ) + PlatformUtils . SEP + " testlib " ) ; NodeTypeLibrary lib = new NodeTypeLibrary ( " testlib " , 0 , 0 , 0 , testlibPath ) ; assertEquals ( NodeTypeLibrary . LibraryType . PYTHON , lib . getType ( ) ) ; } 
private Network createEmptyNetwork ( ) { NodeType canvasNetworkType = manager . getNodeType ( " builtin.canvasnet " ) ; return ( Network ) canvasNetworkType . createNode ( ) ; } 
private Network createTestNetwork ( ) { NodeTypeLibrary builtin = NodeTypeLibrary . BUILTIN ; NodeType canvasNetworkType = builtin . getNodeType ( " canvasnet " ) ; NodeType vectorNetworkType = builtin . getNodeType ( " vecnet " ) ; NodeType imageNetworkType = builtin . getNodeType ( " imagenet " ) ; NodeType ellipseType = builtin . getNodeType ( " ellipse " ) ; NodeType rectType = builtin . getNodeType ( " rect " ) ; NodeType transformType = builtin . getNodeType ( " transform " ) ; NodeType allControlsType = new AllControlsType ( null ) ; Network network = ( Network ) canvasNetworkType . createNode ( ) ; Node allControls = network . create ( allControlsType ) ; allControls . setPosition ( 200 , 10 ) ; allControls . setRendered ( ) ; Network vector1 = ( Network ) network . create ( vectorNetworkType ) ; vector1 . setPosition ( 10 , 10 ) ; vector1.setRendered(); Network vector2 = (Network) network.create(vectorNetworkType); vector2.setPosition(10, 110); Network image1 = (Network) network.create(imageNetworkType); image1.setPosition(10, 210); Network image2 = (Network) network.create(imageNetworkType); image2.setPosition(10, 310); Node ellipse1 = vector1.create(ellipseType); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node ellipse2 = vector1.create(ellipseType); ellipse2.setPosition(100, 130); Node transform1 = vector1.create(transformType); transform1.setPosition(300, 230); Node rect1 = vector2.create(rectType); rect1.setPosition(40, 40); rect1.setRendered(); Node transform2 = vector2.create(transformType); transform2.setPosition(40, 80); transform2.setRendered(); transform2.getParameter("shape").connect(rect1); return network; } 
public boolean readFromFile ( File file ) { FileInputStream fis ; try { Load the document fis = new FileInputStream(file); InputSource source = new InputSource(fis); Setup the parser SAXParserFactory spf = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. spf.setFeature("http:xml.org/sax/features/validation", false); spf.setFeature("http:xml.org/sax/features/external-parameter-entities", false); spf.setFeature("http:xml.org/sax/features/external-general-entities", false); spf.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); SAXParser parser = spf.newSAXParser(); XmlHandler handler = new XmlHandler(manager); parser.parse(source, handler); The parsed network is now stored in the reader setRootNetwork(handler.getNetwork()); setDocumentFile(file); documentChanged = false; return true; } catch (ParserConfigurationException e) { logger.log(Level.SEVERE, "Error during configuration", e); } catch (IOException e) { logger.log(Level.SEVERE, "Error while reading " + file, e); } catch (SAXException e) { logger.log(Level.SEVERE, "Error while parsing" + file, e); } return false; } 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; Node = new RectType ( NodeTypeLibrary . BUILTIN ) . createNode ( ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } 
public static Network load ( NodeTypeLibraryManager manager , String s ) throws RuntimeException { StringReader reader = new StringReader ( s ) ; return load ( manager , new InputSource ( reader ) ) ; } 
public static Network load ( NodeTypeLibraryManager manager , File file ) throws RuntimeException { Load the document FileInputStream fis; try { fis = new FileInputStream(file); } catch (FileNotFoundException e) { logger.log(Level.SEVERE, "Could not read file " + file, e); throw new RuntimeException("Could not read file " + file, e); } return load(manager, new InputSource(fis)); } 
private static Network load ( NodeTypeLibraryManager manager , InputSource source ) throws RuntimeException { Setup the parser SAXParserFactory factory = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. try { factory.setFeature("http:xml.org/sax/features/validation", false); factory.setFeature("http:xml.org/sax/features/external-parameter-entities", false); factory.setFeature("http:xml.org/sax/features/external-general-entities", false); factory.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); } catch (Exception e) { logger.log(Level.SEVERE, "Parsing feature not supported.", e); throw new RuntimeException("Parsing feature not supported.", e); } SAXParser parser; try { parser = factory.newSAXParser(); } catch (Exception e) { logger.log(Level.SEVERE, "Could not create parser.", e); throw new RuntimeException("Could not create parser.", e); } Parse the document XmlHandler handler = new XmlHandler(manager); try { parser.parse(source, handler); } catch (Exception e) { logger.log(Level.SEVERE, "Error during parsing.", e); throw new RuntimeException("Error during parsing.", e); } return handler.getNetwork(); 
public void toXml ( StringBuffer xml , String spaces ) { Build the node xml.append(spaces).append("<node"); xml.append(" name=\"").append(getName()).append("\""); xml.append(" type=\"").append(getNodeType().getQualifiedName()).append("\""); xml.append(" version=\"").append(getNodeType().getVersionAsString()).append("\""); xml.append(" x=\"").append(getX()).append("\""); xml.append(" y=\"").append(getY()).append("\""); if (isRendered()) xml.append(" rendered=\"true\""); xml.append(">"); xml.append(spaces); xml.append(" <data>"); Build the parameter list dataToXml(xml, spaces); End the node xml.append(spaces); xml.append(" </data>"); xml.append(spaces); xml.append("</node>"); } 
public ParameterType getParameterType ( String name ) throws NotFoundException { for ( ParameterType pt : parameterTypes ) { if ( pt . getName ( ) . equals ( name ) ) return pt ; } throw new NotFoundException ( this , name , " Node type " + getName ( ) + " does not have a parameter type ' " + name + " ' " ) ; } 
public void addNodeType ( NodeType nodeType ) { types . put ( nodeType . getName ( ) , nodeType ) ; } 
public NodeType getNodeType ( String nodeName ) throws NotFoundException { if ( ! isLoaded ( ) ) load ( ) ; if ( types . containsKey ( nodeName ) ) { return types . get ( nodeName ) ; 
public void addLibrary ( NodeTypeLibrary library ) { Version newVersion = library . getVersion ( ) ; int i = 0 ; for ( ; i < libraries . size ( ) ; i + + ) { NodeTypeLibrary l = libraries . get ( i ) ; if ( l . getVersion ( ) . smallerThan ( newVersion ) ) break ; } libraries . add ( i , library ) ; } 
public NodeTypeLibrary getLibrary ( String libraryName ) throws NotFoundException { if ( ! lookedForLibraries ) lookForLibraries ( ) ; VersionedLibraryList libraryList = libraryMap . get ( libraryName ) ; if ( libraryList = = null ) throw new NotFoundException ( this , libraryName , " The manager cannot find library ' " + libraryName + " '. " ) ; return libraryList . getLatestVersion ( ) ; } 
public void addLibrary ( NodeTypeLibrary library ) { VersionedLibraryList libraryList = libraryMap . get ( library . getName ( ) ) ; if ( libraryList = = null ) { libraryList = new VersionedLibraryList ( ) ; libraryMap . put ( library . getName ( ) , libraryList ) ; } libraryList . addLibrary ( library ) ; } 
public NodeType getNodeType ( String identifier ) throws NotFoundException { Matcher m = IDENTIFIER_PATTERN . matcher ( identifier ) ; if ( ! m . matches ( ) ) throw new NotFoundException ( this , identifier , " The identifier pattern is not in the correct format " ) ; assert ( m . groupCount ( ) = = 2 ) ; String libraryName = m . group ( 1 ) ; String nodeTypeName = m . group ( 2 ) ; NodeTypeLibrary library = getLibrary ( libraryName ) ; return library . getNodeType ( nodeTypeName ) ; } 
public NodeType getNodeType ( String identifier , Version version ) throws NotFoundException { Matcher m = IDENTIFIER_PATTERN . matcher ( identifier ) ; if ( ! m . matches ( ) ) throw new NotFoundException ( this , identifier , " The identifier pattern is not in the correct format " ) ; assert ( m . groupCount ( ) = = 2 ) ; String libraryName = m . group ( 1 ) ; String nodeTypeName = m . group ( 2 ) ; NodeTypeLibrary library = getLibrary ( libraryName , version ) ; return library . getNodeType ( nodeTypeName ) ; } 
public static NodeTypeLibrary pathToLibrary ( String searchPath , String path ) throws RuntimeException { if ( path = = null | | path . trim ( ) . length ( ) = = 0 ) throw new RuntimeException ( " Empty paths are not accepted. " ) ; String [ ] pathSplit = path . split ( " - " ) ; String libraryName ; String versionString ; assert ( pathSplit . length > 0 ) ; if ( pathSplit . length = = 1 ) { No version information libraryName = pathSplit[0]; versionString = "0.0.0"; } else if (pathSplit.length == 2) { libraryName = pathSplit[0]; versionString = pathSplit[1]; } else { throw new RuntimeException("Only one dash excepted (e.g. \"vector-1.2.3\"): " + path); } Version v = new Version(versionString); return new NodeTypeLibrary(libraryName, v.getMajor(), v.getMinor(), v.getRevision(), new File(searchPath, path)); } 
public String toString ( ) { return super . toString ( ) + " / " + source + " / " + name ; } 
private Node lookupNode ( Attributes attributes ) throws SAXException { NodeType nodeType ; Node newNode ; String identifier = attributes . getValue ( " type " ) ; String version = attributes . getValue ( " version " ) ; try { if ( version = = null ) { nodeType = manager . getNodeType ( identifier ) ; } else { nodeType = manager . getNodeType ( identifier , new Version ( version ) ) ; } } catch ( NotFoundException e ) { throw new SAXException ( " A node with type " + identifier + " and version " + version + " does not exist. " ) ; } newNode = nodeType . createNode ( ) ; String name = attributes . getValue ( " name " ) ; if ( name ! = null ) { newNode . setName ( name ) ; } String x = attributes . getValue ( " x " ) ; if ( x ! = null ) { try { newNode . setX ( Double . parseDouble ( x ) ) ; } catch ( NumberFormatException e ) { logger . log ( Level . WARNING , " Could not parse x attribute for node " + name + " [ " + identifier + " ] value= " + x ) ; } } String y = attributes . getValue ( " y " ) ; if ( y ! = null ) { try { newNode . setY ( Double . parseDouble ( y ) ) ; } catch ( NumberFormatException e ) { logger . log ( Level . WARNING , " Could not parse y attribute for node " + name + " [ " + identifier + " ] value= " + y ) ; } } return newNode ; } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("builtin.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("builtin.rect")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); }} 
public void testPersistence ( ) { Create network Network rootNetwork = (Network) manager.getNodeType("builtin.canvasnet").createNode(); Network vecnet1 = (Network) rootNetwork.create(manager.getNodeType("builtin.vecnet")); vecnet1.setPosition(10, 10); assertEquals("vecnet1", vecnet1.getName()); vecnet1.setRendered(); Node ellipse1 = vecnet1.create(manager.getNodeType("builtin.ellipse")); assertEquals("ellipse1", ellipse1.getName()); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node transform1 = vecnet1.create(manager.getNodeType("builtin.transform")); assertEquals("transform1", transform1.getName()); transform1.setPosition(40, 80); transform1.setRendered(); transform1.getParameter("shape").connect(ellipse1); Write network String xmlString = rootNetwork.toXml(); Read network Network newNetwork = Network.load(manager, xmlString); Perform tests on the network assertEquals(rootNetwork.getName(), newNetwork.getName()); assertTrue(newNetwork.contains("vecnet1")); Network nVector1 = (Network) newNetwork.getNode("vecnet1"); assertTrue(nVector1.contains("ellipse1")); assertTrue(nVector1.contains("transform1")); Node nEllipse1 = nVector1.getNode("ellipse1"); Node nTransform1 = nVector1.getNode("transform1"); assertEquals(ellipse1.getValue("x"), nEllipse1.getValue("x")); assertEquals(ellipse1.getValue("fill"), nEllipse1.getValue("fill")); assertEquals(ellipse1.getValue("stroke"), nEllipse1.getValue("stroke")); assertTrue(nEllipse1.isConnected()); assertTrue(nTransform1.isConnected()); assertTrue(nTransform1.getParameter("shape").isConnectedTo(nEllipse1)); } 
public void testCopy ( ) { Network vector1 = ( Network ) manager . getNodeType ( " builtin.vecnet " ) . createNode ( ) ; Node ellipse1 = vector1 . create ( manager . getNodeType ( " builtin.rect " ) ) ; ellipse1 . setRendered ( ) ; vector1 . update ( ) ; assertFalse ( vector1 . getOutputValue ( ) = = ellipse1 . getOutputValue ( ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; manager = new NodeTypeLibraryManager ( ) ; TestLibrary testlib = new TestLibrary ( ) ; manager . addLibrary ( testlib ) ; TODO: Add test NTL numberType = manager.getNodeType("test.number"); negateType = manager.getNodeType("test.negate"); addType = manager.getNodeType("test.add"); multiplyType = manager.getNodeType("test.multiply"); testNetworkType = manager.getNodeType("test.testnet"); } 
public void testLoad ( ) { initJython ( ) ; NodeTypeLibraryManager manager = new NodeTypeLibraryManager ( ) ; try { manager . addSearchPath ( getLibrariesDirectory ( ) ) ; } catch ( IOException e ) { fail ( " Failed with IOException: " + e ) ; } Load the test library NodeTypeLibrary testlib = manager.getLibrary("testlib"); assertEquals("testlib", testlib.getName()); assertEquals("0.0.0", testlib.getVersion().toString()); assertFalse(testlib.isLoaded()); Retrieve a type from the library. NodeType negateType = testlib.getNodeType("negate"); Retrieving a type implicitly loads the library. assertTrue(testlib.isLoaded()); assertEquals("negate", negateType.getName()); Try it out Node node = negateType.createNode(); node.set("value", 42); assertTrue(node.update()); assertEquals(-42, node.getOutputValue()); } 
public void testVersionedLibraries ( ) { NodeTypeLibraryManager m = new NodeTypeLibraryManager ( ) ; NodeTypeLibrary tn_0_8 = new NodeTypeLibrary ( " test " , 0 , 8 , 0 , new File ( " " ) ) ; NodeTypeLibrary tn_1_0 = new NodeTypeLibrary ( " test " , 1 , 0 , 0 , new File ( " " ) ) ; NodeTypeLibrary tn_2_0 = new NodeTypeLibrary ( " test " , 2 , 0 , 0 , new File ( " " ) ) ; NodeTypeLibrary tn_2_1 = new NodeTypeLibrary ( " test " , 2 , 1 , 0 , new File ( " " ) ) ; Setup the correct order (newest nodes come first) List<NodeTypeLibrary> orderedLibraries = new ArrayList<NodeTypeLibrary>(); orderedLibraries.add(tn_2_1); orderedLibraries.add(tn_2_0); orderedLibraries.add(tn_1_0); orderedLibraries.add(tn_0_8); Add the nodes in semi-random order. NodeTypeLibraryManager.VersionedLibraryList vll = new NodeTypeLibraryManager.VersionedLibraryList(); vll.addLibrary(tn_2_0); vll.addLibrary(tn_0_8); vll.addLibrary(tn_1_0); vll.addLibrary(tn_2_1); assertEquals(orderedLibraries, vll.getLibraries()); Add the nodes in another order. vll = new NodeTypeLibraryManager.VersionedLibraryList(); vll.addLibrary(tn_0_8); vll.addLibrary(tn_1_0); vll.addLibrary(tn_2_0); vll.addLibrary(tn_2_1); assertEquals(orderedLibraries, vll.getLibraries()); assertEquals(tn_2_1, vll.getLatestVersion()); } 
public void testNaming ( ) { NodeType nt = new TestLibrary . Number ( null ) ; checkInvalidName ( nt , " 1234 " , " names cannot start with a digit. " ) ; checkInvalidName ( nt , " node " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " root " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " network " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " UPPERCASE " , " names cannot be in uppercase. " ) ; checkInvalidName ( nt , " uPpercase " , " names cannot contain uppercase letters " ) ; checkInvalidName ( nt , " __reserved " , " names cannot start with double underscores " ) ; checkInvalidName ( nt , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( nt , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( nt , " " , " names cannot be empty " ) ; checkInvalidName ( nt , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; checkValidName ( nt , " radius " ) ; checkValidName ( nt , " _test " ) ; checkValidName ( nt , " _ " ) ; checkValidName ( nt , " _1234 " ) ; checkValidName ( nt , " a1234 " ) ; checkInvalidName ( nt , " radius " , " parameter type names must be unique for the node type " ) ; } 
public abstract int process ( int value ) ; } public static abstract class Binary extends NodeType { public Binary ( NodeTypeLibrary library , String name ) { super ( library , name , ParameterType . Type . INT ) ; addParameterType ( " v1 " , ParameterType . Type . INT ) ; addParameterType ( " v2 " , ParameterType . Type . INT ) ; } public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( process ( node . asInt ( " v1 " ) , node . asInt ( " v2 " ) ) ) ; return true ; } public abstract int process ( int v1 , int v2 ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , 1 , 0 , 0 , new File ( " " ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public abstract int process ( int v1 , int v2 ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , 1 , 0 , 0 , new File ( " " ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public void testType ( ) { NodeType canvasNetworkType = manager . getNodeType ( " builtin.canvasnet " ) ; Node = canvasNetworkType . createNode ( ) ; Assert . assertEquals ( ParameterType . Type . GROB_CANVAS , . getOutputParameter ( ) . getType ( ) ) ; } 
public void testBasicCopy ( ) { Node rect = manager . getNodeType ( " builtin.rect " ) . createNode ( ) ; Node copy = manager . getNodeType ( " builtin.copy " ) . createNode ( ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , g . getBounds ( ) ) ; copy . setValue ( " ty " , 100.0 ) ; copy . setValue ( " copies " , 5 ) ; copy . update ( ) ; g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 500 ) , g . getBounds ( ) ) ; } 
public void testRectNode ( ) { Node r = manager . getNodeType ( " builtin.rect " ) . createNode ( ) ; r . update ( ) ; Object outputValue = r . getOutputValue ( ) ; if ( ! ( outputValue instanceof Group ) ) fail ( " Output value is not a Group, but " + outputValue ) ; Group group = ( Group ) outputValue ; assertEquals ( 1 , group . size ( ) ) ; BezierPath p = ( BezierPath ) group . get ( 0 ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , p . getBounds ( ) ) ; } 
public void testType ( ) { NodeType vectorNetworkType = manager . getNodeType ( " builtin.vecnet " ) ; Node = vectorNetworkType . createNode ( ) ; assertEquals ( ParameterType . Type . GROB_VECTOR , . getOutputParameter ( ) . getType ( ) ) ; } 
public void networkDirty ( Network network ) { if ( network ! = activeNetwork ) return ; activeNetwork . update ( ) ; markChanged ( ) ; } 
public void mouseDragged ( MouseEvent e ) { isDragging = true ; JComponent c = ColorWell . this ; Point pt = e . getPoint ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( c ) ; pt = SwingUtilities . convertPoint ( c , pt , frame . getContentPane ( ) ) ; MouseEvent newEvent = new MouseEvent ( colorPicker , e . getID ( ) , e . getWhen ( ) , e . getModifiers ( ) , ( int ) pt . getX ( ) , ( int ) pt . getY ( ) , e . getClickCount ( ) , e . isPopupTrigger ( ) , e . getButton ( ) ) ; colorPicker . dispatchEvent ( newEvent ) ; } 
public void mouseEntered ( PInputEvent e ) { if ( isConnecting ) { NodeView oldTarget = connectTarget ; 
public void mouseExited ( PInputEvent e ) { if ( isConnecting ) { NodeView oldTarget = connectTarget ; 
public void mouseReleased ( PInputEvent event ) { if ( isConnecting ) { if ( connectTarget ! = null ) connectTarget . repaint ( ) ; NodeView . this . repaint ( ) ; if ( connectSource ! = null & & connectTarget ! = null ) { java . util . List < Parameter > compatibleParameters = connectTarget . getNode ( ) . getCompatibleInputs ( connectSource . getNode ( ) ) ; if ( compatibleParameters . isEmpty ( ) ) { There are no compatible parameters. } else if (compatibleParameters.size() == 1) { Only one possible connection, make it now. Parameter inputParameter = compatibleParameters.get(0); inputParameter.connect(connectSource.getNode()); } else { JPopupMenu menu = new JPopupMenu("Select input"); for (Parameter p : compatibleParameters) { Action a = new SelectCompatibleParameterAction(connectSource.getNode(), connectTarget.getNode(), p); menu.add(a); } Point pt = getNetworkView().getMousePosition(); menu.show(getNetworkView(), pt.x, pt.y); } } } isDragging = false; isConnecting = false; connectSource = null; connectTarget = null; } 
public boolean quit ( ) { boolean allClosed = true ; Because documents will disappear from the list once they are closed, make a copy of the list. java.util.List<NodeBoxDocument> documents = new ArrayList<NodeBoxDocument>(Application.getInstance().getDocuments()); for (NodeBoxDocument d : documents) { allClosed = allClosed && d.shouldClose(); } if (allClosed) { System.exit(0); return true; } return false; } 
private Network createEmptyNetwork ( ) { NodeType canvasNetworkType = manager . getNodeType ( " corecanvas.canvasnet " ) ; return ( Network ) canvasNetworkType . createNode ( ) ; } 
private Network createTestNetwork ( ) { NodeType canvasNetworkType = manager . getNodeType ( " corecanvas.canvasnet " ) ; NodeType vectorNetworkType = manager . getNodeType ( " corevector.vecnet " ) ; NodeType imageNetworkType = manager . getNodeType ( " coreimage.imagenet " ) ; NodeType ellipseType = manager . getNodeType ( " corevector.ellipse " ) ; NodeType rectType = manager . getNodeType ( " corevector.rect " ) ; NodeType transformType = manager . getNodeType ( " corevector.transform " ) ; NodeType allControlsType = new AllControlsType ( null ) ; Network network = ( Network ) canvasNetworkType . createNode ( ) ; Node allControls = network . create ( allControlsType ) ; allControls . setPosition ( 200 , 10 ) ; allControls . setRendered ( ) ; Network vector1 = ( Network ) network . create ( vectorNetworkType ) ; vector1 . setPosition ( 10 , 10 ) ; vector1.setRendered(); Network vector2 = (Network) network.create(vectorNetworkType); vector2.setPosition(10, 110); Network image1 = (Network) network.create(imageNetworkType); image1.setPosition(10, 210); Network image2 = (Network) network.create(imageNetworkType); image2.setPosition(10, 310); Node ellipse1 = vector1.create(ellipseType); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node ellipse2 = vector1.create(ellipseType); ellipse2.setPosition(100, 130); Node transform1 = vector1.create(transformType); transform1.setPosition(300, 230); Node rect1 = vector2.create(rectType); rect1.setPosition(40, 40); rect1.setRendered(); Node transform2 = vector2.create(transformType); transform2.setPosition(40, 80); transform2.setRendered(); transform2.getParameter("shape").connect(rect1); return network; } 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; NodeTypeLibraryManager manager = new NodeTypeLibraryManager ( ) ; NodeType rectType = manager . getNodeType ( " corevector.rect " ) ; Node = rectType . createNode ( ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } 
public void addNodeType ( NodeType nodeType ) { super . addNodeType ( nodeType ) ; } 
protected void addNodeType ( NodeType nodeType ) { types . put ( nodeType . getName ( ) , nodeType ) ; } 
public boolean isLoaded ( ) { Default implementation always returns true return true; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new VectorNetworkType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public static NodeTypeLibrary pathToLibrary ( String searchPath , String path ) throws RuntimeException { if ( path = = null | | path . trim ( ) . length ( ) = = 0 ) throw new RuntimeException ( " Empty paths are not accepted. " ) ; String [ ] pathSplit = path . split ( " - " ) ; String libraryName ; String versionString ; assert ( pathSplit . length > 0 ) ; if ( pathSplit . length = = 1 ) { No version information libraryName = pathSplit[0]; versionString = "0.0.0"; } else if (pathSplit.length == 2) { libraryName = pathSplit[0]; versionString = pathSplit[1]; } else { throw new RuntimeException("Only one dash excepted (e.g. \"vector-1.2.3\"): " + path); } Version v = new Version(versionString); File libraryPath = new File(searchPath, path); Class libraryClass = detectType(libraryPath.getPath()); try { Constructor libConstructor = libraryClass.getConstructor(String.class, Version.class, File.class); 
public static Class detectType ( String libraryPath ) { Read the description file. Instead of parsing the entire file, we load the first line and look for the type="python" pattern to determine the library type. File descriptionFile = getLibraryDescriptionFile(libraryPath); try { FileInputStream fis = new FileInputStream(descriptionFile); 
public void load ( ) { if ( isLoaded ( ) ) return ; File name File file = getLibraryDescriptionFile(); Load the document FileInputStream fis; try { fis = new FileInputStream(file); } catch (FileNotFoundException e) { logger.log(Level.SEVERE, "Could not read file " + file, e); throw new RuntimeException("Could not read file " + file, e); } InputSource source = new InputSource(fis); Setup the parser SAXParserFactory factory = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. try { factory.setFeature("http:xml.org/sax/features/validation", false); factory.setFeature("http:xml.org/sax/features/external-parameter-entities", false); factory.setFeature("http:xml.org/sax/features/external-general-entities", false); factory.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); } catch (Exception e) { logger.log(Level.SEVERE, "Parsing feature not supported.", e); throw new RuntimeException("Parsing feature not supported.", e); } SAXParser parser; try { parser = factory.newSAXParser(); } catch (Exception e) { logger.log(Level.SEVERE, "Could not create parser.", e); throw new RuntimeException("Could not create parser.", e); } Parse the document PythonNodeTypeLibraryHandler handler = new PythonNodeTypeLibraryHandler(this); try { parser.parse(source, handler); } catch (Exception e) { logger.log(Level.SEVERE, "Error during parsing.", e); throw new RuntimeException("Error during parsing.", e); } Set the loaded flag loaded = true; } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.rect")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); }} 
public void testPersistence ( ) { Create network Network rootNetwork = (Network) manager.getNodeType("corecanvas.canvasnet").createNode(); Network vecnet1 = (Network) rootNetwork.create(manager.getNodeType("corevector.vecnet")); vecnet1.setPosition(10, 10); assertEquals("vecnet1", vecnet1.getName()); vecnet1.setRendered(); Node ellipse1 = vecnet1.create(manager.getNodeType("corevector.ellipse")); assertEquals("ellipse1", ellipse1.getName()); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node transform1 = vecnet1.create(manager.getNodeType("corevector.transform")); assertEquals("transform1", transform1.getName()); transform1.setPosition(40, 80); transform1.setRendered(); transform1.getParameter("shape").connect(ellipse1); Write network String xmlString = rootNetwork.toXml(); Read network Network newNetwork = Network.load(manager, xmlString); Perform tests on the network assertEquals(rootNetwork.getName(), newNetwork.getName()); assertTrue(newNetwork.contains("vecnet1")); Network nVector1 = (Network) newNetwork.getNode("vecnet1"); assertTrue(nVector1.contains("ellipse1")); assertTrue(nVector1.contains("transform1")); Node nEllipse1 = nVector1.getNode("ellipse1"); Node nTransform1 = nVector1.getNode("transform1"); assertEquals(ellipse1.getValue("x"), nEllipse1.getValue("x")); assertEquals(ellipse1.getValue("fill"), nEllipse1.getValue("fill")); assertEquals(ellipse1.getValue("stroke"), nEllipse1.getValue("stroke")); assertTrue(nEllipse1.isConnected()); assertTrue(nTransform1.isConnected()); assertTrue(nTransform1.getParameter("shape").isConnectedTo(nEllipse1)); } 
public void testCopy ( ) { Network vector1 = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node ellipse1 = vector1 . create ( manager . getNodeType ( " corevector.rect " ) ) ; ellipse1 . setRendered ( ) ; vector1 . update ( ) ; assertFalse ( vector1 . getOutputValue ( ) = = ellipse1 . getOutputValue ( ) ) ; } 
public void testPathToLibrary ( ) { NodeTypeLibrary lib1 = NodeTypeLibraryManager . pathToLibrary ( getLibrariesDirectory ( ) , " testlib " ) ; assertEquals ( " testlib " , lib1 . getName ( ) ) ; assertEquals ( " 0.0.0 " , lib1 . getVersion ( ) . toString ( ) ) ; assertInvalidLibraryPath ( " " , " empty paths should not be accepted " ) ; assertInvalidLibraryPath ( " bobby-1.2.3-alpha-beta " , " there are too many components " ) ; assertInvalidLibraryPath ( " bobby-a.b.c " , " version specifiers are not numbers " ) ; 
public void testVersionedLibraries ( ) { NodeTypeLibraryManager m = new NodeTypeLibraryManager ( ) ; NodeTypeLibrary tn_0_8 = new CoreNodeTypeLibrary ( " test " , new Version ( 0 , 8 , 0 ) ) ; NodeTypeLibrary tn_1_0 = new CoreNodeTypeLibrary ( " test " , new Version ( 1 , 0 , 0 ) ) ; NodeTypeLibrary tn_2_0 = new CoreNodeTypeLibrary ( " test " , new Version ( 2 , 0 , 0 ) ) ; NodeTypeLibrary tn_2_1 = new CoreNodeTypeLibrary ( " test " , new Version ( 2 , 1 , 0 ) ) ; Setup the correct order (newest nodes come first) List<NodeTypeLibrary> orderedLibraries = new ArrayList<NodeTypeLibrary>(); orderedLibraries.add(tn_2_1); orderedLibraries.add(tn_2_0); orderedLibraries.add(tn_1_0); orderedLibraries.add(tn_0_8); Add the nodes in semi-random order. NodeTypeLibraryManager.VersionedLibraryList vll = new NodeTypeLibraryManager.VersionedLibraryList(); vll.addLibrary(tn_2_0); vll.addLibrary(tn_0_8); vll.addLibrary(tn_1_0); vll.addLibrary(tn_2_1); assertEquals(orderedLibraries, vll.getLibraries()); Add the nodes in another order. vll = new NodeTypeLibraryManager.VersionedLibraryList(); vll.addLibrary(tn_0_8); vll.addLibrary(tn_1_0); vll.addLibrary(tn_2_0); vll.addLibrary(tn_2_1); assertEquals(orderedLibraries, vll.getLibraries()); assertEquals(tn_2_1, vll.getLatestVersion()); } 
public void testDetectType ( ) throws IOException { File testlibPath = new File ( getLibrariesDirectory ( ) + PlatformUtils . SEP + " testlib " ) ; assertEquals ( PythonNodeTypeLibrary . class , NodeTypeLibraryManager . detectType ( testlibPath . getPath ( ) ) ) ; } 
public abstract int process ( int value ) ; } public static abstract class Binary extends NodeType { public Binary ( NodeTypeLibrary library , String name ) { super ( library , name , ParameterType . Type . INT ) ; addParameterType ( " v1 " , ParameterType . Type . INT ) ; addParameterType ( " v2 " , ParameterType . Type . INT ) ; } public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( process ( node . asInt ( " v1 " ) , node . asInt ( " v2 " ) ) ) ; return true ; } public abstract int process ( int v1 , int v2 ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , new Version ( 1 , 0 , 0 ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public abstract int process ( int v1 , int v2 ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , new Version ( 1 , 0 , 0 ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public void testType ( ) { NodeType canvasNetworkType = manager . getNodeType ( " corecanvas.canvasnet " ) ; Node = canvasNetworkType . createNode ( ) ; Assert . assertEquals ( ParameterType . Type . GROB_CANVAS , . getOutputParameter ( ) . getType ( ) ) ; } 
public void testBasicCopy ( ) { Node rect = manager . getNodeType ( " corevector.rect " ) . createNode ( ) ; Node copy = manager . getNodeType ( " corevector.copy " ) . createNode ( ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , g . getBounds ( ) ) ; copy . setValue ( " ty " , 100.0 ) ; copy . setValue ( " copies " , 5 ) ; copy . update ( ) ; g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 500 ) , g . getBounds ( ) ) ; } 
public void testRectNode ( ) { Node r = manager . getNodeType ( " corevector.rect " ) . createNode ( ) ; r . update ( ) ; Object outputValue = r . getOutputValue ( ) ; if ( ! ( outputValue instanceof Group ) ) fail ( " Output value is not a Group, but " + outputValue ) ; Group group = ( Group ) outputValue ; assertEquals ( 1 , group . size ( ) ) ; BezierPath p = ( BezierPath ) group . get ( 0 ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , p . getBounds ( ) ) ; } 
public void testType ( ) { NodeType vectorNetworkType = manager . getNodeType ( " corevector.vecnet " ) ; Node = vectorNetworkType . createNode ( ) ; assertEquals ( ParameterType . Type . GROB_VECTOR , . getOutputParameter ( ) . getType ( ) ) ; } 
public void moveto ( Point pt ) { moveto ( pt . getX ( ) , pt . getY ( ) ) ; } 
public void lineto ( Point pt ) { lineto ( pt . getX ( ) , pt . getY ( ) ) ; } 
public void quadto ( Point pt1 , Point pt2 ) { quadto ( pt1 . getX ( ) , pt1 . getY ( ) , pt2 . getX ( ) , pt2 . getY ( ) ) ; } 
public void curveto ( Point pt1 , Point pt2 , Point pt3 ) { curveto ( pt1 . getX ( ) , pt1 . getY ( ) , pt2 . getX ( ) , pt2 . getY ( ) , pt3 . getX ( ) , pt3 . getY ( ) ) ; } 
public void extend ( Point [ ] points ) { boolean first = true ; for ( Point pt : points ) { if ( first ) { 
public BezierPath cloneAndClear ( ) { BezierPath cloned = new BezierPath ( ) ; cloned . setTransform ( getTransform ( ) . clone ( ) ) ; cloned . fillColor = fillColor = = null ? null : fillColor . clone ( ) ; cloned . strokeColor = strokeColor = = null ? null : strokeColor . clone ( ) ; cloned . strokeWidth = strokeWidth ; return cloned ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); } protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); } protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); } protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); } protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseExited ( MouseEvent e ) { } public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); } protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseDragged ( MouseEvent e ) { } public void mouseMoved ( MouseEvent e ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); } protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseMoved ( MouseEvent e ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x - HALF_HANDLE_SIZE, y - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); } protected Rectangle createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rectangle(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
protected void drawDot ( GraphicsContext ctx , double x , double y ) { BezierPath p = new BezierPath ( ) ; p . setFillColor ( HANDLE_COLOR ) ; p . rect ( x - HALF_HANDLE_SIZE , y - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; ctx . draw ( p ) ; } 
protected void drawDot ( BezierPath p , double x , double y ) { p . rect ( x - HALF_HANDLE_SIZE , y - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void draw ( GraphicsContext ctx ) { double x = node . asFloat ( xName ) ; double y = node . asFloat ( yName ) ; double width = node . asFloat ( widthName ) ; double height = node . asFloat ( heightName ) ; BezierPath cornerPath = new BezierPath ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0.0 ) ; drawDot ( cornerPath , x , y ) ; drawDot ( cornerPath , x + width , y ) ; drawDot ( cornerPath , x + width , y + height ) ; drawDot ( cornerPath , x , y + height ) ; ctx . getCanvas ( ) . add ( cornerPath ) ; BezierPath strokePath = new BezierPath ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . rect ( x , y , width , height ) ; ctx . draw ( strokePath ) ; } 
public void draw ( GraphicsContext ctx ) { double x = node . asFloat ( xName ) ; double y = node . asFloat ( yName ) ; drawDot ( ctx , x , y ) ; } 
public boolean asBoolean ( String name ) { return getParameter ( name ) . asBoolean ( ) ; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new VectorNetworkType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public Handle createHandle ( Node node ) { return new DisplayPointsHandle ( node ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; Text = new Text ( node . asString ( " text " ) , node . asFloat ( " x " ) , node . asFloat ( " y " ) ) ; . setWidth ( node . asFloat ( " width " ) ) ; . setHeight ( node . asFloat ( " height " ) ) ; . setFontName ( node . asString ( " fontName " ) ) ; . setFontSize ( node . asFloat ( " fontSize " ) ) ; . setLineHeight ( node . asFloat ( " lineHeight " ) ) ; . setFillColor ( node . asColor ( " fill " ) ) ; g . add ( . getPath ( ) ) ; node . setOutputValue ( g ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; Text = new Text ( node . asString ( " text " ) , node . asFloat ( " x " ) , node . asFloat ( " y " ) ) ; . setWidth ( node . asFloat ( " width " ) ) ; . setHeight ( node . asFloat ( " height " ) ) ; . setFontName ( node . asString ( " fontName " ) ) ; . setFontSize ( node . asFloat ( " fontSize " ) ) ; . setLineHeight ( node . asFloat ( " lineHeight " ) ) ; . setFillColor ( node . asColor ( " fill " ) ) ; g . add ( ) ; node . setOutputValue ( g ) ; return true ; } 
public void testNodeNaming ( ) { Node = numberType . createNode ( ) ; checkInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; checkInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; checkInvalidName ( , " root " , " names can not be one of the reserved words. " ) ; checkInvalidName ( , " network " , " names can not be one of the reserved words. " ) ; checkInvalidName ( , " __reserved " , " names cannot start with double underscores " ) ; checkInvalidName ( , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( , " " , " names cannot be empty " ) ; checkInvalidName ( , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; checkValidName ( , " radius " ) ; checkValidName ( , " _test " ) ; checkValidName ( , " _ " ) ; checkValidName ( , " _1234 " ) ; checkValidName ( , " a1234 " ) ; checkValidName ( , " node1 " ) ; checkValidName ( , " UPPERCASE " ) ; checkValidName ( , " uPpercase " ) ; } 
public void testNaming ( ) { NodeType nt = new TestLibrary . Number ( null ) ; checkInvalidName ( nt , " 1234 " , " names cannot start with a digit. " ) ; checkInvalidName ( nt , " node " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " root " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " network " , " names can not be one of the reserved words. " ) ; checkInvalidName ( nt , " __reserved " , " names cannot start with double underscores " ) ; checkInvalidName ( nt , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( nt , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; checkInvalidName ( nt , " " , " names cannot be empty " ) ; checkInvalidName ( nt , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; checkValidName ( nt , " radius " ) ; checkValidName ( nt , " _test " ) ; checkValidName ( nt , " _ " ) ; checkValidName ( nt , " _1234 " ) ; checkValidName ( nt , " a1234 " ) ; checkValidName ( nt , " UPPERCASE " ) ; checkValidName ( nt , " uPpercase " ) ; checkInvalidName ( nt , " radius " , " parameter type names must be unique for the node type " ) ; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new VectorNetworkType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; Text = new Text ( node . asString ( " text " ) , node . asFloat ( " x " ) , node . asFloat ( " y " ) ) ; . setWidth ( node . asFloat ( " width " ) ) ; . setHeight ( node . asFloat ( " height " ) ) ; . setFontName ( node . asString ( " fontName " ) ) ; . setFontSize ( node . asFloat ( " fontSize " ) ) ; . setLineHeight ( node . asFloat ( " lineHeight " ) ) ; . setFillColor ( node . asColor ( " fill " ) ) ; BezierPath p = new BezierPath ( . getPath ( ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; g . add ( p ) ; node . setOutputValue ( g ) ; return true ; } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; You can only position an image using an affine transformation. We use the transformation to translate the image to the specified position, and scale it according to the given width and height. Transform imageTrans = new Transform(); Move to the image position imageTrans.translate(x, y); Scaling only applies to image that have their desired width and/or height set. However, getScaleFactor return 1 if height/width are not set, in effect negating the effect of the scale. imageTrans.scale(getScaleFactor()); double a = MathUtils.clamp(alpha); Composite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) a); Composite oldComposite = g.getComposite(); g.setComposite(composite); g.drawRenderedImage(image, imageTrans.getAffineTransform()); g.setComposite(oldComposite); restoreTransform(g); } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new VectorNetworkType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; coreimage . addNodeType ( new ImageType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Image img = new Image ( node . asString ( " fileName " ) ) ; img . setX ( node . asFloat ( " x " ) ) ; img . setY ( node . asFloat ( " y " ) ) ; img . setWidth ( node . asFloat ( " width " ) ) ; img . setHeight ( node . asFloat ( " height " ) ) ; img . setAlpha ( node . asFloat ( " alpha " ) ) ; node . setOutputValue ( img ) ; return true ; } 
public static double clamp ( double v ) { return 0 > v ? 0 : 1 < v ? 1 : v ; } 
public void addSearchPath ( String searchPath ) throws RuntimeException { File f = new File ( searchPath ) ; addSearchPath ( f ) ; } 
public void addSearchPath ( File searchPath ) throws RuntimeException { if ( ! searchPath . isDirectory ( ) ) { throw new RuntimeException ( " The given search path \" " + searchPath + " \" is not a directory. " ) ; } this . searchPaths . add ( searchPath ) ; } 
public void testLoad ( ) { initJython ( ) ; NodeTypeLibraryManager manager = new NodeTypeLibraryManager ( ) ; manager . addSearchPath ( getLibrariesDirectory ( ) ) ; Load the test library NodeTypeLibrary testlib = manager.getLibrary("testlib"); assertEquals("testlib", testlib.getName()); assertEquals("0.0.0", testlib.getVersion().toString()); assertFalse(testlib.isLoaded()); Retrieve a type from the library. NodeType negateType = testlib.getNodeType("negate"); Retrieving a type implicitly loads the library. assertTrue(testlib.isLoaded()); assertEquals("negate", negateType.getName()); Try it out Node node = negateType.createNode(); node.set("value", 42); assertTrue(node.update()); assertEquals(-42, node.getOutputValue()); } 
public abstract Pane clone ( ) ; public void activeNetworkChanged ( Network activeNetwork ) { } public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); } public void changePaneType(Class paneType) { if (!Pane.class.isAssignableFrom(paneType)) return; Pane newPane; try { newPane = (Pane) paneType.newInstance(); } catch (Exception e) { e.printStackTrace(); return; } newPane.setDocument(getDocument()); Container parent = getParent(); Dimension d = getSize(); parent.remove(this); parent.add(newPane); newPane.setSize(d); parent.validate(); }} 
public void activeNetworkChanged ( Network activeNetwork ) { } public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); } public void changePaneType(Class paneType) { if (!Pane.class.isAssignableFrom(paneType)) return; Pane newPane; try { newPane = (Pane) paneType.newInstance(); } catch (Exception e) { e.printStackTrace(); return; } newPane.setDocument(getDocument()); Container parent = getParent(); Dimension d = getSize(); parent.remove(this); parent.add(newPane); newPane.setSize(d); parent.validate(); }} 
public void activeNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); } public void changePaneType(Class paneType) { if (!Pane.class.isAssignableFrom(paneType)) return; Pane newPane; try { newPane = (Pane) paneType.newInstance(); } catch (Exception e) { e.printStackTrace(); return; } newPane.setDocument(getDocument()); Container parent = getParent(); Dimension d = getSize(); parent.remove(this); parent.add(newPane); newPane.setSize(d); parent.validate(); }} 
public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); 
public void actionPerformed ( ActionEvent e ) { getPane ( ) . close ( ) ; } 
public Pane clone ( ) { return new EditorPane ( getDocument ( ) ) ; } 
public static String readFile ( File file ) { StringBuffer contents = new StringBuffer ( ) ; try { FileInputStream fstream = new FileInputStream ( file ) ; DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; while ( ( line = br . readLine ( ) ) ! = null ) { contents . append ( line ) ; contents . append ( " " ) ; } in . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( " Could not read file " + file , e ) ; } return contents . toString ( ) ; } 
private void createPythonNodeTypeLibrary ( Attributes attributes ) throws SAXException { String moduleName = requireAttribute ( " library " , attributes , " module " ) ; library . setPythonModuleName ( moduleName ) ; Load python module TODO: This is the central versioning problem. To properly handle this, we need several system states. Py.getSystemState().path.add(new PyString(library.getPath())); library.setPythonModule(imp.importName(moduleName.intern(), true)); } 
private void createNodeType ( Attributes attributes ) throws SAXException { String name = requireAttribute ( " type " , attributes , " name " ) ; String outputTypeName = requireAttribute ( " type " , attributes , " outputType " ) ; String functionName = requireAttribute ( " type " , attributes , " method " ) ; ParameterType . Type outputType = ParameterType . parseType ( outputTypeName ) ; PyObject module = library . getPythonModule ( ) ; PyObject functionObject ; try { functionObject = module . __getattr__ ( functionName . intern ( ) ) ; } catch ( Exception e ) { throwLibraryException ( " the method ' " + name + " ' does not exist in the module " + module ) ; return ; } PyFunction function = null ; try { function = ( PyFunction ) functionObject ; } catch ( ClassCastException e ) { throwLibraryException ( " the module attribute ' " + functionName + " ' is not a Python function. " ) ; } currentNodeType = new PythonNodeType ( library , name , outputType , function ) ; library . addNodeType ( currentNodeType ) ; } 
public void run ( ) { instance = new Application ( ) ; instance . createNewDocument ( ) ; } 
private Network createEmptyNetwork ( ) { NodeTypeLibraryManager manager = getManager ( ) ; NodeType canvasNetworkType = manager . getNodeType ( " corecanvas.canvasnet " ) ; return ( Network ) canvasNetworkType . createNode ( ) ; } 
private Network createTestNetwork ( ) { NodeTypeLibraryManager manager = getManager ( ) ; NodeType canvasNetworkType = manager . getNodeType ( " corecanvas.canvasnet " ) ; NodeType vectorNetworkType = manager . getNodeType ( " corevector.vecnet " ) ; NodeType imageNetworkType = manager . getNodeType ( " coreimage.imagenet " ) ; NodeType ellipseType = manager . getNodeType ( " corevector.ellipse " ) ; NodeType rectType = manager . getNodeType ( " corevector.rect " ) ; NodeType transformType = manager . getNodeType ( " corevector.transform " ) ; NodeType allControlsType = new AllControlsType ( null ) ; Network network = ( Network ) canvasNetworkType . createNode ( ) ; Node allControls = network . create ( allControlsType ) ; allControls . setPosition ( 200 , 10 ) ; allControls . setRendered ( ) ; Network vector1 = ( Network ) network . create ( vectorNetworkType ) ; vector1 . setPosition ( 10 , 10 ) ; vector1.setRendered(); Network vector2 = (Network) network.create(vectorNetworkType); vector2.setPosition(10, 110); Network image1 = (Network) network.create(imageNetworkType); image1.setPosition(10, 210); Network image2 = (Network) network.create(imageNetworkType); image2.setPosition(10, 310); Node ellipse1 = vector1.create(ellipseType); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node ellipse2 = vector1.create(ellipseType); ellipse2.setPosition(100, 130); Node transform1 = vector1.create(transformType); transform1.setPosition(300, 230); Node rect1 = vector2.create(rectType); rect1.setPosition(40, 40); rect1.setRendered(); Node transform2 = vector2.create(transformType); transform2.setPosition(40, 80); transform2.setRendered(); transform2.getParameter("shape").connect(rect1); return network; } 
public boolean readFromFile ( File file ) { FileInputStream fis ; try { Load the document fis = new FileInputStream(file); InputSource source = new InputSource(fis); Setup the parser SAXParserFactory spf = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. spf.setFeature("http:xml.org/sax/features/validation", false); spf.setFeature("http:xml.org/sax/features/external-parameter-entities", false); spf.setFeature("http:xml.org/sax/features/external-general-entities", false); spf.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); SAXParser parser = spf.newSAXParser(); XmlHandler handler = new XmlHandler(getManager()); parser.parse(source, handler); The parsed network is now stored in the reader setRootNetwork(handler.getNetwork()); setDocumentFile(file); documentChanged = false; return true; } catch (ParserConfigurationException e) { logger.log(Level.SEVERE, "Error during configuration", e); } catch (IOException e) { logger.log(Level.SEVERE, "Error while reading " + file, e); } catch (SAXException e) { logger.log(Level.SEVERE, "Error while parsing" + file, e); } return false; } 
private void reload ( ) { NodeTypeLibrary library = node . getNodeType ( ) . getLibrary ( ) ; if ( library instanceof PythonNodeTypeLibrary ) { PythonNodeTypeLibrary pythonLibrary = ( PythonNodeTypeLibrary ) library ; File moduleFile = pythonLibrary . getPythonModuleFile ( ) ; if ( moduleFile ! = null ) { String code = codeArea . getText ( ) ; FileUtils . writeFile ( moduleFile , code ) ; } } getDocument ( ) . reloadActiveNode ( ) ; } 
public void actionPerformed ( ActionEvent e ) { reload ( ) ; } 
public static void writeFile ( File file , String s ) { try { Writer out = new BufferedWriter ( new FileWriter ( file ) ) ; 
private void initMenu ( ) { JMenuBar menuBar = new JMenuBar ( ) ; File menu JMenu fileMenu = new JMenu("File"); fileMenu.add(newAction); fileMenu.add(openAction); recentFileMenu = new JMenu("Open Recent"); buildRecentFileMenu(); fileMenu.add(recentFileMenu); fileMenu.addSeparator(); fileMenu.add(closeAction); fileMenu.add(saveAction); fileMenu.add(saveAsAction); fileMenu.add(revertAction); fileMenu.addSeparator(); fileMenu.add(exportAction); if (!PlatformUtils.onMac()) { fileMenu.addSeparator(); fileMenu.add(quitAction); } menuBar.add(fileMenu); Edit menu JMenu editMenu = new JMenu("Edit"); editMenu.add(undoAction); editMenu.add(redoAction); editMenu.addSeparator(); editMenu.add(cutAction); editMenu.add(copyAction); editMenu.add(pasteAction); editMenu.addSeparator(); editMenu.add(deleteAction); menuBar.add(editMenu); Node menu JMenu pythonMenu = new JMenu("Node"); pythonMenu.add(reloadAction); menuBar.add(pythonMenu); Window menu JMenu windowMenu = new JMenu("Window"); JMenu layoutMenu = new JMenu("Layout"); layoutMenu.add(new ) windowMenu.add(minimizeAction); windowMenu.add(zoomAction); windowMenu.addSeparator(); windowMenu.add(layoutMenu); windowMenu.addSeparator(); windowMenu.add(bringAllToFrontAction); windowMenu.addSeparator(); menuBar.add(windowMenu); Help menu JMenu helpMenu = new JMenu("Help"); helpMenu.add(nodeboxSiteAction); menuBar.add(helpMenu); setJMenuBar(menuBar); } 
public boolean reloadActiveNode ( ) { if ( activeNode = = null ) return false ; return activeNode . getNodeType ( ) . reload ( ) ; } 
public void actionPerformed ( ActionEvent e ) { } } public class ExportAction extends AbstractAction { public ExportAction ( ) { putValue ( NAME , " Export " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_E ) ) ; } public void actionPerformed ( ActionEvent e ) { export ( ) ; } } public class QuitAction extends AbstractAction { public QuitAction ( ) { putValue ( NAME , " Quit " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Q ) ) ; } public void actionPerformed ( ActionEvent e ) { quit ( ) ; } } public class UndoAction extends AbstractAction { public UndoAction ( ) { putValue ( NAME , " Undo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . undo ( ) ; } catch ( CannotUndoException ex ) { logger . log ( Level . WARNING , " Unable to undo. " , ex ) ; } update ( ) ; redoAction . update ( ) ; } public void update ( ) { if ( undo . canUndo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getUndoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Undo " ) ; } } } public class RedoAction extends AbstractAction { public RedoAction ( ) { putValue ( NAME , " Redo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z , Event . SHIFT_MASK ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . redo ( ) ; } catch ( CannotRedoException ex ) { logger . log ( Level . WARNING , " Unable to redo. " , ex ) ; } update ( ) ; undoAction . update ( ) ; } public void update ( ) { if ( undo . canRedo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getRedoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Redo " ) ; } } } public class CutAction extends AbstractAction { public CutAction ( ) { putValue ( NAME , " Cut " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_X ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { reloadActiveNode ( ) ; } 
public boolean reload ( ) { Default implementation does nothing return false; } 
public Node createNode ( ) { Node = super . createNode ( ) ; instanceRefs . add ( new WeakReference < Node > ( ) ) ; return ; } 
public boolean reload ( ) { return getLibrary ( ) . reload ( ) ; } 
public void reloadPython ( ) { Retrieve the method from the new python module. PyObject module = ((PythonNodeTypeLibrary) getLibrary()).getPythonModule(); String functionName = function.__name__.intern(); PyObject functionObject; try { functionObject = module.__getattr__(functionName); } catch (Exception e) { throw new RuntimeException("the method '" + functionName + "' does not exist in the module " + module, e); } try { this.function = (PyFunction) functionObject; } catch (ClassCastException e) { throw new RuntimeException("the module attribute '" + functionName + "' is not a Python function.", e); } Mark all instances as dirty. for (WeakReference<Node> ref : instanceRefs) { Node n = ref.get(); 
private void createPythonNodeTypeLibrary ( Attributes attributes ) throws SAXException { String moduleName = requireAttribute ( " library " , attributes , " module " ) ; library . setPythonModuleName ( moduleName ) ; Load python module TODO: This is the central versioning problem. To properly handle this, we need several system states. Py.getSystemState().path.add(new PyString(library.getPath())); library.setPythonModule((PyModule) imp.importName(moduleName.intern(), true)); } 
private void load ( ) { manager = new NodeTypeLibraryManager ( ) ; manager . addSearchPath ( PlatformUtils . getUserNodeTypeLibraryDirectory ( ) ) ; int tasks = manager . getLibraries ( ) . size ( ) + 1 ; startupDialog = new ProgressDialog ( null , " Starting NodeBox " , tasks ) ; startupDialog . setVisible ( true ) ; Initialize Jython startupDialog.setMessage("Loading Python"); Thread t = new Thread(new PythonLoader()); t.start(); } 
private void pythonLoadedEvent ( ) { startupDialog . tick ( ) ; Thread = new Thread ( new LibraryLoader ( ) ) ; . start ( ) ; } 
private void librariesLoadedEvent ( ) { startupDialog . setVisible ( false ) ; instance . createNewDocument ( ) ; } 
public void run ( ) { Properties jythonProperties = new Properties ( ) ; String jythonCacheDir = PlatformUtils . getUserDataDirectory ( ) + PlatformUtils . SEP + " jythoncache " ; jythonProperties . put ( " python.cachedir " , jythonCacheDir ) ; PySystemState . initialize ( System . getProperties ( ) , jythonProperties , new String [ ] { " " } ) ; String workingDirectory = System . getProperty ( " user.dir " ) ; File pythonLibraries = new File ( workingDirectory , " lib " + PlatformUtils . SEP + " python2.5 " ) ; Py . getSystemState ( ) . path . add ( new PyString ( pythonLibraries . getAbsolutePath ( ) ) ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { Application . getInstance ( ) . pythonLoadedEvent ( ) ; } 
public void run ( ) { startupDialog . tick ( ) ; } 
public void run ( ) { Application . getInstance ( ) . librariesLoadedEvent ( ) ; } 
public void run ( ) { startupDialog . setMessage ( message ) ; } 
public void run ( ) { instance = new Application ( ) ; instance . load ( ) ; } 
public void updateProgress ( ) { progressBar . setValue ( tasksCompleted ) ; double percentage = ( double ) ( tasksCompleted ) / ( double ) ( taskCount ) ; int ip = ( int ) ( percentage * 100 ) ; progressLabel . setText ( ip + " % " ) ; repaint ( ) ; } 
public void tick ( ) { Increment the tasks completed, but it can never be higher than the number of tasks. tasksCompleted = Math.min(tasksCompleted + 1, taskCount); updateProgress(); } 
public void paintIcon ( Component c , Graphics g , int x , int y ) { g . setColor ( color ) ; g . translate ( x , y ) ; g . drawLine ( 0 , 3 , 5 , 3 ) ; g . drawLine ( 0 , 4 , 5 , 4 ) ; g . drawLine ( 2 , 1 , 2 , 6 ) ; g . drawLine ( 3 , 1 , 3 , 6 ) ; } 
public void paintIcon ( Component c , Graphics g , int x , int y ) { g . setColor ( color ) ; g . translate ( x , y ) ; g . drawLine ( 0 , 3 , 5 , 3 ) ; g . drawLine ( 0 , 4 , 5 , 4 ) ; } 
public void paintIcon ( Component component , Graphics g , int x , int y ) { g . setColor ( color ) ; g . translate ( x , y ) ; if ( direction = = NORTH ) { g . drawLine ( 3 , 1 , 3 , 1 ) ; g . drawLine ( 2 , 2 , 4 , 2 ) ; g . drawLine ( 1 , 3 , 5 , 3 ) ; g . drawLine ( 0 , 4 , 6 , 4 ) ; } else if ( direction = = EAST ) { g . drawLine ( 1 , 0 , 1 , 6 ) ; g . drawLine ( 2 , 1 , 2 , 5 ) ; g . drawLine ( 3 , 2 , 3 , 4 ) ; g . drawLine ( 4 , 3 , 4 , 3 ) ; } else if ( direction = = SOUTH ) { g . drawLine ( 0 , 1 , 6 , 1 ) ; g . drawLine ( 1 , 2 , 5 , 2 ) ; g . drawLine ( 2 , 3 , 4 , 3 ) ; g . drawLine ( 3 , 4 , 3 , 4 ) ; } else if ( direction = = WEST ) { g . drawLine ( 4 , 0 , 4 , 6 ) ; g . drawLine ( 3 , 1 , 3 , 5 ) ; g . drawLine ( 2 , 2 , 2 , 4 ) ; g . drawLine ( 1 , 3 , 1 , 3 ) ; } g . translate ( - x , - y ) ; 
public void actionPerformed ( ActionEvent e ) { addParameterType ( ) ; } 
public void actionPerformed ( ActionEvent e ) { removeSelectedParameterType ( ) ; } 
public void actionPerformed ( ActionEvent e ) { moveUp ( ) ; } 
public void actionPerformed ( ActionEvent e ) { moveDown ( ) ; } 
private void addParameterType ( ) { String parameterName = JOptionPane . showInputDialog ( " Enter parameter name " ) ; if ( parameterName ! = null ) { ParameterType pType = nodeType . addParameterType ( parameterName , ParameterType . Type . ANGLE ) ; 
private void moveDown ( ) { if ( selectedParameterType = = null ) return ; java . util . List < ParameterType > parameterTypes = nodeType . getParameterTypes ( ) ; int index = parameterTypes . indexOf ( selectedParameterType ) ; assert ( index > = 0 ) ; if ( index > = parameterTypes . size ( ) - 1 ) return ; parameterTypes . remove ( selectedParameterType ) ; parameterTypes . add ( index + 1 , selectedParameterType ) ; reloadParameterTypeList ( ) ; parameterList . setSelectedIndex ( index + 1 ) ; } 
private void moveUp ( ) { if ( selectedParameterType = = null ) return ; java . util . List < ParameterType > parameterTypes = nodeType . getParameterTypes ( ) ; int index = parameterTypes . indexOf ( selectedParameterType ) ; assert ( index > = 0 ) ; if ( index = = 0 ) return ; parameterTypes . remove ( selectedParameterType ) ; parameterTypes . add ( index - 1 , selectedParameterType ) ; reloadParameterTypeList ( ) ; parameterList . setSelectedIndex ( index - 1 ) ; } 
private void reloadParameterTypeList ( ) { parameterList . setModel ( parameterListModel ) ; parameterList . repaint ( ) ; } 
public static void main ( String [ ] args ) { JFrame editorFrame = new JFrame ( ) ; editorFrame . getContentPane ( ) . add ( new NodeTypeEditor ( ) ) ; editorFrame . setSize ( 800 , 800 ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; editorFrame . setVisible ( true ) ; } 
public void initParameterPanel ( ) { parameterPanel = new JPanel ( ) ; parameterPanel . setLayout ( new BoxLayout ( parameterPanel , BoxLayout . Y_AXIS ) ) ; JPanel contentPanel = new JPanel ( new GridLayout ( 10 , 2 , 10 , 5 ) ) ; contentPanel . add ( new JLabel ( " Name " ) ) ; nameField = new JTextField ( 20 ) ; nameField . setEditable ( false ) ; contentPanel . add ( nameField ) ; contentPanel . add ( new JLabel ( " Label " ) ) ; labelField = new JTextField ( 20 ) ; labelField . addActionListener ( this ) ; contentPanel . add ( labelField ) ; contentPanel . add ( new JLabel ( " Description " ) ) ; descriptionField = new JTextField ( 20 ) ; descriptionField . addActionListener ( this ) ; contentPanel . add ( descriptionField ) ; contentPanel . add ( new JLabel ( " Type " ) ) ; typeBox = new JComboBox ( new String [ ] { " angle " , " color " , " file " , " float " , " font " , " gradient " , " image " , " int " , " menu " , " seed " , " string " , " text " , " toggle " , " noderef " , " grob_canvas " , " grob_vector " , " grob_image " } ) ; typeBox . addActionListener ( this ) ; contentPanel . add ( typeBox ) ; contentPanel . add ( new JLabel ( " Default Value " ) ) ; defaultValueField = new JTextField ( 20 ) ; defaultValueField . addActionListener ( this ) ; contentPanel . add ( defaultValueField ) ; contentPanel . add ( new JLabel ( " " ) ) ; nullAllowedCheck = new JCheckBox ( " Null allowed " ) ; nullAllowedCheck . addActionListener ( this ) ; contentPanel . add ( nullAllowedCheck ) ; contentPanel . add ( new JLabel ( " Bounding " ) ) ; boundingMethodBox = new JComboBox ( new String [ ] { " none " , " soft " , " hard " } ) ; boundingMethodBox . addActionListener ( this ) ; contentPanel . add ( boundingMethodBox ) ; contentPanel . add ( new JLabel ( " Minimum " ) ) ; minimumValueCheck = new JCheckBox ( ) ; minimumValueCheck . addActionListener ( this ) ; minimumValueField = new JTextField ( 10 ) ; minimumValueField . addActionListener ( this ) ; JPanel minimumValuePanel = new JPanel ( new FlowLayout ( FlowLayout . LEADING , 5 , 0 ) ) ; minimumValuePanel . add ( minimumValueCheck ) ; minimumValuePanel . add ( minimumValueField ) ; contentPanel . add ( minimumValuePanel ) ; contentPanel . add ( new JLabel ( " Maximum " ) ) ; maximumValueCheck = new JCheckBox ( ) ; maximumValueCheck . addActionListener ( this ) ; maximumValueField = new JTextField ( 10 ) ; maximumValueField . addActionListener ( this ) ; JPanel maximumValuePanel = new JPanel ( new FlowLayout ( FlowLayout . LEADING , 5 , 0 ) ) ; maximumValuePanel . add ( maximumValueCheck ) ; maximumValuePanel . add ( maximumValueField ) ; contentPanel . add ( maximumValuePanel ) ; contentPanel . add ( new JLabel ( " Display Level " ) ) ; displayLevelBox = new JComboBox ( new String [ ] { " hud " , " detail " , " hidden " } ) ; displayLevelBox . addActionListener ( this ) ; contentPanel . add ( displayLevelBox ) ; parameterPanel . add ( contentPanel ) ; Dimension fillDimension = new Dimension ( 0 , Integer . MAX_VALUE ) ; parameterPanel . add ( new Box . Filler ( fillDimension , fillDimension , fillDimension ) ) ; } 
public void clearForm ( ) { nameField . setText ( " " ) ; labelField . setText ( " " ) ; descriptionField . setText ( " " ) ; typeBox . setSelectedIndex ( 0 ) ; defaultValueField . setText ( " " ) ; nullAllowedCheck . setSelected ( false ) ; boundingMethodBox . setSelectedIndex ( 0 ) ; minimumValueCheck . setSelected ( false ) ; minimumValueField . setText ( " " ) ; maximumValueCheck . setSelected ( false ) ; maximumValueField . setText ( " " ) ; displayLevelBox . setSelectedIndex ( 0 ) ; } 
public void valueChanged ( ListSelectionEvent e ) { if ( selectedParameterType = = parameterList . getSelectedValue ( ) ) return ; selectedParameterType = ( ParameterType ) parameterList . getSelectedValue ( ) ; if ( selectedParameterType = = null ) { setFormEnabled ( false ) ; clearForm ( ) ; removeButton . setEnabled ( false ) ; } else { setFormEnabled ( true ) ; removeButton . setEnabled ( true ) ; nameField . setText ( selectedParameterType . getName ( ) ) ; labelField . setText ( selectedParameterType . getLabel ( ) ) ; descriptionField . setText ( selectedParameterType . getDescription ( ) ) ; typeBox . setSelectedItem ( selectedParameterType . getType ( ) . toString ( ) . toLowerCase ( ) ) ; defaultValueField . setText ( selectedParameterType . getDefaultValue ( ) . toString ( ) ) ; nullAllowedCheck . setSelected ( selectedParameterType . isNullAllowed ( ) ) ; ParameterType . BoundingMethod boundingMethod = selectedParameterType . getBoundingMethod ( ) ; boundingMethodBox . setSelectedItem ( boundingMethod . toString ( ) . toLowerCase ( ) ) ; Object minimumValue = selectedParameterType . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = selectedParameterType . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; displayLevelBox . setSelectedItem ( selectedParameterType . getDisplayLevel ( ) . toString ( ) . toLowerCase ( ) ) ; } parameterPanel . revalidate ( ) ; } 
public boolean removeParameterType ( ParameterType parameterType ) { if ( parameterTypes . remove ( parameterType ) ) { TODO: This has an effect on the instantiated nodes that contain this parameter. return true; } return false; } 
public boolean canConnectTo ( Node outputNode ) { if ( ! node . inNetwork ( ) ) return false ; if ( ! outputNode . inNetwork ( ) ) return false ; if ( node . getNetwork ( ) ! = outputNode . getNetwork ( ) ) return false ; return outputNode . getOutputParameter ( ) . getCoreType ( ) = = getCoreType ( ) ; } 
public void testConnect ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node ng = net . create ( numberType ) ; Node m = net . create ( multiplyType ) ; assertFalse ( m . getParameter ( " v1 " ) . isConnected ( ) ) ; assertFalse ( m . getParameter ( " v1 " ) . isConnectedTo ( ng ) ) ; assertFalse ( ng . isOutputConnected ( ) ) ; assertFalse ( ng . isOutputConnectedTo ( m ) ) ; assertFalse ( ng . isOutputConnectedTo ( m . getParameter ( " v1 " ) ) ) ; assertTrue ( m . getParameter ( " v1 " ) . canConnectTo ( ng ) ) ; assertTrue ( m . getParameter ( " v2 " ) . canConnectTo ( ng ) ) ; assertFalse ( m . getParameter ( " somestring " ) . canConnectTo ( ng ) ) ; Connection conn = m . getParameter ( " v1 " ) . connect ( ng ) ; assertTrue ( m . getParameter ( " v1 " ) . isConnected ( ) ) ; assertTrue ( m . getParameter ( " v1 " ) . isConnectedTo ( ng ) ) ; assertTrue ( ng . isOutputConnected ( ) ) ; assertTrue ( ng . isOutputConnectedTo ( m ) ) ; assertTrue ( ng . isOutputConnectedTo ( m . getParameter ( " v1 " ) ) ) ; assertEquals ( m . getParameter ( " v1 " ) , conn . getInputParameter ( ) ) ; assertEquals ( ng . getOutputParameter ( ) , conn . getOutputParameter ( ) ) ; assertEquals ( m , conn . getInputNode ( ) ) ; assertEquals ( ng , conn . getOutputNode ( ) ) ; assertConnectionError ( m , " somestring " , ng , " Somestring is of the wrong type and should not be connectable to NumberGenerator's output. " ) ; } 
public void testDirtyPropagation ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node ng = net . create ( numberType ) ; Node m = net . create ( multiplyType ) ; Nodes start out dirty assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating makes them clean ng.update(); m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Connecting the multiplier to another node makes it dirty. The output node doesn't become dirty. m.getParameter("v1").connect(ng); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(ng.isDirty()); This shouldn't have changed. assertFalse(m.isDirty()); A change to the upstream node should make downstream nodes dirty. ng.set("value", 12); assertTrue(ng.isDirty()); assertTrue(m.isDirty()); Updating the downstream node should make all upstreams clean, because their output values are needed to calculate the downstream. m.update(); assertFalse(ng.isDirty()); assertFalse(m.isDirty()); Changes to the downstream node don't affect upstreams. m.set("v2", 1); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); Disconnecting makes the downstream dirty. m.getParameter("v1").disconnect(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); Check is disconnected nodes still propagate. ng.update(); assertFalse(ng.isDirty()); assertTrue(m.isDirty()); m.update(); assertFalse(m.isDirty()); ng.set("value", 13); assertTrue(ng.isDirty()); assertFalse(m.isDirty()); } 
public void testValuePropagation ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node ng = net . create ( numberType ) ; Node m = net . create ( multiplyType ) ; m . set ( " v2 " , 2 ) ; m . getParameter ( " v1 " ) . connect ( ng ) ; assertEquals ( 0 , m . getOutputValue ( ) ) ; ng . set ( " value " , 3 ) ; assertTrue ( m . isDirty ( ) ) ; assertEquals ( 0 , m . getOutputValue ( ) ) ; Updating the NumberGenerator node has no effect on the multiplier node. ng.update(); assertTrue(m.isDirty()); assertEquals(0, m.getOutputValue()); m.update(); assertFalse(m.isDirty()); assertEquals(6, m.getOutputValue()); Test if value stops propagating after disconnection. m.getParameter("v1").disconnect(); assertTrue(m.isDirty()); assertFalse(ng.isDirty()); ng.set("value", 3); m.update(); assertEquals(0, m.getOutputValue()); } 
public void testDisconnect ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node ng = net . create ( numberType ) ; Node m = net . create ( multiplyType ) ; m . set ( " v2 " , 2 ) ; ng . set ( " value " , 5 ) ; m . getParameter ( " v1 " ) . connect ( ng ) ; assertTrue ( m . getParameter ( " v1 " ) . isConnected ( ) ) ; assertTrue ( ng . isOutputConnected ( ) ) ; m . update ( ) ; assertEquals ( 5 , m . asInt ( " v1 " ) ) ; assertEquals ( 10 , m . getOutputValue ( ) ) ; m . getParameter ( " v1 " ) . disconnect ( ) ; assertTrue ( m . isDirty ( ) ) ; assertFalse ( ng . isDirty ( ) ) ; assertFalse ( m . getParameter ( " v1 " ) . isConnected ( ) ) ; assertFalse ( ng . isOutputConnected ( ) ) ; Numbers reverts to default after disconnection m.update(); assertEquals(0, m.getOutputValue()); } 
public void testBasicCopy ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; Node copy = net . create ( manager . getNodeType ( " corevector.copy " ) ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 100 ) , g . getBounds ( ) ) ; copy . setValue ( " ty " , 100.0 ) ; copy . setValue ( " copies " , 5 ) ; copy . update ( ) ; g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 100 , 500 ) , g . getBounds ( ) ) ; } 
public boolean connect ( Parameter outputParameter ) { this . outputParameter = outputParameter ; return true ; } 
public boolean disconnect ( Parameter outputParameter ) { assert ( outputParameter = = this . outputParameter ) ; this . outputParameter = null ; return true ; } 
public Connection connect ( Node input , String paramName , Node output ) { Parameter inputParam = input . getParameter ( paramName ) ; Parameter outputParam = output . getOutputParameter ( ) ; return connect ( inputParam , outputParam ) ; } 
public Connection connect ( Parameter input , Parameter output ) { Sanity checks if (!input.isConnectable()) throw new ConnectionError(input.getNode(), input, "Input parameter is not connectable."); if (!output.isConnectable()) throw new ConnectionError(input.getNode(), input, "Output parameter is not connectable."); if (!input.isInputParameter()) throw new ConnectionError(input.getNode(), input, "Input parameter is not an input parameter."); if (!output.isOutputParameter()) throw new ConnectionError(input.getNode(), output, "Output parameter is not an output parameter."); if (input.getNetwork() != this) throw new ConnectionError(input.getNode(), output, "The input parameter is not in this network."); if (!input.canConnectTo(output)) throw new ConnectionError(input.getNode(), output, "The parameter types do not match."); if (output.getNetwork() != this) throw new ConnectionError(input.getNode(), output, "The output parameter is not in this network."); if (input == output) throw new ConnectionError(input.getNode(), output, "The input and output parameter are the same."); Check if there is already a connection between the input and output. if (input.isConnectedTo(output)) return null; Connection conn = (Connection) upstreams.get(input); if (conn == null) { No connection yet conn = new Connection(output, input); addUpstreamConnection(input, conn); addDownstreamConnection(output, conn); } else { There is a connection if (input.isMultiInput()) { If the connection is multi-connect, add to the connection if (conn.connect(output)) { addDownstreamConnection(output, conn); } } else { On single-connect, remove previous connection first. disconnect(input, conn.getOutputParameter()); Make new connection if (conn.connect(output)) { addUpstreamConnection(input, conn); addDownstreamConnection(output, conn); } } } input.getNode().markDirty(); fireConnectionAdded(conn); return conn; } 
public boolean disconnect ( Parameter input , Parameter output ) { assert input . getNode ( ) . getNetwork ( ) = = this ; assert output . getNode ( ) . getNetwork ( ) = = this ; assert input . isConnectable ( ) ; assert output . isConnectable ( ) ; assert output . isOutputParameter ( ) ; Find the connection first, if it can be found. Connection conn = upstreams.get(input); if (conn != null) { if (conn.disconnect(output)) { 
public boolean disconnect ( Parameter inputParameter ) { Connection conn = getConnection ( inputParameter ) ; if ( conn = = null ) return false ; boolean downstreamRemoved = disconnect ( conn . getInputParameter ( ) , conn . getOutputParameter ( ) ) ; assert ( downstreamRemoved ) ; inputParameter . revertToDefault ( ) ; fireConnectionRemoved ( conn ) ; return true ; } 
public boolean isConnected ( Parameter param ) { if ( param . isOutputParameter ( ) ) { return downstreams . containsKey ( param ) ; 
private void addUpstreamConnection ( Parameter input , Connection connection ) { upstreams . put ( input , connection ) ; } 
private void addDownstreamConnection ( Parameter output , Connection connection ) { List < Connection > connectionList ; connectionList = downstreams . get ( output ) ; if ( connectionList = = null ) { connectionList = new ArrayList < Connection > ( ) ; } connectionList . add ( connection ) ; downstreams . put ( output , connectionList ) ; } 
private void removeUpstreamConnection ( Parameter input ) { upstreams . remove ( input ) ; } 
private void removeDownstreamConnection ( Parameter output , Connection conn ) { List < Connection > connections = downstreams . get ( output ) ; connections . remove ( conn ) ; if ( connections . isEmpty ( ) ) { downstreams . remove ( output ) ; 
public boolean isConnected ( ) { return getNetwork ( ) . isConnected ( this ) ; } 
public boolean isConnectedTo ( Parameter inputParameter ) { Output paramters can only be connected to input parameters. if (inputParameter instanceof OutputParameter) return false; return getNetwork().isConnectedTo(inputParameter, this); } 
public boolean isOutputParameter ( ) { return ! isInputParameter ( ) ; } 
public boolean isConnected ( ) { if ( getNetwork ( ) = = null ) return false ; return getNetwork ( ) . isConnected ( this ) ; } 
public boolean isConnectedTo ( Parameter parameter ) { if ( ! isConnected ( ) ) return false ; Parameters can only be connected to output parameters. if (!(parameter instanceof OutputParameter)) return false; return getNode().getNetwork().isConnectedTo(this, parameter); } 
public boolean isConnectedTo ( Node node ) { if ( ! isConnected ( ) ) return false ; return getNetwork ( ) . isConnectedTo ( this , node . getOutputParameter ( ) ) ; } 
public Connection connect ( Node outputNode ) { return getNetwork ( ) . connect ( this , outputNode . getOutputParameter ( ) ) ; } 
public boolean disconnect ( ) { return getNetwork ( ) . disconnect ( this ) ; } 
public void update ( ProcessingContext ctx ) { if ( isConnected ( ) ) { getConnection ( ) . getOutputNode ( ) . update ( ctx ) ; Object outputValue = getConnection ( ) . getOutputNode ( ) . getOutputValue ( ) ; validate ( outputValue ) ; value = outputValue ; } if ( hasExpression ( ) ) { Update expression connections 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.rect")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); }} 
public void testDependencies ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; Node copy = net . create ( manager . getNodeType ( " corevector.copy " ) ) ; rect . getParameter ( " y " ) . setExpression ( " x " ) ; List < Parameter > dependencies = rect . getParameter ( " y " ) . getDependencies ( ) ; assertEquals ( 1 , dependencies . size ( ) ) ; assertEquals ( rect . getParameter ( " x " ) , dependencies . get ( 0 ) ) ; rect . getParameter ( " y " ) . setExpression ( " copy1.ty + x " ) ; dependencies = rect . getParameter ( " y " ) . getDependencies ( ) ; assertEquals ( 2 , dependencies . size ( ) ) ; assertTrue ( dependencies . contains ( copy . getParameter ( " ty " ) ) ) ; assertTrue ( dependencies . contains ( rect . getParameter ( " x " ) ) ) ; } 
public boolean hasCycles ( ) { for ( Parameter vertex : vertices ) { marks . put ( vertex , Color . WHITE ) ; } for ( Parameter vertex : vertices ) { if ( marks . get ( vertex ) = = Color . WHITE ) { if ( visit ( vertex ) ) return true ; } } return false ; } 
private boolean visit ( Parameter vertex ) { marks . put ( vertex , Color . GRAY ) ; for ( Parameter input : edges . get ( vertex ) ) { if ( ! marks . containsKey ( input ) ) continue ; if ( marks . get ( input ) = = Color . GRAY ) { return true ; } else if ( marks . get ( input ) = = Color . WHITE ) { if ( visit ( input ) ) return true ; } } marks . put ( vertex , Color . BLACK ) ; return false ; } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.ellipse")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); } public void testCycles() { Network net = (Network) testNetworkType.createNode(); Node n1 = net.create(numberType); Node n2 = net.create(numberType); n2.getParameter("value").connect(n1); CycleDetector cd = CycleDetector.initWithNetwork(net); assertFalse(cd.hasCycles()); n1.getParameter("value").connect(n2); cd = CycleDetector.initWithNetwork(net); assertTrue(cd.hasCycles()); }} 
public void testCopy ( ) { Network vector1 = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node ellipse1 = vector1 . create ( manager . getNodeType ( " corevector.ellipse " ) ) ; ellipse1 . setRendered ( ) ; vector1 . update ( ) ; assertFalse ( vector1 . getOutputValue ( ) = = ellipse1 . getOutputValue ( ) ) ; } 
public void testCycles ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node n1 = net . create ( numberType ) ; Node n2 = net . create ( numberType ) ; n2 . getParameter ( " value " ) . connect ( n1 ) ; CycleDetector cd = CycleDetector . initWithNetwork ( net ) ; assertFalse ( cd . hasCycles ( ) ) ; n1 . getParameter ( " value " ) . connect ( n2 ) ; cd = CycleDetector . initWithNetwork ( net ) ; assertTrue ( cd . hasCycles ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { try { parameter . setExpression ( expressionField . getText ( ) ) ; 
public boolean isExplicit ( ) { return type = = Type . EXPLICIT ; } 
public boolean isImplicit ( ) { return type = = Type . IMPLICIT ; } 
public Connection connect ( Node outputNode , Node inputNode , String parameterName ) { Parameter outputParameter = outputNode . getOutputParameter ( ) ; Parameter inputParameter = inputNode . getParameter ( parameterName ) ; return connect ( outputParameter , inputParameter ) ; } 
public Connection connect ( Parameter outputParameter , Parameter inputParameter ) { return connect ( outputParameter , inputParameter , Connection . Type . EXPLICIT ) ; } 
public Connection connect ( Parameter outputParameter , Parameter inputParameter , Connection . Type type ) { Sanity checks if (!inputParameter.isConnectable()) throw new ConnectionError(inputParameter.getNode(), inputParameter, "Input parameter is not connectable."); if (!outputParameter.isConnectable()) throw new ConnectionError(inputParameter.getNode(), inputParameter, "Output parameter is not connectable."); if (!inputParameter.isInputParameter()) throw new ConnectionError(inputParameter.getNode(), inputParameter, "Input parameter is not an input parameter."); if (type == Connection.Type.EXPLICIT && !outputParameter.isOutputParameter()) throw new ConnectionError(inputParameter.getNode(), outputParameter, "Output parameter is not an output parameter."); if (inputParameter.getNetwork() != this) throw new ConnectionError(inputParameter.getNode(), outputParameter, "The input parameter is not in this network."); if (!inputParameter.canConnectTo(outputParameter)) throw new ConnectionError(inputParameter.getNode(), outputParameter, "The parameter types do not match."); if (type == Connection.Type.EXPLICIT && outputParameter.getNetwork() != this) throw new ConnectionError(inputParameter.getNode(), outputParameter, "The output parameter is not in this network."); if (inputParameter == outputParameter) throw new ConnectionError(inputParameter.getNode(), outputParameter, "The input and output parameter are the same."); Check if there already is a connection of the same type between the input and output. Connection conn = getConnection(inputParameter, outputParameter, type); if (conn != null) return conn; Check if there already is an explicit (non-expression) connection on this input. if (type == Connection.Type.EXPLICIT) { Connection explicitConn = getExplicitConnection(inputParameter); if (explicitConn != null) { TODO: Multi-input input parameters should not automatically disconnect. disconnect(outputParameter, inputParameter, type); } } conn = new Connection(outputParameter, inputParameter, type); addUpstreamConnection(inputParameter, conn); addDownstreamConnection(outputParameter, conn); inputParameter.getNode().markDirty(); fireConnectionAdded(conn); return conn; } 
public boolean disconnect ( Parameter outputParameter , Parameter inputParameter ) { return disconnect ( outputParameter , inputParameter , Connection . Type . EXPLICIT ) ; } 
public boolean disconnect ( Parameter outputParameter , Parameter inputParameter , Connection . Type type ) { assert inputParameter . getNode ( ) . getNetwork ( ) = = this ; assert outputParameter . getNode ( ) . getNetwork ( ) = = this ; assert inputParameter . isConnectable ( ) ; assert outputParameter . isConnectable ( ) ; assert outputParameter . isOutputParameter ( ) ; Find the connection Connection conn = getConnection(outputParameter, inputParameter, type); if (conn == null) return false; removeUpstreamConnection(inputParameter, conn); removeDownstreamConnection(outputParameter, conn); inputParameter.revertToDefault(); inputParameter.getNode().markDirty(); fireConnectionRemoved(conn); return true; } 
public boolean disconnect ( Parameter inputParameter ) { Create a copy so the event firing can change the original list around. List<Connection> connections = upstreams.get(inputParameter); if (connections == null) return false; connections = new ArrayList<Connection>(connections); boolean removedSomething = false; for (Connection conn : connections) { boolean disconnected = disconnect(conn.getOutputParameter(), conn.getInputParameter(), conn.getType()); assert (disconnected); fireConnectionRemoved(conn); } inputParameter.revertToDefault(); inputParameter.getNode().markDirty(); return true; } 
public boolean isConnected ( Parameter parameter ) { if ( parameter . isOutputParameter ( ) ) { return downstreams . containsKey ( parameter ) ; 
public boolean isConnectedTo ( Parameter outputParameter , Parameter inputParameter ) { for ( Connection conn : upstreams . get ( inputParameter ) ) { if ( conn . getOutputParameter ( ) = = outputParameter ) return true ; } return false ; } 
private void addUpstreamConnection ( Parameter inputParameter , Connection connection ) { List < Connection > connections = upstreams . get ( inputParameter ) ; if ( connections = = null ) { connections = new ArrayList < Connection > ( ) ; upstreams . put ( inputParameter , connections ) ; } connections . add ( connection ) ; } 
private void addDownstreamConnection ( Parameter outputParameter , Connection connection ) { List < Connection > connections = downstreams . get ( outputParameter ) ; if ( connections = = null ) { connections = new ArrayList < Connection > ( ) ; downstreams . put ( outputParameter , connections ) ; } connections . add ( connection ) ; } 
private void removeUpstreamConnection ( Parameter inputParameter , Connection connection ) { List < Connection > connections = upstreams . get ( inputParameter ) ; boolean removed = connections . remove ( connection ) ; assert ( removed ) ; if ( connections . isEmpty ( ) ) { upstreams . remove ( inputParameter ) ; 
private void removeDownstreamConnection ( Parameter outputParameter , Connection connection ) { List < Connection > connections = downstreams . get ( outputParameter ) ; boolean removed = connections . remove ( connection ) ; assert ( removed ) ; if ( connections . isEmpty ( ) ) { downstreams . remove ( outputParameter ) ; 
public void silentSet ( String name , int value ) { try { getParameter ( name ) . set ( value ) ; 
public void silentSet ( String name , double value ) { try { getParameter ( name ) . set ( value ) ; 
public void silentSet ( String name , String value ) { try { getParameter ( name ) . set ( value ) ; 
public void silentSet ( String name , Color value ) { try { getParameter ( name ) . set ( value ) ; 
public void silentSet ( String name , Object value ) { getParameter ( name ) . setValue ( value ) ; } 
private boolean hasExplicitConnection ( ) { return getExplicitConnection ( ) ! = null ; } 
public boolean isConnectedTo ( Parameter parameter ) { if ( ! isConnected ( ) ) return false ; Since output and input parameters can be intermingled, check both sides of the connection. return getNetwork().isConnectedTo(parameter, this) || getNetwork().isConnectedTo(this, parameter); } 
public boolean isConnectedTo ( Node node ) { if ( ! isConnected ( ) ) return false ; return getNetwork ( ) . isConnectedTo ( node . getOutputParameter ( ) , this ) ; } 
public boolean canConnectTo ( Parameter parameter ) { Parameters can only be connected to output parameters. TODO: No longer true for implicit connections if (!(parameter instanceof OutputParameter)) return false; return parameter.getCoreType() == getCoreType(); } 
public Connection connect ( Node outputNode ) { return getNetwork ( ) . connect ( outputNode . getOutputParameter ( ) , this ) ; } 
public String toString ( ) { return " <Parameter " + getNode ( ) . getName ( ) + " . " + getName ( ) + " ( " + getType ( ) . toString ( ) . toLowerCase ( ) + " )> " ; } 
public void testNodeLocal ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node multiply = net . create ( multiplyType ) ; Parameter p1 = multiply . getParameter ( " v1 " ) ; Parameter p2 = multiply . getParameter ( " v2 " ) ; p2 . setValue ( 12 ) ; assertExpressionEquals ( 12 , p1 , " v2 " ) ; } 
public void testNetworkLocal ( ) { NodeType netType = testNetworkType . clone ( ) ; ParameterType pn = netType . addParameterType ( " pn " , ParameterType . Type . INT ) ; pn . setDefaultValue ( 33 ) ; Network net = ( Network ) netType . createNode ( ) ; Node number1 = net . create ( numberType ) ; Parameter pValue1 = number1 . getParameter ( " value " ) ; pValue1 . set ( 84 ) ; assertEquals ( " number1 " , number1 . getName ( ) ) ; Parameter p1 = test1.addParameter("p1", Parameter.Type.INT); Node number2 = net.create(numberType); assertEquals("number2", number2.getName()); Parameter p2 = number2.addParameter("p2", Parameter.Type.INT); Parameter pValue2 = number2.getParameter("value"); pValue2.set(12); Trying to get the value of number2 by just using the expression "value" is impossible, since it will retrieve the value parameter of number1. assertExpressionInvalid(pValue1, "value"); Access p2 through the node name. assertExpressionEquals(12, pValue1, "number2.value"); Access p2 through the network. assertExpressionEquals(12, pValue1, "network.number2.value"); Access the pn Parameter on the network. assertExpressionEquals(33, pValue1, "network.pn"); } 
public void assertExpressionInvalid ( Parameter p , String expression ) { try { p . setExpression ( expression ) ; 
public void testExpressionConnections ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect1 = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; Node ellipse1 = net . create ( manager . getNodeType ( " corevector.ellipse " ) ) ; Node copy1 = net . create ( manager . getNodeType ( " corevector.copy " ) ) ; copy1 . getParameter ( " shape " ) . connect ( rect1 ) ; copy1 . getParameter ( " tx " ) . setExpression ( " ellipse1.x " ) ; Parameter xParam = ellipse1 . getParameter ( " x " ) ; assertEquals ( 1 , xParam . getDependents ( ) . size ( ) ) ; assert ( xParam . getDependents ( ) . contains ( copy1 . getParameter ( " tx " ) ) ) ; assertEquals ( 2 , copy1 . getConnections ( ) . size ( ) ) ; assertEquals ( 1 , rect1 . getConnections ( ) . size ( ) ) ; assertEquals ( 1 , ellipse1 . getConnections ( ) . size ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( this ) ; final JDialog d = new JDialog ( frame , " Choose Color " , true ) ; d . getContentPane ( ) . setLayout ( new BorderLayout ( 10 , 10 ) ) ; final ColorSwatch colorSwatch = new ColorSwatch ( parameter . asColor ( ) ) ; final JColorChooser colorChooser = new JColorChooser ( parameter . asColor ( ) . getAwtColor ( ) ) ; colorChooser.setPreviewPanel(colorSwatch); colorChooser.setPreviewPanel(new JPanel()); JPanel alphaPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 10, 0)); JLabel alphaLabel = new JLabel("Alpha:"); final JSlider alphaSlider = new JSlider(JSlider.HORIZONTAL, 0, 100, (int) (parameter.asColor().getAlpha() * 100)); alphaPanel.add(alphaLabel); alphaPanel.add(alphaSlider); JPanel colorPanel = new JPanel(new BorderLayout(10, 10)); colorPanel.add(colorSwatch, BorderLayout.NORTH); colorPanel.add(colorChooser, BorderLayout.CENTER); colorPanel.add(alphaPanel, BorderLayout.SOUTH); d.getContentPane().add(colorPanel, BorderLayout.CENTER); JButton btn = new JButton("OK"); btn.addActionListener(new AbstractAction() { public void actionPerformed(ActionEvent e) { d.setVisible(false); } }); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.TRAILING, 0, 0)); buttonPanel.add(btn); d.getContentPane().add(buttonPanel, BorderLayout.SOUTH); ChangeListener changeListener = new ChangeListener() { public void stateChanged(ChangeEvent e) { Color awtColor = colorChooser.getColor(); colorSwatch.setColor(new net.nodebox.graphics.Color( awtColor.getRed(), awtColor.getGreen(), awtColor.getBlue(), alphaSlider.getValue() / 100.0)); colorSwatch.repaint(); } }; colorChooser.getSelectionModel().addChangeListener(changeListener); alphaSlider.getModel().addChangeListener(changeListener); d.pack(); d.setSize(400, 400); SwingUtils.centerOnScreen(d); This goes into modal loop. d.setVisible(true); Color awtColor = colorChooser.getColor(); net.nodebox.graphics.Color c = new net.nodebox.graphics.Color( awtColor.getRed(), awtColor.getGreen(), awtColor.getBlue(), alphaSlider.getValue() / 100.0); parameter.setValue(c); } 
public void actionPerformed ( ActionEvent e ) { d . setVisible ( false ) ; } 
public void stateChanged ( ChangeEvent e ) { Color awtColor = colorChooser . getColor ( ) ; colorSwatch . setColor ( new net . nodebox . graphics . Color ( awtColor . getRed ( ) , awtColor . getGreen ( ) , awtColor . getBlue ( ) , alphaSlider . getValue ( ) / 100.0 ) ) ; colorSwatch . repaint ( ) ; } 
protected void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; g . setColor ( color . getAwtColor ( ) ) ; g . fillRect ( r . x , r . y , r . width , r . height ) ; } 
protected void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; g . setColor ( parameter . asColor ( ) . getAwtColor ( ) ) ; g . fillRect ( r . x , r . y , r . width , r . height ) ; } 
public void activeNetworkChanged ( Network activeNetwork ) { if ( network ! = null ) { network . removeNetworkDataListener ( this ) ; } network = activeNetwork ; if ( network ! = null ) network . addNetworkDataListener ( this ) ; 
public Pane clone ( ) { return new LoggingPane ( getDocument ( ) ) ; } 
public void networkUpdated ( Network network ) { Implemented so we catch nodes with errors. repaint(); } 
public boolean update ( ProcessingContext ctx ) { if ( ! dirty ) return true ; for ( Parameter p : parameters . values ( ) ) { try { p . update ( ctx ) ; } catch ( Exception e ) { messages . add ( new Message ( MessageLevel . ERROR , p . getName ( ) + " : " + e . getMessage ( ) ) ) ; dirty = false ; return false ; } } messages . clear ( ) ; boolean success = process ( ctx ) ; dirty = false ; return success ; } 
public void update ( ProcessingContext ctx ) { Check if the output node on the connection is not the same as my node. In that case, we don't want to process the node, since it will eventually end up updating this parameter, causing infinite recursion. if (getOutputNode() == getInputNode()) return; getOutputNode().update(ctx); outputValue = getOutputNode().getOutputValue(); } 
public void toXml ( StringBuffer xml , String spaces ) { toXml ( xml , spaces , outputParameter ) ; } 
protected void toXml ( StringBuffer xml , String spaces , Parameter outputParameter ) { xml . append ( spaces ) ; xml . append ( " <connection " ) ; xml . append ( " outputNode= \" " ) . append ( outputParameter . getNode ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " inputNode= \" " ) . append ( getInputNode ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " inputParameter= \" " ) . append ( getInputParameter ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " /> " ) ; } 
public void addOutputParameter ( Parameter outputParameter ) { outputParameters . add ( outputParameter ) ; } 
public void update ( ProcessingContext ctx ) { List < Object > values = new ArrayList < Object > ( ) ; for ( Parameter outputParameter : outputParameters ) { Check if the output node on the connection is not the same as my node. In that case, we don't want to process the node, since it will eventually end up updating this parameter, causing infinite recursion. if (outputParameter.getNode() == getInputNode()) continue; outputParameter.getNode().update(ctx); values.add(outputParameter.getNode().getOutputValue()); } outputValue = values; } 
public void toXml ( StringBuffer xml , String spaces ) { for ( Parameter outputParameter : outputParameters ) { toXml ( xml , spaces , outputParameter ) ; 
public Grob asGrob ( ) { assertCardinality ( ) ; if ( getCoreType ( ) = = ParameterType . CoreType . GROB_SHAPE | | getCoreType ( ) = = ParameterType . CoreType . GROB_CANVAS 
private void assertCardinality ( ) { if ( getCardinality ( ) = = ParameterType . Cardinality . MULTIPLE ) throw new AssertionError ( " You cannot retrieve multi-parameters this way. Use getValues(). " ) ; 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.ellipse")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); } public void testCycles() { Network net = (Network) testNetworkType.createNode(); Node n1 = net.create(numberType); Node n2 = net.create(numberType); n2.getParameter("value").connect(n1); CycleDetector cd = CycleDetector.initWithNetwork(net); assertFalse(cd.hasCycles()); n1.getParameter("value").connect(n2); cd = CycleDetector.initWithNetwork(net); assertTrue(cd.hasCycles()); }} 
public void testPersistence ( ) { Create network Network rootNetwork = (Network) manager.getNodeType("corecanvas.canvasnet").createNode(); Network vecnet1 = (Network) rootNetwork.create(manager.getNodeType("corevector.vecnet")); vecnet1.setPosition(10, 10); assertEquals("vecnet1", vecnet1.getName()); vecnet1.setRendered(); Node ellipse1 = vecnet1.create(manager.getNodeType("corevector.ellipse")); assertEquals("ellipse1", ellipse1.getName()); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node transform1 = vecnet1.create(manager.getNodeType("corevector.transform")); assertEquals("transform1", transform1.getName()); transform1.setPosition(40, 80); transform1.setRendered(); transform1.getParameter("shape").connect(ellipse1); TODO: Add a multi-connection node here somewhere. Write network String xmlString = rootNetwork.toXml(); Read network Network newNetwork = Network.load(manager, xmlString); Perform tests on the network assertEquals(rootNetwork.getName(), newNetwork.getName()); assertTrue(newNetwork.contains("vecnet1")); Network nVector1 = (Network) newNetwork.getNode("vecnet1"); assertTrue(nVector1.contains("ellipse1")); assertTrue(nVector1.contains("transform1")); Node nEllipse1 = nVector1.getNode("ellipse1"); Node nTransform1 = nVector1.getNode("transform1"); assertEquals(ellipse1.getValue("x"), nEllipse1.getValue("x")); assertEquals(ellipse1.getValue("fill"), nEllipse1.getValue("fill")); assertEquals(ellipse1.getValue("stroke"), nEllipse1.getValue("stroke")); assertTrue(nEllipse1.isConnected()); assertTrue(nTransform1.isConnected()); assertTrue(nTransform1.getParameter("shape").isConnectedTo(nEllipse1)); } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; manager = new NodeTypeLibraryManager ( ) ; TestLibrary testlib = new TestLibrary ( ) ; manager . addLibrary ( testlib ) ; numberType = manager . getNodeType ( " test.number " ) ; negateType = manager . getNodeType ( " test.negate " ) ; addType = manager . getNodeType ( " test.add " ) ; multiplyType = manager . getNodeType ( " test.multiply " ) ; multiAddType = manager . getNodeType ( " test.multiAdd " ) ; testNetworkType = manager . getNodeType ( " test.testnet " ) ; } 
public void testMultiParameters ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node number1 = net . create ( numberType ) ; number1 . set ( " value " , 1 ) ; Node number2 = net . create ( numberType ) ; number2 . set ( " value " , 2 ) ; Node number3 = net . create ( numberType ) ; number3 . set ( " value " , 3 ) ; Node multiAdd1 = net . create ( multiAddType ) ; Connection c1 = multiAdd1 . getParameter ( " values " ) . connect ( number1 ) ; Connection c2 = multiAdd1 . getParameter ( " values " ) . connect ( number2 ) ; Connection c3 = multiAdd1 . getParameter ( " values " ) . connect ( number3 ) ; assertTrue ( c1 = = c2 ) ; assertTrue ( c1 = = c3 ) ; assertTrue ( c1 instanceof MultiConnection ) ; assertEquals ( 3 , ( ( MultiConnection ) c1 ) . getOutputParameters ( ) . size ( ) ) ; multiAdd1 . update ( ) ; assertEquals ( 6 , multiAdd1 . getOutputValue ( ) ) ; } 
public abstract int process ( int value ) ; } public static abstract class Binary extends NodeType { public Binary ( NodeTypeLibrary library , String name ) { super ( library , name , ParameterType . Type . INT ) ; addParameterType ( " v1 " , ParameterType . Type . INT ) ; addParameterType ( " v2 " , ParameterType . Type . INT ) ; } public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( process ( node . asInt ( " v1 " ) , node . asInt ( " v2 " ) ) ) ; return true ; } public abstract int process ( int v1 , int v2 ) ; } public static abstract class Multi extends NodeType { public Multi ( NodeTypeLibrary library , String name ) { super ( library , name , ParameterType . Type . INT ) ; ParameterType ptValues = addParameterType ( " values " , ParameterType . Type . INT ) ; ptValues . setCardinality ( ParameterType . Cardinality . MULTIPLE ) ; } public boolean process ( Node node , ProcessingContext ctx ) { List < Object > objectValues = node . getValues ( " values " ) ; int [ ] values = new int [ objectValues . size ( ) ] ; for ( int i = 0 ; i < objectValues . size ( ) ; i + + ) { values [ i ] = ( Integer ) objectValues . get ( i ) ; } node . setOutputValue ( process ( values ) ) ; return true ; } public abstract int process ( int [ ] values ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class MultiAdd extends Multi { public MultiAdd ( NodeTypeLibrary library ) { super ( library , " multiAdd " ) ; } public int process ( int [ ] values ) { int sum = 0 ; for ( int v : values ) sum + = v ; return sum ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , new Version ( 1 , 0 , 0 ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new MultiAdd ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public abstract int process ( int v1 , int v2 ) ; } public static abstract class Multi extends NodeType { public Multi ( NodeTypeLibrary library , String name ) { super ( library , name , ParameterType . Type . INT ) ; ParameterType ptValues = addParameterType ( " values " , ParameterType . Type . INT ) ; ptValues . setCardinality ( ParameterType . Cardinality . MULTIPLE ) ; } public boolean process ( Node node , ProcessingContext ctx ) { List < Object > objectValues = node . getValues ( " values " ) ; int [ ] values = new int [ objectValues . size ( ) ] ; for ( int i = 0 ; i < objectValues . size ( ) ; i + + ) { values [ i ] = ( Integer ) objectValues . get ( i ) ; } node . setOutputValue ( process ( values ) ) ; return true ; } public abstract int process ( int [ ] values ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class MultiAdd extends Multi { public MultiAdd ( NodeTypeLibrary library ) { super ( library , " multiAdd " ) ; } public int process ( int [ ] values ) { int sum = 0 ; for ( int v : values ) sum + = v ; return sum ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , new Version ( 1 , 0 , 0 ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new MultiAdd ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public boolean process ( Node node , ProcessingContext ctx ) { List < Object > objectValues = node . getValues ( " values " ) ; int [ ] values = new int [ objectValues . size ( ) ] ; for ( int i = 0 ; i < objectValues . size ( ) ; i + + ) { values [ i ] = ( Integer ) objectValues . get ( i ) ; } node . setOutputValue ( process ( values ) ) ; return true ; } 
public abstract int process ( int [ ] values ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class MultiAdd extends Multi { public MultiAdd ( NodeTypeLibrary library ) { super ( library , " multiAdd " ) ; } public int process ( int [ ] values ) { int sum = 0 ; for ( int v : values ) sum + = v ; return sum ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , new Version ( 1 , 0 , 0 ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new MultiAdd ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public int process ( int [ ] values ) { int sum = 0 ; for ( int v : values ) sum + = v ; return sum ; } 
public boolean hasOutputParameter ( Parameter parameter ) { return outputParameter = = parameter ; } 
public boolean hasOutputParameter ( Parameter parameter ) { for ( Parameter outputParameter : outputParameters ) { if ( outputParameter = = parameter ) return true ; } return false ; } 
public boolean disconnect ( Parameter inputParameter ) { List < Connection > connections = upstreams . get ( inputParameter ) ; if ( connections = = null ) return false ; Create a copy so the event firing can change the original list around. connections = new ArrayList<Connection>(connections); boolean removedSomething = false; for (Connection conn : connections) { Only remove explicit connections if (conn.getType() != Connection.Type.EXPLICIT) continue; Create a copy of the output parameters since they will be changed. List<Parameter> outputParameters = new ArrayList<Parameter>(conn.getOutputParameters()); for (Parameter outputParameter : outputParameters) { boolean disconnected = disconnect(outputParameter, conn.getInputParameter(), conn.getType()); assert (disconnected); fireConnectionRemoved(conn); } } inputParameter.revertToDefault(); inputParameter.getNode().markDirty(); return true; } 
public boolean isConnectedTo ( Parameter outputParameter , Parameter inputParameter ) { for ( Connection conn : upstreams . get ( inputParameter ) ) { if ( conn . hasOutputParameter ( outputParameter ) ) return true ; } return false ; } 
public boolean disconnect ( ) { boolean removedSomething = false ; Disconnect all my inputs. for (Parameter p : parameters.values()) { removedSomething = network.disconnect(p) | removedSomething; } Disconnect all my outputs. Copy the list of downstreams, since you will be removing elements from it while iterating. List<Connection> downstreamConnections = new ArrayList<Connection>(getOutputParameter().getDownstreamConnections()); for (Connection c : downstreamConnections) { removedSomething = network.disconnect(getOutputParameter(), c.getInputParameter(), Connection.Type.EXPLICIT) | removedSomething; } return removedSomething; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new MergeType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new VectorNetworkType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; coreimage . addNodeType ( new ImageType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; List < Object > shapes = node . getValues ( " shapes " ) ; for ( Object shapeObject : shapes ) { Grob shape = ( Grob ) shapeObject ; outputGroup . add ( shape . clone ( ) ) ; } node . setOutputValue ( outputGroup ) ; return true ; } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.ellipse")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); } public void testCycles() { Network net = (Network) testNetworkType.createNode(); Node n1 = net.create(numberType); Node n2 = net.create(numberType); n2.getParameter("value").connect(n1); CycleDetector cd = CycleDetector.initWithNetwork(net); assertFalse(cd.hasCycles()); n1.getParameter("value").connect(n2); cd = CycleDetector.initWithNetwork(net); assertTrue(cd.hasCycles()); }} 
public void testPersistence ( ) { Create network Network rootNetwork = (Network) manager.getNodeType("corecanvas.canvasnet").createNode(); Network vecnet1 = (Network) rootNetwork.create(manager.getNodeType("corevector.vecnet")); vecnet1.setPosition(10, 10); assertEquals("vecnet1", vecnet1.getName()); vecnet1.setRendered(); Node ellipse1 = vecnet1.create(manager.getNodeType("corevector.ellipse")); assertEquals("ellipse1", ellipse1.getName()); ellipse1.setRendered(); ellipse1.setPosition(100, 30); Node transform1 = vecnet1.create(manager.getNodeType("corevector.transform")); assertEquals("transform1", transform1.getName()); transform1.setPosition(40, 80); transform1.setRendered(); transform1.getParameter("shape").connect(ellipse1); Node rect1 = vecnet1.create(manager.getNodeType("corevector.rect")); assertEquals("ellipse1", ellipse1.getName()); rect1.setPosition(180, 30); Node merge1 = vecnet1.create(manager.getNodeType("corevector.merge")); assertEquals("merge1", merge1.getName()); merge1.getParameter("shapes").connect(transform1); merge1.getParameter("shapes").connect(rect1); Write network String xmlString = rootNetwork.toXml(); Read network Network newNetwork = Network.load(manager, xmlString); Perform tests on the network assertEquals(rootNetwork.getName(), newNetwork.getName()); assertTrue(newNetwork.contains("vecnet1")); Network nVector1 = (Network) newNetwork.getNode("vecnet1"); assertTrue(nVector1.contains("ellipse1")); assertTrue(nVector1.contains("transform1")); Node nEllipse1 = nVector1.getNode("ellipse1"); Node nTransform1 = nVector1.getNode("transform1"); Node nRect1 = nVector1.getNode("rect1"); Node nMerge1 = nVector1.getNode("merge1"); assertEquals(ellipse1.getValue("x"), nEllipse1.getValue("x")); assertEquals(ellipse1.getValue("fill"), nEllipse1.getValue("fill")); assertEquals(ellipse1.getValue("stroke"), nEllipse1.getValue("stroke")); assertTrue(nEllipse1.isConnected()); assertTrue(nTransform1.isConnected()); assertTrue(nTransform1.getParameter("shape").isConnectedTo(nEllipse1)); assertTrue(nMerge1.getParameter("shapes").isConnectedTo(nRect1)); assertTrue(nMerge1.getParameter("shapes").isConnectedTo(nTransform1)); Check if this is the same connection Parameter nShapes = nMerge1.getParameter("shapes"); Connection c1 = nVector1.getConnection(nTransform1, nShapes); Connection c2 = nVector1.getConnection(nRect1, nShapes); assertTrue(c1 == c2); assertTrue(c1 instanceof MultiConnection); This tests for a bug where the connection would be created twice. nMerge1.getParameter("shapes").disconnect(); assertFalse(nShapes.isConnectedTo(nRect1)); assertFalse(nShapes.isConnectedTo(nTransform1)); } 
public void testMultiParameters ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node number1 = net . create ( numberType ) ; number1 . set ( " value " , 1 ) ; Node number2 = net . create ( numberType ) ; number2 . set ( " value " , 2 ) ; Node number3 = net . create ( numberType ) ; number3 . set ( " value " , 3 ) ; Node multiAdd = net . create ( multiAddType ) ; Connection c1 = multiAdd . getParameter ( " values " ) . connect ( number1 ) ; Connection c2 = multiAdd . getParameter ( " values " ) . connect ( number2 ) ; Connection c3 = multiAdd . getParameter ( " values " ) . connect ( number3 ) ; assertTrue ( c1 = = c2 ) ; assertTrue ( c1 = = c3 ) ; assertTrue ( c1 instanceof MultiConnection ) ; assertEquals ( 3 , c1 . getOutputParameters ( ) . size ( ) ) ; multiAdd . update ( ) ; assertEquals ( 1 + 2 + 3 , multiAdd . getOutputValue ( ) ) ; Check dirty propagation assertFalse(multiAdd.isDirty()); number2.set("value", 200); assertTrue(multiAdd.isDirty()); multiAdd.update(); assertEquals(1 + 200 + 3, multiAdd.getOutputValue()); Check disconnect number2.disconnect(); assertFalse(number2.isConnected()); assertTrue(number1.isConnected()); assertTrue(number3.isConnected()); assertTrue(multiAdd.isConnected()); multiAdd.update(); assertEquals(1 + 3, multiAdd.getOutputValue()); multiAdd.disconnect(); assertFalse(number2.isConnected()); assertFalse(number1.isConnected()); assertFalse(number3.isConnected()); assertFalse(multiAdd.isConnected()); } 
public void testBasicMerge ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect1 = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; rect1 . set ( " x " , 25.0 ) ; Node ellipse1 = net . create ( manager . getNodeType ( " corevector.ellipse " ) ) ; ellipse1 . set ( " x " , 199.0 ) ; Node merge = net . create ( manager . getNodeType ( " corevector.merge " ) ) ; merge . getParameter ( " shapes " ) . connect ( rect1 ) ; merge . getParameter ( " shapes " ) . connect ( ellipse1 ) ; merge . update ( ) ; Group g = ( Group ) merge . getOutputValue ( ) ; assertEquals ( 2 , g . getGrobs ( ) . size ( ) ) ; Group rectGroup = ( Group ) g . get ( 0 ) ; assertEquals ( 1 , rectGroup . size ( ) ) ; BezierPath rectPath = ( BezierPath ) rectGroup . get ( 0 ) ; Compare the X value set on the rect1 node so we know it is the output of the rect1 node. assertEquals(25.0, rectPath.getBounds().getX()); Group ellipseGroup = (Group) g.get(1); assertEquals(1, ellipseGroup.size()); BezierPath ellipsePath = (BezierPath) ellipseGroup.get(0); Compare the X value set on the ellipse1 node assertEquals(199.0, ellipsePath.getBounds().getX()); 
public void actionPerformed ( ActionEvent e ) { parameter . disconnect ( ) ; } 
public void actionPerformed ( ActionEvent e ) { removeSelected ( ) ; } 
public static void main ( String [ ] args ) { Network net = Network . load ( new NodeTypeLibraryManager ( ) , new File ( " /Users/fdb/Desktop/mergetest2.ndbx " ) ) ; Parameter p = net . getNode ( " merge1 " ) . getParameter ( " shapes " ) ; JDialog d = new JDialog ( ) ; d . setModal ( true ) ; d . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; MultiConnectionPanel panel = new MultiConnectionPanel ( p ) ; d . getContentPane ( ) . add ( panel , BorderLayout . CENTER ) ; d . setSize ( 400 , 400 ) ; d . setVisible ( true ) ; } 
private void moveDown ( ) { Connection c = getConnection ( ) ; if ( c = = null ) return ; Parameter selectedParameter = ( Parameter ) outputParameterList . getSelectedValue ( ) ; if ( selectedParameter = = null ) return ; java . util . List < Parameter > parameters = c . getOutputParameters ( ) ; int index = parameters . indexOf ( selectedParameter ) ; assert ( index > = 0 ) ; if ( index > = parameters . size ( ) - 1 ) return ; parameters . remove ( selectedParameter ) ; parameters . add ( index + 1 , selectedParameter ) ; reloadList ( ) ; outputParameterList . setSelectedIndex ( index + 1 ) ; parameter . getNode ( ) . markDirty ( ) ; } 
private void moveUp ( ) { Connection c = getConnection ( ) ; if ( c = = null ) return ; Parameter selectedParameter = ( Parameter ) outputParameterList . getSelectedValue ( ) ; if ( selectedParameter = = null ) return ; java . util . List < Parameter > parameters = c . getOutputParameters ( ) ; int index = parameters . indexOf ( selectedParameter ) ; assert ( index > = 0 ) ; if ( index = = 0 ) return ; parameters . remove ( selectedParameter ) ; parameters . add ( index - 1 , selectedParameter ) ; reloadList ( ) ; outputParameterList . setSelectedIndex ( index - 1 ) ; parameter . getNode ( ) . markDirty ( ) ; } 
private void removeSelected ( ) { Parameter outputParameter = ( Parameter ) outputParameterList . getSelectedValue ( ) ; if ( outputParameter = = null ) return ; Network network = parameter . getNetwork ( ) ; network . disconnect ( outputParameter , parameter ) ; reloadList ( ) ; parameter . getNode ( ) . markDirty ( ) ; } 
private void reloadList ( ) { outputParameterList . setModel ( parameterListModel ) ; outputParameterList . repaint ( ) ; } 
public void componentResized ( ComponentEvent e ) { Dimension controlSize = control . getPreferredSize ( ) ; Rectangle bounds = getBounds ( ) ; int h = bounds . height - TOP_PADDING - BOTTOM_PADDING ; label . setBounds ( 0 , TOP_PADDING , 100 , h ) ; control . setBounds ( 110 , TOP_PADDING , controlSize . width , h ) ; control . doLayout ( ) ; expressionField . setBounds ( 110 , TOP_PADDING , 200 , h ) ; popupButton . setBounds ( bounds . width - 30 , TOP_PADDING , 30 , h ) ; repaint ( ) ; } 
public Object evaluate ( ) { return evaluate ( new ProcessingContext ( ) ) ; } 
public Object evaluate ( ProcessingContext context ) { ProxyResolverFactory prf = new ProxyResolverFactory ( parameter . getNode ( ) , context , mutable ) ; try { return MVEL . executeExpression ( compiledExpression , prf ) ; 
public Node copyNodeWithUpstream ( Node node ) { Create a new network into which we can put this clone. Constructor networkConstructor; try { networkConstructor = getClass().getConstructor(NodeType.class); } catch (Exception e) { logger.log(Level.SEVERE, "Class " + getNetwork().getClass() + " has no appropriate constructor.", e); return null; } Network newNetwork; try { newNetwork = (Network) networkConstructor.newInstance(getNodeType()); } catch (Exception e) { logger.log(Level.SEVERE, "Class " + getClass() + " cannot be instantiated.", e); return null; } return node.copyWithUpstream(newNetwork); } 
public Node copyWithUpstream ( Network newNetwork ) { Constructor nodeConstructor ; try { nodeConstructor = getClass ( ) . getConstructor ( NodeType . class ) ; } catch ( NoSuchMethodException e ) { logger . log ( Level . SEVERE , " Class " + getClass ( ) + " has no appropriate constructor. " , e ) ; return null ; } Node newNode ; try { newNode = ( Node ) nodeConstructor . newInstance ( nodeType ) ; } catch ( Exception e ) { logger . log ( Level . SEVERE , " Class " + getClass ( ) + " cannot be instantiated. " , e ) ; return null ; } newNode . setName ( getName ( ) ) ; newNode . setNetwork ( newNetwork ) ; for ( Parameter p : parameters . values ( ) ) { newNode . parameters . remove ( p ) ; newNode . parameters . put ( p . getName ( ) , p . copyWithUpstream ( newNode ) ) ; } return newNode ; } 
public Object put ( Object key , Object value ) { if ( ! mutable ) throw new AssertionError ( " You cannot change the node access proxy. " ) ; String k = key . toString ( ) ; Only search the parameters if (node.hasParameter(k)) { if (markedParameters != null) markedParameters.add(node.getParameter(k)); Object oldValue = node.getValue(k); node.setValue(k, value); return oldValue; } throw new RuntimeException("Parameter " + k + " not found on node " + node.getName()); } 
public Parameter copyWithUpstream ( Node newNode ) { Constructor parameterConstructor ; try { parameterConstructor = getClass ( ) . getConstructor ( ParameterType . class , Node . class ) ; } catch ( NoSuchMethodException e ) { logger . log ( Level . SEVERE , " Class " + getClass ( ) + " has no appropriate constructor. " , e ) ; return null ; } Parameter newParameter ; try { newParameter = ( Parameter ) parameterConstructor . newInstance ( parameterType , newNode ) ; } catch ( Exception e ) { logger . log ( Level . SEVERE , " Class " + getClass ( ) + " cannot be instantiated. " , e ) ; return null ; } Connection conn = getNetwork ( ) . getExplicitConnection ( this ) ; if ( conn ! = null ) { Node newOutputNode = conn . getOutputNode ( ) . copyWithUpstream ( newNode . getNetwork ( ) ) ; newParameter . connect ( newOutputNode ) ; } else if ( hasExpression ( ) ) { newParameter . setExpression ( getExpression ( ) ) ; } else { TODO: Clone the value properly. newParameter.value = value; } return newParameter; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . getParameter ( " template " ) . isConnected ( ) ? node . asGrob ( " template " ) : null ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) ; double sy = node . asFloat ( " sy " ) ; String expression = node . asString ( " expression " ) ; if ( expression = = null | | expression . trim ( ) . length ( ) = = 0 ) { if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } } else { Expression set. The expression allows you to modify field values on upstream nodes while copying. The expression has access to all the nodes by their name (e.g. rect1), and can set values on them. The CY local variable contains the copy number (starting from zero) Parameter pShape = node.getParameter("shape"); if (!pShape.isConnected()) throw new AssertionError("The shape is not connected."); Transform t = new Transform(); for (int i = 0; i < copies; i++) { Node upstreamNode = pShape.getExplicitConnection().getOutputNode(); Node copiedUpstreamNode = upstreamNode.getNetwork().copyNodeWithUpstream(upstreamNode); These expressions can mutate the values; that's sort of the point. Expression expressionObject = new Expression(copiedUpstreamNode.getOutputParameter(), expression, true); The expression object changes the node values, so I don't care about the output. ProcessingContext copyContext = (ProcessingContext) ctx.clone(); copyContext.put("COPY", i); expressionObject.evaluate(copyContext); Now evaluate the output of the new upstream node. copiedUpstreamNode.update(ctx); if (copiedUpstreamNode.hasError()) throw new ProcessingError(node, "Upstream node contained errors:" + copiedUpstreamNode.getMessages().toString()); We do not need to clone the output shape. Grob outputShape = (Grob) copiedUpstreamNode.getOutputValue(); outputShape.appendTransform(t); outputGroup.add(outputShape); t.translate(tx, ty); t.rotate(r); t.scale(sx, sy); } } node.setOutputValue(outputGroup); return true; } 
private void doCopy ( Group outputGroup , Grob shape , double startx , double starty , int copies , double tx , double ty , double r , double sx , double sy ) { Set up the transform Transform t = new Transform(); t.translate(startx, starty); Loop through the number of copies for (int i = 0; i < copies; i++) { Clone the input shape so we can change transformations on it. 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.ellipse")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); } public void xtestCycles() { Network net = (Network) testNetworkType.createNode(); Node n1 = net.create(numberType); Node n2 = net.create(numberType); n2.getParameter("value").connect(n1); CycleDetector cd = CycleDetector.initWithNetwork(net); assertFalse(cd.hasCycles()); n1.getParameter("value").connect(n2); cd = CycleDetector.initWithNetwork(net); assertTrue(cd.hasCycles()); }} 
public void xtestCycles ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node n1 = net . create ( numberType ) ; Node n2 = net . create ( numberType ) ; n2 . getParameter ( " value " ) . connect ( n1 ) ; CycleDetector cd = CycleDetector . initWithNetwork ( net ) ; assertFalse ( cd . hasCycles ( ) ) ; n1 . getParameter ( " value " ) . connect ( n2 ) ; cd = CycleDetector . initWithNetwork ( net ) ; assertTrue ( cd . hasCycles ( ) ) ; } 
public void testCopyWithUpstream ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node number1 = net . create ( numberType ) ; Node number2 = net . create ( numberType ) ; Node add1 = net . create ( addType ) ; assertEquals ( " number1 " , number1 . getName ( ) ) ; assertEquals ( " number2 " , number2 . getName ( ) ) ; assertEquals ( " add1 " , add1 . getName ( ) ) ; add1 . getParameter ( " v1 " ) . connect ( number1 ) ; add1 . getParameter ( " v2 " ) . connect ( number2 ) ; Node copiedAdd1 = add1 . getNetwork ( ) . copyNodeWithUpstream ( add1 ) ; assertEquals ( " add1 " , copiedAdd1 . getName ( ) ) ; Network copiedNetwork = copiedAdd1 . getNetwork ( ) ; assertEquals ( net . getName ( ) , copiedNetwork . getName ( ) ) ; Node copiedNumber1 = copiedAdd1 . getNetwork ( ) . getNode ( " number1 " ) ; Node copiedNumber2 = copiedAdd1 . getNetwork ( ) . getNode ( " number2 " ) ; assertNotNull ( copiedNumber1 ) ; assertNotNull ( copiedNumber2 ) ; assert ( copiedAdd1 . isConnected ( ) ) ; assert ( copiedAdd1 . getParameter ( " v1 " ) . isConnectedTo ( copiedNumber1 ) ) ; assert ( copiedAdd1 . getParameter ( " v2 " ) . isConnectedTo ( copiedNumber2 ) ) ; } 
public void testValidate ( ) { NodeType customType = numberType . clone ( ) ; ParameterType ptFloat = customType . addParameterType ( " float " , ParameterType . Type . FLOAT ) ; assertInvalidValue ( ptFloat , " A " ) ; assertInvalidValue ( ptFloat , new Color ( ) ) ; assertInvalidValue ( ptFloat , new Canvas ( ) ) ; assertValidValue ( ptFloat , 1.0 ) ; As a special exception, floating-point parameters can also accept integers assertValidValue(ptFloat, 1); ParameterType ptInt = customType.addParameterType("int", ParameterType.Type.INT); assertInvalidValue(ptFloat, "A"); assertInvalidValue(ptFloat, new Color()); assertInvalidValue(ptFloat, new Canvas()); assertValidValue(ptFloat, 1); You cannot assign floating-point values to integers, so the above exception to the rule only works in one way. assertValidValue(ptFloat, 1.0); ParameterType ptColor = customType.addParameterType("color", ParameterType.Type.COLOR); assertInvalidValue(ptColor, "A"); assertInvalidValue(ptColor, 2); assertValidValue(ptColor, new Color()); Toggle has a hard bounded range between 0 and 1. ParameterType ptToggle = customType.addParameterType("toggle", ParameterType.Type.TOGGLE); assertInvalidValue(ptToggle, "A"); assertInvalidValue(ptToggle, -1); assertInvalidValue(ptToggle, 100); assertValidValue(ptToggle, 0); assertValidValue(ptToggle, 1); } 
public void testCopyStamping ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; Node copy = net . create ( manager . getNodeType ( " corevector.copy " ) ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . set ( " copies " , 10 ) ; copy . set ( " expression " , " rect1.x = COPY " ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( 0 , 0 , 109 , 100 ) , g . getBounds ( ) ) ; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new GridType ( corevector ) ) ; corevector . addNodeType ( new MergeType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new VectorNetworkType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; coreimage . addNodeType ( new ImageType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . getParameter ( " template " ) . isConnected ( ) ? node . asGrob ( " template " ) : null ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) ; double sy = node . asFloat ( " sy " ) ; String expression = node . asString ( " expression " ) ; if ( expression = = null | | expression . trim ( ) . length ( ) = = 0 ) { if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } } else { Expression set. The expression allows you to modify field values on upstream nodes while copying. The expression has access to all the nodes by their name (e.g. rect1), and can set values on them. The CY local variable contains the copy number (starting from zero) Parameter pShape = node.getParameter("shape"); if (!pShape.isConnected()) throw new AssertionError("The shape is not connected."); List<Point> points; if (template == null) { points = new ArrayList<Point>(); points.add(new Point()); } else { points = pointsForGrob(template); } int copyIndex = 0; for (Point p : points) { Transform t = new Transform(); t.translate(p.getX(), p.getY()); for (int i = 0; i < copies; i++) { Node upstreamNode = pShape.getExplicitConnection().getOutputNode(); Node copiedUpstreamNode = upstreamNode.getNetwork().copyNodeWithUpstream(upstreamNode); These expressions can mutate the values; that's sort of the point. Expression expressionObject = new Expression(copiedUpstreamNode.getOutputParameter(), expression, true); The expression object changes the node values, so I don't care about the output. ProcessingContext copyContext = (ProcessingContext) ctx.clone(); copyContext.put("COPY", copyIndex); expressionObject.evaluate(copyContext); Now evaluate the output of the new upstream node. copiedUpstreamNode.update(ctx); if (copiedUpstreamNode.hasError()) throw new ProcessingError(node, "Upstream node contained errors:" + copiedUpstreamNode.getMessages().toString()); We do not need to clone the output shape. Grob outputShape = (Grob) copiedUpstreamNode.getOutputValue(); outputShape.appendTransform(t); outputGroup.add(outputShape); t.translate(tx, ty); t.rotate(r); t.scale(sx, sy); copyIndex++; } } } node.setOutputValue(outputGroup); return true; } 
public boolean process ( Node node , ProcessingContext ctx ) { int rows = node . asInt ( " rows " ) ; int columns = node . asInt ( " columns " ) ; double rowsize = node . asFloat ( " rowsize " ) ; double columnsize = node . asFloat ( " columnsize " ) ; double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; for ( int rowindex = 0 ; rowindex < rows ; rowindex + + ) { for ( int columnindex = 0 ; columnindex < columns ; columnindex + + ) { p . moveto ( x + columnindex * columnsize , y + rowindex * rowsize ) ; } } g . add ( p ) ; node . setOutputValue ( g ) ; return true ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . translate ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; context . getCanvas ( ) . draw ( g2 ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.resetContext(); context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("g", context); interpreter.set("BezierPath", net.nodebox.graphics.BezierPath.class); interpreter.set("Canvas", net.nodebox.graphics.Canvas.class); interpreter.set("Color", net.nodebox.graphics.Color.class); interpreter.set("GraphicsContext", net.nodebox.graphics.GraphicsContext.class); interpreter.set("Grob", net.nodebox.graphics.Grob.class); interpreter.set("Group", net.nodebox.graphics.Group.class); interpreter.set("Image", net.nodebox.graphics.Image.class); interpreter.set("NodeBoxError", net.nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", net.nodebox.graphics.PathElement.class); interpreter.set("Point", net.nodebox.graphics.Point.class); interpreter.set("Rect", net.nodebox.graphics.Rect.class); interpreter.set("Text", net.nodebox.graphics.Text.class); interpreter.set("Transform", net.nodebox.graphics.Transform.class); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . translate ( getWidth ( ) / 2.0 , getHeight ( ) / 2.0 ) ; if ( getNetwork ( ) = = null ) return ; Object outputValue = getNetwork ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { ( ( Grob ) outputValue ) . draw ( g2 ) ; } Draw handle if (handle != null) { Create a canvas with a transparent background net.nodebox.graphics.Canvas canvas = new net.nodebox.graphics.Canvas(); canvas.setBackground(new net.nodebox.graphics.Color(0, 0, 0, 0)); GraphicsContext ctx = new GraphicsContext(canvas); handle.draw(ctx); ctx.getCanvas().draw(g2); } Draw center g.setColor(new Color(240, 240, 240)); g.drawLine(-getWidth() / 2, 0, getWidth() / 2, 0); g.drawLine(0, -getHeight() / 2, 0, getHeight() / 2); } 
private net . nodebox . graphics . Point pointForEvent ( MouseEvent e ) { double cx = - getWidth ( ) / 2.0 + e . getX ( ) ; double cy = - getHeight ( ) / 2.0 + e . getY ( ) ; return new net . nodebox . graphics . Point ( cx , cy ) ; } 
public void mouseClicked ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseClicked ( pointForEvent ( e ) ) ; } 
public void mousePressed ( MouseEvent e ) { if ( handle = = null ) return ; handle . mousePressed ( pointForEvent ( e ) ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseReleased ( pointForEvent ( e ) ) ; } 
public void mouseEntered ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseEntered ( pointForEvent ( e ) ) ; } 
public void mouseExited ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseExited ( pointForEvent ( e ) ) ; } 
public void mouseDragged ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseDragged ( pointForEvent ( e ) ) ; } 
public void mouseMoved ( MouseEvent e ) { if ( handle = = null ) return ; handle . mouseMoved ( pointForEvent ( e ) ) ; } 
public void rect ( double cx , double cy , double width , double height ) { double halfWidth = width / 2 ; double halfHeight = height / 2 ; moveto ( cx - halfWidth , cy - halfHeight ) ; lineto ( cx + halfWidth , cy - halfHeight ) ; lineto ( cx + halfWidth , cy + halfHeight ) ; lineto ( cx - halfWidth , cy + halfHeight ) ; close ( ) ; } 
public void rect ( double cx , double cy , double width , double height , double r ) { roundedRect ( cx , cy , width , height , r ) ; } 
public void rect ( double cx , double cy , double width , double height , double rx , double ry ) { roundedRect ( cx , cy , width , height , rx , ry ) ; } 
public void roundedRect ( double cx , double cy , double width , double height , double r ) { roundedRect ( cx , cy , width , height , r , r ) ; } 
public void roundedRect ( double cx , double cy , double width , double height , double rx , double ry ) { double halfWidth = width / 2.0 ; double halfHeight = height / 2.0 ; double dx = rx ; double dy = ry ; rx/ry cannot be greater than half of the width of the rectangle (required by SVG spec) dx = Math.min(dx, width * 0.5); dy = Math.min(dy, height * 0.5); moveto(cx + dx - halfWidth, cy - halfHeight); if (dx < width * 0.5) lineto(cx + halfWidth - rx, cy - halfHeight); curveto(cx + halfWidth - dx * ONE_MINUS_QUARTER, cy - halfHeight, cx + halfWidth, cy - halfHeight + dy * ONE_MINUS_QUARTER, cx + halfWidth, cy - halfHeight + dy); if (dy < height * 0.5) lineto(cx + halfWidth, cy + halfHeight - dy); curveto(cx + halfWidth, cy + halfHeight - dy * ONE_MINUS_QUARTER, cx + halfWidth - dx * ONE_MINUS_QUARTER, cy + halfHeight, cx + halfWidth - dx, cy + halfHeight); if (dx < width * 0.5) lineto(cx + dx, cy + halfHeight); curveto(cx - halfWidth + dx * ONE_MINUS_QUARTER, cy + halfHeight, cx - halfWidth, cy + halfHeight - dy * ONE_MINUS_QUARTER, cx - halfWidth, cy + halfHeight - dy); if (dy < height * 0.5) lineto(cx - halfWidth, cy - halfHeight + dy); curveto(cx - halfWidth, cy - halfHeight + dy * ONE_MINUS_QUARTER, cx - halfWidth + dx * ONE_MINUS_QUARTER, cy - halfHeight, cx - halfWidth + dx, cy - halfHeight); close(); } 
public void ellipse ( double cx , double cy , double width , double height ) { Ellipse2D . Double e = new Ellipse2D . Double ( cx - width / 2 , cy - height / 2 , width , height ) ; extend ( e ) ; } 
public void draw ( Graphics2D g ) { double halfWidth = width / 2 ; double halfHeight = height / 2 ; double left = - halfWidth ; double right = halfWidth ; double top = - halfHeight ; double bottom = halfHeight ; g . setColor ( background . getAwtColor ( ) ) ; g . fillRect ( ( int ) left , ( int ) top , ( int ) width , ( int ) height ) ; Rectangle clip = g . getClipBounds ( ) ; int clipwidth = width > clip . width ? clip . width : ( int ) height ; int clipheight = height > clip . height ? clip . height : ( int ) width ; g . setClip ( clip . x , clip . y , clipwidth , clipheight ) ; super . draw ( g ) ; } 
public void prependTransform ( Transform transform ) { this . transform . prepend ( transform ) ; } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; You can only position an image using an affine transformation. We use the transformation to translate the image to the specified position, and scale it according to the given width and height. Transform imageTrans = new Transform(); Move to the image position. Convert x, y, which are centered coordinates, to "real" coordinates. double factor = getScaleFactor(); double finalWidth = image.getWidth() * factor; double finalHeight = image.getHeight() * factor; imageTrans.translate(x - finalWidth / 2, y - finalHeight / 2); Scaling only applies to image that have their desired width and/or height set. However, getScaleFactor return 1 if height/width are not set, in effect negating the effect of the scale. imageTrans.scale(getScaleFactor()); double a = MathUtils.clamp(alpha); Composite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) a); Composite oldComposite = g.getComposite(); g.setComposite(composite); g.drawRenderedImage(image, imageTrans.getAffineTransform()); g.setComposite(oldComposite); restoreTransform(g); } 
public static Rect centeredRect ( double cx , double cy , double width , double height ) { return new Rect ( cx - width / 2 , cy - height / 2 , width , height ) ; } 
public void mouseClicked ( Point pt ) { } public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
protected void drawDot ( GraphicsContext ctx , double x , double y ) { BezierPath p = new BezierPath ( ) ; p . setFillColor ( HANDLE_COLOR ) ; p . rect ( x , y , HANDLE_SIZE , HANDLE_SIZE ) ; ctx . draw ( p ) ; } 
protected void drawDot ( BezierPath p , double x , double y ) { p . rect ( x , y , HANDLE_SIZE , HANDLE_SIZE ) ; } 
protected Rect createHitRectangle ( double x , double y ) { int ix = ( int ) x ; int iy = ( int ) y ; return new Rect ( ix - HALF_HANDLE_SIZE , iy - HALF_HANDLE_SIZE , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void draw ( GraphicsContext ctx ) { double cx = node . asFloat ( xName ) ; double cy = node . asFloat ( yName ) ; double width = node . asFloat ( widthName ) ; double height = node . asFloat ( heightName ) ; double left = cx - width / 2 ; double right = cx + width / 2 ; double top = cy - height / 2 ; double bottom = cy + height / 2 ; BezierPath cornerPath = new BezierPath ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0.0 ) ; drawDot ( cornerPath , left , top ) ; drawDot ( cornerPath , right , top ) ; drawDot ( cornerPath , right , bottom ) ; drawDot ( cornerPath , left , bottom ) ; drawDot ( cornerPath , cx , cy ) ; ctx . getCanvas ( ) . add ( cornerPath ) ; BezierPath strokePath = new BezierPath ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . rect ( cx , cy , width , height ) ; ctx . draw ( strokePath ) ; } 
public void mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; ocx = node . asFloat ( xName ) ; ocy = node . asFloat ( yName ) ; owidth = node . asFloat ( widthName ) ; oheight = node . asFloat ( heightName ) ; double left = ocx - owidth / 2 ; double right = ocx + owidth / 2 ; double top = ocy - oheight / 2 ; double bottom = ocy + oheight / 2 ; Rect topLeft = createHitRectangle ( left , top ) ; Rect topRight = createHitRectangle ( right , top ) ; Rect bottomLeft = createHitRectangle ( left , bottom ) ; Rect bottomRight = createHitRectangle ( right , bottom ) ; Rect center = new Rect ( left , top , owidth , oheight ) ; if ( topLeft . contains ( pt ) ) { dragState = DragState . TOP_LEFT ; 
public void mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return ; double x = pt . getX ( ) ; double y = pt . getY ( ) ; double dx = x - px ; double dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return ; switch ( dragState ) { case TOP_LEFT : 
public void mouseReleased ( Point pt ) { dragState = DragState . NONE ; } 
public Node getNode ( ) ; public void draw ( GraphicsContext ctx ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt);} 
public void draw ( GraphicsContext ctx ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt);} 
public void mouseClicked ( Point pt ) ; public void mousePressed ( Point pt ) ; public void mouseReleased ( Point pt ) ; public void mouseEntered ( Point pt ) ; public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; } 
public void mousePressed ( Point pt ) ; public void mouseReleased ( Point pt ) ; public void mouseEntered ( Point pt ) ; public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; } 
public void mouseReleased ( Point pt ) ; public void mouseEntered ( Point pt ) ; public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; } 
public void mouseEntered ( Point pt ) ; public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; } 
public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; } 
public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; } 
public void mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; ox = node . asFloat ( xName ) ; oy = node . asFloat ( yName ) ; Rect hitRect = createHitRectangle ( ox , oy ) ; if ( hitRect . contains ( pt ) ) { dragging = true ; 
public void mouseDragged ( Point e ) { if ( ! dragging ) return ; double x = e . getX ( ) ; double y = e . getY ( ) ; double dx = x - px ; double dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return ; node . set ( xName , ox + dx ) ; node . set ( yName , oy + dy ) ; } 
public void mouseReleased ( Point pt ) { dragging = false ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . getParameter ( " template " ) . isConnected ( ) ? node . asGrob ( " template " ) : null ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) ; double sy = node . asFloat ( " sy " ) ; String expression = node . asString ( " expression " ) ; if ( expression = = null | | expression . trim ( ) . length ( ) = = 0 ) { if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } } else { Expression set. The expression allows you to modify field values on upstream nodes while copying. The expression has access to all the nodes by their name (e.g. rect1), and can set values on them. The CY local variable contains the copy number (starting from zero) Parameter pShape = node.getParameter("shape"); if (!pShape.isConnected()) throw new AssertionError("The shape is not connected."); List<Point> points; if (template == null) { points = new ArrayList<Point>(); points.add(new Point()); } else { points = pointsForGrob(template); } int copyIndex = 0; for (Point p : points) { Transform t = new Transform(); t.translate(p.getX(), p.getY()); for (int i = 0; i < copies; i++) { Node upstreamNode = pShape.getExplicitConnection().getOutputNode(); Node copiedUpstreamNode = upstreamNode.getNetwork().copyNodeWithUpstream(upstreamNode); These expressions can mutate the values; that's sort of the point. Expression expressionObject = new Expression(copiedUpstreamNode.getOutputParameter(), expression, true); The expression object changes the node values, so I don't care about the output. ProcessingContext copyContext = (ProcessingContext) ctx.clone(); copyContext.put("COPY", copyIndex); expressionObject.evaluate(copyContext); Now evaluate the output of the new upstream node. copiedUpstreamNode.update(ctx); if (copiedUpstreamNode.hasError()) throw new ProcessingError(node, "Upstream node contained errors:" + copiedUpstreamNode.getMessages().toString()); We do not need to clone the output shape. Grob outputShape = (Grob) copiedUpstreamNode.getOutputValue(); outputShape.prependTransform(t); outputGroup.add(outputShape); t.translate(tx, ty); t.rotate(r); t.scale(sx, sy); copyIndex++; } } } node.setOutputValue(outputGroup); return true; } 
public boolean process ( Node node , ProcessingContext ctx ) { double width = node . asFloat ( " width " ) ; double height = node . asFloat ( " height " ) ; int rows = node . asInt ( " rows " ) ; int columns = node . asInt ( " columns " ) ; double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; double columnsize = 0 ; double left = 0 ; if ( columns > 1 ) { columnsize = width / ( columns - 1 ) ; left = x - width / 2 ; } double rowsize = 0 ; double top = 0 ; if ( rows > 1 ) { rowsize = height / ( rows - 1 ) ; top = y - height / 2 ; } Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; for ( int rowindex = 0 ; rowindex < rows ; rowindex + + ) { for ( int columnindex = 0 ; columnindex < columns ; columnindex + + ) { p . moveto ( left + columnindex * columnsize , top + rowindex * rowsize ) ; } } g . add ( p ) ; node . setOutputValue ( g ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; BezierPath p = new BezierPath ( ) ; p . setFillColor ( node . asColor ( " fill " ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; double rx = node . asFloat ( " rx " ) ; double ry = node . asFloat ( " ry " ) ; if ( rx = = 0 & & ry = = 0 ) { p . rect ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; } else { p . roundedRect ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) , rx , ry ) ; } g . add ( p ) ; node . setOutputValue ( g ) ; return true ; } 
public void testBounds ( ) { BezierPath p1 = new BezierPath ( ) ; p1 . rect ( 20 , 30 , 40 , 50 ) ; assertEquals ( Rect . centeredRect ( 20 , 30 , 40 , 50 ) , p1 . getBounds ( ) ) ; BezierPath p2 = new BezierPath ( ) ; p2 . rect ( 60 , 70 , 80 , 90 ) ; assertEquals ( Rect . centeredRect ( 60 , 70 , 80 , 90 ) , p2 . getBounds ( ) ) ; } 
public void testFrame ( ) { BezierPath p1 = new BezierPath ( ) ; p1 . rect ( 20 , 30 , 40 , 50 ) ; p1 . translate ( 200 , 300 ) ; assertEquals ( Rect . centeredRect ( 220 , 330 , 40 , 50 ) , p1 . getFrame ( ) ) ; } 
public void testBounds ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Group g1 = new Group ( ) ; g1 . add ( r1 ) ; assertEquals ( Rect . centeredRect ( 10 , 20 , 30 , 40 ) , g1 . getBounds ( ) ) ; } 
public void testTransformedBounds ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; r1 . translate ( 200 , 300 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; assertEquals ( Rect . centeredRect ( 210 , 320 , 30 , 40 ) , g . getBounds ( ) ) ; } 
public void testTransformedElements ( ) { BezierPath r1 = new BezierPath ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; BezierPath r2 = new BezierPath ( ) ; r2 . rect ( 10 , 120 , 30 , 40 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; g . add ( r2 ) ; Rect rect1 = Rect . centeredRect ( 10 , 20 , 30 , 40 ) ; Rect rect2 = Rect . centeredRect ( 10 , 120 , 30 , 40 ) ; assertEquals ( rect1 . united ( rect2 ) , g . getBounds ( ) ) ; } 
public void testBasicCopy ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; Node copy = net . create ( manager . getNodeType ( " corevector.copy " ) ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( Rect . centeredRect ( 0 , 0 , 100 , 100 ) , g . getBounds ( ) ) ; copy . setValue ( " ty " , 100.0 ) ; copy . setValue ( " copies " , 5 ) ; copy . update ( ) ; g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( - 50 , - 50 , 100 , 500 ) , g . getBounds ( ) ) ; } 
public void testCopyStamping ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; Node copy = net . create ( manager . getNodeType ( " corevector.copy " ) ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . set ( " copies " , 10 ) ; copy . set ( " expression " , " rect1.x = COPY " ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( - 50 , - 50 , 109 , 100 ) , g . getBounds ( ) ) ; } 
public void testBasicMerge ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect1 = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; rect1 . set ( " x " , 25.0 ) ; Node ellipse1 = net . create ( manager . getNodeType ( " corevector.ellipse " ) ) ; ellipse1 . set ( " x " , 199.0 ) ; Node merge = net . create ( manager . getNodeType ( " corevector.merge " ) ) ; merge . getParameter ( " shapes " ) . connect ( rect1 ) ; merge . getParameter ( " shapes " ) . connect ( ellipse1 ) ; merge . update ( ) ; Group g = ( Group ) merge . getOutputValue ( ) ; assertEquals ( 2 , g . getGrobs ( ) . size ( ) ) ; Group rectGroup = ( Group ) g . get ( 0 ) ; assertEquals ( 1 , rectGroup . size ( ) ) ; BezierPath rectPath = ( BezierPath ) rectGroup . get ( 0 ) ; Compare the X value set on the rect1 node so we know it is the output of the rect1 node. assertEquals(25.0 - 50.0, rectPath.getBounds().getX()); Group ellipseGroup = (Group) g.get(1); assertEquals(1, ellipseGroup.size()); BezierPath ellipsePath = (BezierPath) ellipseGroup.get(0); Compare the X value set on the ellipse1 node assertEquals(199.0 - 50.0, ellipsePath.getBounds().getX()); 
public void testRectNode ( ) { Node r = manager . getNodeType ( " corevector.rect " ) . createNode ( ) ; r . update ( ) ; Object outputValue = r . getOutputValue ( ) ; if ( ! ( outputValue instanceof Group ) ) fail ( " Output value is not a Group, but " + outputValue ) ; Group group = ( Group ) outputValue ; assertEquals ( 1 , group . size ( ) ) ; BezierPath p = ( BezierPath ) group . get ( 0 ) ; assertEquals ( new Rect ( - 50 , - 50 , 100 , 100 ) , p . getBounds ( ) ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { return false ; } 
public void mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return ; double x = pt . getX ( ) ; double y = pt . getY ( ) ; double dx = x - px ; double dy = y - py ; The delta value is multiplied by 2 to create the double effect of moving the top left corner down and the bottom left corner up (in the case of the top left handle). dx *= 2; dy *= 2; if (dx == 0 && dy == 0) return; switch (dragState) { case TOP_LEFT: 
public void networkDirty ( Network network ) { if ( network ! = activeNetwork ) return ; markChanged ( ) ; activeNetwork . update ( ) ; doRender(); 
private void doRender ( ) { renderThread . render ( activeNetwork ) ; } 
public void actionPerformed ( ActionEvent e ) { if ( shouldClose ( ) ) { renderThread . shutdown ( ) ; 
public void run ( ) { while ( running ) { if ( shouldRender & & ! isRendering ) 
public void render ( Network network ) { this . network = network ; shouldRender = true ; } 
private void doRender ( ) { if ( isRendering ) return ; isRendering = true ; network . update ( ) ; shouldRender = false ; isRendering = false ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); g2.translate(getWidth() / 2.0, getHeight() / 2.0); if (getNetwork() == null) return; Object outputValue = getNetwork().getOutputValue(); if (outputValue instanceof Grob) { ((Grob) outputValue).draw(g2); } Draw handle if (handle != null) { Create a canvas with a transparent background net.nodebox.graphics.Canvas canvas = new net.nodebox.graphics.Canvas(); canvas.setBackground(new net.nodebox.graphics.Color(0, 0, 0, 0)); GraphicsContext ctx = new GraphicsContext(canvas); handle.draw(ctx); ctx.getCanvas().draw(g2); } Draw center g.setColor(new Color(240, 240, 240)); g.drawLine(-getWidth() / 2, 0, getWidth() / 2, 0); g.drawLine(0, -getHeight() / 2, 0, getHeight() / 2); } 
public void draw ( Graphics2D g ) { double halfWidth = width / 2 ; double halfHeight = height / 2 ; double left = - halfWidth ; double right = halfWidth ; double top = - halfHeight ; double bottom = halfHeight ; g . setColor ( background . getAwtColor ( ) ) ; g . fillRect ( ( int ) left , ( int ) top , ( int ) width , ( int ) height ) ; Rectangle clip = g . getClipBounds ( ) ; int clipwidth = clip ! = null & & width > clip . width ? clip . width : ( int ) height ; int clipheight = clip ! = null & & height > clip . height ? clip . height : ( int ) width ; g . setClip ( clip ! = null ? clip . x : 0 , clip ! = null ? clip . y : 0 , clipwidth , clipheight ) ; super . draw ( g ) ; } 
private void librariesErrorEvent ( String libraryName , Exception exception ) { startupDialog . setVisible ( false ) ; ExceptionDialog ed = new ExceptionDialog ( null , exception , " Library: " + libraryName ) ; ed . setVisible ( true ) ; } 
public void run ( ) { Properties jythonProperties = new Properties ( ) ; String jythonCacheDir = PlatformUtils . getUserDataDirectory ( ) + PlatformUtils . SEP + " jythoncache " ; jythonProperties . put ( " python.cachedir " , jythonCacheDir ) ; PySystemState . initialize ( System . getProperties ( ) , jythonProperties , new String [ ] { " " } ) ; String workingDirectory = System . getProperty ( " user.dir " ) ; File pythonLibraries = new File ( workingDirectory , " lib " + PlatformUtils . SEP + " python.zip " ) ; Py . getSystemState ( ) . path . add ( new PyString ( pythonLibraries . getAbsolutePath ( ) ) ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { if ( finalException ! = null ) { Application . getInstance ( ) . librariesErrorEvent ( finalLibraryName , finalException ) ; 
public void actionPerformed ( ActionEvent e ) { System . exit ( - 1 ) ; } 
public static void handle ( Throwable ) { System . out . println ( " handle! " ) ; showException ( Thread . currentThread ( ) , ) ; } 
public void uncaughtException ( final Thread , final Throwable e ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { showException ( , e ) ; 
public void run ( ) { showException ( , e ) ; } 
private static void showException ( Thread , Throwable e ) { String msg = String . format ( " Unexpected problem on thread %s: %s " , . getName ( ) , e . getMessage ( ) ) ; logException ( , e ) ; note: in a real app, you should locate the currently focused frame or dialog and use it as the parent. In this example, I'm just passing a null owner, which means this dialog may get buried behind some other screen. ExceptionDialog ed = new ExceptionDialog(null, e); ed.setVisible(true); } 
private static void logException ( Thread , Throwable e ) { todo: start a thread that sends an email, or write to a log file, or send a JMS message...whatever }} 
public void networkDirty ( Network network ) { if ( network ! = activeNetwork ) return ; markChanged ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { activeNetwork . update ( ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); g2.translate(getWidth() / 2.0, getHeight() / 2.0); if (getNetwork() == null) return; Object outputValue = getNetwork().getOutputValue(); if (outputValue instanceof Grob) { ((Grob) outputValue).draw(g2); } Draw handle if (handle != null) { Create a canvas with a transparent background 
public void mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return ; double x = pt . getX ( ) ; double y = pt . getY ( ) ; double dx = x - px ; double dy = y - py ; The delta value is multiplied by 2 to create the double effect of moving the top left corner down and the bottom left corner up (in the case of the top left handle). if (dx == 0 && dy == 0) return; switch (dragState) { case TOP_LEFT: 
public void actionPerformed ( ActionEvent e ) { if ( shouldClose ( ) ) { renderThread.shutdown(); 
public void roundedRect ( double cx , double cy , double width , double height , double rx , double ry ) { double halfWidth = width / 2.0 ; double halfHeight = height / 2.0 ; double dx = rx ; double dy = ry ; double left = cx - halfWidth ; double right = cx + halfWidth ; double top = cy - halfHeight ; double bottom = cy + halfHeight ; rx/ry cannot be greater than half of the width of the retoctangle (required by SVG spec) dx = Math.min(dx, width * 0.5); dy = Math.min(dy, height * 0.5); moveto(left + dx, top); if (dx < width * 0.5) lineto(right - rx, top); curveto(right - dx * ONE_MINUS_QUARTER, top, right, top + dy * ONE_MINUS_QUARTER, right, top + dy); if (dy < height * 0.5) lineto(right, bottom - dy); curveto(right, bottom - dy * ONE_MINUS_QUARTER, right - dx * ONE_MINUS_QUARTER, bottom, right - dx, bottom); if (dx < width * 0.5) lineto(left + dx, bottom); curveto(left + dx * ONE_MINUS_QUARTER, bottom, left, bottom - dy * ONE_MINUS_QUARTER, left, bottom - dy); if (dy < height * 0.5) lineto(left, top + dy); curveto(left, top + dy * ONE_MINUS_QUARTER, left + dx * ONE_MINUS_QUARTER, top, left + dx, top); close(); } 
public void testOnlyOneConnect ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node number1 = net . create ( numberType ) ; Node number2 = net . create ( numberType ) ; Node negate1 = net . create ( negateType ) ; negate1 . getParameter ( " value " ) . connect ( number1 ) ; assertTrue ( number1 . isConnected ( ) ) ; assertFalse ( number2 . isConnected ( ) ) ; assertTrue ( negate1 . isConnected ( ) ) ; Now change the connection to number2. negate1.getParameter("value").connect(number2); assertFalse(number1.isConnected()); assertTrue(number2.isConnected()); assertTrue(negate1.isConnected()); } 
public String toString ( ) { return " <Image ( " + getWidth ( ) + " , " + getHeight ( ) + " )> " ; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new GridType ( corevector ) ) ; corevector . addNodeType ( new MergeType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new PathNetworkType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; coreimage . addNodeType ( new ImageType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public boolean canConnectTo ( Parameter parameter ) { Output paramters can only be connected to input parameters. if (parameter instanceof OutputParameter) return false; return super.canConnectTo(parameter); } 
public Grob asGrob ( ) { assertCardinality ( ) ; if ( getCoreType ( ) = = ParameterType . CoreType . GROB_PATH | | getCoreType ( ) = = ParameterType . CoreType . GROB_CANVAS 
public boolean canConnectTo ( Parameter parameter ) { Parameters can only be connected to output parameters. TODO: No longer true for implicit connections if (!(parameter instanceof OutputParameter)) return false; return getParameterType().canConnectTo(parameter.getParameterType()); } 
public boolean canConnectTo ( Node outputNode ) { if ( ! node . inNetwork ( ) ) return false ; if ( ! outputNode . inNetwork ( ) ) return false ; if ( node . getNetwork ( ) ! = outputNode . getNetwork ( ) ) return false ; return canConnectTo ( outputNode . getOutputParameter ( ) ) ; } 
public boolean canConnectTo ( ParameterType outputParameterType ) { Class thisType = CORE_TYPE_MAPPING . get ( coreType ) ; Class otherType = CORE_TYPE_MAPPING . get ( outputParameterType . coreType ) ; return thisType . isAssignableFrom ( otherType ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { BezierPath p = new BezierPath ( ) ; p . setFillColor ( node . asColor ( " fill " ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; p . ellipse ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; node . setOutputValue ( p ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { double width = node . asFloat ( " width " ) ; double height = node . asFloat ( " height " ) ; int rows = node . asInt ( " rows " ) ; int columns = node . asInt ( " columns " ) ; double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; double columnsize = 0 ; double left = 0 ; if ( columns > 1 ) { columnsize = width / ( columns - 1 ) ; left = x - width / 2 ; } double rowsize = 0 ; double top = 0 ; if ( rows > 1 ) { rowsize = height / ( rows - 1 ) ; top = y - height / 2 ; } BezierPath p = new BezierPath ( ) ; for ( int rowindex = 0 ; rowindex < rows ; rowindex + + ) { for ( int columnindex = 0 ; columnindex < columns ; columnindex + + ) { p . moveto ( left + columnindex * columnsize , top + rowindex * rowsize ) ; } } node . setOutputValue ( p ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { BezierPath p = new BezierPath ( ) ; p . setFillColor ( node . asColor ( " fill " ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; double rx = node . asFloat ( " rx " ) ; double ry = node . asFloat ( " ry " ) ; if ( rx = = 0 & & ry = = 0 ) { p . rect ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; } else { p . roundedRect ( node . asFloat ( " x " ) , node . asFloat ( " y " ) , node . asFloat ( " width " ) , node . asFloat ( " height " ) , rx , ry ) ; } node . setOutputValue ( p ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { BezierPath path = ( BezierPath ) node . asGrob ( " path " ) ; int amount = node . asInt ( " points " ) ; Random random = new Random ( node . asInt ( " seed " ) ) ; BezierPath newPath = new BezierPath ( ) ; Rect bounds = path . getBounds ( ) ; double bx = bounds . getX ( ) ; double by = bounds . getY ( ) ; double bw = bounds . getWidth ( ) ; double bh = bounds . getHeight ( ) ; Point pt = null ; for ( int i = 0 ; i < amount ; i + + ) { int tries = 100 ; while ( tries > 0 ) { pt = new Point ( bx + random . nextDouble ( ) * bw , by + random . nextDouble ( ) * bh ) ; if ( path . contains ( pt ) ) break ; tries - - ; } if ( tries = = 0 ) { node . addWarning ( " Scatter: no points found on the path. " ) ; } else { newPath . moveto ( pt ) ; } } node . setOutputValue ( newPath ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Text = new Text ( node . asString ( " text " ) , node . asFloat ( " x " ) , node . asFloat ( " y " ) ) ; . setWidth ( node . asFloat ( " width " ) ) ; . setHeight ( node . asFloat ( " height " ) ) ; . setFontName ( node . asString ( " fontName " ) ) ; . setFontSize ( node . asFloat ( " fontSize " ) ) ; . setLineHeight ( node . asFloat ( " lineHeight " ) ) ; . setFillColor ( node . asColor ( " fill " ) ) ; BezierPath p = new BezierPath ( . getPath ( ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; node . setOutputValue ( p ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group g = new Group ( ) ; Text = new Text ( node . asString ( " text " ) , node . asFloat ( " x " ) , node . asFloat ( " y " ) ) ; . setWidth ( node . asFloat ( " width " ) ) ; . setHeight ( node . asFloat ( " height " ) ) ; . setFontName ( node . asString ( " fontName " ) ) ; . setFontSize ( node . asFloat ( " fontSize " ) ) ; . setLineHeight ( node . asFloat ( " lineHeight " ) ) ; . setFillColor ( node . asColor ( " fill " ) ) ; g . add ( ) ; node . setOutputValue ( g ) ; return true ; } 
public void testDefaultValue ( ) { NodeType customType = numberType . clone ( ) ; ParameterType ptInt = customType . addParameterType ( " int " , ParameterType . Type . INT ) ; ParameterType ptFloat = customType . addParameterType ( " float " , ParameterType . Type . FLOAT ) ; ParameterType ptString = customType . addParameterType ( " string " , ParameterType . Type . STRING ) ; ParameterType ptColor = customType . addParameterType ( " color " , ParameterType . Type . COLOR ) ; ParameterType ptCanvas = customType . addParameterType ( " canvas " , ParameterType . Type . GROB_CANVAS ) ; ParameterType ptPath = customType . addParameterType ( " path " , ParameterType . Type . GROB_PATH ) ; ParameterType ptImage = customType . addParameterType ( " image " , ParameterType . Type . GROB_IMAGE ) ; assertEquals ( 0 , ptInt . getDefaultValue ( ) ) ; assertEquals ( 0.0 , ptFloat . getDefaultValue ( ) ) ; assertEquals ( " " , ptString . getDefaultValue ( ) ) ; assertEquals ( new Color ( ) , ptColor . getDefaultValue ( ) ) ; assertEquals ( new Canvas ( ) , ptCanvas . getDefaultValue ( ) ) ; assertEquals ( new BezierPath ( ) , ptPath . getDefaultValue ( ) ) ; assertEquals ( new Image ( ) , ptImage . getDefaultValue ( ) ) ; } 
public void testDowncasting ( ) { NodeType customType = numberType . clone ( ) ; ParameterType ptGrob = customType . addParameterType ( " grob " , ParameterType . Type . GROB ) ; ParameterType ptCanvas = customType . addParameterType ( " canvas " , ParameterType . Type . GROB_CANVAS ) ; ParameterType ptGroup = customType . addParameterType ( " group " , ParameterType . Type . GROB_GROUP ) ; ParameterType ptImage = customType . addParameterType ( " image " , ParameterType . Type . GROB_IMAGE ) ; ParameterType ptPath = customType . addParameterType ( " path " , ParameterType . Type . GROB_PATH ) ; ParameterType ptText = customType . addParameterType ( " text " , ParameterType . Type . GROB_TEXT ) ; Canvas canvas = new Canvas ( ) ; Group group = new Group ( ) ; Image image = new Image ( ) ; BezierPath path = new BezierPath ( ) ; Text text = new Text ( " " , 0 , 0 ) ; assertValidValue ( ptGrob , canvas ) ; assertValidValue ( ptGrob , group ) ; assertValidValue ( ptGrob , image ) ; assertValidValue ( ptGrob , path ) ; assertValidValue ( ptGrob , text ) ; assertValidValue ( ptCanvas , canvas ) ; assertInvalidValue ( ptCanvas , group ) ; assertInvalidValue ( ptCanvas , image ) ; assertInvalidValue ( ptCanvas , path ) ; assertInvalidValue ( ptCanvas , text ) ; assertValidValue ( ptGroup , canvas ) ; assertValidValue ( ptGroup , group ) ; assertInvalidValue ( ptGroup , image ) ; assertInvalidValue ( ptGroup , path ) ; assertInvalidValue ( ptGroup , text ) ; assertInvalidValue ( ptImage , canvas ) ; assertInvalidValue ( ptImage , group ) ; assertValidValue ( ptImage , image ) ; assertInvalidValue ( ptImage , path ) ; assertInvalidValue ( ptImage , text ) ; assertInvalidValue ( ptPath , canvas ) ; assertInvalidValue ( ptPath , group ) ; assertInvalidValue ( ptPath , image ) ; assertValidValue ( ptPath , path ) ; assertInvalidValue ( ptPath , text ) ; assertInvalidValue ( ptText , canvas ) ; assertInvalidValue ( ptText , group ) ; assertInvalidValue ( ptText , image ) ; assertInvalidValue ( ptText , path ) ; assertValidValue ( ptText , text ) ; assertTrue ( ptGrob . canConnectTo ( ptCanvas ) ) ; assertTrue ( ptGrob . canConnectTo ( ptGroup ) ) ; assertTrue ( ptGrob . canConnectTo ( ptImage ) ) ; assertTrue ( ptGrob . canConnectTo ( ptPath ) ) ; assertTrue ( ptGrob . canConnectTo ( ptText ) ) ; assertTrue ( ptGrob . canConnectTo ( ptGrob ) ) ; assertTrue ( ptCanvas . canConnectTo ( ptCanvas ) ) ; assertFalse ( ptCanvas . canConnectTo ( ptGroup ) ) ; assertTrue ( ptGroup . canConnectTo ( ptGroup ) ) ; assertTrue ( ptGroup . canConnectTo ( ptCanvas ) ) ; assertTrue ( ptPath . canConnectTo ( ptPath ) ) ; assertFalse ( ptPath . canConnectTo ( ptGrob ) ) ; assertFalse ( ptPath . canConnectTo ( ptImage ) ) ; } 
public void testBasicMerge ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect1 = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; rect1 . set ( " x " , 25.0 ) ; Node ellipse1 = net . create ( manager . getNodeType ( " corevector.ellipse " ) ) ; ellipse1 . set ( " x " , 199.0 ) ; Node merge = net . create ( manager . getNodeType ( " corevector.merge " ) ) ; merge . getParameter ( " shapes " ) . connect ( rect1 ) ; merge . getParameter ( " shapes " ) . connect ( ellipse1 ) ; merge . update ( ) ; Group g = ( Group ) merge . getOutputValue ( ) ; assertEquals ( 2 , g . getGrobs ( ) . size ( ) ) ; BezierPath rectPath = ( BezierPath ) g . get ( 0 ) ; Compare the X value set on the rect1 node so we know it is the output of the rect1 node. assertEquals(25.0 - 50.0, rectPath.getBounds().getX()); BezierPath ellipsePath = (BezierPath) g.get(1); Compare the X value set on the ellipse1 node assertEquals(199.0 - 50.0, ellipsePath.getBounds().getX()); 
public void testRectNode ( ) { Node r = manager . getNodeType ( " corevector.rect " ) . createNode ( ) ; r . update ( ) ; Object outputValue = r . getOutputValue ( ) ; if ( ! ( outputValue instanceof BezierPath ) ) fail ( " Output value is not a BezierPath, but " + outputValue ) ; BezierPath p = ( BezierPath ) outputValue ; assertEquals ( new Rect ( - 50 , - 50 , 100 , 100 ) , p . getBounds ( ) ) ; } 
public void testType ( ) { NodeType vectorNetworkType = manager . getNodeType ( " corevector.vecnet " ) ; Node = vectorNetworkType . createNode ( ) ; assertEquals ( ParameterType . Type . GROB_PATH , . getOutputParameter ( ) . getType ( ) ) ; } 
public void update ( ProcessingContext ctx ) { Check if the output node on the connection is not the same as my node. In that case, we don't want to process the node, since it will eventually end up updating this parameter, causing infinite recursion. if (getOutputNode() == getInputNode()) return; getOutputNode().update(ctx); TODO: This doesn't take multiconnections into account outputValue = getOutputNode().getOutputValue(); } 
public Grob asGrob ( ) { assertCardinality ( ) ; if ( getCoreType ( ) = = ParameterType . CoreType . GROB | | getCoreType ( ) = = ParameterType . CoreType . GROB_CANVAS 
public boolean process ( Node node , ProcessingContext ctx ) { Text = new Text ( node . asString ( " text " ) , node . asFloat ( " x " ) , node . asFloat ( " y " ) ) ; . setWidth ( node . asFloat ( " width " ) ) ; . setHeight ( node . asFloat ( " height " ) ) ; . setFontName ( node . asString ( " fontName " ) ) ; . setFontSize ( node . asFloat ( " fontSize " ) ) ; . setLineHeight ( node . asFloat ( " lineHeight " ) ) ; . setFillColor ( node . asColor ( " fill " ) ) ; node . setOutputValue ( ) ; return true ; } 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.resetContext(); context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("g", context); interpreter.set("BezierPath", net.nodebox.graphics.BezierPath.class); interpreter.set("Canvas", net.nodebox.graphics.Canvas.class); interpreter.set("Color", net.nodebox.graphics.Color.class); interpreter.set("GraphicsContext", net.nodebox.graphics.GraphicsContext.class); interpreter.set("Grob", net.nodebox.graphics.Grob.class); interpreter.set("Group", net.nodebox.graphics.Group.class); interpreter.set("Image", net.nodebox.graphics.Image.class); interpreter.set("NodeBoxError", net.nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", net.nodebox.graphics.PathElement.class); interpreter.set("Point", net.nodebox.graphics.Point.class); interpreter.set("Rect", net.nodebox.graphics.Rect.class); interpreter.set("Text", net.nodebox.graphics.Text.class); interpreter.set("Transform", net.nodebox.graphics.Transform.class); interpreter.set("LEFT", Text.Align.LEFT); interpreter.set("RIGHT", Text.Align.RIGHT); interpreter.set("CENTER", Text.Align.CENTER); interpreter.set("JUSTIFY", Text.Align.JUSTIFY); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
public void resetContext ( ) { fillColor = new Color ( ) ; strokeColor = null ; strokeWidth = 1.0 ; canvas . setBackground ( new Color ( 1 , 1 , 1 ) ) ; path = null ; transform = new Transform ( ) ; transformStack = new ArrayList < Transform > ( ) ; fontName = " Helvetica " ; fontSize = 24 ; lineHeight = 1.2 ; align = Text . Align . CENTER ; } 
public BezierPath line ( double x1 , double y1 , double x2 , double y2 ) { BezierPath p = new BezierPath ( ) ; p . line ( x1 , y1 , x2 , y2 ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public Text text ( String text , double x , double y ) { return text ( text , x , y , 0 , 0 ) ; } 
public Text text ( String text , double x , double y , double width ) { return text ( text , x , y , width , 0 ) ; } 
public BezierPath textPath ( String text , double x , double y ) { return textPath ( text , x , y , 0 , 0 ) ; } 
public BezierPath textPath ( String text , double x , double y , double width ) { return textPath ( text , x , y , width , 0 ) ; } 
public Rect textMetrics ( String text ) { return textMetrics ( text , 0 , 0 ) ; } 
public Rect textMetrics ( String text , double width ) { return textMetrics ( text , width , 0 ) ; } 
public void draw ( Graphics2D g ) { if ( fillColor = = null ) return ; setupTransform ( g ) ; if ( text = = null | | text . length ( ) = = 0 ) return ; TextLayoutIterator iterator = new TextLayoutIterator ( ) ; while ( iterator . hasNext ( ) ) { TextLayout layout = iterator . next ( ) ; layout . draw ( g , ( float ) baseLineX + iterator . getX ( ) , ( float ) baseLineY + iterator . getY ( ) ) ; } restoreTransform ( g ) ; } 
public void typeChangedEvent ( ParameterType source ) { for ( WeakReference < Node > ref : instanceRefs ) { Node = ref . get ( ) ; 
public void boundingChangedEvent ( ParameterType source ) { for ( WeakReference < Node > ref : instanceRefs ) { Node = ref . get ( ) ; 
public void displayLevelChangedEvent ( ParameterType source ) { for ( WeakReference < Node > ref : instanceRefs ) { Node = ref . get ( ) ; 
public void nullAllowedChangedEvent ( ParameterType source ) { for ( WeakReference < Node > ref : instanceRefs ) { Node = ref . get ( ) ; 
public Node createNode ( ) { Node = new Node ( this ) ; instanceRefs . add ( new WeakReference < Node > ( ) ) ; return ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . getParameter ( " template " ) . isConnected ( ) ? node . asGrob ( " template " ) : null ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) ; double sy = node . asFloat ( " sy " ) ; String expression = node . asString ( " expression " ) ; Expression expressionObject = new Expression ( expression , true ) ; ProcessingContext copyContext = ( ProcessingContext ) ctx . clone ( ) ; if ( expression = = null | | expression . trim ( ) . length ( ) = = 0 ) { if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } } else { Expression set. The expression allows you to modify field values on upstream nodes while copying. The expression has access to all the nodes by their name (e.g. rect1), and can set values on them. The CY local variable contains the copy number (starting from zero) Parameter pShape = node.getParameter("shape"); if (!pShape.isConnected()) throw new AssertionError("The shape is not connected."); List<Point> points; if (template == null) { points = new ArrayList<Point>(); points.add(new Point()); } else { points = pointsForGrob(template); } int copyIndex = 0; for (Point p : points) { Transform t = new Transform(); t.translate(p.getX(), p.getY()); for (int i = 0; i < copies; i++) { Node upstreamNode = pShape.getExplicitConnection().getOutputNode(); Node copiedUpstreamNode = upstreamNode.getNetwork().copyNodeWithUpstream(upstreamNode); These expressions can mutate the values; that's sort of the point. expressionObject.setParameter(copiedUpstreamNode.getOutputParameter()); The expression object changes the node values, so I don't care about the output. copyContext.put("COPY", copyIndex); expressionObject.evaluate(copyContext); Now evaluate the output of the new upstream node. copiedUpstreamNode.update(ctx); if (copiedUpstreamNode.hasError()) throw new ProcessingError(node, "Upstream node contained errors:" + copiedUpstreamNode.getMessages().toString()); We do not need to clone the output shape. Grob outputShape = (Grob) copiedUpstreamNode.getOutputValue(); outputShape.prependTransform(t); outputGroup.add(outputShape); t.translate(tx, ty); t.rotate(r); t.scale(sx, sy); copyIndex++; } } } node.setOutputValue(outputGroup); return true; } 
public boolean process ( Node node , ProcessingContext ctx ) { Text = new Text ( node . asString ( " text " ) , node . asFloat ( " x " ) , node . asFloat ( " y " ) ) ; . setWidth ( node . asFloat ( " width " ) ) ; . setHeight ( node . asFloat ( " height " ) ) ; . setFontName ( node . asString ( " fontName " ) ) ; . setFontSize ( node . asFloat ( " fontSize " ) ) ; . setLineHeight ( node . asFloat ( " lineHeight " ) ) ; . setAlign ( Text . Align . valueOf ( node . asString ( " align " ) . toUpperCase ( ) ) ) ; . setFillColor ( node . asColor ( " fill " ) ) ; BezierPath p = new BezierPath ( . getPath ( ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; node . setOutputValue ( p ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Text = new Text ( node . asString ( " text " ) , node . asFloat ( " x " ) , node . asFloat ( " y " ) ) ; . setWidth ( node . asFloat ( " width " ) ) ; . setHeight ( node . asFloat ( " height " ) ) ; . setFontName ( node . asString ( " fontName " ) ) ; . setFontSize ( node . asFloat ( " fontSize " ) ) ; . setLineHeight ( node . asFloat ( " lineHeight " ) ) ; . setAlign ( Text . Align . valueOf ( node . asString ( " align " ) . toUpperCase ( ) ) ) ; . setFillColor ( node . asColor ( " fill " ) ) ; node . setOutputValue ( ) ; return true ; } 
public void activeNodeChanged ( Node activeNode ) { If the active node is already selected, don't change the selection. This avoids nasty surprises when multiple nodes (including the active one) are selected. if (networkView.isSelected(activeNode)) return; networkView.singleSelect(activeNode); } 
public void propertyChange ( PropertyChangeEvent evt ) { if ( ! evt . getPropertyName ( ) . equals ( NetworkView . SELECT_PROPERTY ) ) return ; Set < NodeView > selection = ( Set < NodeView > ) evt . getNewValue ( ) ; If there is no selection, set the active node to null. if (selection == null || selection.isEmpty()) { getDocument().setActiveNode(null); 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; popupHandler = new PopupHandler ( ) ; getLayer ( ) . addInputEventListener ( popupHandler ) ; } 
public boolean isSelected ( Node node ) { if ( node = = null ) return false ; NodeView nodeView = getNodeView ( node ) ; return isSelected ( nodeView ) ; } 
public boolean isSelected ( NodeView nodeView ) { if ( nodeView = = null ) return false ; return selection . contains ( nodeView ) ; } 
public void select ( Node node ) { NodeView nodeView = getNodeView ( node ) ; select ( nodeView ) ; } 
public void singleSelect ( Node node ) { if ( node = = null ) return ; NodeView nodeView = getNodeView ( node ) ; singleSelect ( nodeView ) ; } 
public void singleSelect ( NodeView nodeView ) { if ( nodeView = = null ) return ; if ( selection . size ( ) = = 1 & & selection . contains ( nodeView ) ) return ; for ( NodeView nv : selection ) { nv . setSelected ( false ) ; } selection . clear ( ) ; selection . add ( nodeView ) ; nodeView . setSelected ( true ) ; firePropertyChange ( SELECT_PROPERTY , null , selection ) ; } 
public void select ( NodeView nodeView ) { if ( nodeView = = null ) return ; If the selection already contained the object, bail out. This is to prevent the select event from firing. if (selection.contains(nodeView)) return; selection.add(nodeView); nodeView.setSelected(true); firePropertyChange(SELECT_PROPERTY, null, selection); } 
public void select ( Set < NodeView > newSelection ) { boolean selectionChanged = false ; for ( NodeView nodeView : newSelection ) { if ( ! selection . contains ( nodeView ) ) { selectionChanged = true ; nodeView . setSelected ( true ) ; selection . add ( nodeView ) ; } } if ( selectionChanged ) firePropertyChange ( SELECT_PROPERTY , null , selection ) ; 
public void deselect ( NodeView nodeView ) { if ( nodeView = = null ) return ; If the selection didn't contain the object in the first place, bail out. This is to prevent the select event from firing. if (!selection.contains(nodeView)) return; selection.remove(nodeView); nodeView.setSelected(false); firePropertyChange(SELECT_PROPERTY, null, selection); } 
public void deselectAll ( ) { If the selection was already empty, we don't need to do anything. if (selection.isEmpty()) return; for (NodeView nodeView : selection) { nodeView.setSelected(false); } selection.clear(); firePropertyChange(SELECT_PROPERTY, null, selection); } 
public void nodeRemoved ( Network source , Node node ) { NodeView nv = getNodeView ( node ) ; if ( nv = = null ) return ; getLayer ( ) . removeChild ( nv ) ; if ( selection . contains ( nv ) ) { deselect ( nv ) ; 
public void dragSelection ( double deltaX , double deltaY ) { for ( NodeView nv : selection ) { Point2D pt = nv . getOffset ( ) ; 
public void mousePressed ( PInputEvent e ) { if ( e . getButton ( ) ! = MouseEvent . BUTTON1 ) return ; Point2D p = e . getPosition ( ) ; selectionMarker = new SelectionMarker ( p ) ; getLayer ( ) . addChild ( selectionMarker ) ; temporarySelection . clear ( ) ; } 
public void mouseDragged ( PInputEvent e ) { if ( selectionMarker = = null ) return ; Point2D prev = selectionMarker . getOffset ( ) ; Point2D p = e . getPosition ( ) ; selectionMarker . setWidth ( p . getX ( ) - prev . getX ( ) ) ; selectionMarker . setHeight ( p . getY ( ) - prev . getY ( ) ) ; ListIterator childIter = getLayer ( ) . getChildrenIterator ( ) ; temporarySelection . clear ( ) ; while ( childIter . hasNext ( ) ) { Object o = childIter . next ( ) ; 
public void mouseReleased ( PInputEvent pInputEvent ) { if ( selectionMarker = = null ) return ; getLayer ( ) . removeChild ( selectionMarker ) ; selectionMarker = null ; select ( temporarySelection ) ; temporarySelection . clear ( ) ; } 
public void processEvent ( PInputEvent e , int i ) { if ( ! e . isPopupTrigger ( ) ) return ; if ( e . isHandled ( ) ) return ; Point2D p = e . getCanvasPosition ( ) ; networkMenu . show ( NetworkView . this , ( int ) p . getX ( ) , ( int ) p . getY ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { showNodeManagerDialog ( ) ; } 
public void mouseDragged ( PInputEvent e ) { if ( isDragging ) { Point2D pt = e . getPosition ( ) ; double dx = pt . getX ( ) - dragPoint . getX ( ) ; double dy = pt . getY ( ) - dragPoint . getY ( ) ; getNetworkView ( ) . dragSelection ( dx , dy ) ; dragPoint = pt ; } e . setHandled ( true ) ; } 
public void processEvent ( PInputEvent e , int i ) { if ( ! e . isPopupTrigger ( ) ) return ; JPopupMenu menu = new JPopupMenu ( ) ; menu . add ( new SetRenderedAction ( ) ) ; menu . add ( new DeleteAction ( ) ) ; Point2D p = e . getCanvasPosition ( ) ; menu . show ( NodeView . this . networkView , ( int ) p . getX ( ) , ( int ) p . getY ( ) ) ; e . setHandled ( true ) ; } 
public void actionPerformed ( ActionEvent e ) { node . setRendered ( ) ; } 
public void actionPerformed ( ActionEvent e ) { node . getNetwork ( ) . remove ( node ) ; } 
public boolean exportToFile ( File file ) { todo: file export only works on grobs. Object outputValue = activeNetwork.getOutputValue(); net.nodebox.graphics.Canvas canvas; if (outputValue instanceof net.nodebox.graphics.Canvas) { canvas = (net.nodebox.graphics.Canvas) outputValue; } else if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; Rect bounds = g.getBounds(); canvas = new net.nodebox.graphics.Canvas(bounds.getWidth(), bounds.getHeight()); } else { throw new RuntimeException("This type of output cannot be exported " + outputValue); } canvas.save(file); return true; } 
public void boundingChangedEvent ( ParameterType source ) { getParameter ( source . getName ( ) ) . boundingChangedEvent ( source ) ; } 
public void setValue ( Object value ) throws ValueError { OutputParameter accesses the value directly, since setValue in Parameter checks if the parameter is connected, which has different semantics for an OutputParameter. getParameterType().validate(value); this.value = value; fireValueChanged(); } 
public void boundingChangedEvent ( ParameterType source ) { if ( source . getBoundingMethod ( ) = = ParameterType . BoundingMethod . HARD ) clampToBounds ( ) ; 
public void testRemove ( ) { First add a node Network net = (Network) testNetworkType.createNode(); Node number1 = net.create(numberType); number1.set("value", 42); number1.setRendered(); net.update(); assertEquals(42, net.getOutputValue()); Now remove and update again net.remove(number1); net.update(); This should cause the network to complain that there is no node to render. assertTrue(net.hasError()); The output value should revert to the default value. assertEquals(0, net.getOutputValue()); } 
public void mouseReleased ( PInputEvent event ) { if ( isConnecting ) { if ( connectTarget ! = null ) connectTarget . repaint ( ) ; NodeView . this . repaint ( ) ; if ( connectSource ! = null & & connectTarget ! = null ) { java . util . List < Parameter > compatibleParameters = connectTarget . getNode ( ) . getCompatibleInputs ( connectSource . getNode ( ) ) ; if ( compatibleParameters . isEmpty ( ) ) { There are no compatible parameters. } else if (compatibleParameters.size() == 1) { Only one possible connection, make it now. Parameter inputParameter = compatibleParameters.get(0); try { inputParameter.connect(connectSource.getNode()); } catch (ConnectionError e) { JOptionPane.showMessageDialog(networkView, e.getMessage(), "Connection error", JOptionPane.ERROR_MESSAGE); } } else { JPopupMenu menu = new JPopupMenu("Select input"); for (Parameter p : compatibleParameters) { Action a = new SelectCompatibleParameterAction(connectSource.getNode(), connectTarget.getNode(), p); menu.add(a); } Point pt = getNetworkView().getMousePosition(); menu.show(getNetworkView(), pt.x, pt.y); } } } isDragging = false; isConnecting = false; connectSource = null; connectTarget = null; } 
public void actionPerformed ( ActionEvent e ) { try { inputParameter . connect ( outputNode ) ; 
public void actionPerformed ( ActionEvent e ) { if ( parameter . hasExpression ( ) ) { parameter . clearExpression ( ) ; } else { parameter . setExpression ( parameter . asExpression ( ) ) ; } setExpressionStatus ( ) ; } 
public void update ( ProcessingContext ctx ) { Check if the output node on the connection is not the same as my node. In that case, we don't want to process the node, since it will eventually end up updating this parameter, causing infinite recursion. if (getOutputNode() == getInputNode()) return; getOutputNode().update(ctx); outputValue = getOutputNode().getOutputValue(); } 
public String toString ( ) { return inputParameter + " => " + outputParameter ; } 
public String toString ( ) { return inputParameter + " => " + outputParameter + " : " + getMessage ( ) ; } 
public boolean hasCycles ( ) { for ( Node vertex : vertices ) { marks . put ( vertex , Color . WHITE ) ; } for ( Node vertex : vertices ) { if ( marks . get ( vertex ) = = Color . WHITE ) { if ( visit ( vertex ) ) return true ; } } return false ; } 
private boolean visit ( Node vertex ) { marks . put ( vertex , Color . GRAY ) ; Set < Node > outputNodes = edges . get ( vertex ) ; if ( outputNodes ! = null ) { for ( Node output : outputNodes ) { if ( ! marks . containsKey ( output ) ) continue ; if ( marks . get ( output ) = = Color . GRAY ) { return true ; } else if ( marks . get ( output ) = = Color . WHITE ) { if ( visit ( output ) ) return true ; } else { Visiting black vertices is okay. } } } marks.put(vertex, Color.BLACK); return false; } 
public String toString ( ) { return getInputParameter ( ) + " => " + getOutputParameters ( ) ; } 
public boolean containsCycles ( ) { return new CycleDetector ( this ) . hasCycles ( ) ; } 
public boolean isInputConnectedTo ( Node outputNode ) { Check parameters for upstream connections. for (Parameter p : parameters.values()) { if (p.isConnectedTo(outputNode)) return true; } return false; } 
public boolean update ( ProcessingContext ctx ) { if ( ! dirty ) return true ; for ( Parameter p : parameters . values ( ) ) { if ( ctx . isUpdating ( p ) | | ctx . hasProcessed ( p ) ) continue ; ctx . beginUpdating ( p ) ; try { p . update ( ctx ) ; } catch ( Exception e ) { messages . add ( new Message ( MessageLevel . ERROR , p . getName ( ) + " : " + e . getMessage ( ) ) ) ; dirty = false ; return false ; } ctx . endUpdating ( p ) ; } Only after all parameters have been processed should we process the node. This happens if parameters depend on eachother, which causes recursion. for (Parameter p : parameters.values()) { if (!ctx.hasProcessed(p)) return false; } messages.clear(); boolean success = process(ctx); dirty = false; return success; } 
public Connection connect ( Node outputNode ) { throw new ConnectionError ( this , null , " You can only connect from an input parameter. " ) ; } 
public boolean disconnect ( ) { throw new ConnectionError ( this , null , " You can only disconnect from an input parameter. " ) ; } 
public void clearExpression ( ) { this . expression = null ; setExpressionEnabled ( false ) ; clearDependencies ( ) ; fireValueChanged ( ) ; } 
public void beginUpdating ( Parameter parameter ) { State state = updatedParameters . get ( parameter ) ; if ( state = = null ) { updatedParameters . put ( parameter , State . UPDATING ) ; 
public void endUpdating ( Parameter parameter ) { State state = updatedParameters . get ( parameter ) ; if ( state = = null ) { throw new AssertionError ( " You should have called beginUpdating first. " ) ; 
public boolean isUpdating ( Parameter p ) { return updatedParameters . get ( p ) = = State . UPDATING ; } 
public boolean hasProcessed ( Parameter p ) { return updatedParameters . get ( p ) = = State . PROCESSED ; } 
public void testCycles ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node number1 = net . create ( numberType ) ; Node add1 = net . create ( addType ) ; Parameter pValue = number1 . getParameter ( " value " ) ; Parameter pV1 = add1 . getParameter ( " v1 " ) ; Parameter pV2 = add1 . getParameter ( " v2 " ) ; Create a direct cycle. assertExpressionInvalid(pValue, "value"); This should not have created any connections assertTrue(pValue.getDependencies().isEmpty()); number1.set("value", 42); assertExpressionEquals(42, pV1, "number1.value"); Create a 2-node cycle with expressions assertExpressionInvalid(pValue, "add1.v1"); Now create a 2-parameter cycle within the same node. pV1.setExpression("v2"); assertTrue(add1.update()); This does not cause an error... pV2.setExpression("v1"); TODO: ... but updating this node does. Currently, this works fine, but all parameters will get their default value. assertTrue(add1.update()); } 
public void testStaleData ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node number1 = net . create ( numberType ) ; Node add1 = net . create ( addType ) ; Parameter v1 = add1 . getParameter ( " v1 " ) ; Parameter v2 = add1 . getParameter ( " v2 " ) ; Basic setup: v2 -> v1 -> number1.value For this to work, v1 needs to update number1 first before v2 gets the data. If the value is not updated, v2 will get the value from v1, which hasn't updated yet, and which will thus return 0. number1.set("value", 42); v1.setExpression("number1.value"); v2.setExpression("v1"); assertTrue(add1.update()); assertEquals(42 + 42, add1.getOutputValue()); Because we cannot determine the exact order of processing, we need to run this test twice. So this is the setup in the other direction: v1 -> v2 -> number1.value This time, v2 needs to update number1 first, then v1. number1.set("value", 33); v1.setExpression("v2"); v2.setExpression("number1.value"); assertTrue(add1.update()); assertEquals(33 + 33, add1.getOutputValue()); } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.ellipse")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); } public void testCycles() { Network net = (Network) testNetworkType.createNode(); Node n1 = net.create(numberType); Node n2 = net.create(numberType); Node n3 = net.create(numberType); assertFalse(n2.isConnected()); assertValidConnect(n2, "value", n1); assertTrue(n2.isConnected()); assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isOutputConnectedTo(n2)); assertValidConnect(n3, "value", n2); assertTrue(n3.isConnected()); assertTrue(n3.isInputConnectedTo(n2)); assertTrue(n2.isOutputConnectedTo(n3)); Try creating a 2-node cycle. assertInvalidConnect(n1, "value", n2); The connection didn't go through, so n1's input is not connected to n2. assertFalse(n1.isInputConnectedTo(n2)); However the output of n2 is still connected to n1. assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isConnected()); assertTrue(n2.isConnected()); Try creating a 3-node cycle. assertInvalidConnect(n1, "value", n3); Test multi-input connections. Node n4 = net.create(multiAddType); assertValidConnect(n4, "values", n1); assertValidConnect(n4, "values", n2); assertValidConnect(n4, "values", n3); assertInvalidConnect(n4, "values", n4); assertInvalidConnect(n1, "value", n4); } private void assertValidConnect(Node inputNode, String inputParameterName, Node outputNode) { try { inputNode.getParameter(inputParameterName).connect(outputNode); } catch (ConnectionError e) { fail("Should not have thrown ConnectionError: " + e); } } private void assertInvalidConnect(Node inputNode, String inputParameterName, Node outputNode) { try { inputNode.getParameter(inputParameterName).connect(outputNode); fail("Should have thrown ConnectionError."); } catch (ConnectionError e) { } }} 
public void testCycles ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node n1 = net . create ( numberType ) ; Node n2 = net . create ( numberType ) ; Node n3 = net . create ( numberType ) ; assertFalse ( n2 . isConnected ( ) ) ; assertValidConnect ( n2 , " value " , n1 ) ; assertTrue ( n2 . isConnected ( ) ) ; assertTrue ( n2 . isInputConnectedTo ( n1 ) ) ; assertTrue ( n1 . isOutputConnectedTo ( n2 ) ) ; assertValidConnect ( n3 , " value " , n2 ) ; assertTrue ( n3 . isConnected ( ) ) ; assertTrue ( n3 . isInputConnectedTo ( n2 ) ) ; assertTrue ( n2 . isOutputConnectedTo ( n3 ) ) ; Try creating a 2-node cycle. assertInvalidConnect(n1, "value", n2); The connection didn't go through, so n1's input is not connected to n2. assertFalse(n1.isInputConnectedTo(n2)); However the output of n2 is still connected to n1. assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isConnected()); assertTrue(n2.isConnected()); Try creating a 3-node cycle. assertInvalidConnect(n1, "value", n3); Test multi-input connections. Node n4 = net.create(multiAddType); assertValidConnect(n4, "values", n1); assertValidConnect(n4, "values", n2); assertValidConnect(n4, "values", n3); assertInvalidConnect(n4, "values", n4); assertInvalidConnect(n1, "value", n4); } 
private void assertValidConnect ( Node inputNode , String inputParameterName , Node outputNode ) { try { inputNode . getParameter ( inputParameterName ) . connect ( outputNode ) ; 
private void assertInvalidConnect ( Node inputNode , String inputParameterName , Node outputNode ) { try { inputNode . getParameter ( inputParameterName ) . connect ( outputNode ) ; 
public void move ( double x , double y ) { this . x + = x ; this . y + = y ; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new GridType ( corevector ) ) ; corevector . addNodeType ( new MergeType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new PathNetworkType ( corevector ) ) ; corevector . addNodeType ( new WiggleType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; coreimage . addNodeType ( new ImageType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); g2.translate(getWidth() / 2.0, getHeight() / 2.0); if (getNetwork() == null) return; Object outputValue = getNetwork().getOutputValue(); if (outputValue instanceof Grob) { ((Grob) outputValue).draw(g2); } Draw handle if (handle != null && showHandle) { Create a canvas with a transparent background 
public void actionPerformed ( ActionEvent e ) { viewer . setShowHandle ( ( ( JCheckBox ) e . getSource ( ) ) . isSelected ( ) ) ; } 
public void extend ( List < Point > points ) { boolean first = true ; for ( Point pt : points ) { if ( first ) { 
public void resetContext ( boolean resetBackground ) { fillColor = new Color ( ) ; strokeColor = null ; strokeWidth = 1.0 ; if ( resetBackground ) canvas . setBackground ( new Color ( 1 , 1 , 1 ) ) ; path = null ; transform = new Transform ( ) ; transformStack = new ArrayList < Transform > ( ) ; fontName = " Helvetica " ; fontSize = 24 ; lineHeight = 1.2 ; align = Text . Align . CENTER ; } 
public boolean isDisplayPointNumbers ( ) { return displayPointNumbers ; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new GridType ( corevector ) ) ; corevector . addNodeType ( new MergeType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new SortType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new PathNetworkType ( corevector ) ) ; corevector . addNodeType ( new WiggleType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; coreimage . addNodeType ( new ImageType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public Handle createHandle ( Node node ) { DisplayPointsHandle handle = new DisplayPointsHandle ( node ) ; handle . setDisplayPointNumbers ( true ) ; return handle ; } 
public int compare ( Point p1 , Point p2 ) { double distP1 = Math . sqrt ( Math . pow ( tx - p1 . getX ( ) , 2 ) + Math . pow ( ty - p1 . getY ( ) , 2 ) ) ; double distP2 = Math . sqrt ( Math . pow ( tx - p2 . getX ( ) , 2 ) + Math . pow ( ty - p2 . getY ( ) , 2 ) ) ; if ( distP1 > distP2 ) { return 1 ; 
public static void main ( String [ ] args ) { ColorDialog cd = new ColorDialog ( null ) ; cd . setSize ( 800 , 400 ) ; cd . setLocationByPlatform ( true ) ; cd . setAlwaysOnTop ( true ) ; cd . setVisible ( true ) ; } 
private float clamp ( float v ) { return Math . max ( 0F , Math . min ( 1F , v ) ) ; } 
private void updateRGB ( ) { changeDisabled = true ; red = color . getRed ( ) / 255 F ; green = color . getGreen ( ) / 255 F ; blue = color . getBlue ( ) / 255 F ; redSlider . setValue ( ( int ) ( red * MAX_RANGE ) ) ; greenSlider . setValue ( ( int ) ( green * MAX_RANGE ) ) ; blueSlider . setValue ( ( int ) ( blue * MAX_RANGE ) ) ; redDraggable . setValue ( red ) ; greenDraggable . setValue ( green ) ; blueDraggable . setValue ( blue ) ; changeDisabled = false ; } 
private void updateHSB ( ) { changeDisabled = true ; float [ ] hsb = new float [ 3 ] ; Color . RGBtoHSB ( ( int ) ( red * 255 ) , ( int ) ( green * 255 ) , ( int ) ( blue * 255 ) , hsb ) ; hue = hsb [ 0 ] ; saturation = hsb [ 1 ] ; brightness = hsb [ 2 ] ; hueSlider . setValue ( ( int ) ( hue * MAX_RANGE ) ) ; saturationSlider . setValue ( ( int ) ( saturation * MAX_RANGE ) ) ; brightnessSlider . setValue ( ( int ) ( brightness * MAX_RANGE ) ) ; hueDraggable . setValue ( hue ) ; saturationDraggable . setValue ( saturation ) ; brightnessDraggable . setValue ( brightness ) ; changeDisabled = false ; } 
private void updateAlpha ( ) { changeDisabled = true ; alpha = color . getAlpha ( ) / 255 F ; alphaSlider . setValue ( ( int ) ( alpha * MAX_RANGE ) ) ; alphaDraggable . setValue ( alpha ) ; changeDisabled = false ; } 
protected void paintComponent ( Graphics g ) { g . setColor ( color ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; g . setColor ( Color . DARK_GRAY ) ; g . drawRect ( 0 , 0 , getWidth ( ) - 1 , getHeight ( ) - 1 ) ; } 
public void paintComponent ( Graphics g ) { paintDraggableNumber ( g ) ; } 
protected void paintDraggableNumber ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Rectangle r = getBounds ( ) ; int radius = r . height / 2 ; int halfradius = ( radius / 2 ) - 2 ; r . setRect ( 2 , 2 , r . width - 8 , r . height - 8 ) ; g2 . setColor ( new Color ( 215 , 215 , 215 ) ) ; g2 . fillRoundRect ( r . x , r . y , r . width , r . height , radius , radius ) ; g2 . setColor ( new Color ( 150 , 150 , 150 ) ) ; g2 . drawRoundRect ( r . x , r . y , r . width , r . height , radius , radius ) ; g2 . setColor ( new Color ( 187 , 187 , 187 ) ) ; g2 . drawLine ( r . x + halfradius , r . y + 1 , r . width - halfradius , r . y + 1 ) ; g2 . setColor ( new Color ( 223 , 223 , 223 ) ) ; g2 . drawLine ( r . x + halfradius , r . y + r . height - 1 , r . width - halfradius , r . y + r . height - 1 ) ; g2 . setColor ( new Color ( 0 , 0 , 0 ) ) ; g2 . setFont ( PlatformUtils . getSmallBoldFont ( ) ) ; paintCenteredString ( g2 , valueAsString ( ) , r . x + r . width / 2F , r . y + r . height / 2F ) ; TODO: The "-2" at the end is a hack. leftIcon.paintIcon(this, g, r.x + 2, r.y + r.height / 2 - 2); rightIcon.paintIcon(this, g, r.x + r.width - 8, r.y + r.height / 2 - 2); } 
public void actionPerformed ( ActionEvent e ) { dispose ( ) ; } 
public static void main ( String [ ] args ) { ColorDialog cd = new ColorDialog ( null ) ; cd . setSize ( 500 , 340 ) ; cd . setLocationByPlatform ( true ) ; cd . setAlwaysOnTop ( true ) ; cd . setVisible ( true ) ; } 
public void actionPerformed ( ActionEvent e ) { JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( this ) ; final JDialog d = new JDialog ( frame , " Choose Color " , true ) ; d . getContentPane ( ) . setLayout ( new BorderLayout ( 10 , 10 ) ) ; final ColorSwatch colorSwatch = new ColorSwatch(parameter.asColor()); Install a listener that listens for active node changed events, so we can dispose of the color dialog. TODO: Find a better way to do this. Maybe add color dialogs to the document itself? Component component = getParent(); while (!(component instanceof NodeBoxDocument)) { component = component.getParent(); } NodeBoxDocument doc = (NodeBoxDocument) component; doc.addDocumentFocusListener(this); if (colorDialog == null) { colorDialog = new ColorDialog((Frame) SwingUtilities.getWindowAncestor(this)); 
public void activeNodeChanged ( Node activeNode ) { if ( colorDialog ! = null ) { colorDialog . dispose ( ) ; 
protected void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; g . setColor ( parameter . asColor ( ) . getAwtColor ( ) ) ; g . fillRect ( r . x , r . y , r . width , r . height ) ; g . setColor ( Color . darkGray ) ; g . drawRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; } 
public boolean exportToFile ( File file ) { todo: file export only works on grobs. if (activeNetwork == null || activeNetwork.getRenderedNode() == null) return false; Object outputValue = activeNetwork.getRenderedNode().getOutputValue(); net.nodebox.graphics.Canvas canvas; if (outputValue instanceof net.nodebox.graphics.Canvas) { canvas = (net.nodebox.graphics.Canvas) outputValue; } else if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; Rect bounds = g.getBounds(); canvas = new net.nodebox.graphics.Canvas(bounds.getWidth(), bounds.getHeight()); We need to translate the canvas to compensate for the x/y value of the grob. double dx = bounds.getWidth() / 2 + bounds.getX(); double dy = bounds.getHeight() / 2 + bounds.getY(); canvas.translate(-dx, -dy); canvas.add(g); } else { throw new RuntimeException("This type of output cannot be exported " + outputValue); } canvas.save(file); return true; } 
public void draw ( Graphics2D g ) { double halfWidth = width / 2 ; double halfHeight = height / 2 ; double left = - halfWidth ; double top = - halfHeight ; g . setColor ( background . getAwtColor ( ) ) ; g . fillRect ( ( int ) left , ( int ) top , ( int ) width , ( int ) height ) ; Rectangle clip = g.getClipBounds(); int clipwidth = clip != null && width > clip.width ? clip.width : (int) height; int clipheight = clip != null && height > clip.height ? clip.height : (int) width; g.setClip(clip != null ? clip.x : 0, clip != null ? clip.y : 0, clipwidth, clipheight); super.draw(g); } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; corecanvas . addNodeType ( new CanvasType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new GridType ( corevector ) ) ; corevector . addNodeType ( new MergeType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new SortType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new PathNetworkType ( corevector ) ) ; corevector . addNodeType ( new WiggleType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; coreimage . addNodeType ( new ImageType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Canvas canvas = new Canvas ( node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; canvas.translate(-x, -y); canvas.setBackground(node.asColor("background")); List<Object> shapes = node.getValues("shapes"); for (Object shapeObject : shapes) { Grob shape = (Grob) shapeObject; shape = shape.clone(); shape.translate(x, y); canvas.add(shape); } node.setOutputValue(canvas); return true; } 
public Handle createHandle ( Node node ) { FourPointHandle handle = new FourPointHandle ( node ) ; return handle ; } 
public void testCloning ( ) { Color backgroundColor = new Color ( 0.1 , 0.2 , 0.3 ) ; Canvas c = new Canvas ( 200 , 300 ) ; c . setBackground ( backgroundColor ) ; Canvas c2 = c . clone ( ) ; assertEquals ( c , c2 ) ; assertEquals ( 200.0 , c2 . getWidth ( ) ) ; assertEquals ( 300.0 , c2 . getHeight ( ) ) ; assertEquals ( backgroundColor , c . getBackground ( ) ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . getParameter ( " template " ) . isConnected ( ) ? node . asGrob ( " template " ) : null ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) ; double sy = node . asFloat ( " sy " ) ; String expression = node . asString ( " expression " ) ; Expression expressionObject = new Expression ( expression , true ) ; ProcessingContext copyContext = ( ProcessingContext ) ctx . clone ( ) ; if ( expression = = null | | expression . trim ( ) . length ( ) = = 0 ) { if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } } else { Expression set. The expression allows you to modify field values on upstream nodes while copying. The expression has access to all the nodes by their name (e.g. rect1), and can set values on them. The CNUM local variable contains the copy number (starting from zero) Parameter pShape = node.getParameter("shape"); if (!pShape.isConnected()) throw new AssertionError("The shape is not connected."); List<Point> points; if (template == null) { points = new ArrayList<Point>(); points.add(new Point()); } else { points = pointsForGrob(template); } int copyIndex = 0; for (Point p : points) { Transform t = new Transform(); t.translate(p.getX(), p.getY()); for (int i = 0; i < copies; i++) { Node upstreamNode = pShape.getExplicitConnection().getOutputNode(); Node copiedUpstreamNode = upstreamNode.getNetwork().copyNodeWithUpstream(upstreamNode); These expressions can mutate the values; that's sort of the point. expressionObject.setParameter(copiedUpstreamNode.getOutputParameter()); The expression object changes the node values, so I don't care about the output. copyContext.put("CNUM", copyIndex); expressionObject.evaluate(copyContext); Now evaluate the output of the new upstream node. copiedUpstreamNode.update(ctx); if (copiedUpstreamNode.hasError()) throw new ProcessingError(node, "Upstream node contained errors:" + copiedUpstreamNode.getMessages().toString()); We do not need to clone the output shape. Grob outputShape = (Grob) copiedUpstreamNode.getOutputValue(); outputShape.prependTransform(t); outputGroup.add(outputShape); t.translate(tx, ty); t.rotate(r); t.scale(sx, sy); copyIndex++; } } } node.setOutputValue(outputGroup); return true; } 
public void mouseReleased ( MouseEvent e ) { if ( oldValue ! = value ) fireStateChanged ( ) ; 
public boolean hasMinimumValue ( ) { return minimumValue = = null ; } 
public void clearMinimumValue ( ) { this . minimumValue = null ; } 
public boolean hasMaximumValue ( ) { return maximumValue = = null ; } 
public void clearMaximumValue ( ) { this . maximumValue = null ; } 
public double clampValue ( double value ) { if ( minimumValue ! = null & & value < minimumValue ) value = minimumValue ; if ( maximumValue ! = null & & value > maximumValue ) value = maximumValue ; return value ; } 
public void characters ( char [ ] ch , int start , int length ) throws SAXException { switch ( state ) { case IN_KEY : 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . getParameter ( " template " ) . isConnected ( ) ? node . asGrob ( " template " ) : null ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) / 100.0 ; double sy = node . asFloat ( " sy " ) / 100.0 ; String expression = node . asString ( " expression " ) ; Expression expressionObject = new Expression ( expression , true ) ; ProcessingContext copyContext = ( ProcessingContext ) ctx . clone ( ) ; if ( expression = = null | | expression . trim ( ) . length ( ) = = 0 ) { if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } } else { Expression set. The expression allows you to modify field values on upstream nodes while copying. The expression has access to all the nodes by their name (e.g. rect1), and can set values on them. The CNUM local variable contains the copy number (starting from zero) Parameter pShape = node.getParameter("shape"); if (!pShape.isConnected()) throw new AssertionError("The shape is not connected."); List<Point> points; if (template == null) { points = new ArrayList<Point>(); points.add(new Point()); } else { points = pointsForGrob(template); } int copyIndex = 0; for (Point p : points) { Transform t = new Transform(); t.translate(p.getX(), p.getY()); for (int i = 0; i < copies; i++) { Node upstreamNode = pShape.getExplicitConnection().getOutputNode(); Node copiedUpstreamNode = upstreamNode.getNetwork().copyNodeWithUpstream(upstreamNode); These expressions can mutate the values; that's sort of the point. expressionObject.setParameter(copiedUpstreamNode.getOutputParameter()); The expression object changes the node values, so I don't care about the output. copyContext.put("CNUM", copyIndex); expressionObject.evaluate(copyContext); Now evaluate the output of the new upstream node. copiedUpstreamNode.update(ctx); if (copiedUpstreamNode.hasError()) throw new ProcessingError(node, "Upstream node contained errors:" + copiedUpstreamNode.getMessages().toString()); We do not need to clone the output shape. Grob outputShape = (Grob) copiedUpstreamNode.getOutputValue(); outputShape.prependTransform(t); outputGroup.add(outputShape); t.translate(tx, ty); t.rotate(r); t.scale(sx, sy); copyIndex++; } } } node.setOutputValue(outputGroup); return true; } 
public boolean process ( Node node , ProcessingContext ctx ) { Grob g = node . asGrob ( " shape " ) ; Grob outGrob = g . clone ( ) ; Transform = new Transform ( ) ; . translate ( node . asFloat ( " tx " ) , node . asFloat ( " ty " ) ) ; . rotate ( node . asFloat ( " r " ) ) ; . scale ( node . asFloat ( " sx " ) / 100.0 , node . asFloat ( " sy " ) / 100.0 ) ; outGrob . appendTransform ( ) ; node . setOutputValue ( outGrob ) ; return true ; } 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g = g . clone ( ) ; g . translate ( asFloat ( " tx " ) , asFloat ( " ty " ) ) ; g . rotate ( asFloat ( " r " ) ) ; g . scale ( asFloat ( " sx " ) / 100.0 , asFloat ( " sy " ) / 100.0 ) ; setOutputValue ( g ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; popupHandler = new PopupHandler ( ) ; addInputEventListener ( popupHandler ) ; } 
public void actionPerformed ( ActionEvent e ) { getCamera ( ) . setViewTransform ( new AffineTransform ( ) ) ; } 
public boolean quit ( ) { Because documents will disappear from the list once they are closed, make a copy of the list. java.util.List<NodeBoxDocument> documents = new ArrayList<NodeBoxDocument>(getDocuments()); for (NodeBoxDocument d : documents) { if (!d.shouldClose()) return false; } System.exit(0); return true; } 
public boolean readFromFile ( String path ) { NodeBoxDocument doc = createNewDocument ( ) ; doc . readFromFile ( path ) ; return true ; } 
private void librariesLoadedEvent ( ) { startupDialog . setVisible ( false ) ; if ( documents . isEmpty ( ) ) instance . createNewDocument ( ) ; 
private void updateTitle ( ) { String postfix = " " ; if ( ! PlatformUtils . onMac ( ) ) { todo: mac only code postfix = (documentChanged ? " *" : "") + " - PNA"; } else { getRootPane().putClientProperty("Window.documentModified", documentChanged); } if (documentFile == null) { setTitle("Untitled" + postfix); 
private void close ( ) { if ( shouldClose ( ) ) { renderThread.shutdown(); 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void networkDirty(Network network) { if (network != activeNetwork) return; markChanged(); SwingUtilities.invokeLater(new Runnable() { public void run() { activeNetwork.update(); } }); doRender(); } private void doRender() { renderThread.render(activeNetwork); } public void networkUpdated(Network network) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void networkDirty(Network network) { if (network != activeNetwork) return; markChanged(); SwingUtilities.invokeLater(new Runnable() { public void run() { activeNetwork.update(); } }); doRender(); } private void doRender() { renderThread.render(activeNetwork); } public void networkUpdated(Network network) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void networkDirty(Network network) { if (network != activeNetwork) return; markChanged(); SwingUtilities.invokeLater(new Runnable() { public void run() { activeNetwork.update(); } }); doRender(); } private void doRender() { renderThread.render(activeNetwork); } public void networkUpdated(Network network) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void networkDirty(Network network) { if (network != activeNetwork) return; markChanged(); SwingUtilities.invokeLater(new Runnable() { public void run() { activeNetwork.update(); } }); doRender(); } private void doRender() { renderThread.render(activeNetwork); } public void networkUpdated(Network network) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void windowDeactivated ( WindowEvent e ) { } Network events public void networkDirty(Network network) { if (network != activeNetwork) return; markChanged(); SwingUtilities.invokeLater(new Runnable() { public void run() { activeNetwork.update(); } }); doRender(); } private void doRender() { renderThread.render(activeNetwork); } public void networkUpdated(Network network) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
private void doRender ( ) { renderThread.render(activeNetwork); } public void networkUpdated(Network network) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void networkUpdated ( Network network ) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { close ( ) ; } 
public void actionPerformed ( ActionEvent e ) { } } public class ExportAction extends AbstractAction { public ExportAction ( ) { putValue ( NAME , " Export " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_E ) ) ; } public void actionPerformed ( ActionEvent e ) { export ( ) ; } } public class QuitAction extends AbstractAction { public QuitAction ( ) { putValue ( NAME , " Quit " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Q ) ) ; } public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . quit ( ) ; } } public class UndoAction extends AbstractAction { public UndoAction ( ) { putValue ( NAME , " Undo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . undo ( ) ; } catch ( CannotUndoException ex ) { logger . log ( Level . WARNING , " Unable to undo. " , ex ) ; } update ( ) ; redoAction . update ( ) ; } public void update ( ) { if ( undo . canUndo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getUndoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Undo " ) ; } } } public class RedoAction extends AbstractAction { public RedoAction ( ) { putValue ( NAME , " Redo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z , Event . SHIFT_MASK ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . redo ( ) ; } catch ( CannotRedoException ex ) { logger . log ( Level . WARNING , " Unable to redo. " , ex ) ; } update ( ) ; undoAction . update ( ) ; } public void update ( ) { if ( undo . canRedo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getRedoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Redo " ) ; } } } public class CutAction extends AbstractAction { public CutAction ( ) { putValue ( NAME , " Cut " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_X ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . quit ( ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Grob shape = node . asGrob ( " shape " ) . clone ( ) ; Color fillColor = node . asColor ( " fill " ) ; Color strokeColor = node . asColor ( " stroke " ) ; double strokeWidth = node . asFloat ( " strokewidth " ) ; changeColor ( shape , fillColor , strokeColor , strokeWidth ) ; node . setOutputValue ( shape ) ; return true ; } 
private void changeColor ( Grob grob , Color fillColor , Color strokeColor , double strokeWidth ) { if ( grob instanceof BezierPath ) { BezierPath p = ( BezierPath ) grob ; 
public static double clamp ( double v , double min , double max ) { return min > v ? min : max < v ? max : v ; } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; if ( fillColor ! = null & & fillColor . isVisible ( ) ) { g . setColor ( fillColor . getAwtColor ( ) ) ; g . fill ( getGeneralPath ( ) ) ; } if ( strokeWidth > 0 & & strokeColor ! = null & & strokeColor . isVisible ( ) ) { try { g . setColor ( strokeColor . getAwtColor ( ) ) ; g . setStroke ( new BasicStroke ( ( float ) strokeWidth ) ) ; g . draw ( getGeneralPath ( ) ) ; } catch ( Exception e ) { Invalid transformations can cause the pen to not display. Catch the exception and throw it away. The path would be too small to be displayed anyway. } } restoreTransform(g); } 
public static double random ( long seed , double . . . minmax ) { switch ( minmax . length ) { case 0 : 
public static double random ( long seed ) { randomGenerator . setSeed ( seed * 100000000 ) ; return randomGenerator . nextDouble ( ) ; } 
public static double random ( long seed , double max ) { return random ( seed ) * max ; } 
public static double random ( long seed , double min , double max ) { return min + random ( seed ) * ( max - min ) ; } 
public static Color color ( double . . . values ) { switch ( values . length ) { case 0 : 
public static Color color ( double gray ) { return new Color ( gray , gray , gray ) ; } 
public static Color color ( double gray , double alpha ) { return new Color ( gray , gray , gray , alpha ) ; } 
public static Color color ( double red , double green , double blue ) { return new Color ( red , green , blue ) ; } 
public static Color color ( double red , double green , double blue , double alpha ) { return new Color ( red , green , blue , alpha ) ; } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; You can only position an image using an affine transformation. We use the transformation to translate the image to the specified position, and scale it according to the given width and height. Transform imageTrans = new Transform(); Move to the image position. Convert x, y, which are centered coordinates, to "real" coordinates. double factor = getScaleFactor(); double finalWidth = getWidth() * factor; double finalHeight = getHeight() * factor; imageTrans.translate(x - finalWidth / 2, y - finalHeight / 2); Scaling only applies to image that have their desired width and/or height set. However, getScaleFactor return 1 if height/width are not set, in effect negating the effect of the scale. imageTrans.scale(getScaleFactor()); double a = MathUtils.clamp(alpha); Composite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) a); Composite oldComposite = g.getComposite(); g.setComposite(composite); g.drawImage(awtImage, imageTrans.getAffineTransform(), null); g.setComposite(oldComposite); restoreTransform(g); } 
private void createNetwork ( Attributes attributes ) throws SAXException { Network newNetwork ; try { newNetwork = ( Network ) lookupNode ( attributes ) ; } catch ( ClassCastException e ) { throw new SAXException ( " Node " + attributes . getValue ( " type " ) + " is not a network. " ) ; } if ( currentNetwork = = null ) { rootNetwork = newNetwork ; } else { currentNetwork . add ( newNetwork ) ; } currentNode = currentNetwork = newNetwork ; parseNodeFlags ( currentNetwork , attributes ) ; expressionMap = new HashMap < Parameter , String > ( ) ; } 
private void setTemporaryExpression ( String parameterName , String expression ) throws SAXException { Parameter parameter = currentNode . getParameter ( parameterName ) ; if ( parameter = = null ) throw new SAXException ( " Node " + currentNode . getName ( ) + " has no parameter ' " + parameterName + " ' " ) ; expressionMap . put ( parameter , expression ) ; } 
public void testCopyStamping ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; Node copy = net . create ( manager . getNodeType ( " corevector.copy " ) ) ; copy . getParameter ( " shape " ) . connect ( rect ) ; copy . set ( " copies " , 10 ) ; copy . set ( " expression " , " rect1.x = CNUM " ) ; copy . update ( ) ; Grob g = ( Grob ) copy . getOutputValue ( ) ; assertEquals ( new Rect ( - 50 , - 50 , 109 , 100 ) , g . getBounds ( ) ) ; } 
private void addBuiltinLibraries ( ) { CoreNodeTypeLibrary corecanvas = new CoreNodeTypeLibrary ( " corecanvas " , new Version ( 1 , 0 , 0 ) ) ; corecanvas . addNodeType ( new CanvasNetworkType ( corecanvas ) ) ; corecanvas . addNodeType ( new CanvasType ( corecanvas ) ) ; addLibrary ( corecanvas ) ; CoreNodeTypeLibrary corevector = new CoreNodeTypeLibrary ( " corevector " , new Version ( 1 , 0 , 0 ) ) ; corevector . addNodeType ( new ColorType ( corevector ) ) ; corevector . addNodeType ( new CopyType ( corevector ) ) ; corevector . addNodeType ( new EllipseType ( corevector ) ) ; corevector . addNodeType ( new GridType ( corevector ) ) ; corevector . addNodeType ( new MergeType ( corevector ) ) ; corevector . addNodeType ( new RectType ( corevector ) ) ; corevector . addNodeType ( new ResampleType ( corevector ) ) ; corevector . addNodeType ( new ScatterType ( corevector ) ) ; corevector . addNodeType ( new SortType ( corevector ) ) ; corevector . addNodeType ( new StarType ( corevector ) ) ; corevector . addNodeType ( new TextType ( corevector ) ) ; corevector . addNodeType ( new TextPathType ( corevector ) ) ; corevector . addNodeType ( new TransformType ( corevector ) ) ; corevector . addNodeType ( new PathNetworkType ( corevector ) ) ; corevector . addNodeType ( new WiggleType ( corevector ) ) ; addLibrary ( corevector ) ; CoreNodeTypeLibrary coreimage = new CoreNodeTypeLibrary ( " coreimage " , new Version ( 1 , 0 , 0 ) ) ; coreimage . addNodeType ( new ImageNetworkType ( coreimage ) ) ; coreimage . addNodeType ( new ImageType ( coreimage ) ) ; addLibrary ( coreimage ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { BezierPath p = new BezierPath ( ) ; p . setFillColor ( node . asColor ( " fill " ) ) ; p . setStrokeColor ( node . asColor ( " stroke " ) ) ; p . setStrokeWidth ( node . asFloat ( " strokewidth " ) ) ; double startx = node . asFloat ( " x " ) ; double starty = node . asFloat ( " y " ) ; double outer = node . asFloat ( " outer " ) ; double inner = node . asFloat ( " inner " ) ; int points = node . asInt ( " points " ) ; p . moveto ( startx , starty + outer ) ; double angle , x , y , radius ; for ( int i = 1 ; i < points * 2 ; i + + ) { angle = i * Math . PI / ( double ) points ; x = Math . sin ( angle ) ; y = Math . cos ( angle ) ; radius = i % 2 = = 1 ? inner : outer ; x = startx + radius * x ; y = starty + radius * y ; p . lineto ( x , y ) ; } p . close ( ) ; node . setOutputValue ( p ) ; return true ; } 
public Handle createHandle ( Node node ) { return new FourPointHandle ( node , " x " , " y " , " outer " , " inner " ) ; } 
public void valueChanged ( Parameter source , Object newValue ) { if ( value ! = null & & value . equals ( newValue ) ) return ; setValueForControl ( newValue ) ; } 
public void networkUpdated ( Network network ) { if ( ! networkError & & ! network . hasError ( ) ) return ; networkError = network . hasError ( ) ; repaint ( ) ; } 
public boolean update ( ProcessingContext ctx ) { Node output is not cached, so we need to regenerate this node every time. This actually sounds worse than it is, because most of our time would be spent in cloning node data anyway, spoling any advantages caching might have. The idea is to make caching optional, but now, there just is no caching. if (!dirty) return true; for (Parameter p : parameters.values()) { if (ctx.isUpdating(p) || ctx.hasProcessed(p)) continue; ctx.beginUpdating(p); try { p.update(ctx); } catch (Exception e) { messages.add(new Message(MessageLevel.ERROR, p.getName() + ": " + e.getMessage())); dirty = false; return false; } ctx.endUpdating(p); } Only after all parameters have been processed should we process the node. This happens if parameters depend on eachother, which causes recursion. for (Parameter p : parameters.values()) { if (!ctx.hasProcessed(p)) return false; } messages.clear(); boolean success = process(ctx); dirty = false; return success; } 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Canvas c = new Canvas ( asFloat ( " width " ) , asFloat ( " height " ) ) ; Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; c . add ( g ) ; setOutputValue ( c ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Canvas canvas = new Canvas ( node . asFloat ( " width " ) , node . asFloat ( " height " ) ) ; double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; canvas.translate(-x, -y); canvas.setBackground(node.asColor("background")); List<Object> shapes = node.getValues("shapes"); for (Object shapeObject : shapes) { Grob shape = (Grob) shapeObject; shape.translate(x, y); canvas.add(shape); } node.setOutputValue(canvas); return true; } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; List < Object > shapes = node . getValues ( " shapes " ) ; for ( Object shapeObject : shapes ) { Grob shape = ( Grob ) shapeObject ; outputGroup . add ( shape ) ; } node . setOutputValue ( outputGroup ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Grob g = node . asGrob ( " shape " ) ; Grob outGrob = g ; Transform = new Transform ( ) ; . translate ( node . asFloat ( " tx " ) , node . asFloat ( " ty " ) ) ; . rotate ( node . asFloat ( " r " ) ) ; . scale ( node . asFloat ( " sx " ) / 100.0 , node . asFloat ( " sy " ) / 100.0 ) ; outGrob . appendTransform ( ) ; node . setOutputValue ( outGrob ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { Grob shape = node . asGrob ( " shape " ) ; Color fillColor = node . asColor ( " fill " ) ; Color strokeColor = node . asColor ( " stroke " ) ; double strokeWidth = node . asFloat ( " strokewidth " ) ; changeColor ( shape , fillColor , strokeColor , strokeWidth ) ; node . setOutputValue ( shape ) ; return true ; } 
public boolean process ( ProcessingContext ctx ) { boolean success = updateRenderedNode ( ctx ) ; if ( success ) { Object outputValue = getRenderedNode ( ) . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; g . translate ( asFloat ( " tx " ) , asFloat ( " ty " ) ) ; g . rotate ( asFloat ( " r " ) ) ; g . scale ( asFloat ( " sx " ) / 100.0 , asFloat ( " sy " ) / 100.0 ) ; setOutputValue ( g ) ; } else { throw new AssertionError ( getAbsolutePath ( ) + " : output of rendered node is not Grob, but " + outputValue ) ; } } else { getOutputParameter ( ) . revertToDefault ( ) ; } return success ; } 
public boolean isConnectedTo ( Parameter inputParameter ) { Output parameters can only be connected to input parameters. if (inputParameter instanceof OutputParameter) return false; return getNetwork().isConnectedTo(inputParameter, this); } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; manager = new NodeTypeLibraryManager ( ) ; testLibrary = new TestLibrary ( ) ; manager . addLibrary ( testLibrary ) ; numberType = manager . getNodeType ( " test.number " ) ; negateType = manager . getNodeType ( " test.negate " ) ; addType = manager . getNodeType ( " test.add " ) ; multiplyType = manager . getNodeType ( " test.multiply " ) ; multiAddType = manager . getNodeType ( " test.multiAdd " ) ; testNetworkType = manager . getNodeType ( " test.testnet " ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( 12 ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( - node . asInt ( " value " ) ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( node . asInt ( " value " ) + 10 ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( node . asInt ( " value " ) * 2 ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( node . asFloat ( " value " ) / 2.0 ) ; return true ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( node . asString ( " value " ) . toUpperCase ( ) ) ; return true ; } 
public void testMigrate ( ) { NodeType alphaType = new AlphaType ( ) ; NodeType betaType = new BetaType ( ) ; NodeType gammaType = new GammaType ( ) ; NodeType deltaType = new DeltaType ( ) ; NodeType epsilonType = new EpsilonType ( ) ; NodeType zetaType = new ZetaType ( ) ; Create an alpha type node. This type has no parameters. Node n = alphaType.createNode(); n.update(); assertEquals(12, n.getOutputValue()); Change the node type to beta. This type has one parameter; the node should get the default parameter value. n.setNodeType(betaType); Check if the parameter is there and has the correct value. assertEquals(ParameterType.Type.INT, n.getParameter("value").getType()); assertEquals(13, n.asInt("value")); n.update(); assertEquals(-13, n.getOutputValue()); Change the node type to gamma. This type has the same parameter but with a different default value. Changing the type should not change the value. n.setNodeType(gammaType); The default value refers to the new parameter type assertEquals(99, n.getParameter("value").getParameterType().getDefaultValue()); The value of the parameter is unchanged. assertEquals(13, n.asInt("value")); n.update(); assertEquals(23, n.getOutputValue()); Set value to negative in preparation of bounding check. n.set("value", -100); Change the node type to delta, which has hard bounding set. n.setNodeType(deltaType); Check that the value is clamped to bounds. assertEquals(3, n.asInt("value")); n.update(); assertEquals(6, n.getOutputValue()); Change the node type to epsilon, which has the same parameters of a different type. n.setNodeType(epsilonType); assertEquals(ParameterType.Type.FLOAT, n.getOutputParameter().getType()); Since the output type has changed and the node has not yet updated, the output gets the default value. assertEquals(0.0, n.getOutputValue()); assertEquals(ParameterType.Type.FLOAT, n.getParameter("value").getType()); assertEquals(3.0, n.asFloat("value")); n.update(); assertEquals(1.5, n.getOutputValue()); Change the node type to zeta, where the value parameter is of type string. n.setNodeType(zetaType); Again, the output is set to default value of the string type. assertEquals("", n.getOutputValue()); assertEquals("3.0", n.asString("value")); n.set("value", "no shouting"); n.update(); assertEquals("NO SHOUTING", n.getOutputValue()); Let's try to convert back to epsilon, which has a float value. Of course, the value "no shouting" does not convert to a floating-point value. The value will be reset to its default. n.setNodeType(epsilonType); assertEquals(0.0, n.asFloat("value")); } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.ellipse")); ellipse1.setRendered(); vector1.update(); assertTrue(vector1.getOutputValue() == ellipse1.getOutputValue()); } public void testCycles() { Network net = (Network) testNetworkType.createNode(); Node n1 = net.create(numberType); Node n2 = net.create(numberType); Node n3 = net.create(numberType); assertFalse(n2.isConnected()); assertValidConnect(n2, "value", n1); assertTrue(n2.isConnected()); assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isOutputConnectedTo(n2)); assertValidConnect(n3, "value", n2); assertTrue(n3.isConnected()); assertTrue(n3.isInputConnectedTo(n2)); assertTrue(n2.isOutputConnectedTo(n3)); Try creating a 2-node cycle. assertInvalidConnect(n1, "value", n2); The connection didn't go through, so n1's input is not connected to n2. assertFalse(n1.isInputConnectedTo(n2)); However the output of n2 is still connected to n1. assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isConnected()); assertTrue(n2.isConnected()); Try creating a 3-node cycle. assertInvalidConnect(n1, "value", n3); Test multi-input connections. Node n4 = net.create(multiAddType); assertValidConnect(n4, "values", n1); assertValidConnect(n4, "values", n2); assertValidConnect(n4, "values", n3); assertInvalidConnect(n4, "values", n4); assertInvalidConnect(n1, "value", n4); } private void assertValidConnect(Node inputNode, String inputParameterName, Node outputNode) { try { inputNode.getParameter(inputParameterName).connect(outputNode); } catch (ConnectionError e) { fail("Should not have thrown ConnectionError: " + e); } } private void assertInvalidConnect(Node inputNode, String inputParameterName, Node outputNode) { try { inputNode.getParameter(inputParameterName).connect(outputNode); fail("Should have thrown ConnectionError."); } catch (ConnectionError e) { } }} 
public void testCopy ( ) { Network vector1 = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node ellipse1 = vector1 . create ( manager . getNodeType ( " corevector.ellipse " ) ) ; ellipse1 . setRendered ( ) ; vector1 . update ( ) ; assertTrue ( vector1 . getOutputValue ( ) = = ellipse1 . getOutputValue ( ) ) ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( node . asInt ( " value " ) + node . asInt ( " value2 " ) ) ; return true ; } 
public void testMigrateAddParameter ( ) { NodeType alphaType = new AlphaType ( ) ; NodeType betaType = new BetaType ( ) ; Create an alpha type node. This type has no parameters. Node n = alphaType.createNode(); n.update(); assertEquals(12, n.getOutputValue()); Change the node type to beta. This type has one parameter; the node should get the default parameter value. n.setNodeType(betaType); Check if the parameter is there and has the correct value. assertEquals(ParameterType.Type.INT, n.getParameter("value").getType()); assertEquals(13, n.asInt("value")); n.update(); assertEquals(-13, n.getOutputValue()); } 
public void testMigrateDifferentDefaultValue ( ) { NodeType betaType = new BetaType ( ) ; NodeType gammaType = new GammaType ( ) ; Create a beta type node. This type has one parameter, value. Node n = betaType.createNode(); n.update(); assertEquals(-13, n.getOutputValue()); Change the node type to gamma. This type has the same parameter but with a different default value. Changing the type should not change the value. n.setNodeType(gammaType); The default value refers to the new parameter type assertEquals(99, n.getParameter("value").getParameterType().getDefaultValue()); The value of the parameter is unchanged. assertEquals(13, n.asInt("value")); n.update(); assertEquals(23, n.getOutputValue()); } 
public void testMigrateBounding ( ) { NodeType betaType = new BetaType ( ) ; NodeType deltaType = new DeltaType ( ) ; Create a beta type node. This type has one parameter, value. Node n = betaType.createNode(); Set value to negative in preparation of bounding check. n.set("value", -100); n.update(); assertEquals(100, n.getOutputValue()); Change the node type to delta, which has hard bounding set. n.setNodeType(deltaType); Check that the value is clamped to bounds. assertEquals(3, n.asInt("value")); n.update(); assertEquals(6, n.getOutputValue()); } 
public void testMigrateCompatibleType ( ) { NodeType betaType = new BetaType ( ) ; NodeType epsilonType = new EpsilonType ( ) ; Create a beta type node. This type has one parameter, value. Node n = betaType.createNode(); Change the node type to epsilon, which has the same parameters of a different type. n.setNodeType(epsilonType); assertEquals(ParameterType.Type.FLOAT, n.getOutputParameter().getType()); Since the output type has changed and the node has not yet updated, the output gets the default value. assertEquals(0.0, n.getOutputValue()); assertEquals(ParameterType.Type.FLOAT, n.getParameter("value").getType()); assertEquals(13.0, n.asFloat("value")); n.update(); assertEquals(6.5, n.getOutputValue()); } 
public void testMigrateIncompatibleType ( ) { NodeType betaType = new BetaType ( ) ; NodeType zetaType = new ZetaType ( ) ; Create a beta type node. This type has one parameter, value. Node n = betaType.createNode(); n.set("value", 101); n.update(); assertEquals(-101, n.getOutputValue()); Change the node type to zeta, where the value parameter is of type string. n.setNodeType(zetaType); Again, the output is set to default value of the string type. assertEquals("", n.getOutputValue()); assertEquals("101", n.asString("value")); n.set("value", "no shouting"); n.update(); assertEquals("NO SHOUTING", n.getOutputValue()); Let's try to convert back to epsilon, which has an integer value. Of course, the value "no shouting" does not convert to an integer value. The value will be reset to its default. n.setNodeType(betaType); assertEquals(13, n.asInt("value")); 
public void testMigrateRemoveParameters ( ) { Type with two int parameters, value and value2 NodeType etaType = new EtaType(); Type with one int parameter, value NodeType betaType = new BetaType(); Node n = etaType.createNode(); assertTrue(n.hasParameter("value")); assertTrue(n.hasParameter("value2")); n.setNodeType(betaType); assertTrue(n.hasParameter("value")); assertFalse(n.hasParameter("value2")); } 
public void disconnect ( ) { inputParameter . getNetwork ( ) . disconnect ( outputParameter , inputParameter , type ) ; } 
public void disconnect ( ) { for ( Parameter outputParameter : outputParameters ) { getInputParameter ( ) . getNetwork ( ) . disconnect ( outputParameter , getInputParameter ( ) , getType ( ) ) ; 
public boolean disconnect ( ) { if ( getNetwork ( ) = = null ) return false ; return getNetwork ( ) . disconnect ( this ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; manager = new NodeTypeLibraryManager ( ) ; testLibrary = new TestLibrary ( ) ; manager . addLibrary ( testLibrary ) ; numberType = manager . getNodeType ( " test.number " ) ; negateType = manager . getNodeType ( " test.negate " ) ; addType = manager . getNodeType ( " test.add " ) ; multiplyType = manager . getNodeType ( " test.multiply " ) ; multiAddType = manager . getNodeType ( " test.multiAdd " ) ; floatNegateType = manager . getNodeType ( " test.floatNegate " ) ; testNetworkType = manager . getNodeType ( " test.testnet " ) ; } 
public void testMigrateConnected ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; NodeType betaType = new BetaType ( ) ; NodeType gammaType = new GammaType ( ) ; Node outputNode = net . create ( numberType ) ; Node = net . create ( betaType ) ; outputNode . set ( " value " , 42 ) ; . getParameter ( " value " ) . connect ( outputNode ) ; assertTrue ( . isConnected ( ) ) ; assertTrue ( outputNode . isConnected ( ) ) ; assertTrue ( . isInputConnectedTo ( outputNode ) ) ; . update ( ) ; assertEquals ( - 42 , . getOutputValue ( ) ) ; . setNodeType ( gammaType ) ; assertTrue ( . isInputConnectedTo ( outputNode ) ) ; assertTrue ( . getParameter ( " value " ) . isConnectedTo ( outputNode ) ) ; . update ( ) ; assertEquals ( 52 , . getOutputValue ( ) ) ; } 
public void testMigrateConnectedParameterRemoved ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; NodeType betaType = new BetaType ( ) ; NodeType alphaType = new AlphaType ( ) ; Node outputNode = net . create ( numberType ) ; Node = net . create ( betaType ) ; outputNode . set ( " value " , 42 ) ; . getParameter ( " value " ) . connect ( outputNode ) ; . update ( ) ; assertEquals ( - 42 , . getOutputValue ( ) ) ; . setNodeType ( alphaType ) ; assertFalse ( . isConnected ( ) ) ; assertFalse ( outputNode . isConnected ( ) ) ; assertFalse ( . isInputConnectedTo ( outputNode ) ) ; } 
public void testMigrateConnectedIncompatibleParameter ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; NodeType betaType = new BetaType ( ) ; NodeType epsilonType = new EpsilonType ( ) ; Node outputNode = net . create ( numberType ) ; Node = net . create ( betaType ) ; outputNode . set ( " value " , 42 ) ; . getParameter ( " value " ) . connect ( outputNode ) ; . update ( ) ; assertEquals ( - 42 , . getOutputValue ( ) ) ; . setNodeType ( epsilonType ) ; assertFalse ( . isConnected ( ) ) ; assertFalse ( outputNode . isConnected ( ) ) ; assertFalse ( . isInputConnectedTo ( outputNode ) ) ; . update ( ) ; assertEquals ( 0.0 , . getOutputValue ( ) ) ; } 
public void testMigrateOutputConnected ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; NodeType gammaType = new GammaType ( ) ; NodeType epsilonType = new EpsilonType ( ) ; Node = net . create ( gammaType ) ; Node inputNode = net . create ( negateType ) ; Node inputNode2 = net . create ( addType ) ; inputNode . getParameter ( " value " ) . connect ( ) ; inputNode . setRendered ( ) ; inputNode2 . getParameter ( " v1 " ) . connect ( ) ; net . update ( ) ; -109 = 99 (default value of gamma type) + 10 (processing of gamma type) turned negative (processing of input node). assertEquals(-109, net.getOutputValue()); Migrate output node to incompatible type. n.setNodeType(epsilonType); assertFalse(n.isConnected()); assertFalse(inputNode.isConnected()); assertFalse(inputNode.isInputConnectedTo(n)); assertFalse(inputNode2.isConnected()); assertFalse(inputNode2.isInputConnectedTo(n)); net.update(); Default value of negate assertEquals(0, net.getOutputValue()); } 
public abstract int process ( int value ) ; } public static abstract class Binary extends NodeType { public Binary ( NodeTypeLibrary library , String name ) { super ( library , name , ParameterType . Type . INT ) ; addParameterType ( " v1 " , ParameterType . Type . INT ) ; addParameterType ( " v2 " , ParameterType . Type . INT ) ; } public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( process ( node . asInt ( " v1 " ) , node . asInt ( " v2 " ) ) ) ; return true ; } public abstract int process ( int v1 , int v2 ) ; } public static abstract class Multi extends NodeType { public Multi ( NodeTypeLibrary library , String name ) { super ( library , name , ParameterType . Type . INT ) ; ParameterType ptValues = addParameterType ( " values " , ParameterType . Type . INT ) ; ptValues . setCardinality ( ParameterType . Cardinality . MULTIPLE ) ; } public boolean process ( Node node , ProcessingContext ctx ) { List < Object > objectValues = node . getValues ( " values " ) ; int [ ] values = new int [ objectValues . size ( ) ] ; for ( int i = 0 ; i < objectValues . size ( ) ; i + + ) { values [ i ] = ( Integer ) objectValues . get ( i ) ; } node . setOutputValue ( process ( values ) ) ; return true ; } public abstract int process ( int [ ] values ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return - value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class MultiAdd extends Multi { public MultiAdd ( NodeTypeLibrary library ) { super ( library , " multiAdd " ) ; } public int process ( int [ ] values ) { int sum = 0 ; for ( int v : values ) sum + = v ; return sum ; } } public static class FloatNegate extends NodeType { public FloatNegate ( NodeTypeLibrary library ) { super ( library , " floatNegate " , ParameterType . Type . FLOAT ) ; addParameterType ( " value " , ParameterType . Type . FLOAT ) ; } public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( - node . asFloat ( " value " ) ) ; return true ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , new Version ( 1 , 0 , 0 ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new MultiAdd ( this ) ) ; addNodeType ( new FloatNegate ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public abstract int process ( int v1 , int v2 ) ; } public static abstract class Multi extends NodeType { public Multi ( NodeTypeLibrary library , String name ) { super ( library , name , ParameterType . Type . INT ) ; ParameterType ptValues = addParameterType ( " values " , ParameterType . Type . INT ) ; ptValues . setCardinality ( ParameterType . Cardinality . MULTIPLE ) ; } public boolean process ( Node node , ProcessingContext ctx ) { List < Object > objectValues = node . getValues ( " values " ) ; int [ ] values = new int [ objectValues . size ( ) ] ; for ( int i = 0 ; i < objectValues . size ( ) ; i + + ) { values [ i ] = ( Integer ) objectValues . get ( i ) ; } node . setOutputValue ( process ( values ) ) ; return true ; } public abstract int process ( int [ ] values ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return - value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class MultiAdd extends Multi { public MultiAdd ( NodeTypeLibrary library ) { super ( library , " multiAdd " ) ; } public int process ( int [ ] values ) { int sum = 0 ; for ( int v : values ) sum + = v ; return sum ; } } public static class FloatNegate extends NodeType { public FloatNegate ( NodeTypeLibrary library ) { super ( library , " floatNegate " , ParameterType . Type . FLOAT ) ; addParameterType ( " value " , ParameterType . Type . FLOAT ) ; } public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( - node . asFloat ( " value " ) ) ; return true ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , new Version ( 1 , 0 , 0 ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new MultiAdd ( this ) ) ; addNodeType ( new FloatNegate ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public abstract int process ( int [ ] values ) ; } public static class Number extends Unary { public Number ( NodeTypeLibrary library ) { super ( library , " number " ) ; } public int process ( int value ) { return value ; } } public static class Negate extends Unary { public Negate ( NodeTypeLibrary library ) { super ( library , " negate " ) ; } public int process ( int value ) { return - value ; } } public static class Add extends Binary { public Add ( NodeTypeLibrary library ) { super ( library , " add " ) ; } public int process ( int v1 , int v2 ) { return v1 + v2 ; } } public static class Multiply extends Binary { public Multiply ( NodeTypeLibrary library ) { super ( library , " multiply " ) ; addParameterType ( " somestring " , ParameterType . Type . STRING ) ; } public int process ( int v1 , int v2 ) { return v1 * v2 ; } } public static class MultiAdd extends Multi { public MultiAdd ( NodeTypeLibrary library ) { super ( library , " multiAdd " ) ; } public int process ( int [ ] values ) { int sum = 0 ; for ( int v : values ) sum + = v ; return sum ; } } public static class FloatNegate extends NodeType { public FloatNegate ( NodeTypeLibrary library ) { super ( library , " floatNegate " , ParameterType . Type . FLOAT ) ; addParameterType ( " value " , ParameterType . Type . FLOAT ) ; } public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( - node . asFloat ( " value " ) ) ; return true ; } } public static class TestNetworkType extends NodeType { public TestNetworkType ( NodeTypeLibrary library ) { super ( library , " testnet " , ParameterType . Type . INT ) ; } @Override public boolean process ( Node node , ProcessingContext ctx ) { throw new RuntimeException ( " Image network is not implemented yet. " ) ; } @Override public Node createNode ( ) { return new Network ( this ) ; } } public TestLibrary ( ) { super ( " test " , new Version ( 1 , 0 , 0 ) ) ; addNodeType ( new Number ( this ) ) ; addNodeType ( new Negate ( this ) ) ; addNodeType ( new Add ( this ) ) ; addNodeType ( new Multiply ( this ) ) ; addNodeType ( new MultiAdd ( this ) ) ; addNodeType ( new FloatNegate ( this ) ) ; addNodeType ( new TestNetworkType ( this ) ) ; } @Override public boolean isLoaded ( ) { return true ; } } 
public int process ( int value ) { return - value ; } 
public boolean process ( Node node , ProcessingContext ctx ) { node . setOutputValue ( - node . asFloat ( " value " ) ) ; return true ; } 
public boolean accept ( File f ) { return f . isDirectory ( ) | | accept ( null , f . getName ( ) ) ; } 
public boolean accept ( File f , String s ) { String extension = FileUtils . getExtension ( s ) ; if ( extension ! = null ) { for ( String extension1 : extensions ) { if ( extension1 . equals ( " * " ) | | extension1 . equalsIgnoreCase ( extension ) ) { return true ; } } } return false ; } 
public static File createTemporaryDirectory ( String prefix ) { File tempDir = null ; try { tempDir = File . createTempFile ( prefix , " " ) ; } catch ( IOException e ) { throw new RuntimeException ( " Could not create temporary file " + prefix ) ; } boolean success = tempDir . delete ( ) ; if ( ! success ) throw new RuntimeException ( " Could not delete temporary file " + tempDir ) ; success = tempDir . mkdir ( ) ; if ( ! success ) throw new RuntimeException ( " Could not create temporary directory " + tempDir ) ; return tempDir ; } 
public static boolean deleteDirectory ( File directory ) { if ( directory . exists ( ) ) { File [ ] files = directory . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { deleteDirectory ( file ) ; } else { noinspection ResultOfMethodCallIgnored file.delete(); } } } return (directory.delete()); } 
public void migrateType ( NodeType newNodeType ) { for ( WeakReference < Node > ref : instanceRefs ) { Node = ref . get ( ) ; if ( ! = null ) . setNodeType ( newNodeType ) ; } Add all my instance refs to the new type's instance refs. newNodeType.instanceRefs.addAll(instanceRefs); } 
public boolean hasNodeType ( String nodeName ) { if ( ! isLoaded ( ) ) load ( ) ; return types . containsKey ( nodeName ) ; } 
public boolean hasLibrary ( String libraryName ) { if ( ! lookedForLibraries ) lookForLibraries ( ) ; return libraryMap . containsKey ( libraryName ) ; } 
public NodeTypeLibrary createPythonLibrary ( String libraryName ) { TODO: Make sure library name follows naming conventions. if (searchPaths.size() != 1) { throw new AssertionError("Only one search path is supported, otherwise we cannot deduce where the library should go."); } The directory the library will be created in is the first on the list of search paths. String libraryParentDirectory = searchPaths.get(0).getAbsolutePath(); String libraryDirectory = libraryParentDirectory + PlatformUtils.SEP + libraryName; boolean createdDirectory = new File(libraryDirectory).mkdir(); if (!createdDirectory) throw new RuntimeException("Could not create library directory \"" + libraryDirectory + "\"."); File ntlFile = new File(libraryDirectory + PlatformUtils.SEP + "types.ntl"); String ntlContents = "<library name=\"" + libraryName + "\" formatVersion=\"0.8\" type=\"python\" module=\"" + libraryName + "\">" + " <type name=\"test\" outputType=\"grob_path\" method=\"test\">" + " <description>Test method.</description>" + " <parameter type=\"float\" name=\"x\"/>" + " <parameter type=\"float\" name=\"y\"/>" + " </type>" + "</library>"; File moduleFile = new File(libraryDirectory + PlatformUtils.SEP + libraryName + ".py"); String moduleContents = "from net.nodebox import graphics" + "def test(x, y):" + " p = graphics.BezierPath()" + " p.ellipse(x, y, 50, 50)" + " return p"; FileUtils.writeFile(ntlFile, ntlContents); FileUtils.writeFile(moduleFile, moduleContents); NodeTypeLibrary library = pathToLibrary(libraryParentDirectory, libraryName); addLibrary(library); return library; } 
protected void addNodeType ( NodeType nodeType ) { String nodeTypeName = nodeType . getName ( ) ; if ( hasNodeType ( nodeTypeName ) ) { NodeType oldNodeType = getNodeType ( nodeTypeName ) ; oldNodeType . migrateType ( nodeType ) ; } super . addNodeType ( nodeType ) ; } 
public void load ( ) { if ( isLoaded ( ) ) return ; Set the loaded flag here, because addNodeType checks hasNodeType, which lazy-loads the library, causing infinite recursion. loaded = true; File name File file = getLibraryDescriptionFile(); Load the document FileInputStream fis; try { fis = new FileInputStream(file); } catch (FileNotFoundException e) { logger.log(Level.SEVERE, "Could not read file " + file, e); throw new RuntimeException("Could not read file " + file, e); } InputSource source = new InputSource(fis); Setup the parser SAXParserFactory factory = SAXParserFactory.newInstance(); The next lines make sure that the SAX parser doesn't try to validate the document, or tries to load in external DTDs (such as those from W3). Non-parsing means you don't need an internet connection to use the program, and speeds up loading the document massively. try { factory.setFeature("http:xml.org/sax/features/validation", false); factory.setFeature("http:xml.org/sax/features/external-parameter-entities", false); factory.setFeature("http:xml.org/sax/features/external-general-entities", false); factory.setFeature("http:apache.org/xml/features/nonvalidating/load-external-dtd", false); } catch (Exception e) { logger.log(Level.SEVERE, "Parsing feature not supported.", e); throw new RuntimeException("Parsing feature not supported.", e); } SAXParser parser; try { parser = factory.newSAXParser(); } catch (Exception e) { logger.log(Level.SEVERE, "Could not create parser.", e); throw new RuntimeException("Could not create parser.", e); } Parse the document PythonNodeTypeLibraryHandler handler = new PythonNodeTypeLibraryHandler(this); try { parser.parse(source, handler); 
private void createPythonNodeTypeLibrary ( Attributes attributes ) throws SAXException { String moduleName = requireAttribute ( " library " , attributes , " module " ) ; library . setPythonModuleName ( moduleName ) ; Load python module TODO: This is the central versioning problem. To properly handle this, we need several system states. PyString libraryPath = new PyString(library.getPath()); PyList sysPath = Py.getSystemState().path; if (!sysPath.contains(libraryPath)) sysPath.add(libraryPath); library.setPythonModule((PyModule) imp.importName(moduleName.intern(), true)); } 
private void createNodeType ( Attributes attributes ) throws SAXException { String name = requireAttribute ( " type " , attributes , " name " ) ; String outputTypeName = requireAttribute ( " type " , attributes , " outputType " ) ; String functionName = requireAttribute ( " type " , attributes , " method " ) ; ParameterType . Type outputType = ParameterType . parseType ( outputTypeName ) ; PyObject module = library . getPythonModule ( ) ; PyObject functionObject ; try { functionObject = module . __getattr__ ( functionName . intern ( ) ) ; } catch ( Exception e ) { throwLibraryException ( " the method ' " + name + " ' does not exist in the module " + module ) ; return ; } PyFunction function = null ; try { function = ( PyFunction ) functionObject ; } catch ( ClassCastException e ) { throwLibraryException ( " the module attribute ' " + functionName + " ' is not a Python function. " ) ; } currentNodeType = new PythonNodeType ( library , name , outputType , function ) ; } 
public static void initializePython ( ) { Properties jythonProperties = new Properties ( ) ; String jythonCacheDir = PlatformUtils . getUserDataDirectory ( ) + PlatformUtils . SEP + " jythoncache " ; jythonProperties . put ( " python.cachedir " , jythonCacheDir ) ; PySystemState . initialize ( System . getProperties ( ) , jythonProperties , new String [ ] { " " } ) ; String workingDirectory = System . getProperty ( " user.dir " ) ; File pythonLibraries = new File ( workingDirectory , " lib " + PlatformUtils . SEP + " python.zip " ) ; Py . getSystemState ( ) . path . add ( new PyString ( pythonLibraries . getAbsolutePath ( ) ) ) ; } 
protected void setUp ( ) throws Exception { PythonUtils . initializePython ( ) ; The librariesDirectory is used in the testCreatePythonLibrary method. librariesDirectory = FileUtils.createTemporaryDirectory("testlibs"); Create a new NTLM with a custom search path set to the temporary libraries directory. manager = new NodeTypeLibraryManager(librariesDirectory); networkEventHandler = new NetworkEventHandler(); } 
protected void tearDown ( ) throws Exception { FileUtils . deleteDirectory ( librariesDirectory ) ; } 
public void testCreatePythonLibrary ( ) throws IOException { Create a new Python library in the test libraries folder. String libraryName = "tlib"; NodeTypeLibrary library = manager.createPythonLibrary(libraryName); Check if the library's path is correct. assertEquals(librariesDirectory.getCanonicalPath() + PlatformUtils.SEP + libraryName, library.getPath()); Check if the library loads correctly. assertTrue(library.hasNodeType("test")); NodeType testType = library.getNodeType("test"); assertTrue(testType.hasParameterType("x")); assertTrue(testType.hasParameterType("y")); Create a test node and examine the output Node testNode = testType.createNode(); testNode.set("x", 50); testNode.set("y", 30); testNode.update(); assertTrue(testNode.getOutputValue() instanceof BezierPath); BezierPath p = (BezierPath) testNode.getOutputValue(); assertEquals(new Rect(25, 5, 50, 50), p.getBounds()); FileUtils.deleteDirectory(librariesDirectory); } 
public void testReload ( ) throws IOException { NodeType canvasnetType = manager . getNodeType ( " corecanvas.canvasnet " ) ; Network net = ( Network ) canvasnetType . createNode ( ) ; net . addNetworkEventListener ( networkEventHandler ) ; Create a new Python library in the test libraries folder. String libraryName = "tlib"; NodeTypeLibrary library = manager.createPythonLibrary(libraryName); String libraryDirectory = library.getPath(); NodeType testType = library.getNodeType("test"); assertTrue(testType.hasParameterType("x")); assertTrue(testType.hasParameterType("y")); assertFalse(testType.hasParameterType("size")); Node testNode = net.create(testType); testNode.set("x", 50); testNode.set("y", 30); assertTrue(testNode.hasParameter("x")); assertTrue(testNode.hasParameter("y")); assertFalse(testNode.hasParameter("size")); Change the type information and module contents. File ntlFile = new File(libraryDirectory + PlatformUtils.SEP + "types.ntl"); String ntlContents = "<library name=\"" + libraryName + "\" formatVersion=\"0.8\" type=\"python\" module=\"" + libraryName + "\">" + " <type name=\"test\" outputType=\"grob_path\" method=\"test\">" + " <description>Test method.</description>" + " <parameter type=\"float\" name=\"x\"/>" + " <parameter type=\"float\" name=\"y\"/>" + " <parameter type=\"float\" name=\"size\" defaultValue=\"100\"/>" + " </type>" + "</library>"; File moduleFile = new File(libraryDirectory + PlatformUtils.SEP + libraryName + ".py"); String moduleContents = "from net.nodebox import graphics" + "def test(x, y, size):" + " p = graphics.BezierPath()" + " p.ellipse(x, y, size, size)" + " return p"; FileUtils.writeFile(ntlFile, ntlContents); FileUtils.writeFile(moduleFile, moduleContents); Assert no node changed event have been fired yet. assertEquals(0, networkEventHandler.nodeChangedCounter); Now reload the library library.reload(); NodeType newType = testNode.getNodeType(); assertTrue(newType.hasParameterType("x")); assertTrue(newType.hasParameterType("y")); assertTrue(newType.hasParameterType("size")); assertTrue(testNode.hasParameter("x")); assertTrue(testNode.hasParameter("y")); assertTrue(testNode.hasParameter("size")); assertEquals(50.0, testNode.asFloat("x")); assertEquals(30.0, testNode.asFloat("y")); assertEquals(100.0, testNode.asFloat("size")); Check if the node changed event has fired. assertEquals(1, networkEventHandler.nodeChangedCounter); networkEventHandler.nodeChangedCounter = 0; reset the counter by hand. Create a second node and reload the library. The event should now be fired twice, once for each node. Node testNode2 = net.create(newType); library.reload(); assertEquals(2, networkEventHandler.nodeChangedCounter); 
public void nodeChanged ( Network source , Node node ) { nodeChangedCounter + + ; } 
public void run ( ) { PythonUtils . initializePython ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
private void initMenu ( ) { JMenuBar menuBar = new JMenuBar ( ) ; File menu JMenu fileMenu = new JMenu("File"); fileMenu.add(newAction); fileMenu.add(openAction); recentFileMenu = new JMenu("Open Recent"); buildRecentFileMenu(); fileMenu.add(recentFileMenu); fileMenu.addSeparator(); fileMenu.add(closeAction); fileMenu.add(saveAction); fileMenu.add(saveAsAction); fileMenu.add(revertAction); fileMenu.addSeparator(); fileMenu.add(exportAction); if (!PlatformUtils.onMac()) { fileMenu.addSeparator(); fileMenu.add(quitAction); } menuBar.add(fileMenu); Edit menu JMenu editMenu = new JMenu("Edit"); editMenu.add(undoAction); editMenu.add(redoAction); editMenu.addSeparator(); editMenu.add(cutAction); editMenu.add(copyAction); editMenu.add(pasteAction); editMenu.addSeparator(); editMenu.add(deleteAction); menuBar.add(editMenu); Node menu JMenu pythonMenu = new JMenu("Node"); pythonMenu.add(reloadAction); pythonMenu.add(newLibraryAction); menuBar.add(pythonMenu); Window menu JMenu windowMenu = new JMenu("Window"); JMenu layoutMenu = new JMenu("Layout"); layoutMenu.add(new ) windowMenu.add(minimizeAction); windowMenu.add(zoomAction); windowMenu.addSeparator(); windowMenu.add(layoutMenu); windowMenu.addSeparator(); windowMenu.add(bringAllToFrontAction); windowMenu.addSeparator(); menuBar.add(windowMenu); Help menu JMenu helpMenu = new JMenu("Help"); helpMenu.add(nodeboxSiteAction); menuBar.add(helpMenu); setJMenuBar(menuBar); } 
private void doRender ( ) { renderThread.render(activeNetwork); } public void networkUpdated(Network network) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void networkUpdated ( Network network ) { } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class ExportAction extends AbstractAction { public ExportAction ( ) { putValue ( NAME , " Export... " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_E ) ) ; } public void actionPerformed ( ActionEvent e ) { export ( ) ; } } public class QuitAction extends AbstractAction { public QuitAction ( ) { putValue ( NAME , " Quit " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Q ) ) ; } public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . quit ( ) ; } } public class UndoAction extends AbstractAction { public UndoAction ( ) { putValue ( NAME , " Undo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . undo ( ) ; } catch ( CannotUndoException ex ) { logger . log ( Level . WARNING , " Unable to undo. " , ex ) ; } update ( ) ; redoAction . update ( ) ; } public void update ( ) { if ( undo . canUndo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getUndoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Undo " ) ; } } } public class RedoAction extends AbstractAction { public RedoAction ( ) { putValue ( NAME , " Redo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z , Event . SHIFT_MASK ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . redo ( ) ; } catch ( CannotRedoException ex ) { logger . log ( Level . WARNING , " Unable to redo. " , ex ) ; } update ( ) ; undoAction . update ( ) ; } public void update ( ) { if ( undo . canRedo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getRedoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Redo " ) ; } } } public class CutAction extends AbstractAction { public CutAction ( ) { putValue ( NAME , " Cut " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_X ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { String libraryName = JOptionPane . showInputDialog ( NodeBoxDocument . this , " Enter the name for the new library " , " Create New Library " , JOptionPane . QUESTION_MESSAGE ) ; if ( libraryName = = null | | libraryName . trim ( ) . length ( ) = = 0 ) return ; createNewLibrary ( libraryName ) ; } 
public void nodeChanged ( Network source , Node node ) { Maybe the name of the node was changed. Redraw the node view. NodeView nv = getNodeView(node); nv.repaint(); } 
public void fireNodePositionChanged ( Node node ) { if ( listeners = = null ) return ; for ( EventListener l : listeners . getListeners ( NetworkEventListener . class ) ) ( ( NetworkEventListener ) l ) . nodePositionChanged ( this , node ) ; 
public void nodeAdded ( Network source , Node node ) { } public void nodePositionChanged ( Network source , Node node ) { To change body of implemented methods use File | Settings | File Templates. }} 
public void nodeRemoved ( Network source , Node node ) { } public void nodePositionChanged ( Network source , Node node ) { To change body of implemented methods use File | Settings | File Templates. }} 
public void connectionAdded ( Network source , Connection connection ) { } public void nodePositionChanged ( Network source , Node node ) { To change body of implemented methods use File | Settings | File Templates. }} 
public void connectionRemoved ( Network source , Connection connection ) { } public void nodePositionChanged ( Network source , Node node ) { To change body of implemented methods use File | Settings | File Templates. }} 
public void renderedNodeChanged ( Network source , Node node ) { } public void nodePositionChanged ( Network source , Node node ) { To change body of implemented methods use File | Settings | File Templates. }} 
public void nodeChanged ( Network source , Node node ) { } public void nodePositionChanged ( Network source , Node node ) { To change body of implemented methods use File | Settings | File Templates. }} 
public void nodePositionChanged ( Network source , Node node ) { To change body of implemented methods use File | Settings | File Templates. }} 
public void nodeAdded ( Network source , Node node ) ; public void nodePositionChanged ( Network source , Node node ) ; } 
public void nodeRemoved ( Network source , Node node ) ; public void nodePositionChanged ( Network source , Node node ) ; } 
public void connectionAdded ( Network source , Connection connection ) ; public void nodePositionChanged ( Network source , Node node ) ; } 
public void connectionRemoved ( Network source , Connection connection ) ; public void nodePositionChanged ( Network source , Node node ) ; } 
public void renderedNodeChanged ( Network source , Node node ) ; public void nodePositionChanged ( Network source , Node node ) ; } 
public void nodeChanged ( Network source , Node node ) ; public void nodePositionChanged ( Network source , Node node ) ; } 
public void fireNodePositionChanged ( ) { if ( inNetwork ( ) ) getNetwork ( ) . fireNodePositionChanged ( this ) ; 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); g2.translate(getWidth() / 2.0, getHeight() / 2.0); if (getNetwork() == null) return; Object outputValue = getNetwork().getOutputParameter().getValueReference(); if (outputValue instanceof Grob) { ((Grob) outputValue).draw(g2); } Draw handle if (handle != null && showHandle) { Create a canvas with a transparent background 
public static void main ( String [ ] args ) { SimpleEditor e = new SimpleEditor ( ) ; e . setLocationByPlatform ( true ) ; e . setVisible ( true ) ; } 
public void switchToDocument ( SimpleDocument document ) { for ( SimpleDocument doc : openDocuments ) { doc . getFileTab ( ) . setActive ( false ) ; } placeHolder . removeAll ( ) ; if ( document ! = null ) { placeHolder . add ( document . getCodeScroll ( ) , BorderLayout . CENTER ) ; document . getFileTab ( ) . setActive ( true ) ; } placeHolder . revalidate ( ) ; placeHolder . repaint ( ) ; } 
public void newTabWithFile ( File file ) { if ( file . isDirectory ( ) ) return ; SimpleDocument doc = getDocument ( file ) ; if ( doc = = null ) { String contents = FileUtils . readFile ( file ) ; CodeArea codeArea = new CodeArea ( ) ; codeArea . setText ( contents ) ; FileTab fileTab = new FileTab ( file ) ; doc = new SimpleDocument ( file , codeArea , fileTab ) ; openDocuments . add ( doc ) ; tabBar . add ( fileTab ) ; tabBar . revalidate ( ) ; tabBar . repaint ( ) ; } switchToDocument ( doc ) ; } 
public void closeDocument ( SimpleDocument document ) { if ( document . isChanged ( ) ) { SaveDialog sd = new SaveDialog ( ) ; int retVal = sd . show ( this ) ; if ( retVal = = JOptionPane . YES_OPTION ) { document . save ( ) ; Now fall through, which will close the document } else if (retVal == JOptionPane.NO_OPTION) { Fall through, which will close the document } else if (retVal == JOptionPane.CANCEL_OPTION) { return; } } tabBar.remove(document.getFileTab()); tabBar.revalidate(); tabBar.repaint(); int documentIndex = openDocuments.indexOf(document); openDocuments.remove(document); placeHolder.removeAll(); SimpleDocument doc = null; if (openDocuments.size() == 0) { switchToDocument(doc); 
public void closeTab ( FileTab fileTab ) { SimpleDocument doc = getDocument ( fileTab ) ; closeDocument ( doc ) ; } 
public void switchToTab ( FileTab fileTab ) { SimpleDocument doc = getDocument ( fileTab ) ; switchToDocument ( doc ) ; } 
public void valueChanged ( TreeSelectionEvent e ) { File f = ( File ) e . getPath ( ) . getLastPathComponent ( ) ; if ( f . isDirectory ( ) ) return ; newTabWithFile ( f ) ; } 
public String toString ( ) { return file . getName ( ) ; } 
public boolean isChanged ( ) { return changed ; } 
public void save ( ) { FileUtils . writeFile ( file , codeArea . getText ( ) ) ; setChanged ( false ) ; } 
public void insertUpdate ( DocumentEvent e ) { setChanged ( true ) ; } 
public void removeUpdate ( DocumentEvent e ) { setChanged ( true ) ; } 
public void changedUpdate ( DocumentEvent e ) { setChanged ( true ) ; } 
public void actionPerformed ( ActionEvent e ) { closeTab ( FileTab . this ) ; } 
public void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; g . setColor ( getBackground ( ) ) ; g . fillRoundRect ( r . x , r . y , r . width , r . height , 5 , 5 ) ; } 
public boolean isActive ( ) { return active ; } 
public void mouseClicked ( MouseEvent e ) { switchToTab ( this ) ; } 
public boolean accept ( File pathname ) { if ( pathname . getName ( ) . equals ( " .svn " ) ) return false ; if ( pathname . getName ( ) . equals ( " .git " ) ) return false ; if ( pathname . isDirectory ( ) ) return true ; if ( pathname . getName ( ) . endsWith ( " .py " ) ) return true ; if ( pathname . getName ( ) . endsWith ( " .ntl " ) ) return true ; return false ; } 
public boolean isLeaf ( Object node ) { assert ( node instanceof File ) ; return ! ( ( File ) node ) . isDirectory ( ) ; } 
public Grob asGrob ( ) { if ( getCoreType ( ) = = ParameterType . CoreType . GROB | | getCoreType ( ) = = ParameterType . CoreType . GROB_CANVAS 
private Object clonedValue ( Object value ) { if ( value instanceof Grob ) { return ( ( Grob ) value ) . clone ( ) ; 
public void testMultiConnect ( ) { Network net = ( Network ) testNetworkType . createNode ( ) ; Node number1 = net . create ( numberType ) ; number1 . set ( " value " , 5 ) ; Node number2 = net . create ( numberType ) ; number2 . set ( " value " , 10 ) ; Node multiAdd1 = net . create ( multiAddType ) ; net . connect ( number1 , multiAdd1 , " values " ) ; net . connect ( number2 , multiAdd1 , " values " ) ; assertTrue ( number1 . isConnected ( ) ) ; assertTrue ( number2 . isConnected ( ) ) ; multiAdd1 . setRendered ( ) ; Test default behaviour net.update(); assertFalse(net.isDirty()); assertFalse(multiAdd1.isDirty()); assertEquals(15, net.getOutputValue()); Change number1 and see if the change propagates. number1.set("value", 3); assertTrue(net.isDirty()); assertTrue(multiAdd1.isDirty()); net.update(); assertEquals(13, net.getOutputValue()); change number2 and see if the change propagates. number2.set("value", 4); assertTrue(net.isDirty()); assertTrue(multiAdd1.isDirty()); net.update(); assertEquals(7, net.getOutputValue()); } 
public void testMacro ( ) { public void testCopy() { Network vector1 = (Network) manager.getNodeType("corevector.vecnet").createNode(); Node ellipse1 = vector1.create(manager.getNodeType("corevector.ellipse")); ellipse1.setRendered(); vector1.update(); assertFalse(vector1.getOutputValue() == ellipse1.getOutputValue()); } public void testCycles() { Network net = (Network) testNetworkType.createNode(); Node n1 = net.create(numberType); Node n2 = net.create(numberType); Node n3 = net.create(numberType); assertFalse(n2.isConnected()); assertValidConnect(n2, "value", n1); assertTrue(n2.isConnected()); assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isOutputConnectedTo(n2)); assertValidConnect(n3, "value", n2); assertTrue(n3.isConnected()); assertTrue(n3.isInputConnectedTo(n2)); assertTrue(n2.isOutputConnectedTo(n3)); Try creating a 2-node cycle. assertInvalidConnect(n1, "value", n2); The connection didn't go through, so n1's input is not connected to n2. assertFalse(n1.isInputConnectedTo(n2)); However the output of n2 is still connected to n1. assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isConnected()); assertTrue(n2.isConnected()); Try creating a 3-node cycle. assertInvalidConnect(n1, "value", n3); Test multi-input connections. Node n4 = net.create(multiAddType); assertValidConnect(n4, "values", n1); assertValidConnect(n4, "values", n2); assertValidConnect(n4, "values", n3); assertInvalidConnect(n4, "values", n4); assertInvalidConnect(n1, "value", n4); } private void assertValidConnect(Node inputNode, String inputParameterName, Node outputNode) { try { inputNode.getParameter(inputParameterName).connect(outputNode); } catch (ConnectionError e) { fail("Should not have thrown ConnectionError: " + e); } } private void assertInvalidConnect(Node inputNode, String inputParameterName, Node outputNode) { try { inputNode.getParameter(inputParameterName).connect(outputNode); fail("Should have thrown ConnectionError."); } catch (ConnectionError e) { } }} 
public void testBasicMerge ( ) { Network net = ( Network ) manager . getNodeType ( " corevector.vecnet " ) . createNode ( ) ; Node rect1 = net . create ( manager . getNodeType ( " corevector.rect " ) ) ; rect1 . set ( " x " , 25.0 ) ; Node ellipse1 = net . create ( manager . getNodeType ( " corevector.ellipse " ) ) ; ellipse1 . set ( " x " , 199.0 ) ; Node merge = net . create ( manager . getNodeType ( " corevector.merge " ) ) ; merge . getParameter ( " shapes " ) . connect ( rect1 ) ; merge . getParameter ( " shapes " ) . connect ( ellipse1 ) ; merge . update ( ) ; Group g = ( Group ) merge . getOutputValue ( ) ; assertEquals ( 2 , g . getGrobs ( ) . size ( ) ) ; BezierPath rectPath = ( BezierPath ) g . get ( 0 ) ; Compare the X value set on the rect1 node so we know it is the output of the rect1 node. assertEquals(25.0 - 50.0, rectPath.getBounds().getX()); BezierPath ellipsePath = (BezierPath) g.get(1); Compare the X value set on the ellipse1 node assertEquals(199.0 - 50.0, ellipsePath.getBounds().getX()); } 
public void testPropagation ( ) { This weird network shape causes errors with the propagation. The problem is the grid node that is connected to two separate copy nodes. Network net = (Network) manager.getNodeType("corecanvas.canvasnet").createNode(); Node rect1 = net.create(manager.getNodeType("corevector.rect")); Node rect2 = net.create(manager.getNodeType("corevector.rect")); Node copy1 = net.create(manager.getNodeType("corevector.copy")); Node copy2 = net.create(manager.getNodeType("corevector.copy")); Node grid1 = net.create(manager.getNodeType("corevector.grid")); Node merge1 = net.create(manager.getNodeType("corevector.merge")); net.connect(rect1, copy1, "shape"); net.connect(rect2, copy2, "shape"); net.connect(grid1, copy1, "template"); net.connect(grid1, copy2, "template"); net.connect(copy1, merge1, "shapes"); net.connect(copy2, merge1, "shapes"); merge1.setRendered(); net.update(); assertFalse(rect1.isDirty()); assertFalse(copy1.isDirty()); assertFalse(rect2.isDirty()); assertFalse(copy2.isDirty()); assertFalse(grid1.isDirty()); assertFalse(merge1.isDirty()); rect1.set("x", 50); assertTrue(rect1.isDirty()); assertTrue(copy1.isDirty()); assertFalse(rect2.isDirty()); assertFalse(copy2.isDirty()); assertFalse(grid1.isDirty()); assertTrue(merge1.isDirty()); net.update(); assertFalse(rect1.isDirty()); assertFalse(copy1.isDirty()); assertFalse(rect2.isDirty()); assertFalse(copy2.isDirty()); assertFalse(grid1.isDirty()); assertFalse(merge1.isDirty()); rect2.set("x", 50); assertFalse(rect1.isDirty()); assertFalse(copy1.isDirty()); assertTrue(rect2.isDirty()); assertTrue(copy2.isDirty()); assertFalse(grid1.isDirty()); assertTrue(merge1.isDirty()); } 
public boolean process ( Node node , ProcessingContext ctx ) { Group outputGroup = new Group ( ) ; Grob shape = node . asGrob ( " shape " ) ; Grob template = node . getParameter ( " template " ) . isConnected ( ) ? node . asGrob ( " template " ) : null ; int copies = node . asInt ( " copies " ) ; double tx = node . asFloat ( " tx " ) ; double ty = node . asFloat ( " ty " ) ; double r = node . asFloat ( " r " ) ; double sx = node . asFloat ( " sx " ) / 100.0 ; double sy = node . asFloat ( " sy " ) / 100.0 ; double kx = node . asFloat ( " kx " ) ; double ky = node . asFloat ( " ky " ) ; String expression = node . asString ( " expression " ) ; Expression expressionObject = new Expression ( expression , true ) ; ProcessingContext copyContext = ( ProcessingContext ) ctx . clone ( ) ; if ( expression = = null | | expression . trim ( ) . length ( ) = = 0 ) { if ( template = = null ) { copy source geometry according to transformation parameters doCopy(outputGroup, shape, 0, 0, copies, tx, ty, r, sx, sy); } else { copy source geometry according to template Go over each point in the template geometry, and put a copy of the source geometry there. for (Point p : pointsForGrob(template)) { doCopy(outputGroup, shape, p.getX(), p.getY(), copies, tx, ty, r, sx, sy); } } } else { Expression set. The expression allows you to modify field values on upstream nodes while copying. The expression has access to all the nodes by their name (e.g. rect1), and can set values on them. The CNUM local variable contains the copy number (starting from zero) Parameter pShape = node.getParameter("shape"); if (!pShape.isConnected()) throw new AssertionError("The shape is not connected."); List<Point> points; if (template == null) { points = new ArrayList<Point>(); points.add(new Point()); } else { points = pointsForGrob(template); } int copyIndex = 0; for (Point p : points) { Transform t = new Transform(); t.translate(p.getX(), p.getY()); for (int i = 0; i < copies; i++) { Node upstreamNode = pShape.getExplicitConnection().getOutputNode(); Node copiedUpstreamNode = upstreamNode.getNetwork().copyNodeWithUpstream(upstreamNode); These expressions can mutate the values; that's sort of the point. expressionObject.setParameter(copiedUpstreamNode.getOutputParameter()); The expression object changes the node values, so I don't care about the output. copyContext.put("CNUM", copyIndex); expressionObject.evaluate(copyContext); Now evaluate the output of the new upstream node. copiedUpstreamNode.update(ctx); if (copiedUpstreamNode.hasError()) throw new ProcessingError(node, "Upstream node contained errors:" + copiedUpstreamNode.getMessages().toString()); We do not need to clone the output shape. Grob outputShape = (Grob) copiedUpstreamNode.getOutputValue(); outputShape.prependTransform(t); outputGroup.add(outputShape); t.translate(tx, ty); t.rotate(r); t.scale(sx, sy); t.skew(kx, ky); copyIndex++; } } } node.setOutputValue(outputGroup); return true; } 
public boolean process ( Node node , ProcessingContext ctx ) { Grob g = node . asGrob ( " shape " ) ; Grob outGrob = g ; Transform = new Transform ( ) ; . translate ( node . asFloat ( " tx " ) , node . asFloat ( " ty " ) ) ; . rotate ( node . asFloat ( " r " ) ) ; . scale ( node . asFloat ( " sx " ) / 100.0 , node . asFloat ( " sy " ) / 100.0 ) ; . skew ( node . asFloat ( " kx " ) , node . asFloat ( " ky " ) ) ; outGrob . appendTransform ( ) ; node . setOutputValue ( outGrob ) ; return true ; } 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof Commit ) ) return false ; return id . equals ( ( ( Commit ) obj ) . id ) ; } 
public Repository createRepository ( File projectDirectory ) { Repository r = Repository . create ( this , projectDirectory ) ; repositories . put ( r . getProjectName ( ) , r ) ; return r ; } 
private void loadRepositories ( ) { for ( File projectDirectory : localHistoryDirectory . listFiles ( ) ) { if ( ! projectDirectory . isDirectory ( ) ) continue ; 
private void parseConfiguration ( ) { File configPath = new File ( directory , " config " ) ; if ( ! configPath . exists ( ) ) throw new AssertionError ( " Repository " + projectName + " does not have a config file. " ) ; Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( configPath ) ) ; } catch ( IOException e ) { throw new RuntimeException ( " Could not read config file for repository " + projectName , e ) ; } String formatVersion = properties . getProperty ( " repositoryformatversion " ) ; if ( ! formatVersion . equals ( " 0 " ) ) throw new AssertionError ( " Project " + projectName + " : unsupported repository format version. " ) ; projectDirectory = new File ( properties . getProperty ( " projectpath " ) ) ; if ( ! projectDirectory . exists ( ) ) throw new AssertionError ( " Project " + projectName + " : non-existant project directory ' " + projectDirectory + " '. " ) ; 
public static Repository create ( LocalHistoryManager manager , File projectDirectory ) { if ( ! projectDirectory . exists ( ) ) throw new AssertionError ( " The project directory ' " + projectDirectory + " ' does not exist. " ) ; if ( ! projectDirectory . isDirectory ( ) ) throw new AssertionError ( " The project directory ' " + projectDirectory + " ' is not a directory. " ) ; String projectName = projectDirectory . getName ( ) ; File repositoryDirectory = new File ( manager . getLocalHistoryDirectory ( ) , projectName ) ; File objectsDirectory = new File ( repositoryDirectory , " objects " ) ; File refsDirectory = new File ( repositoryDirectory , " refs " ) ; File configFile = new File ( repositoryDirectory , " config " ) ; if ( repositoryDirectory . exists ( ) ) throw new AssertionError ( " A repository named ' " + projectName + " ' already exists. " ) ; boolean success ; success = repositoryDirectory . mkdir ( ) ; if ( ! success ) throw new RuntimeException ( " Error while creating repository directory " + repositoryDirectory ) ; success = objectsDirectory . mkdir ( ) ; if ( ! success ) throw new RuntimeException ( " Error while creating objects directory " + objectsDirectory ) ; success = refsDirectory . mkdir ( ) ; if ( ! success ) throw new RuntimeException ( " Error while creating refs directory " + refsDirectory ) ; Properties p = new Properties ( ) ; p . setProperty ( " repositoryformatversion " , " 0 " ) ; p . setProperty ( " projectpath " , projectDirectory . getAbsolutePath ( ) ) ; try { configFile . createNewFile ( ) ; FileOutputStream out = new FileOutputStream ( configFile ) ; p . store ( out , null ) ; } catch ( IOException e ) { throw new RuntimeException ( " Error while writing configuration file " + configFile + " . " , e ) ; } return new Repository ( manager , projectName ) ; } 
public File objectPath ( String id ) { return objectPath ( id , false ) ; } 
public File objectPath ( String id , boolean createPath ) { if ( id = = null | | id . length ( ) ! = 40 ) throw new AssertionError ( " Invalid id. Use hashObject to get a valid id. " ) ; The directory is composed of the two first characters of the hash. String firstTwo = id.substring(0, 2); String theRest = id.substring(2); File dirName = new File(directory, "objects/" + firstTwo); if (createPath && !dirName.exists()) { if (!dirName.mkdir()) { throw new AssertionError("Project " + projectName + ": could not create directory '" + dirName + "'."); } } return new File(dirName, theRest); } 
public boolean objectExists ( String id ) { return objectPath ( id , false ) . exists ( ) ; } 
public byte [ ] readObject ( String id ) { File objectPath = objectPath ( id ) ; return readFile ( objectPath ) ; byte[] compressedData = readFile(objectPath); 
public String hashObject ( String fileName ) { return hashObject ( fileName , false ) ; } 
public String hashObject ( String fileName , boolean write ) { File fullPath = new File ( projectDirectory , fileName ) ; return hashObject ( fullPath , write ) ; } 
public String hashObject ( File file , boolean write ) { if ( ! file . exists ( ) ) throw new AssertionError ( " File ' " + file + " ' does not exist. " ) ; if ( file . isDirectory ( ) ) throw new AssertionError ( " File ' " + file + " ' is a directory, which this method cannot hash. " ) ; byte [ ] data = readFile ( file ) ; if ( write ) return writeObject ( data ) ; 
public String writeObject ( byte [ ] data ) { String id = hashData ( data ) ; if ( ! objectExists ( id ) ) { File objectPath = objectPath ( id , true ) ; writeFile ( objectPath , data , 0 , data . length ) ; byte[] compressedData = new byte[data.length]; Deflater d = new Deflater(); d.setInput(data); d.finish(); int compressedLength = d.deflate(compressedData); writeFile(objectPath, compressedData, 0, compressedLength); } return id; } 
public boolean accept ( File dir , String name ) { return name . length ( ) = = 38 ; } 
public String readRef ( String name ) { File refsDirectory = new File ( getDirectory ( ) , " refs " ) ; File refsFile = new File ( refsDirectory , name ) ; if ( ! refsFile . exists ( ) ) return null ; byte [ ] refBytes = readFile ( refsFile ) ; return new String ( refBytes ) ; } 
public void writeRef ( String name , String id ) { File refsDirectory = new File ( getDirectory ( ) , " refs " ) ; File refsFile = new File ( refsDirectory , name ) ; writeFile ( refsFile , id . getBytes ( ) , 0 , 40 ) ; } 
public boolean refExists ( String name ) { File refsDirectory = new File ( getDirectory ( ) , " refs " ) ; File refsFile = new File ( refsDirectory , name ) ; return refsFile . exists ( ) ; } 
public String commit ( String message ) { StringBuffer commitDataBuffer = new StringBuffer ( ) ; Store the contents of the working directory in the object database. This will return the root id of the tree. String treeId = hashDirectoryRecursive(projectDirectory); commitDataBuffer.append("tree ").append(treeId).append(""); Find the current head: this will be the parent of this commit. String parentId = readRef("HEAD"); if (parentId != null) { commitDataBuffer.append("parent ").append(parentId).append(""); } Add the commit time Calendar cal = Calendar.getInstance(); commitDataBuffer.append("time ").append(Commit.dateFormat.format(cal.getTime())).append(""); Append an empty line to indicate the commit message follows commitDataBuffer.append(""); Add the commit message commitDataBuffer.append(message); Store the commit in the object database. String commitId = writeObject(commitDataBuffer.toString().getBytes()); This commit will be the new head. Write a reference to it. writeRef("HEAD", commitId); return commitId; } 
public String hashData ( byte [ ] data ) { MessageDigest md ; try { md = MessageDigest . getInstance ( " SHA1 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new AssertionError ( " This Java implementation does not support SHA-1 hashing. " ) ; } md . update ( data ) ; byte [ ] digest = md . digest ( ) ; String hexStr = " " ; for ( byte aDigest : digest ) { hexStr + = Integer . toString ( ( aDigest & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ; } return hexStr ; } 
public String hashDirectoryRecursive ( File directory ) { if ( ! directory . exists ( ) ) throw new AssertionError ( " Directory ' " + directory + " ' does not exist. " ) ; if ( ! directory . isDirectory ( ) ) throw new AssertionError ( " Directory ' " + directory + " ' is not a directory. " ) ; StringBuffer treeDataBuffer = new StringBuffer ( ) ; for ( File f : directory . listFiles ( ) ) { String type , id ; if ( f . isDirectory ( ) ) { id = hashDirectoryRecursive ( f ) ; type = " tree " ; } else { id = hashObject ( f , true ) ; type = " blob " ; } treeDataBuffer . append ( type ) . append ( " " ) . append ( id ) . append ( " " ) . append ( f . getName ( ) ) . append ( " " ) ; } Remove the final "" String treeData = treeDataBuffer.substring(treeDataBuffer.length() - 1); return writeObject(treeData.getBytes()); } 
private byte [ ] readFile ( File file ) { try { FileInputStream in = new FileInputStream ( file ) ; 
private void writeFile ( File file , byte [ ] data , int offset , int length ) { try { FileOutputStream out = new FileOutputStream ( file ) ; 
protected void setUp ( ) throws Exception { Create a tempory folder tempDirectory = File.createTempFile("localhistory", ""); tempDirectory.delete(); tempDirectory.mkdir(); localHistoryDirectory = new File(tempDirectory, "_history"); manager = new LocalHistoryManager(localHistoryDirectory); testDirectory = new File(tempDirectory, "testproject"); testDirectory.mkdir(); } 
public void testHashObject ( ) { Repository r = manager . createRepository ( testDirectory ) ; String fname = " greeting " ; String contents = " Hello, world! " ; createProjectFile ( fname , contents ) ; assertEquals ( " 943a702d06f34599aee1f8da8ef9f7296031d699 " , r . hashObject ( " greeting " ) ) ; } 
public void testCreate ( ) { Repository r = manager . createRepository ( testDirectory ) ; Creating the repository should have created the _history/testproject folder and a configuration file inside of that folder. File projectHistoryDirectory = new File(localHistoryDirectory, "testproject"); File configFile = new File(projectHistoryDirectory, "config"); assertTrue(projectHistoryDirectory.exists() && projectHistoryDirectory.isDirectory()); assertTrue(configFile.exists() && configFile.isFile()); assertEquals(testDirectory, r.getProjectDirectory()); Trying to create the repository again will result in an error. try { manager.createRepository(testDirectory); 
public void testAddFile ( ) { Repository r = manager . createRepository ( testDirectory ) ; Assert this repository is empty: no objects, and the head commit returns None. assertEquals(0, r.getObjectCount()); assertEquals(null, r.getHead()); String fname = "greeting"; String contents = "Hello, world!"; createProjectFile(fname, contents); String id = r.hashObject(fname); String commitId1 = r.commit("Adding files to the project."); Assert that the contents are stored in the repository. assertEquals(contents, new String(r.readObject(id))); Assert the head commit now refers to the newly created commit. assertEquals(commitId1, r.getHead().getId()); Since this is the first commit, it will not have a parent. assertEquals(null, r.getHead().getParentId()); Once commited, there will be three objects in the database: the file, the tree, and the commit. assertEquals(3, r.getObjectCount()); String commitId2 = r.commit("My second commit with the same files."); assertNotSame(commitId1, commitId2); Since no files/folders were changed, only one new object is created in the database: the second commit. assertEquals(4, r.getObjectCount()); Assert the head commit now refers to the newly created commit. assertEquals(commitId2, r.getHead().getId()); Assert the parent commit refers to our previous commit. assertEquals(commitId1, r.getHead().getParentId()); } 
protected void tearDown ( ) throws Exception { FileUtils . deleteDirectory ( tempDirectory ) ; } 
private void createProjectFile ( String fname , String contents ) { File projectFile = new File ( testDirectory , fname ) ; FileUtils . writeFile ( projectFile , contents ) ; } 
private void init ( ) { this . setMargin ( new Insets ( 0 , 5 , 0 , 5 ) ) ; setFont ( PlatformUtils . getEditorFont ( ) ) ; setEditorKit ( new PythonEditorKit ( ) ) ; rootElement = getDocument ( ) . getDefaultRootElement ( ) ; todo:this code should be in the kit for (KeyStroke ks : defaultInputMap.allKeys()) { getInputMap().put(ks, defaultInputMap.get(ks)); } addMouseListener(new DragDetector()); } 
private void reload ( ) { NodeTypeLibrary library = node . getNodeType ( ) . getLibrary ( ) ; if ( library instanceof PythonNodeTypeLibrary ) { PythonNodeTypeLibrary pythonLibrary = ( PythonNodeTypeLibrary ) library ; File moduleDirectory = new File ( pythonLibrary . getPath ( ) ) ; editor . setEditorDirectory ( moduleDirectory ) ; editor . saveAll ( ) ; String code = codeArea.getText(); FileUtils.writeFile(moduleFile, code); } getDocument().reloadActiveNode(); } 
public void actionPerformed ( ActionEvent e ) { Component c = ( Component ) e . getSource ( ) ; EditorPane p = ( EditorPane ) SwingUtilities . getAncestorOfClass ( EditorPane . class , c ) ; p . reload ( ) ; } 
public static void main ( String [ ] args ) { File editorDirectory = new File ( PlatformUtils . getUserNodeTypeLibraryDirectory ( ) ) ; JFrame frame = new JFrame ( " Simple Editor " ) ; JPanel rootPanel = new JPanel ( new BorderLayout ( ) ) ; rootPanel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 ) ) ; SimpleEditor e = new SimpleEditor ( ) ; e . setEditorDirectory ( editorDirectory ) ; rootPanel . add ( e ) ; frame . setContentPane ( rootPanel ) ; frame . setLocationByPlatform ( true ) ; frame . setSize ( 1100 , 800 ) ; frame . setVisible ( true ) ; } 
public void closeDocument ( SimpleDocument document ) { if ( document . isChanged ( ) ) { SaveDialog sd = new SaveDialog ( ) ; int retVal = sd . show ( ( JFrame ) SwingUtilities . getWindowAncestor ( this ) ) ; if ( retVal = = JOptionPane . YES_OPTION ) { document . save ( ) ; Now fall through, which will close the document } else if (retVal == JOptionPane.NO_OPTION) { Fall through, which will close the document } else if (retVal == JOptionPane.CANCEL_OPTION) { return; } } tabBar.remove(document.getFileTab()); tabBar.revalidate(); tabBar.repaint(); int documentIndex = openDocuments.indexOf(document); openDocuments.remove(document); placeHolder.removeAll(); SimpleDocument doc = null; if (openDocuments.size() == 0) { switchToDocument(doc); 
public void saveAll ( ) { for ( SimpleDocument doc : openDocuments ) { doc . save ( ) ; 
private void createPythonNodeTypeLibrary ( Attributes attributes ) throws SAXException { String moduleName = requireAttribute ( " library " , attributes , " module " ) ; Load python module TODO: This is the central versioning problem. To properly handle this, we need several system states. We just import, we cannot manage multiple versions. PyModule pythonModule = (PyModule) imp.importName(moduleName.intern(), false); library.setPythonModule(pythonModule); } 
public static void initializePython ( ) { Properties jythonProperties = new Properties ( ) ; String jythonCacheDir = PlatformUtils . getUserDataDirectory ( ) + PlatformUtils . SEP + " jythoncache " ; jythonProperties . put ( " python.cachedir " , jythonCacheDir ) ; PySystemState . initialize ( System . getProperties ( ) , jythonProperties , new String [ ] { " " } ) ; String workingDirectory = System . getProperty ( " user.dir " ) ; Add the built-in python libraries File pythonLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "python.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Add the user libraries Py.getSystemState().path.add(new PyString(PlatformUtils.getUserDataDirectory())); } 
public void mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; ox = node . asFloat ( xName ) ; oy = node . asFloat ( yName ) ; Rect hitRect = createHitRectangle ( ox , oy ) ; dragging = hitRect . contains ( pt ) ; } 
public void mouseDragged ( Point e ) { if ( ! dragging ) return ; double x = e . getX ( ) ; double y = e . getY ( ) ; double dx = x - px ; double dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return ; TODO: Temporary float fix to get a working compile. Doubles will be removed. node.setValue(xName, (float) (ox + dx)); node.setValue(yName, (float) (oy + dy)); } 
public boolean hasOutput ( Port port ) { return outputs . contains ( port ) ; } 
public boolean hasOutputs ( ) { return outputs . size ( ) > 0 ; } 
public boolean addOutput ( Port port ) { if ( port = = null ) throw new IllegalArgumentException ( " The given port cannot be null. " ) ; if ( outputs . contains ( port ) ) return false ; Sanity check to see if the output and input ports are not the same, which would cause infinite recursion. if (port.getNode() == input.getNode()) throw new IllegalArgumentException("The output port cannot be on the same node as the input port."); outputs.add(port); return true; } 
public boolean removeOutput ( Port port ) throws IllegalArgumentException { if ( ! outputs . contains ( port ) ) throw new IllegalArgumentException ( " The given port does not participate in this connection. " ) ; outputs . remove ( port ) ; return outputs . isEmpty ( ) ; } 
public boolean removeOutputNode ( Node node ) throws IllegalArgumentException { return removeOutput ( node . getOutputPort ( ) ) ; } 
public String toString ( ) { return getOutputs ( ) + " <= " + getInput ( ) ; } 
public void toXml ( StringBuffer xml , String spaces ) { for ( Port output : outputs ) { toXml ( xml , spaces , output ) ; 
protected void toXml ( StringBuffer xml , String spaces , Port output ) { xml . append ( spaces ) ; xml . append ( " <conn " ) ; xml . append ( " output= \" " ) . append ( output . getNode ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " input= \" " ) . append ( getInputNode ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " port= \" " ) . append ( getInput ( ) . getName ( ) ) . append ( " \" " ) ; xml . append ( " /> " ) ; } 
public String toString ( ) { return output + " <= " + input + " : " + getMessage ( ) ; } 
public void addDependency ( T dependency , T dependent ) throws IllegalArgumentException { if ( dependency . equals ( dependent ) ) { throw new IllegalArgumentException ( " The dependency ' " + dependency + " ' refers to itself. " ) ; } nodes . add ( dependency ) ; nodes . add ( dependent ) ; Set < T > dependencies = upstreams . get ( dependent ) ; if ( dependencies = = null ) { dependencies = new HashSet < T > ( ) ; upstreams . put ( dependent , dependencies ) ; } dependencies . add ( dependency ) ; Set < T > dependents = downstreams . get ( dependency ) ; if ( dependents = = null ) { dependents = new HashSet < T > ( ) ; downstreams . put ( dependency , dependents ) ; } dependents . add ( dependent ) ; Check for cycles and remove the dependency if cycles were found. if (hasCycles()) { upstreams.remove(dependent); 
public void addDependency ( T dependency , T dependent , I info ) throws IllegalArgumentException { addDependency ( dependency , dependent ) ; setInfo ( dependent , info ) ; } 
public boolean removeDependency ( T dependency , T dependent ) { Set < T > dependencies = upstreams . get ( dependent ) ; Set < T > dependents = downstreams . get ( dependency ) ; boolean removedSomething = false ; if ( dependencies ! = null ) removedSomething = dependencies . remove ( dependency ) ; if ( dependents ! = null ) removedSomething = dependents . remove ( dependency ) | removedSomething ; return removedSomething ; } 
public boolean hasDependency ( T dependency , T dependent ) { Set < T > dependencies = upstreams . get ( dependent ) ; return dependencies ! = null & & dependencies . contains ( dependency ) ; } 
public void removeInfo ( T node ) { nodeInfo . remove ( node ) ; } 
public boolean removeDependencies ( T dependent ) { Set < T > dependencies = upstreams . get ( dependent ) ; if ( dependencies = = null ) return false ; for ( T dependency : dependencies ) { Set < T > dependents = downstreams . get ( dependency ) ; dependents . remove ( dependent ) ; } upstreams . remove ( dependent ) ; TODO: Check removeInfo(dependent); return true; } 
public boolean removeDependents ( T dependency ) { Set < T > dependents = downstreams . get ( dependency ) ; if ( dependents = = null ) return false ; for ( T dependent : dependents ) { Set < T > dependencies = upstreams . get ( dependent ) ; dependencies . remove ( dependency ) ; TODO: Check removeInfo(dependent); } downstreams.remove(dependency); return true; } 
private boolean hasCycles ( ) { The cycle detector stores its state in the marks map. This map is nulled at the end of the method. marks = new HashMap<T, Color>(nodes.size()); for (T node : nodes) { marks.put(node, Color.WHITE); } for (T node : nodes) { if (marks.get(node) == Color.WHITE) { if (visit(node)) { marks = null; return true; } } } marks = null; return false; } 
private boolean visit ( T node ) { marks . put ( node , Color . GRAY ) ; Set < T > outputNodes = downstreams . get ( node ) ; if ( outputNodes ! = null ) { for ( T output : outputNodes ) { if ( ! marks . containsKey ( output ) ) continue ; if ( marks . get ( output ) = = Color . GRAY ) { return true ; } else if ( marks . get ( output ) = = Color . WHITE ) { if ( visit ( output ) ) return true ; } else { Visiting black vertices is okay. } } } marks.put(node, Color.BLACK); return false; } 
public boolean hasNext ( ) { return q . size ( ) > 0 ; } 
public T next ( ) { T node = q . remove ( ) ; Set < T > children = downstreams . get ( node ) ; if ( children ! = null ) { for ( T child : children ) { q . add ( child ) ; } } return node ; } 
public void remove ( ) { throw new UnsupportedOperationException ( " Remove not supported. " ) ; } 
public void nodeDirty ( Node node ) ; public void nodeUpdated ( Node node ) ; } 
public Object evaluate ( ) throws ExpressionError { return evaluate ( new ProcessingContext ( ) ) ; } 
public Object evaluate ( ProcessingContext context ) throws ExpressionError { markedParameterReferences = new HashSet < WeakReference < Parameter > > ( ) ; ProxyResolverFactory prf = new ProxyResolverFactory ( parameter . getNode ( ) , context , mutable , markedParameterReferences ) ; try { return MVEL . executeExpression ( compiledExpression , prf ) ; 
public String toString ( ) { return String . format ( " InvalidNameException on %s name %s: %s " , source , name , getMessage ( ) ) ; } 
public Object cook ( Node node , ProcessingContext context ) { try { return method . invoke ( null , node , context ) ; 
public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( qName . equals ( " ndbx " ) ) { startNdbxTag ( attributes ) ; 
private void resetState ( ) { state = ParseState . INVALID ; characterData = null ; } 
public void endDocument ( ) throws SAXException { Since parameter expressions can refer to arbitrary other parameters in the network, we need to have the fully created document first before setting expressions. Expressions are evaluated once they are set so they can create dependencies on other parameters. for (Map.Entry<Parameter, String> entry : expressionMap.entrySet()) { entry.getKey().setExpression(entry.getValue()); 
private void startNdbxTag ( Attributes attributes ) throws SAXException { Make sure we use the correct format and file type. String formatVersion = attributes.getValue("formatVersion"); if (formatVersion == null) throw new SAXException("NodeBox file does not have required attribute formatVersion."); if (!formatVersion.equals("0.9")) throw new SAXException("Unknown formatVersion " + formatVersion); 
private void startVarTag ( Attributes attributes ) throws SAXException { Variables that get stored in the NodeBox library. String name = attributes.getValue("name"); String value = attributes.getValue("value"); if (name == null) throw new SAXException("Name attribute is required in var tags."); if (value == null) throw new SAXException("Value attribute is required in var tags."); library.setVariable(name, value); } 
private void startCodeTag ( Attributes attributes ) throws SAXException { String type = attributes . getValue ( " type " ) ; if ( type = = null ) throw new SAXException ( " Type attribute is required in code tags. " ) ; try { currentCodeType = CodeType . valueOf ( type . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { throw new SAXException ( " Invalid type attribute in code tag: should be python or java, not " + type + " . " ) ; } state = ParseState . IN_CODE ; characterData = new StringBuffer ( ) ; } 
private void setLibraryCode ( String code ) throws SAXException { library . setCode ( parseCode ( code ) ) ; } 
private void startNodeTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( " name " ) ; String prototypeId = attributes . getValue ( " prototype " ) ; String dataClassAsString = attributes . getValue ( " dataClass " ) ; if ( name = = null ) throw new SAXException ( " Name attribute is required in node tags. " ) ; if ( prototypeId = = null ) throw new SAXException ( " Prototype attribute is required in node tags. " ) ; Class dataClass = null ; if ( dataClassAsString ! = null ) { try { dataClass = Class . forName ( dataClassAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Given dataclass " + dataClassAsString + " not found. " ) ; } } Node prototype = manager . getNode ( prototypeId ) ; if ( prototype = = null ) throw new SAXException ( " Unknown prototype " + prototypeId + " for node " + name ) ; Node newNode = prototype . newInstance ( library , name , dataClass ) ; Add the child to the node library or its parent if (currentNode == null) { library.add(newNode); } else { currentNode.add(newNode); } Parse additional node flags. if ("true".equals(attributes.getValue("rendered"))) newNode.setRendered(); Go down into the current node; this will now become the current network. currentNode = newNode; } 
private void startDescriptionTag ( Attributes attributes ) throws SAXException { if ( currentNode = = null ) throw new SAXException ( " Description tag encountered without a current node. " ) ; state = ParseState . IN_DESCRIPTION ; characterData = new StringBuffer ( ) ; } 
private void setDescription ( String description ) throws SAXException { if ( currentNode = = null ) throw new SAXException ( " Description tag ended without a current node. " ) ; currentNode . setDescription ( description ) ; } 
private void startParameterTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( " name " ) ; String typeAsString = attributes . getValue ( " type " ) ; if ( currentNode = = null ) throw new SAXException ( " Parameter tag encountered without a current node. " ) ; if ( name = = null ) throw new SAXException ( " Name is required for parameter on node ' " + currentNode . getName ( ) + " '. " ) ; if ( typeAsString = = null ) { No type attribute was given, so the parameter should already exist. 
private void startValueTag ( Attributes attributes ) throws SAXException { if ( currentParameter = = null ) throw new SAXException ( " Value tag encountered without current parameter. " ) ; state = ParseState . IN_VALUE ; characterData = new StringBuffer ( ) ; The value tag should be empty except when the parameter type is code. Then the value tag has a type attribute that specifies the code type. if (currentParameter.getType() != Parameter.Type.CODE) return; String type = attributes.getValue("type"); if (type == null) throw new SAXException("Type attribute is required in code tags."); try { currentCodeType = CodeType.valueOf(type.toUpperCase()); 
private void startExpressionTag ( Attributes attributes ) throws SAXException { if ( currentParameter = = null ) throw new SAXException ( " Expression tag encountered without current parameter. " ) ; state = ParseState . IN_EXPRESSION ; characterData = new StringBuffer ( ) ; } 
private NodeCode parseCode ( String source ) throws SAXException { if ( currentCodeType = = CodeType . PYTHON ) { return new PythonCode ( source ) ; 
private void setTemporaryExpression ( String expression ) throws SAXException { if ( currentParameter = = null ) throw new SAXException ( " There is no current parameter. " ) ; expressionMap . put ( currentParameter , expression ) ; } 
private void startPortTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( " name " ) ; String typeAsString = attributes . getValue ( " type " ) ; String cardinalityAsString = attributes . getValue ( " cardinality " ) ; if ( name = = null ) throw new SAXException ( " Name is required for port on node ' " + currentNode . getName ( ) + " '. " ) ; if ( typeAsString = = null ) throw new SAXException ( " Type is required for port on node ' " + currentNode . getName ( ) + " '. " ) ; Class type ; try { type = Class . forName ( typeAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Class " + typeAsString + " for port " + name + " not found. " ) ; } Port . Cardinality cardinality = Port . Cardinality . SINGLE ; if ( cardinalityAsString ! = null ) { try { cardinality = Port . Cardinality . valueOf ( cardinalityAsString . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { throw new SAXException ( " Invalid cardinality attribute in port tag: should be single or multiple, not " + cardinalityAsString + " . " ) ; } } currentNode . addPort ( name , type , cardinality ) ; } 
private void startConnectionTag ( Attributes attributes ) throws SAXException { output node identifier, without package String outputAsString = attributes.getValue("output"); input node identifier, without package String inputAsString = attributes.getValue("input"); input port identifier String portAsString = attributes.getValue("port"); String currentNodeString = currentNode == null ? "<null>" : currentNode.getName(); if (outputAsString == null) throw new SAXException("Output is required for connection in node '" + currentNodeString + "'."); if (inputAsString == null) throw new SAXException("Input is required for connection in node '" + currentNodeString + "'."); if (portAsString == null) throw new SAXException("Port is required for connection in node '" + currentNodeString + "'."); Node output, input; if (currentNode == null) { output = library.get(outputAsString); input = library.get(inputAsString); } else { output = currentNode.getChild(outputAsString); input = currentNode.getChild(inputAsString); } if (output == null) throw new SAXException("Output node '" + outputAsString + "' does not exist."); if (input == null) throw new SAXException("Input node '" + inputAsString + "' does not exist."); Port port = input.getPort(portAsString); if (port == null) throw new SAXException("Port '" + portAsString + "' on node '" + inputAsString + "' does not exist."); port.connect(output); } 
public void characters ( char [ ] ch , int start , int length ) throws SAXException { switch ( state ) { case IN_CODE : if ( currentCodeType = = null ) throw new SAXException ( " Code encountered, but no current code type. " ) ; break ; case IN_DESCRIPTION : if ( currentNode = = null ) throw new SAXException ( " Description encountered, but no current node. " ) ; break ; case IN_VALUE : if ( currentParameter = = null ) throw new SAXException ( " Value encountered, but no current parameter. " ) ; break ; case IN_EXPRESSION : if ( currentParameter = = null ) throw new SAXException ( " Expression encountered, but no current parameter. " ) ; default : Bail out when we don't recognize this state. return; } We have a valid character state, so we can safely append to characterData. characterData.append(ch, start, length); } 
public Object cook ( Node node , ProcessingContext context ) { return null ; } 
public boolean isEmpty ( ) { return children . isEmpty ( ) ; } 
public Node create ( Node prototype ) { if ( prototype = = null ) throw new IllegalArgumentException ( " Prototype cannot be null. " ) ; return create ( prototype , null , null ) ; } 
public Node create ( Node prototype , String name ) { return create ( prototype , name , null ) ; } 
public Node create ( Node prototype , Class dataClass ) { return create ( prototype , null , dataClass ) ; } 
public Node create ( Node prototype , String name , Class dataClass ) { if ( prototype = = null ) throw new IllegalArgumentException ( " Prototype cannot be null. " ) ; if ( dataClass = = null ) dataClass = prototype . getOutputPort ( ) . getDataClass ( ) ; if ( name = = null ) name = uniqueName ( prototype . getName ( ) ) ; Node newNode = prototype . rawInstance ( library , name , dataClass ) ; add ( newNode ) ; return newNode ; } 
public boolean remove ( Node node ) { assert ( node ! = null ) ; if ( ! contains ( node ) ) return false ; node.markDirty(); node.disconnect(); node.parent = null; children.remove(node.getName()); if (node == renderedChild) { setRenderedChild(null); } node.removeNodeAttributeListener(this); fireNodeRemoved(node); return true; } 
public String uniqueName ( String prefix ) { int counter = 1 ; while ( true ) { String suggestedName = prefix + counter ; 
public boolean contains ( String nodeName ) { return children . containsKey ( nodeName ) ; } 
public boolean contains ( Node node ) { return children . containsValue ( node ) ; } 
public boolean hasChildren ( ) { return ! children . isEmpty ( ) ; } 
public void attributeChanged ( Node source ) { Check if the node exists and remove it in one operation. If remove() returns true, the given node is not a child and we should not store it. if (!children.values().remove(source)) return; children.put(source.getName(), source); } 
public boolean isRendered ( ) { return parent ! = null & & parent . getRenderedChild ( ) = = this ; } 
public Parameter addParameter ( String name , Parameter . Type type , Object value ) { Parameter p = addParameter ( name , type ) ; p . setValue ( value ) ; return p ; } 
public boolean removeParameter ( String name ) { First remove all dependencies to and from this parameter. Don't rewrite any expressions. Parameter p = parameters.get(name); if (p == null) return false; p.removedEvent(); parameters.remove(name); TODO: Fire some more stuff fireNodeAttributeChanged(); markDirty(); return true; } 
public boolean hasParameter ( String name ) { return getParameter ( name ) ! = null ; } 
 void renameParameter ( Parameter p , String oldName , String newName ) { assert ( p . getName ( ) . equals ( newName ) ) ; parameters . remove ( oldName ) ; parameters . put ( newName , p ) ; } 
public String asString ( String parameterName ) { Parameter p = getParameter ( parameterName ) ; No type checking is performed here. Any parameter type can be converted to a String. return p.asString(); } 
public void setValue ( String parameterName , Object value ) throws IllegalArgumentException { Parameter p = parameters . get ( parameterName ) ; if ( p = = null ) throw new IllegalArgumentException ( " Parameter " + parameterName + " does not exist. " ) ; p . setValue ( value ) ; } 
public void silentSet ( String parameterName , Object value ) { try { setValue ( parameterName , value ) ; 
public Port addPort ( String name , Class dataClass ) { return addPort ( name , dataClass , Port . Cardinality . SINGLE ) ; } 
public Port addPort ( String name , Class dataClass , Port . Cardinality cardinality ) { Port p = new Port ( this , name , dataClass , cardinality ) ; ports . put ( name , p ) ; if ( parent ! = null ) { if ( parent . childGraph = = null ) parent . childGraph = new DependencyGraph < Port , Connection > ( ) ; parent . childGraph . addDependency ( p , outputPort ) ; } return p ; } 
public void removePort ( String name ) { throw new UnsupportedOperationException ( " removePort is not implemented yet. " ) ; TODO: Implement, make sure to remove internal dependencies. 
public boolean hasPort ( String portName ) { return ports . containsKey ( portName ) ; } 
public void addDirtyListener ( DirtyListener l ) { listenerList . add ( DirtyListener . class , l ) ; } 
public void removeDirtyListener ( DirtyListener l ) { listenerList . remove ( DirtyListener . class , l ) ; } 
public void fireNodeDirty ( ) { Some event listeners remove themselves from the node as a result of handling the event. This modifies the listener list, and can cause some listeners to be skipped. By counting backwards, listeners can remove themselves without causing problems. This technique was adapted from Swing Hacks. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == DirtyListener.class) { 
public void fireNodeUpdated ( ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == DirtyListener.class) { 
public void addNodeAttributeListener ( NodeAttributeListener l ) { listenerList . add ( NodeAttributeListener . class , l ) ; } 
public void removeNodeAttributeListener ( NodeAttributeListener l ) { listenerList . remove ( NodeAttributeListener . class , l ) ; } 
public void fireNodeAttributeChanged ( ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeAttributeListener.class) { ((NodeAttributeListener) listeners[i + 1]).attributeChanged(this); } } if (hasParent()) getParent().fireChildAttributeChanged(this); 
public void addNodeChildListener ( NodeChildListener l ) { listenerList . add ( NodeChildListener . class , l ) ; } 
public void removeNodeChildListener ( NodeChildListener l ) { listenerList . remove ( NodeChildListener . class , l ) ; } 
public void fireChildAdded ( Node child ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeChildListener.class) { 
public void fireChildRemoved ( Node child ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeChildListener.class) { 
public void fireConnectionAdded ( Connection c ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeChildListener.class) { 
public void fireConnectionRemoved ( Connection c ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeChildListener.class) { 
public void fireRenderedChildChanged ( Node child ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeChildListener.class) { 
public void fireChildAttributeChanged ( Node child ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeChildListener.class) { 
public void addParameterValueListener ( ParameterValueListener l ) { listenerList . add ( ParameterValueListener . class , l ) ; } 
public void removeParameterValueListener ( ParameterValueListener l ) { listenerList . remove ( ParameterValueListener . class , l ) ; } 
public void fireParameterValueChanged ( Parameter source ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == ParameterValueListener.class) { 
public void addParameterAttributeListener ( ParameterAttributeListener l ) { listenerList . add ( ParameterAttributeListener . class , l ) ; } 
public void removeParameterAttributeListener ( ParameterAttributeListener l ) { listenerList . remove ( ParameterAttributeListener . class , l ) ; } 
public void fireParameterAttributeChanged ( Parameter source ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == ParameterAttributeListener.class) { 
public Connection connect ( Node inputNode , String portName , Node outputNode ) { Port outputPort = outputNode . getOutputPort ( ) ; Port inputPort = inputNode . getPort ( portName ) ; return connect ( inputPort , outputPort ) ; } 
public boolean disconnect ( Port port ) { if ( port = = null ) throw new IllegalArgumentException ( " The input port cannot be null. " ) ; if ( port . getNode ( ) ! = this ) throw new IllegalArgumentException ( " The input port is not on this node. " ) ; Node parent = port . getNode ( ) . getParent ( ) ; if ( parent = = null ) return false ; DependencyGraph < Port , Connection > dg = parent . childGraph ; if ( dg = = null ) return false ; if ( ! port . isConnected ( ) ) return false ; if ( port . isInputPort ( ) ) { boolean removedSomething = dg . removeDependencies ( port ) ; 
public boolean isConnected ( ) { if ( parent = = null ) return false ; if ( parent . childGraph = = null ) return false ; Check output port for downstream connections. We check this first because it goes fast. if (parent.childGraph.getDependents(outputPort).size() > 0) return true; Check parameters for upstream connections. for (Port p : ports.values()) { if (parent.childGraph.getDependencies(p).size() > 0) return true; } return false; } 
public boolean isConnected ( Port port ) { if ( port = = null ) throw new IllegalArgumentException ( " Port cannot be null. " ) ; if ( port . getNode ( ) ! = this ) throw new IllegalArgumentException ( " This node does not own the given port. " ) ; The port needs to be in a parent to be connected. if (parent == null) return false; if (parent.childGraph == null) return false; if (port.isInputPort()) return parent.childGraph.getDependencies(port).size() > 0; 
public boolean isConnectedTo ( Port port1 , Port port2 ) throws IllegalArgumentException { The order of the ports is unimportant, but one needs to be an input and the other an output. If the two ports have the same direction, they can never be connected. if (port1.getDirection() == port2.getDirection()) return false; Port output = port1.isOutputPort() ? port1 : port2; Port input = port1.isInputPort() ? port1 : port2; return output.getNode().isConnectedTo(input.getNode()); } 
public boolean isConnectedTo ( Node other ) { if ( other = = null ) return false ; if ( other = = this ) return false ; if ( this . isOutputConnectedTo ( other ) ) { return true ; } else if ( other . isOutputConnectedTo ( this ) ) { return true ; } return false ; } 
public boolean isInputConnectedTo ( Node outputNode ) { return outputNode . isOutputConnectedTo ( this ) ; } 
public boolean isOutputConnected ( ) { return outputPort . isConnected ( ) ; } 
public boolean isOutputConnectedTo ( Node inputNode ) { if ( inputNode = = null ) throw new IllegalArgumentException ( " Input node cannot be null. " ) ; Both nodes need to have the same parent to be connected. if (parent == null || inputNode.parent == null || parent != inputNode.parent) return false; if (parent.childGraph == null) return false; Port output = getOutputPort(); for (Port p : inputNode.ports.values()) { if (parent.childGraph.hasDependency(output, p)) return true; } return false; } 
public boolean isOutputConnectedTo ( Port input ) { if ( input = = null ) throw new IllegalArgumentException ( " Input port cannot be null. " ) ; if ( ! input . isInputPort ( ) ) throw new IllegalArgumentException ( " The given port is not an input. " ) ; return parent ! = null & & parent . childGraph ! = null & & parent . childGraph . hasDependency ( outputPort , input ) ; } 
public void update ( ) throws ProcessingError { update ( new ProcessingContext ( ) ) ; } 
public void update ( ProcessingContext ctx ) throws ProcessingError { if ( ! dirty ) return ; Update all upstream nodes. if (parent != null && parent.childGraph != null) { for (Port port : ports.values()) { Connection conn = parent.childGraph.getInfo(port); if (conn == null) continue; Updating the connection sets the value of the corresponding input port. conn.update(ctx); } } Update all parameter expressions. for (Parameter param : parameters.values()) { try { param.update(ctx); } catch (Exception e) { throw new ProcessingError(this, "Error occurred while updating parameter " + param + ": " + e.getMessage(), e); } } All dependencies are up-to-date. Process the node. process(ctx); Because the dirty flag gets reset *after* the node has processed, nodes that throw a ProcessingError are not marked as clean. dirty = false; fireNodeUpdated(); } 
public void process ( ProcessingContext ctx ) throws ProcessingError { try { NodeCode code = asCode ( " _code " ) ; 
public Object cook ( Node node , ProcessingContext context ) throws ProcessingError { Node renderedChild = node . getRenderedChild ( ) ; if ( renderedChild = = null ) throw new ProcessingError ( this , " No child node to render. " ) ; renderedChild . update ( context ) ; return renderedChild . getOutputValue ( ) ; } 
public static Object doNothing ( Node , ProcessingContext ctx ) { return null ; } 
public Handle createHandle ( ) { NodeCode handleCode = asCode ( " _handle " ) ; if ( handleCode = = null ) return null ; TODO: Do we need the ProcessingContext in the handle or can we pass null? Object handleObj = handleCode.cook(this, new ProcessingContext()); if (!(handleObj instanceof Handle)) throw new AssertionError("Handle code for node " + getName() + " does not return Handle object."); return (Handle) handleObj; } 
public Node newInstance ( NodeLibrary library , String name ) { return newInstance ( library , name , outputPort . getDataClass ( ) ) ; } 
public Node newInstance ( NodeLibrary library , String name , Class dataClass ) { Node = rawInstance ( library , name , dataClass ) ; library . add ( ) ; return ; if (library == null) throw new IllegalArgumentException("Library parameter cannot be null."); 
private Node rawInstance ( NodeLibrary library , String name , Class dataClass ) { if ( library = = null ) throw new IllegalArgumentException ( " Library parameter cannot be null. " ) ; if ( dataClass = = null ) dataClass = outputPort . getDataClass ( ) ; Node = new Node ( library , name , dataClass ) ; . prototype = this ; . dirty = true ; Clone all parameters. for (Parameter p : parameters.values()) { n.parameters.put(p.getName(), p.clone(n)); } Clone all ports. for (Port p : ports.values()) { n.ports.put(p.getName(), p.clone(n)); } return n; } 
public Node copyWithUpstream ( Node newParent ) { throw new UnsupportedOperationException ( " This method is not yet implemented. " ) ; / * 
public String toString ( ) { if ( prototype = = null ) { return String . format ( " <Node %s> " , getIdentifier ( ) ) ; 
public Object put ( Object key , Object value ) { if ( ! mutable ) throw new AssertionError ( " You cannot change the node access proxy. " ) ; String k = key . toString ( ) ; Only search the parameters if (node.hasParameter(k)) { if (markedParameterReferences != null) markedParameterReferences.add(new WeakReference<Parameter>(node.getParameter(k))); Object oldValue = node.getValue(k); node.setValue(k, value); return oldValue; } throw new RuntimeException("Parameter " + k + " not found on node " + node.getName()); } 
public void childAdded ( Node source , Node child ) ; public void childAttributeChanged ( Node source , Node child ) ; } 
public void childRemoved ( Node source , Node child ) ; public void childAttributeChanged ( Node source , Node child ) ; } 
public void connectionAdded ( Node source , Connection connection ) ; public void childAttributeChanged ( Node source , Node child ) ; } 
public void connectionRemoved ( Node source , Connection connection ) ; public void childAttributeChanged ( Node source , Node child ) ; } 
public void renderedChildChanged ( Node source , Node child ) ; public void childAttributeChanged ( Node source , Node child ) ; } 
public Object cook ( Node node , ProcessingContext context ) ; public String getSource ( ) ; public String getType ( ) ; } 
public void add ( Node node ) { if ( node . getLibrary ( ) ! = this ) throw new AssertionError ( " This node is already added to another library. " ) ; The root node can be null in only one case: when we're creating the builtins library. In that case, the rootNode becomes the given node. if (rootNode == null) { rootNode = node; 
public Node get ( String name ) { if ( " root " . equals ( name ) ) return rootNode ; return rootNode . getChild ( name ) ; } 
public Node remove ( String name ) { Node node = rootNode . getChild ( name ) ; if ( node = = null ) return null ; rootNode . remove ( node ) ; return node ; } 
public boolean remove ( Node node ) { return rootNode . remove ( node ) ; } 
public boolean contains ( String nodeName ) { return rootNode . contains ( nodeName ) ; } 
public void store ( ) throws IOException , IllegalArgumentException { if ( file = = null ) throw new IllegalArgumentException ( " Library was not loaded from a file and no file given to store. " ) ; store ( file ) ; } 
public void store ( File f ) throws IOException { FileOutputStream fos = new FileOutputStream ( f ) ; fos . write ( toXml ( ) . getBytes ( " UTF-8 " ) ) ; fos . close ( ) ; } 
private void writeOrderedChild ( StringBuffer xml , List < Node > children , Node child ) { Node prototype = child . getPrototype ( ) ; if ( prototype . getLibrary ( ) = = this & & children . contains ( prototype ) ) writeOrderedChild ( xml , children , prototype ) ; child . toXml ( xml , " " ) ; children . remove ( child ) ; } 
public void addParameterDependency ( Parameter dependency , Parameter dependent ) { parameterGraph . addDependency ( dependency , dependent ) ; } 
public void removeParameterDependencies ( Parameter p ) { parameterGraph . removeDependencies ( p ) ; } 
public void removeParameterDependents ( Parameter p ) { parameterGraph . removeDependents ( p ) ; } 
public NodeLibrary get ( String libraryName ) { return libraries . get ( libraryName ) ; } 
public void add ( NodeLibrary library ) { libraries . put ( library . getName ( ) , library ) ; } 
public void remove ( NodeLibrary library ) { libraries . remove ( library . getName ( ) ) ; } 
public boolean contains ( String libraryName ) { return libraries . containsKey ( libraryName ) ; } 
public boolean hasNode ( String identifier ) { return getNode ( identifier ) ! = null ; } 
public NodeLibrary load ( String libraryName , String xml ) { try { if ( contains ( libraryName ) ) 
public NodeLibrary load ( File f ) throws RuntimeException { try { The library name is the file name without the ".ndbx" extension. 
private void load ( NodeLibrary library , InputStream is ) throws IOException , ParserConfigurationException , SAXException { Because the library can define both prototypes and instances that use these prototypes, we need to be able to retrieve nodes from this library as well. The handler uses manager.getNode() to retrieve a prototype, so we need to add the library in advance to be able to load nodes from it. add(library); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); NDBXHandler handler = new NDBXHandler(this, library); parser.parse(is, handler); } 
public static NodeCode getCode ( String identifier ) throws IllegalArgumentException { Matcher m = CODE_PATTERN . matcher ( identifier ) ; if ( ! m . matches ( ) | | m . groupCount ( ) ! = 4 ) { throw new IllegalArgumentException ( " The given identifier ' " + identifier + " ' is not valid. " ) ; } String runtime = m . group ( 1 ) ; String className = m . group ( 2 ) ; This is group 4, because of the nested group in our regex pattern. String methodName = m.group(4); if (!"java".equals(runtime)) { throw new IllegalArgumentException("Invalid runtime; only java is supported."); } Class clazz; try { clazz = Class.forName(className); } catch (ClassNotFoundException e) { throw new IllegalArgumentException("The class '" + className + "' could not be found.", e); } try { return new JavaMethodWrapper(clazz, methodName); 
public void setName ( String name ) throws InvalidNameException { if ( name ! = null & & getName ( ) . equals ( name ) ) return ; validateName ( name ) ; String oldName = this . name ; this . name = name ; node . renameParameter ( this , oldName , name ) ; node . fireNodeAttributeChanged ( ) ; } 
public void validateName ( String name ) { if ( name = = null | | name . trim ( ) . length ( ) = = 0 ) throw new InvalidNameException ( this , name , " Name cannot be null or empty. " ) ; if ( node . hasParameter ( name ) ) throw new InvalidNameException ( this , name , " There is already a parameter named " + name + " . " ) ; if ( node . hasPort ( name ) ) throw new InvalidNameException ( this , name , " There is already a port named " + name + " . " ) ; Use the same validation as for nodes. Node.validateName(name); } 
private void clampToBounds ( ) { if ( type = = Type . INT ) { int v = ( Integer ) value ; 
private void fireAttributeChanged ( ) { node . fireParameterAttributeChanged ( this ) ; } 
public int asInt ( ) { if ( type = = Type . INT ) { return ( Integer ) value ; 
public float asFloat ( ) { if ( type = = Type . INT ) { int v = ( Integer ) value ; 
public String asString ( ) { if ( value = = null ) return null ; if ( type = = Type . STRING ) { return ( String ) value ; 
public boolean asBoolean ( ) { if ( type = = Type . INT ) { int v = ( Integer ) value ; 
public Color asColor ( ) { if ( type = = Type . COLOR ) { return ( Color ) getValue ( ) ; 
public NodeCode asCode ( ) { if ( type = = Type . CODE ) { return ( NodeCode ) getValue ( ) ; 
public String asExpression ( ) { if ( type = = Type . INT ) { return String . valueOf ( ( Integer ) value ) ; 
public void set ( Object value ) throws IllegalArgumentException { setValue ( value ) ; } 
public void setValue ( Object value ) throws IllegalArgumentException { if ( hasExpression ( ) ) { throw new IllegalArgumentException ( " The parameter has an expression set. " ) ; } validate throws IllegalArgumentException when the value fails validation. validate(value); if (this.value.equals(value)) return; As a special exception, integer values can be cast up to floating-point values. if (value instanceof Integer && type == Type.FLOAT) { this.value = (float) ((Integer) value); } else { this.value = value; } markDirty(); } 
private void markDirty ( ) { if ( dirty ) return ; dirty = true ; fireValueChanged ( ) ; } 
public void clearExpression ( ) { this . expression = null ; removeDependencies ( ) ; fireValueChanged ( ) ; } 
private void addDependency ( Parameter p ) { getLibrary ( ) . addParameterDependency ( p , this ) ; } 
private void removeDependencies ( ) { getLibrary ( ) . removeParameterDependencies ( this ) ; 
private void dependencyChangedEvent ( Parameter p ) { markDirty ( ) ; getNode().markDirty(); 
public void removedEvent ( ) { removeDependencies ( ) ; removeDependents ( ) ; } 
public void update ( ProcessingContext context ) throws ExpressionError { if ( ! dirty ) return ; To avoid infinite recursion, we set dirty to false before processing any of the dependencies. If we come by this parameter again, we have already updated it. dirty = false; if (hasExpression()) { Update all dependencies. 
public void revertToDefault ( ) { this . value = getDefaultValue ( ) ; fireValueChanged ( ) ; } 
public Object parseValue ( String value ) throws IllegalArgumentException { return parseValue ( value , type ) ; } 
public static Object parseValue ( String value , Type type ) throws IllegalArgumentException { if ( type = = Type . INT ) { try { 
public void toXml ( StringBuffer xml , String spaces ) { We only write out the attributes that have changed with regards to the prototype. Node protoNode = getNode().getPrototype(); Parameter protoParam = null; if (protoNode != null) protoParam = protoNode.getParameter(getName()); If the parameter and its prototype are completely equal, don't write anything. if (prototypeEquals(protoParam)) return; The parameters are not equal, so we can start writing the name. xml.append(spaces).append("<param name=\"").append(getName()).append("\""); Write parameter type if (protoParam == null || getType().equals(protoParam.getType())) xml.append(" type=\"").append(getType().toString().toLowerCase()).append("\""); xml.append(">"); Write parameter value / expression if (hasExpression()) { xml.append(spaces).append("<expression>").append(getExpression()).append("</expression>"); } else { if (type == Type.INT) { xml.append(spaces).append(" <value>").append(asInt()).append("</value>"); } else if (type == Type.FLOAT) { xml.append(spaces).append(" <value>").append(asFloat()).append("</value>"); } else if (type == Type.STRING) { xml.append(spaces).append(" <value>").append(asString()).append("</value>"); } else if (type == Type.COLOR) { xml.append(spaces).append(" <value>").append(asColor().toString()).append("</value>"); } else if (type == Type.CODE) { xml.append(spaces).append(" <value type=\"").append(asCode().getType()).append("\"><![CDATA[").append(asCode().getSource()).append("]]></value>"); } else { throw new AssertionError("Unknown value class " + type); } } xml.append(spaces).append("</param>"); } 
private boolean prototypeEquals ( Parameter o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Parameter parameter = ( Parameter ) o ; if ( boundingMethod ! = parameter . boundingMethod ) return false ; if ( displayLevel ! = parameter . displayLevel ) return false ; if ( expression ! = null ? ! expression . equals ( parameter . expression ) : parameter . expression ! = null ) return false ; if ( helpText ! = null ? ! helpText . equals ( parameter . helpText ) : parameter . helpText ! = null ) return false ; if ( ! label . equals ( parameter . label ) ) return false ; if ( maximumValue ! = null ? ! maximumValue . equals ( parameter . maximumValue ) : parameter . maximumValue ! = null ) return false ; if ( ! menuItems . equals ( parameter . menuItems ) ) return false ; if ( minimumValue ! = null ? ! minimumValue . equals ( parameter . minimumValue ) : parameter . minimumValue ! = null ) return false ; if ( ! name . equals ( parameter . name ) ) return false ; if ( type ! = parameter . type ) return false ; if ( value ! = null ? ! value . equals ( parameter . value ) : parameter . value ! = null ) return false ; if ( widget ! = parameter . widget ) return false ; return true ; } 
public Parameter copyWithUpstream ( Node newNode ) { throw new UnsupportedOperationException ( " Not yet supported. " ) ; / * 
private Object cloneValue ( Object value ) { if ( value instanceof Color ) { return new Color ( ( Color ) value ) ; 
public void validateName ( String name ) { if ( name = = null | | name . trim ( ) . length ( ) = = 0 ) throw new InvalidNameException ( this , name , " Name cannot be null or empty. " ) ; if ( node . hasPort ( name ) ) throw new InvalidNameException ( this , name , " There is already a port named " + name + " . " ) ; if ( node . hasParameter ( name ) ) throw new InvalidNameException ( this , name , " There is already a parameter named " + name + " . " ) ; Use the same validation as for nodes. Node.validateName(name); } 
public void validate ( Object value ) throws IllegalArgumentException { Null is accepted as a default value. if (value == null) return; if (!dataClass.isAssignableFrom(value.getClass())) throw new IllegalArgumentException("Value " + value + " is not of required class (was " + value.getClass() + ", required " + dataClass); 
public void setValue ( Object value ) throws IllegalArgumentException { if ( cardinality ! = Cardinality . SINGLE ) throw new AssertionError ( " You can only call setValue when cardinality is SINGLE. " ) ; validate ( value ) ; this . value = value ; } 
public void addValue ( Object value ) throws IllegalArgumentException { if ( cardinality ! = Cardinality . MULTIPLE ) throw new AssertionError ( " You can only call addValue when cardinality is MULTIPLE. " ) ; validate ( value ) ; if ( values = = null ) values = new ArrayList < Object > ( ) ; values . add ( value ) ; } 
public void reset ( ) { value = null ; values = null ; } 
public boolean isInputPort ( ) { return direction = = Direction . IN ; } 
public boolean isOutputPort ( ) { return direction = = Direction . OUT ; } 
public boolean isConnected ( ) { return node . isConnected ( this ) ; } 
public boolean isConnectedTo ( Port port ) { if ( ! isConnected ( ) ) return false ; return node . isConnectedTo ( this , port ) ; } 
public boolean isConnectedTo ( Node outputNode ) { return isConnectedTo ( outputNode . getOutputPort ( ) ) ; } 
public boolean canConnectTo ( Node outputNode ) { if ( outputNode = = null ) return false ; if ( getNode ( ) = = outputNode ) return false ; return canConnectTo ( outputNode . getOutputPort ( ) ) ; } 
public boolean canConnectTo ( Port outputPort ) { if ( outputPort = = null ) return false ; if ( outputPort = = this ) return false ; if ( outputPort . getDirection ( ) ! = Direction . OUT ) return false ; An input port can only be connected to an output port. Since we just checked the direction of the output port, we need to make sure if this port is an input. if (direction != Direction.IN) return false; Check if the data classes match. They can either be equal, or the output type can be downcasted to the input type. Class inputClass = getDataClass(); Class outputClass = outputPort.getDataClass(); return inputClass.isAssignableFrom(outputClass); } 
public Connection connect ( Node outputNode ) throws IllegalArgumentException { if ( outputNode = = null ) throw new IllegalArgumentException ( " Output node cannot be null. " ) ; if ( getParentNode ( ) = = null ) throw new IllegalArgumentException ( " This port has no parent node. " ) ; return getNode ( ) . connect ( this , outputNode . getOutputPort ( ) ) ; } 
public void disconnect ( ) { getNode ( ) . disconnect ( this ) ; } 
public Port clone ( Node ) { return new Port ( , getName ( ) , getDataClass ( ) , getCardinality ( ) , getDirection ( ) ) ; } 
public String toString ( ) { return node . getName ( ) + " . " + getName ( ) ; } 
public void toXml ( StringBuffer xml , String spaces ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = getNode().getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getPort(getName()); If the port and its prototype are equal, don't write anything. if (protoPort != null && protoPort.getName().equals(getName()) && protoPort.getDataClass().equals(getDataClass()) && protoPort.getDirection().equals(getDirection()) && protoPort.getCardinality().equals(getCardinality())) return; xml.append(spaces) .append("<port name=\"") .append(getName()) .append("\" type=\"") .append(getDataClass().getName()); if (getCardinality() != Cardinality.SINGLE) xml.append("\" cardinality=\"") .append(getCardinality().toString().toLowerCase()); xml.append("\"/>"); } 
private void preCook ( ) { The namespace will remain bound to the interpreter. Changes to this dictionary will affect the namespace of the interpreter. namespace = new PyDictionary(); PythonInterpreter interpreter = new PythonInterpreter(namespace); Immediately run the code to extract the cook(self) method. interpreter.exec(source); try { cookFunction = (PyFunction) interpreter.get("cook"); 
public Object cook ( Node node , ProcessingContext context ) throws RuntimeException { if ( cookFunction = = null ) preCook ( ) ; Add globals into the function namespace. namespace.put("FRAME", context.getFrame()); PyObject self; if (node == null) { self = Py.None; } else { self = new SelfWrapper(node); } PyObject pyResult = cookFunction.__call__(self); Unwrap the result. Object result = pyResult.__tojava__(Object.class); if (result == Py.NoConversion) { throw new RuntimeException("Cannot convert Python object " + pyResult + " to java."); } return result; } 
public PyObject __findattr_ex__ ( String name ) { if ( " node " . equals ( name ) ) return Py . java2py ( node ) ; Parameter p = node . getParameter ( name ) ; if ( p = = null ) { Port port = node . getPort ( name ) ; 
public void noParameterOrPortError ( String name ) { throw Py . AttributeError ( String . format ( " Node '%.50s' has no parameter or port '%.400s' " , node . getIdentifier ( ) , name ) ) ; 
public void testDirty ( ) { Node ng = numberNode . newInstance ( testLibrary , " number1 " ) ; assertTrue ( ng . isDirty ( ) ) ; ng . update ( ) ; assertFalse ( ng . isDirty ( ) ) ; assertEquals ( 0 , ng . getOutputValue ( ) ) ; ng . setValue ( " value " , 12 ) ; assertTrue ( ng . isDirty ( ) ) ; Asking for the output value doesn't update the node implicitly. assertEquals(0, ng.getOutputValue()); You have to explicitly update the node to get the new output value. ng.update(); assertFalse(ng.isDirty()); assertEquals(12, ng.getOutputValue()); } 
public void testConnect ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node multiply1 = multiplyNode . newInstance ( testLibrary , " multiply1 " ) ; Node upper1 = convertToUppercaseNode . newInstance ( testLibrary , " upper1 " ) ; assertFalse ( multiply1 . getPort ( " v1 " ) . isConnected ( ) ) ; assertFalse ( multiply1 . getPort ( " v1 " ) . isConnectedTo ( number1 ) ) ; assertFalse ( number1 . isOutputConnected ( ) ) ; assertFalse ( number1 . isOutputConnectedTo ( multiply1 ) ) ; assertFalse ( number1 . isOutputConnectedTo ( multiply1 . getPort ( " v1 " ) ) ) ; assertTrue ( multiply1 . getPort ( " v1 " ) . canConnectTo ( number1 ) ) ; assertTrue ( multiply1 . getPort ( " v2 " ) . canConnectTo ( number1 ) ) ; assertFalse ( convertToUppercaseNode . getPort ( " value " ) . canConnectTo ( number1 ) ) ; Connection conn = multiply1 . getPort ( " v1 " ) . connect ( number1 ) ; assertTrue ( multiply1 . getPort ( " v1 " ) . isConnected ( ) ) ; assertTrue ( multiply1 . getPort ( " v1 " ) . isConnectedTo ( number1 ) ) ; assertTrue ( number1 . isOutputConnected ( ) ) ; assertTrue ( number1 . isOutputConnectedTo ( multiply1 ) ) ; assertTrue ( number1 . isOutputConnectedTo ( multiply1 . getPort ( " v1 " ) ) ) ; assertEquals ( multiply1 . getPort ( " v1 " ) , conn . getInput ( ) ) ; assertEquals ( number1 . getOutputPort ( ) , conn . getOutput ( ) ) ; assertEquals ( multiply1 , conn . getInputNode ( ) ) ; assertEquals ( number1 , conn . getOutputNode ( ) ) ; assertConnectionError ( upper1 , " value " , number1 , " Value is of the wrong type and should not be connectable to NumberIn's output. " ) ; } 
public void testConnectCasting ( ) { Node upstream , downstream ; Both are of the same type. Should be able to connect. upstream = Node.ROOT_NODE.newInstance(testLibrary, "upstream", HashMap.class); downstream = Node.ROOT_NODE.newInstance(testLibrary, "downstream"); downstream.addPort("value", HashMap.class); downstream.getPort("value").connect(upstream); Reset the library testLibrary = new NodeLibrary("test"); Upstream is a more specific type, which is allowed. upstream = Node.ROOT_NODE.newInstance(testLibrary, "upstream", LinkedHashMap.class); downstream = Node.ROOT_NODE.newInstance(testLibrary, "downstream"); downstream.addPort("value", HashMap.class); downstream.getPort("value").connect(upstream); Reset the library testLibrary = new NodeLibrary("test"); Now downstream is more specific, which is NOT allowed. upstream = Node.ROOT_NODE.newInstance(testLibrary, "upstream", HashMap.class); downstream = Node.ROOT_NODE.newInstance(testLibrary, "downstream"); downstream.addPort("value", LinkedHashMap.class); assertConnectionError(downstream, "value", upstream, "Downstream is a more specific type."); Reset the library testLibrary = new NodeLibrary("test"); Downstream is an interface which upstream implements. upstream = Node.ROOT_NODE.newInstance(testLibrary, "upstream", LinkedHashMap.class); downstream = Node.ROOT_NODE.newInstance(testLibrary, "downstream"); downstream.addPort("value", Map.class); downstream.getPort("value").connect(upstream); } 
public void testCycles ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; assertConnectionError(ng, "number", ng, "Nodes cannot connect to themselves."); 
public void testDirtyPropagation ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node addConstant1 = addConstantNode . newInstance ( testLibrary , " addConstant1 " ) ; Nodes start out dirty assertTrue(number1.isDirty()); assertTrue(addConstant1.isDirty()); Updating makes them clean number1.update(); addConstant1 will throw an error since it needs input. assertProcessingError(addConstant1, NullPointerException.class); assertFalse(number1.isDirty()); When a node throws an error it is not clean. assertTrue(addConstant1.isDirty()); Connecting the add constant to another node makes it dirty. The output (upstream) node doesn't become dirty. addConstant1.getPort("value").connect(number1); assertFalse(number1.isDirty()); assertTrue(addConstant1.isDirty()); addConstant1.update(); assertFalse(number1.isDirty()); This shouldn't have changed. assertFalse(addConstant1.isDirty()); A change to the upstream node should make downstream nodes dirty. number1.setValue("value", 12); assertTrue(number1.isDirty()); assertTrue(addConstant1.isDirty()); Updating the downstream node should make all upstreams clean, because their output values are needed to calculate the downstream. addConstant1.update(); assertFalse(number1.isDirty()); assertFalse(addConstant1.isDirty()); Changes to the downstream node don't affect upstreams. addConstant1.setValue("constant", 1); assertFalse(number1.isDirty()); assertTrue(addConstant1.isDirty()); addConstant1.update(); assertFalse(addConstant1.isDirty()); Disconnecting makes the downstream dirty. addConstant1.getPort("value").disconnect(); assertFalse(number1.isDirty()); assertTrue(addConstant1.isDirty()); Connect addConstant1 to a new node. Node number2 = numberNode.newInstance(testLibrary, "number2"); addConstant1.getPort("value").connect(number2); Check if disconnected nodes still propagate. number1.update(); assertFalse(number1.isDirty()); assertTrue(addConstant1.isDirty()); addConstant1.update(); assertFalse(addConstant1.isDirty()); number1.setValue("value", 13); assertTrue(number1.isDirty()); assertFalse(addConstant1.isDirty()); } 
public void testValuePropagation ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node number2 = numberNode . newInstance ( testLibrary , " number2 " ) ; Node m = multiplyNode . newInstance ( testLibrary , " multiply1 " ) ; m . getPort ( " v1 " ) . connect ( number1 ) ; m . getPort ( " v2 " ) . connect ( number2 ) ; assertNull ( m . getOutputValue ( ) ) ; number1 . setValue ( " value " , 3 ) ; number2 . setValue ( " value " , 2 ) ; assertTrue ( m . isDirty ( ) ) ; assertNull ( m . getOutputValue ( ) ) ; Updating the NumberIn node has no effect on the multiplier node. number1.update(); assertTrue(m.isDirty()); assertNull(m.getOutputValue()); m.update(); assertFalse(m.isDirty()); assertEquals(6, m.getOutputValue()); Test if value stops propagating after disconnection. m.getPort("v1").disconnect(); assertFalse(m.getPort("v1").isConnected()); assertTrue(m.isDirty()); The value is still the old value because the node has not been updated yet. assertEquals(6, m.getOutputValue()); assertFalse(number1.isDirty()); number1.setValue("value", 3); assertProcessingError(m, NullPointerException.class); assertNull(m.getOutputValue()); } 
public void testDisconnect ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node number2 = numberNode . newInstance ( testLibrary , " number2 " ) ; Node m = multiplyNode . newInstance ( testLibrary , " multiply1 " ) ; number1 . setValue ( " value " , 5 ) ; number2 . setValue ( " value " , 2 ) ; m . getPort ( " v1 " ) . connect ( number1 ) ; m . getPort ( " v2 " ) . connect ( number2 ) ; assertTrue ( m . getPort ( " v1 " ) . isConnected ( ) ) ; assertTrue ( number1 . isOutputConnected ( ) ) ; m . update ( ) ; assertEquals ( 5 , m . getPort ( " v1 " ) . getValue ( ) ) ; assertEquals ( 10 , m . getOutputValue ( ) ) ; Disconnecting a port makes the dependent nodes dirty, but not the upstream nodes. "Dirt flows downstream" m.getPort("v1").disconnect(); assertTrue(m.isDirty()); assertFalse(number1.isDirty()); assertFalse(m.getPort("v1").isConnected()); assertFalse(number1.isOutputConnected()); The value of the input port is set to null after disconnection. Since our simple multiply node doesn't handle null, it throws a NullPointerException, which gets wrapped in a ProcessingError. assertProcessingError(m, NullPointerException.class); assertNull(m.getOutputValue()); } 
public void testOnlyOneConnect ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node number2 = numberNode . newInstance ( testLibrary , " number2 " ) ; Node negate1 = negateNode . newInstance ( testLibrary , " negate1 " ) ; negate1 . getPort ( " value " ) . connect ( number1 ) ; assertTrue ( number1 . isConnected ( ) ) ; assertFalse ( number2 . isConnected ( ) ) ; assertTrue ( negate1 . isConnected ( ) ) ; Now change the connection to number2. negate1.getPort("value").connect(number2); assertFalse(number1.isConnected()); assertTrue(number2.isConnected()); assertTrue(negate1.isConnected()); } 
public void testRemove ( ) { First add a node Node net = testNetworkNode.newInstance(testLibrary, "net1"); Node number1 = net.create(numberNode); number1.setValue("value", 42); number1.setRendered(); net.update(); assertEquals(42, net.getOutputValue()); Now remove and update again net.remove(number1); assertNull(net.getRenderedChild()); This should cause the network to complain that there is no node to render. assertProcessingError(net, ProcessingError.class); The output value should revert to null. assertEquals(null, net.getOutputValue()); } 
public void testMultiConnect ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net1 " ) ; Node number1 = net . create ( numberNode ) ; number1 . setValue ( " value " , 5 ) ; Node number2 = net . create ( numberNode ) ; number2 . setValue ( " value " , 10 ) ; Node multiAdd1 = net . create ( multiAddNode ) ; multiAdd1 . getPort ( " values " ) . connect ( number1 ) ; multiAdd1 . getPort ( " values " ) . connect ( number2 ) ; assertTrue ( number1 . isConnected ( ) ) ; assertTrue ( number2 . isConnected ( ) ) ; multiAdd1 . setRendered ( ) ; Test default behaviour net.update(); assertFalse(net.isDirty()); assertFalse(multiAdd1.isDirty()); assertEquals(15, net.getOutputValue()); Change number1 and see if the change propagates. number1.setValue("value", 3); assertTrue(net.isDirty()); assertTrue(multiAdd1.isDirty()); net.update(); assertEquals(13, net.getOutputValue()); change number2 and see if the change propagates. number2.setValue("value", 4); assertTrue(net.isDirty()); assertTrue(multiAdd1.isDirty()); net.update(); assertEquals(7, net.getOutputValue()); } 
public void testTopNodes ( ) { DependencyGraph < Character , Object > dg ; List < Character > topNodes ; Construct a simple graph: A <- B <- C dg = new DependencyGraph<Character, Object>(); dg.addDependency('A', 'B'); dg.addDependency('B', 'C'); topNodes = dg.getTopNodes(); assertEquals(1, topNodes.size()); assertTrue(topNodes.contains('A')); Construct a graph with no dependencies: A, B, C dg = new DependencyGraph<Character, Object>(); dg.addNode('A'); dg.addNode('B'); dg.addNode('C'); topNodes = dg.getTopNodes(); assertEquals(3, topNodes.size()); assertTrue(topNodes.contains('A')); assertTrue(topNodes.contains('B')); assertTrue(topNodes.contains('C')); Construct a graph with more complex dependencies: A <- B, A <- C, B <- D dg = new DependencyGraph<Character, Object>(); dg.addDependency('A', 'B'); dg.addDependency('A', 'C'); dg.addDependency('B', 'D'); topNodes = dg.getTopNodes(); assertEquals(1, topNodes.size()); assertTrue(topNodes.contains('A')); } 
public void testCycles ( ) { DependencyGraph < Character , Object > dg ; Direct cycle: A <- A dg = new DependencyGraph<Character, Object>(); assertInvalidDependency(dg, 'A', 'A'); One degree of separation: A <- B <- A dg = new DependencyGraph<Character, Object>(); dg.addDependency('A', 'B'); assertInvalidDependency(dg, 'B', 'A'); assertEquals(0, dg.getDependencies('A').size()); assertEquals('A', (char)dg.getDependencies('B').iterator().next()); Two degrees of separation: A <- B <- C <- A dg = new DependencyGraph<Character, Object>(); dg.addDependency('A', 'B'); dg.addDependency('B', 'C'); assertInvalidDependency(dg, 'C', 'A'); Diamond shape: A <- B <- D, A <- C <- D dg = new DependencyGraph<Character, Object>(); dg.addDependency('A', 'B'); dg.addDependency('A', 'C'); dg.addDependency('B', 'D'); dg.addDependency('C', 'D'); assertInvalidDependency(dg, 'B', 'A'); assertInvalidDependency(dg, 'C', 'A'); assertInvalidDependency(dg, 'D', 'A'); } 
public void testBreadthFirst ( ) { Because of the hashing function, we cannot predict the order of undependent nodes. Therefore, we use our custom assertOneOf method to indicate "one of the following". DependencyGraph<Character, Object> dg; Iterator<Character> it; Simple graph: A <- B dg = new DependencyGraph<Character, Object>(); dg.addDependency('A', 'B'); it = dg.getBreadthFirstIterator(); assertEquals('A', (char)it.next()); assertEquals('B', (char)it.next()); assertFalse(it.hasNext()); No dependencies: A, B, C dg = new DependencyGraph<Character, Object>(); dg.addNode('A'); dg.addNode('B'); dg.addNode('C'); it = dg.getBreadthFirstIterator(); assertOneOf("ABC", it.next()); assertOneOf("ABC", it.next()); assertOneOf("ABC", it.next()); assertFalse(it.hasNext()); Complex: A <- B <- C, B <- D dg = new DependencyGraph<Character, Object>(); dg.addDependency('A', 'B'); dg.addDependency('B', 'C'); dg.addDependency('B', 'D'); it = dg.getBreadthFirstIterator(); assertEquals('A', (char)it.next()); assertEquals('B', (char)it.next()); assertOneOf("CD", it.next()); assertOneOf("CD", it.next()); assertFalse(it.hasNext()); } 
public void testRemoveDependencies ( ) { DependencyGraph < Character , Object > dg ; dg = new DependencyGraph < Character , Object > ( ) ; Z depends on A and B. dg.addDependency('A', 'Z'); dg.addDependency('B', 'Z'); X and Y depend on Z dg.addDependency('Z', 'X'); dg.addDependency('Z', 'Y'); assertTrue(dg.hasDependency('A', 'Z')); assertTrue(dg.hasDependency('B', 'Z')); assertFalse(dg.hasDependency('Z', 'A')); assertTrue(dg.hasDependency('Z', 'X')); assertTrue(dg.hasDependency('Z', 'Y')); Remove all dependencies for Z. dg.removeDependencies('Z'); assertFalse(dg.hasDependency('A', 'Z')); assertFalse(dg.hasDependency('B', 'Z')); assertFalse(dg.hasDependency('Z', 'A')); assertTrue(dg.hasDependency('Z', 'X')); assertTrue(dg.hasDependency('Z', 'Y')); } 
public void testRemoveDependents ( ) { DependencyGraph < Character , Object > dg ; dg = new DependencyGraph < Character , Object > ( ) ; Z depends on A and B. dg.addDependency('A', 'Z'); dg.addDependency('B', 'Z'); X and Y depend on Z dg.addDependency('Z', 'X'); dg.addDependency('Z', 'Y'); We already checked if the dependencies are correct in testRemoveDependencies(). Remove all dependents for Z. This happens when the Z parameter is about to be removed. dg.removeDependents('Z'); assertTrue(dg.hasDependency('A', 'Z')); assertTrue(dg.hasDependency('B', 'Z')); assertFalse(dg.hasDependency('Z', 'X')); assertFalse(dg.hasDependency('Z', 'Y')); } 
public void assertInvalidDependency ( DependencyGraph < Character , Object > dg , Character dependency , Character dependent ) { try { dg . addDependency ( dependency , dependent ) ; 
public void assertOneOf ( String expected , char actual ) { for ( char c : expected . toCharArray ( ) ) { if ( expected . indexOf ( c ) > = 0 ) return ; } fail ( " The character ' " + actual + " ' is not one of the expected \" " + expected + " \" . " ) ; } 
public void testSimple ( ) { Node = numberNode . newInstance ( testLibrary , " number " ) ; Parameter pValue = . getParameter ( " value " ) ; Expression e = new Expression ( pValue , " 1 + 2 " ) ; assertEquals ( 3 , e . asInt ( ) ) ; } 
public void testNodeLocal ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node addDirect = net . create ( addDirectNode ) ; Parameter p1 = addDirect . getParameter ( " v1 " ) ; Parameter p2 = addDirect . getParameter ( " v2 " ) ; p2 . setValue ( 12 ) ; assertExpressionEquals ( 12 , p1 , " v2 " ) ; } 
public void testExpressionErrors ( ) { Setting an expression immediately evaluates it and returns an error if the expression is invalid. Node test = Node.ROOT_NODE.newInstance(testLibrary, "test"); Parameter pX = test.addParameter("x", Parameter.Type.INT, 3); assertInvalidExpression(pX, "y", "could not access: y"); Parameter pY = test.addParameter("y", Parameter.Type.INT, 5); assertExpressionEquals(5, pX, "y"); Expression of parameter x is still set to "y" assertEquals("y", pX.getExpression()); } 
public void testDeadDependencies ( ) { Node test = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pX = test . addParameter ( " x " , Parameter . Type . INT , 3 ) ; Parameter pY = test . addParameter ( " y " , Parameter . Type . INT , 5 ) ; pX . setExpression ( " y " ) ; assertTrue ( pX . getDependencies ( ) . contains ( pY ) ) ; pX . update ( new ProcessingContext ( ) ) ; assertEquals ( 5 , pX . getValue ( ) ) ; test . removeParameter ( " y " ) ; At this point, the parameter dependency should no longer exist. assertFalse(pX.getDependencies().contains(pY)); try { pX.update(new ProcessingContext()); } catch (ExpressionError e) { update throws an error since the expression references a parameter that cannot be found. throw e; assertTrue(e.getCause().getMessage().toLowerCase().contains("unable to resolve variable 'y'")); } The value hasn't changed. assertEquals(5, pX.getValue()); } 
public void testDeadDependents ( ) { Node net = Node . ROOT_NODE . newInstance ( testLibrary , " net " ) ; Node number1 = net . create ( numberNode ) ; Node number2 = net . create ( numberNode ) ; Parameter pValue1 = number1 . getParameter ( " value " ) ; Parameter pValue2 = number2 . getParameter ( " value " ) ; number1 . setValue ( " value " , 5 ) ; number2 . getParameter ( " value " ) . setExpression ( " number1.value " ) ; number2 . setRendered ( ) ; net . update ( ) ; assertFalse ( net . isDirty ( ) ) ; assertEquals ( 5 , net . getOutputValue ( ) ) ; number1 . setValue ( " value " , 13 ) ; assertTrue ( net . isDirty ( ) ) ; net . update ( ) ; assertEquals ( 13 , net . getOutputValue ( ) ) ; assertTrue ( pValue1 . getDependents ( ) . contains ( pValue2 ) ) ; number2 . removeParameter ( " value " ) ; assertFalse ( pValue1 . getDependents ( ) . contains ( pValue2 ) ) ; } 
public void testOnlyReferenceParameters ( ) { Node net = Node . ROOT_NODE . newInstance ( testLibrary , " net " ) ; Node number1 = net . create ( numberNode ) ; Node number2 = net . create ( numberNode ) ; Parameter pValue2 = number2 . getParameter ( " value " ) ; Setting the expression does not throw an error. pValue2.setExpression("number1"); Evaluating the node does. assertProcessingError(number2, "value is not an int"); } 
public void testCycles ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node number1 = net . create ( numberNode ) ; Node addDirect1 = net . create ( addDirectNode ) ; Parameter pValue = number1 . getParameter ( " value " ) ; Parameter pV1 = addDirect1 . getParameter ( " v1 " ) ; Parameter pV2 = addDirect1 . getParameter ( " v2 " ) ; Create a direct cycle. assertInvalidExpression(pValue, "value", "refers to itself"); This should not have created any connections assertTrue(pValue.getDependencies().isEmpty()); number1.setValue("value", 42); assertExpressionEquals(42, pV1, "number1.value"); Create a 2-node cycle with expressions assertInvalidExpression(pValue, "addDirect1.v1", "cyclic dependency"); Now create a 2-parameter cycle within the same node. pV1.setExpression("v2"); addDirect1.update(); assertInvalidExpression(pV2, "v1", "cyclic dependency"); } 
public void testStaleData ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node number1 = net . create ( numberNode ) ; Node add1 = net . create ( addDirectNode ) ; Parameter v1 = add1 . getParameter ( " v1 " ) ; Parameter v2 = add1 . getParameter ( " v2 " ) ; Basic setup: v2 -> v1 -> number1.value For this to work, v1 needs to update number1 first before v2 gets the data. If the value is not updated, v2 will get the value from v1, which hasn't updated yet, and which will thus return 0. number1.setValue("value", 42); v1.setExpression("number1.value"); v2.setExpression("v1"); add1.update(); assertEquals(42 + 42, add1.getOutputValue()); Because we cannot determine the exact order of processing, we need to run this test twice. So this is the setup in the other direction: v1 -> v2 -> number1.value This time, v2 needs to update number1 first, then v1. number1.setValue("value", 33); Setting v1 to the expression v2 would cause a cycle, since v2 is already linked to v1. Clear v2's expression first. v2.clearExpression(); v1.setExpression("v2"); v2.setExpression("number1.value"); add1.update(); assertEquals(33 + 33, add1.getOutputValue()); } 
public void testNetworkLocal ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; net . addParameter ( " pn " , Parameter . Type . INT , 33 ) ; Node number1 = net . create ( numberNode ) ; Parameter pValue1 = number1 . getParameter ( " value " ) ; pValue1 . set ( 84 ) ; assertEquals ( " number1 " , number1 . getName ( ) ) ; Parameter p1 = test1.addParameter("p1", Parameter.Type.INT); Node number2 = net.create(numberNode); assertEquals("number2", number2.getName()); Parameter p2 = number2.addParameter("p2", Parameter.Type.INT); Parameter pValue2 = number2.getParameter("value"); pValue2.set(12); Trying to get the value of number2 by just using the expression "value" is impossible, since it will retrieve the value parameter of number1, which will cause a cycle. assertInvalidExpression(pValue1, "value", "refers to itself"); Access p2 through the node name. assertExpressionEquals(12, pValue1, "number2.value"); Access p2 through the network. assertExpressionEquals(12, pValue1, "network.number2.value"); Access the pn Parameter on the network. assertExpressionEquals(33, pValue1, "network.pn"); } 
public void testDependencies ( ) { Node polynet = Node . ROOT_NODE . newInstance ( testLibrary , " polynet " ) ; Node rect1 = polynet . create ( rectNode ) ; Node translate1 = polynet . create ( manager . getNode ( " polygraph.translate " ) ) ; assertEquals ( " translate1 " , translate1 . getName ( ) ) ; rect1 . getParameter ( " y " ) . setExpression ( " x " ) ; Set < Parameter > dependencies = rect1 . getParameter ( " y " ) . getDependencies ( ) ; assertEquals ( 1 , dependencies . size ( ) ) ; dependencies . contains ( rect1 . getParameter ( " x " ) ) ; rect1 . getParameter ( " y " ) . setExpression ( " translate1.ty + x " ) ; dependencies = rect1 . getParameter ( " y " ) . getDependencies ( ) ; assertEquals ( 2 , dependencies . size ( ) ) ; assertTrue ( dependencies . contains ( translate1 . getParameter ( " ty " ) ) ) ; assertTrue ( dependencies . contains ( rect1 . getParameter ( " x " ) ) ) ; } 
public void assertExpressionEquals ( Object expected , Parameter p , String expression ) { We don't catch the ExpressionError but let it bubble up. p.setExpression(expression); p.update(new ProcessingContext()); assertEquals(expected, p.getValue()); } 
private void assertInvalidExpression ( Parameter p , String expression , String expectedMessage ) { try { p . setExpression ( expression ) ; 
public void testFormatVersion ( ) { String xml ; xml = " <ndbx></ndbx> " ; assertParsingFails ( xml , " required attribute formatVersion " ) ; xml = " <ndbx formatVersion= \" 2.4 \" ></ndbx> " ; assertParsingFails ( xml , " unknown formatVersion " ) ; xml = NDBX_HEADER + NDBX_FOOTER ; parseXml ( xml ) ; } 
public void testUnknownTag ( ) { String xml = NDBX_HEADER + " <flower name= \" dandelion \" ></flower> " + NDBX_FOOTER ; assertParsingFails ( xml , " unknown tag flower " ) ; } 
public void testInvalidNodeFormat ( ) { assertParsingFails ( NDBX_HEADER + " <node></node> " + NDBX_FOOTER , " name attribute is required " ) ; assertParsingFails ( NDBX_HEADER + " <node name= \" dot1 \" ></node> " + NDBX_FOOTER , " prototype attribute is required " ) ; Try loading a node with a prototype that does not exist yet. assertParsingFails(NDBX_HEADER + "<node name=\"dot1\" prototype=\"testlib.xxxx\"></node>" + NDBX_FOOTER, "xxx"); Assert that parsing the load does not store the nodes. assertFalse(manager.hasNode("dot1")); Parse and include the basic types. parseXml(NDBX_HEADER + "<node name=\"dot1\" prototype=\"testlib.dot\"></node>" + NDBX_FOOTER); Try loading a node with an existing name (but in a different namespace). (Include basic types). parseXml(NDBX_HEADER + "<node name=\"dot\" prototype=\"testlib.dot\"></node>" + NDBX_FOOTER); } 
public void testInvalidParameterFormat ( ) { String NODE_HEADER = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" > " ; String NODE_FOOTER = " </node> " + NDBX_FOOTER ; Name is required assertParsingFails(NODE_HEADER + "<param></param>" + NODE_FOOTER, ""); Strictly speaking, mentioning an existing parameter is not invalid, just useless. parseXml(NODE_HEADER + "<param name=\"x\"/>" + NODE_FOOTER); Unknown name, and no value or type given assertParsingFails(NODE_HEADER + "<param name=\"test\"></param>" + NODE_FOOTER, "does not exist"); Unknown name, and no type given assertParsingFails(NODE_HEADER + "<param name=\"test\"><value>hello</value></param>" + NODE_FOOTER, "does not exist"); Valid name, but value is of wrong type assertParsingFails(NODE_HEADER + "<param name=\"x\"><value>hello</value></param>" + NODE_FOOTER, "could not parse"); Valid name, but value is in invalid tag assertParsingFails(NODE_HEADER + "<param name=\"x\"><float>hello</float></param>" + NODE_FOOTER, "unknown tag float"); Type parameter indicates a new parameter needs to be created, but a parameter with this name already exists assertParsingFails(NODE_HEADER + "<param name=\"x\" type=\"string\"><value>hello</value></param>" + NODE_FOOTER, "already exists"); Same as above, but type is now the same as prototype's. This should not make a difference though. assertParsingFails(NODE_HEADER + "<param name=\"x\" type=\"float\"><value>20.0</value></param>" + NODE_FOOTER, "already exists"); Unknown name, but type and value given, so new parameter was created. parseXml(NODE_HEADER + "<param name=\"test\" type=\"string\"><value>hello</value></param>" + NODE_FOOTER); } 
public void testInvalidCode ( ) { String NODE_HEADER = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" ><param name= \" _code \" > " ; String NODE_FOOTER = " </param></node> " + NDBX_FOOTER ; Value tags for code need a type parameter. assertParsingFails(NODE_HEADER + "<value>print 'hello'</value>" + NODE_FOOTER, "type attribute is required"); We do not support Cobol (yet). assertParsingFails(NODE_HEADER + "<value type=\"cobol\">PROCEDURE DIVISION.DisplayPrompt. DISPLAY \"Hello, World!\". STOP RUN.</value>" + NODE_FOOTER, "invalid type attribute"); TODO: Test CDATA formatting. 
public void testInvalidConnectionFormat ( ) { String NODE_HEADER = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" ></node> " + " <node name= \" rotate1 \" prototype= \" testlib.rotate \" ></node> " ; String NODE_FOOTER = NDBX_FOOTER ; Output is required assertParsingFails(NODE_HEADER + "<conn/>" + NODE_FOOTER, "output is required"); Input is required assertParsingFails(NODE_HEADER + "<conn output=\"dot1\"/>" + NODE_FOOTER, "input is required"); Input port is required assertParsingFails(NODE_HEADER + "<conn output=\"dot1\" input=\"rotate1\"/>" + NODE_FOOTER, "port is required"); Correct syntax parseXml(NODE_HEADER + "<conn output=\"dot1\" input=\"rotate1\" port=\"shape\"/>" + NODE_FOOTER); Invalid output/input/port assertParsingFails(NODE_HEADER + "<conn output=\"unknown\" input=\"rotate1\" port=\"shape\"/>" + NODE_FOOTER, "does not exist"); assertParsingFails(NODE_HEADER + "<conn output=\"dot1\" input=\"unknown\" port=\"shape\"/>" + NODE_FOOTER, "does not exist"); assertParsingFails(NODE_HEADER + "<conn output=\"dot1\" input=\"rotate1\" port=\"unknown\"/>" + NODE_FOOTER, "does not exist"); } 
public void testOnlyDefaults ( ) { String xml = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" type= \" vector \" ></node> " + NDBX_FOOTER ; NodeLibrary library = parseXml ( xml ) ; Node protoDot = manager . getNode ( " testlib.dot " ) ; assertTrue ( library . contains ( " dot1 " ) ) ; Node dot1 = library . get ( " dot1 " ) ; assertEquals ( protoDot , dot1 . getPrototype ( ) ) ; Since dot1 inherits from the prototype, it has all the parameters of the prototype. assertTrue(dot1.hasParameter("x")); assertTrue(dot1.hasParameter("y")); This is really an implementation detail. We should not make guarantees about the "same-ness" of parameters. assertNotSame(protoDot.getParameter("x"), dot1.getParameter("x")); assertEquals(0F, dot1.getValue("x")); assertEquals(0F, dot1.getValue("y")); } 
private void resetManager ( ) { manager = new NodeLibraryManager ( ) ; loadBasicTypes ( ) ; } 
private void loadBasicTypes ( ) { NodeLibrary testlib = new NodeLibrary ( " testlib " ) ; Node dot = Node . ROOT_NODE . newInstance ( testlib , " dot " , BezierPath . class ) ; testlib . add ( dot ) ; dot . addParameter ( " x " , Parameter . Type . FLOAT , 0F ) ; dot . addParameter ( " y " , Parameter . Type . FLOAT , 0F ) ; Node rotate = Node . ROOT_NODE . newInstance ( testlib , " rotate " , BezierPath . class ) ; testlib . add ( rotate ) ; rotate . addPort ( " shape " , BezierPath . class ) ; rotate . addParameter ( " rotation " , Parameter . Type . FLOAT , 0F ) ; manager . add ( testlib ) ; } 
private void assertParsingFails ( String xml , String expectedMessage ) { try { parseXml ( xml ) ; 
private NodeLibrary parseXml ( String xml ) { resetManager ( ) ; try { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; 
public void nodeDirty ( Node node ) { + + dirtyCounter ; } 
public void nodeUpdated ( Node node ) { + + updatedCounter ; } 
public void testCreate ( ) { Node grandParent = testNetworkNode . newInstance ( testLibrary , " grandParent " ) ; Node parent = grandParent . create ( testNetworkNode , " parent " ) ; Node child = parent . create ( numberNode ) ; assertTrue ( grandParent . contains ( parent ) ) ; assertTrue ( parent . contains ( child ) ) ; Contains doesn't go into child networks. assertFalse(grandParent.contains(child)); assertTrue(child.hasParent()); assertTrue(grandParent.hasParent()); assertTrue(child.hasParent()); assertFalse(testLibrary.getRootNode().hasParent()); assertEquals(testLibrary.getRootNode(), grandParent.getParent()); assertEquals(grandParent, parent.getParent()); assertEquals(parent, child.getParent()); } 
public void testDataEvent ( ) { TestDataListener l = new TestDataListener ( ) ; Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; net . addDirtyListener ( l ) ; Node n1 = net . create ( numberNode ) ; Node n2 = net . create ( numberNode ) ; assertEquals ( 0 , l . dirtyCounter ) ; assertEquals ( 0 , l . updatedCounter ) ; n1 . setRendered ( ) ; Network was already dirty from the start, counter is not updated. assertEquals(0, l.dirtyCounter); assertEquals(0, l.updatedCounter); net.update(); assertEquals(0, l.dirtyCounter); assertEquals(1, l.updatedCounter); n2.setRendered(); assertEquals(1, l.dirtyCounter); assertEquals(1, l.updatedCounter); net.update(); assertEquals(1, l.dirtyCounter); assertEquals(2, l.updatedCounter); } 
public void testBasicProcessing ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node v1 = net . create ( numberNode ) ; v1 . setValue ( " value " , 42 ) ; assertProcessingError ( net , " no child node to render " ) ; assertEquals ( null , net . getOutputValue ( ) ) ; v1 . setRendered ( ) ; net . update ( ) ; assertEquals ( 42 , net . getOutputValue ( ) ) ; } 
public void testMacro ( ) { public void testCopy() { Node net1 = Node.ROOT_NODE.newInstance(testLibrary, "net"); Node rect1 = net1.create(rectNode); rect1.setRendered(); net1.update(); assertTrue(net1.getOutputValue() == rect1.getOutputValue()); } public void testCycles() { Node net = testNetworkNode.newInstance(testLibrary, "net1"); Node n1 = net.create(numberNode); Node n2 = net.create(numberNode); Node n3 = net.create(numberNode); assertFalse(n2.isConnected()); assertValidConnect(n2, "valuePort", n1); assertTrue(n2.isConnected()); assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isOutputConnectedTo(n2)); assertValidConnect(n3, "valuePort", n2); assertTrue(n3.isConnected()); assertTrue(n3.isInputConnectedTo(n2)); assertTrue(n2.isOutputConnectedTo(n3)); Try creating a 2-node cycle. assertInvalidConnect(n1, "valuePort", n2); The connection didn't go through, so n1's input is not connected to n2. assertFalse(n1.isInputConnectedTo(n2)); However the output of n2 is still connected to n1. assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isConnected()); assertTrue(n2.isConnected()); Try creating a 3-node cycle. assertInvalidConnect(n1, "valuePort", n3); Test multi-input connections. Node n4 = net.create(multiAddNode); assertValidConnect(n4, "values", n1); assertValidConnect(n4, "values", n2); assertValidConnect(n4, "values", n3); assertInvalidConnect(n4, "values", n4); assertInvalidConnect(n1, "valuePort", n4); } public void testReparenting() { Node net1 = Node.ROOT_NODE.newInstance(testLibrary, "net1"); Node net2 = Node.ROOT_NODE.newInstance(testLibrary, "net2"); Node number1 = net1.create(numberNode); Node negate1 = net1.create(negateNode); Node addConstant1 = net1.create(addConstantNode); number1.setValue("value", 5); negate1.getPort("value").connect(number1); addConstant1.getPort("value").connect(negate1); addConstant1.setValue("constant", -3); addConstant1.setRendered(); assertTrue(negate1.isConnected()); assertTrue(number1.isConnected()); assertTrue(addConstant1.isConnected()); net1.update(); assertEquals(-8, net1.getOutputValue()); negate1.setParent(net2); assertFalse(negate1.isConnected()); assertFalse(number1.isConnected()); assertFalse(addConstant1.isConnected()); } private void assertValidConnect(Node inputNode, String inputPortName, Node outputNode) { assert inputNode != null; assert inputPortName != null; assert outputNode != null; try { inputNode.getPort(inputPortName).connect(outputNode); } catch (IllegalArgumentException e) { fail("Should not have thrown IllegalArgumentException: " + e); } } private void assertInvalidConnect(Node inputNode, String inputPortName, Node outputNode) { try { inputNode.getPort(inputPortName).connect(outputNode); fail("Should have thrown IllegalArgumentException."); } catch (IllegalArgumentException ignored) { } }} 
public void testPersistence ( ) { Node polynet1 = manager . getNode ( " polygraph.network " ) . newInstance ( testLibrary , " polynet1 " ) ; Node polynet1 = testLibrary.getRootNode().create(manager.getNode("polygraph.network"), "polynet1"); polynet1.setPosition(10, 10); assertEquals("polynet1", polynet1.getName()); polynet1.setRendered(); Node polygon1 = polynet1.create(manager.getNode("polygraph.polygon")); assertEquals("polygon1", polygon1.getName()); polygon1.setRendered(); polygon1.setPosition(100, 30); Node translate1 = polynet1.create(manager.getNode("polygraph.translate")); assertEquals("translate1", translate1.getName()); translate1.setPosition(40, 80); translate1.setRendered(); translate1.getPort("polygon").connect(polygon1); Node rect1 = polynet1.create(manager.getNode("polygraph.rect")); assertEquals("rect1", rect1.getName()); rect1.setPosition(180, 30); Node merge1 = polynet1.create(manager.getNode("polygraph.merge")); assertEquals("merge1", merge1.getName()); merge1.getPort("polygons").connect(translate1); merge1.getPort("polygons").connect(rect1); Store/load library String xml = testLibrary.toXml(); NodeLibrary newLibrary = manager.load("newLibrary", xml); Node newRoot = newLibrary.getRootNode(); assertEquals("root", newRoot.getName()); assertTrue(newRoot.contains("polynet1")); Node nPolynet1 = newRoot.getChild("polynet1"); assertTrue(nPolynet1.contains("polygon1")); assertTrue(nPolynet1.contains("translate1")); Node nPolygon1 = nPolynet1.getChild("polygon1"); Node nTranslate1 = nPolynet1.getChild("translate1"); Node nRect1 = nPolynet1.getChild("rect1"); Node nMerge1 = nPolynet1.getChild("merge1"); assertEquals(polygon1.getValue("x"), nPolygon1.getValue("x")); assertEquals(polygon1.getValue("fill"), nPolygon1.getValue("fill")); assertEquals(polygon1.getValue("stroke"), nPolygon1.getValue("stroke")); assertTrue(nPolygon1.isConnected()); assertTrue(nTranslate1.isConnected()); assertTrue(nTranslate1.getPort("polygon").isConnectedTo(nPolygon1)); assertTrue(nMerge1.getPort("polygons").isConnectedTo(nRect1)); assertTrue(nMerge1.getPort("polygons").isConnectedTo(nTranslate1)); Check if this is the same connection Port nPolygons = nMerge1.getPort("polygons"); assertEquals(1, nTranslate1.getDownstreamConnections().size()); assertEquals(1, nRect1.getDownstreamConnections().size()); Connection c1 = nTranslate1.getDownstreamConnections().iterator().next(); Connection c2 = nRect1.getDownstreamConnections().iterator().next(); assertTrue(c1 == c2); This tests for a bug where the connection would be created twice. nMerge1.getPort("polygons").disconnect(); assertFalse(nPolygons.isConnectedTo(nRect1)); assertFalse(nPolygons.isConnectedTo(nTranslate1)); } 
public void testCopy ( ) { Node net1 = Node . ROOT_NODE . newInstance ( testLibrary , " net " ) ; Node rect1 = net1 . create ( rectNode ) ; rect1 . setRendered ( ) ; net1 . update ( ) ; assertTrue ( net1 . getOutputValue ( ) = = rect1 . getOutputValue ( ) ) ; } 
public void testCycles ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net1 " ) ; Node n1 = net . create ( numberNode ) ; Node n2 = net . create ( numberNode ) ; Node n3 = net . create ( numberNode ) ; assertFalse ( n2 . isConnected ( ) ) ; assertValidConnect ( n2 , " valuePort " , n1 ) ; assertTrue ( n2 . isConnected ( ) ) ; assertTrue ( n2 . isInputConnectedTo ( n1 ) ) ; assertTrue ( n1 . isOutputConnectedTo ( n2 ) ) ; assertValidConnect ( n3 , " valuePort " , n2 ) ; assertTrue ( n3 . isConnected ( ) ) ; assertTrue ( n3 . isInputConnectedTo ( n2 ) ) ; assertTrue ( n2 . isOutputConnectedTo ( n3 ) ) ; Try creating a 2-node cycle. assertInvalidConnect(n1, "valuePort", n2); The connection didn't go through, so n1's input is not connected to n2. assertFalse(n1.isInputConnectedTo(n2)); However the output of n2 is still connected to n1. assertTrue(n2.isInputConnectedTo(n1)); assertTrue(n1.isConnected()); assertTrue(n2.isConnected()); Try creating a 3-node cycle. assertInvalidConnect(n1, "valuePort", n3); Test multi-input connections. Node n4 = net.create(multiAddNode); assertValidConnect(n4, "values", n1); assertValidConnect(n4, "values", n2); assertValidConnect(n4, "values", n3); assertInvalidConnect(n4, "values", n4); assertInvalidConnect(n1, "valuePort", n4); } 
public void testReparenting ( ) { Node net1 = Node . ROOT_NODE . newInstance ( testLibrary , " net1 " ) ; Node net2 = Node . ROOT_NODE . newInstance ( testLibrary , " net2 " ) ; Node number1 = net1 . create ( numberNode ) ; Node negate1 = net1 . create ( negateNode ) ; Node addConstant1 = net1 . create ( addConstantNode ) ; number1 . setValue ( " value " , 5 ) ; negate1 . getPort ( " value " ) . connect ( number1 ) ; addConstant1 . getPort ( " value " ) . connect ( negate1 ) ; addConstant1 . setValue ( " constant " , - 3 ) ; addConstant1 . setRendered ( ) ; assertTrue ( negate1 . isConnected ( ) ) ; assertTrue ( number1 . isConnected ( ) ) ; assertTrue ( addConstant1 . isConnected ( ) ) ; net1 . update ( ) ; assertEquals ( - 8 , net1 . getOutputValue ( ) ) ; negate1 . setParent ( net2 ) ; assertFalse ( negate1 . isConnected ( ) ) ; assertFalse ( number1 . isConnected ( ) ) ; assertFalse ( addConstant1 . isConnected ( ) ) ; } 
private void assertValidConnect ( Node inputNode , String inputPortName , Node outputNode ) { assert inputNode ! = null ; assert inputPortName ! = null ; assert outputNode ! = null ; try { inputNode . getPort ( inputPortName ) . connect ( outputNode ) ; 
private void assertInvalidConnect ( Node inputNode , String inputPortName , Node outputNode ) { try { inputNode . getPort ( inputPortName ) . connect ( outputNode ) ; 
public void testGet ( ) { Node trunk = Node . ROOT_NODE . newInstance ( testLibrary , " trunk " ) ; Node branch = Node . ROOT_NODE . newInstance ( testLibrary , " branch " ) ; Node leaf1 = Node . ROOT_NODE . newInstance ( testLibrary , " leaf1 " ) ; Node leaf2 = Node . ROOT_NODE . newInstance ( testLibrary , " leaf2 " ) ; leaf1 . setParent ( branch ) ; leaf2 . setParent ( branch ) ; branch . setParent ( trunk ) ; trunk . addParameter ( " age " , Parameter . Type . INT , 42 ) ; branch . addParameter ( " length " , Parameter . Type . INT , 33 ) ; leaf1 . addParameter ( " width " , Parameter . Type . INT , 5 ) ; leaf2 . addParameter ( " width " , Parameter . Type . INT , 7 ) ; Check reserved keywords. assertProxyEquals(testLibrary.getRootNode(), trunk, "root"); assertProxyNull(trunk, "parent"); Check children assertProxyEquals(branch, trunk, "branch"); assertProxyEquals(leaf1, branch, "leaf1"); assertProxyEquals(leaf2, branch, "leaf2"); assertProxyNull(branch, "leaf3"); } 
public void assertProxyEquals ( Node expectedNode , Node proxyNode , String key ) { NodeAccessProxy proxy = new NodeAccessProxy ( proxyNode ) ; Object obj = proxy . get ( key ) ; assertNotNull ( obj ) ; assertEquals ( NodeAccessProxy . class , obj . getClass ( ) ) ; assertEquals ( expectedNode , ( ( NodeAccessProxy ) obj ) . getNode ( ) ) ; } 
private void assertProxyNull ( Node proxyNode , String key ) { NodeAccessProxy proxy = new NodeAccessProxy ( proxyNode ) ; Object obj = proxy . get ( key ) ; assertNull ( obj ) ; } 
public void testNodeNameChange ( ) { NodeLibrary test = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( test , " alpha " ) ; test . add ( alpha ) ; assertEquals ( alpha , test . get ( " alpha " ) ) ; now change the name alpha.setName("beta"); assertEquals(alpha, test.get("beta")); } 
public void testNewInstance ( ) { NodeLibrary test = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( test , " alpha " ) ; assertTrue ( test . contains ( " alpha " ) ) ; 
protected void setUp ( ) throws Exception { manager = new NodeLibraryManager ( ) ; testLibrary = new NodeLibrary ( " test " ) ; TODO: manager.add(testLibrary); 
public void testLoad ( ) { The example.ndbx references polygraph nodes, so make sure those are loaded. PolygraphLibrary polygraph = new PolygraphLibrary(); manager.add(polygraph); manager.load(new File("test/demo.ndbx")); assertNotNull(manager.get("demo")); assertNotNull(manager.getNode("demo.root")); assertNotNull(manager.getNode("demo.rect1")); assertNotNull(manager.getNode("demo.move1")); Node rect1 = manager.getNode("demo.rect1"); Node move1 = manager.getNode("demo.move1"); assertEquals(polygraph.get("rect"), rect1.getPrototype()); assertEquals(Node.ROOT_NODE, move1.getPrototype()); assertTrue(rect1.hasParameter("x")); assertTrue(rect1.hasParameter("y")); assertFalse(rect1.hasParameter("tx")); assertTrue(move1.hasParameter("tx")); assertTrue(move1.hasParameter("ty")); assertFalse(move1.hasParameter("x")); Test connections assertTrue(move1.getPort("polygon").isConnectedTo(rect1)); assertTrue(rect1.isConnectedTo(move1)); Try executing rect1.update(); Object obj = rect1.getOutputValue(); assertEquals(Polygon.class, obj.getClass()); assertEquals(new Rectangle(0, 0, 100, 100), ((Polygon) obj).getBounds()); move1.update(); obj = move1.getOutputValue(); assertEquals(Polygon.class, obj.getClass()); assertEquals(new Rectangle(15, -40, 100, 100), ((Polygon) obj).getBounds()); } 
public void testStoreAndLoad ( ) throws IOException { Create a temporary file to store the nodes in. File f = temporaryLibraryFile(); The name of the library without extension is how the library will be stored in the manager. Since we generate a temporary file, we need to know its name to retrieve it from the manager. String basename = FileUtils.stripExtension(f); NodeLibrary storedLibrary = new NodeLibrary(basename); Node dotNode = Node.ROOT_NODE.newInstance(storedLibrary, "dot"); dotNode.addParameter("x", Parameter.Type.FLOAT); dotNode.addParameter("y", Parameter.Type.FLOAT); Node circleNode = dotNode.newInstance(storedLibrary, "circle"); circleNode.addParameter("size", Parameter.Type.FLOAT, 50F); storedLibrary.add(dotNode); storedLibrary.add(circleNode); try { Store the node library 
public void testOrderedDependencies ( ) throws IOException { Create a temporary file to store the nodes in. File f = temporaryLibraryFile(); The library stores nodes in a Set so we can't know the exact ordering of the nodes. Therefore, we test in all directions. testOrderedDependencies(f, new String[]{"alpha", "beta", "gamma"}); testOrderedDependencies(f, new String[]{"alpha", "gamma", "beta"}); testOrderedDependencies(f, new String[]{"beta", "alpha", "gamma"}); testOrderedDependencies(f, new String[]{"beta", "gamma", "alpha"}); testOrderedDependencies(f, new String[]{"gamma", "beta", "alpha"}); testOrderedDependencies(f, new String[]{"gamma", "alpha", "beta"}); } 
private void testOrderedDependencies ( File f , String [ ] names ) throws IOException { resetManager ( ) ; The name of the library without extension is how the library will be stored in the manager. Since we generate a temporary file, we need to know its name to retrieve it from the manager. String basename = FileUtils.stripExtension(f); NodeLibrary library = new NodeLibrary(basename); Node prototype = Node.ROOT_NODE; for (String name : names) { Node instance = prototype.newInstance(library, name); library.add(instance); prototype = instance; } library.store(f); manager.load(f); NodeLibrary newLib = manager.get(basename); Node newPrototype = Node.ROOT_NODE; for (String name : names) { Node newInstance = newLib.get(name); 
public void testChildNodes ( ) { Node net = Node . ROOT_NODE . newInstance ( testLibrary , " net " ) ; Node rect = Node . ROOT_NODE . newInstance ( testLibrary , " rect " ) ; rect . setParent ( net ) ; } 
private void resetManager ( ) { manager = new NodeLibraryManager ( ) ; } 
private File temporaryLibraryFile ( ) { try { return File . createTempFile ( " lib " , " .ndbx " ) ; 
public void testBaseNode ( ) { Node baseNode = Node . ROOT_NODE ; Parameter pCode = baseNode . getParameter ( " _code " ) ; Parameter pHandle = baseNode . getParameter ( " _handle " ) ; assertEquals ( " _code " , pCode . getName ( ) ) ; assertEquals ( Parameter . Type . CODE , pCode . getType ( ) ) ; assertEquals ( " _handle " , pHandle . getName ( ) ) ; assertEquals ( Parameter . Type . CODE , pHandle . getType ( ) ) ; assertProcessingError ( baseNode , " no child node to render " ) ; } 
public void testBasicClone ( ) { Node myNode = Node . ROOT_NODE . newInstance ( testLibrary , " myNode " ) ; myNode . setValue ( " _code " , new JavaMethodWrapper ( getClass ( ) , " _addParameter " ) ) ; myNode . update ( ) ; assertTrue ( myNode . hasParameter ( " myparam " ) ) ; assertEquals ( " myvalue " , myNode . getValue ( " myparam " ) ) ; } 
public void testBasicUsage ( ) { Node dotNode = Node . ROOT_NODE . newInstance ( testLibrary , " dotNode " ) ; dotNode . addParameter ( " x " , Parameter . Type . FLOAT ) ; dotNode . addParameter ( " y " , Parameter . Type . FLOAT ) ; dotNode . setValue ( " _code " , new JavaMethodWrapper ( getClass ( ) , " _dot " ) ) ; dotNode . addParameter ( " _output " , Parameter . Type . STRING ) ; Check default values assertEquals(0F, dotNode.getValue("x")); assertEquals(0F, dotNode.getValue("y")); assertEquals("", dotNode.getValue("_output")); Process dotNode.update(); assertEquals("dot(0.0,0.0)", dotNode.getOutputValue()); Create instance and change values Node dotInstance = dotNode.newInstance(testLibrary, "dotInstance"); dotInstance.setValue("x", 25F); dotInstance.setValue("y", 42F); dotInstance.update(); assertEquals("dot(25.0,42.0)", dotInstance.getOutputValue()); Check that original hasn't changed assertEquals(0F, dotNode.asFloat("x")); assertEquals(0F, dotNode.asFloat("y")); assertEquals("dot(0.0,0.0)", dotNode.getOutputValue()); Now let the instance use its own code dotInstance.setValue("_code", new JavaMethodWrapper(getClass(), "_dot2")); dotInstance.update(); assertEquals("dot2(25.0,42.0)", dotInstance.getOutputValue()); } 
public void testGetValue ( ) { Inheritance: A <- B <- C Node nodeA = Node.ROOT_NODE.newInstance(testLibrary, "A"); nodeA.addParameter("a", Parameter.Type.FLOAT, 1F); Node nodeB = nodeA.newInstance(testLibrary, "B"); nodeB.addParameter("b", Parameter.Type.FLOAT, 2F); Node nodeC = nodeB.newInstance(testLibrary, "C"); nodeC.addParameter("c", Parameter.Type.FLOAT, 3F); assertEquals(1F, nodeC.asFloat("a")); assertEquals(2F, nodeC.asFloat("b")); assertEquals(3F, nodeC.asFloat("c")); } 
public void testSetValue ( ) { Inheritance: A <- B <- C Node nodeA = Node.ROOT_NODE.newInstance(testLibrary, "A"); nodeA.addParameter("a", Parameter.Type.FLOAT, 1F); Node nodeB = nodeA.newInstance(testLibrary, "B"); nodeB.addParameter("b", Parameter.Type.FLOAT, 2F); Node nodeC = nodeB.newInstance(testLibrary, "C"); nodeC.addParameter("c", Parameter.Type.FLOAT, 3F); nodeC.setValue("a", 10F); nodeC.setValue("b", 20F); nodeC.setValue("c", 30F); assertEquals(1F, nodeA.asFloat("a")); assertEquals(2F, nodeB.asFloat("b")); assertEquals(10F, nodeC.asFloat("a")); assertEquals(20F, nodeC.asFloat("b")); assertEquals(30F, nodeC.asFloat("c")); } 
public void testParameterPropagation ( ) { Inheritance: A <- B Node nodeA = Node.ROOT_NODE.newInstance(testLibrary, "A"); nodeA.addParameter("f", Parameter.Type.FLOAT, 1F); Node nodeB = nodeA.newInstance(testLibrary, "B"); The parameters of A and B are not the same. assertNotSame(nodeA.getParameter("f"), nodeB.getParameter("f")); nodeA.setValue("f", 10F); The value for the B parameter doesn't automatically change when A was changed. assertEquals(10F, nodeA.asFloat("f")); assertEquals(1F, nodeB.asFloat("f")); Setting the value of B does not affect the value of A. nodeB.getParameter("f").setValue(55F); assertEquals(10F, nodeA.asFloat("f")); assertEquals(55F, nodeB.asFloat("f")); Reverting to the default value will force B to load the new parameter value from the prototype. nodeB.getParameter("f").revertToDefault(); assertEquals(10F, nodeB.asFloat("f")); } 
public void testPortAttributes ( ) { Node nodeA = Node . ROOT_NODE . newInstance ( testLibrary , " A " ) ; Port outputPort = nodeA . getOutputPort ( ) ; assertEquals ( " output " , outputPort . getName ( ) ) ; assertEquals ( Port . Direction . OUT , outputPort . getDirection ( ) ) ; assertEquals ( Object . class , outputPort . getDataClass ( ) ) ; assertEquals ( null , outputPort . getValue ( ) ) ; Port stringPort = nodeA . addPort ( " stringPort " , String . class ) ; assertEquals ( " stringPort " , stringPort . getName ( ) ) ; assertEquals ( Port . Direction . IN , stringPort . getDirection ( ) ) ; assertEquals ( String . class , stringPort . getDataClass ( ) ) ; assertEquals ( null , stringPort . getValue ( ) ) ; } 
public void testPortPropagation ( ) { Node nodeA = Node . ROOT_NODE . newInstance ( testLibrary , " A " ) ; nodeA . addPort ( " path " , BezierPath . class ) ; Node nodeB = nodeA . newInstance ( testLibrary , " B " ) ; assertTrue ( nodeB . hasPort ( " path " ) ) ; } 
public void testChildNodes ( ) { Node net = Node . ROOT_NODE . newInstance ( testLibrary , " net " ) ; Node rect = Node . ROOT_NODE . newInstance ( testLibrary , " rect " ) ; rect . setParent ( net ) ; assertTrue ( net . contains ( " rect " ) ) ; } 
public void testParameters ( ) { Node = Node . ROOT_NODE ; assertNull ( . getParameter ( " p1 " ) ) ; assertTrue ( . hasParameter ( " _code " ) ) ; assertNotNull ( . getParameter ( " _code " ) ) ; assertNull ( . getParameter ( " x " ) ) ; } 
public void testNodeNaming ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test1 " ) ; assertInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; assertInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " root " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " network " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " __reserved " , " names cannot start with double underscores " ) ; assertInvalidName ( , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " " , " names cannot be empty " ) ; assertInvalidName ( , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; assertValidName ( , " radius " ) ; assertValidName ( , " _test " ) ; assertValidName ( , " _ " ) ; assertValidName ( , " _1234 " ) ; assertValidName ( , " a1234 " ) ; assertValidName ( , " node1 " ) ; assertValidName ( , " UPPERCASE " ) ; assertValidName ( , " uPpercase " ) ; } 
public void testDirty ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . setValue ( " value " , 12 ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; . getParameter ( " value " ) . set ( 13 ) ; assertTrue ( . isDirty ( ) ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; } 
public void testCopyWithUpstream ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net1 " ) ; Node number1 = net . create ( numberNode ) ; Node number2 = net . create ( numberNode ) ; Node add1 = net . create ( addNode ) ; assertEquals ( " number1 " , number1 . getName ( ) ) ; assertEquals ( " number2 " , number2 . getName ( ) ) ; assertEquals ( " add1 " , add1 . getName ( ) ) ; add1 . getPort ( " v1 " ) . connect ( number1 ) ; add1 . getPort ( " v2 " ) . connect ( number2 ) ; 
public void testDisconnect ( ) { Node net1 = testNetworkNode . newInstance ( testLibrary , " net1 " ) ; Node number1 = net1 . create ( numberNode ) ; Node number2 = net1 . create ( numberNode ) ; Node multiAdd1 = net1 . create ( multiAddNode ) ; number1 . setValue ( " value " , 5 ) ; number2 . setValue ( " value " , 8 ) ; multiAdd1 . getPort ( " values " ) . connect ( number1 ) ; multiAdd1 . getPort ( " values " ) . connect ( number2 ) ; multiAdd1 . update ( ) ; assertFalse ( multiAdd1 . isDirty ( ) ) ; assertEquals ( 2 , multiAdd1 . getPort ( " values " ) . getValues ( ) . size ( ) ) ; assertEquals ( 13 , multiAdd1 . getOutputValue ( ) ) ; multiAdd1 . disconnect ( ) ; assertTrue ( multiAdd1 . isDirty ( ) ) ; assertFalse ( multiAdd1 . isConnected ( ) ) ; assertFalse ( number1 . isConnected ( ) ) ; assertFalse ( number2 . isConnected ( ) ) ; multiAdd1 . update ( ) ; assertEquals ( 0 , multiAdd1 . getPort ( " values " ) . getValues ( ) . size ( ) ) ; assertEquals ( 0 , multiAdd1 . getOutputValue ( ) ) ; } 
private void assertInvalidName ( Node , String newName , String reason ) { try { . setName ( newName ) ; 
private void assertValidName ( Node , String newName ) { try { . setName ( newName ) ; 
public static void _addParameter ( Node node , ProcessingContext ctx ) { node . addParameter ( " myparam " , Parameter . Type . STRING , " myvalue " ) ; } 
public static String _dot ( Node node , ProcessingContext ctx ) { double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; return " dot( " + x + " , " + y + " ) " ; } 
public static String _dot2 ( Node node , ProcessingContext ctx ) { double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; return " dot2( " + x + " , " + y + " ) " ; } 
public static String _circle ( Node node , ProcessingContext ctx ) { double x = node . asFloat ( " x " ) ; double y = node . asFloat ( " y " ) ; return " circle( " + x + " , " + y + " ) " ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; manager = new NodeLibraryManager ( ) ; testNodes = new TestNodes ( ) ; testLibrary = new NodeLibrary ( " test " ) ; polygraphLibrary = new PolygraphLibrary ( ) ; manager . add ( testNodes ) ; manager . add ( polygraphLibrary ) ; numberNode = manager . getNode ( " testlib.number " ) ; negateNode = manager . getNode ( " testlib.negate " ) ; addNode = manager . getNode ( " testlib.add " ) ; addDirectNode = manager . getNode ( " testlib.addDirect " ) ; addConstantNode = manager . getNode ( " testlib.addConstant " ) ; multiplyNode = manager . getNode ( " testlib.multiply " ) ; multiAddNode = manager . getNode ( " testlib.multiAdd " ) ; floatNegateNode = manager . getNode ( " testlib.floatNegate " ) ; convertToUppercaseNode = manager . getNode ( " testlib.convertToUppercase " ) ; testNetworkNode = manager . getNode ( " testlib.testnet " ) ; polygonNode = manager . getNode ( " polygraph.polygon " ) ; rectNode = manager . getNode ( " polygraph.rect " ) ; translateNode = manager . getNode ( " polygraph.translate " ) ; } 
public void testDummy ( ) { This needs to be here, otherwise jUnit complains that there are no tests in this class. } Custom assertions public void assertConnectionError(Node inputNode, String inputPort, Node outputNode, String message) { try { inputNode.getPort(inputPort).connect(outputNode); fail(message); } catch (IllegalArgumentException ignored) { } } public void assertProcessingError(Node node, Class expectedErrorClass) { try { node.update(); fail("The node " + node + " should have failed processing."); } catch (ProcessingError e) { ProcessingErrors are not wrapped, so check if the expected error is a ProcessingError. if (expectedErrorClass == ProcessingError.class) return; assertEquals(expectedErrorClass, e.getCause().getClass()); } } public void assertProcessingError(Node node, String expectedErrorMessage) { try { node.update(); fail("The node " + node + " should have failed processing."); } catch (ProcessingError e) { assertTrue("Was expecting error " + expectedErrorMessage + ", got " + e.toString(), e.toString().toLowerCase().contains(expectedErrorMessage.toLowerCase())); } }} 
public void assertConnectionError ( Node inputNode , String inputPort , Node outputNode , String message ) { try { inputNode . getPort ( inputPort ) . connect ( outputNode ) ; 
public void assertProcessingError ( Node node , Class expectedErrorClass ) { try { node . update ( ) ; 
public void assertProcessingError ( Node node , String expectedErrorMessage ) { try { node . update ( ) ; 
public void testNaming ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; assertInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; assertInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " root " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " network " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " __reserved " , " names cannot start with double underscores " ) ; assertInvalidName ( , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " " , " names cannot be empty " ) ; assertInvalidName ( , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; assertValidName ( , " radius " ) ; assertValidName ( , " _test " ) ; assertValidName ( , " _ " ) ; assertValidName ( , " _1234 " ) ; assertValidName ( , " a1234 " ) ; assertValidName ( , " UPPERCASE " ) ; assertValidName ( , " uPpercase " ) ; assertInvalidName ( , " radius " , " parameter names must be unique for the node " ) ; . addPort ( " myport " , Integer . class ) ; assertInvalidName ( , " myport " , " parameter names must be unique across parameters and ports " ) ; } 
public void testDefaultValue ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; Parameter pInt = . addParameter ( " int " , Parameter . Type . INT ) ; Parameter pFloat = . addParameter ( " float " , Parameter . Type . FLOAT ) ; Parameter pString = . addParameter ( " string " , Parameter . Type . STRING ) ; Parameter pColor = . addParameter ( " color " , Parameter . Type . COLOR ) ; Parameter pCode = . addParameter ( " code " , Parameter . Type . CODE ) ; assertEquals ( 0 , pInt . getDefaultValue ( ) ) ; assertEquals ( 0F , pFloat . getDefaultValue ( ) ) ; assertEquals ( " " , pString . getDefaultValue ( ) ) ; assertEquals ( new Color ( ) , pColor . getDefaultValue ( ) ) ; assertEquals ( " EmptyCode " , pCode . getDefaultValue ( ) . getClass ( ) . getSimpleName ( ) ) ; } 
public void testValidate ( ) { Node customType = numberNode . newInstance ( testLibrary , " number1 " ) ; Parameter pFloat = customType . addParameter ( " float " , Parameter . Type . FLOAT ) ; assertInvalidValue ( pFloat , " A " ) ; assertInvalidValue ( pFloat , new Color ( ) ) ; assertInvalidValue ( pFloat , new Canvas ( ) ) ; assertValidValue ( pFloat , 1F ) ; As a special exception, floating-point parameters can also accept integers assertValidValue(pFloat, 1); Parameter pInt = customType.addParameter("int", Parameter.Type.INT); assertInvalidValue(pInt, "A"); assertInvalidValue(pInt, new Color()); assertInvalidValue(pInt, new Canvas()); assertValidValue(pInt, 1); You cannot assign floating-point values to integers, so the above exception to the rule only works in one way. assertInvalidValue(pInt, 1F); Parameter pColor = customType.addParameter("color", Parameter.Type.COLOR); assertInvalidValue(pColor, "A"); assertInvalidValue(pColor, 2); assertValidValue(pColor, new Color()); Toggle has a hard bounded range between 0 and 1. Parameter ptToggle = customType.addParameter("toggle", Parameter.Type.INT); ptToggle.setBoundingMethod(Parameter.BoundingMethod.HARD); ptToggle.setMinimumValue(0F); ptToggle.setMaximumValue(1F); assertInvalidValue(ptToggle, "A"); assertInvalidValue(ptToggle, -1); assertInvalidValue(ptToggle, 100); assertValidValue(ptToggle, 0); assertValidValue(ptToggle, 1); } 
public void testBounding ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; Parameter pAngle = . addParameter ( " angle " , Parameter . Type . FLOAT ) ; pAngle . setBoundingMethod ( Parameter . BoundingMethod . SOFT ) ; pAngle . setMinimumValue ( - 100 F ) ; pAngle . setMaximumValue ( 100 F ) ; assertValidValue ( , " angle " , 0F ) ; assertValidValue ( , " angle " , 1000 F ) ; assertValidValue ( , " angle " , - 1000 F ) ; pAngle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; assertEquals ( - 100 F , . asFloat ( " angle " ) ) ; Setting the bounding type to hard clamped the value assertInvalidValue(n, "angle", 500F); pAngle.setBoundingMethod(Parameter.BoundingMethod.NONE); assertValidValue(n, "angle", 300F); pAngle.setBoundingMethod(Parameter.BoundingMethod.HARD); assertEquals(100F, n.asFloat("angle")); } 
public void testCorrectType ( ) { Node number = numberNode . newInstance ( testLibrary , " number1 " ) ; Parameter pValue = number . getParameter ( " value " ) ; assertEquals ( Parameter . Type . INT , pValue . getType ( ) ) ; } 
public void testDirectValue ( ) { Node num1 = numberNode . newInstance ( testLibrary , " number1 " ) ; assertEquals ( null , num1 . getOutputValue ( ) ) ; Node num2 = numberNode . newInstance ( testLibrary , " number2 " ) ; num2 . setValue ( " value " , 12 ) ; assertEquals ( null , num2 . getOutputValue ( ) ) ; assertFalse ( num2 . getParameter ( " value " ) . hasExpression ( ) ) ; } 
public void testAsFloat ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " node " ) ; . addParameter ( " int " , Parameter . Type . INT , 42 ) ; assertEquals ( 42 F , . asFloat ( " int " ) ) ; . addParameter ( " string " , Parameter . Type . STRING , " hello " ) ; try { . asFloat ( " string " ) ; 
public void testAsString ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " allControls " ) ; . addParameter ( " int " , Parameter . Type . INT ) ; . addParameter ( " float " , Parameter . Type . FLOAT ) ; . addParameter ( " string " , Parameter . Type . STRING ) ; . addParameter ( " color " , Parameter . Type . COLOR ) ; . addParameter ( " code " , Parameter . Type . CODE ) ; assertEquals ( " 0 " , . asString ( " int " ) ) ; assertEquals ( " 0.0 " , . asString ( " float " ) ) ; assertEquals ( " " , . asString ( " string " ) ) ; assertEquals ( " #000000ff " , . asString ( " color " ) ) ; assertEquals ( " " , . asString ( " code " ) ) ; } 
public void testInvalidName ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " node1 " ) ; Parameter pAlice = . addParameter ( " alice " , Parameter . Type . FLOAT ) ; Parameter pBob = . addParameter ( " bob " , Parameter . Type . FLOAT ) ; assertEquals ( pAlice . getName ( ) , " alice " ) ; assertEquals ( pBob . getName ( ) , " bob " ) ; assertValidName ( pBob , " joe " ) ; assertEquals ( pBob . getName ( ) , " joe " ) ; assertFalse ( . hasParameter ( " bob " ) ) ; assertTrue ( . hasParameter ( " joe " ) ) ; assertParameterNotFound ( , " bob " ) ; assertEquals ( pBob , . getParameter ( " joe " ) ) ; assertInvalidName ( pBob , " alice " , " Can not take the name of an existing parameter. " ) ; assertEquals ( pBob , . getParameter ( " joe " ) ) ; Check the previous setName hasn't affected the current name. } 
public void testLabel ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " node1 " ) ; Parameter p1 = . addParameter ( " width " , Parameter . Type . FLOAT ) ; assertEquals ( " Width " , p1 . getLabel ( ) ) ; Parameter p2 = . addParameter ( " a_somewhat_longer_parameter " , Parameter . Type . FLOAT ) ; assertEquals ( " A Somewhat Longer Parameter " , p2 . getLabel ( ) ) ; Parameter p3 = . addParameter ( " double__underscores__here " , Parameter . Type . FLOAT ) ; assertEquals ( " Double Underscores Here " , p3 . getLabel ( ) ) ; } 
public void testValues ( ) { Node = new ValueBuiltin ( ) . getInstance ( ) ; assertEquals ( Parameter . Type . INT , . getParameter ( " int " ) . getType ( ) ) ; assertEquals ( Parameter . Type . FLOAT , . getParameter ( " float " ) . getType ( ) ) ; assertEquals ( Parameter . Type . STRING , . getParameter ( " string " ) . getType ( ) ) ; assertEquals ( 0 , . asInt ( " int " ) ) ; assertEquals ( 0F , . asFloat ( " float " ) ) ; assertEquals ( " " , . asString ( " string " ) ) ; . setValue ( " int " , 12 ) ; . setValue ( " float " , 0.5F ) ; . setValue ( " string " , " hello " ) ; assertEquals ( 12 , . asInt ( " int " ) ) ; assertEquals ( 0.5F , . asFloat ( " float " ) ) ; assertEquals ( " hello " , . asString ( " string " ) ) ; } 
public void testLenientValues ( ) { Node = new ValueBuiltin ( ) . getInstance ( ) ; Set value of a float with an int. n.setValue("float", 12); assertEquals(12F, n.asFloat("float")); Set value of a float with a double. try { n.setValue("float", 0.5); fail("Double value should not have been accepted."); } catch (IllegalArgumentException ignored) { } Value is still set to previous value. assertEquals(12F, n.asFloat("float")); } 
public void testExpressionDependencies ( ) { Node polynet = Node . ROOT_NODE . newInstance ( testLibrary , " polynet " ) ; Node rect1 = polynet . create ( manager . getNode ( " polygraph.rect " ) ) ; Node rect2 = polynet . create ( manager . getNode ( " polygraph.rect " ) ) ; Node translate1 = polynet . create ( manager . getNode ( " polygraph.translate " ) ) ; translate1 . getPort ( " polygon " ) . connect ( rect1 ) ; translate1 . getParameter ( " tx " ) . setExpression ( " rect2.x " ) ; Parameter txParam = translate1 . getParameter ( " tx " ) ; Parameter xParam = rect2 . getParameter ( " x " ) ; assertEquals ( 1 , xParam . getDependents ( ) . size ( ) ) ; assertTrue ( xParam . getDependents ( ) . contains ( txParam ) ) ; assertEquals ( 1 , txParam . getDependencies ( ) . size ( ) ) ; assertTrue ( txParam . getDependencies ( ) . contains ( xParam ) ) ; } 
public void testMultiParameters ( ) { Node net1 = Node . ROOT_NODE . newInstance ( testLibrary , " net1 " ) ; Node number1 = net1 . create ( numberNode ) ; number1 . setValue ( " value " , 1 ) ; Node number2 = net1 . create ( numberNode ) ; number2 . setValue ( " value " , 2 ) ; Node number3 = net1 . create ( numberNode ) ; number3 . setValue ( " value " , 3 ) ; Node multiAdd = net1 . create ( multiAddNode ) ; Connection c1 = multiAdd . getPort ( " values " ) . connect ( number1 ) ; Connection c2 = multiAdd . getPort ( " values " ) . connect ( number2 ) ; Connection c3 = multiAdd . getPort ( " values " ) . connect ( number3 ) ; assertTrue ( c1 = = c2 ) ; assertTrue ( c1 = = c3 ) ; assertEquals ( 3 , c1 . getOutputs ( ) . size ( ) ) ; multiAdd . update ( ) ; assertEquals ( 1 + 2 + 3 , multiAdd . getOutputValue ( ) ) ; Check dirty propagation assertFalse(multiAdd.isDirty()); number2.setValue("value", 200); assertTrue(multiAdd.isDirty()); multiAdd.update(); assertEquals(1 + 200 + 3, multiAdd.getOutputValue()); Check disconnect number2.disconnect(); assertFalse(number2.isConnected()); assertTrue(number1.isConnected()); assertTrue(number3.isConnected()); assertTrue(multiAdd.isConnected()); multiAdd.update(); assertEquals(1 + 3, multiAdd.getOutputValue()); multiAdd.disconnect(); assertFalse(number2.isConnected()); assertFalse(number1.isConnected()); assertFalse(number3.isConnected()); assertFalse(multiAdd.isConnected()); } 
public void testParameterCloning ( ) { Node nodeA = Node . ROOT_NODE . newInstance ( testLibrary , " a " ) ; Parameter aAngle = nodeA . addParameter ( " angle " , Parameter . Type . FLOAT , 42 F ) ; aAngle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; aAngle . setMinimumValue ( 0F ) ; aAngle . setMaximumValue ( 360 F ) ; aAngle . setLabel ( " My Angle " ) ; aAngle . setDisplayLevel ( Parameter . DisplayLevel . HUD ) ; aAngle . setHelpText ( " The angle of the node. " ) ; aAngle . setWidget ( Parameter . Widget . ANGLE ) ; Node nodeB = nodeA . newInstance ( testLibrary , " b " ) ; Parameter bAngle = nodeB . getParameter ( " angle " ) ; assertNotNull ( bAngle ) ; assertNotSame ( aAngle , bAngle ) ; assertEquals ( aAngle . getBoundingMethod ( ) , bAngle . getBoundingMethod ( ) ) ; assertEquals ( aAngle . getMinimumValue ( ) , bAngle . getMinimumValue ( ) ) ; assertEquals ( aAngle . getMaximumValue ( ) , bAngle . getMaximumValue ( ) ) ; assertEquals ( aAngle . getLabel ( ) , bAngle . getLabel ( ) ) ; assertEquals ( aAngle . getDisplayLevel ( ) , bAngle . getDisplayLevel ( ) ) ; assertEquals ( aAngle . getHelpText ( ) , bAngle . getHelpText ( ) ) ; assertEquals ( aAngle . getWidget ( ) , bAngle . getWidget ( ) ) ; } 
private void assertInvalidName ( Node , String newName , String reason ) { try { . addParameter ( newName , Parameter . Type . INT ) ; 
private void assertValidName ( Node , String newName ) { try { . addParameter ( newName , Parameter . Type . INT ) ; 
private void assertValidValue ( Parameter p , Object value ) { try { p . validate ( value ) ; 
private void assertInvalidValue ( Parameter p , Object value ) { try { p . validate ( value ) ; 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " value " ) ; . addParameter ( " int " , Parameter . Type . INT ) ; . addParameter ( " float " , Parameter . Type . FLOAT ) ; . addParameter ( " string " , Parameter . Type . STRING ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { return 42 ; } 
private void assertValidName ( Parameter p , String newName ) { try { p . setName ( newName ) ; 
private void assertInvalidName ( Parameter p , String newName , String reason ) { try { p . setName ( newName ) ; 
private void assertParameterNotFound ( Node , String parameterName ) { assertNull ( " The parameter \" " + parameterName + " \" should not have been found. " , . getParameter ( parameterName ) ) ; } 
public void testNaming ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; assertInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; assertInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; assertValidName ( , " radius " ) ; assertInvalidName ( , " radius " , " port names must be unique for the node " ) ; . addParameter ( " myparam " , Parameter . Type . INT ) ; assertInvalidName ( , " myparam " , " port names must be unique across parameters and ports " ) ; } 
public void testGetOutput ( ) { NodeLibraryManager manager = new NodeLibraryManager ( ) ; Node mergeNode = manager . getNode ( " vector/merge " ) ; 
public void testDowncasting ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; Port ptGrob = . addPort ( " grob " , Grob . class ) ; Port ptCanvas = . addPort ( " canvas " , Canvas . class ) ; Port ptGroup = . addPort ( " group " , Group . class ) ; Port ptImage = . addPort ( " image " , Image . class ) ; Port ptPath = . addPort ( " path " , BezierPath . class ) ; Port ptText = . addPort ( " text " , Text . class ) ; Canvas canvas = new Canvas ( ) ; Group group = new Group ( ) ; Image image = new Image ( ) ; BezierPath path = new BezierPath ( ) ; Text text = new Text ( " " , 0 , 0 ) ; assertValidValue ( ptGrob , canvas ) ; assertValidValue ( ptGrob , group ) ; assertValidValue ( ptGrob , image ) ; assertValidValue ( ptGrob , path ) ; assertValidValue ( ptGrob , text ) ; assertValidValue ( ptCanvas , canvas ) ; assertInvalidValue ( ptCanvas , group ) ; assertInvalidValue ( ptCanvas , image ) ; assertInvalidValue ( ptCanvas , path ) ; assertInvalidValue ( ptCanvas , text ) ; assertValidValue ( ptGroup , canvas ) ; assertValidValue ( ptGroup , group ) ; assertInvalidValue ( ptGroup , image ) ; assertInvalidValue ( ptGroup , path ) ; assertInvalidValue ( ptGroup , text ) ; assertInvalidValue ( ptImage , canvas ) ; assertInvalidValue ( ptImage , group ) ; assertValidValue ( ptImage , image ) ; assertInvalidValue ( ptImage , path ) ; assertInvalidValue ( ptImage , text ) ; assertInvalidValue ( ptPath , canvas ) ; assertInvalidValue ( ptPath , group ) ; assertInvalidValue ( ptPath , image ) ; assertValidValue ( ptPath , path ) ; assertInvalidValue ( ptPath , text ) ; assertInvalidValue ( ptText , canvas ) ; assertInvalidValue ( ptText , group ) ; assertInvalidValue ( ptText , image ) ; assertInvalidValue ( ptText , path ) ; assertValidValue ( ptText , text ) ; 
public void testCardinality ( ) { Node test = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; test . addPort ( " single " , Object . class ) ; test . addPort ( " multiple " , Object . class , Port . Cardinality . MULTIPLE ) ; assertEquals ( Port . Cardinality . SINGLE , test . getPort ( " single " ) . getCardinality ( ) ) ; assertEquals ( Port . Cardinality . MULTIPLE , test . getPort ( " multiple " ) . getCardinality ( ) ) ; Now clone this instance and check cardinality. Node cloned = test.newInstance(testLibrary, "cloned"); assertEquals(Port.Cardinality.SINGLE, cloned.getPort("single").getCardinality()); assertEquals(Port.Cardinality.MULTIPLE, cloned.getPort("multiple").getCardinality()); } 
private void assertInvalidName ( Node , String newName , String reason ) { try { . addPort ( newName , Integer . class ) ; 
private void assertValidName ( Node , String newName ) { try { . addPort ( newName , Integer . class ) ; 
private void assertValidValue ( Port p , Object value ) { try { p . validate ( value ) ; 
private void assertInvalidValue ( Port p , Object value ) { try { p . validate ( value ) ; 
protected void setUp ( ) throws Exception { testLibrary = new NodeLibrary ( " test " ) ; } 
public void testBasic ( ) { assertSnippetEquals ( " hello " , " \" hello \" " , null ) ; assertSnippetEquals ( 5 , " 2+3 " , null ) ; assertSnippetEquals ( 2.5 , " 5.0/2.0 " , null ) ; Python returns a Double. } 
public void testSelf ( ) { Node node1 = Node . ROOT_NODE . newInstance ( testLibrary , " node1 " ) ; node1 . addParameter ( " alpha " , Parameter . Type . INT , 42 ) ; assertSnippetEquals ( 42 , " self.alpha " , node1 ) ; node1 . addPort ( " polygon " , Polygon . class ) ; node1 . setPortValue ( " polygon " , Polygon . rect ( 20 , 30 , 40 , 50 ) ) ; assertSnippetEquals ( new Rectangle ( 20 , 30 , 40 , 50 ) , " self.polygon.bounds " , node1 ) ; } 
public void testNodeAccess ( ) { Node node1 = Node . ROOT_NODE . newInstance ( testLibrary , " node1 " ) ; node1 . setPosition ( 35 , 22 ) ; node1 . addParameter ( " x " , Parameter . Type . INT , 42 ) ; assertSnippetEquals ( 42 , " self.x " , node1 ) ; assertSnippetEquals ( 35.0 , " self.node.x " , node1 ) ; } 
public void testGlobals ( ) { assertSnippetEquals ( 11 , " FRAME + 10 " , null , new ProcessingContext ( ) ) ; } 
public void testErrors ( ) { Node node1 = Node . ROOT_NODE . newInstance ( testLibrary , " node1 " ) ; Test for intialization errors. assertCodeFails("# No source code", null, "does not contain a function"); assertSnippetFails("/ hello?", null, "SyntaxError"); Change the cook function to a number. assertCodeFails("cook = 5", null, "not a function."); Cook with too many parameters. The error here is a bit backwards but correct. assertCodeFails("def cook(moe, curly, larry): pass", null, "takes exactly 3 arguments (1 given)"); Test for errors in the cook function. assertSnippetFails("1 / 0", null, "ZeroDivisionError"); assertSnippetFails("self.x", null, "'NoneType' object has no attribute 'x'"); assertSnippetFails("self.alpha", node1, "Node 'test.node1' has no parameter or port 'alpha'"); node1.addParameter("alpha", Parameter.Type.INT, 42); assertSnippetEquals(42, "self.alpha", node1); } 
private void assertSnippetEquals ( Object expected , String snippet , Node node ) { assertSnippetEquals ( expected , snippet , node , new ProcessingContext ( ) ) ; } 
private void assertSnippetEquals ( Object expected , String snippet , Node node , ProcessingContext context ) { String source = snippetToCode ( snippet ) ; PythonCode code = new PythonCode ( source ) ; Object obj = code . cook ( node , context ) ; assertEquals ( expected , obj ) ; } 
private void assertSnippetFails ( String snippet , Node node , String expectedMessage ) { assertSnippetFails ( snippet , node , new ProcessingContext ( ) , expectedMessage ) ; } 
private void assertSnippetFails ( String snippet , Node node , ProcessingContext context , String expectedMessage ) { assertCodeFails ( snippetToCode ( snippet ) , node , context , expectedMessage ) ; } 
private void assertCodeFails ( String source , Node node , String expectedMessage ) { assertCodeFails ( source , node , new ProcessingContext ( ) , expectedMessage ) ; } 
private void assertCodeFails ( String source , Node node , ProcessingContext context , String expectedMessage ) { PythonCode code = new PythonCode ( source ) ; try { code . cook ( node , context ) ; 
private String snippetToCode ( String snippet ) { return " def cook(self): return " + snippet ; } 
public void testBasicGenerator ( ) { Node rect1 = Node . ROOT_NODE . newInstance ( testLibrary , " rect1 " , Polygon . class ) ; rect1 . addParameter ( " x " , Parameter . Type . INT , 20 ) ; rect1 . addParameter ( " y " , Parameter . Type . INT , 30 ) ; rect1 . addParameter ( " width " , Parameter . Type . INT , 40 ) ; rect1 . addParameter ( " height " , Parameter . Type . INT , 50 ) ; PythonCode code = new PythonCode ( " from net.nodebox.node.polygraph import Polygon " + " def cook(self): " + " return Polygon.rect(self.x, self.y, self.width, self.height) " ) ; rect1 . setValue ( " _code " , code ) ; rect1 . update ( ) ; Polygon polygon = ( Polygon ) rect1 . getOutputValue ( ) ; assertEquals ( new Rectangle ( 20 , 30 , 40 , 50 ) , polygon . getBounds ( ) ) ; } 
public void testBasicFilter ( ) { Node rect1 = rectNode . newInstance ( testLibrary , " rect1 " ) ; Node mover = Node . ROOT_NODE . newInstance ( testLibrary , " mover " , Polygon . class ) ; mover . addPort ( " polygon " , Polygon . class ) ; mover . addParameter ( " tx " , Parameter . Type . INT , 10 ) ; mover . addParameter ( " ty " , Parameter . Type . INT , 20 ) ; PythonCode code = new PythonCode ( " def cook(self): " + " return self.polygon.translated(self.tx, self.ty) " ) ; mover . setValue ( " _code " , code ) ; mover . getPort ( " polygon " ) . connect ( rect1 ) ; mover . update ( ) ; Polygon polygon = ( Polygon ) mover . getOutputValue ( ) ; assertEquals ( new Rectangle ( 10 , 20 , 100 , 100 ) , polygon . getBounds ( ) ) ; } 
public void testIncorrectReturnType ( ) { Node rect1 = Node . ROOT_NODE . newInstance ( testLibrary , " rect1 " , Polygon . class ) ; PythonCode code = new PythonCode ( " def cook(self): return 'hello' " ) ; rect1 . setValue ( " _code " , code ) ; assertProcessingError ( rect1 , " Value hello is not of required class " ) ; } 
public void testMultiPort ( ) { Node multiAdd = Node . ROOT_NODE . newInstance ( testLibrary , " multiAdd " , Integer . class ) ; Port pValues = multiAdd . addPort ( " values " , Integer . class , Port . Cardinality . MULTIPLE ) ; PythonCode code = new PythonCode ( " def cook(self): return sum(self.values) " ) ; multiAdd . setValue ( " _code " , code ) ; multiAdd . update ( ) ; No values were given, so the output returns 0. assertEquals(0, multiAdd.getOutputValue()); Node number1 = numberNode.newInstance(testLibrary, "number1"); Node number2 = numberNode.newInstance(testLibrary, "number2"); Node number3 = numberNode.newInstance(testLibrary, "number3"); number1.setValue("value", 1); number2.setValue("value", 3); number3.setValue("value", 5); pValues.connect(number1); pValues.connect(number2); pValues.connect(number3); multiAdd.update(); assertEquals(9, multiAdd.getOutputValue()); pValues.disconnect(); multiAdd.update(); assertEquals(0, multiAdd.getOutputValue()); } 
public void testParameterGone ( ) { Node stringIn = Node . ROOT_NODE . newInstance ( testLibrary , " stringIn " , String . class ) ; stringIn . addParameter ( " string " , Parameter . Type . STRING ) ; PythonCode code = new PythonCode ( " def cook(self): n return self.string " ) ; stringIn . setValue ( " _code " , code ) ; stringIn . setValue ( " string " , " hello " ) ; stringIn . update ( ) ; assertEquals ( " hello " , stringIn . getOutputValue ( ) ) ; stringIn . removeParameter ( " string " ) ; assertProcessingError ( stringIn , " Node 'test.stringIn' has no parameter or port 'string' " ) ; } 
public void testConnecting ( ) { Node stringIn = Node . ROOT_NODE . newInstance ( testLibrary , " stringIn " , String . class ) ; stringIn . addParameter ( " string " , Parameter . Type . STRING ) ; PythonCode stringInCode = new PythonCode ( " def cook(self): n return self.string " ) ; stringIn . setValue ( " _code " , stringInCode ) ; Node upper = Node . ROOT_NODE . newInstance ( testLibrary , " upper " , String . class ) ; upper . addPort ( " string " , String . class ) ; PythonCode upperCode = new PythonCode ( " def cook(self): n return self.string.upper() " ) ; upper . setValue ( " _code " , upperCode ) ; upper . getPort ( " string " ) . connect ( stringIn ) ; stringIn . setValue ( " string " , " hello " ) ; upper . update ( ) ; assertEquals ( " HELLO " , upper . getOutputValue ( ) ) ; } 
private void addBuiltin ( Builtin builtin ) { add ( builtin . getInstance ( ) ) ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " number " , Integer . class ) ; . addParameter ( " value " , Parameter . Type . INT ) ; . addPort ( " valuePort " , Integer . class ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " negate " , Integer . class ) ; . addPort ( " value " , Integer . class ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { int value = ( Integer ) node . getPortValue ( " value " ) ; return - value ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " add " , Integer . class ) ; . addPort ( " v1 " , Integer . class ) ; . addPort ( " v2 " , Integer . class ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { int v1 = ( Integer ) node . getPortValue ( " v1 " ) ; int v2 = ( Integer ) node . getPortValue ( " v2 " ) ; return v1 + v2 ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " addDirect " , Integer . class ) ; . addParameter ( " v1 " , Parameter . Type . INT ) ; . addParameter ( " v2 " , Parameter . Type . INT ) ; return ; } 
public Object cook ( Node node , ProcessingContext ctx ) { return node . asInt ( " v1 " ) + node . asInt ( " v2 " ) ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " addConstant " , Integer . class ) ; . addPort ( " value " , Integer . class ) ; . addParameter ( " constant " , Parameter . Type . INT ) ; return ; } 
public Object cook ( Node node , ProcessingContext ctx ) { return ( ( Integer ) node . getPortValue ( " value " ) ) + node . asInt ( " constant " ) ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " multiply " , Integer . class ) ; . addPort ( " v1 " , Integer . class ) ; . addPort ( " v2 " , Integer . class ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { int v1 = ( Integer ) node . getPortValue ( " v1 " ) ; int v2 = ( Integer ) node . getPortValue ( " v2 " ) ; return v1 * v2 ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " multiAdd " , Integer . class ) ; . addPort ( " values " , Integer . class , Port . Cardinality . MULTIPLE ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { List < Object > values = node . getPortValues ( " values " ) ; int sum = 0 ; for ( Object obj : values ) { int v = ( Integer ) obj ; sum + = v ; } return sum ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " floatNegate " , Float . class ) ; . addPort ( " value " , Float . TYPE ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { float value = ( Float ) node . getPortValue ( " value " ) ; return - value ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " convertToUppercase " , String . class ) ; . addPort ( " value " , String . class ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { String value = ( String ) node . getPortValue ( " value " ) ; return value . toUpperCase ( ) ; } 
protected Node createInstance ( ) { return Node . ROOT_NODE . newInstance ( TestNodes . this , " testnet " , Integer . class ) ; } 
public Object cook ( Node node , ProcessingContext context ) { return node . cook ( node , context ) ; } 
public static Polygon rect ( float x , float y , float width , float height ) { Polygon p = new Polygon ( ) ; p . addPoint ( new Point ( x , y ) ) ; p . addPoint ( new Point ( x + width , y ) ) ; p . addPoint ( new Point ( x + width , y + height ) ) ; p . addPoint ( new Point ( x , y + height ) ) ; return p ; } 
public void extend ( Polygon p ) { for ( Point pt : p . points ) { addPoint ( pt ) ; 
public Polygon clone ( ) { Polygon p = new Polygon ( ) ; for ( Point pt : points ) { p . addPoint ( pt ) ; } return p ; } 
public void testBounds ( ) { Polygon p ; p = Polygon . rect ( 0 , 0 , 100 , 100 ) ; assertEquals ( new Rectangle ( 0 , 0 , 100 , 100 ) , p . getBounds ( ) ) ; p = Polygon . rect ( - 32 , - 45 , 12 , 68 ) ; assertEquals ( new Rectangle ( - 32 , - 45 , 12 , 68 ) , p . getBounds ( ) ) ; } 
public void testTranslated ( ) { Polygon p ; p = Polygon . rect ( 0 , 0 , 100 , 100 ) ; Polygon p2 = p . translated ( 50 , - 40 ) ; assertEquals ( new Rectangle ( 50 , - 40 , 100 , 100 ) , p2 . getBounds ( ) ) ; } 
public Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " polygon " , Polygon . class ) ; . addParameter ( " path " , Parameter . Type . STRING ) ; return ; } 
public Object cook ( Node node , ProcessingContext ctx ) { Polygon p = new Polygon ( ) ; String pathString = node . asString ( " path " ) ; for ( String pointString : pathString . split ( " " ) ) { String [ ] coords = pointString . split ( " , " ) ; assert ( coords . length = = 2 ) ; float x = Float . parseFloat ( coords [ 0 ] ) ; float y = Float . parseFloat ( coords [ 1 ] ) ; p . addPoint ( new Point ( x , y ) ) ; } return p ; } 
public Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " rect " , Polygon . class ) ; . addParameter ( " x " , Parameter . Type . FLOAT , 0 ) ; . addParameter ( " y " , Parameter . Type . FLOAT , 0 ) ; . addParameter ( " width " , Parameter . Type . FLOAT , 100 ) ; . addParameter ( " height " , Parameter . Type . FLOAT , 100 ) ; return ; } 
public Object cook ( Node node , ProcessingContext ctx ) { float x = node . asFloat ( " x " ) ; float y = node . asFloat ( " y " ) ; float width = node . asFloat ( " width " ) ; float height = node . asFloat ( " height " ) ; return Polygon . rect ( x , y , width , height ) ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " translate " , Polygon . class ) ; . addPort ( " polygon " , Polygon . class ) ; . addParameter ( " tx " , Parameter . Type . FLOAT ) ; . addParameter ( " ty " , Parameter . Type . FLOAT ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { float tx = node . asFloat ( " tx " ) ; float ty = node . asFloat ( " ty " ) ; Polygon p = ( Polygon ) node . getPortValue ( " polygon " ) ; return p . translated ( tx , ty ) ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " merge " , Polygon . class ) ; . addPort ( " polygons " , Polygon . class , Port . Cardinality . MULTIPLE ) ; return ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Rectangle rectangle = ( Rectangle ) o ; if ( Float . compare ( rectangle . height , height ) ! = 0 ) return false ; if ( Float . compare ( rectangle . width , width ) ! = 0 ) return false ; if ( Float . compare ( rectangle . x , x ) ! = 0 ) return false ; if ( Float . compare ( rectangle . y , y ) ! = 0 ) return false ; return true ; } 
public String toString ( ) { return " Rectangle{ " + " x= " + x + 
public void testStripExtension ( ) { assertEquals ( " test " , FileUtils . stripExtension ( " test.ndbx " ) ) ; assertEquals ( " MixedCase " , FileUtils . stripExtension ( " MixedCase.GIF " ) ) ; Retain case assertEquals("a.lot.of.dots", FileUtils.stripExtension("a.lot.of.dots.dot")); Extension = last dot assertEquals("noextension", FileUtils.stripExtension("noextension")); assertEquals("", FileUtils.stripExtension("")); Retain case } 
public void testGetExtension ( ) { assertEquals ( " png " , FileUtils . getExtension ( " helloworld.png " ) ) ; assertEquals ( " gif " , FileUtils . getExtension ( " MixedCase.GIF " ) ) ; Always lower case assertEquals("dot", FileUtils.getExtension("a.lot.of.dots.dot")); Extension = last dot assertEquals("", FileUtils.getExtension("noextension")); } 
private void load ( ) { manager = new NodeLibraryManager ( ) ; TODO: manager.addSearchPath(PlatformUtils.getUserNodeTypeLibraryDirectory()); int tasks = manager.getLibraries().size() + 1; startupDialog = new ProgressDialog(null, "Starting NodeBox", tasks); startupDialog.setVisible(true); Initialize Jython startupDialog.setMessage("Loading Python"); Thread t = new Thread(new PythonLoader()); t.start(); } 
public void currentNodeChanged ( Node node ) ; public void focusedNodeChanged ( Node node ) ; } 
public void focusedNodeChanged ( Node activeNode ) { setNode ( activeNode ) ; } 
public void actionPerformed ( ActionEvent e ) { Parameter pCode = node . getParameter ( " _code " ) ; if ( pCode = = null ) return ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; } 
public void currentNodeChanged ( Node activeNetwork ) { if ( node ! = null ) { node . removeDirtyListener ( this ) ; } node = activeNetwork ; if ( node ! = null ) node . addDirtyListener ( this ) ; 
public void nodeDirty ( Node node ) { } public void nodeUpdated ( Node node ) { StringBuffer sb = new StringBuffer ( ) ; if ( node . hasError ( ) ) { sb . append ( node . getError ( ) . toString ( ) ) ; } loggingArea . setText ( sb . toString ( ) ) ; } public Pane clone ( ) { return new LoggingPane ( getDocument ( ) ) ; } } 
public void nodeUpdated ( Node node ) { StringBuffer sb = new StringBuffer ( ) ; if ( node . hasError ( ) ) { sb . append ( node . getError ( ) . toString ( ) ) ; } loggingArea . setText ( sb . toString ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { pane . getDocument ( ) . setActiveNetwork ( node ) ; } 
public void currentNodeChanged ( Node activeNetwork ) { setNetwork ( activeNetwork ) ; } 
public void focusedNodeChanged ( Node activeNode ) { If the active node is already selected, don't change the selection. This avoids nasty surprises when multiple nodes (including the active one) are selected. if (networkView.isSelected(activeNode)) return; networkView.singleSelect(activeNode); } 
protected Node createInstance ( ) { NodeLibrary library = new NodeLibrary ( " allcontrols " ) ; Node = Node . ROOT_NODE . newInstance ( library , " allcontrols " , Canvas . class ) ; . addParameter ( " angle " , Parameter . Type . FLOAT ) . setWidget ( Parameter . Widget . ANGLE ) ; . addParameter ( " color " , Parameter . Type . COLOR ) . setWidget ( Parameter . Widget . COLOR ) ; . addParameter ( " file " , Parameter . Type . STRING ) . setWidget ( Parameter . Widget . FILE ) ; . addParameter ( " float " , Parameter . Type . FLOAT ) . setWidget ( Parameter . Widget . FLOAT ) ; . addParameter ( " font " , Parameter . Type . STRING ) . setWidget ( Parameter . Widget . FONT ) ; . addParameter ( " gradient " , Parameter . Type . COLOR ) . setWidget ( Parameter . Widget . GRADIENT ) ; . addParameter ( " image " , Parameter . Type . STRING ) . setWidget ( Parameter . Widget . IMAGE ) ; . addParameter ( " int " , Parameter . Type . INT ) . setWidget ( Parameter . Widget . INT ) ; . addParameter ( " menu " , Parameter . Type . STRING ) . setWidget ( Parameter . Widget . MENU ) ; . addParameter ( " seed " , Parameter . Type . INT ) . setWidget ( Parameter . Widget . SEED ) ; . addParameter ( " string " , Parameter . Type . STRING ) . setWidget ( Parameter . Widget . STRING ) ; . addParameter ( " text " , Parameter . Type . STRING ) . setWidget ( Parameter . Widget . TEXT ) ; . addParameter ( " toggle " , Parameter . Type . INT ) . setWidget ( Parameter . Widget . TOGGLE ) ; . addParameter ( " noderef " , Parameter . Type . STRING ) . setWidget ( Parameter . Widget . NODEREF ) ; Parameter pMenu = . getParameter ( " menu " ) ; pMenu . addMenuItem ( " red " , " Red " ) ; pMenu . addMenuItem ( " green " , " Green " ) ; pMenu . addMenuItem ( " blue " , " Blue " ) ; pMenu . setValue ( " blue " ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { net . nodebox . graphics . Canvas c = new net . nodebox . graphics . Canvas ( ) ; addText ( c , node , " angle " , 1 ) ; addText ( c , node , " color " , 2 ) ; addText ( c , node , " file " , 3 ) ; addText ( c , node , " float " , 4 ) ; addText ( c , node , " font " , 5 ) ; addText ( c , node , " gradient " , 6 ) ; addText ( c , node , " image " , 7 ) ; addText ( c , node , " int " , 8 ) ; addText ( c , node , " menu " , 9 ) ; addText ( c , node , " seed " , 10 ) ; addText ( c , node , " string " , 11 ) ; addText ( c , node , " text " , 12 ) ; addText ( c , node , " toggle " , 13 ) ; addText ( c , node , " noderef " , 14 ) ; node . setOutputValue ( c ) ; return true ; } 
private void initMenu ( ) { JMenuBar menuBar = new JMenuBar ( ) ; File menu JMenu fileMenu = new JMenu("File"); fileMenu.add(newAction); fileMenu.add(openAction); recentFileMenu = new JMenu("Open Recent"); buildRecentFileMenu(); fileMenu.add(recentFileMenu); fileMenu.addSeparator(); fileMenu.add(closeAction); fileMenu.add(saveAction); fileMenu.add(saveAsAction); fileMenu.add(revertAction); fileMenu.addSeparator(); fileMenu.add(exportAction); if (!PlatformUtils.onMac()) { fileMenu.addSeparator(); fileMenu.add(quitAction); } menuBar.add(fileMenu); Edit menu JMenu editMenu = new JMenu("Edit"); editMenu.add(undoAction); editMenu.add(redoAction); editMenu.addSeparator(); editMenu.add(cutAction); editMenu.add(copyAction); editMenu.add(pasteAction); editMenu.addSeparator(); editMenu.add(deleteAction); menuBar.add(editMenu); Node menu JMenu pythonMenu = new JMenu("Node"); pythonMenu.add(reloadAction); pythonMenu.add(newLibraryAction); menuBar.add(pythonMenu); Window menu JMenu windowMenu = new JMenu("Window"); JMenu layoutMenu = new JMenu("Layout"); layoutMenu.add(new ) windowMenu.add(minimizeAction); windowMenu.add(zoomAction); windowMenu.addSeparator(); windowMenu.add(layoutMenu); windowMenu.addSeparator(); windowMenu.add(bringAllToFrontAction); windowMenu.addSeparator(); menuBar.add(windowMenu); Help menu JMenu helpMenu = new JMenu("Help"); helpMenu.add(nodeboxSiteAction); menuBar.add(helpMenu); setJMenuBar(menuBar); } 
public boolean readFromFile ( File file ) { try { NodeLibrary library = getManager ( ) . load ( file ) ; setNodeLibrary ( library ) ; setDocumentFile ( file ) ; The parsed network is now stored in the reader documentChanged = false; return true; } catch (RuntimeException e) { logger.log(Level.SEVERE, "Error while parsing" + file, e); } return false; } 
public boolean saveToFile ( File file ) { try { nodeLibrary . store ( file ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , " An error occurred while saving the file. " , " MainController " , JOptionPane . ERROR_MESSAGE ) ; logger . log ( Level . SEVERE , " An error occurred while saving the file. " , e ) ; return false ; } documentChanged = false ; updateTitle ( ) ; return true ; 
public boolean exportToFile ( File file ) { todo: file export only works on grobs. if (activeNetwork == null || activeNetwork.getRenderedChild() == null) return false; Object outputValue = activeNetwork.getRenderedChild().getOutputValue(); net.nodebox.graphics.Canvas canvas; if (outputValue instanceof net.nodebox.graphics.Canvas) { canvas = (net.nodebox.graphics.Canvas) outputValue; } else if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; Rect bounds = g.getBounds(); canvas = new net.nodebox.graphics.Canvas(bounds.getWidth(), bounds.getHeight()); We need to translate the canvas to compensate for the x/y value of the grob. double dx = bounds.getWidth() / 2 + bounds.getX(); double dy = bounds.getHeight() / 2 + bounds.getY(); canvas.translate(-dx, -dy); canvas.add(g); } else { throw new RuntimeException("This type of output cannot be exported " + outputValue); } canvas.save(file); return true; } 
public boolean reloadActiveNode ( ) { if ( activeNode = = null ) return false ; TODO: What should reloading do? return activeNode.reload(); return false; } 
public void nodeDirty ( Node node ) { if ( node ! = activeNetwork ) return ; markChanged ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
private void doRender ( ) { renderThread.render(activeNetwork); } public void nodeUpdated(Node node) { Just here to statisfy DirtyListener interface. } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void nodeUpdated ( Node node ) { Just here to statisfy DirtyListener interface. } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class ExportAction extends AbstractAction { public ExportAction ( ) { putValue ( NAME , " Export... " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_E ) ) ; } public void actionPerformed ( ActionEvent e ) { export ( ) ; } } public class QuitAction extends AbstractAction { public QuitAction ( ) { putValue ( NAME , " Quit " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Q ) ) ; } public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . quit ( ) ; } } public class UndoAction extends AbstractAction { public UndoAction ( ) { putValue ( NAME , " Undo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . undo ( ) ; } catch ( CannotUndoException ex ) { logger . log ( Level . WARNING , " Unable to undo. " , ex ) ; } update ( ) ; redoAction . update ( ) ; } public void update ( ) { if ( undo . canUndo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getUndoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Undo " ) ; } } } public class RedoAction extends AbstractAction { public RedoAction ( ) { putValue ( NAME , " Redo " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_Z , Event . SHIFT_MASK ) ) ; setEnabled ( false ) ; } public void actionPerformed ( ActionEvent e ) { try { undo . redo ( ) ; } catch ( CannotRedoException ex ) { logger . log ( Level . WARNING , " Unable to redo. " , ex ) ; } update ( ) ; undoAction . update ( ) ; } public void update ( ) { if ( undo . canRedo ( ) ) { setEnabled ( true ) ; putValue ( Action . NAME , undo . getRedoPresentationName ( ) ) ; } else { setEnabled ( false ) ; putValue ( Action . NAME , " Redo " ) ; } } } public class CutAction extends AbstractAction { public CutAction ( ) { putValue ( NAME , " Cut " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_X ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class CopyAction extends AbstractAction { public CopyAction ( ) { putValue ( NAME , " Copy " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_C ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class PasteAction extends AbstractAction { public PasteAction ( ) { putValue ( NAME , " Paste " ) ; putValue ( ACCELERATOR_KEY , PlatformUtils . getKeyStroke ( KeyEvent . VK_V ) ) ; } public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { } } public class DeleteAction extends AbstractAction { public DeleteAction ( ) { putValue ( NAME , " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_DELETE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void actionPerformed ( ActionEvent e ) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public abstract Pane clone ( ) ; public void currentNodeChanged ( Node activeNetwork ) { } public void focusedNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); } public void changePaneType(Class paneType) { if (!Pane.class.isAssignableFrom(paneType)) return; Pane newPane; try { newPane = (Pane) paneType.newInstance(); } catch (Exception e) { e.printStackTrace(); return; } newPane.setDocument(getDocument()); Container parent = getParent(); Dimension d = getSize(); parent.remove(this); parent.add(newPane); newPane.setSize(d); parent.validate(); }} 
public void currentNodeChanged ( Node activeNetwork ) { } public void focusedNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); } public void changePaneType(Class paneType) { if (!Pane.class.isAssignableFrom(paneType)) return; Pane newPane; try { newPane = (Pane) paneType.newInstance(); } catch (Exception e) { e.printStackTrace(); return; } newPane.setDocument(getDocument()); Container parent = getParent(); Dimension d = getSize(); parent.remove(this); parent.add(newPane); newPane.setSize(d); parent.validate(); }} 
public void focusedNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); } public void changePaneType(Class paneType) { if (!Pane.class.isAssignableFrom(paneType)) return; Pane newPane; try { newPane = (Pane) paneType.newInstance(); } catch (Exception e) { e.printStackTrace(); return; } newPane.setDocument(getDocument()); Container parent = getParent(); Dimension d = getSize(); parent.remove(this); parent.add(newPane); newPane.setSize(d); parent.validate(); }} 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node = manager . getNode ( " corevector.rect " ) . newInstance ( testLibrary , " myrect " ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } 
public static String choosePath ( Node root , String path ) { PathDialog dialog = new PathDialog ( root ) ; dialog . setModal ( true ) ; dialog . setVisible ( true ) ; return dialog . getSelectedPath ( ) ; } 
public boolean isLeaf ( Object node ) { Node parentNode = ( Node ) node ; return ! parentNode . hasChildren ( ) ; } 
public void render ( Node node ) { this . node = node ; shouldRender = true ; } 
private void doRender ( ) { if ( isRendering ) return ; isRendering = true ; node . update ( ) ; shouldRender = false ; isRendering = false ; } 
public void focusedNodeChanged ( Node activeNode ) { setActiveNode ( activeNode ) ; } 
public static void main ( String [ ] args ) { File editorDirectory = new File ( PlatformUtils . getUserNodeTypeLibraryDirectory ( ) ) ; JFrame frame = new JFrame ( " Simple Editor " ) ; JPanel rootPanel = new JPanel ( new BorderLayout ( ) ) ; rootPanel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 ) ) ; DirectoryEditor e = new DirectoryEditor ( ) ; e . setEditorDirectory ( editorDirectory ) ; rootPanel . add ( e ) ; frame . setContentPane ( rootPanel ) ; frame . setLocationByPlatform ( true ) ; frame . setSize ( 1100 , 800 ) ; frame . setVisible ( true ) ; } 
public void insertUpdate ( DocumentEvent e ) { setChanged ( true ) ; } 
public void removeUpdate ( DocumentEvent e ) { setChanged ( true ) ; } 
public void changedUpdate ( DocumentEvent e ) { setChanged ( true ) ; } 
public void valueChanged ( Parameter source ) { setValueForControl ( source . getValue ( ) ) ; } 
public void focusedNodeChanged ( Node node ) { if ( colorDialog ! = null ) { colorDialog . dispose ( ) ; 
public void actionPerformed ( ActionEvent e ) { Parameter . MenuItem item = ( Parameter . MenuItem ) menuBox . getSelectedItem ( ) ; parameter . setValue ( item . getKey ( ) ) ; } 
public void valueChanged ( Parameter source ) { Object newValue = source . getValue ( ) ; if ( value ! = null & & value . equals ( newValue ) ) return ; setValueForControl ( newValue ) ; } 
public void actionPerformed ( ActionEvent e ) { String newPath = PathDialog . choosePath ( parameter . getNode ( ) . getRoot ( ) , parameter . asString ( ) ) ; parameter . setValue ( newPath ) ; } 
private void moveDown ( ) { Connection c = getConnection ( ) ; if ( c = = null ) return ; Port selectedPort = ( Port ) outputList . getSelectedValue ( ) ; if ( selectedPort = = null ) return ; java . util . List < Port > ports = c . getOutputs ( ) ; int index = ports . indexOf ( selectedPort ) ; assert ( index > = 0 ) ; if ( index > = ports . size ( ) - 1 ) return ; ports . remove ( selectedPort ) ; ports . add ( index + 1 , selectedPort ) ; reloadList ( ) ; outputList . setSelectedIndex ( index + 1 ) ; input . getNode ( ) . markDirty ( ) ; } 
private void moveUp ( ) { Connection c = getConnection ( ) ; if ( c = = null ) return ; Port selectedPort = ( Port ) outputList . getSelectedValue ( ) ; if ( selectedPort = = null ) return ; java . util . List < Port > ports = c . getOutputs ( ) ; int index = ports . indexOf ( selectedPort ) ; assert ( index > = 0 ) ; if ( index = = 0 ) return ; ports . remove ( selectedPort ) ; ports . add ( index - 1 , selectedPort ) ; reloadList ( ) ; outputList . setSelectedIndex ( index - 1 ) ; input . getNode ( ) . markDirty ( ) ; } 
private void removeSelected ( ) { Port output = ( Port ) outputList . getSelectedValue ( ) ; if ( output = = null ) return ; Node node = input . getNode ( ) ; node . disconnect ( input , output . getNode ( ) ) ; reloadList ( ) ; } 
private void reloadList ( ) { outputList . setModel ( portListModel ) ; outputList . repaint ( ) ; } 
public void currentNodeChanged ( Node activeNetwork ) { setNode ( activeNetwork ) ; } 
public void childAdded ( Node source , Node child ) { NodeView nv = new NodeView ( this , node ) ; getLayer ( ) . addChild ( nv ) ; } 
public void childRemoved ( Node source , Node child ) { NodeView nv = getNodeView ( node ) ; if ( nv = = null ) return ; getLayer ( ) . removeChild ( nv ) ; if ( selection . contains ( nv ) ) { deselect ( nv ) ; 
public void connectionAdded ( Node source , Connection connection ) { connectionLayer . repaint ( ) ; } 
public void connectionRemoved ( Node source , Connection connection ) { connectionLayer . repaint ( ) ; } 
public void renderedChildChanged ( Node source , Node child ) { repaint ( ) ; } 
public void nodeUpdated ( Node node ) { if ( ! networkError & & ! node . hasError ( ) ) return ; networkError = node . hasError ( ) ; repaint ( ) ; } 
private boolean smartConnect ( Node activeNode , Node newNode ) { Check if there is an active node. if (activeNode == null) return false; Check if there are compatible ports on the new node that can be connected to the output of the active node. List<Port> compatibles = newNode.getCompatibleInputs(activeNode); if (compatibles.size() == 0) return false; Connect the output of the active node to the first compatible input of the new node. compatibles.get(0).connect(activeNode); Move the node under the active node. newNode.setPosition(activeNode.getX(), activeNode.getY() + 40); Return true to indicate the connection was created successfully. return true; } 
private void selectAndClose ( ) { selectedNode = ( Node ) nodeList . getSelectedValue ( ) ; closeDialog ( ) ; } 
public void actionPerformed ( ActionEvent e ) { addParameter ( ) ; } 
public void actionPerformed ( ActionEvent e ) { removeSelectedParameter ( ) ; } 
private void addParameter ( ) { String parameterName = JOptionPane . showInputDialog ( " Enter parameter name " ) ; if ( parameterName ! = null ) { Parameter parameter = node . addParameter ( parameterName , Parameter . Type . FLOAT ) ; 
private void moveDown ( ) { if ( selectedParameter = = null ) return ; java . util . List < Parameter > parameterTypes = node . getParameters ( ) ; int index = parameterTypes . indexOf ( selectedParameter ) ; assert ( index > = 0 ) ; if ( index > = parameterTypes . size ( ) - 1 ) return ; parameterTypes . remove ( selectedParameter ) ; parameterTypes . add ( index + 1 , selectedParameter ) ; reloadParameterList ( ) ; parameterList . setSelectedIndex ( index + 1 ) ; } 
private void moveUp ( ) { if ( selectedParameter = = null ) return ; java . util . List < Parameter > parameterTypes = node . getParameters ( ) ; int index = parameterTypes . indexOf ( selectedParameter ) ; assert ( index > = 0 ) ; if ( index = = 0 ) return ; parameterTypes . remove ( selectedParameter ) ; parameterTypes . add ( index - 1 , selectedParameter ) ; reloadParameterList ( ) ; parameterList . setSelectedIndex ( index - 1 ) ; } 
private void reloadParameterList ( ) { parameterList . setModel ( parameterListModel ) ; parameterList . repaint ( ) ; } 
public void initParameterPanel ( ) { parameterPanel = new JPanel ( ) ; parameterPanel . setLayout ( new BoxLayout ( parameterPanel , BoxLayout . Y_AXIS ) ) ; JPanel contentPanel = new JPanel ( new GridLayout ( 10 , 2 , 10 , 5 ) ) ; contentPanel . add ( new JLabel ( " Name " ) ) ; nameField = new JTextField ( 20 ) ; nameField . setEditable ( false ) ; contentPanel . add ( nameField ) ; contentPanel . add ( new JLabel ( " Label " ) ) ; labelField = new JTextField ( 20 ) ; labelField . addActionListener ( this ) ; contentPanel . add ( labelField ) ; contentPanel . add ( new JLabel ( " Description " ) ) ; descriptionField = new JTextField ( 20 ) ; descriptionField . addActionListener ( this ) ; contentPanel . add ( descriptionField ) ; contentPanel . add ( new JLabel ( " Type " ) ) ; typeBox = new JComboBox ( new String [ ] { " angle " , " color " , " file " , " float " , " font " , " gradient " , " image " , " int " , " menu " , " seed " , " string " , " text " , " toggle " , " noderef " , " grob_canvas " , " grob_vector " , " grob_image " } ) ; typeBox . addActionListener ( this ) ; contentPanel . add ( typeBox ) ; contentPanel . add ( new JLabel ( " Default Value " ) ) ; valueField = new JTextField ( 20 ) ; valueField . addActionListener ( this ) ; contentPanel . add ( valueField ) ; contentPanel . add ( new JLabel ( " " ) ) ; nullAllowedCheck = new JCheckBox ( " Null allowed " ) ; nullAllowedCheck . addActionListener ( this ) ; contentPanel . add ( nullAllowedCheck ) ; contentPanel . add ( new JLabel ( " Bounding " ) ) ; boundingMethodBox = new JComboBox ( new String [ ] { " none " , " soft " , " hard " } ) ; boundingMethodBox . addActionListener ( this ) ; contentPanel . add ( boundingMethodBox ) ; contentPanel . add ( new JLabel ( " Minimum " ) ) ; minimumValueCheck = new JCheckBox ( ) ; minimumValueCheck . addActionListener ( this ) ; minimumValueField = new JTextField ( 10 ) ; minimumValueField . addActionListener ( this ) ; JPanel minimumValuePanel = new JPanel ( new FlowLayout ( FlowLayout . LEADING , 5 , 0 ) ) ; minimumValuePanel . add ( minimumValueCheck ) ; minimumValuePanel . add ( minimumValueField ) ; contentPanel . add ( minimumValuePanel ) ; contentPanel . add ( new JLabel ( " Maximum " ) ) ; maximumValueCheck = new JCheckBox ( ) ; maximumValueCheck . addActionListener ( this ) ; maximumValueField = new JTextField ( 10 ) ; maximumValueField . addActionListener ( this ) ; JPanel maximumValuePanel = new JPanel ( new FlowLayout ( FlowLayout . LEADING , 5 , 0 ) ) ; maximumValuePanel . add ( maximumValueCheck ) ; maximumValuePanel . add ( maximumValueField ) ; contentPanel . add ( maximumValuePanel ) ; contentPanel . add ( new JLabel ( " Display Level " ) ) ; displayLevelBox = new JComboBox ( new String [ ] { " hud " , " detail " , " hidden " } ) ; displayLevelBox . addActionListener ( this ) ; contentPanel . add ( displayLevelBox ) ; parameterPanel . add ( contentPanel ) ; Dimension fillDimension = new Dimension ( 0 , Integer . MAX_VALUE ) ; parameterPanel . add ( new Box . Filler ( fillDimension , fillDimension , fillDimension ) ) ; } 
public void clearForm ( ) { nameField . setText ( " " ) ; labelField . setText ( " " ) ; descriptionField . setText ( " " ) ; typeBox . setSelectedIndex ( 0 ) ; valueField . setText ( " " ) ; nullAllowedCheck . setSelected ( false ) ; boundingMethodBox . setSelectedIndex ( 0 ) ; minimumValueCheck . setSelected ( false ) ; minimumValueField . setText ( " " ) ; maximumValueCheck . setSelected ( false ) ; maximumValueField . setText ( " " ) ; displayLevelBox . setSelectedIndex ( 0 ) ; } 
public void valueChanged ( ListSelectionEvent e ) { if ( selectedParameter = = parameterList . getSelectedValue ( ) ) return ; selectedParameter = ( Parameter ) parameterList . getSelectedValue ( ) ; if ( selectedParameter = = null ) { setFormEnabled ( false ) ; clearForm ( ) ; removeButton . setEnabled ( false ) ; } else { setFormEnabled ( true ) ; removeButton . setEnabled ( true ) ; nameField . setText ( selectedParameter . getName ( ) ) ; labelField . setText ( selectedParameter . getLabel ( ) ) ; descriptionField.setText(selectedParameter.getDescription()); typeBox.setSelectedItem(selectedParameter.getType().toString().toLowerCase()); valueField.setText(selectedParameter.getDefaultValue().toString()); nullAllowedCheck.setSelected(selectedParameter.isNullAllowed()); Parameter.BoundingMethod boundingMethod = selectedParameter.getBoundingMethod(); boundingMethodBox.setSelectedItem(boundingMethod.toString().toLowerCase()); Object minimumValue = selectedParameter.getMinimumValue(); String minimumValueString = minimumValue == null ? "" : minimumValue.toString(); minimumValueCheck.setSelected(minimumValue != null); minimumValueField.setText(minimumValueString); minimumValueField.setEnabled(minimumValue != null); Object maximumValue = selectedParameter.getMaximumValue(); String maximumValueString = maximumValue == null ? "" : maximumValue.toString(); maximumValueCheck.setSelected(maximumValue != null); maximumValueField.setText(maximumValueString); maximumValueField.setEnabled(maximumValue != null); displayLevelBox.setSelectedItem(selectedParameter.getDisplayLevel().toString().toLowerCase()); } parameterPanel.revalidate(); } 
public static void main ( String [ ] args ) { JFrame editorFrame = new JFrame ( ) ; Node node = new NodeBoxDocument . AllControlsType ( ) . createInstance ( ) ; editorFrame . getContentPane ( ) . add ( new NodeTypeEditor ( node ) ) ; editorFrame . setSize ( 800 , 800 ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; editorFrame . setVisible ( true ) ; } 
public void mouseReleased ( PInputEvent event ) { if ( isConnecting ) { if ( connectTarget ! = null ) connectTarget . repaint ( ) ; NodeView . this . repaint ( ) ; if ( connectSource ! = null & & connectTarget ! = null ) { java . util . List < Port > compatiblePorts = connectTarget . getNode ( ) . getCompatibleInputs ( connectSource . getNode ( ) ) ; if ( compatiblePorts . isEmpty ( ) ) { There are no compatible parameters. } else if (compatiblePorts.size() == 1) { Only one possible connection, make it now. Port inputPort = compatiblePorts.get(0); try { inputPort.connect(connectSource.getNode()); } catch (ConnectionError e) { JOptionPane.showMessageDialog(networkView, e.getMessage(), "Connection error", JOptionPane.ERROR_MESSAGE); } } else { JPopupMenu menu = new JPopupMenu("Select input"); for (Port p : compatiblePorts) { Action a = new SelectCompatiblePortAction(connectSource.getNode(), connectTarget.getNode(), p); menu.add(a); } Point pt = getNetworkView().getMousePosition(); menu.show(getNetworkView(), pt.x, pt.y); } } } isDragging = false; isConnecting = false; connectSource = null; connectTarget = null; } 
public void actionPerformed ( ActionEvent e ) { try { inputPort . connect ( outputNode ) ; 
public void actionPerformed ( ActionEvent e ) { node . getParent ( ) . remove ( node ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); g2.translate(getWidth() / 2.0, getHeight() / 2.0); if (getNode() == null) return; Object outputValue = getNode().getOutputValue(); if (outputValue instanceof Grob) { ((Grob) outputValue).draw(g2); } Draw handle if (handle != null && showHandle) { Create a canvas with a transparent background 
public boolean disconnect ( Port input , Node outputNode ) { if ( input = = null ) throw new IllegalArgumentException ( " The input port cannot be null. " ) ; if ( outputNode = = null ) throw new IllegalArgumentException ( " The output node cannot be null. " ) ; if ( input . getParentNode ( ) ! = outputNode . getParent ( ) ) throw new IllegalArgumentException ( " The input and output are not under the same parent. " ) ; if ( ! input . isInputPort ( ) ) throw new IllegalArgumentException ( " The given port is not an input. " ) ; Node parent = input . getParentNode ( ) ; if ( parent = = null ) return false ; DependencyGraph < Port , Connection > dg = parent . childGraph ; if ( dg = = null ) return false ; Port output = outputNode . outputPort ; boolean removedSomething = dg . removeDependency ( output , input ) ; if ( removedSomething ) { input . reset ( ) ; This port was changed. Mark the node as dirty. input.getNode().markDirty(); } return removedSomething; } 
public void testLoading ( ) { NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary library = manager . load ( new File ( " test/polynodes.ndbx " ) ) ; assertTrue ( library . contains ( " rect " ) ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node rect = manager . getNode ( " polynodes.rect " ) ; Parameter pX = rect . getParameter ( " x " ) ; assertEquals ( Parameter . Type . FLOAT , pX . getType ( ) ) ; Node rect1 = rect . newInstance ( testLibrary , " rect1 " ) ; rect1 . setValue ( " x " , 20 ) ; rect1 . setValue ( " y " , 30 ) ; rect1 . setValue ( " width " , 40 ) ; rect1 . setValue ( " height " , 50 ) ; rect1 . update ( ) ; Object value = rect1 . getOutputValue ( ) ; assertEquals ( Polygon . class , value . getClass ( ) ) ; Polygon polygon = ( Polygon ) value ; assertEquals ( new Rectangle ( 20 , 30 , 40 , 50 ) , polygon . getBounds ( ) ) ; } 
public void toXml ( StringBuffer xml , String spaces ) { We only write out the attributes that have changed with regards to the prototype. Node protoNode = getNode().getPrototype(); Parameter protoParam = null; if (protoNode != null) protoParam = protoNode.getParameter(getName()); If the parameter and its prototype are completely equal, don't write anything. if (prototypeEquals(protoParam)) return; The parameters are not equal, so we can start writing the name. xml.append(spaces).append("<param name=\"").append(getName()).append("\""); Write parameter type if (protoParam == null || !getType().equals(protoParam.getType())) xml.append(" type=\"").append(getType().toString().toLowerCase()).append("\""); xml.append(">"); Write parameter value / expression if (hasExpression()) { xml.append(spaces).append("<expression>").append(getExpression()).append("</expression>"); } else { if (type == Type.INT) { xml.append(spaces).append(" <value>").append(asInt()).append("</value>"); } else if (type == Type.FLOAT) { xml.append(spaces).append(" <value>").append(asFloat()).append("</value>"); } else if (type == Type.STRING) { xml.append(spaces).append(" <value>").append(asString()).append("</value>"); } else if (type == Type.COLOR) { xml.append(spaces).append(" <value>").append(asColor().toString()).append("</value>"); } else if (type == Type.CODE) { xml.append(spaces).append(" <value type=\"").append(asCode().getType()).append("\"><![CDATA[").append(asCode().getSource()).append("]]></value>"); } else { throw new AssertionError("Unknown value class " + type); } } xml.append(spaces).append("</param>"); } 
public void testCreate ( ) { Node grandParent = testNetworkNode . newInstance ( testLibrary , " grandParent " ) ; Node parent = grandParent . create ( testNetworkNode , " parent " ) ; Node child = parent . create ( numberNode ) ; assertTrue ( grandParent . contains ( parent ) ) ; assertTrue ( parent . contains ( child ) ) ; Contains doesn't go into child networks. assertFalse(grandParent.contains(child)); assertTrue(child.hasParent()); assertTrue(grandParent.hasParent()); assertTrue(child.hasParent()); assertFalse(testLibrary.getRootNode().hasParent()); assertEquals(testLibrary.getRootNode(), grandParent.getParent()); assertEquals(grandParent, parent.getParent()); assertEquals(parent, child.getParent()); } 
public void testCodeLoading ( ) { Node hello = Node . ROOT_NODE . newInstance ( testLibrary , " hello " ) ; String code = " def cook(self): n return 'hello' " ; hello . setValue ( " _code " , new PythonCode ( code ) ) ; hello . update ( ) ; assertEquals ( " hello " , hello . getOutputValue ( ) ) ; Store/load library String xml = testLibrary.toXml(); NodeLibrary newLibrary = manager.load("newLibrary", xml); Node newHello = newLibrary.get("hello"); newHello.update(); assertEquals("hello", newHello.getOutputValue()); } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); g2.translate(getWidth() / 2.0, getHeight() / 2.0); if (getNode() == null) return; Object outputValue = getNode().getOutputValue(); if (outputValue instanceof Grob) { ((Grob) outputValue).draw(g2); } else if (outputValue != null) { String s = outputValue.toString(); g2.drawString(s, 5, 20); } Draw handle if (handle != null && showHandle) { Create a canvas with a transparent background 
public Handle createHandle ( ) { NodeCode handleCode = asCode ( " _handle " ) ; if ( handleCode = = null ) return null ; TODO: Do we need the ProcessingContext in the handle or can we pass null? Object handleObj = handleCode.cook(this, new ProcessingContext()); if (handleObj == null) return null; if (!(handleObj instanceof Handle)) throw new AssertionError("Handle code for node " + getName() + " does not return Handle object."); return (Handle) handleObj; } 
public void testPersistence ( ) { Node polynet1 = manager . getNode ( " polygraph.network " ) . newInstance ( testLibrary , " polynet1 " ) ; Node polynet1 = testLibrary.getRootNode().create(manager.getNode("polygraph.network"), "polynet1"); polynet1.setPosition(10, 10); assertEquals("polynet1", polynet1.getName()); polynet1.setRendered(); Node polygon1 = polynet1.create(manager.getNode("polygraph.polygon")); assertEquals("polygon1", polygon1.getName()); polygon1.setRendered(); polygon1.setPosition(100, 30); Node translate1 = polynet1.create(manager.getNode("polygraph.translate")); assertEquals("translate1", translate1.getName()); translate1.setPosition(40, 80); translate1.setRendered(); translate1.getPort("polygon").connect(polygon1); Node rect1 = polynet1.create(manager.getNode("polygraph.rect")); assertEquals("rect1", rect1.getName()); rect1.setPosition(180, 30); Node merge1 = polynet1.create(manager.getNode("polygraph.merge")); assertEquals("merge1", merge1.getName()); merge1.getPort("polygons").connect(translate1); merge1.getPort("polygons").connect(rect1); NodeLibrary newLibrary = storeAndLoad(testLibrary); Node newRoot = newLibrary.getRootNode(); assertEquals("root", newRoot.getName()); assertTrue(newRoot.contains("polynet1")); Node nPolynet1 = newRoot.getChild("polynet1"); assertTrue(nPolynet1.contains("polygon1")); assertTrue(nPolynet1.contains("translate1")); Node nPolygon1 = nPolynet1.getChild("polygon1"); Node nTranslate1 = nPolynet1.getChild("translate1"); Node nRect1 = nPolynet1.getChild("rect1"); Node nMerge1 = nPolynet1.getChild("merge1"); assertEquals(polygon1.getValue("x"), nPolygon1.getValue("x")); assertEquals(polygon1.getValue("fill"), nPolygon1.getValue("fill")); assertEquals(polygon1.getValue("stroke"), nPolygon1.getValue("stroke")); assertTrue(nPolygon1.isConnected()); assertTrue(nTranslate1.isConnected()); assertTrue(nTranslate1.getPort("polygon").isConnectedTo(nPolygon1)); assertTrue(nMerge1.getPort("polygons").isConnectedTo(nRect1)); assertTrue(nMerge1.getPort("polygons").isConnectedTo(nTranslate1)); Check if this is the same connection Port nPolygons = nMerge1.getPort("polygons"); assertEquals(1, nTranslate1.getDownstreamConnections().size()); assertEquals(1, nRect1.getDownstreamConnections().size()); Connection c1 = nTranslate1.getDownstreamConnections().iterator().next(); Connection c2 = nRect1.getDownstreamConnections().iterator().next(); assertTrue(c1 == c2); This tests for a bug where the connection would be created twice. nMerge1.getPort("polygons").disconnect(); assertFalse(nPolygons.isConnectedTo(nRect1)); assertFalse(nPolygons.isConnectedTo(nTranslate1)); } 
public void testCodeLoading ( ) { Node hello = Node . ROOT_NODE . newInstance ( testLibrary , " hello " ) ; String code = " def cook(self): n return 'hello' " ; hello . setValue ( " _code " , new PythonCode ( code ) ) ; hello . update ( ) ; assertEquals ( " hello " , hello . getOutputValue ( ) ) ; Store/load library NodeLibrary newLibrary = storeAndLoad(testLibrary); Node newHello = newLibrary.get("hello"); newHello.update(); assertEquals("hello", newHello.getOutputValue()); } 
public void testTypeLoading ( ) { Node alltypes = Node . ROOT_NODE . newInstance ( testLibrary , " alltypes " ) ; alltypes . addParameter ( " i " , Parameter . Type . INT , 42 ) ; alltypes . addParameter ( " f " , Parameter . Type . FLOAT , 42 F ) ; alltypes . addParameter ( " s " , Parameter . Type . STRING , " 42 " ) ; alltypes . addParameter ( " c " , Parameter . Type . COLOR , new Color ( 0.4 , 0.2 , 0.1 , 0.9 ) ) ; TODO: You are here. NodeLibrary newLibrary = storeAndLoad(testLibrary); Node newAlltypes = newLibrary.get("alltypes"); Parameter pI = newAlltypes.getParameter("i"); Parameter pF = newAlltypes.getParameter("f"); Parameter pS = newAlltypes.getParameter("s"); Parameter pC = newAlltypes.getParameter("c"); assertEquals(Parameter.Type.INT, pI.getType()); assertEquals(Parameter.Type.FLOAT, pF.getType()); assertEquals(Parameter.Type.STRING, pS.getType()); assertEquals(Parameter.Type.COLOR, pC.getType()); assertEquals("i", pI.getName()); assertEquals(42, pI.getValue()); assertEquals(42F, pF.getValue()); assertEquals("42", pS.getValue()); assertEquals(new Color(0.4, 0.2, 0.1, 0.9), pC.getValue()); } 
private NodeLibrary storeAndLoad ( NodeLibrary lib ) { String xml = testLibrary . toXml ( ) ; return manager . load ( " newLibrary " , xml ) ; } 
public void testNewInstance ( ) { NodeLibrary test = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( test , " alpha " ) ; assertTrue ( test . contains ( " alpha " ) ) ; assertTrue ( test . getRootNode ( ) . contains ( " alpha " ) ) ; assertTrue ( test . getRootNode ( ) . contains ( alpha ) ) ; } 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof Color ) ) return false ; Color other = ( Color ) obj ; Because of the conversion to/from hex, we can have rounding errors. Therefore, we only compare what we can store, i.e. values in the 0-255 range. return Math.round(r * 255) == Math.round(other.r * 255) && Math.round(g * 255) == Math.round(other.g * 255) 
public static Color parseColor ( String value ) { return new Color ( value ) ; } 
public void testTypeLoading ( ) { Node alltypes = Node . ROOT_NODE . newInstance ( testLibrary , " alltypes " ) ; alltypes . addParameter ( " i " , Parameter . Type . INT , 42 ) ; alltypes . addParameter ( " f " , Parameter . Type . FLOAT , 42 F ) ; alltypes . addParameter ( " s " , Parameter . Type . STRING , " 42 " ) ; alltypes . addParameter ( " c " , Parameter . Type . COLOR , new Color ( 0.4 , 0.2 , 0.1 , 0.9 ) ) ; NodeLibrary newLibrary = storeAndLoad ( testLibrary ) ; Node newAlltypes = newLibrary . get ( " alltypes " ) ; Parameter pI = newAlltypes . getParameter ( " i " ) ; Parameter pF = newAlltypes . getParameter ( " f " ) ; Parameter pS = newAlltypes . getParameter ( " s " ) ; Parameter pC = newAlltypes . getParameter ( " c " ) ; assertEquals ( Parameter . Type . INT , pI . getType ( ) ) ; assertEquals ( Parameter . Type . FLOAT , pF . getType ( ) ) ; assertEquals ( Parameter . Type . STRING , pS . getType ( ) ) ; assertEquals ( Parameter . Type . COLOR , pC . getType ( ) ) ; assertEquals ( " i " , pI . getName ( ) ) ; assertEquals ( 42 , pI . getValue ( ) ) ; assertEquals ( 42 F , pF . getValue ( ) ) ; assertEquals ( " 42 " , pS . getValue ( ) ) ; assertEquals ( new Color ( 0.4 , 0.2 , 0.1 , 0.9 ) , pC . getValue ( ) ) ; } 
public void childAdded ( Node source , Node child ) { NodeView nv = new NodeView ( this , child ) ; getLayer ( ) . addChild ( nv ) ; } 
public void childRemoved ( Node source , Node child ) { NodeView nv = getNodeView ( child ) ; if ( nv = = null ) return ; getLayer ( ) . removeChild ( nv ) ; if ( selection . contains ( nv ) ) { deselect ( nv ) ; 
public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) { NodeView nv = getNodeView ( child ) ; if ( nv = = null ) return ; if ( attribute = = NodeAttributeListener . Attribute . NAME ) { nv . repaint ( ) ; 
public void processEvent ( PInputEvent e , int i ) { if ( ! e . isPopupTrigger ( ) ) return ; JPopupMenu menu = new JPopupMenu ( ) ; menu . add ( new SetRenderedAction ( ) ) ; menu . add ( new RenameAction ( ) ) ; menu . add ( new DeleteAction ( ) ) ; Point2D p = e . getCanvasPosition ( ) ; menu . show ( NodeView . this . networkView , ( int ) p . getX ( ) , ( int ) p . getY ( ) ) ; e . setHandled ( true ) ; } 
public void actionPerformed ( ActionEvent e ) { String s = JOptionPane . showInputDialog ( networkView , " New name: " , node . getName ( ) ) ; if ( s = = null | | s . length ( ) = = 0 ) return ; try { node . setName ( s ) ; 
public void setName ( String name ) throws InvalidNameException { if ( this . name . equals ( name ) ) return ; validateName ( name ) ; this . name = name ; fireNodeAttributeChanged ( Attribute . NAME ) ; } 
public static void validateName ( String name ) throws InvalidNameException { Matcher m1 = NODE_NAME_PATTERN . matcher ( name ) ; Matcher m2 = DOUBLE_UNDERSCORE_PATTERN . matcher ( name ) ; Matcher m3 = RESERVED_WORD_PATTERN . matcher ( name ) ; if ( ! m1 . matches ( ) ) { throw new InvalidNameException ( null , name , " Names can only contain lowercase letters, numbers, and the underscore. Names cannot be longer than 29 characters. " ) ; } if ( m2 . matches ( ) ) { throw new InvalidNameException ( null , name , " Names starting with double underscore are reserved for internal use. " ) ; } if ( m3 . matches ( ) ) { throw new InvalidNameException ( null , name , " Names cannot be a reserved word (network, node, root). " ) ; 
public boolean remove ( Node node ) { assert ( node ! = null ) ; if ( ! contains ( node ) ) return false ; node.markDirty(); node.disconnect(); node.parent = null; children.remove(node.getName()); if (node == renderedChild) { setRenderedChild(null); } node.removeNodeAttributeListener(this); fireChildRemoved(node); return true; } 
public void attributeChanged ( Node source , Attribute attribute ) { We only need to react to name changes. if (attribute != Attribute.NAME) return; Check if the node exists and remove it in one operation. If remove() returns true, the given node is not a child and we should not store it. if (!children.values().remove(source)) return; children.put(source.getName(), source); } 
public Parameter addParameter ( String name , Parameter . Type type ) { Parameter p = new Parameter ( this , name , type ) ; parameters . put ( name , p ) ; fireNodeAttributeChanged ( Attribute . PARAMETER ) ; return p ; } 
public Parameter addParameter ( String name , Parameter . Type type , Object value ) { Parameter p = addParameter ( name , type ) ; p . setValue ( value ) ; fireNodeAttributeChanged ( Attribute . PARAMETER ) ; return p ; } 
public boolean removeParameter ( String name ) { First remove all dependencies to and from this parameter. Don't rewrite any expressions. Parameter p = parameters.get(name); if (p == null) return false; p.removedEvent(); parameters.remove(name); fireNodeAttributeChanged(Attribute.PARAMETER); markDirty(); return true; } 
public void fireNodeAttributeChanged ( Attribute attribute ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeAttributeListener.class) { ((NodeAttributeListener) listeners[i + 1]).attributeChanged(this, attribute); } } if (hasParent()) getParent().fireChildAttributeChanged(this, attribute); 
public void fireChildAttributeChanged ( Node child , Attribute attribute ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == NodeChildListener.class) { 
public Object cook ( Node node , ProcessingContext context ) throws ProcessingError { if ( ! node . hasChildren ( ) ) return null ; Node renderedChild = node . getRenderedChild ( ) ; if ( renderedChild = = null ) throw new ProcessingError ( this , " No child node to render. " ) ; renderedChild . update ( context ) ; return renderedChild . getOutputValue ( ) ; } 
public void childAdded ( Node source , Node child ) ; public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) ; } 
public void childRemoved ( Node source , Node child ) ; public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) ; } 
public void connectionAdded ( Node source , Connection connection ) ; public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) ; } 
public void connectionRemoved ( Node source , Connection connection ) ; public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) ; } 
public void renderedChildChanged ( Node source , Node child ) ; public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) ; } 
public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) ; } 
public void setName ( String name ) throws InvalidNameException { if ( name ! = null & & getName ( ) . equals ( name ) ) return ; validateName ( name ) ; String oldName = this . name ; this . name = name ; node . renameParameter ( this , oldName , name ) ; node . fireNodeAttributeChanged ( NodeAttributeListener . Attribute . PARAMETER ) ; } 
public void testRemove ( ) { First add a node Node net = testNetworkNode.newInstance(testLibrary, "net1"); Node number1 = net.create(numberNode); We add a second node to check for the processing error. If there are no nodes in the parent, the root will just return null. net.create(numberNode); number1.setValue("value", 42); number1.setRendered(); net.update(); assertEquals(42, net.getOutputValue()); Now remove and update again net.remove(number1); assertNull(net.getRenderedChild()); This should cause the network to complain that there is no node to render. assertProcessingError(net, ProcessingError.class); The output value should revert to null. assertEquals(null, net.getOutputValue()); } 
public void childAdded ( Node source , Node child ) { + + childAddedCounter ; } 
public void childRemoved ( Node source , Node child ) { + + childRemovedCounter ; } 
public void connectionAdded ( Node source , Connection connection ) { + + connectionAddedCounter ; } 
public void connectionRemoved ( Node source , Connection connection ) { + + connectionRemovedCounter ; } 
public void renderedChildChanged ( Node source , Node child ) { + + renderedChildChangedCounter ; } 
public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) { + + childAttributeChangedCounter ; } 
public void testChildEvent ( ) { TestChildListener l1 = new TestChildListener ( ) ; TestChildListener l2 = new TestChildListener ( ) ; Node parent1 = Node . ROOT_NODE . newInstance ( testLibrary , " parent1 " ) ; Node parent2 = Node . ROOT_NODE . newInstance ( testLibrary , " parent2 " ) ; parent1 . addNodeChildListener ( l1 ) ; parent2 . addNodeChildListener ( l2 ) ; Node n1 = parent1 . create ( numberNode ) ; assertEquals ( 1 , l1 . childAddedCounter ) ; n1 . setParent ( parent2 ) ; assertEquals ( 1 , l1 . childAddedCounter ) ; assertEquals ( 1 , l2 . childAddedCounter ) ; assertEquals ( 1 , l1 . childRemovedCounter ) ; } 
public void attributeChanged ( Node source , Attribute attribute ) { switch ( attribute ) { case LIBRARY : 
public void testBaseNode ( ) { Node baseNode = Node . ROOT_NODE ; Parameter pCode = baseNode . getParameter ( " _code " ) ; Parameter pHandle = baseNode . getParameter ( " _handle " ) ; assertEquals ( " _code " , pCode . getName ( ) ) ; assertEquals ( Parameter . Type . CODE , pCode . getType ( ) ) ; assertEquals ( " _handle " , pHandle . getName ( ) ) ; assertEquals ( Parameter . Type . CODE , pHandle . getType ( ) ) ; baseNode . update ( ) ; assertNull ( baseNode . getOutputValue ( ) ) ; } 
public void testNodeAttributeEvent ( ) { TestAttributeListener l = new TestAttributeListener ( ) ; Node test = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; test . addNodeAttributeListener ( l ) ; Setting the name to itself does not trigger an event. test.setName("test"); assertEquals(0, l.nameCounter); test.setName("newname"); assertEquals(1, l.nameCounter); Parameter p1 = test.addParameter("p1", Parameter.Type.FLOAT); assertEquals(1, l.parameterCounter); p1.setName("parameter1"); assertEquals(2, l.parameterCounter); TODO: These trigger ParameterAttributeChanged p1.setBoundingMethod(Parameter.BoundingMethod.HARD); assertEquals(3, l.parameterCounter); p1.setMinimumValue(0F); assertEquals(4, l.parameterCounter); Changing the value does not trigger the event. The event only happens for metadata, not data. If you want to catch that, use DirtyListener. p1.setValue(20F); assertEquals(2, l.parameterCounter); test.removeParameter("parameter1"); assertEquals(3, l.parameterCounter); } 
protected void paintComponent ( Graphics g ) { java . util . List < Node > nodes = getNetworkParts ( ) ; positions = new int [ nodes . size ( ) ] ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( font ) ; g2 . drawImage ( addressGradient , 0 , 0 , getWidth ( ) , 26 , null ) ; int x = 6 ; for ( int i = 0 ; i < nodes . size ( ) ; i + + ) { Node part = nodes . get ( i ) ; 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { int mx = e . getX ( ) ; armed = partIndex ( mx ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; java . util . List < Node > nodes = getNetworkParts ( ) ; Node selectedNode = nodes . get ( partIndex ) ; System.out.println("part = " + selectedNode); if (selectedNode != null) document.setActiveNetwork(selectedNode); repaint(); } public void mouseEntered(MouseEvent e) { } public void mouseExited(MouseEvent e) { armed = -1; repaint(); } private int partIndex(int x) { if (positions == null) return -1; for (int i = 0; i < positions.length; i++) { if (x < positions[i]) return i; } return -1; } public static void drawShadowText(Graphics2D g2, String s, int x, int y) { Color c = g2.getColor(); g2.setColor(shadowColor); g2.drawString(s, x, y + 1); g2.setColor(c); g2.drawString(s, x, y); }} 
public void mousePressed ( MouseEvent e ) { int mx = e . getX ( ) ; armed = partIndex ( mx ) ; repaint ( ) ; } 
public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; java . util . List < Node > nodes = getNetworkParts ( ) ; Node selectedNode = nodes . get ( partIndex ) ; System.out.println("part = " + selectedNode); if (selectedNode != null) document.setActiveNetwork(selectedNode); repaint(); } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } public static void drawShadowText ( Graphics2D g2 , String s , int x , int y ) { Color c = g2 . getColor ( ) ; g2 . setColor ( shadowColor ) ; g2 . drawString ( s , x , y + 1 ) ; g2 . setColor ( c ) ; g2 . drawString ( s , x , y ) ; } } 
public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } 
private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } 
public static void drawShadowText ( Graphics2D g2 , String s , int x , int y ) { Color c = g2 . getColor ( ) ; g2 . setColor ( shadowColor ) ; g2 . drawString ( s , x , y + 1 ) ; g2 . setColor ( c ) ; g2 . drawString ( s , x , y ) ; } 
protected void paintComponent ( Graphics g ) { java . util . List < Node > nodes = getNetworkParts ( ) ; positions = new int [ nodes . size ( ) ] ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( SwingUtils . boldFont ) ; g2 . drawImage ( addressGradient , 0 , 0 , getWidth ( ) , 25 , null ) ; int x = 14 ; for ( int i = 0 ; i < nodes . size ( ) ; i + + ) { Node part = nodes . get ( i ) ; 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { int mx = e . getX ( ) ; armed = partIndex ( mx ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; java . util . List < Node > nodes = getNetworkParts ( ) ; Node selectedNode = nodes . get ( partIndex ) ; System.out.println("part = " + selectedNode); if (selectedNode != null) document.setActiveNetwork(selectedNode); repaint(); } public void mouseEntered(MouseEvent e) { } public void mouseExited(MouseEvent e) { armed = -1; repaint(); } private int partIndex(int x) { if (positions == null) return -1; for (int i = 0; i < positions.length; i++) { if (x < positions[i]) return i; } return -1; }} 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } } 
protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderDivider , 0 , 0 , null ) ; 
public void actionPerformed ( ActionEvent e ) { if ( node = = null ) return ; Parameter pCode = node . getParameter ( " _code " ) ; if ( pCode = = null ) return ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; } 
public abstract Pane clone ( ) ; public abstract String getPaneName ( ) ; public void currentNodeChanged ( Node activeNetwork ) { } public void focusedNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); } public void changePaneType(Class paneType) { if (!Pane.class.isAssignableFrom(paneType)) return; Pane newPane; try { newPane = (Pane) paneType.newInstance(); } catch (Exception e) { e.printStackTrace(); return; } newPane.setDocument(getDocument()); Container parent = getParent(); Dimension d = getSize(); parent.remove(this); parent.add(newPane); newPane.setSize(d); parent.validate(); }} 
public abstract String getPaneName ( ) ; public void currentNodeChanged ( Node activeNetwork ) { } public void focusedNodeChanged ( Node activeNode ) { } public void splitLeftRight ( ) { split ( JSplitPane . HORIZONTAL_SPLIT ) ; } private void split ( int orientation ) { Dimension d = getSize ( ) ; Container parent = getParent ( ) ; parent . remove ( this ) ; PaneSplitter split = new PaneSplitter ( orientation , this , this . clone ( ) ) ; split . setSize ( d ) ; parent . add ( split ) ; parent . validate ( ) ; } public void close ( ) { Container parent = getParent ( ) ; if ( ! ( parent instanceof PaneSplitter ) ) return ; PaneSplitter split = ( PaneSplitter ) parent ; Component left = split . getLeftComponent ( ) ; Component right = split . getRightComponent ( ) ; Component remainingComponent = left = = this ? right : left ; split . remove ( left ) ; split . remove ( right ) ; Container grandParent = parent . getParent ( ) ; if ( ! ( grandParent instanceof PaneSplitter ) ) return ; PaneSplitter grandSplit = ( PaneSplitter ) grandParent ; Component grandLeft = grandSplit . getLeftComponent ( ) ; Component grandRight = grandSplit . getRightComponent ( ) ; String constraint = split = = grandLeft ? JSplitPane . LEFT : JSplitPane . RIGHT ; Remove the split pane. grandSplit.remove(split); grandSplit.add(remainingComponent, constraint); } public void changePaneType(Class paneType) { if (!Pane.class.isAssignableFrom(paneType)) return; Pane newPane; try { newPane = (Pane) paneType.newInstance(); } catch (Exception e) { e.printStackTrace(); return; } newPane.setDocument(getDocument()); Container parent = getParent(); Dimension d = getSize(); parent.remove(this); parent.add(newPane); newPane.setSize(d); parent.validate(); }} 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { if ( e . getX ( ) < this . getWidth ( ) - 20 ) return ; paneOptionsMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; } } 
public void mousePressed ( MouseEvent e ) { if ( e . getX ( ) < this . getWidth ( ) - 20 ) return ; paneOptionsMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; } } 
public void mouseExited ( MouseEvent e ) { } @Override protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; } } 
protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Full width minus left side and right side int contentWidth = getWidth() - 9 - 21; g.drawImage(paneMenuLeft, 0, 0, null); g.drawImage(paneMenuBackground, 9, 0, contentWidth, 21, null); g.drawImage(paneMenuRight, 9 + contentWidth, 0, null); g2.setFont(SwingUtils.boldFont); g2.setColor(SwingUtils.normalColor); SwingUtils.drawShadowText(g2, pane.getPaneName(), 9, 14); } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } 
public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } 
public static void centerOnScreen ( Window w ) { Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; Dimension screenSize = toolkit . getScreenSize ( ) ; int x = ( screenSize . width - w . getWidth ( ) ) / 2 ; int y = ( screenSize . height - w . getHeight ( ) ) / 2 ; w . setLocation ( x , y ) ; } 
public static String stripExtension ( File f ) { return stripExtension ( f . getName ( ) ) ; } 
public static String stripExtension ( String fileName ) { int i = fileName . lastIndexOf ( '.' ) ; if ( i = = - 1 ) return fileName ; return fileName . substring ( 0 , i ) ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { Rectangle bounds = getBounds ( ) ; paneTypePopup . show ( this , bounds . x , bounds . y + bounds . height - 4 ) ; } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } private class PaneTypePopup extends JPopupMenu { public PaneTypePopup ( ) { add ( new ChangePaneTypeAction ( " Network " , NetworkPane . class ) ) ; add ( new ChangePaneTypeAction ( " Parameters " , ParameterPane . class ) ) ; add ( new ChangePaneTypeAction ( " Viewer " , ViewerPane . class ) ) ; add ( new ChangePaneTypeAction ( " Source " , EditorPane . class ) ) ; add ( new ChangePaneTypeAction ( " Console " , ConsolePane . class ) ) ; add ( new ChangePaneTypeAction ( " Log " , LoggingPane . class ) ) ; } } private class ChangePaneTypeAction extends AbstractAction { private Class paneType ; private ChangePaneTypeAction ( String name , Class paneType ) { super ( name ) ; this . paneType = paneType ; } public void actionPerformed ( ActionEvent e ) { pane . changePaneType ( paneType ) ; } } } 
public void mousePressed ( MouseEvent e ) { Rectangle bounds = getBounds ( ) ; paneTypePopup . show ( this , bounds . x , bounds . y + bounds . height - 4 ) ; } 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } private class PaneTypePopup extends JPopupMenu { public PaneTypePopup ( ) { add ( new ChangePaneTypeAction ( " Network " , NetworkPane . class ) ) ; add ( new ChangePaneTypeAction ( " Parameters " , ParameterPane . class ) ) ; add ( new ChangePaneTypeAction ( " Viewer " , ViewerPane . class ) ) ; add ( new ChangePaneTypeAction ( " Source " , EditorPane . class ) ) ; add ( new ChangePaneTypeAction ( " Console " , ConsolePane . class ) ) ; add ( new ChangePaneTypeAction ( " Log " , LoggingPane . class ) ) ; } } private class ChangePaneTypeAction extends AbstractAction { private Class paneType ; private ChangePaneTypeAction ( String name , Class paneType ) { super ( name ) ; this . paneType = paneType ; } public void actionPerformed ( ActionEvent e ) { pane . changePaneType ( paneType ) ; } } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } private class PaneTypePopup extends JPopupMenu { public PaneTypePopup ( ) { add ( new ChangePaneTypeAction ( " Network " , NetworkPane . class ) ) ; add ( new ChangePaneTypeAction ( " Parameters " , ParameterPane . class ) ) ; add ( new ChangePaneTypeAction ( " Viewer " , ViewerPane . class ) ) ; add ( new ChangePaneTypeAction ( " Source " , EditorPane . class ) ) ; add ( new ChangePaneTypeAction ( " Console " , ConsolePane . class ) ) ; add ( new ChangePaneTypeAction ( " Log " , LoggingPane . class ) ) ; } } private class ChangePaneTypeAction extends AbstractAction { private Class paneType ; private ChangePaneTypeAction ( String name , Class paneType ) { super ( name ) ; this . paneType = paneType ; } public void actionPerformed ( ActionEvent e ) { pane . changePaneType ( paneType ) ; } } } 
public void mouseExited ( MouseEvent e ) { } private class PaneTypePopup extends JPopupMenu { public PaneTypePopup ( ) { add ( new ChangePaneTypeAction ( " Network " , NetworkPane . class ) ) ; add ( new ChangePaneTypeAction ( " Parameters " , ParameterPane . class ) ) ; add ( new ChangePaneTypeAction ( " Viewer " , ViewerPane . class ) ) ; add ( new ChangePaneTypeAction ( " Source " , EditorPane . class ) ) ; add ( new ChangePaneTypeAction ( " Console " , ConsolePane . class ) ) ; add ( new ChangePaneTypeAction ( " Log " , LoggingPane . class ) ) ; } } private class ChangePaneTypeAction extends AbstractAction { private Class paneType ; private ChangePaneTypeAction ( String name , Class paneType ) { super ( name ) ; this . paneType = paneType ; } public void actionPerformed ( ActionEvent e ) { pane . changePaneType ( paneType ) ; } } } 
public void actionPerformed ( ActionEvent e ) { pane . changePaneType ( paneType ) ; } 
public void reload ( ) { if ( node = = null ) return ; Parameter pCode = node . getParameter ( " _code " ) ; if ( pCode = = null ) return ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; } 
private void init ( Mode mode , String text , Image normalImage , Image checkedImage ) { this . mode = mode ; this . text = text ; this . normalImage = normalImage ; this . checkedImage = checkedImage ; int width = measureWidth ( ) ; Dimension d = new Dimension ( width , BUTTON_HEIGHT ) ; setSize ( d ) ; setPreferredSize ( d ) ; setMinimumSize ( d ) ; setMaximumSize ( d ) ; addMouseListener ( this ) ; } 
private int measureWidth ( ) { To measure text we need a graphics context. Create an image and use its' graphics context. BufferedImage tmp = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB); Graphics2D g2 = tmp.createGraphics(); int width = normalImage.getWidth(null); width += IMAGE_TEXT_MARGIN; width += (int) g2.getFontMetrics().stringWidth(text); width += 1; Anti-aliasing can take up an extra pixel. return width; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( checked ) { g2 . drawImage ( checkedImage , 0 , 0 , null ) ; } else { g2 . drawImage ( normalImage , 0 , 0 , null ) ; } int w = normalImage . getWidth ( null ) ; g2 . setFont ( SwingUtils . boldFont ) ; if ( armed ) { g2 . setColor ( SwingUtils . armedColor ) ; } else { g2 . setColor ( SwingUtils . normalColor ) ; } SwingUtils . drawShadowText ( g2 , text , w + IMAGE_TEXT_MARGIN , TEXT_BASELINE ) ; } 
public void mouseClicked ( MouseEvent e ) { try { actionMethod . invoke ( actionObject ) ; 
public void mousePressed ( MouseEvent e ) { armed = true ; repaint ( ) ; } 
public void mouseReleased ( MouseEvent e ) { armed = false ; if ( mode = = Mode . CHECK ) checked = ! checked ; repaint ( ) ; } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = false ; repaint ( ) ; } } 
public void mouseExited ( MouseEvent e ) { armed = false ; repaint ( ) ; } 
public void toggleHandles ( ) { viewer . setShowHandle ( handlesCheck . isChecked ( ) ) ; } 
public void updateIcon ( ) { Image icon = getImageForNode ( node ) ; Create the icon. We include only the parts that are not changed by state. This means leaving off the error and rendered image. Also, we draw the rim at the very end, above the error and rendered, so we can't draw it here yet. fullIcon = new BufferedImage(NODE_FULL_SIZE, NODE_FULL_SIZE, BufferedImage.TYPE_INT_ARGB); Graphics2D fg = fullIcon.createGraphics(); Count the input ports and draw them. java.util.List<Port> inputs = node.getPorts(); if (inputs.size() > 0) { int portY = (NODE_FULL_SIZE - NODE_PORT_HEIGHT) / 2; fg.drawImage(nodeInPort, 0, portY, null); } Draw the other layers. fg.drawImage(nodeOutPort, 0, 0, null); fg.drawImage(nodeMask, 0, 0, null); fg.setComposite(AlphaComposite.SrcIn); fg.drawImage(icon, 10, 10, NODE_IMAGE_SIZE, NODE_IMAGE_SIZE, null); fg.setComposite(AlphaComposite.SrcOver); fg.drawImage(nodeReflection, 0, 0, null); fg.dispose(); } 
protected void paint ( PPaintContext ctx ) { Graphics2D g = ctx . getGraphics ( ) ; Shape clip = g . getClip ( ) ; g . clip ( getBounds ( ) ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; Draw the selection/connection border if (connectTarget == this || selected) g.drawImage(nodeGlow, 0, 0, null); g.drawImage(fullIcon, 0, 0, null); if (node.hasError()) g.drawImage(nodeError, 0, 0, null); if (node.isRendered()) g.drawImage(nodeRendered, 0, 0, null); g.drawImage(nodeRim, 0, 0, null); Draw the node name. g.setFont(SwingUtils.boldFont); g.setColor(new Color(22, 22, 22)); int textWidth = g.getFontMetrics().stringWidth(node.getName()); int x = (int) ((NODE_FULL_SIZE - textWidth) / 2f); SwingUtils.drawShadowText(g, node.getName(), x, NODE_FULL_SIZE + 5); Reset the clipping. g.setClip(clip); } 
public void actionPerformed ( ActionEvent e ) { node . setRendered ( ) ; networkView . repaint ( ) ; } 
public static void drawShadowText ( Graphics2D g2 , String s , int x , int y ) { Color c = g2 . getColor ( ) ; g2 . setColor ( brighter ( c , 0.25 ) ) ; g2 . drawString ( s , x , y + 1 ) ; g2 . setColor ( c ) ; g2 . drawString ( s , x , y ) ; } 
private static Color brighter ( Color c , double factor ) { int r = c . getRed ( ) ; int g = c . getGreen ( ) ; int b = c . getBlue ( ) ; int i = ( int ) ( 1.0 / ( 1.0 - factor ) ) ; if ( r = = 0 & & g = = 0 & & b = = 0 ) { return new Color ( i , i , i ) ; } if ( r > 0 & & r < i ) r = i ; if ( g > 0 & & g < i ) g = i ; if ( b > 0 & & b < i ) b = i ; return new Color ( Math . min ( ( int ) ( r / factor ) , 255 ) , Math . min ( ( int ) ( g / factor ) , 255 ) , 
protected void paintComponent ( Graphics g ) { java . util . List < Node > nodes = getNetworkParts ( ) ; positions = new int [ nodes . size ( ) ] ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( SwingUtils . FONT_BOLD ) ; g2 . drawImage ( addressGradient , 0 , 0 , getWidth ( ) , 25 , null ) ; int x = 14 ; for ( int i = 0 ; i < nodes . size ( ) ; i + + ) { Node part = nodes . get ( i ) ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( checked ) { g2 . drawImage ( checkedImage , 0 , 0 , null ) ; } else { g2 . drawImage ( normalImage , 0 , 0 , null ) ; } int w = normalImage . getWidth ( null ) ; g2 . setFont ( SwingUtils . FONT_BOLD ) ; if ( armed ) { g2 . setColor ( SwingUtils . COLOR_ARMED ) ; } else { g2 . setColor ( SwingUtils . COLOR_NORMAL ) ; } SwingUtils . drawShadowText ( g2 , text , w + IMAGE_TEXT_MARGIN , TEXT_BASELINE ) ; } 
protected void paint ( PPaintContext ctx ) { Graphics2D g = ctx . getGraphics ( ) ; Shape clip = g . getClip ( ) ; g . clip ( getBounds ( ) ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; Draw the selection/connection border if (connectTarget == this || selected) g.drawImage(nodeGlow, 0, 0, null); g.drawImage(fullIcon, 0, 0, null); if (node.hasError()) g.drawImage(nodeError, 0, 0, null); if (node.isRendered()) g.drawImage(nodeRendered, 0, 0, null); g.drawImage(nodeRim, 0, 0, null); Draw the node name. g.setFont(SwingUtils.FONT_BOLD); g.setColor(new Color(20, 20, 20)); int textWidth = g.getFontMetrics().stringWidth(node.getName()); int x = (int) ((NODE_FULL_SIZE - textWidth) / 2f); SwingUtils.drawShadowText(g, node.getName(), x, NODE_FULL_SIZE + 5, new Color(133, 133, 133)); Reset the clipping. g.setClip(clip); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Full width minus left side and right side int contentWidth = getWidth() - 9 - 21; g.drawImage(paneMenuLeft, 0, 0, null); g.drawImage(paneMenuBackground, 9, 0, contentWidth, 21, null); g.drawImage(paneMenuRight, 9 + contentWidth, 0, null); g2.setFont(SwingUtils.FONT_BOLD); g2.setColor(SwingUtils.COLOR_NORMAL); SwingUtils.drawShadowText(g2, pane.getPaneName(), 9, 14); } 
public static void drawShadowText ( Graphics2D g2 , String s , int x , int y ) { drawShadowText ( g2 , s , x , y , COLOR_SHADOW ) ; } 
public static void drawShadowText ( Graphics2D g2 , String s , int x , int y , Color shadowColor ) { Color c = g2 . getColor ( ) ; g2 . setColor ( shadowColor ) ; g2 . drawString ( s , x , y + 1 ) ; g2 . setColor ( c ) ; g2 . drawString ( s , x , y ) ; } 
private void doRename ( ) { String s = JOptionPane . showInputDialog ( networkView , " New name: " , node . getName ( ) ) ; if ( s = = null | | s . length ( ) = = 0 ) return ; try { node . setName ( s ) ; 
public void actionPerformed ( ActionEvent e ) { doRename ( ) ; } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { int labelWidth = 100 ; Draw border on the side of the label g.setColor(new Color(140, 140, 140)); g.fillRect(x, y + height - 2, labelWidth - 2, 1); g.setColor(new Color(166, 166, 166)); g.fillRect(x, y + height - 1, labelWidth - 2, 1); Draw border on parameter side g.setColor(new Color(179, 179, 179)); g.fillRect(x + labelWidth + 1, y + height - 2, width - labelWidth - 1, 1); g.setColor(new Color(213, 213, 213)); g.fillRect(x + labelWidth + 1, y + height - 1, width - labelWidth - 1, 1); g.setColor(borderColor); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( this , g ) ; int textX = getWidth ( ) - fm . stringWidth ( getText ( ) ) - 10 ; int textY = fm . getAscent ( ) ; g . setColor ( SwingUtils . COLOR_NORMAL ) ; g . setFont ( SwingUtils . FONT_BOLD ) ; SwingUtils . drawShadowText ( g2 , getText ( ) , textX , textY , new Color ( 176 , 176 , 176 ) ) ; } 
protected void paintComponent ( Graphics g ) { int height = getHeight ( ) ; int width = getWidth ( ) ; g . setColor ( new Color ( 153 , 153 , 153 ) ) ; g . fillRect ( 0 , 0 , labelWidth - 2 , height ) ; g . setColor ( new Color ( 146 , 146 , 146 ) ) ; g . fillRect ( labelWidth - 2 , 0 , 1 , height ) ; g . setColor ( new Color ( 133 , 133 , 133 ) ) ; g . fillRect ( labelWidth - 1 , 0 , 1 , height ) ; g . setColor ( new Color ( 112 , 112 , 112 ) ) ; g . fillRect ( labelWidth , 0 , 1 , height ) ; g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( labelWidth + 1 , 0 , width - labelWidth , height ) ; } 
public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); Rectangle r = getBounds(); int centerWidth = r.width - draggerLeftWidth - draggerRightWidth; g2.drawImage(draggerLeft, 0, 0, null); g2.drawImage(draggerRight, r.width - draggerRightWidth, 0, null); g2.drawImage(draggerBackground, draggerLeftWidth, 0, centerWidth, draggerHeight, null); g2.setFont(SwingUtils.FONT_BOLD); g2.setColor(SwingUtils.COLOR_NORMAL); SwingUtils.drawCenteredShadowText(g2, valueAsString(), r.width / 2, 14, highlightColor); } 
public void componentResized ( ComponentEvent e ) { numberField . setBounds ( draggerLeftWidth , 1 , getWidth ( ) - draggerLeftWidth - draggerRightWidth , draggerHeight - 2 ) ; } 
public void componentResized ( ComponentEvent e ) { Dimension controlSize = control . getPreferredSize ( ) ; Rectangle bounds = getBounds ( ) ; int h = bounds . height - TOP_PADDING - BOTTOM_PADDING ; label . setBounds ( 0 , TOP_PADDING , ParameterView . LABEL_WIDTH , h ) ; control . setBounds ( ParameterView . LABEL_WIDTH + 10 , TOP_PADDING , controlSize . width , h ) ; control . doLayout ( ) ; expressionField . setBounds ( ParameterView . LABEL_WIDTH + 10 , TOP_PADDING , 200 , h ) ; repaint ( ) ; } 
public void mousePressed ( MouseEvent e ) { if ( e . getX ( ) < this . getWidth ( ) - 20 ) return ; popupMenu . show ( this , this . getWidth ( ) - 20 , 20 ) ; } 
protected void paintComponent ( Graphics g ) { g . drawImage ( popupButtonImage , getWidth ( ) - 20 , 0 , null ) ; 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { int labelWidth = ParameterView . LABEL_WIDTH ; Draw border on the side of the label g.setColor(labelUp); g.fillRect(x, y + height - 2, labelWidth - 2, 1); g.setColor(labelDown); g.fillRect(x, y + height - 1, labelWidth - 2, 1); Draw border on parameter side g.setColor(parameterUp); g.fillRect(x + labelWidth + 1, y + height - 2, width - labelWidth - 1, 1); g.setColor(parameterDown); g.fillRect(x + labelWidth + 1, y + height - 1, width - labelWidth - 1, 1); } 
protected void paintComponent ( Graphics g ) { int height = getHeight ( ) ; int width = getWidth ( ) ; g . setColor ( new Color ( 153 , 153 , 153 ) ) ; g . fillRect ( 0 , 0 , LABEL_WIDTH - 3 , height ) ; g . setColor ( new Color ( 146 , 146 , 146 ) ) ; g . fillRect ( LABEL_WIDTH - 3 , 0 , 1 , height ) ; g . setColor ( new Color ( 133 , 133 , 133 ) ) ; g . fillRect ( LABEL_WIDTH - 2 , 0 , 1 , height ) ; g . setColor ( new Color ( 112 , 112 , 112 ) ) ; g . fillRect ( LABEL_WIDTH - 1 , 0 , 1 , height ) ; g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( LABEL_WIDTH , 0 , width - LABEL_WIDTH , height ) ; } 
public static void drawCenteredShadowText ( Graphics2D g2 , String s , int x , int y ) { drawCenteredShadowText ( g2 , s , x , y , COLOR_SHADOW ) ; } 
public static void drawCenteredShadowText ( Graphics2D g2 , String s , int x , int y , Color shadowColor ) { FontRenderContext frc = g2 . getFontRenderContext ( ) ; Rectangle2D bounds = g2 . getFont ( ) . getStringBounds ( s , frc ) ; int leftX = ( int ) ( x - ( float ) bounds . getWidth ( ) / 2 ) ; drawShadowText ( g2 , s , leftX , y , shadowColor ) ; } 
public void toggle ( ) { parameter . set ( checkBox . isChecked ( ) ? 1 : 0 ) ; 
public void currentNodeChanged ( Node node ) { } public void focusedNodeChanged ( Node node ) { if ( colorDialog ! = null ) { colorDialog . dispose ( ) ; } } private class ColorButton extends JButton { private ColorButton ( ) { addActionListener ( ColorControl . this ) ; } @Override protected void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; g . setColor ( parameter . asColor ( ) . getAwtColor ( ) ) ; g . fillRect ( r . x , r . y , r . width , r . height ) ; g . setColor ( Color . darkGray ) ; g . drawRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; } } } 
private void load ( ) { manager = new NodeLibraryManager ( ) ; manager . addSearchPath ( PlatformUtils . getApplicationNodeLibraryDirectory ( ) ) ; manager . addSearchPath ( PlatformUtils . getUserNodeTypeLibraryDirectory ( ) ) ; manager . lookForLibraries ( ) ; int tasks = manager . getLibraries ( ) . size ( ) + 1 ; startupDialog = new ProgressDialog ( null , " Starting NodeBox " , tasks ) ; startupDialog . setVisible ( true ) ; Initialize Jython startupDialog.setMessage("Loading Python"); Thread t = new Thread(new PythonLoader()); t.start(); } 
public static void main ( String [ ] args ) { File editorDirectory = PlatformUtils . getUserNodeTypeLibraryDirectory ( ) ; JFrame frame = new JFrame ( " Simple Editor " ) ; JPanel rootPanel = new JPanel ( new BorderLayout ( ) ) ; rootPanel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 ) ) ; DirectoryEditor e = new DirectoryEditor ( ) ; e . setEditorDirectory ( editorDirectory ) ; rootPanel . add ( e ) ; frame . setContentPane ( rootPanel ) ; frame . setLocationByPlatform ( true ) ; frame . setSize ( 1100 , 800 ) ; frame . setVisible ( true ) ; } 
public void addSearchPath ( File f ) { if ( ! f . isDirectory ( ) ) throw new IllegalArgumentException ( " The given file should be a directory. " ) ; searchPaths . add ( f ) ; } 
public void lookForLibraries ( ) { if ( lookedForLibraries ) return ; refreshLibraries ( ) ; } 
private void refreshLibraries ( ) { lookedForLibraries = true ; for ( File path : searchPaths ) { lookForLibraries ( path ) ; 
private void lookForLibraries ( File dir ) { for ( File f : dir . listFiles ( ) ) { if ( f . isDirectory ( ) ) { 
public final void traverse ( File f ) { if ( f . isDirectory ( ) ) { 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Fill the background with a neutral grey. g2.setColor(new Color(232, 232, 232)); Rectangle clip = g.getClipBounds(); g2.fillRect(clip.x, clip.y, clip.width, clip.height); if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); g2.translate(getWidth() / 2.0, getHeight() / 2.0); if (getNode() == null) return; Object outputValue = getNode().getOutputValue(); if (outputValue instanceof Grob) { ((Grob) outputValue).draw(g2); } else if (outputValue != null) { String s = outputValue.toString(); g2.drawString(s, 5, 20); } Draw handle if (handle != null && showHandle) { Create a canvas with a transparent background 
public void actionPerformed ( ActionEvent actionEvent ) { Clipboard clipboard = getToolkit ( ) . getSystemClipboard ( ) ; StringSelection ss = new StringSelection ( log ) ; clipboard . setContents ( ss , ExceptionDialog . this ) ; } 
public void lostOwnership ( Clipboard clipboard , Transferable transferable ) { Do nothing }} 
public boolean readFromFile ( File file ) { try { NodeLibrary library = getManager ( ) . load ( file ) ; setNodeLibrary ( library ) ; setDocumentFile ( file ) ; The parsed network is now stored in the reader documentChanged = false; return true; } catch (RuntimeException e) { logger.log(Level.SEVERE, "Error while parsing" + file, e); ExceptionDialog d = new ExceptionDialog(this, e); d.setVisible(true); } return false; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( this , g ) ; int textX = getWidth ( ) - fm . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = fm.getAscent() + 6; g.setColor(SwingUtils.COLOR_NORMAL); g.setFont(SwingUtils.FONT_BOLD); SwingUtils.drawShadowText(g2, getText(), textX, textY, new Color(176, 176, 176)); } 
protected void paintComponent ( Graphics g ) { if ( node = = null ) { Rectangle clip = g . getClipBounds ( ) ; 
protected void paintComponent ( Graphics g ) { Height aligns to 30px high control, such as float, string, color, etc. g.drawImage(popupButtonImage, getWidth() - 20, 4, null); 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setColor ( SwingUtils . COLOR_NORMAL ) ; g2 . setFont ( SwingUtils . FONT_BOLD ) ; int textX = ParameterView . LABEL_WIDTH - g2 . getFontMetrics ( ) . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = 19; SwingUtils.drawShadowText(g2, getText(), textX, textY, new Color(176, 176, 176)); } 
protected void paint ( PPaintContext ctx ) { Graphics2D g = ctx . getGraphics ( ) ; Shape clip = g . getClip ( ) ; g . clip ( getBounds ( ) ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; Draw the selection/connection border if (connectTarget == this || selected) g.drawImage(nodeGlow, 0, 0, null); g.drawImage(fullIcon, 0, 0, null); if (node.hasError()) g.drawImage(nodeError, 0, 0, null); if (node.isRendered()) g.drawImage(nodeRendered, 0, 0, null); g.drawImage(nodeRim, 0, 0, null); Draw the node name. g.setFont(SwingUtils.FONT_BOLD); g.setColor(new Color(194, 194, 194)); int textWidth = g.getFontMetrics().stringWidth(node.getName()); int x = (int) ((NODE_FULL_SIZE - textWidth) / 2f); SwingUtils.drawShadowText(g, node.getName(), x, NODE_FULL_SIZE + 5, new Color(23, 23, 23), -1); Reset the clipping. g.setClip(clip); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setColor ( SwingUtils . COLOR_NORMAL ) ; g2 . setFont ( SwingUtils . FONT_BOLD ) ; int textX = ParameterView . LABEL_WIDTH - g2 . getFontMetrics ( ) . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = 19; SwingUtils.drawShadowText(g2, getText(), textX, textY, new Color(176, 176, 176), 1); } 
public static void drawShadowText ( Graphics2D g2 , String s , int x , int y ) { drawShadowText ( g2 , s , x , y , COLOR_SHADOW , 1 ) ; } 
public static void drawShadowText ( Graphics2D g2 , String s , int x , int y , Color shadowColor , int offset ) { Color c = g2 . getColor ( ) ; g2 . setColor ( shadowColor ) ; g2 . drawString ( s , x , y + offset ) ; g2 . setColor ( c ) ; g2 . drawString ( s , x , y ) ; } 
public static void drawCenteredShadowText ( Graphics2D g2 , String s , int x , int y , Color shadowColor ) { FontRenderContext frc = g2 . getFontRenderContext ( ) ; Rectangle2D bounds = g2 . getFont ( ) . getStringBounds ( s , frc ) ; int leftX = ( int ) ( x - ( float ) bounds . getWidth ( ) / 2 ) ; drawShadowText ( g2 , s , leftX , y , shadowColor , 1 ) ; } 
public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) { NodeView nv = getNodeView ( child ) ; if ( nv = = null ) return ; if ( attribute = = NodeAttributeListener . Attribute . NAME | | attribute = = NodeAttributeListener . Attribute . IMAGE ) { nv . repaint ( ) ; 
public void toggleMessages ( ) { setMessages ( messagesCheck . isChecked ( ) ) ; } 
public void nodeUpdated ( Node node ) { updateMessages ( node ) ; } 
private void updateMessages ( Node node ) { See if any errors happened. if (node != null && node.hasError()) { StringBuffer sb = new StringBuffer(); 
public void componentResized ( ComponentEvent e ) { splitter . setDividerLocation ( splitter . getHeight ( ) ) ; } 
public void componentMoved ( ComponentEvent e ) { } public void componentShown ( ComponentEvent e ) { } public void componentHidden ( ComponentEvent e ) { } private class ReloadAction extends AbstractAction { private ReloadAction ( ) { super ( " Reload " ) ; ImageIcon icon = new ImageIcon ( " res/code-reload.png " , " Reload " ) ; putValue ( Action . SMALL_ICON , icon ) ; } public void actionPerformed ( ActionEvent e ) { if ( node = = null ) return ; Parameter pCode = node . getParameter ( " _code " ) ; if ( pCode = = null ) return ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; } } } 
public void componentShown ( ComponentEvent e ) { } public void componentHidden ( ComponentEvent e ) { } private class ReloadAction extends AbstractAction { private ReloadAction ( ) { super ( " Reload " ) ; ImageIcon icon = new ImageIcon ( " res/code-reload.png " , " Reload " ) ; putValue ( Action . SMALL_ICON , icon ) ; } public void actionPerformed ( ActionEvent e ) { if ( node = = null ) return ; Parameter pCode = node . getParameter ( " _code " ) ; if ( pCode = = null ) return ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; } } } 
public void componentHidden ( ComponentEvent e ) { } private class ReloadAction extends AbstractAction { private ReloadAction ( ) { super ( " Reload " ) ; ImageIcon icon = new ImageIcon ( " res/code-reload.png " , " Reload " ) ; putValue ( Action . SMALL_ICON , icon ) ; } public void actionPerformed ( ActionEvent e ) { if ( node = = null ) return ; Parameter pCode = node . getParameter ( " _code " ) ; if ( pCode = = null ) return ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; } } } 
public BasicSplitPaneDivider createDefaultDivider ( ) { return new EditorSpliterDivider ( this ) ; } 
public void run ( ) { try { activeNetwork . update ( ) ; 
public static void initializePython ( ) { Properties jythonProperties = new Properties ( ) ; String jythonCacheDir = PlatformUtils . getUserDataDirectory ( ) + PlatformUtils . SEP + " _jythoncache " ; jythonProperties . put ( " python.cachedir " , jythonCacheDir ) ; PySystemState . initialize ( System . getProperties ( ) , jythonProperties , new String [ ] { " " } ) ; String workingDirectory = System . getProperty ( " user.dir " ) ; Add the built-in python libraries File pythonLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "python.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Add the user libraries Py.getSystemState().path.add(new PyString(PlatformUtils.getUserDataDirectory())); } 
public void componentMoved ( ComponentEvent e ) { } public void componentShown ( ComponentEvent e ) { } public void componentHidden ( ComponentEvent e ) { } public void caretUpdate ( CaretEvent e ) { JEditorPane editArea = ( JEditorPane ) e . getSource ( ) ; int caretpos = editArea . getCaretPosition ( ) ; Element root = editArea . getDocument ( ) . getDefaultRootElement ( ) ; int linenum = root . getElementIndex ( caretpos ) + 1 ; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } private void updatePosition(int linenum, int columnnum) { splitter.setLocation(linenum, columnnum); } private class ReloadAction extends AbstractAction { private ReloadAction() { super("Reload"); ImageIcon icon = new ImageIcon("res/code-reload.png", "Reload"); putValue(Action.SMALL_ICON, icon); } public void actionPerformed(ActionEvent e) { if (node == null) return; Parameter pCode = node.getParameter("_code"); if (pCode == null) return; NodeCode code = new PythonCode(editor.getSource()); pCode.set(code); } }} 
public void componentShown ( ComponentEvent e ) { } public void componentHidden ( ComponentEvent e ) { } public void caretUpdate ( CaretEvent e ) { JEditorPane editArea = ( JEditorPane ) e . getSource ( ) ; int caretpos = editArea . getCaretPosition ( ) ; Element root = editArea . getDocument ( ) . getDefaultRootElement ( ) ; int linenum = root . getElementIndex ( caretpos ) + 1 ; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } private void updatePosition(int linenum, int columnnum) { splitter.setLocation(linenum, columnnum); } private class ReloadAction extends AbstractAction { private ReloadAction() { super("Reload"); ImageIcon icon = new ImageIcon("res/code-reload.png", "Reload"); putValue(Action.SMALL_ICON, icon); } public void actionPerformed(ActionEvent e) { if (node == null) return; Parameter pCode = node.getParameter("_code"); if (pCode == null) return; NodeCode code = new PythonCode(editor.getSource()); pCode.set(code); } }} 
public void componentHidden ( ComponentEvent e ) { } public void caretUpdate ( CaretEvent e ) { JEditorPane editArea = ( JEditorPane ) e . getSource ( ) ; int caretpos = editArea . getCaretPosition ( ) ; Element root = editArea . getDocument ( ) . getDefaultRootElement ( ) ; int linenum = root . getElementIndex ( caretpos ) + 1 ; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } private void updatePosition(int linenum, int columnnum) { splitter.setLocation(linenum, columnnum); } private class ReloadAction extends AbstractAction { private ReloadAction() { super("Reload"); ImageIcon icon = new ImageIcon("res/code-reload.png", "Reload"); putValue(Action.SMALL_ICON, icon); } public void actionPerformed(ActionEvent e) { if (node == null) return; Parameter pCode = node.getParameter("_code"); if (pCode == null) return; NodeCode code = new PythonCode(editor.getSource()); pCode.set(code); } }} 
public void caretUpdate ( CaretEvent e ) { JEditorPane editArea = ( JEditorPane ) e . getSource ( ) ; int caretpos = editArea . getCaretPosition ( ) ; Element root = editArea . getDocument ( ) . getDefaultRootElement ( ) ; int linenum = root . getElementIndex ( caretpos ) + 1 ; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } 
private void updatePosition ( int linenum , int columnnum ) { splitter . setLocation ( linenum , columnnum ) ; } 
public void addCaretListener ( CaretListener l ) { codeArea . addCaretListener ( l ) ; } 
public void removeCaretListener ( CaretListener l ) { codeArea . removeCaretListener ( l ) ; } 
private void updateTitle ( ) { String postfix = " " ; if ( ! PlatformUtils . onMac ( ) ) { todo: mac only code postfix = (documentChanged ? " *" : ""); } else { getRootPane().putClientProperty("Window.documentModified", documentChanged); } if (documentFile == null) { setTitle("Untitled" + postfix); 
private void startNodeTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( " name " ) ; String prototypeId = attributes . getValue ( " prototype " ) ; String typeAsString = attributes . getValue ( " type " ) ; if ( name = = null ) throw new SAXException ( " Name attribute is required in node tags. " ) ; if ( prototypeId = = null ) throw new SAXException ( " Prototype attribute is required in node tags. " ) ; Class dataClass = null ; if ( typeAsString ! = null ) { try { dataClass = Class . forName ( typeAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Given type " + typeAsString + " not found. " ) ; } } Node prototype = manager . getNode ( prototypeId ) ; if ( prototype = = null ) throw new SAXException ( " Unknown prototype " + prototypeId + " for node " + name ) ; Node newNode = prototype . newInstance ( library , name , dataClass ) ; Add the child to the node library or its parent if (currentNode == null) { library.add(newNode); } else { currentNode.add(newNode); } Parse additional node flags. if ("true".equals(attributes.getValue("rendered"))) newNode.setRendered(); Go down into the current node; this will now become the current network. currentNode = newNode; } 
public void testOnlyDefaults ( ) { String xml = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" type= \" vector \" ></node> " + NDBX_FOOTER ; NodeLibrary library = parseXml ( xml ) ; Node protoDot = manager . getNode ( " testlib.dot " ) ; assertTrue ( library . contains ( " dot1 " ) ) ; Node dot1 = library . get ( " dot1 " ) ; assertEquals ( protoDot , dot1 . getPrototype ( ) ) ; Since dot1 inherits from the prototype, it has all the parameters of the prototype. assertTrue(dot1.hasParameter("x")); assertTrue(dot1.hasParameter("y")); This is really an implementation detail. We should not make guarantees about the "same-ness" of parameters. assertNotSame(protoDot.getParameter("x"), dot1.getParameter("x")); assertEquals(0F, dot1.getValue("x")); assertEquals(0F, dot1.getValue("y")); } 
public void testPortTypes ( ) { NodeLibrary typeLib = new NodeLibrary ( " typeLib " ) ; Node . ROOT_NODE . newInstance ( typeLib , " alpha " , Polygon . class ) ; String xml = typeLib . toXml ( ) ; NodeLibrary library = parseXml ( xml ) ; Node alpha = library . get ( " alpha " ) ; assertEquals ( Polygon . class , alpha . getOutputPort ( ) . getDataClass ( ) ) ; Create a new instance with the same output type. Store it in a temporary node library. Node beta = alpha.newInstance(new NodeLibrary("xxx"), "beta"); StringBuffer sb = new StringBuffer(); beta.toXml(sb, ""); The output type is the same, so should not be persisted. assertFalse(sb.toString().contains("Polygon")); Check if ports have their types persisted. Node n = Node.ROOT_NODE.newInstance(typeLib, "gamma"); n.addPort("string", String.class); n.addPort("polygon", Polygon.class); xml = typeLib.toXml(); library = parseXml(xml); Node gamma = library.get("gamma"); assertEquals(String.class, gamma.getPort("string").getDataClass()); assertEquals(Polygon.class, gamma.getPort("polygon").getDataClass()); } 
public static void paintConnection ( Graphics2D g , Node outputNode , Node inputNode ) { float x1 = ( float ) ( inputNode . getX ( ) + 1 ) ; Compensate for selection border float y1 = (float) (inputNode.getY() + NodeView.NODE_FULL_SIZE / 2); paintConnection(g, outputNode, x1, y1); } 
public static void paintConnection ( Graphics2D g , Node outputNode , float x1 , float y1 ) { g . setStroke ( new BasicStroke ( 2 ) ) ; GeneralPath p = new GeneralPath ( ) ; Start position is at the middle right of the node. float x0 = (float) (outputNode.getX() + NodeView.NODE_FULL_SIZE - 1); Compensate for selection border float y0 = (float) (outputNode.getY() + NodeView.NODE_FULL_SIZE / 2); End position is at the middle left of the node. float dx = Math.abs(y1 - y0) / 2; p.moveTo(x0, y0); p.curveTo(x0 + dx, y0, x1 - dx, y1, x1, y1); g.draw(p); } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; PopupHandler popupHandler = new PopupHandler ( ) ; addInputEventListener ( popupHandler ) ; } 
public boolean isSelected ( NodeView nodeView ) { return nodeView ! = null & & selection . contains ( nodeView ) ; } 
public void startConnection ( NodeView connectionSource ) { this . connectionSource = connectionSource ; } 
public void endConnection ( ) { NodeView oldTarget = this . connectionTarget ; this . connectionSource = null ; connectionTarget = null ; connectionPoint = null ; if ( oldTarget ! = null ) oldTarget . repaint ( ) ; connectionLayer . repaint ( ) ; } 
public boolean isConnecting ( ) { return connectionSource ! = null ; } 
public void dragConnectionPoint ( Point2D pt ) { assert isConnecting ( ) ; this . connectionPoint = pt ; connectionLayer . repaint ( ) ; } 
protected void paint ( PPaintContext c ) { Graphics2D g = c . getGraphics ( ) ; g . setColor ( new Color ( 200 , 200 , 200 , 100 ) ) ; PBounds b = getBounds ( ) ; Inset the bounds so we don't draw outside the refresh region. b.inset(1, 1); g.fill(b); g.setColor(new Color(100, 100, 100, 100)); g.draw(b); } 
public void mouseReleased ( PInputEvent e ) { if ( selectionMarker = = null ) return ; getLayer ( ) . removeChild ( selectionMarker ) ; selectionMarker = null ; select ( temporarySelection ) ; temporarySelection . clear ( ) ; } 
protected void paint ( PPaintContext ctx ) { Graphics2D g = ctx . getGraphics ( ) ; Shape clip = g . getClip ( ) ; g . clip ( getBounds ( ) ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; Draw the selection/connection border if (selected && networkView.getConnectionTarget() != this) g.drawImage(nodeGlow, 0, 0, null); if (networkView.getConnectionTarget() == this) g.drawImage(nodeConnectionGlow, 0, 0, null); g.drawImage(fullIcon, 0, 0, null); if (node.hasError()) g.drawImage(nodeError, 0, 0, null); if (node.isRendered()) g.drawImage(nodeRendered, 0, 0, null); g.drawImage(nodeRim, 0, 0, null); Draw the node name. g.setFont(SwingUtils.FONT_BOLD); g.setColor(new Color(194, 194, 194)); int textWidth = g.getFontMetrics().stringWidth(node.getName()); int x = (int) ((NODE_FULL_SIZE - textWidth) / 2f); SwingUtils.drawShadowText(g, node.getName(), x, NODE_FULL_SIZE + 5, new Color(23, 23, 23), -1); Reset the clipping. g.setClip(clip); } 
public void mouseExited ( PInputEvent e ) { if ( networkView . isConnecting ( ) ) { System . out . println ( " NV end target " + node ) ; 
public void mouseDragged ( PInputEvent e ) { if ( isDragging ) { Point2D pt = e . getPosition ( ) ; double dx = pt . getX ( ) - dragPoint . getX ( ) ; double dy = pt . getY ( ) - dragPoint . getY ( ) ; getNetworkView ( ) . dragSelection ( dx , dy ) ; dragPoint = pt ; } else if ( networkView . isConnecting ( ) ) { Point2D p = e . getPosition ( ) ; networkView . dragConnectionPoint ( p ) ; } e . setHandled ( true ) ; } 
public void mouseReleased ( PInputEvent event ) { System . out . println ( " NV RELEASED " ) ; if ( networkView . isConnecting ( ) ) { 
private void startNodeTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( " name " ) ; String prototypeId = attributes . getValue ( " prototype " ) ; String typeAsString = attributes . getValue ( " type " ) ; if ( name = = null ) throw new SAXException ( " Name attribute is required in node tags. " ) ; if ( prototypeId = = null ) throw new SAXException ( " Prototype attribute is required in node tags. " ) ; Class dataClass = null ; if ( typeAsString ! = null ) { try { dataClass = Class . forName ( typeAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Given type " + typeAsString + " not found. " ) ; } } Node prototype = manager . getNode ( prototypeId ) ; if ( prototype = = null ) throw new SAXException ( " Unknown prototype " + prototypeId + " for node " + name ) ; Node newNode = prototype . newInstance ( library , name , dataClass ) ; Add the child to the node library or its parent if (currentNode == null) { library.add(newNode); } else { currentNode.add(newNode); } Parse additional node flags. String x = attributes.getValue("x"); String y = attributes.getValue("y"); if (x != null) newNode.setX(Double.parseDouble(x)); if (y != null) newNode.setY(Double.parseDouble(y)); if ("true".equals(attributes.getValue("rendered"))) newNode.setRendered(); Go down into the current node; this will now become the current network. currentNode = newNode; } 
public void testPosition ( ) { NodeLibrary l = new NodeLibrary ( " test " ) ; Node = Node . ROOT_NODE . newInstance ( l , " test " ) ; . setPosition ( 25 , 50 ) ; NodeLibrary lib = parseXml ( l . toXml ( ) ) ; Node test = lib . get ( " test " ) ; assertEquals ( 25.0 , test . getX ( ) ) ; assertEquals ( 50.0 , test . getY ( ) ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Fill the background with a neutral grey. g2.setColor(new Color(232, 232, 232)); Rectangle clip = g.getClipBounds(); g2.fillRect(clip.x, clip.y, clip.width, clip.height); if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); if (getNode() == null) return; Object outputValue = getNode().getOutputValue(); if (outputValue instanceof Grob) { g2.translate(getWidth() / 2.0, getHeight() / 2.0); ((Grob) outputValue).draw(g2); } else if (outputValue != null) { String s = outputValue.toString(); g2.setColor(SwingUtils.COLOR_NORMAL); g2.setFont(PlatformUtils.getEditorFont()); g2.drawString(s, 5, 20); } Draw handle if (handle != null && showHandle) { Create a canvas with a transparent background 
public void mouseExited ( PInputEvent e ) { if ( networkView . isConnecting ( ) ) { networkView . setTemporaryConnectionTarget ( null ) ; 
public void mouseReleased ( PInputEvent event ) { if ( networkView . isConnecting ( ) ) { Check if both source and target are set. 
public void testStoreInLibrary ( ) { NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary library = manager . load ( new File ( " test/polynodes.ndbx " ) ) ; assertTrue ( library . contains ( " rect " ) ) ; manager. 
public void doEnter ( ) { String lastLine = getLastLine ( ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; ByteArrayOutputStream errorStream = new ByteArrayOutputStream ( ) ; interpreter . setOut ( outputStream ) ; interpreter . setErr ( errorStream ) ; interpreter . set ( " document " , pane . getDocument ( ) ) ; interpreter . set ( " root " , pane . getDocument ( ) . getActiveNetwork ( ) . getRoot ( ) ) ; interpreter . set ( " parent " , pane . getDocument ( ) . getActiveNetwork ( ) ) ; interpreter . set ( " node " , pane . getDocument ( ) . getActiveNode ( ) ) ; for ( Parameter . Type : Parameter . Type . values ( ) ) interpreter . set ( . name ( ) , ) ; Exception pythonException = null ; try { interpreter . exec ( lastLine ) ; } catch ( Exception e ) { pythonException = e ; logger . log ( Level . INFO , " Error on exec " , e ) ; } addString ( " " ) ; String os = outputStream . toString ( ) ; if ( os . length ( ) > 0 ) { addString ( os ) ; if ( ! os . endsWith ( " " ) ) addString ( " " ) ; } if ( pythonException ! = null ) addString ( pythonException . toString ( ) + " " ) ; newPrompt ( ) ; } 
public void testOnlyDefaults ( ) { String xml = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" type= \" net.nodebox.node.polygraph.Polygon \" ></node> " + NDBX_FOOTER ; NodeLibrary library = parseXml ( xml ) ; Node protoDot = manager . getNode ( " testlib.dot " ) ; assertTrue ( library . contains ( " dot1 " ) ) ; Node dot1 = library . get ( " dot1 " ) ; assertEquals ( protoDot , dot1 . getPrototype ( ) ) ; Since dot1 inherits from the prototype, it has all the parameters of the prototype. assertTrue(dot1.hasParameter("x")); assertTrue(dot1.hasParameter("y")); This is really an implementation detail. We should not make guarantees about the "same-ness" of parameters. assertNotSame(protoDot.getParameter("x"), dot1.getParameter("x")); assertEquals(0F, dot1.getValue("x")); assertEquals(0F, dot1.getValue("y")); } 
public boolean readFromFile ( File file ) { try { NodeLibrary library = NodeLibrary . load ( file , getManager ( ) ) ; setNodeLibrary ( library ) ; setDocumentFile ( file ) ; The parsed network is now stored in the reader documentChanged = false; return true; } catch (RuntimeException e) { logger.log(Level.SEVERE, "Error while parsing" + file, e); ExceptionDialog d = new ExceptionDialog(this, e); d.setVisible(true); } return false; } 
private void startNodeTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( " name " ) ; String prototypeId = attributes . getValue ( " prototype " ) ; String typeAsString = attributes . getValue ( " type " ) ; if ( name = = null ) throw new SAXException ( " Name attribute is required in node tags. " ) ; if ( prototypeId = = null ) throw new SAXException ( " Prototype attribute is required in node tags. " ) ; Class dataClass = null ; if ( typeAsString ! = null ) { try { dataClass = Class . forName ( typeAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Given type " + typeAsString + " not found. " ) ; } } Switch between relative and long identifiers. Long identifiers (e.g. "polygraph.rect") contain both a library and name and should be looked up using the manager. Short identifiers (e.g. "beta") contain only a name and are in the same library as this node. They should be looked up using the library. Node prototype = null; if (prototypeId.contains(".")) { Long identifier prototype = manager.getNode(prototypeId); } else { Short identifier prototype = library.get(prototypeId); } if (prototype == null) throw new SAXException("Unknown prototype " + prototypeId + " for node " + name); Node newNode = prototype.newInstance(library, name, dataClass); Add the child to the node library or its parent if (currentNode == null) { library.add(newNode); } else { currentNode.add(newNode); } Parse additional node flags. String x = attributes.getValue("x"); String y = attributes.getValue("y"); if (x != null) newNode.setX(Double.parseDouble(x)); if (y != null) newNode.setY(Double.parseDouble(y)); if ("true".equals(attributes.getValue("rendered"))) newNode.setRendered(); Go down into the current node; this will now become the current network. currentNode = newNode; } 
public static NodeLibrary load ( String libraryName , String xml , NodeLibraryManager manager ) throws RuntimeException { try { NodeLibrary library = new NodeLibrary ( libraryName ) ; 
public static NodeLibrary load ( File f , NodeLibraryManager manager ) throws RuntimeException { try { The library name is the file name without the ".ndbx" extension. 
private static void load ( NodeLibrary library , InputStream is , NodeLibraryManager manager ) throws IOException , ParserConfigurationException , SAXException { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; SAXParser parser = spf . newSAXParser ( ) ; NDBXHandler handler = new NDBXHandler ( library , manager ) ; parser . parse ( is , handler ) ; } 
public void add ( NodeLibrary library ) { if ( contains ( library . getName ( ) ) ) throw new RuntimeException ( " The manager already has a node library called " + library . getName ( ) ) ; libraries . put ( library . getName ( ) , library ) ; } 
public NodeLibrary load ( String libraryName , String xml ) throws RuntimeException { NodeLibrary library = NodeLibrary . load ( libraryName , xml , this ) ; add ( library ) ; return library ; } 
public NodeLibrary load ( File f ) throws RuntimeException { NodeLibrary library = NodeLibrary . load ( f , this ) ; add ( library ) ; return library ; } 
public void testStoreInLibrary ( ) { NodeLibraryManager manager ; NodeLibrary library ; First try loading from within the manager manager = new NodeLibraryManager(); library = manager.load(new File("test/polynodes.ndbx")); assertTrue(manager.contains("polynodes")); assertTrue(library.contains("rect")); Now try loading using the NodeLibrary.load static method. manager = new NodeLibraryManager(); We pass in the manager to figure out the prototypes. library = NodeLibrary.load(new File("test/polynodes.ndbx"), manager); assertFalse(manager.contains("polynodes")); You can add the library yourself. manager.add(library); assertTrue(manager.contains("polynodes")); } 
public void testStoreConnections ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " , Polygon . class ) ; Node beta = Node . ROOT_NODE . newInstance ( library , " beta " , Polygon . class ) ; beta . addPort ( " polygon " , Polygon . class ) ; beta . getPort ( " polygon " ) . connect ( alpha ) ; assertTrue ( alpha . isConnectedTo ( beta ) ) ; assertTrue ( beta . isConnectedTo ( alpha ) ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , library . toXml ( ) , manager ) ; Node newAlpha = newLibrary . get ( " alpha " ) ; Node newBeta = newLibrary . get ( " beta " ) ; assertTrue ( newAlpha . isConnectedTo ( newBeta ) ) ; assertTrue ( newBeta . isConnectedTo ( newAlpha ) ) ; } 
public void actionPerformed ( ActionEvent e ) { showNodeSelectionDialog ( ) ; } 
private boolean contains ( Node node , String searchString ) { String description = node . getDescription ( ) = = null ? " " : node . getDescription ( ) ; return node . getName ( ) . contains ( searchString ) | | description . contains ( searchString ) ; } 
public void initParameterPanel ( ) { parameterPanel = new JPanel ( ) ; parameterPanel . setLayout ( new BoxLayout ( parameterPanel , BoxLayout . Y_AXIS ) ) ; parameterPanel . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; JPanel contentPanel = new JPanel ( new GridLayout ( 10 , 2 , 10 , 5 ) ) ; Name contentPanel.add(new JLabel("Name")); nameField = new JTextField(20); nameField.setEditable(false); contentPanel.add(nameField); Label contentPanel.add(new JLabel("Label")); labelField = new JTextField(20); labelField.addActionListener(this); contentPanel.add(labelField); Description contentPanel.add(new JLabel("Description")); descriptionField = new JTextField(20); descriptionField.addActionListener(this); contentPanel.add(descriptionField); Type contentPanel.add(new JLabel("Type")); typeBox = new JComboBox(Parameter.Type.values()); typeBox.addActionListener(this); contentPanel.add(typeBox); Widget contentPanel.add(new JLabel("Widget")); widgetBox = new JComboBox(Parameter.Widget.values()); widgetBox.addActionListener(this); contentPanel.add(widgetBox); Value contentPanel.add(new JLabel("Value")); valueField = new JTextField(20); valueField.addActionListener(this); contentPanel.add(valueField); Bounding Method contentPanel.add(new JLabel("Bounding")); boundingMethodBox = new JComboBox(new String[]{"none", "soft", "hard"}); boundingMethodBox.addActionListener(this); contentPanel.add(boundingMethodBox); contentPanel.add(new JLabel("Minimum")); minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); contentPanel.add(minimumValuePanel); contentPanel.add(new JLabel("Maximum")); maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); contentPanel.add(maximumValuePanel); contentPanel.add(new JLabel("Display Level")); displayLevelBox = new JComboBox(new String[]{"hud", "detail", "hidden"}); displayLevelBox.addActionListener(this); contentPanel.add(displayLevelBox); parameterPanel.add(contentPanel); Dimension fillDimension = new Dimension(0, Integer.MAX_VALUE); parameterPanel.add(new Box.Filler(fillDimension, fillDimension, fillDimension)); } 
public void clearForm ( ) { nameField . setText ( " " ) ; labelField . setText ( " " ) ; descriptionField . setText ( " " ) ; typeBox . setSelectedItem ( Parameter . Type . INT ) ; widgetBox . setSelectedItem ( Parameter . Widget . INT ) ; valueField . setText ( " " ) ; boundingMethodBox . setSelectedIndex ( 0 ) ; minimumValueCheck . setSelected ( false ) ; minimumValueField . setText ( " " ) ; maximumValueCheck . setSelected ( false ) ; maximumValueField . setText ( " " ) ; displayLevelBox . setSelectedIndex ( 0 ) ; } 
public void valueChanged ( ListSelectionEvent e ) { if ( selectedParameter = = parameterList . getSelectedValue ( ) ) return ; selectedParameter = ( Parameter ) parameterList . getSelectedValue ( ) ; if ( selectedParameter = = null ) { setFormEnabled ( false ) ; clearForm ( ) ; removeButton . setEnabled ( false ) ; } else { setFormEnabled ( true ) ; removeButton . setEnabled ( true ) ; nameField . setText ( selectedParameter . getName ( ) ) ; labelField . setText ( selectedParameter . getLabel ( ) ) ; descriptionField.setText(selectedParameter.getDescription()); typeBox.setSelectedItem(selectedParameter.getType()); widgetBox.setSelectedItem(selectedParameter.getWidget()); valueField.setText(selectedParameter.getValue().toString()); Parameter.BoundingMethod boundingMethod = selectedParameter.getBoundingMethod(); boundingMethodBox.setSelectedItem(boundingMethod.toString().toLowerCase()); Object minimumValue = selectedParameter.getMinimumValue(); String minimumValueString = minimumValue == null ? "" : minimumValue.toString(); minimumValueCheck.setSelected(minimumValue != null); minimumValueField.setText(minimumValueString); minimumValueField.setEnabled(minimumValue != null); Object maximumValue = selectedParameter.getMaximumValue(); String maximumValueString = maximumValue == null ? "" : maximumValue.toString(); maximumValueCheck.setSelected(maximumValue != null); maximumValueField.setText(maximumValueString); maximumValueField.setEnabled(maximumValue != null); displayLevelBox.setSelectedItem(selectedParameter.getDisplayLevel().toString().toLowerCase()); } parameterPanel.revalidate(); } 
public static void main ( String [ ] args ) { JFrame editorFrame = new JFrame ( ) ; Node node = new NodeBoxDocument . AllControlsType ( ) . createInstance ( ) ; editorFrame . getContentPane ( ) . add ( new NodeMetaEditor ( node ) ) ; editorFrame . setSize ( 800 , 800 ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; editorFrame . setVisible ( true ) ; } 
public void editMetadata ( ) { if ( node = = null ) return ; NodeMetaEditor editor = new NodeMetaEditor ( node ) ; JFrame editorFrame = new JFrame ( node . getName ( ) + " Metadata " ) ; editorFrame . getContentPane ( ) . add ( editor ) ; editorFrame . setSize ( 800 , 800 ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setVisible ( true ) ; } 
public void update ( ProcessingContext ctx ) throws ProcessingError { if ( ! dirty ) return ; Update all upstream nodes. if (parent != null && parent.childGraph != null) { for (Port port : ports.values()) { Connection conn = parent.childGraph.getInfo(port); if (conn == null) continue; Updating the connection sets the value of the corresponding input port. conn.update(ctx); } } Update all parameter expressions. for (Parameter param : parameters.values()) { try { param.update(ctx); } catch (Exception e) { throw new ProcessingError(this, "Error occurred while updating parameter " + param + ": " + e.getMessage(), e); } } All dependencies are up-to-date. Process the node. ProcessingError pe = null; try { process(ctx); } catch (ProcessingError e) { pe = e; } Even if an error occurred the node is still marked as clean, and events are fired. Only after these steps is the error thrown. It is important to mark the node as clean so that subsequent changes to the node mark it as dirty, triggering an event. This allows you to fix the node. dirty = false; fireNodeUpdated(); If exception occurs, throw it. if (pe != null) throw pe; 
public void testDirtyPropagation ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node addConstant1 = addConstantNode . newInstance ( testLibrary , " addConstant1 " ) ; Nodes start out dirty assertTrue(number1.isDirty()); assertTrue(addConstant1.isDirty()); Updating makes them clean number1.update(); addConstant1 will throw an error since it needs input. assertProcessingError(addConstant1, NullPointerException.class); assertFalse(number1.isDirty()); When a node throws an error it is still marked as clean. assertFalse(addConstant1.isDirty()); Connecting the add constant to another node makes it dirty. The output (upstream) node doesn't become dirty. addConstant1.getPort("value").connect(number1); assertFalse(number1.isDirty()); assertTrue(addConstant1.isDirty()); addConstant1.update(); assertFalse(number1.isDirty()); This shouldn't have changed. assertFalse(addConstant1.isDirty()); A change to the upstream node should make downstream nodes dirty. number1.setValue("value", 12); assertTrue(number1.isDirty()); assertTrue(addConstant1.isDirty()); Updating the downstream node should make all upstreams clean, because their output values are needed to calculate the downstream. addConstant1.update(); assertFalse(number1.isDirty()); assertFalse(addConstant1.isDirty()); Changes to the downstream node don't affect upstreams. addConstant1.setValue("constant", 1); assertFalse(number1.isDirty()); assertTrue(addConstant1.isDirty()); addConstant1.update(); assertFalse(addConstant1.isDirty()); Disconnecting makes the downstream dirty. addConstant1.getPort("value").disconnect(); assertFalse(number1.isDirty()); assertTrue(addConstant1.isDirty()); Connect addConstant1 to a new node. Node number2 = numberNode.newInstance(testLibrary, "number2"); addConstant1.getPort("value").connect(number2); Check if disconnected nodes still propagate. number1.update(); assertFalse(number1.isDirty()); assertTrue(addConstant1.isDirty()); addConstant1.update(); assertFalse(addConstant1.isDirty()); number1.setValue("value", 13); assertTrue(number1.isDirty()); assertFalse(addConstant1.isDirty()); } 
public void testError ( ) { Node bad = addDirectNode . newInstance ( testLibrary , " bad " ) ; TestDirtyListener listener = new TestDirtyListener ( ) ; bad . addDirtyListener ( listener ) ; bad . setValue ( " v1 " , 12 ) ; bad . setValue ( " v2 " , 3 ) ; Since the node starts out as dirty, setting values doesn't increase the counter. assertEquals(0, listener.dirtyCounter); This code inherits the default code, which doesn't throw an error. bad.update(); assertEquals(15, bad.getOutputValue()); Updating the code marks it as clean. assertFalse(bad.isDirty()); assertEquals(1, listener.updatedCounter); assertEquals(0, listener.dirtyCounter); This code causes a division by zero. bad.setValue("_code", new PythonCode("def cook(self): return 1 / 0")); assertEquals(1, listener.dirtyCounter); We just changed a parameter value, so the node is dirty. assertTrue(bad.isDirty()); Processing will fail. assertProcessingError(bad, "integer division or modulo by zero"); After processing failed, events are still called, and the node is marked clean. Output is set to null. assertFalse(bad.isDirty()); assertNull(bad.getOutputValue()); assertEquals(2, listener.updatedCounter); assertEquals(1, listener.dirtyCounter); } 
public boolean reload ( ) { if ( node = = null ) return false ; Parameter pCode = node . getParameter ( " _code " ) ; if ( pCode = = null ) return false ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; return true ; } 
public boolean reloadActiveNode ( ) { if ( activeNode = = null ) return false ; Pane p = SwingUtils . getPaneForComponent ( getFocusOwner ( ) ) ; if ( p = = null | | ! ( p instanceof EditorPane ) ) return false ; return ( ( EditorPane ) p ) . reload ( ) ; } 
public void testNullBounds ( ) { BezierPath p ; Check what happens without any initialization. p = new BezierPath(); assertEquals(new Rect(0, 0, 0, 0), p.getBounds()); Getting general path will construct an internal path, and markt the BezierPath as not dirty. p = new BezierPath(); p.getGeneralPath(); assertEquals(new Rect(0, 0, 0, 0), p.getBounds()); p = new BezierPath(); p.getGeneralPath(); Now clean Get bounds. This will fill in the internal bounds attribute. assertEquals(new Rect(0, 0, 0, 0), p.getBounds()); p.rect(0, 0, 100, 100); Make it dirty again Check if bounds were updated. assertEquals(Rect.centeredRect(0, 0, 100, 100), p.getBounds()); } 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.resetContext(); context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("g", context); interpreter.set("BezierPath", nodebox.graphics.BezierPath.class); interpreter.set("Canvas", nodebox.graphics.Canvas.class); interpreter.set("Color", nodebox.graphics.Color.class); interpreter.set("GraphicsContext", nodebox.graphics.GraphicsContext.class); interpreter.set("Grob", nodebox.graphics.Grob.class); interpreter.set("Group", nodebox.graphics.Group.class); interpreter.set("Image", nodebox.graphics.Image.class); interpreter.set("NodeBoxError", nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", nodebox.graphics.PathElement.class); interpreter.set("Point", nodebox.graphics.Point.class); interpreter.set("Rect", nodebox.graphics.Rect.class); interpreter.set("Text", nodebox.graphics.Text.class); interpreter.set("Transform", nodebox.graphics.Transform.class); interpreter.set("LEFT", Text.Align.LEFT); interpreter.set("RIGHT", Text.Align.RIGHT); interpreter.set("CENTER", Text.Align.CENTER); interpreter.set("JUSTIFY", Text.Align.JUSTIFY); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
private void addText ( nodebox . graphics . Canvas c , Node node , String parameterName , double y ) { c . add ( new Text ( parameterName + " : " + node . asString ( parameterName ) , 10 , 24 + y * 24 ) ) ; } 
public Object cook ( Node node , ProcessingContext context ) { nodebox . graphics . Canvas c = new nodebox . graphics . Canvas ( ) ; addText ( c , node , " angle " , 1 ) ; addText ( c , node , " color " , 2 ) ; addText ( c , node , " file " , 3 ) ; addText ( c , node , " float " , 4 ) ; addText ( c , node , " font " , 5 ) ; addText ( c , node , " gradient " , 6 ) ; addText ( c , node , " image " , 7 ) ; addText ( c , node , " int " , 8 ) ; addText ( c , node , " menu " , 9 ) ; addText ( c , node , " seed " , 10 ) ; addText ( c , node , " string " , 11 ) ; addText ( c , node , " text " , 12 ) ; addText ( c , node , " toggle " , 13 ) ; addText ( c , node , " noderef " , 14 ) ; node . setOutputValue ( c ) ; return true ; } 
public boolean exportToFile ( File file ) { todo: file export only works on grobs. if (activeNetwork == null || activeNetwork.getRenderedChild() == null) return false; Object outputValue = activeNetwork.getRenderedChild().getOutputValue(); nodebox.graphics.Canvas canvas; if (outputValue instanceof nodebox.graphics.Canvas) { canvas = (nodebox.graphics.Canvas) outputValue; } else if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; Rect bounds = g.getBounds(); canvas = new nodebox.graphics.Canvas(bounds.getWidth(), bounds.getHeight()); We need to translate the canvas to compensate for the x/y value of the grob. double dx = bounds.getWidth() / 2 + bounds.getX(); double dy = bounds.getHeight() / 2 + bounds.getY(); canvas.translate(-dx, -dy); canvas.add(g); } else { throw new RuntimeException("This type of output cannot be exported " + outputValue); } canvas.save(file); return true; } 
private nodebox . graphics . Point pointForEvent ( MouseEvent e ) { double cx = - getWidth ( ) / 2.0 + e . getX ( ) ; double cy = - getHeight ( ) / 2.0 + e . getY ( ) ; return new nodebox . graphics . Point ( cx , cy ) ; } 
public void testOnlyDefaults ( ) { String xml = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" type= \" nodebox.node.polygraph.Polygon \" ></node> " + NDBX_FOOTER ; NodeLibrary library = parseXml ( xml ) ; Node protoDot = manager . getNode ( " testlib.dot " ) ; assertTrue ( library . contains ( " dot1 " ) ) ; Node dot1 = library . get ( " dot1 " ) ; assertEquals ( protoDot , dot1 . getPrototype ( ) ) ; Since dot1 inherits from the prototype, it has all the parameters of the prototype. assertTrue(dot1.hasParameter("x")); assertTrue(dot1.hasParameter("y")); This is really an implementation detail. We should not make guarantees about the "same-ness" of parameters. assertNotSame(protoDot.getParameter("x"), dot1.getParameter("x")); assertEquals(0F, dot1.getValue("x")); assertEquals(0F, dot1.getValue("y")); } 
public void testBasicGenerator ( ) { Node rect1 = Node . ROOT_NODE . newInstance ( testLibrary , " rect1 " , Polygon . class ) ; rect1 . addParameter ( " x " , Parameter . Type . INT , 20 ) ; rect1 . addParameter ( " y " , Parameter . Type . INT , 30 ) ; rect1 . addParameter ( " width " , Parameter . Type . INT , 40 ) ; rect1 . addParameter ( " height " , Parameter . Type . INT , 50 ) ; PythonCode code = new PythonCode ( " from nodebox.node.polygraph import Polygon " + " def cook(self): " + " return Polygon.rect(self.x, self.y, self.width, self.height) " ) ; rect1 . setValue ( " _code " , code ) ; rect1 . update ( ) ; Polygon polygon = ( Polygon ) rect1 . getOutputValue ( ) ; assertEquals ( new Rectangle ( 20 , 30 , 40 , 50 ) , polygon . getBounds ( ) ) ; } 
private void load ( ) { manager = new NodeLibraryManager ( ) ; manager . addSearchPath ( PlatformUtils . getApplicationScriptsDirectory ( ) ) ; manager . addSearchPath ( PlatformUtils . getUserScriptsDirectory ( ) ) ; manager . lookForLibraries ( ) ; int tasks = manager . getLibraries ( ) . size ( ) + 1 ; startupDialog = new ProgressDialog ( null , " Starting NodeBox " , tasks ) ; startupDialog . setVisible ( true ) ; Initialize Jython startupDialog.setMessage("Loading Python"); Thread t = new Thread(new PythonLoader()); t.start(); } 
public static void initializePython ( ) { Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = PlatformUtils.getUserDataDirectory() + PlatformUtils.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. String workingDirectory = System.getProperty("user.dir"); File pythonLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "python.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(PlatformUtils.getUserPythonDirectory().getAbsolutePath())); } 
public static void main ( String [ ] args ) { File editorDirectory = PlatformUtils . getUserScriptsDirectory ( ) ; JFrame frame = new JFrame ( " Simple Editor " ) ; JPanel rootPanel = new JPanel ( new BorderLayout ( ) ) ; rootPanel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 ) ) ; DirectoryEditor e = new DirectoryEditor ( ) ; e . setEditorDirectory ( editorDirectory ) ; rootPanel . add ( e ) ; frame . setContentPane ( rootPanel ) ; frame . setLocationByPlatform ( true ) ; frame . setSize ( 1100 , 800 ) ; frame . setVisible ( true ) ; } 
private void resetState ( ) { state = ParseState . INVALID ; characterData = null ; currentMenuKey = null ; } 
private void startNdbxTag ( Attributes attributes ) throws SAXException { Make sure we use the correct format and file type. String formatVersion = attributes.getValue(NDBX_FORMAT_VERSION); if (formatVersion == null) throw new SAXException("NodeBox file does not have required attribute formatVersion."); if (!formatVersion.equals("0.9")) throw new SAXException("Unknown formatVersion " + formatVersion); 
private void startVarTag ( Attributes attributes ) throws SAXException { Variables that get stored in the NodeBox library. String name = attributes.getValue(VAR_NAME); String value = attributes.getValue(VAR_VALUE); if (name == null) throw new SAXException("Name attribute is required in var tags."); if (value == null) throw new SAXException("Value attribute is required in var tags."); library.setVariable(name, value); } 
private void startCodeTag ( Attributes attributes ) throws SAXException { String type = attributes . getValue ( CODE_TYPE ) ; if ( type = = null ) throw new SAXException ( " Type attribute is required in code tags. " ) ; try { currentCodeType = CodeType . valueOf ( type . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { throw new SAXException ( " Invalid type attribute in code tag: should be python or java, not " + type + " . " ) ; } state = ParseState . IN_CODE ; characterData = new StringBuffer ( ) ; } 
private void startNodeTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( NODE_NAME ) ; String prototypeId = attributes . getValue ( NODE_PROTOTYPE ) ; String typeAsString = attributes . getValue ( NODE_TYPE ) ; if ( name = = null ) throw new SAXException ( " Name attribute is required in node tags. " ) ; if ( prototypeId = = null ) throw new SAXException ( " Prototype attribute is required in node tags. " ) ; Class dataClass = null ; if ( typeAsString ! = null ) { try { dataClass = Class . forName ( typeAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Given type " + typeAsString + " not found. " ) ; } } Switch between relative and long identifiers. Long identifiers (e.g. "polygraph.rect") contain both a library and name and should be looked up using the manager. Short identifiers (e.g. "beta") contain only a name and are in the same library as this node. They should be looked up using the library. Node prototype; if (prototypeId.contains(".")) { Long identifier prototype = manager.getNode(prototypeId); } else { Short identifier prototype = library.get(prototypeId); } if (prototype == null) throw new SAXException("Unknown prototype " + prototypeId + " for node " + name); Node newNode = prototype.newInstance(library, name, dataClass); Add the child to the node library or its parent if (currentNode == null) { library.add(newNode); } else { currentNode.add(newNode); } Parse additional node flags. String x = attributes.getValue(NODE_X); String y = attributes.getValue(NODE_Y); if (x != null) newNode.setX(Double.parseDouble(x)); if (y != null) newNode.setY(Double.parseDouble(y)); if ("true".equals(attributes.getValue(NODE_RENDERED))) newNode.setRendered(); Go down into the current node; this will now become the current network. currentNode = newNode; } 
private void startParameterTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( PARAMETER_NAME ) ; String typeAsString = attributes . getValue ( PARAMETER_TYPE ) ; if ( currentNode = = null ) throw new SAXException ( " Parameter tag encountered without a current node. " ) ; if ( name = = null ) throw new SAXException ( " Name is required for parameter on node ' " + currentNode . getName ( ) + " '. " ) ; if ( typeAsString = = null ) { No type attribute was given, so the parameter should already exist. currentParameter = currentNode.getParameter(name); if (currentParameter == null) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' does not exist."); } else { Type was given, so this is a new parameter. TODO: If type is given and parameter exists, migrate type. if (currentNode.hasParameter(name)) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' already exists."); Parameter.Type type = Parameter.Type.valueOf(typeAsString.toUpperCase()); currentParameter = currentNode.addParameter(name, type); } Parse parameter attributes. String widget = attributes.getValue(PARAMETER_WIDGET); String label = attributes.getValue(PARAMETER_LABEL); String helpText = attributes.getValue(PARAMETER_HELP_TEXT); String displayLevel = attributes.getValue(PARAMETER_DISPLAY_LEVEL); String boundingMethod = attributes.getValue(PARAMETER_BOUNDING_METHOD); String minimumValue = attributes.getValue(PARAMETER_MINIMUM_VALUE); String maximumValue = attributes.getValue(PARAMETER_MAXIMUM_VALUE); if (widget != null) currentParameter.setWidget(Parameter.Widget.valueOf(widget.toUpperCase())); if (label != null) currentParameter.setLabel(label); if (helpText != null) currentParameter.setHelpText(helpText); if (displayLevel!= null) currentParameter.setDisplayLevel(Parameter.DisplayLevel.valueOf(displayLevel.toUpperCase())); if (boundingMethod != null) currentParameter.setBoundingMethod(Parameter.BoundingMethod.valueOf(boundingMethod.toUpperCase())); if (minimumValue != null) currentParameter.setMinimumValue(Float.parseFloat(minimumValue)); if (maximumValue != null) currentParameter.setMaximumValue(Float.parseFloat(maximumValue)); 
private void startValueTag ( Attributes attributes ) throws SAXException { if ( currentParameter = = null ) throw new SAXException ( " Value tag encountered without current parameter. " ) ; state = ParseState . IN_VALUE ; characterData = new StringBuffer ( ) ; The value tag should be empty except when the parameter type is code. Then the value tag has a type attribute that specifies the code type. if (currentParameter.getType() != Parameter.Type.CODE) return; String type = attributes.getValue(VALUE_TYPE); if (type == null) throw new SAXException("Type attribute is required in code type parameters."); try { currentCodeType = CodeType.valueOf(type.toUpperCase()); 
private void startMenuTag ( Attributes attributes ) throws SAXException { if ( currentParameter = = null ) throw new SAXException ( " Menu tag encountered without current parameter. " ) ; state = ParseState . IN_MENU ; String key = attributes . getValue ( MENU_KEY ) ; if ( key = = null ) throw new SAXException ( " Attribute key for menu tag cannot be null. " ) ; currentMenuKey = key ; characterData = new StringBuffer ( ) ; } 
private void startPortTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( PORT_NAME ) ; String typeAsString = attributes . getValue ( PORT_TYPE ) ; String cardinalityAsString = attributes . getValue ( PORT_CARDINALITY ) ; if ( name = = null ) throw new SAXException ( " Name is required for port on node ' " + currentNode . getName ( ) + " '. " ) ; if ( typeAsString = = null ) throw new SAXException ( " Type is required for port on node ' " + currentNode . getName ( ) + " '. " ) ; Class type ; try { type = Class . forName ( typeAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Class " + typeAsString + " for port " + name + " not found. " ) ; } Port . Cardinality cardinality = Port . Cardinality . SINGLE ; if ( cardinalityAsString ! = null ) { try { cardinality = Port . Cardinality . valueOf ( cardinalityAsString . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { throw new SAXException ( " Invalid cardinality attribute in port tag: should be single or multiple, not " + cardinalityAsString + " . " ) ; } } currentNode . addPort ( name , type , cardinality ) ; } 
private void startConnectionTag ( Attributes attributes ) throws SAXException { output node identifier, without package String outputAsString = attributes.getValue(CONNECTION_OUTPUT); input node identifier, without package String inputAsString = attributes.getValue(CONNECTION_INPUT); input port identifier String portAsString = attributes.getValue(CONNECTION_PORT); String currentNodeString = currentNode == null ? "<null>" : currentNode.getName(); if (outputAsString == null) throw new SAXException("Output is required for connection in node '" + currentNodeString + "'."); if (inputAsString == null) throw new SAXException("Input is required for connection in node '" + currentNodeString + "'."); if (portAsString == null) throw new SAXException("Port is required for connection in node '" + currentNodeString + "'."); Node output, input; if (currentNode == null) { output = library.get(outputAsString); input = library.get(inputAsString); } else { output = currentNode.getChild(outputAsString); input = currentNode.getChild(inputAsString); } if (output == null) throw new SAXException("Output node '" + outputAsString + "' does not exist."); if (input == null) throw new SAXException("Input node '" + inputAsString + "' does not exist."); Port port = input.getPort(portAsString); if (port == null) throw new SAXException("Port '" + portAsString + "' on node '" + inputAsString + "' does not exist."); port.connect(output); } 
public void characters ( char [ ] ch , int start , int length ) throws SAXException { switch ( state ) { case IN_CODE : if ( currentCodeType = = null ) throw new SAXException ( " Code encountered, but no current code type. " ) ; break ; case IN_DESCRIPTION : if ( currentNode = = null ) throw new SAXException ( " Description encountered, but no current node. " ) ; break ; case IN_VALUE : if ( currentParameter = = null ) throw new SAXException ( " Value encountered, but no current parameter. " ) ; break ; case IN_EXPRESSION : if ( currentParameter = = null ) throw new SAXException ( " Expression encountered, but no current parameter. " ) ; break ; case IN_MENU : if ( currentParameter = = null ) throw new SAXException ( " Menu encountered, but no current parameter. " ) ; break ; default : Bail out when we don't recognize this state. return; } We have a valid character state, so we can safely append to characterData. characterData.append(ch, start, length); } 
public void toXml ( StringBuffer xml , String spaces ) { We only write out the attributes that have changed with regards to the prototype. Parameter protoParam = getPrototype(); If the parameter and its prototype are completely equal, don't write anything. if (prototypeEquals(protoParam)) return; The parameters are not equal, so we can start writing the name. xml.append(spaces).append("<param name=\"").append(getName()).append("\""); Write parameter type if (protoParam == null || !getType().equals(protoParam.getType())) xml.append(" ").append(NDBXHandler.PARAMETER_TYPE).append("=\"").append(getType().toString().toLowerCase()).append("\""); Write parameter attributes attributeToXml(xml, "widget", NDBXHandler.PARAMETER_WIDGET, protoParam, WIDGET_MAPPING.get(type)); attributeToXml(xml, "label", NDBXHandler.PARAMETER_LABEL, protoParam, StringUtils.humanizeName(name)); attributeToXml(xml, "helpText", NDBXHandler.PARAMETER_HELP_TEXT, protoParam, null); attributeToXml(xml, "displayLevel", NDBXHandler.PARAMETER_DISPLAY_LEVEL, protoParam, null); attributeToXml(xml, "boundingMethod", NDBXHandler.PARAMETER_BOUNDING_METHOD, protoParam, BoundingMethod.NONE); attributeToXml(xml, "minimumValue", NDBXHandler.PARAMETER_MINIMUM_VALUE, protoParam, null); attributeToXml(xml, "maximumValue", NDBXHandler.PARAMETER_MAXIMUM_VALUE, protoParam, null); xml.append(">"); Write parameter value / expression if (hasExpression()) { xml.append(spaces).append(" <expression>").append(getExpression()).append("</expression>"); } else { if (type == Type.INT) { xml.append(spaces).append(" <value>").append(asInt()).append("</value>"); } else if (type == Type.FLOAT) { xml.append(spaces).append(" <value>").append(asFloat()).append("</value>"); } else if (type == Type.STRING) { xml.append(spaces).append(" <value>").append(asString()).append("</value>"); } else if (type == Type.COLOR) { xml.append(spaces).append(" <value>").append(asColor().toString()).append("</value>"); } else if (type == Type.CODE) { xml.append(spaces).append(" <value type=\"").append(asCode().getType()).append("\"><![CDATA[").append(asCode().getSource()).append("]]></value>"); } else { throw new AssertionError("Unknown value class " + type); } } Write menu items for (MenuItem item : menuItems) { xml.append(spaces).append(" <menu key=\"").append(item.getKey()).append("\">").append(item.getLabel()).append("</menu>"); } xml.append(spaces).append("</param>"); } 
private void attributeToXml ( StringBuffer xml , String attrName , String xmlName , Parameter protoParam , Object defaultValue ) { try { String methodName = " get " + attrName . substring ( 0 , 1 ) . toUpperCase ( ) + attrName . substring ( 1 ) ; 
public void testLoading ( ) { NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary library = manager . load ( new File ( " test/polynodes.ndbx " ) ) ; assertTrue ( library . contains ( " rect " ) ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node rect = manager . getNode ( " polynodes.rect " ) ; Parameter pX = rect . getParameter ( " x " ) ; assertEquals ( Parameter . Type . FLOAT , pX . getType ( ) ) ; Node rect1 = rect . newInstance ( testLibrary , " rect1 " ) ; rect1 . setValue ( " x " , 20 ) ; rect1 . setValue ( " y " , 30 ) ; rect1 . setValue ( " width " , 40 ) ; try { rect1 . setValue ( " height " , 50 ) ; fail ( " Height has an expression set. " ) ; } catch ( IllegalArgumentException e ) { rect1 . getParameter ( " height " ) . clearExpression ( ) ; rect1 . setValue ( " height " , 50 ) ; } rect1 . update ( ) ; Object value = rect1 . getOutputValue ( ) ; assertEquals ( Polygon . class , value . getClass ( ) ) ; Polygon polygon = ( Polygon ) value ; assertEquals ( new Rectangle ( 20 , 30 , 40 , 50 ) , polygon . getBounds ( ) ) ; } 
public void testStoreExpressions ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " ) ; alpha . addParameter ( " v " , Parameter . Type . INT ) ; alpha . setValue ( " v " , 10 ) ; alpha . getParameter ( " v " ) . setExpression ( " 44 - 2 " ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , library . toXml ( ) , manager ) ; Node newAlpha = newLibrary . get ( " alpha " ) ; assertEquals ( " 44 - 2 " , newAlpha . getParameter ( " v " ) . getExpression ( ) ) ; newAlpha . update ( ) ; assertEquals ( 42 , newAlpha . getValue ( " v " ) ) ; } 
public void testStoreParameterAttributes ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " , Polygon . class ) ; Parameter pAngle = alpha . addParameter ( " angle " , Parameter . Type . FLOAT , 42 ) ; pAngle . setWidget ( Parameter . Widget . ANGLE ) ; pAngle . setMinimumValue ( - 360 f ) ; pAngle . setMaximumValue ( 360 f ) ; pAngle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; Parameter pMenu = alpha . addParameter ( " menu " , Parameter . Type . STRING , " es " ) ; pMenu . setWidget ( Parameter . Widget . MENU ) ; pMenu . addMenuItem ( " en " , " English " ) ; pMenu . addMenuItem ( " es " , " Spanish " ) ; Parameter pHidden = alpha . addParameter ( " hidden " , Parameter . Type . STRING , " invisible " ) ; pHidden . setDisplayLevel ( Parameter . DisplayLevel . HIDDEN ) ; Parameter pLabel = alpha . addParameter ( " label " , Parameter . Type . STRING , " label + help text " ) ; pLabel . setLabel ( " My Label " ) ; pLabel . setHelpText ( " My Help Text " ) ; System . out . println ( library . toXml ( ) ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , library . toXml ( ) , manager ) ; Node newAlpha = newLibrary . get ( " alpha " ) ; Parameter newAngle = newAlpha . getParameter ( " angle " ) ; assertEquals ( Parameter . Widget . ANGLE , newAngle . getWidget ( ) ) ; assertEquals ( Parameter . BoundingMethod . HARD , newAngle . getBoundingMethod ( ) ) ; assertEquals ( - 360 f , newAngle . getMinimumValue ( ) ) ; assertEquals ( 360 f , newAngle . getMaximumValue ( ) ) ; Parameter newMenu = newAlpha . getParameter ( " menu " ) ; assertEquals ( Parameter . Widget . MENU , newMenu . getWidget ( ) ) ; Parameter . MenuItem item0 = newMenu . getMenuItems ( ) . get ( 0 ) ; Parameter . MenuItem item1 = newMenu . getMenuItems ( ) . get ( 1 ) ; assertEquals ( " en " , item0 . getKey ( ) ) ; assertEquals ( " English " , item0 . getLabel ( ) ) ; assertEquals ( " es " , item1 . getKey ( ) ) ; assertEquals ( " Spanish " , item1 . getLabel ( ) ) ; Parameter newHidden = newAlpha . getParameter ( " hidden " ) ; assertEquals ( Parameter . DisplayLevel . HIDDEN , newHidden . getDisplayLevel ( ) ) ; assertEquals ( " invisible " , newHidden . getValue ( ) ) ; Parameter newLabel = newAlpha . getParameter ( " label " ) ; assertEquals ( " My Label " , newLabel . getLabel ( ) ) ; assertEquals ( " My Help Text " , newLabel . getHelpText ( ) ) ; } 
public void addMenuItem ( String key , String label ) { menuItems . add ( new MenuItem ( key , label ) ) ; fireAttributeChanged ( ) ; } 
public void attributeChanged ( Parameter source ) { + + changeCounter ; } 
public void testParameterEvents ( ) { MyParameterAttributeListener l ; Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pMenu = alpha . addParameter ( " menu " , Parameter . Type . STRING ) ; l = new MyParameterAttributeListener ( ) ; alpha . addParameterAttributeListener ( l ) ; assertEquals ( 0 , l . changeCounter ) ; pMenu . setWidget ( Parameter . Widget . MENU ) ; assertEquals ( 1 , l . changeCounter ) ; pMenu . addMenuItem ( " en " , " English " ) ; pMenu . addMenuItem ( " es " , " Spanis " ) ; assertEquals ( 3 , l . changeCounter ) ; Parameter pFloat = alpha . addParameter ( " float " , Parameter . Type . FLOAT ) ; l = new MyParameterAttributeListener ( ) ; alpha . addParameterAttributeListener ( l ) ; assertEquals ( 0 , l . changeCounter ) ; pFloat . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; assertEquals ( 1 , l . changeCounter ) ; pFloat . setMinimumValue ( - 100 f ) ; pFloat . setMaximumValue ( 100 f ) ; assertEquals ( 3 , l . changeCounter ) ; } 
public void attributeChanged ( Parameter source ) { rebuildInterface ( ) ; } 
public void valueChanged ( Parameter source ) { if ( parameter ! = source ) return ; setValueForControl ( source . getValue ( ) ) ; } 
public void valueChanged ( Parameter source ) { if ( parameter ! = source ) return ; Object newValue = source . getValue ( ) ; if ( value ! = null & & value . equals ( newValue ) ) return ; setValueForControl ( newValue ) ; } 
public void setValue ( Object value ) throws IllegalArgumentException { if ( hasExpression ( ) ) { throw new IllegalArgumentException ( " The parameter has an expression set. " ) ; } validate throws IllegalArgumentException when the value fails validation. validate(value); if (this.value.equals(value)) return; As a special exception, integer values can be cast up to floating-point values, and double values can be cast down (losing precision). if (value instanceof Integer && type == Type.FLOAT) { this.value = (float) ((Integer) value); } else if (value instanceof Double && type == Type.FLOAT) { this.value = (float) ((Double) value).doubleValue(); } else { this.value = value; } markDirty(); } 
private Object convertToType ( Object value ) { if ( type ! = Type . FLOAT ) return value ; if ( value instanceof Float ) return value ; if ( value instanceof Integer ) return ( ( Integer ) value ) . floatValue ( ) ; if ( value instanceof Double ) return ( ( Double ) value ) . floatValue ( ) ; throw new IllegalArgumentException ( " Value " + value + " cannot be converted to float. " ) ; } 
public void valueChanged ( Parameter source ) { Integer counter = valueMap . get ( source ) ; if ( counter = = null ) counter = 0 ; + + counter ; valueMap . put ( source , counter ) ; } 
public void testLenientValues ( ) { Node = new ValueBuiltin ( ) . getInstance ( ) ; Set value of a float with an int. n.setValue("float", 12); assertEquals(12F, n.asFloat("float")); Set value of a float with a double. n.setValue("float", 0.5); Value is still set to previous value. assertEquals(0.5f, n.asFloat("float")); } 
public void testParameterValueEvents ( ) { TestParameterValueListener l ; Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; l = new TestParameterValueListener ( ) ; . addParameterValueListener ( l ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; Parameter pBeta = . addParameter ( " beta " , Parameter . Type . FLOAT ) ; Initialization has triggered the parameter value event. assertEquals(1, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); pAlpha.setValue(100); assertEquals(2, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); Change the value to the current value. This should not trigger the event. pAlpha.setValue(100); assertEquals(2, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); The node is already dirty, and parameters will not receive any new events. Update the node so it becomes clean again. Set an expression for beta. This triggers the event. n.update(); pAlpha.setValue(3); pBeta.setExpression("alpha + 1"); assertEquals(2, l.getCounter(pBeta)); Now change alpha. This will not trigger beta, since the node is not updated yet. assertEquals(3, l.getCounter(pAlpha)); assertEquals(2, l.getCounter(pBeta)); Update the node, which will trigger the value changed event. n.update(); assertEquals(3, l.getCounter(pAlpha)); assertEquals(3, l.getCounter(pBeta)); } 
public void testParameterMetaEvents ( ) { TestParameterAttributeListener l ; Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pMenu = alpha . addParameter ( " menu " , Parameter . Type . STRING ) ; l = new TestParameterAttributeListener ( ) ; alpha . addParameterAttributeListener ( l ) ; assertEquals ( 0 , l . changeCounter ) ; pMenu . setWidget ( Parameter . Widget . MENU ) ; assertEquals ( 1 , l . changeCounter ) ; pMenu . addMenuItem ( " en " , " English " ) ; pMenu . addMenuItem ( " es " , " Spanis " ) ; assertEquals ( 3 , l . changeCounter ) ; Parameter pFloat = alpha . addParameter ( " float " , Parameter . Type . FLOAT ) ; l = new TestParameterAttributeListener ( ) ; alpha . addParameterAttributeListener ( l ) ; assertEquals ( 0 , l . changeCounter ) ; pFloat . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; assertEquals ( 1 , l . changeCounter ) ; pFloat . setMinimumValue ( - 100 f ) ; pFloat . setMaximumValue ( 100 f ) ; assertEquals ( 3 , l . changeCounter ) ; } 
public void testInternalType ( ) { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pFloat = alpha . addParameter ( " float " , Parameter . Type . FLOAT ) ; We can set a double or integer value to a float parameter. pFloat.set(33); However, getValue() should always return a float. assertEquals(33f, pFloat.getValue()); Now try the same with expressions. Set an expression that returns an integer. pFloat.setExpression("12"); alpha.update(); Since this is a float parameter, getValue should always return a float. assertEquals(12f, pFloat.getValue()); } 
public void valueChanged ( Parameter source ) { if ( parameter ! = source ) return ; setExpressionStatus ( ) ; 
public void actionPerformed ( ActionEvent e ) { if ( parameter . hasExpression ( ) ) { parameter . clearExpression ( ) ; 
public void actionPerformed ( ActionEvent e ) { parameter . revertToDefault ( ) ; Reverting to default could cause an expression to be set/cleared. 
public void setValue ( Object value ) throws IllegalArgumentException { if ( hasExpression ( ) ) { throw new IllegalArgumentException ( " The parameter has an expression set. " ) ; } validate throws IllegalArgumentException when the value fails validation. validate(value); if (this.value != null && this.value.equals(value)) return; As a special exception, integer values can be cast up to floating-point values, and double values can be cast down (losing precision). if (value instanceof Integer && type == Type.FLOAT) { this.value = (float) ((Integer) value); } else if (value instanceof Double && type == Type.FLOAT) { this.value = (float) ((Double) value).doubleValue(); } else { this.value = value; } markDirty(); } 
public void clearExpression ( ) { this . expression = null ; removeDependencies ( ) ; markDirty ( ) ; } 
public void testParameterValueEvents ( ) { TestParameterValueListener l ; Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; l = new TestParameterValueListener ( ) ; . addParameterValueListener ( l ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; Parameter pBeta = . addParameter ( " beta " , Parameter . Type . FLOAT ) ; Initialization has triggered the parameter value event. assertEquals(1, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); Update the node so new events will get fired. n.update(); pAlpha.setValue(100); assertEquals(2, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); Change the value to the current value. This should not trigger the event. pAlpha.setValue(100); assertEquals(2, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); The node is already dirty, and parameters will not receive any new events. Update the node so it becomes clean again. Set an expression for beta. This triggers the event. n.update(); pAlpha.setValue(3); pBeta.setExpression("alpha + 1"); assertEquals(2, l.getCounter(pBeta)); Now change alpha. This will not trigger beta, since the node is not updated yet. assertEquals(3, l.getCounter(pAlpha)); assertEquals(2, l.getCounter(pBeta)); Update the node, which will trigger the value changed event. n.update(); assertEquals(3, l.getCounter(pAlpha)); assertEquals(3, l.getCounter(pBeta)); } 
public void testRevertToDefault ( ) { Create a prototype node with an int parameter with an expression. Node proto = Node.ROOT_NODE.newInstance(testLibrary, "proto"); Parameter pAlpha = proto.addParameter("alpha", Parameter.Type.INT); pAlpha.setExpression("40 + 2"); Parameter pBeta = proto.addParameter("beta", Parameter.Type.INT, 88); Create an instance of this prototype. Node test = proto.newInstance(testLibrary, "test"); Parameter tAlpha = test.getParameter("alpha"); Check if the instance inherits the expression. assertTrue(tAlpha.hasExpression()); assertEquals("40 + 2", tAlpha.getExpression()); Update the node so the expression gets evaluated. test.update(); Remove the expression. tAlpha.clearExpression(); assertEquals(42, tAlpha.getValue()); Revert to default. The expression should be restored. tAlpha.revertToDefault(); assertTrue(tAlpha.hasExpression()); assertEquals("40 + 2", tAlpha.getExpression()); Now test the other way around. If the prototype has no expression, but the instance does, remove the expression and set the value. Parameter tBeta = test.getParameter("beta"); assertFalse(tBeta.hasExpression()); tBeta.setExpression("3 - 2"); test.update(); assertEquals(1, tBeta.getValue()); Revert to default. The beta parameter should have a regular value instead of an expression. tBeta.revertToDefault(); assertFalse(tBeta.hasExpression()); assertEquals(88, tBeta.getValue()); } 
public Node newInstance ( NodeLibrary library , String name , Class dataClass ) { Node = rawInstance ( library , name , dataClass ) ; library . add ( ) ; return ; } 
public void testStoreParameterAttributes ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " , Polygon . class ) ; Parameter pAngle = alpha . addParameter ( " angle " , Parameter . Type . FLOAT , 42 ) ; pAngle . setWidget ( Parameter . Widget . ANGLE ) ; pAngle . setMinimumValue ( - 360 f ) ; pAngle . setMaximumValue ( 360 f ) ; pAngle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; Parameter pMenu = alpha . addParameter ( " menu " , Parameter . Type . STRING , " es " ) ; pMenu . setWidget ( Parameter . Widget . MENU ) ; pMenu . addMenuItem ( " en " , " English " ) ; pMenu . addMenuItem ( " es " , " Spanish " ) ; Parameter pHidden = alpha . addParameter ( " hidden " , Parameter . Type . STRING , " invisible " ) ; pHidden . setDisplayLevel ( Parameter . DisplayLevel . HIDDEN ) ; Parameter pLabel = alpha . addParameter ( " label " , Parameter . Type . STRING , " label + help text " ) ; pLabel . setLabel ( " My Label " ) ; pLabel . setHelpText ( " My Help Text " ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , library . toXml ( ) , manager ) ; Node newAlpha = newLibrary . get ( " alpha " ) ; Parameter newAngle = newAlpha . getParameter ( " angle " ) ; assertEquals ( Parameter . Widget . ANGLE , newAngle . getWidget ( ) ) ; assertEquals ( Parameter . BoundingMethod . HARD , newAngle . getBoundingMethod ( ) ) ; assertEquals ( - 360 f , newAngle . getMinimumValue ( ) ) ; assertEquals ( 360 f , newAngle . getMaximumValue ( ) ) ; Parameter newMenu = newAlpha . getParameter ( " menu " ) ; assertEquals ( Parameter . Widget . MENU , newMenu . getWidget ( ) ) ; Parameter . MenuItem item0 = newMenu . getMenuItems ( ) . get ( 0 ) ; Parameter . MenuItem item1 = newMenu . getMenuItems ( ) . get ( 1 ) ; assertEquals ( " en " , item0 . getKey ( ) ) ; assertEquals ( " English " , item0 . getLabel ( ) ) ; assertEquals ( " es " , item1 . getKey ( ) ) ; assertEquals ( " Spanish " , item1 . getLabel ( ) ) ; Parameter newHidden = newAlpha . getParameter ( " hidden " ) ; assertEquals ( Parameter . DisplayLevel . HIDDEN , newHidden . getDisplayLevel ( ) ) ; assertEquals ( " invisible " , newHidden . getValue ( ) ) ; Parameter newLabel = newAlpha . getParameter ( " label " ) ; assertEquals ( " My Label " , newLabel . getLabel ( ) ) ; assertEquals ( " My Help Text " , newLabel . getHelpText ( ) ) ; } 
private void portSelected ( Port p ) { editorPanel . removeAll ( ) ; PortAttributesEditor editor = new PortAttributesEditor ( p ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; } 
private void parameterSelected ( Parameter p ) { editorPanel . removeAll ( ) ; ParameterAttributesEditor editor = new ParameterAttributesEditor ( p ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; } 
public void valueChanged ( ListSelectionEvent e ) { if ( selectedParameter = = parameterList . getSelectedValue ( ) ) return ; selectedParameter = ( Parameter ) parameterList . getSelectedValue ( ) ; if ( selectedParameter = = null ) { removeButton . setEnabled ( false ) ; 
public boolean isSelected ( ) { return selected ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( selected ) { Rectangle clip = g2 . getClipBounds ( ) ; g2 . setColor ( new Color ( 60 , 60 , 60 ) ) ; g2 . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; } g2 . setFont ( SwingUtils . FONT_REGULAR ) ; if ( selected ) { g2 . setColor ( Color . WHITE ) ; } else { g2 . setColor ( Color . BLACK ) ; } g2 . drawString ( text , 15 , 18 ) ; } 
public void addPort ( final Port p ) { final SourceLabel label = new SourceLabel ( p . getName ( ) , p ) ; label . addMouseListener ( new MouseListener ( ) { public void mouseClicked ( MouseEvent e ) { setSelectedLabel ( label ) ; } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } ) ; labelMap . put ( p , label ) ; add ( label ) ; } 
public void mouseClicked ( MouseEvent e ) { setSelectedLabel ( label ) ; } 
public void addParameter ( final Parameter p ) { final SourceLabel label = new SourceLabel ( p . getName ( ) , p ) ; label . addMouseListener ( new MouseListener ( ) { public void mouseClicked ( MouseEvent e ) { setSelectedLabel ( label ) ; } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } ) ; labelMap . put ( p , label ) ; add ( label ) ; } 
public void addHeader ( String s ) { JLabel header = new JLabel ( s ) ; header . setEnabled ( false ) ; header . setForeground ( SwingUtils . COLOR_DISABLED ) ; header . setFont ( SwingUtils . FONT_BOLD ) ; header . setMinimumSize ( new Dimension ( 100 , 25 ) ) ; header . setMaximumSize ( new Dimension ( 500 , 25 ) ) ; header . setPreferredSize ( new Dimension ( 140 , 25 ) ) ; add ( header ) ; } 
public static void main ( String [ ] args ) { JFrame editorFrame = new JFrame ( ) ; Node node = new NodeBoxDocument . AllControlsType ( ) . createInstance ( ) ; node . addPort ( " shape " , Object . class ) ; editorFrame . getContentPane ( ) . add ( new NodeAttributesEditor ( node ) ) ; editorFrame . setSize ( 800 , 800 ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; editorFrame . setVisible ( true ) ; } 
public void initPanel ( ) { setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; JPanel contentPanel = new JPanel ( new GridLayout ( 10 , 2 , 10 , 5 ) ) ; Name contentPanel.add(new JLabel("Name")); nameField = new JFormattedTextField(20); nameField.setEditable(false); contentPanel.add(nameField); Label contentPanel.add(new JLabel("Label")); labelField = new JTextField(20); labelField.addActionListener(this); labelField.addFocusListener(this); contentPanel.add(labelField); Help Text contentPanel.add(new JLabel("Help Text")); helpTextField = new JTextField(20); helpTextField.addActionListener(this); helpTextField.addFocusListener(this); contentPanel.add(helpTextField); Type contentPanel.add(new JLabel("Type")); typeBox = new JComboBox(Parameter.Type.values()); typeBox.addActionListener(this); contentPanel.add(typeBox); Widget contentPanel.add(new JLabel("Widget")); widgetBox = new JComboBox(Parameter.Widget.values()); widgetBox.addActionListener(this); contentPanel.add(widgetBox); Value contentPanel.add(new JLabel("Value")); valueField = new JTextField(20); valueField.addActionListener(this); valueField.addFocusListener(this); contentPanel.add(valueField); Bounding Method contentPanel.add(new JLabel("Bounding")); boundingMethodBox = new JComboBox(new String[]{"none", "soft", "hard"}); boundingMethodBox.addActionListener(this); contentPanel.add(boundingMethodBox); contentPanel.add(new JLabel("Minimum")); minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); minimumValueField.addFocusListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); contentPanel.add(minimumValuePanel); contentPanel.add(new JLabel("Maximum")); maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); maximumValueField.addFocusListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); contentPanel.add(maximumValuePanel); contentPanel.add(new JLabel("Display Level")); displayLevelBox = new JComboBox(new String[]{"hud", "detail", "hidden"}); displayLevelBox.addActionListener(this); contentPanel.add(displayLevelBox); add(contentPanel); Dimension fillDimension = new Dimension(0, Integer.MAX_VALUE); add(new Box.Filler(fillDimension, fillDimension, fillDimension)); } 
public void updateValues ( ) { nameField . setText ( parameter . getName ( ) ) ; labelField . setText ( parameter . getLabel ( ) ) ; helpTextField . setText ( parameter . getHelpText ( ) ) ; typeBox . setSelectedItem ( parameter . getType ( ) ) ; widgetBox . setSelectedItem ( parameter . getWidget ( ) ) ; valueField . setText ( parameter . getValue ( ) . toString ( ) ) ; Parameter . BoundingMethod boundingMethod = parameter . getBoundingMethod ( ) ; boundingMethodBox . setSelectedItem ( boundingMethod . toString ( ) . toLowerCase ( ) ) ; Object minimumValue = parameter . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = parameter . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; displayLevelBox . setSelectedItem ( parameter . getDisplayLevel ( ) . toString ( ) . toLowerCase ( ) ) ; revalidate ( ) ; } 
private void showError ( String msg ) { The message dialog popup will cause a focus lost event to be thrown, which will cause another action event, throwing up a second dialog popup. We temporarily disable focus lost events. focusLostEvents = false; JOptionPane.showMessageDialog(this, msg, "NodeBox", JOptionPane.ERROR_MESSAGE); focusLostEvents = true; } 
public void focusGained ( FocusEvent e ) { Do nothing. } public void focusLost(FocusEvent e) { if (!focusLostEvents) return; actionPerformed(new ActionEvent(e.getSource(), 0, "focusLost")); }} 
public void focusLost ( FocusEvent e ) { if ( ! focusLostEvents ) return ; actionPerformed ( new ActionEvent ( e . getSource ( ) , 0 , " focusLost " ) ) ; } 
public void editMetadata ( ) { if ( node = = null ) return ; NodeAttributesEditor editor = new NodeAttributesEditor ( node ) ; JFrame editorFrame = new JFrame ( node . getName ( ) + " Metadata " ) ; editorFrame . getContentPane ( ) . add ( editor ) ; editorFrame . setSize ( 800 , 800 ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setVisible ( true ) ; } 
public void addNotify ( ) { super . addNotify ( ) ; parameter . getNode ( ) . addParameterValueListener ( this ) ; } 
public void removeNotify ( ) { super . removeNotify ( ) ; parameter . getNode ( ) . removeParameterValueListener ( this ) ; } 
public void valueChanged ( Parameter source ) { if ( parameter ! = source ) return ; setExpressionStatus ( ) ; } 
public void initPanel ( ) { setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; JPanel contentPanel = new JPanel ( new GridLayout ( 3 , 2 , 10 , 5 ) ) ; Name contentPanel.add(new JLabel("Name")); nameField = new JTextField(20); nameField.setEnabled(false); contentPanel.add(nameField); Data Class contentPanel.add(new JLabel("Data Class")); dataClassField = new JTextField(20); dataClassField.addActionListener(this); dataClassField.addFocusListener(this); dataClassField.setEnabled(false); contentPanel.add(dataClassField); Cardinality contentPanel.add(new JLabel("Cardinality")); cardinalityBox = new JComboBox(Port.Cardinality.values()); cardinalityBox.setEnabled(false); contentPanel.add(cardinalityBox); add(contentPanel); Dimension fillDimension = new Dimension(0, Integer.MAX_VALUE); add(new Box.Filler(fillDimension, fillDimension, fillDimension)); } 
public void updateValues ( ) { nameField . setText ( port . getName ( ) ) ; dataClassField . setText ( port . getDataClass ( ) . getName ( ) ) ; cardinalityBox . setSelectedItem ( port . getCardinality ( ) ) ; revalidate ( ) ; } 
public void focusGained ( FocusEvent e ) { Do nothing. } public void focusLost(FocusEvent e) { actionPerformed(new ActionEvent(e.getSource(), 0, "focusLost")); } } 
public void focusLost ( FocusEvent e ) { actionPerformed ( new ActionEvent ( e . getSource ( ) , 0 , " focusLost " ) ) ; } 
public Parameter getParameter ( ) ; public void setValueForControl ( Object v ) ; } 
public void testTypeMigration ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter alpha will be converted from float to string. Parameter pAlpha = n.addParameter("alpha", Parameter.Type.FLOAT); pAlpha.setValue(12.5f); Change the type to string. pAlpha.setType(Parameter.Type.STRING); assertEquals("12.5", pAlpha.getValue()); String types can't use a float widget, so the widget should revert to the default widget for that type. assertEquals(Parameter.Widget.STRING, pAlpha.getWidget()); Parameter beta will be converted from color to int. Parameter pBeta = n.addParameter("beta", Parameter.Type.COLOR); assertEquals(Parameter.Widget.COLOR, pBeta.getWidget()); pBeta.setValue(new Color(0.1, 0.2, 0.3, 0.4)); Change the type to int. pBeta.setType(Parameter.Type.INT); The value can't be migrated sensibly, so the default value for int is used. assertEquals(Parameter.getDefaultValue(Parameter.Type.INT), pBeta.getValue()); The widget also defaults to the correct widget. assertEquals(Parameter.Widget.INT, pBeta.getWidget()); Parameter gamma will be converted from string to code. Parameter pGamma = n.addParameter("gamma", Parameter.Type.STRING); assertEquals(Parameter.Widget.STRING, pGamma.getWidget()); Set the value to something. This value will not be parsed as code. String source = "print 'hello'"; pGamma.setValue(source); Change the type to code. pGamma.setType(Parameter.Type.CODE); The code will not be migrated. assertEquals(Parameter.emptyCode, pGamma.getValue()); NodeCode code = (NodeCode) pGamma.getValue(); assertEquals("", code.getSource()); assertNull(code.cook(n, new ProcessingContext())); } 
public void nodeUpdated ( Node node , ProcessingContext context ) { updateMessages ( node , context ) ; } 
public void nodeUpdated ( Node node , ProcessingContext context ) { StringBuffer sb = new StringBuffer ( ) ; if ( node . hasError ( ) ) { sb . append ( node . getError ( ) . toString ( ) ) ; } loggingArea . setText ( sb . toString ( ) ) ; } 
public void nodeUpdated ( Node node , ProcessingContext context ) { if ( ! networkError & & ! node . hasError ( ) ) return ; networkError = node . hasError ( ) ; repaint ( ) ; } 
public void actionPerformed ( ActionEvent e ) { addEvent ( ) ; } 
public void actionPerformed ( ActionEvent e ) { removeEvent ( ) ; } 
private void portSelected ( Port p ) { editorPanel . removeAll ( ) ; PortAttributesEditor editor = new PortAttributesEditor ( p ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; selectedPort = p ; selectedParameter = null ; } 
private void parameterSelected ( Parameter p ) { editorPanel . removeAll ( ) ; ParameterAttributesEditor editor = new ParameterAttributesEditor ( p ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; selectedParameter = p ; selectedPort = null ; } 
private void addEvent ( ) { JMenuItem item ; JPopupMenu menu = new JPopupMenu ( ) ; item = menu . add ( " Parameter " ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { addParameter ( ) ; } } ) ; item = menu . add ( " Port " ) ; item . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { addPort ( ) ; } } ) ; menu . show ( addButton , 0 , addButton . getHeight ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { addPort ( ) ; } 
private void addPort ( ) { JOptionPane . showMessageDialog ( this , " Sorry, adding ports is not implemented yet. " ) ; } 
private void removeEvent ( ) { if ( selectedParameter ! = null ) { removeSelectedParameter ( ) ; 
private void removeSelectedPort ( ) { node . removePort ( selectedPort . getName ( ) ) ; reloadParameterList ( ) ; } 
public void nodeDirty ( Node node ) { if ( node ! = activeNetwork ) return ; markChanged ( ) ; updateActiveNetwork ( ) ; } 
private void updateActiveNetwork ( ) { try { activeNetwork . update ( ) ; 
private void doRender ( ) { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void nodeUpdated ( Node node , ProcessingContext context ) { Just here to statisfy DirtyListener interface. } Document Action classes public class NewAction extends AbstractAction { public NewAction() { putValue(NAME, "New"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_N)); } public void actionPerformed(ActionEvent e) { Application.getInstance().createNewDocument(); } } public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } } public class OpenRecentAction extends AbstractAction { private File file; public OpenRecentAction(File file) { this.file = file; putValue(NAME, file.getName()); } public void actionPerformed(ActionEvent e) { open(file); } } public class CloseAction extends AbstractAction { public CloseAction() { putValue(NAME, "Close"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_W)); } public void actionPerformed(ActionEvent e) { close(); } } public class SaveAction extends AbstractAction { public SaveAction() { putValue(NAME, "Save"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S)); } public void actionPerformed(ActionEvent e) { save(); } } public class SaveAsAction extends AbstractAction { public SaveAsAction() { putValue(NAME, "Save As..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_S, Event.SHIFT_MASK)); } public void actionPerformed(ActionEvent e) { saveAs(); } } public class RevertAction extends AbstractAction { public RevertAction() { putValue(NAME, "Revert to Saved"); } public void actionPerformed(ActionEvent e) { } } public class ExportAction extends AbstractAction { public ExportAction() { putValue(NAME, "Export..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_E)); } public void actionPerformed(ActionEvent e) { export(); } } public class QuitAction extends AbstractAction { public QuitAction() { putValue(NAME, "Quit"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Q)); } public void actionPerformed(ActionEvent e) { Application.getInstance().quit(); } } public class UndoAction extends AbstractAction { public UndoAction() { putValue(NAME, "Undo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.undo(); } catch (CannotUndoException ex) { logger.log(Level.WARNING, "Unable to undo.", ex); } update(); redoAction.update(); } public void update() { if (undo.canUndo()) { setEnabled(true); putValue(Action.NAME, undo.getUndoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Undo"); } } } public class RedoAction extends AbstractAction { public RedoAction() { putValue(NAME, "Redo"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK)); setEnabled(false); } public void actionPerformed(ActionEvent e) { try { undo.redo(); } catch (CannotRedoException ex) { logger.log(Level.WARNING, "Unable to redo.", ex); } update(); undoAction.update(); } public void update() { if (undo.canRedo()) { setEnabled(true); putValue(Action.NAME, undo.getRedoPresentationName()); } else { setEnabled(false); putValue(Action.NAME, "Redo"); } } } public class CutAction extends AbstractAction { public CutAction() { putValue(NAME, "Cut"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_X)); } public void actionPerformed(ActionEvent e) { } } public class CopyAction extends AbstractAction { public CopyAction() { putValue(NAME, "Copy"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_C)); } public void actionPerformed(ActionEvent e) { } } public class PasteAction extends AbstractAction { public PasteAction() { putValue(NAME, "Paste"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_V)); } public void actionPerformed(ActionEvent e) { } } public class DeleteAction extends AbstractAction { public DeleteAction() { putValue(NAME, "Delete"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0)); } public void actionPerformed(ActionEvent e) { TODO: Find network view, delete selected. } } public class ReloadAction extends AbstractAction { public ReloadAction() { putValue(NAME, "Reload"); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_R)); } public void actionPerformed(ActionEvent e) { reloadActiveNode(); } } public class NewLibraryAction extends AbstractAction { public NewLibraryAction() { putValue(NAME, "New Library..."); } public void actionPerformed(ActionEvent e) { String libraryName = JOptionPane.showInputDialog(NodeBoxDocument.this, "Enter the name for the new library", "Create New Library", JOptionPane.QUESTION_MESSAGE); if (libraryName == null || libraryName.trim().length() == 0) return; createNewLibrary(libraryName); } } public class MinimizeAction extends AbstractAction { public MinimizeAction() { putValue(NAME, "Minimize"); putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, KeyEvent.META_MASK)); } public void actionPerformed(ActionEvent e) { setState(Frame.ICONIFIED); } } public class ZoomAction extends AbstractAction { public ZoomAction() { putValue(NAME, "Zoom"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class BringAllToFrontAction extends AbstractAction { public BringAllToFrontAction() { putValue(NAME, "Bring All to Front"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } } public class NodeboxSiteAction extends AbstractAction { public NodeboxSiteAction() { putValue(NAME, "NodeBox Site"); } public void actionPerformed(ActionEvent e) { TODO: Implement Toolkit.getDefaultToolkit().beep(); } }} 
public void nodeDirty ( Node node ) ; public void nodeUpdated ( Node node , ProcessingContext context ) ; } 
public void fireNodeUpdated ( ProcessingContext context ) { See comment in #fireNodeDirty. Object[] listeners = listenerList.getListenerList(); for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == DirtyListener.class) { 
public void update ( ProcessingContext ctx ) throws ProcessingError { if ( ! dirty ) return ; Update all upstream nodes. if (parent != null && parent.childGraph != null) { for (Port port : ports.values()) { Connection conn = parent.childGraph.getInfo(port); if (conn == null) continue; Updating the connection sets the value of the corresponding input port. conn.update(ctx); } } Update all parameter expressions. for (Parameter param : parameters.values()) { try { param.update(ctx); } catch (Exception e) { throw new ProcessingError(this, "Error occurred while updating parameter " + param + ": " + e.getMessage(), e); } } All dependencies are up-to-date. Process the node. ProcessingError pe = null; try { process(ctx); } catch (ProcessingError e) { pe = e; } Even if an error occurred the node is still marked as clean, and events are fired. Only after these steps is the error thrown. It is important to mark the node as clean so that subsequent changes to the node mark it as dirty, triggering an event. This allows you to fix the node. dirty = false; fireNodeUpdated(ctx); If exception occurs, throw it. if (pe != null) throw pe; 
public Object cook ( Node node , ProcessingContext context ) throws RuntimeException { if ( cookFunction = = null ) preCook ( ) ; Add globals into the function namespace. namespace.put("FRAME", context.getFrame()); PyObject self; if (node == null) { self = Py.None; } else { self = new SelfWrapper(node); } Reassign the output and error streams. PrintStream oldOutStream = System.out; PrintStream oldErrStream = System.err; System.setOut(context.getOutputStream()); System.setErr(context.getErrorStream()); PySystemState ss = Py.getSystemState(); PyObject oldStdout = ss.stdout; PyObject oldStderr = ss.stderr; ss.stdout = Py.java2py(context.getOutputStream()); ss.stderr = Py.java2py(context.getErrorStream()); Run the Python function. PyObject pyResult; try { pyResult = cookFunction.__call__(self); } finally { Reset the output streams. System.setOut(oldOutStream); System.setErr(oldErrStream); ss.stdout = oldStdout; ss.stderr = oldStderr; } Unwrap the result. Object result = pyResult.__tojava__(Object.class); if (result == Py.NoConversion) { throw new RuntimeException("Cannot convert Python object " + pyResult + " to java."); } return result; } 
public void nodeUpdated ( Node node , ProcessingContext context ) { + + updatedCounter ; } 
public void testOutput ( ) { ProcessingContext ctx ; PythonCode helloCode = new PythonCode ( " def cook(self): print 'hello' " ) ; Node test = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; test . setValue ( " _code " , helloCode ) ; ctx = new ProcessingContext ( ) ; test . update ( ctx ) ; assertEquals ( " hello " , ctx . getOutput ( ) ) ; Try this in a network. All the output of the nodes should be merged. Node parent = Node.ROOT_NODE.newInstance(testLibrary, "parent"); Node child = parent.create(Node.ROOT_NODE, "child"); child.setValue("_code", helloCode); child.setRendered(); ctx = new ProcessingContext(); parent.update(ctx); assertEquals("hello", ctx.getOutput()); } 
public void testNodeNaming ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test1 " ) ; assertInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; assertInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " root " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " network " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " context " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " __reserved " , " names cannot start with double underscores " ) ; assertInvalidName ( , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " " , " names cannot be empty " ) ; assertInvalidName ( , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; assertValidName ( , " radius " ) ; assertValidName ( , " _test " ) ; assertValidName ( , " _ " ) ; assertValidName ( , " _1234 " ) ; assertValidName ( , " a1234 " ) ; assertValidName ( , " node1 " ) ; assertValidName ( , " UPPERCASE " ) ; assertValidName ( , " uPpercase " ) ; } 
public void testNaming ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; assertInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; assertInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " root " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " network " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " context " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " __reserved " , " names cannot start with double underscores " ) ; assertInvalidName ( , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " " , " names cannot be empty " ) ; assertInvalidName ( , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; assertValidName ( , " radius " ) ; assertValidName ( , " _test " ) ; assertValidName ( , " _ " ) ; assertValidName ( , " _1234 " ) ; assertValidName ( , " a1234 " ) ; assertValidName ( , " UPPERCASE " ) ; assertValidName ( , " uPpercase " ) ; assertInvalidName ( , " radius " , " parameter names must be unique for the node " ) ; . addPort ( " myport " , Integer . class ) ; assertInvalidName ( , " myport " , " parameter names must be unique across parameters and ports " ) ; } 
public void testNaming ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; assertInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; assertInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " context " , " names can not be one of the reserved words. " ) ; assertValidName ( , " radius " ) ; assertInvalidName ( , " radius " , " port names must be unique for the node " ) ; . addParameter ( " myparam " , Parameter . Type . INT ) ; assertInvalidName ( , " myparam " , " port names must be unique across parameters and ports " ) ; } 
public void childRemoved ( Node source , Node child ) { NodeView nv = getNodeView ( child ) ; if ( nv = = null ) return ; getLayer ( ) . removeChild ( nv ) ; if ( selection . contains ( nv ) ) { deselect ( nv ) ; } If this child was connected, it is now disconnected. This means we should repaint the connection layer. connectionLayer.repaint(); } 
public boolean remove ( Node node ) { assert ( node ! = null ) ; if ( ! contains ( node ) ) return false ; node . markDirty ( ) ; node . disconnect ( ) ; node . parent = null ; children . remove ( node . getName ( ) ) ; if ( node = = renderedChild ) { setRenderedChild ( null ) ; } node . removeNodeAttributeListener ( this ) ; fireChildRemoved ( node ) ; return true ; } 
public void testRemoveNode ( ) { Create a basic connection. Node number1 = numberNode.newInstance(testLibrary, "number1"); Node negate1 = negateNode.newInstance(testLibrary, "negate1"); negate1.getPort("value").connect(number1); Remove the node. This should also remove all connections. testLibrary.getRootNode().remove(number1); assertFalse(number1.isConnected()); assertFalse(negate1.isConnected()); } 
public void testAccessors ( ) { Node rect1 = rectNode . newInstance ( testLibrary , " rect1 " ) ; Node trans1 = translateNode . newInstance ( testLibrary , " trans1 " ) ; Port pPolygon = trans1 . getPort ( " polygon " ) ; assertNull ( pPolygon . getConnection ( ) ) ; pPolygon . connect ( rect1 ) ; Connection c = pPolygon . getConnection ( ) ; assertNotNull ( c ) ; assertEquals ( rect1 , c . getOutputNode ( ) ) ; assertEquals ( trans1 , c . getInputNode ( ) ) ; assertEquals ( pPolygon , c . getInput ( ) ) ; } 
public Object evaluate ( ProcessingContext context ) throws ExpressionError { Set up state variables in the expression utilities class. This is not thread-safe. ExpressionHelper.currentContext = context; ExpressionHelper.currentParameter = parameter; Marked parameter references are used to find which parameters this expression references. markedParameterReferences = new HashSet<WeakReference<Parameter>>(); ProxyResolverFactory prf = new ProxyResolverFactory(parameter.getNode(), context, mutable, markedParameterReferences); try { return MVEL.executeExpression(compiledExpression, prf); 
public static Object stamp ( String key , Object defaultValue ) { if ( currentContext = = null ) return defaultValue ; currentParameter . markStampExpression ( ) ; Object v = currentContext . get ( key ) ; return v ! = null ? v : defaultValue ; } 
public void clearExpression ( String parameterName ) { Parameter p = parameters . get ( parameterName ) ; if ( p = = null ) throw new IllegalArgumentException ( " Parameter " + parameterName + " does not exist. " ) ; p . clearExpression ( ) ; } 
public boolean hasStampExpression ( ) { for ( Parameter p : parameters . values ( ) ) { if ( p . hasStampExpression ( ) ) return true ; } return false ; } 
public void update ( ProcessingContext ctx ) throws ProcessingError { if ( ! dirty ) return ; updateDependencies ( ctx ) ; All dependencies are up-to-date. Process the node. ProcessingError pe = null; try { process(ctx); } catch (ProcessingError e) { pe = e; } Even if an error occurred the node is still marked as clean, and events are fired. Only after these steps is the error thrown. It is important to mark the node as clean so that subsequent changes to the node mark it as dirty, triggering an event. This allows you to fix the node. dirty = false; fireNodeUpdated(ctx); If exception occurs, throw it. if (pe != null) throw pe; 
public void updateDependencies ( ProcessingContext ctx ) throws ProcessingError { Update all upstream nodes. if (parent != null && parent.childGraph != null) { for (Port port : ports.values()) { Connection conn = parent.childGraph.getInfo(port); if (conn == null) continue; Updating the connection sets the value of the corresponding input port. conn.update(ctx); } } Update all parameter expressions. for (Parameter param : parameters.values()) { try { 
 void markDirty ( ) { if ( dirty ) return ; dirty = true ; fireValueChanged ( ) ; } 
public void clearExpression ( ) { this . expression = null ; hasStampExpression = false ; removeDependencies ( ) ; markDirty ( ) ; } 
public boolean hasStampExpression ( ) { return hasStampExpression ; } 
 void markStampExpression ( ) { this . hasStampExpression = true ; } 
public void put ( String key , Object value ) { valueMap . put ( key , value ) ; } 
public Object get ( String key ) { return valueMap . get ( key ) ; } 
public boolean containsKey ( String key ) { return valueMap . containsKey ( key ) ; } 
public Set < String > keySet ( ) { return valueMap . keySet ( ) ; } 
public Object cook ( Node node , ProcessingContext context ) throws RuntimeException { if ( cookFunction = = null ) preCook ( ) ; Add globals into the function namespace. namespace.put("context", context); namespace.put("FRAME", context.getFrame()); PyObject self; if (node == null) { self = Py.None; } else { self = new SelfWrapper(node); } Reassign the output and error streams. PrintStream oldOutStream = System.out; PrintStream oldErrStream = System.err; System.setOut(context.getOutputStream()); System.setErr(context.getErrorStream()); PySystemState ss = Py.getSystemState(); PyObject oldStdout = ss.stdout; PyObject oldStderr = ss.stderr; ss.stdout = Py.java2py(context.getOutputStream()); ss.stderr = Py.java2py(context.getErrorStream()); Run the Python function. PyObject pyResult; try { pyResult = cookFunction.__call__(self); } finally { Reset the output streams. System.setOut(oldOutStream); System.setErr(oldErrStream); ss.stdout = oldStdout; ss.stderr = oldStderr; } Unwrap the result. Object result = pyResult.__tojava__(Object.class); if (result == Py.NoConversion) { throw new RuntimeException("Cannot convert Python object " + pyResult + " to java."); } return result; } 
public void testStamp ( ) { Polygon p ; Node rect1 = rectNode . newInstance ( testLibrary , " rect1 " ) ; Sets the width to a stamp expression. If this node gets executed, it retrieves "mywidth" from the context and uses that. If mywidth could not be found, it uses the default value of 20 for this parameter. rect1.getParameter("width").setExpression("stamp(\"mywidth\", 20)"); Update the node to see if it works. rect1.update(); p = (Polygon) rect1.getOutputValue(); assertEquals(new Rectangle(0, 0, 20, 100), p.getBounds()); The stamper is a node that relies on copy stamping to replace one of the parameters of the connected node. The connected node (rect1) still needs to use the "stamp" expression. Node stamper = translateNode.newInstance(testLibrary, "stamper"); Nodes are automatically evaluated once, even though we do not use the output. TODO: Set a flag on the node that allows control over cooking. String code = "def cook(self):" + " context.put(self.key, self.value)" + " self.node.stampDirty()" + " self.node.updateDependencies(context)" + " return self.polygon"; stamper.setValue("_code", new PythonCode(code)); stamper.addParameter("key", Parameter.Type.STRING); stamper.addParameter("value", Parameter.Type.FLOAT); stamper.setValue("key", "mywidth"); stamper.setValue("value", 50); stamper.getPort("polygon").connect(rect1); stamper.update(); p = (Polygon) stamper.getOutputValue(); assertEquals(new Rectangle(0, 0, 50, 100), p.getBounds()); } 
public void testHasStampExpression ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; Parameter pBeta = . addParameter ( " beta " , Parameter . Type . FLOAT ) ; assertFalse ( . hasStampExpression ( ) ) ; Set the parameters to expressions that do not use the stamp function. pAlpha.setExpression(" 12 + 5"); pBeta.setExpression("random(1, 5, 10)"); assertFalse(n.hasStampExpression()); Set one of the parameters to the stamp function. pBeta.setExpression("stamp(\"mybeta\", 42)"); assertTrue(n.hasStampExpression()); Set the other parameter expression to a stamp function as well. pAlpha.setExpression("stamp(\"myalpha\", 0) * 5"); assertTrue(n.hasStampExpression()); Clear out the expressions one by one. pAlpha.clearExpression(); assertTrue(n.hasStampExpression()); Change the beta parameter to some other expression. pBeta.setExpression("85 - 6"); assertFalse(n.hasStampExpression()); } 
public void testStampExpression ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node stamp1 = Node . ROOT_NODE . newInstance ( testLibrary , " stamp1 " , Integer . class ) ; stamp1 . addPort ( " value " , Integer . class ) ; stamp1 . getPort ( " value " ) . connect ( number1 ) ; The code prepares upstream dependencies for stamping, processes them and negates the output. String stampCode = "def cook(self):" + " context.put('my_a', 99)" + " self.node.stampDirty()" + " self.node.updateDependencies(context)" + " return -self.value # Negate the output"; stamp1.setValue("_code", new PythonCode(stampCode)); Parameter pValue = number1.getParameter("value"); Set number1 to a regular value. This should not influence the stamp operation. pValue.set(12); stamp1.update(); assertEquals(-12, stamp1.getOutputValue()); Set number1 to an expression. Since we're not using stamp, nothing strange should happen to the output. pValue.setExpression("2 + 1"); stamp1.update(); assertEquals(-3, stamp1.getOutputValue()); Set number1 to an unknown stamp expression. The default value will be picked. pValue.setExpression("stamp(\"xxx\", 19)"); stamp1.update(); assertEquals(-19, stamp1.getOutputValue()); Set number1 to the my_a stamp expression. The expression will be picked up. pValue.setExpression("stamp(\"my_a\", 33)"); stamp1.update(); assertEquals(-99, stamp1.getOutputValue()); } 
public void testMarkStampedDirty ( ) { Setup a graph where a <- b <- c. Node a = Node.ROOT_NODE.newInstance(testLibrary, "a", Integer.class); Node b = Node.ROOT_NODE.newInstance(testLibrary, "b", Integer.class); Node c = Node.ROOT_NODE.newInstance(testLibrary, "c", Integer.class); a.addParameter("a", Parameter.Type.INT); b.addParameter("b", Parameter.Type.INT); Port bIn = b.addPort("in", Integer.class); Port cIn = c.addPort("in", Integer.class); bIn.connect(a); cIn.connect(b); Update the graph. This will make a, b and c clean. c.update(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); Set b to a stamped expression. This will make node b, and all of its dependencies, dirty. b.setExpression("b", "stamp(\"my_b\", 55)"); assertTrue(b.hasStampExpression()); assertFalse(a.isDirty()); assertTrue(b.isDirty()); assertTrue(c.isDirty()); Update the graph, cleaning all of the nodes. c.update(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); Mark only stamped upstream nodes as dirty. This will make b dirty, and all of its dependencies. c.stampDirty(); assertFalse(a.isDirty()); assertTrue(b.isDirty()); assertTrue(c.isDirty()); Remove the expression and update. This will make all nodes clean again. b.clearExpression("b"); c.update(); Node b will not be dirty, since everything was updated. assertFalse(b.isDirty()); Since there are no nodes with stamp expressions, marking the stamped upstream nodes will have no effect. c.stampDirty(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); } 
public void testHasStampExpression ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; No expression is set, so the stamp flag should be off. assertFalse(pAlpha.hasStampExpression()); The expression doesn't reference te stamp function. pAlpha.setExpression("12 + 3"); assertFalse(pAlpha.hasStampExpression()); Updating the node shouldn't make any difference in the stamp expression flag. n.update(); assertFalse(pAlpha.hasStampExpression()); Now set an expression that does use the stamp function. pAlpha.setExpression("stamp(\"myalpha\", 12)"); assertTrue(pAlpha.hasStampExpression()); Again, updating the node shouldn't make any difference. n.update(); assertTrue(pAlpha.hasStampExpression()); Set the parameter to the *same* expression. pAlpha.setExpression("stamp(\"myalpha\", 12)"); assertTrue(pAlpha.hasStampExpression()); Clear out the expression. pAlpha.clearExpression(); assertFalse(pAlpha.hasStampExpression()); } 
public Object evaluate ( ProcessingContext context ) throws ExpressionError { Set up state variables in the expression utilities class. This is not thread-safe. ExpressionHelper.currentContext = context; ExpressionHelper.currentParameter = parameter; Marked parameter references are used to find which parameters this expression references. markedParameterReferences = new HashSet<WeakReference<Parameter>>(); ProxyResolverFactory prf = new ProxyResolverFactory(parameter.getNode(), context, markedParameterReferences); try { return MVEL.executeExpression(compiledExpression, prf); 
public void testNetworkLocal ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; net . addParameter ( " pn " , Parameter . Type . INT , 33 ) ; Node number1 = net . create ( numberNode ) ; Parameter pValue1 = number1 . getParameter ( " value " ) ; pValue1 . set ( 84 ) ; assertEquals ( " number1 " , number1 . getName ( ) ) ; Parameter p1 = test1.addParameter("p1", Parameter.Type.INT); Node number2 = net.create(numberNode); assertEquals("number2", number2.getName()); Parameter p2 = number2.addParameter("p2", Parameter.Type.INT); Parameter pValue2 = number2.getParameter("value"); pValue2.set(12); Trying to get the value of number2 by just using the expression "value" is impossible, since it will retrieve the value parameter of number1, which will cause a cycle. assertInvalidExpression(pValue1, "value", "refers to itself"); Access p2 through the node name. assertExpressionEquals(12, pValue1, "number2.value"); Access p2 through the network. assertExpressionEquals(12, pValue1, "parent.number2.value"); Access the pn Parameter on the network. assertExpressionEquals(33, pValue1, "parent.pn"); } 
public void testGet ( ) { Node root = testLibrary . getRootNode ( ) ; Node trunk = Node . ROOT_NODE . newInstance ( testLibrary , " trunk " ) ; Node branch = Node . ROOT_NODE . newInstance ( testLibrary , " branch " ) ; Node leaf1 = Node . ROOT_NODE . newInstance ( testLibrary , " leaf1 " ) ; Node leaf2 = Node . ROOT_NODE . newInstance ( testLibrary , " leaf2 " ) ; leaf1 . setParent ( branch ) ; leaf2 . setParent ( branch ) ; branch . setParent ( trunk ) ; trunk . addParameter ( " age " , Parameter . Type . INT , 42 ) ; branch . addParameter ( " length " , Parameter . Type . INT , 33 ) ; leaf1 . addParameter ( " width " , Parameter . Type . INT , 5 ) ; leaf2 . addParameter ( " width " , Parameter . Type . INT , 7 ) ; Check reserved keywords. assertProxyEquals(root, trunk, "root"); assertProxyEquals(root, trunk, "parent"); assertProxyNull(root, "parent"); Check children assertProxyEquals(branch, trunk, "branch"); assertProxyEquals(leaf1, branch, "leaf1"); assertProxyEquals(leaf2, branch, "leaf2"); assertProxyNull(branch, "leaf3"); } 
public boolean disconnect ( Port input , Node outputNode ) { if ( input = = null ) throw new IllegalArgumentException ( " The input port cannot be null. " ) ; if ( outputNode = = null ) throw new IllegalArgumentException ( " The output node cannot be null. " ) ; if ( input . getParentNode ( ) ! = outputNode . getParent ( ) ) throw new IllegalArgumentException ( " The input and output are not under the same parent. " ) ; if ( ! input . isInputPort ( ) ) throw new IllegalArgumentException ( " The given port is not an input. " ) ; Node parent = input . getParentNode ( ) ; if ( parent = = null ) return false ; DependencyGraph < Port , Connection > dg = parent . childGraph ; if ( dg = = null ) return false ; Connection c = dg . getInfo ( input ) ; Port output = outputNode . outputPort ; boolean removedSomething = dg . removeDependency ( output , input ) ; if ( removedSomething ) { input . reset ( ) ; This port was changed. Mark the node as dirty. input.getNode().markDirty(); parent.fireConnectionRemoved(c); } return removedSomething; } 
public void connectionAdded ( Node source , Connection connection ) { + + connectCounter ; } 
public void connectionRemoved ( Node source , Connection connection ) { + + disconnectCounter ; } 
public void testConnectionEvents ( ) { ConnectListener l = new ConnectListener ( ) ; Setup a basic network with number1 <- addConstant1 Node root = testLibrary.getRootNode(); root.addNodeChildListener(l); Node number1 = root.create(numberNode); Node addConstant1 = root.create(addConstantNode); No connect/disconnect events have been fired. assertEquals(0, l.connectCounter); assertEquals(0, l.disconnectCounter); Creating a connection fires the event. addConstant1.getPort("value").connect(number1); assertEquals(1, l.connectCounter); assertEquals(0, l.disconnectCounter); Create a second number and connect it to the add constant. This should fire a disconnect event from number1, and a connect event to number2. Node number2 = root.create(numberNode); addConstant1.getPort("value").connect(number2); assertEquals(2, l.connectCounter); assertEquals(1, l.disconnectCounter); Disconnect the constant node. This should remove all (1) connections, and cause one disconnect event. addConstant1.disconnect(); assertEquals(2, l.connectCounter); assertEquals(2, l.disconnectCounter); } 
public boolean removeDependency ( T dependency , T dependent ) { Set < T > dependencies = upstreams . get ( dependent ) ; Set < T > dependents = downstreams . get ( dependency ) ; boolean removedSomething = false ; if ( dependencies ! = null ) removedSomething = dependencies . remove ( dependency ) ; if ( dependents ! = null ) removedSomething = dependents . remove ( dependent ) | removedSomething ; return removedSomething ; } 
public void testRemoveDependency ( ) { DependencyGraph < Character , Object > dg ; dg = new DependencyGraph < Character , Object > ( ) ; Z depends on A. dg.addDependency('A', 'Z'); assertEquals(1, dg.getDependencies('Z').size()); assertEquals(1, dg.getDependents('A').size()); Remove the dependency. assertTrue(dg.removeDependency('A', 'Z')); assertFalse(dg.hasDependency('A', 'Z')); assertEquals(0, dg.getDependencies('Z').size()); assertEquals(0, dg.getDependents('A').size()); } 
public boolean disconnect ( Port input , Node outputNode ) { if ( input = = null ) throw new IllegalArgumentException ( " The input port cannot be null. " ) ; if ( outputNode = = null ) throw new IllegalArgumentException ( " The output node cannot be null. " ) ; if ( input . getParentNode ( ) ! = outputNode . getParent ( ) ) throw new IllegalArgumentException ( " The input and output are not under the same parent. " ) ; if ( ! input . isInputPort ( ) ) throw new IllegalArgumentException ( " The given port is not an input. " ) ; Node parent = input . getParentNode ( ) ; if ( parent = = null ) return false ; DependencyGraph < Port , Connection > dg = parent . childGraph ; if ( dg = = null ) return false ; Connection c = dg . getInfo ( input ) ; Port output = outputNode . outputPort ; boolean removedSomething = dg . removeDependency ( output , input ) ; if ( removedSomething ) { We remove the output port from the connection. c.removeOutput(output); If the connection has no more output ports, remove the connection entirely. if (!c.hasOutputs()) dg.removeInfo(input); input.reset(); This port was changed. Mark the node as dirty. input.getNode().markDirty(); parent.fireConnectionRemoved(c); } return removedSomething; } 
public void testDisconnect ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node number2 = numberNode . newInstance ( testLibrary , " number2 " ) ; Node m = multiplyNode . newInstance ( testLibrary , " multiply1 " ) ; number1 . setValue ( " value " , 5 ) ; number2 . setValue ( " value " , 2 ) ; m . getPort ( " v1 " ) . connect ( number1 ) ; m . getPort ( " v2 " ) . connect ( number2 ) ; assertTrue ( m . getPort ( " v1 " ) . isConnected ( ) ) ; assertTrue ( number1 . isOutputConnected ( ) ) ; m . update ( ) ; assertEquals ( 5 , m . getPort ( " v1 " ) . getValue ( ) ) ; assertEquals ( 10 , m . getOutputValue ( ) ) ; assertNotNull ( m . getPort ( " v1 " ) . getConnection ( ) ) ; Disconnecting a port makes the dependent nodes dirty, but not the upstream nodes. "Dirt flows downstream" m.getPort("v1").disconnect(); assertTrue(m.isDirty()); assertFalse(number1.isDirty()); assertFalse(m.getPort("v1").isConnected()); assertFalse(number1.isOutputConnected()); assertNull(m.getPort("v1").getConnection()); The value of the input port is set to null after disconnection. Since our simple multiply node doesn't handle null, it throws a NullPointerException, which gets wrapped in a ProcessingError. assertProcessingError(m, NullPointerException.class); assertNull(m.getOutputValue()); } 
public void testDisconnectOutputNode ( ) { Setup a simple network where number1 <- addConstant1. Node root = testLibrary.getRootNode(); Node number1 = root.create(numberNode); Node addConstant1 = root.create(addConstantNode); Port pValue =addConstant1.getPort("value"); pValue.connect(number1); Remove the specific connection and check if everything was removed. addConstant1.disconnect(pValue, number1); assertFalse(number1.isConnected()); assertFalse(addConstant1.isConnected()); assertNull(pValue.getConnection()); } 
public void select ( Connection connection ) { selection = connection ; } 
public void deselect ( ) { selection = null ; repaint ( ) ; } 
public boolean hasSelection ( ) { return selection ! = null ; } 
public static void paintConnection ( Graphics2D g , Node outputNode , Node inputNode ) { GeneralPath p = connectionPath ( outputNode , inputNode ) ; paintConnectionPath ( g , p ) ; } 
public static void paintConnection ( Graphics2D g , Node outputNode , float x1 , float y1 ) { GeneralPath p = connectionPath ( outputNode , x1 , y1 ) ; paintConnectionPath ( g , p ) ; } 
public static void paintConnectionPath ( Graphics2D g , GeneralPath p ) { g . setStroke ( new BasicStroke ( 2 ) ) ; g . draw ( p ) ; } 
public static GeneralPath connectionPath ( Node outputNode , Node inputNode ) { float x1 = ( float ) ( inputNode . getX ( ) + 1 ) ; Compensate for selection border float y1 = (float) (inputNode.getY() + NodeView.NODE_FULL_SIZE / 2); return connectionPath(outputNode, x1, y1); } 
public static GeneralPath connectionPath ( Node outputNode , float x1 , float y1 ) { GeneralPath p = new GeneralPath ( ) ; Start position is at the middle right of the node. float x0 = (float) (outputNode.getX() + NodeView.NODE_FULL_SIZE - 1); Compensate for selection border float y0 = (float) (outputNode.getY() + NodeView.NODE_FULL_SIZE / 2); End position is at the middle left of the node. float dx = Math.abs(y1 - y0) / 2; p.moveTo(x0, y0); p.curveTo(x0 + dx, y0, x1 - dx, y1, x1, y1); return p; } 
public void mouseClickedEvent ( PInputEvent e ) { Connection c = clickedConnection ( e . getPosition ( ) ) ; if ( c = = null ) { deselect ( ) ; 
public void singleSelect ( NodeView nodeView ) { if ( nodeView = = null ) return ; if ( selection . size ( ) = = 1 & & selection . contains ( nodeView ) ) return ; for ( NodeView nv : selection ) { nv . setSelected ( false ) ; } connectionLayer . deselect ( ) ; selection . clear ( ) ; selection . add ( nodeView ) ; nodeView . setSelected ( true ) ; firePropertyChange ( SELECT_PROPERTY , null , selection ) ; } 
public void deselectAll ( ) { If the selection was already empty, we don't need to do anything. if (selection.isEmpty()) return; for (NodeView nodeView : selection) { nodeView.setSelected(false); } selection.clear(); connectionLayer.deselect(); firePropertyChange(SELECT_PROPERTY, null, selection); } 
public void mouseClicked ( PInputEvent e ) { if ( e . getButton ( ) ! = MouseEvent . BUTTON1 ) return ; deselectAll ( ) ; connectionLayer . mouseClickedEvent ( e ) ; } 
public void mouseDragged ( PInputEvent e ) { if ( selectionMarker = = null ) return ; Point2D prev = selectionMarker . getOffset ( ) ; Point2D p = e . getPosition ( ) ; selectionMarker . setWidth ( p . getX ( ) - prev . getX ( ) ) ; selectionMarker . setHeight ( p . getY ( ) - prev . getY ( ) ) ; ListIterator childIter = getLayer ( ) . getChildrenIterator ( ) ; connectionLayer . deselect ( ) ; temporarySelection . clear ( ) ; while ( childIter . hasNext ( ) ) { Object o = childIter . next ( ) ; 
public void testExpressionPropagation ( ) { Inheritance: A <- B Node nodeA = Node.ROOT_NODE.newInstance(testLibrary, "A"); Parameter pF =nodeA.addParameter("f", Parameter.Type.INT, 0); String expr1="12 + 5"; pF.setExpression(expr1); Node nodeB = nodeA.newInstance(testLibrary, "B"); assertEquals(expr1, nodeB.getParameter("f").getExpression()); Changing the expression of A does not automatically change that of B. String expr2 = "4 * 2"; pF.setExpression(expr2); assertEquals(expr1, nodeB.getParameter("f").getExpression()); Reverting to default does. nodeB.getParameter("f").revertToDefault(); assertEquals(expr2, nodeB.getParameter("f").getExpression()); } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Expression that = ( Expression ) o ; if ( ! expression . equals ( that . expression ) ) return false ; return true ; } 
public int hashCode ( ) { return expression . hashCode ( ) ; } 
private boolean prototypeEquals ( Parameter o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Parameter parameter = ( Parameter ) o ; if ( boundingMethod ! = parameter . boundingMethod ) return false ; if ( displayLevel ! = parameter . displayLevel ) return false ; if ( expression ! = null ? ! expression . equals ( parameter . expression ) : parameter . expression ! = null ) return false ; if ( helpText ! = null ? ! helpText . equals ( parameter . helpText ) : parameter . helpText ! = null ) return false ; if ( ! label . equals ( parameter . label ) ) return false ; if ( maximumValue ! = null ? ! maximumValue . equals ( parameter . maximumValue ) : parameter . maximumValue ! = null ) return false ; if ( ! menuItems . equals ( parameter . menuItems ) ) return false ; if ( minimumValue ! = null ? ! minimumValue . equals ( parameter . minimumValue ) : parameter . minimumValue ! = null ) return false ; if ( ! name . equals ( parameter . name ) ) return false ; if ( type ! = parameter . type ) return false ; if ( expression = = null ) if ( value ! = null ? ! value . equals ( parameter . value ) : parameter . value ! = null ) return false ; if ( widget ! = parameter . widget ) return false ; return true ; } 
public void testStamp ( ) { Polygon p ; Node rect1 = rectNode . newInstance ( testLibrary , " rect1 " ) ; Sets the width to a stamp expression. If this node gets executed, it retrieves "mywidth" from the context and uses that. If mywidth could not be found, it uses the default value of 20 for this parameter. rect1.getParameter("width").setExpression("stamp(\"mywidth\", 20)"); Update the node to see if it works. rect1.update(); p = (Polygon) rect1.getOutputValue(); assertEquals(new Rectangle(0, 0, 20, 100), p.getBounds()); The stamper is a node that relies on copy stamping to replace one of the parameters of the connected node. The connected node (rect1) still needs to use the "stamp" expression. Node stamper = translateNode.newInstance(testLibrary, "stamper"); Nodes are automatically evaluated once, even though we do not use the output. TODO: Set a flag on the node that allows control over cooking. String code = "def cook(self):" + " context.put(self.key, self.value)" + " self.node.stampDirty()" + " self.node.updateDependencies(context)" + " return self.polygon"; stamper.setValue("_code", new PythonCode(code)); stamper.addParameter("key", Parameter.Type.STRING); stamper.addParameter("value", Parameter.Type.FLOAT); stamper.setValue("key", "mywidth"); stamper.setValue("value", 50); stamper.getPort("polygon").connect(rect1); stamper.update(); p = (Polygon) stamper.getOutputValue(); assertEquals(new Rectangle(0, 0, 50, 100), p.getBounds()); } 
public void testEquals ( ) { Node a = Node . ROOT_NODE . newInstance ( testLibrary , " a " ) ; Node b = Node . ROOT_NODE . newInstance ( testLibrary , " b " ) ; Parameter pA = a . addParameter ( " a " , Parameter . Type . INT ) ; Parameter pB = b . addParameter ( " b " , Parameter . Type . INT ) ; String expr1 = " random(1, 2, 3) " ; Expression eA = new Expression ( pA , expr1 ) ; Expression eB = new Expression ( pB , expr1 ) ; assertEquals ( eA , eB ) ; } 
public void testStoreExpressions ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " ) ; alpha . addParameter ( " v " , Parameter . Type . INT ) ; alpha . setValue ( " v " , 10 ) ; alpha . getParameter ( " v " ) . setExpression ( " 44 - 2 " ) ; Inherit from alpha. Node beta = alpha.newInstance(library, "beta"); Roundabout way to check if the expression tag only appears once. If the first position where it appears == the last position, it only appears once. String xml = library.toXml(); assertTrue(xml.indexOf("<expression>") == xml.lastIndexOf("<expression>")); NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", library.toXml(), manager); Node newAlpha = newLibrary.get("alpha"); assertEquals("44 - 2", newAlpha.getParameter("v").getExpression()); newAlpha.update(); assertEquals(42, newAlpha.getValue("v")); } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; MenuItem menuItem = ( MenuItem ) o ; if ( ! key . equals ( menuItem . key ) ) return false ; if ( ! label . equals ( menuItem . label ) ) return false ; return true ; } 
public int hashCode ( ) { int result = key . hashCode ( ) ; result = 31 * result + label . hashCode ( ) ; return result ; } 
public void toXml ( StringBuffer xml , String spaces ) { We only write out the attributes that have changed with regards to the prototype. Parameter protoParam = getPrototype(); If the parameter and its prototype are completely equal, don't write anything. if (prototypeEquals(protoParam)) return; The parameters are not equal, so we can start writing the name. xml.append(spaces).append("<param name=\"").append(getName()).append("\""); Write parameter type if (protoParam == null || !getType().equals(protoParam.getType())) xml.append(" ").append(NDBXHandler.PARAMETER_TYPE).append("=\"").append(getType().toString().toLowerCase()).append("\""); Write parameter attributes attributeToXml(xml, "widget", NDBXHandler.PARAMETER_WIDGET, protoParam, WIDGET_MAPPING.get(type)); attributeToXml(xml, "label", NDBXHandler.PARAMETER_LABEL, protoParam, StringUtils.humanizeName(name)); attributeToXml(xml, "helpText", NDBXHandler.PARAMETER_HELP_TEXT, protoParam, null); attributeToXml(xml, "displayLevel", NDBXHandler.PARAMETER_DISPLAY_LEVEL, protoParam, DisplayLevel.HUD); attributeToXml(xml, "boundingMethod", NDBXHandler.PARAMETER_BOUNDING_METHOD, protoParam, BoundingMethod.NONE); attributeToXml(xml, "minimumValue", NDBXHandler.PARAMETER_MINIMUM_VALUE, protoParam, null); attributeToXml(xml, "maximumValue", NDBXHandler.PARAMETER_MAXIMUM_VALUE, protoParam, null); xml.append(">"); Write parameter value / expression if (hasExpression()) { xml.append(spaces).append(" <expression>").append(getExpression()).append("</expression>"); } else { if (type == Type.INT) { xml.append(spaces).append(" <value>").append(asInt()).append("</value>"); } else if (type == Type.FLOAT) { xml.append(spaces).append(" <value>").append(asFloat()).append("</value>"); } else if (type == Type.STRING) { xml.append(spaces).append(" <value>").append(asString()).append("</value>"); } else if (type == Type.COLOR) { xml.append(spaces).append(" <value>").append(asColor().toString()).append("</value>"); } else if (type == Type.CODE) { xml.append(spaces).append(" <value type=\"").append(asCode().getType()).append("\"><![CDATA[").append(asCode().getSource()).append("]]></value>"); } else { throw new AssertionError("Unknown value class " + type); } } Write menu items if (menuItems.size() > 0) { List<Parameter.MenuItem> protoItems = protoParam == null ? null : protoParam.getMenuItems(); if (!menuItems.equals(protoItems)) { for (MenuItem item : menuItems) { xml.append(spaces).append(" <menu key=\"").append(item.getKey()).append("\">").append(item.getLabel()).append("</menu>"); } } } xml.append(spaces).append("</param>"); } 
public void testStoreExpressions ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " ) ; alpha . addParameter ( " v " , Parameter . Type . INT ) ; alpha . setValue ( " v " , 10 ) ; alpha . getParameter ( " v " ) . setExpression ( " 44 - 2 " ) ; Inherit from alpha. Node beta = alpha.newInstance(library, "beta"); Check if the expression tag only appears once. String xml = library.toXml(); assertOnlyOnce(xml, "<expression>"); NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.get("alpha"); assertEquals("44 - 2", newAlpha.getParameter("v").getExpression()); newAlpha.update(); assertEquals(42, newAlpha.getValue("v")); } 
public void testStoreParameterAttributes ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " , Polygon . class ) ; Parameter pAngle = alpha . addParameter ( " angle " , Parameter . Type . FLOAT , 42 ) ; pAngle . setWidget ( Parameter . Widget . ANGLE ) ; pAngle . setMinimumValue ( - 360 f ) ; pAngle . setMaximumValue ( 360 f ) ; pAngle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; Parameter pMenu = alpha . addParameter ( " menu " , Parameter . Type . STRING , " es " ) ; pMenu . setWidget ( Parameter . Widget . MENU ) ; pMenu . addMenuItem ( " en " , " English " ) ; pMenu . addMenuItem ( " es " , " Spanish " ) ; Parameter pHidden = alpha . addParameter ( " hidden " , Parameter . Type . STRING , " invisible " ) ; pHidden . setDisplayLevel ( Parameter . DisplayLevel . HIDDEN ) ; Parameter pLabel = alpha . addParameter ( " label " , Parameter . Type . STRING , " label + help text " ) ; pLabel . setLabel ( " My Label " ) ; pLabel . setHelpText ( " My Help Text " ) ; Inherit from alpha. This is used to test if prototype data is stored only once. Node beta = alpha.newInstance(library, "beta"); String xml = library.toXml(); assertOnlyOnce(xml, "<param name=\"menu\""); NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.get("alpha"); Parameter newAngle = newAlpha.getParameter("angle"); assertEquals(Parameter.Widget.ANGLE, newAngle.getWidget()); assertEquals(Parameter.BoundingMethod.HARD, newAngle.getBoundingMethod()); assertEquals(-360f, newAngle.getMinimumValue()); assertEquals(360f, newAngle.getMaximumValue()); Parameter newMenu = newAlpha.getParameter("menu"); assertEquals(Parameter.Widget.MENU, newMenu.getWidget()); Parameter.MenuItem item0 = newMenu.getMenuItems().get(0); Parameter.MenuItem item1 = newMenu.getMenuItems().get(1); assertEquals("en", item0.getKey()); assertEquals("English", item0.getLabel()); assertEquals("es", item1.getKey()); assertEquals("Spanish", item1.getLabel()); Parameter newHidden = newAlpha.getParameter("hidden"); assertEquals(Parameter.DisplayLevel.HIDDEN, newHidden.getDisplayLevel()); assertEquals("invisible", newHidden.getValue()); Parameter newLabel = newAlpha.getParameter("label"); assertEquals("My Label", newLabel.getLabel()); assertEquals("My Help Text", newLabel.getHelpText()); } 
public void assertOnlyOnce ( String source , String searchString ) { If the first position where it appears == the last position, it only appears once. assertTrue(source.indexOf(searchString) >= 0 && source.indexOf(searchString) == source.lastIndexOf(searchString)); } 
public void valueChanged ( Parameter source ) { Don't change the expression area if the expression is the same. This would cause an infinite loop of setExpression/valueChanged calls. if (expressionArea.getText().equals(parameter.getExpression())) return; expressionArea.setText(parameter.getExpression()); } 
public void actionPerformed ( ActionEvent e ) { ExpressionWindow . this . dispose ( ) ; } 
private boolean saveExpression ( ) { expressionArea . requestFocus ( ) ; try { parameter . setExpression ( expressionArea . getText ( ) ) ; 
public void actionPerformed ( ActionEvent e ) { saveExpression ( ) ; } 
public void actionPerformed ( ActionEvent e ) { if ( saveExpression ( ) ) { dispose ( ) ; 
public static void main ( String [ ] args ) { NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pX = node . addParameter ( " x " , Parameter . Type . FLOAT ) ; ExpressionWindow win = new ExpressionWindow ( pX ) ; win . setVisible ( true ) ; } 
public void componentResized ( ComponentEvent e ) { Dimension controlSize = control . getPreferredSize ( ) ; Rectangle bounds = getBounds ( ) ; int h = bounds . height - TOP_PADDING - BOTTOM_PADDING ; label . setBounds ( 0 , TOP_PADDING , ParameterView . LABEL_WIDTH , h ) ; control . setBounds ( ParameterView . LABEL_WIDTH + 10 , TOP_PADDING , controlSize . width , h ) ; control . doLayout ( ) ; expressionPanel . setBounds ( ParameterView . LABEL_WIDTH + 10 , TOP_PADDING , 200 , h ) ; repaint ( ) ; } 
public void actionPerformed ( ActionEvent e ) { window = new ExpressionWindow ( parameter ) ; window . setLocationRelativeTo ( this ) ; window . setVisible ( true ) ; } 
public void setExpression ( String expression ) throws ExpressionError { if ( this . expression ! = null & & this . expression . equals ( expression ) ) return ; this . expression = expression ; markedParameterReferences = null ; ExpressionCompiler compiler = new ExpressionCompiler ( expression ) ; try { this . compiledExpression = compiler . compile ( parserContext ) ; 
public void removeNotify ( ) { super . removeNotify ( ) ; parameter . getNode ( ) . removeParameterValueListener ( this ) ; if ( window ! = null ) window . dispose ( ) ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setColor ( SwingUtils . COLOR_NORMAL ) ; g2 . setFont ( SwingUtils . FONT_BOLD ) ; int textX = ParameterView . LABEL_WIDTH - g2 . getFontMetrics ( ) . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = (getHeight() - g2.getFont().getSize()) / 2 + g2.getFont().getSize(); SwingUtils.drawShadowText(g2, getText(), textX, textY, new Color(176, 176, 176), 1); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setColor ( SwingUtils . COLOR_NORMAL ) ; g2 . setFont ( SwingUtils . FONT_BOLD ) ; int textX = ParameterView . LABEL_WIDTH - g2 . getFontMetrics ( ) . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = (getHeight() - g2.getFont().getSize()) / 2 + 10; SwingUtils.drawShadowText(g2, getText(), textX, textY, new Color(176, 176, 176), 1); } 
public void actionPerformed ( ActionEvent e ) { AbstractParameterEditor . this . dispose ( ) ; } 
public void actionPerformed ( ActionEvent e ) { if ( save ( ) ) { dispose ( ) ; 
public void valueChanged ( Parameter source ) { Don't change the expression area if the expression is the same. This would cause an infinite loop of setExpression/valueChanged calls. if (expressionArea.getText().equals(getParameter().getExpression())) return; expressionArea.setText(getParameter().getExpression()); } 
public boolean save ( ) { expressionArea . requestFocus ( ) ; try { getParameter ( ) . setExpression ( expressionArea . getText ( ) ) ; 
public static void main ( String [ ] args ) { NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pX = node . addParameter ( " x " , Parameter . Type . FLOAT ) ; AbstractParameterEditor win = new ExpressionWindow ( pX ) ; win . setVisible ( true ) ; } 
public void addParameterEditor ( ParameterEditor editor ) { if ( parameterEditors . contains ( editor ) ) return ; parameterEditors . add ( editor ) ; } 
public void removeParameterEditor ( ParameterEditor editor ) { parameterEditors . remove ( editor ) ; } 
public void actionPerformed ( ActionEvent e ) { NodeBoxDocument doc = NodeBoxDocument . getCurrentDocument ( ) ; if ( doc = = null ) throw new RuntimeException ( " No current active document. " ) ; ExpressionWindow window = new ExpressionWindow ( parameter ) ; window . setLocationRelativeTo ( this ) ; window . setVisible ( true ) ; doc . addParameterEditor ( window ) ; } 
public boolean save ( ) { textArea . requestFocus ( ) ; try { getParameter ( ) . setValue ( textArea . getText ( ) ) ; 
public void valueChanged ( Parameter source ) { Don't change the expression area if the expression is the same. This would cause an infinite loop of setExpression/valueChanged calls. if (textArea.getText().equals(getParameter().asString())) return; textArea.setText(getParameter().asString()); } 
public static void main ( String [ ] args ) { NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pText = node . addParameter ( " text " , Parameter . Type . STRING ) ; AbstractParameterEditor win = new TextWindow ( pText ) ; win . setVisible ( true ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.resetContext(); context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("g", context); interpreter.set("BezierPath", nodebox.graphics.BezierPath.class); interpreter.set("Canvas", nodebox.graphics.Canvas.class); interpreter.set("Color", nodebox.graphics.Color.class); interpreter.set("GraphicsContext", nodebox.graphics.GraphicsContext.class); interpreter.set("Grob", nodebox.graphics.Grob.class); interpreter.set("Path", Path.class); interpreter.set("Group", Group.class); interpreter.set("Image", nodebox.graphics.Image.class); interpreter.set("NodeBoxError", nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", nodebox.graphics.PathElement.class); interpreter.set("Point", nodebox.graphics.Point.class); interpreter.set("Rect", nodebox.graphics.Rect.class); interpreter.set("Text", nodebox.graphics.Text.class); interpreter.set("Transform", nodebox.graphics.Transform.class); interpreter.set("LEFT", Text.Align.LEFT); interpreter.set("RIGHT", Text.Align.RIGHT); interpreter.set("CENTER", Text.Align.CENTER); interpreter.set("JUSTIFY", Text.Align.JUSTIFY); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
public boolean exportToFile ( File file ) { todo: file export only works on grobs. if (activeNetwork == null || activeNetwork.getRenderedChild() == null) return false; Object outputValue = activeNetwork.getRenderedChild().getOutputValue(); nodebox.graphics.Canvas canvas; if (outputValue instanceof nodebox.graphics.Canvas) { canvas = (nodebox.graphics.Canvas) outputValue; } else if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; Rect bounds = g.getBounds(); canvas = new nodebox.graphics.Canvas(bounds.getWidth(), bounds.getHeight()); We need to translate the canvas to compensate for the x/y value of the grob. double dx = bounds.getWidth() / 2 + bounds.getX(); double dy = bounds.getHeight() / 2 + bounds.getY(); TODO: canvas.translate(-dx, -dy); canvas.add(g); } else { throw new RuntimeException("This type of output cannot be exported " + outputValue); } canvas.save(file); return true; } 
private nodebox . graphics . Point pointForEvent ( MouseEvent e ) { double cx = - getWidth ( ) / 2.0 + e . getX ( ) ; double cy = - getHeight ( ) / 2.0 + e . getY ( ) ; return new nodebox . graphics . Point ( ( float ) cx , ( float ) cy ) ; } 
public void transform ( Transform ) { this . transform . append ( ) ; } 
public void translate ( float tx , float ty ) { transform . translate ( tx , ty ) ; } 
public void rotate ( float degrees ) { transform . rotate ( degrees ) ; } 
public void scale ( float scale ) { transform . scale ( scale ) ; } 
public void scale ( float sx , float sy ) { transform . scale ( sx , sy ) ; } 
public void skew ( float kx , float ky ) { transform . skew ( kx , ky ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } Object methods public abstract Grob clone();} 
public void moveto ( float x , float y ) { elements . add ( new PathElement ( PathElement . MOVETO , x , y ) ) ; needsMoveto = false ; dirty = true ; } 
public void lineto ( float x , float y ) { if ( needsMoveto ) throw new NodeBoxError ( " Lineto without first doing moveto. " ) ; elements . add ( new PathElement ( PathElement . LINETO , x , y ) ) ; dirty = true ; } 
public void quadto ( float x1 , float y1 , float x2 , float y2 ) { if ( needsMoveto ) throw new NodeBoxError ( " Quadto without first doing moveto. " ) ; PathElement lastElement = elements . get ( elements . size ( ) - 1 ) ; We don't support quads natively, but we accept them and convert them to a cubic bezier. float lastX = lastElement.getX(); float lastY = lastElement.getY(); float c1x = lastX + (x1 - lastX) * 2 / 3; float c1y = lastY + (y1 - lastY) * 2 / 3; float c2x = x2 - (x2 - x1) * 2 / 3; float c2y = y2 - (y2 - y1) * 2 / 3; curveto(c1x, c1y, c2x, c2y, x2, y2); } 
public void curveto ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { if ( needsMoveto ) throw new NodeBoxError ( " Curveto without first doing moveto. " ) ; elements . add ( new PathElement ( PathElement . CURVETO , x1 , y1 , x2 , y2 , x3 , y3 ) ) ; dirty = true ; } 
public void rect ( float cx , float cy , float width , float height ) { float halfWidth = width / 2 ; float halfHeight = height / 2 ; moveto ( cx - halfWidth , cy - halfHeight ) ; lineto ( cx + halfWidth , cy - halfHeight ) ; lineto ( cx + halfWidth , cy + halfHeight ) ; lineto ( cx - halfWidth , cy + halfHeight ) ; close ( ) ; } 
public void rect ( Rect r , float roundness ) { roundedRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , roundness ) ; } 
public void rect ( Rect r , float rx , float ry ) { roundedRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , rx , ry ) ; } 
public void rect ( float cx , float cy , float width , float height , float r ) { roundedRect ( cx , cy , width , height , r ) ; } 
public void rect ( float cx , float cy , float width , float height , float rx , float ry ) { roundedRect ( cx , cy , width , height , rx , ry ) ; } 
public void roundedRect ( Rect r , float roundness ) { roundedRect ( r , roundness , roundness ) ; } 
public void roundedRect ( Rect r , float rx , float ry ) { roundedRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , rx , ry ) ; } 
public void roundedRect ( float cx , float cy , float width , float height , float r ) { roundedRect ( cx , cy , width , height , r , r ) ; } 
public void roundedRect ( float cx , float cy , float width , float height , float rx , float ry ) { float halfWidth = width / 2f ; float halfHeight = height / 2f ; float dx = rx ; float dy = ry ; float left = cx - halfWidth ; float right = cx + halfWidth ; float top = cy - halfHeight ; float bottom = cy + halfHeight ; rx/ry cannot be greater than half of the width of the retoctangle (required by SVG spec) dx = Math.min(dx, width * 0.5f); dy = Math.min(dy, height * 0.5f); moveto(left + dx, top); if (dx < width * 0.5) lineto(right - rx, top); curveto(right - dx * ONE_MINUS_QUARTER, top, right, top + dy * ONE_MINUS_QUARTER, right, top + dy); if (dy < height * 0.5) lineto(right, bottom - dy); curveto(right, bottom - dy * ONE_MINUS_QUARTER, right - dx * ONE_MINUS_QUARTER, bottom, right - dx, bottom); if (dx < width * 0.5) lineto(left + dx, bottom); curveto(left + dx * ONE_MINUS_QUARTER, bottom, left, bottom - dy * ONE_MINUS_QUARTER, left, bottom - dy); if (dy < height * 0.5) lineto(left, top + dy); curveto(left, top + dy * ONE_MINUS_QUARTER, left + dx * ONE_MINUS_QUARTER, top, left + dx, top); close(); } 
public void ellipse ( float cx , float cy , float width , float height ) { Ellipse2D . Float e = new Ellipse2D . Float ( cx - width / 2 , cy - height / 2 , width , height ) ; extend ( e ) ; } 
public void line ( float x1 , float y1 , float x2 , float y2 ) { moveto ( x1 , y1 ) ; lineto ( x2 , y2 ) ; } 
public void text ( String text , String fontName , float fontSize , float lineHeight , Text . Align align , float x , float y ) { text ( text , fontName , fontSize , lineHeight , align , x , y , Float . MAX_VALUE , Float . MAX_VALUE ) ; } 
public void text ( String text , String fontName , float fontSize , float lineHeight , Text . Align align , float x , float y , float width ) { text ( text , fontName , fontSize , lineHeight , align , x , y , width , Float . MAX_VALUE ) ; } 
public void text ( String text , String fontName , float fontSize , float lineHeight , Text . Align align , float x , float y , float width , float height ) { Text = new Text ( text , x , y , width , height ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; extend ( . getPath ( ) ) ; } 
public static float lineLength ( float x0 , float y0 , float x1 , float y1 ) { x0 = Math . abs ( x0 - x1 ) ; x0 * = x0 ; y0 = Math . abs ( y0 - y1 ) ; y0 * = y0 ; return ( float ) Math . sqrt ( x0 + y0 ) ; } 
public static Point linePoint ( float , float x0 , float y0 , float x1 , float y1 ) { return new Point ( x0 + * ( x1 - x0 ) , 
public static float curveLength ( float x0 , float y0 , float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { return curveLength ( x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 , 20 ) ; } 
public static float curveLength ( float x0 , float y0 , float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , int ) { float length = 0 ; float xi = x0 ; float yi = y0 ; float ; float px , py ; float tmpX , tmpY ; for ( int i = 0 ; i < ; i + + ) { = ( i + 1 ) / ( float ) ; Point pt = curvePoint ( , x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 ) ; px = pt . getX ( ) ; py = pt . getY ( ) ; tmpX = Math . abs ( xi - px ) ; tmpX * = tmpX ; tmpY = Math . abs ( yi - py ) ; tmpY * = tmpY ; length + = Math . sqrt ( tmpX + tmpY ) ; xi = px ; yi = py ; } return length ; } 
public static Point curvePoint ( float , float x0 , float y0 , float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { float mint = 1 - ; float x01 = x0 * mint + x1 * ; float y01 = y0 * mint + y1 * ; float x12 = x1 * mint + x2 * ; float y12 = y1 * mint + y2 * ; float x23 = x2 * mint + x3 * ; float y23 = y2 * mint + y3 * ; float out_c1x = x01 * mint + x12 * ; float out_c1y = y01 * mint + y12 * ; float out_c2x = x12 * mint + x23 * ; float out_c2y = y12 * mint + y23 * ; float out_x = out_c1x * mint + out_c2x * ; float out_y = out_c1y * mint + out_c2y * ; return new Point ( out_x , out_y ) ; } 
public boolean contains ( float x , float y ) { return getGeneralPath ( ) . contains ( x , y ) ; } 
public void transform ( Transform ) { throw new UnsupportedOperationException ( ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { throw new UnsupportedOperationException ( ) ; } 
public void draw ( Graphics2D g ) { if ( fillColor ! = null & & fillColor . isVisible ( ) ) { g . setColor ( fillColor . getAwtColor ( ) ) ; g . fill ( getGeneralPath ( ) ) ; } if ( strokeWidth > 0 & & strokeColor ! = null & & strokeColor . isVisible ( ) ) { try { 
public BezierPath cloneAndClear ( ) { BezierPath cloned = new BezierPath ( ) ; cloned . fillColor = fillColor = = null ? null : fillColor . clone ( ) ; cloned . strokeColor = strokeColor = = null ? null : strokeColor . clone ( ) ; cloned . strokeWidth = strokeWidth ; return cloned ; } 
public void draw ( Graphics2D g ) { float halfWidth = width / 2 ; float halfHeight = height / 2 ; float left = - halfWidth ; float top = - halfHeight ; g . setColor ( background . getAwtColor ( ) ) ; g . fillRect ( ( int ) left , ( int ) top , ( int ) width , ( int ) height ) ; Rectangle clip = g.getClipBounds(); int clipwidth = clip != null && width > clip.width ? clip.width : (int) height; int clipheight = clip != null && height > clip.height ? clip.height : (int) width; g.setClip(clip != null ? clip.x : 0, clip != null ? clip.y : 0, clipwidth, clipheight); super.draw(g); } 
void setFillColor ( Color fillColor ) ; void setFill ( Color c ) ; void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( float strokeWidth ) ; } 
void setFill ( Color c ) ; void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( float strokeWidth ) ; } 
void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( float strokeWidth ) ; } 
void setStroke ( Color c ) ; void setStrokeWidth ( float strokeWidth ) ; } 
public void addPoint ( Point pt ) { ensureLength ( pointCount + 1 ) ; points [ pointCount + + ] = pt . clone ( ) ; } 
public void addPoint ( float x , float y ) { ensureLength ( pointCount + 1 ) ; points [ pointCount + + ] = new Point ( x , y ) ; } 
private void ensureLength ( int length ) { if ( points . length > = length ) return ; Copy everything over into new array. Point[] newPoints = new Point[length]; System.arraycopy(points, 0, newPoints, 0, points.length); points = newPoints; } 
public void flatten ( ) { throw new UnsupportedOperationException ( ) ; } 
public IGeometry flattened ( ) { throw new UnsupportedOperationException ( ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( pointCount < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, pointCount); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { Point pt = points[0]; Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); for (int i = 1; i < pointCount; i++) { pt = points[i]; if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points[i - 2]; ctrl2 = points[i - 1]; gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); We used up two extra points. i += 2; } } gp.closePath(); } public void transform(Transform t) { throw new UnsupportedOperationException(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
public void draw ( Graphics2D g ) { if ( pointCount < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, pointCount); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } 
void _extendPath ( GeneralPath gp ) { Point pt = points [ 0 ] ; Point ctrl1 , ctrl2 ; gp . moveTo ( pt . x , pt . y ) ; for ( int i = 1 ; i < pointCount ; i + + ) { pt = points [ i ] ; if ( pt . isLineTo ( ) ) { gp . lineTo ( pt . x , pt . y ) ; } else if ( pt . isCurveTo ( ) ) { ctrl1 = points [ i - 2 ] ; ctrl2 = points [ i - 1 ] ; gp . curveTo ( ctrl1 . x , ctrl1 . y , ctrl2 . x , ctrl2 . y , pt . x , pt . y ) ; We used up two extra points. i += 2; } } gp.closePath(); } 
public void resetContext ( boolean resetBackground ) { fillColor = new Color ( ) ; strokeColor = null ; strokeWidth = 1f ; if ( resetBackground ) canvas . setBackground ( new Color ( 1 , 1 , 1 ) ) ; path = null ; transform = new Transform ( ) ; transformStack = new ArrayList < Transform > ( ) ; fontName = " Helvetica " ; fontSize = 24 ; lineHeight = 1.2f ; align = Text . Align . CENTER ; } 
public void size ( float width , float height ) { canvas . setWidth ( width ) ; canvas . setHeight ( height ) ; } 
public BezierPath rect ( float x , float y , float width , float height ) { BezierPath p = new BezierPath ( ) ; p . rect ( x , y , width , height ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath rect ( Rect r , float roundness ) { BezierPath p = new BezierPath ( ) ; p . rect ( r , roundness ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath rect ( float x , float y , float width , float height , float roundness ) { BezierPath p = new BezierPath ( ) ; p . rect ( x , y , width , height , roundness ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath rect ( float x , float y , float width , float height , float rx , float ry ) { BezierPath p = new BezierPath ( ) ; p . rect ( x , y , width , height , rx , ry ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath oval ( float x , float y , float width , float height ) { TODO: Deprecation warning return ellipse(x, y, width, height); } 
public BezierPath ellipse ( float x , float y , float width , float height ) { BezierPath p = new BezierPath ( ) ; p . ellipse ( x , y , width , height ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public BezierPath line ( float x1 , float y1 , float x2 , float y2 ) { BezierPath p = new BezierPath ( ) ; p . line ( x1 , y1 , x2 , y2 ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public void beginPath ( float x , float y ) { beginPath ( ) ; moveto ( x , y ) ; } 
public void moveto ( float x , float y ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; path . moveto ( x , y ) ; } 
public void lineto ( float x , float y ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; path . lineto ( x , y ) ; } 
public void curveto ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; path . curveto ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } 
public BezierPath findPath ( List < Point > points , float curvature ) { throw new RuntimeException ( " Not implemented yet " ) ; } 
public Text text ( String text , float x , float y ) { return text ( text , x , y , 0 , 0 ) ; } 
public Text text ( String text , float x , float y , float width ) { return text ( text , x , y , width , 0 ) ; } 
public Text text ( String text , float x , float y , float width , float height ) { Text = new Text ( text , x , y , width , height ) ; inheritFromContext ( ) ; canvas . add ( ) ; return ; } 
public BezierPath textPath ( String text , float x , float y ) { return textPath ( text , x , y , 0 , 0 ) ; } 
public BezierPath textPath ( String text , float x , float y , float width ) { return textPath ( text , x , y , width , 0 ) ; } 
public BezierPath textPath ( String text , float x , float y , float width , float height ) { BezierPath p = new BezierPath ( ) ; p . text ( text , fontName , fontSize , lineHeight , align , x , y , width , height ) ; inheritFromContext ( p ) ; return p ; } 
public Rect textMetrics ( String text , float width ) { return textMetrics ( text , width , 0 ) ; } 
public Rect textMetrics ( String text , float width , float height ) { Text = new Text ( text , 0 , 0 , width , height ) ; inheritFromContext ( ) ; return . getMetrics ( ) ; } 
public Image image ( String path , float x , float y ) { Image img = new Image ( path ) ; img . setX ( x ) ; img . setY ( y ) ; inheritFromContext ( img ) ; canvas . add ( img ) ; return img ; } 
private void inheritFromContext ( BezierPath p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; } 
private void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) ; public void draw ( Graphics2D g ) ; Geometric queries public Rect getBounds(); Transformations public void transform(Transform t); Cloning public Grob clone();} 
public void draw ( Graphics2D g ) ; Geometric queries public Rect getBounds(); Transformations public void transform(Transform t); Cloning public Grob clone();} 
public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone();} 
public void transform ( Transform ) ; Cloning public Grob clone();} 
public void add ( IGeometry g ) { if ( items = = null ) { items = new IGeometry [ 1 ] ; items [ 0 ] = g ; } else { IGeometry [ ] newItems = new IGeometry [ items . length + 1 ] ; System . arraycopy ( items , 0 , newItems , 0 , items . length ) ; newItems [ items . length ] = g ; items = newItems ; } if ( g instanceof Path ) { currentPath = ( Path ) g ; 
public void extend ( Group g ) { IGeometry [ ] groupItems = g . getItems ( ) ; IGeometry [ ] newItems = new Path [ items . length + groupItems . length ] ; System . arraycopy ( items , 0 , newItems , 0 , items . length ) ; int i = items . length ; for ( IGeometry item : groupItems ) { newItems [ i + + ] = item . clone ( ) ; } items = newItems ; } 
public void addPoint ( Point pt ) { ensureCurrentPath ( ) ; currentPath . addPoint ( pt ) ; } 
public void addPoint ( float x , float y ) { ensureCurrentPath ( ) ; currentPath . addPoint ( x , y ) ; } 
private void ensureCurrentPath ( ) { if ( currentPath ! = null ) return ; currentPath = new Path ( ) ; add ( currentPath ) ; } 
public void transform ( Transform ) { for ( Grob grob : items ) { grob . transform ( ) ; 
public void draw ( Graphics2D g ) { for ( Grob grob : items ) { grob . draw ( g ) ; 
public int getPointCount ( ) ; public IGeometry flattened(); public IGeometry clone();} 
public Point [ ] getPoints ( ) ; public IGeometry flattened(); public IGeometry clone();} 
public void addPoint ( Point pt ) ; public IGeometry flattened(); public IGeometry clone();} 
public void addPoint ( float x , float y ) ; Geometric operations public IGeometry flattened(); public IGeometry clone();} 
public void flatten ( ) ; public IGeometry flattened ( ) ; public IGeometry clone ( ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { TODO: Implement } public void draw(Graphics2D g) { setupTransform(g); You can only position an image using an affine transformation. We use the transformation to translate the image to the specified position, and scale it according to the given width and height. Transform imageTrans = new Transform(); Move to the image position. Convert x, y, which are centered coordinates, to "real" coordinates. float factor = getScaleFactor(); float finalWidth = image.getWidth() * factor; float finalHeight = image.getHeight() * factor; imageTrans.translate(x - finalWidth / 2, y - finalHeight / 2); Scaling only applies to image that have their desired width and/or height set. However, getScaleFactor return 1 if height/width are not set, in effect negating the effect of the scale. imageTrans.scale(getScaleFactor()); float a = MathUtils.clamp(alpha); Composite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) a); Composite oldComposite = g.getComposite(); g.setComposite(composite); g.drawRenderedImage(image, imageTrans.getAffineTransform()); g.setComposite(oldComposite); restoreTransform(g); } public Image clone() { return new Image(this); } @Override public boolean equals(Object obj) { if (this == obj) return true; if (!(obj instanceof Image)) return false; Image other = (Image) obj; return this.x == other.x && this.y == other.y && this.desiredWidth == other.desiredWidth && this.desiredHeight == other.desiredHeight && this.alpha == other.alpha && this.image.equals(other.image) && super.equals(other); } @Override public String toString() { return "<Image (" + getWidth() + ", " + getHeight() + ")>"; }} 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; You can only position an image using an affine transformation. We use the transformation to translate the image to the specified position, and scale it according to the given width and height. Transform imageTrans = new Transform(); Move to the image position. Convert x, y, which are centered coordinates, to "real" coordinates. float factor = getScaleFactor(); float finalWidth = image.getWidth() * factor; float finalHeight = image.getHeight() * factor; imageTrans.translate(x - finalWidth / 2, y - finalHeight / 2); Scaling only applies to image that have their desired width and/or height set. However, getScaleFactor return 1 if height/width are not set, in effect negating the effect of the scale. imageTrans.scale(getScaleFactor()); float a = MathUtils.clamp(alpha); Composite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) a); Composite oldComposite = g.getComposite(); g.setComposite(composite); g.drawRenderedImage(image, imageTrans.getAffineTransform()); g.setComposite(oldComposite); restoreTransform(g); } 
public Grob get ( int index ) { try { return items . get ( index ) ; 
public void transform ( Transform ) { for ( Grob g : items ) { g . transform ( ) ; 
public static void render ( Canvas c , File file ) { I'm using fully qualified class names here so as not to polute the class' namespace. com.lowagie.text.Rectangle size = new com.lowagie.text.Rectangle(c.getWidth(), c.getHeight()); com.lowagie.text.Document document = new com.lowagie.text.Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } com.lowagie.text.pdf.PdfWriter writer; try { writer = com.lowagie.text.pdf.PdfWriter.getInstance(document, fos); } catch (com.lowagie.text.DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); com.lowagie.text.pdf.PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = contentByte.createGraphics(size.getWidth(), size.getHeight(), fontMapper); graphics.translate(c.getWidth() / 2, c.getHeight() / 2); c.draw(graphics); graphics.dispose(); document.close(); 
public void rect ( float x , float y , float width , float height ) { float w2 = width / 2 ; float h2 = height / 2 ; addPoint ( x - w2 , y - h2 ) ; addPoint ( x + w2 , y - h2 ) ; addPoint ( x + w2 , y + h2 ) ; addPoint ( x - w2 , y + h2 ) ; } 
public void ellipse ( float x , float y , float width , float height ) { Ellipse2D . Float e = new Ellipse2D . Float ( x , y , width , height ) ; PathIterator iter = e . getPathIterator ( null ) ; float [ ] coords = new float [ 6 ] ; while ( ! iter . isDone ( ) ) { int type = iter . currentSegment ( coords ) ; 
public void add ( Contour c ) { if ( contours = = null ) { contours = new Contour [ 1 ] ; contours [ 0 ] = c ; } else { Contour [ ] newContours = new Contour [ contours . length + 1 ] ; System . arraycopy ( contours , 0 , newContours , 0 , contours . length ) ; newContours [ contours . length ] = c ; contours = newContours ; } currentContour = c ; } 
public void clear ( ) { contours = null ; currentContour = null ; } 
public void addPoint ( Point pt ) { ensureCurrentContour ( ) ; currentContour . addPoint ( pt ) ; } 
public void addPoint ( float x , float y ) { ensureCurrentContour ( ) ; currentContour . addPoint ( x , y ) ; } 
private void ensureCurrentContour ( ) { if ( currentContour ! = null ) return ; currentContour = new Contour ( ) ; add ( currentContour ) ; } 
public void transform ( Transform ) { . map ( getPoints ( ) ) ; } 
public void flatten ( ) { throw new UnsupportedOperationException ( " Not implemented. " ) ; } 
public Path flattened ( ) { throw new UnsupportedOperationException ( " Not implemented. " ) ; } 
public void draw ( Graphics2D g ) { If we can't fill or stroke the path, there's nothing to draw. if (fillColor == null && strokeColor == null) return; int pointCount = getPointCount(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, pointCount); for (Contour c : contours) { c._extendPath(gp); } if (fillColor != null) { g.setColor(fillColor.getAwtColor()); g.fill(gp); } if (strokeWidth > 0 && strokeColor != null) { try { 
public void inheritFromContext ( GraphicsContext ctx ) { } public Path clone ( ) { return new Path ( this ) ; } } 
public boolean isCurveTo ( ) { return type = = CURVE_TO ; } 
public void move ( float x , float y ) { this . x + = x ; this . y + = y ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Point ) ) return false ; Point p = ( Point ) o ; return x = = p . x & & y = = p . y & & type = = p . type ; } 
public static Rect centeredRect ( float cx , float cy , float width , float height ) { return new Rect ( cx - width / 2 , cy - height / 2 , width , height ) ; } 
public void draw ( Graphics2D g ) { if ( fillColor = = null ) return ; saveTransform ( g ) ; if ( text = = null | | text . length ( ) = = 0 ) return ; TextLayoutIterator iterator = new TextLayoutIterator ( ) ; while ( iterator . hasNext ( ) ) { TextLayout layout = iterator . next ( ) ; layout . draw ( g , ( float ) baseLineX + iterator . getX ( ) , ( float ) baseLineY + iterator . getY ( ) ) ; } restoreTransform ( g ) ; } 
public static Transform translated ( float tx , float ty ) { Transform = new Transform ( ) ; . translate ( tx , ty ) ; return ; } 
public Rect map ( Rect r ) { TODO: The size conversion might be incorrect. (using deltaTransform) In that case, make topLeft and bottomRight points. Point2D origin = new Point2D.Double(r.getX(), r.getY()); Point2D size = new Point2D.Double(r.getWidth(), r.getHeight()); Point2D transformedOrigin = new Point2D.Double(); Point2D transformedSize = new Point2D.Double(); affineTransform.transform(origin, transformedOrigin); affineTransform.deltaTransform(size, transformedSize); return new Rect((float) transformedOrigin.getX(), (float) transformedOrigin.getY(), (float) transformedSize.getX(), (float) transformedSize.getY()); } 
public void map ( Point [ ] points ) { float [ ] coords = new float [ points . length * 2 ] ; for ( int i = 0 ; i < points . length ; i + + ) { coords [ i * 2 ] = points [ i ] . x ; coords [ i * 2 + 1 ] = points [ i ] . y ; } affineTransform . transform ( coords , 0 , coords , 0 , points . length ) ; for ( int i = 0 ; i < points . length ; i + + ) { points [ i ] . x = coords [ i * 2 ] ; 
public Rect convertBoundsToFrame ( Rect bounds ) { AffineTransform = fullTransform ( bounds ) ; Point2D transformedOrigin = new Point2D . Double ( ) ; Point2D transformedSize = new Point2D . Double ( ) ; . transform ( new Point2D . Double ( bounds . getX ( ) , bounds . getY ( ) ) , transformedOrigin ) ; . deltaTransform ( new Point2D . Double ( bounds . getWidth ( ) , bounds . getHeight ( ) ) , transformedSize ) ; return new Rect ( ( float ) transformedOrigin . getX ( ) , ( float ) transformedOrigin . getY ( ) , ( float ) transformedSize . getX ( ) , ( float ) transformedSize . getY ( ) ) ; } 
public void mouseClicked ( Point pt ) { } public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, double x, double y) { BezierPath p = new BezierPath(); p.setFillColor(HANDLE_COLOR); p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(BezierPath p, double x, double y) { p.rect((float) x, (float) y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
protected void drawDot ( GraphicsContext ctx , double x , double y ) { BezierPath p = new BezierPath ( ) ; p . setFillColor ( HANDLE_COLOR ) ; p . rect ( ( float ) x , ( float ) y , HANDLE_SIZE , HANDLE_SIZE ) ; ctx . draw ( p ) ; } 
protected void drawDot ( BezierPath p , double x , double y ) { p . rect ( ( float ) x , ( float ) y , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void draw ( GraphicsContext ctx ) { float cx = node . asFloat ( xName ) ; float cy = node . asFloat ( yName ) ; float width = node . asFloat ( widthName ) ; float height = node . asFloat ( heightName ) ; float left = cx - width / 2 ; float right = cx + width / 2 ; float top = cy - height / 2 ; float bottom = cy + height / 2 ; BezierPath cornerPath = new BezierPath ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0 ) ; drawDot ( cornerPath , left , top ) ; drawDot ( cornerPath , right , top ) ; drawDot ( cornerPath , right , bottom ) ; drawDot ( cornerPath , left , bottom ) ; drawDot ( cornerPath , cx , cy ) ; ctx . getCanvas ( ) . add ( cornerPath ) ; BezierPath strokePath = new BezierPath ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . rect ( cx , cy , width , height ) ; ctx . draw ( strokePath ) ; } 
public void mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; ocx = node . asFloat ( xName ) ; ocy = node . asFloat ( yName ) ; owidth = node . asFloat ( widthName ) ; oheight = node . asFloat ( heightName ) ; float left = ocx - owidth / 2 ; float right = ocx + owidth / 2 ; float top = ocy - oheight / 2 ; float bottom = ocy + oheight / 2 ; Rect topLeft = createHitRectangle ( left , top ) ; Rect topRight = createHitRectangle ( right , top ) ; Rect bottomLeft = createHitRectangle ( left , bottom ) ; Rect bottomRight = createHitRectangle ( right , bottom ) ; Rect center = new Rect ( left , top , owidth , oheight ) ; if ( topLeft . contains ( pt ) ) { dragState = DragState . TOP_LEFT ; 
public void mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return ; float x = pt . getX ( ) ; float y = pt . getY ( ) ; float dx = x - px ; float dy = y - py ; The delta value is multiplied by 2 to create the float effect of moving the top left corner down and the bottom left corner up (in the case of the top left handle). if (dx == 0 && dy == 0) return; switch (dragState) { case TOP_LEFT: 
public static float clamp ( float v ) { return 0 > v ? 0 : 1 < v ? 1 : v ; } 
public static float clamp ( float v , float min , float max ) { return min > v ? min : max < v ? max : v ; } 
public void testCloning ( ) { Color backgroundColor = new Color ( 0.1 , 0.2 , 0.3 ) ; Canvas c = new Canvas ( 200 , 300 ) ; c . setBackground ( backgroundColor ) ; Canvas c2 = c . clone ( ) ; assertEquals ( 200 f , c2 . getWidth ( ) ) ; assertEquals ( 300 f , c2 . getHeight ( ) ) ; assertEquals ( backgroundColor , c . getBackground ( ) ) ; } 
public void testEmptyPath ( ) { Path p = new Path ( ) ; assertEquals ( 0 , p . getPoints ( ) . length ) ; } 
public void testMakeEllipse ( ) { Path p = new Path ( ) ; p . ellipse ( 10 , 20 , 30 , 40 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 40 ) , p . getBounds ( ) ) ; } 
public void testColors ( ) { Path p1 = new Path ( ) ; Path p2 = new Path ( ) ; p1 . rect ( 0 , 0 , 100 , 100 ) ; p2 . rect ( 150 , 150 , 100 , 100 ) ; Group g = new Group ( ) ; g . add ( p1 ) ; g . add ( p2 ) ; assertEquals ( 2 , g . size ( ) ) ; Each path has 4 points. assertEquals(8, g.getPointCount()); Color red = new Color(1, 0, 0); g.setFill(red); assertEquals(red, p1.getFillColor()); assertEquals(red, p2.getFillColor()); } 
public void testCustomAttributes ( ) { Add a velocity to each point of the path. Path p = new Path(); p.rect(0, 0, 100, 100); assertEquals(4, p.getPointCount()); } 
public void testTransform ( ) { Path p = new Path ( ) ; p . rect ( 10 , 20 , 30 , 40 ) ; p . transform ( Transform . translated ( 5 , 7 ) ) ; assertEquals ( new Rect ( 15 , 27 , 30 , 40 ) , p . getBounds ( ) ) ; } 
public void testInheritFromContext ( ) { GraphicsContext ctx = new GraphicsContext ( ) ; Color c = new Color ( ) ; assertEquals ( c , ctx . getFillColor ( ) ) ; ctx . rect ( 0 , 0 , 100 , 100 ) ; BezierPath p = ( BezierPath ) ctx . getCanvas ( ) . getItems ( ) . get ( 0 ) ; assertEquals ( c , p . getFillColor ( ) ) ; Color red = new Color ( 1 , 0 , 0 ) ; ctx . setFillColor ( red ) ; ctx . setAlign ( Text . Align . RIGHT ) ; Text = ctx . text ( " hello " , 20 , 20 ) ; assertEquals ( red , . getFillColor ( ) ) ; assertEquals ( Text . Align . RIGHT , . getAlign ( ) ) ; } 
public void testTransform ( ) { TestGrob tg = new TestGrob ( 1 , 2 , 3 , 4 ) ; assertEquals ( new Rect ( 1 , 2 , 3 , 4 ) , tg . getBounds ( ) ) ; tg . translate ( 200 , 300 ) ; assertEquals ( new Rect ( 201 , 302 , 3 , 4 ) , tg . getBounds ( ) ) ; 
public void testBounds ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Group g1 = new Group ( ) ; g1 . add ( r1 ) ; assertEquals ( new Rect ( 10 , 20 , 30 , 40 ) , g1 . getBounds ( ) ) ; } 
public void testTransformedBounds ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Transform = new Transform ( ) ; . translate ( 200 , 300 ) ; r1 . transform ( ) ; Group g = new Group ( ) ; g . add ( r1 ) ; assertEquals ( new Rect ( 210 , 320 , 30 , 40 ) , g . getBounds ( ) ) ; } 
public void testTransformedElements ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Path r2 = new Path ( ) ; r2 . rect ( 10 , 120 , 30 , 40 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; g . add ( r2 ) ; Rect rect1 = new Rect ( 10 , 20 , 30 , 40 ) ; Rect rect2 = new Rect ( 10 , 120 , 30 , 40 ) ; assertEquals ( rect1 . united ( rect2 ) , g . getBounds ( ) ) ; } 
public void testAdd ( ) { Path p = new Path ( ) ; p . rect ( 10 , 20 , 30 , 40 ) ; Group g = new Group ( ) ; g . add ( p ) ; p . transform ( Transform . translated ( 5 , 7 ) ) ; Since the path is in the group and not cloned, the bounds of the group will be those of the translated path. assertEquals(new Rect(15, 27, 30, 40), g.getBounds()); } 
public void testGetPaths ( ) { Group root = new Group ( ) ; Group parent1 = new Group ( ) ; Group parent2 = new Group ( ) ; root . add ( parent1 ) ; root . add ( parent2 ) ; assertEquals ( 0 , root . getPaths ( ) . length ) ; Path p1 = new Path ( ) ; parent1 . add ( p1 ) ; assertEquals ( 1 , root . getPaths ( ) . length ) ; assertSame ( p1 , root . getPaths ( ) [ 0 ] ) ; Path p2 = new Path ( ) ; parent2 . add ( p2 ) ; assertEquals ( 2 , root . getPaths ( ) . length ) ; assertSame ( p1 , root . getPaths ( ) [ 0 ] ) ; assertSame ( p2 , root . getPaths ( ) [ 1 ] ) ; } 
public void testDowncasting ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; Port ptGrob = . addPort ( " grob " , Grob . class ) ; Port ptCanvas = . addPort ( " canvas " , Canvas . class ) ; Port ptGroup = . addPort ( " group " , OldGroup . class ) ; Port ptImage = . addPort ( " image " , Image . class ) ; Port ptPath = . addPort ( " path " , BezierPath . class ) ; Port ptText = . addPort ( " text " , Text . class ) ; Canvas canvas = new Canvas ( ) ; OldGroup group = new OldGroup ( ) ; Image image = new Image ( ) ; BezierPath path = new BezierPath ( ) ; Text text = new Text ( " " , 0 , 0 ) ; assertValidValue ( ptGrob , canvas ) ; assertValidValue ( ptGrob , group ) ; assertValidValue ( ptGrob , image ) ; assertValidValue ( ptGrob , path ) ; assertValidValue ( ptGrob , text ) ; assertValidValue ( ptCanvas , canvas ) ; assertInvalidValue ( ptCanvas , group ) ; assertInvalidValue ( ptCanvas , image ) ; assertInvalidValue ( ptCanvas , path ) ; assertInvalidValue ( ptCanvas , text ) ; assertValidValue ( ptGroup , canvas ) ; assertValidValue ( ptGroup , group ) ; assertInvalidValue ( ptGroup , image ) ; assertInvalidValue ( ptGroup , path ) ; assertInvalidValue ( ptGroup , text ) ; assertInvalidValue ( ptImage , canvas ) ; assertInvalidValue ( ptImage , group ) ; assertValidValue ( ptImage , image ) ; assertInvalidValue ( ptImage , path ) ; assertInvalidValue ( ptImage , text ) ; assertInvalidValue ( ptPath , canvas ) ; assertInvalidValue ( ptPath , group ) ; assertInvalidValue ( ptPath , image ) ; assertValidValue ( ptPath , path ) ; assertInvalidValue ( ptPath , text ) ; assertInvalidValue ( ptText , canvas ) ; assertInvalidValue ( ptText , group ) ; assertInvalidValue ( ptText , image ) ; assertInvalidValue ( ptText , path ) ; assertValidValue ( ptText , text ) ; 
public void addPoint ( Point pt ) { points . add ( pt . clone ( ) ) ; } 
public void addPoint ( float x , float y ) { points . add ( new Point ( x , y ) ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( pointCount < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, pointCount); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); We used up two extra points. i += 2; } } gp.closePath(); } public void transform(Transform t) { throw new UnsupportedOperationException(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
void _extendPath ( GeneralPath gp ) { Point pt = points . get ( 0 ) ; Point ctrl1 , ctrl2 ; gp . moveTo ( pt . x , pt . y ) ; for ( int i = 1 ; i < pointCount ; i + + ) { pt = points . get ( i ) ; if ( pt . isLineTo ( ) ) { gp . lineTo ( pt . x , pt . y ) ; } else if ( pt . isCurveTo ( ) ) { ctrl1 = points . get ( i - 2 ) ; ctrl2 = points . get ( i - 1 ) ; gp . curveTo ( ctrl1 . x , ctrl1 . y , ctrl2 . x , ctrl2 . y , pt . x , pt . y ) ; We used up two extra points. i += 2; } } gp.closePath(); } 
public void add ( IGeometry g ) { items . add ( g ) ; if ( g instanceof Path ) { currentPath = ( Path ) g ; 
public void clear ( ) { items . clear ( ) ; currentPath = null ; } 
public void extend ( Group g ) { for ( IGeometry item : g . items ) { items . add ( item . clone ( ) ) ; 
public int getPointCount ( ) ; public IGeometry flattened(); public IGeometry clone();} 
public List < Point > getPoints ( ) ; public IGeometry flattened(); public IGeometry clone();} 
public void add ( Contour c ) { contours . add ( c ) ; currentContour = c ; } 
public void clear ( ) { contours . clear ( ) ; currentContour = null ; } 
public void map ( java . util . List < Point > points ) { float [ ] coords = new float [ points . size ( ) * 2 ] ; int i = 0 ; for ( Point pt : points ) { coords [ i + + ] = pt . x ; coords [ i + + ] = pt . y ; } affineTransform . transform ( coords , 0 , coords , 0 , points . size ( ) ) ; i = 0 ; for ( Point pt : points ) { pt . x = coords [ i + + ] ; 
public void testEmptyPath ( ) { Path p = new Path ( ) ; assertEquals ( 0 , p . getPoints ( ) . size ( ) ) ; } 
public void text ( String text , String fontName , float fontSize , float lineHeight , Text . Align align , float x , float y , float width , float height ) { Text = new Text ( text , x , y , width , height ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; TODO extend(t.getPath()); 
public float updateSegmentLengths ( ) { java . util . List < Point > points = getPoints ( ) ; segmentLengths = new ArrayList < Float > ( ) ; float totalLength = 0 ; We cannot form a line or curve with the first point. Since the algorithm looks back at previous points, we start looking from the first useful point, which is the second (index of 1). for (int pi = 1; pi < points.size(); pi++) { Point pt = points.get(pi); if (pt.isLineTo()) { Point pt0 = points.get(pi - 1); float length = Path.lineLength(pt0.x, pt0.y, pt.x, pt.y); segmentLengths.add(length); totalLength += length; } else if (pt.isCurveTo()) { Point pt0 = points.get(pi - 3); Point c1 = points.get(pi - 2); Point c2 = points.get(pi - 1); float length = Path.curveLength(pt0.x, pt0.y, c1.x, c1.y, c2.x, c2.y, pt.x, pt.y, SEGMENT_ACCURACY); segmentLengths.add(length); totalLength += length; } } this.length = totalLength; return totalLength; } 
public Point pointAt ( float ) { if ( segmentLengths = = null ) updateSegmentLengths ( ) ; Check if there is a path. if (length <= 0) throw new NodeBoxError("The path is empty."); Since t is relative, convert it to the absolute length. float absT = t * length; The resT is what remains of t after we traversed all segments. float resT = t; Find the segment that contains t. int segnum = -1; for (Float seglength : segmentLengths) { segnum++; if (absT <= seglength || segnum == segmentLengths.size()-1) break; absT -= seglength; resT -= seglength / length; } resT /= (segmentLengths.get(segnum) / length); Find the point index for the segment. int pi = pointIndexForSegment(segnum + 1); Point pt1 = points.get(pi); if (pt1.isLineTo()) { Point pt0 = points.get(pi - 1); 
private int pointIndexForSegment ( int segnum ) { int pointIndex = 0 ; for ( Point pt : points ) { if ( pt . isCurveTo ( ) | | pt . isLineTo ( ) ) { if ( segnum = = 0 ) break ; segnum - - ; } pointIndex + + ; } return pointIndex < points . size ( ) ? pointIndex : points . size ( ) - 1 ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); int pointCount = getPointCount(); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); We used up two extra points. i += 2; } } gp.closePath(); } public void transform(Transform t) { throw new UnsupportedOperationException(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } 
 void _extendPath ( GeneralPath gp ) { Point pt = points . get ( 0 ) ; Point ctrl1 , ctrl2 ; gp . moveTo ( pt . x , pt . y ) ; int pointCount = getPointCount ( ) ; for ( int i = 1 ; i < pointCount ; i + + ) { pt = points . get ( i ) ; if ( pt . isLineTo ( ) ) { gp . lineTo ( pt . x , pt . y ) ; } else if ( pt . isCurveTo ( ) ) { ctrl1 = points . get ( i - 2 ) ; ctrl2 = points . get ( i - 1 ) ; gp . curveTo ( ctrl1 . x , ctrl1 . y , ctrl2 . x , ctrl2 . y , pt . x , pt . y ) ; We used up two extra points. i += 2; } } gp.closePath(); } 
public void moveto ( float x , float y ) { Close the current path. currentContour = null; addPoint(x, y); } 
public void lineto ( float x , float y ) { if ( currentContour = = null ) throw new RuntimeException ( " Lineto without moveto first. " ) ; addPoint ( x , y ) ; } 
public void curveto ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { if ( currentContour = = null ) throw new RuntimeException ( " Curveto without moveto first. " ) ; addPoint ( new Point ( x1 , y1 , Point . CURVE_DATA ) ) ; addPoint ( new Point ( x2 , y2 , Point . CURVE_DATA ) ) ; addPoint ( new Point ( x3 , y3 , Point . CURVE_TO ) ) ; } 
public void close ( ) { currentContour = null ; pathDirty = true ; lengthDirty = true ; } 
public void addPoint ( Point pt ) { ensureCurrentContour ( ) ; currentContour . addPoint ( pt ) ; pathDirty = true ; lengthDirty = true ; } 
public void addPoint ( float x , float y ) { ensureCurrentContour ( ) ; currentContour . addPoint ( x , y ) ; pathDirty = true ; lengthDirty = true ; } 
private void ensureCurrentContour ( ) { if ( currentContour ! = null ) return ; currentContour = new Contour ( ) ; add ( currentContour ) ; pathDirty = true ; lengthDirty = true ; } 
public void rect ( float cx , float cy , float width , float height ) { float w2 = width / 2 ; float h2 = height / 2 ; addPoint ( cx - w2 , cy - h2 ) ; addPoint ( cx + w2 , cy - h2 ) ; addPoint ( cx + w2 , cy + h2 ) ; addPoint ( cx - w2 , cy + h2 ) ; close ( ) ; } 
public void extend ( Path p ) { for ( Contour c : p . contours ) { contours . add ( c . clone ( ) ) ; 
public void extend ( java . util . List < Point > points ) { for ( Point pt : points ) { addPoint ( pt . clone ( ) ) ; 
public void extend ( Point [ ] points ) { for ( Point pt : points ) { addPoint ( pt . clone ( ) ) ; 
private void updateContourLengths ( ) { contourLengths = new ArrayList < Float > ( contours . size ( ) ) ; pathLength = 0 ; float length ; for ( Contour c : contours ) { length = c . getLength ( ) ; contourLengths . add ( length ) ; pathLength + = length ; } lengthDirty = false ; } 
public Contour contourAt ( float ) { Since t is relative, convert it to the absolute length. float absT = t * getLength(); Find the contour that contains t. float cLength; for (Contour c : contours) { cLength = c.getLength(); if (absT <= cLength) return c; absT -= cLength; } return null; } 
public Point pointAt ( float ) { float length = getLength ( ) ; Since t is relative, convert it to the absolute length. float absT = t * length; The resT is what remains of t after we traversed all segments. float resT = t; Find the contour that contains t. float cLength; Contour currentContour = null; for (Contour c : contours) { currentContour = c; cLength = c.getLength(); if (absT <= cLength) break; absT -= cLength; resT -= cLength / length; } if (currentContour == null) return new Point(); resT /= (currentContour.getLength() / length); return currentContour.pointAt(resT); } 
public Point [ ] resample ( ) { return resample ( 100 , true ) ; } 
public Point [ ] resample ( boolean closed ) { return resample ( 100 , closed ) ; } 
public Point [ ] resample ( int amount ) { return resample ( amount , true ) ; } 
public Point [ ] resample ( int amount , boolean closed ) { Point [ ] points = new Point [ amount ] ; float delta = 1 ; if ( closed ) { if ( amount > 0 ) { delta = 1f / amount ; } } else { The delta value is divided by amount - 1, because we also want the last point (t=1.0) If I wouldn't use amount - 1, I fall one point short of the end. E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0, if amount = 2, I want point at t 0.0 and t 1.0 if (amount > 2) { delta = 1f / (amount - 1f); } } for (int i = 0; i < amount; i++) { points[i] = pointAt(delta * i); } return points; } 
public void draw ( Graphics2D g ) { If we can't fill or stroke the path, there's nothing to draw. if (fillColor == null && strokeColor == null) return; GeneralPath gp = getGeneralPath(); if (fillColor != null) { g.setColor(fillColor.getAwtColor()); g.fill(gp); } if (strokeWidth > 0 && strokeColor != null) { try { 
public void testPointAt ( ) { Contour c1 = new Contour ( ) ; c1 . addPoint ( 0 , 0 ) ; c1 . addPoint ( 100 , 0 ) ; assertEquals ( new Point ( 0 , 0 ) , c1 . pointAt ( 0 ) ) ; assertEquals ( new Point ( 50 f , 0 ) , c1 . pointAt ( 0.5f ) ) ; assertEquals ( new Point ( 100 , 0 ) , c1 . pointAt ( 1f ) ) ; assertEquals ( new Point ( - 50 , 0 ) , c1 . pointAt ( - 0.5f ) ) ; assertEquals ( new Point ( 150 , 0 ) , c1 . pointAt ( 1.5f ) ) ; Contour c2 = new Contour ( ) ; c2 . addPoint ( new Point ( 0 , 0 , Point . LINE_TO ) ) ; c2 . addPoint ( new Point ( 0 , 0 , Point . CURVE_DATA ) ) ; c2 . addPoint ( new Point ( 100 , 0 , Point . CURVE_DATA ) ) ; c2 . addPoint ( new Point ( 100 , 0 , Point . CURVE_TO ) ) ; assertEquals ( new Point ( 0 , 0 ) , c2 . pointAt ( 0 ) ) ; assertEquals ( new Point ( 50 f , 0 ) , c2 . pointAt ( 0.5f ) ) ; assertEquals ( new Point ( 100 , 0 ) , c2 . pointAt ( 1f ) ) ; assertEquals ( new Point ( - 50 , 0 ) , c2 . pointAt ( - 0.5f ) ) ; assertEquals ( new Point ( 150 , 0 ) , c2 . pointAt ( 1.5f ) ) ; } 
public void testPointAtMultiple ( ) { Contour c1 = new Contour ( ) ; c1 . addPoint ( 0 , 0 ) ; c1 . addPoint ( 50 , 0 ) ; c1 . addPoint ( 100 , 0 ) ; assertEquals ( new Point ( - 50 , 0 ) , c1 . pointAt ( - 0.5f ) ) ; assertEquals ( new Point ( 0 , 0 ) , c1 . pointAt ( 0 ) ) ; assertEquals ( new Point ( 25 , 0 ) , c1 . pointAt ( 0.25f ) ) ; assertEquals ( new Point ( 50 , 0 ) , c1 . pointAt ( 0.5f ) ) ; assertEquals ( new Point ( 60 , 0 ) , c1 . pointAt ( 0.6f ) ) ; assertEquals ( new Point ( 100 , 0 ) , c1 . pointAt ( 1f ) ) ; assertEquals ( new Point ( 150 , 0 ) , c1 . pointAt ( 1.5f ) ) ; } 
public void testLength ( ) { Contour c = new Contour ( ) ; c . addPoint ( 0 , 0 ) ; c . addPoint ( 100 , 0 ) ; assertEquals ( 100 f , c . getLength ( ) ) ; } 
public void testBounds ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Group g1 = new Group ( ) ; g1 . add ( r1 ) ; assertEquals ( Rect . centeredRect ( 10 , 20 , 30 , 40 ) , g1 . getBounds ( ) ) ; } 
public void testTransformedBounds ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Transform = new Transform ( ) ; . translate ( 200 , 300 ) ; r1 . transform ( ) ; Group g = new Group ( ) ; g . add ( r1 ) ; assertEquals ( Rect . centeredRect ( 210 , 320 , 30 , 40 ) , g . getBounds ( ) ) ; } 
public void testTransformedElements ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Path r2 = new Path ( ) ; r2 . rect ( 10 , 120 , 30 , 40 ) ; Group g = new Group ( ) ; g . add ( r1 ) ; g . add ( r2 ) ; Rect rect1 = Rect . centeredRect ( 10 , 20 , 30 , 40 ) ; Rect rect2 = Rect . centeredRect ( 10 , 120 , 30 , 40 ) ; assertEquals ( rect1 . united ( rect2 ) , g . getBounds ( ) ) ; } 
public void testAdd ( ) { Path p = new Path ( ) ; p . rect ( 10 , 20 , 30 , 40 ) ; Group g = new Group ( ) ; g . add ( p ) ; p . transform ( Transform . translated ( 5 , 7 ) ) ; Since the path is in the group and not cloned, the bounds of the group will be those of the translated path. assertEquals(Rect.centeredRect(15, 27, 30, 40), g.getBounds()); } 
public void testMakeEllipse ( ) { Path p = new Path ( ) ; p . ellipse ( 10 , 20 , 30 , 40 ) ; assertEquals ( Rect . centeredRect ( 10 , 20 , 30 , 40 ) , p . getBounds ( ) ) ; } 
public void testTransform ( ) { Path p = new Path ( ) ; p . rect ( 10 , 20 , 30 , 40 ) ; p . transform ( Transform . translated ( 5 , 7 ) ) ; assertEquals ( Rect . centeredRect ( 15 , 27 , 30 , 40 ) , p . getBounds ( ) ) ; } 
public void testLength ( ) { Path p = new Path ( ) ; p . line ( 0 , 0 , 50 , 0 ) ; p . line ( 50 , 0 , 100 , 0 ) ; assertEquals ( 100 f , p . getLength ( ) ) ; } 
public void testPointAt ( ) { Path p = new Path ( ) ; p . line ( 0 , 0 , 50 , 0 ) ; p . line ( 50 , 0 , 100 , 0 ) ; assertEquals ( new Point ( 0 , 0 ) , p . pointAt ( 0f ) ) ; assertEquals ( new Point ( 10 , 0 ) , p . pointAt ( 0.1f ) ) ; assertEquals ( new Point ( 25 , 0 ) , p . pointAt ( 0.25f ) ) ; assertEquals ( new Point ( 40 , 0 ) , p . pointAt ( 0.4f ) ) ; assertEquals ( new Point ( 50 , 0 ) , p . pointAt ( 0.5f ) ) ; assertEquals ( new Point ( 75 , 0 ) , p . pointAt ( 0.75f ) ) ; assertEquals ( new Point ( 80 , 0 ) , p . pointAt ( 0.8f ) ) ; assertEquals ( new Point ( 100 , 0 ) , p . pointAt ( 1f ) ) ; } 
public Point pointAt ( float ) { if ( segmentLengths = = null ) updateSegmentLengths ( ) ; Check if there is a path. if (length <= 0) throw new NodeBoxError("The path is empty."); Since t is relative, convert it to the absolute length. float absT = t * length; The resT is what remains of t after we traversed all segments. float resT = t; Find the segment that contains t. int segnum = -1; for (Float seglength : segmentLengths) { segnum++; if (absT <= seglength || segnum == segmentLengths.size() - 1) break; absT -= seglength; resT -= seglength / length; } resT /= (segmentLengths.get(segnum) / length); Find the point index for the segment. int pi = pointIndexForSegment(segnum + 1); Point pt1 = points.get(pi); if (pt1.isLineTo()) { Point pt0 = points.get(pi - 1); 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); int pointCount = getPointCount(); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); We used up two extra points. i += 2; } } if (closed) gp.closePath(); } public void transform(Transform t) { t.map(getPoints()); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
 void _extendPath ( GeneralPath gp ) { Point pt = points . get ( 0 ) ; Point ctrl1 , ctrl2 ; gp . moveTo ( pt . x , pt . y ) ; int pointCount = getPointCount ( ) ; for ( int i = 1 ; i < pointCount ; i + + ) { pt = points . get ( i ) ; if ( pt . isLineTo ( ) ) { gp . lineTo ( pt . x , pt . y ) ; } else if ( pt . isCurveTo ( ) ) { ctrl1 = points . get ( i - 2 ) ; ctrl2 = points . get ( i - 1 ) ; gp . curveTo ( ctrl1 . x , ctrl1 . y , ctrl2 . x , ctrl2 . y , pt . x , pt . y ) ; We used up two extra points. i += 2; } } if (closed) gp.closePath(); 
public void close ( ) { if ( currentContour ! = null ) currentContour . close ( ) ; currentContour = null ; pathDirty = true ; lengthDirty = true ; } 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.resetContext(); context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("g", context); interpreter.set("Path", nodebox.graphics.Path.class); interpreter.set("Canvas", nodebox.graphics.Canvas.class); interpreter.set("Color", nodebox.graphics.Color.class); interpreter.set("GraphicsContext", nodebox.graphics.GraphicsContext.class); interpreter.set("Grob", nodebox.graphics.Grob.class); interpreter.set("Path", Path.class); interpreter.set("Group", Group.class); interpreter.set("Image", nodebox.graphics.Image.class); interpreter.set("NodeBoxError", nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", nodebox.graphics.PathElement.class); interpreter.set("Point", nodebox.graphics.Point.class); interpreter.set("Rect", nodebox.graphics.Rect.class); interpreter.set("Text", nodebox.graphics.Text.class); interpreter.set("Transform", nodebox.graphics.Transform.class); interpreter.set("LEFT", Text.Align.LEFT); interpreter.set("RIGHT", Text.Align.RIGHT); interpreter.set("CENTER", Text.Align.CENTER); interpreter.set("JUSTIFY", Text.Align.JUSTIFY); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
public void addPoint ( Point pt ) { points . add ( pt . clone ( ) ) ; markDirty ( ) ; } 
public void addPoint ( float x , float y ) { points . add ( new Point ( x , y ) ) ; markDirty ( ) ; } 
public void close ( ) { this . closed = true ; markDirty ( ) ; } 
public float updateSegmentLengths ( ) { java . util . List < Point > points = getPoints ( ) ; segmentLengths = new ArrayList < Float > ( ) ; float totalLength = 0 ; We cannot form a line or curve with the first point. Since the algorithm looks back at previous points, we start looking from the first useful point, which is the second (index of 1). for (int pi = 1; pi < points.size(); pi++) { Point pt = points.get(pi); if (pt.isLineTo()) { Point pt0 = points.get(pi - 1); float length = Path.lineLength(pt0.x, pt0.y, pt.x, pt.y); segmentLengths.add(length); totalLength += length; } else if (pt.isCurveTo()) { Point pt0 = points.get(pi - 3); Point c1 = points.get(pi - 2); Point c2 = points.get(pi - 1); float length = Path.curveLength(pt0.x, pt0.y, c1.x, c1.y, c2.x, c2.y, pt.x, pt.y, SEGMENT_ACCURACY); segmentLengths.add(length); totalLength += length; } } If the path is closed, add the closing segment. if (closed && !points.isEmpty()) { Point pt0 = points.get(points.size() - 1); Point pt1 = points.get(0); float length = Path.lineLength(pt0.x, pt0.y, pt1.x, pt1.y); segmentLengths.add(length); totalLength += length; } this.length = totalLength; return totalLength; } 
public Point [ ] resample ( int amount ) { Point [ ] points = new Point [ amount ] ; float delta = 1 ; if ( closed ) { if ( amount > 0 ) { delta = 1f / amount ; } } else { The delta value is divided by amount - 1, because we also want the last point (t=1.0) If I wouldn't use amount - 1, I fall one point short of the end. E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0, if amount = 2, I want point at t 0.0 and t 1.0 if (amount > 2) { delta = 1f / (amount - 1f); } } for (int i = 0; i < amount; i++) { points[i] = pointAt(delta * i); } return points; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); int pointCount = getPointCount(); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); We used up two extra points. i += 2; } } if (closed) gp.closePath(); } public void transform(Transform t) { t.map(getPoints()); markDirty(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
public void transform ( Transform ) { . map ( getPoints ( ) ) ; markDirty ( ) ; } 
public Path rect ( Rect r ) { Path p = new Path ( ) ; p . rect ( r ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public Path rect ( float x , float y , float width , float height ) { Path p = new Path ( ) ; p . rect ( x , y , width , height ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public Path rect ( Rect r , float roundness ) { Path p = new Path ( ) ; p . rect ( r , roundness ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public Path rect ( float x , float y , float width , float height , float roundness ) { Path p = new Path ( ) ; p . rect ( x , y , width , height , roundness ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public Path rect ( float x , float y , float width , float height , float rx , float ry ) { Path p = new Path ( ) ; p . rect ( x , y , width , height , rx , ry ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public Path oval ( float x , float y , float width , float height ) { TODO: Deprecation warning return ellipse(x, y, width, height); } 
public Path ellipse ( float x , float y , float width , float height ) { Path p = new Path ( ) ; p . ellipse ( x , y , width , height ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public Path line ( float x1 , float y1 , float x2 , float y2 ) { Path p = new Path ( ) ; p . line ( x1 , y1 , x2 , y2 ) ; inheritFromContext ( p ) ; canvas . add ( p ) ; return p ; } 
public void beginPath ( ) { path = new Path ( ) ; pathClosed = false ; } 
public Path endPath ( boolean draw ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginPath() first. " ) ; if ( autoClosePath ) closePath ( ) ; Path p = path ; inheritFromContext ( p ) ; if ( draw ) canvas . add ( p ) ; Initialize a new path path = null; pathClosed = false; return p; } 
public void drawPath ( Path path ) { inheritFromContext ( path ) ; canvas . add ( path ) ; } 
public Path findPath ( List < Point > points ) { return findPath ( points , 1 ) ; } 
public Path findPath ( List < Point > points , float curvature ) { throw new RuntimeException ( " Not implemented yet " ) ; } 
public Path textPath ( String text , float x , float y ) { return textPath ( text , x , y , 0 , 0 ) ; } 
public Path textPath ( String text , float x , float y , float width ) { return textPath ( text , x , y , width , 0 ) ; } 
public Path textPath ( String text , float x , float y , float width , float height ) { Text = new Text ( text , x , y , width , height ) ; Path p = new Path ( ) ; p . text ( ) ; inheritFromContext ( p ) ; return p ; } 
private void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; } 
public void extend ( Shape s ) { PathIterator pi = s . getPathIterator ( new AffineTransform ( ) ) ; float px = 0 ; float py = 0 ; while ( ! pi . isDone ( ) ) { float [ ] points = new float [ 6 ] ; 
public Point [ ] resample ( int amount ) { Point [ ] points = new Point [ amount ] ; float delta = 1 ; TODO: Check each contour to see if it's open or not. boolean closed = true; if (closed) { if (amount > 0) { delta = 1f / amount; } } else { The delta value is divided by amount - 1, because we also want the last point (t=1.0) If I wouldn't use amount - 1, I fall one point short of the end. E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0, if amount = 2, I want point at t 0.0 and t 1.0 if (amount > 2) { delta = 1f / (amount - 1f); } } for (int i = 0; i < amount; i++) { points[i] = pointAt(delta * i); } return points; } 
public boolean intersects ( Path p ) { Area a1 = new Area ( getGeneralPath ( ) ) ; Area a2 = new Area ( p . getGeneralPath ( ) ) ; a1 . intersect ( a2 ) ; return ! a1 . isEmpty ( ) ; } 
public Path intersected ( Path p ) { Area a1 = new Area ( getGeneralPath ( ) ) ; Area a2 = new Area ( p . getGeneralPath ( ) ) ; a1 . intersect ( a2 ) ; return new Path ( a1 ) ; } 
public Path subtracted ( Path p ) { Area a1 = new Area ( getGeneralPath ( ) ) ; Area a2 = new Area ( p . getGeneralPath ( ) ) ; a1 . subtract ( a2 ) ; return new Path ( a1 ) ; } 
public Path united ( Path p ) { Area a1 = new Area ( getGeneralPath ( ) ) ; Area a2 = new Area ( p . getGeneralPath ( ) ) ; a1 . add ( a2 ) ; return new Path ( a1 ) ; } 
public boolean isOnCurve ( ) { return type ! = CURVE_DATA ; } 
public boolean isOffCurve ( ) { return type = = CURVE_DATA ; } 
public Path map ( Path p ) { Path newPath = new Path ( p ) ; map ( newPath . getPoints ( ) ) ; return newPath ; } 
public void mouseClicked ( Point pt ) { } public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseMoved ( Point pt ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
protected void drawDot ( GraphicsContext ctx , float x , float y ) { Path p = new Path ( ) ; p . setFillColor ( HANDLE_COLOR ) ; p . rect ( x , y , HANDLE_SIZE , HANDLE_SIZE ) ; ctx . draw ( p ) ; } 
protected void drawDot ( Path p , float x , float y ) { p . rect ( x , y , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void draw ( GraphicsContext ctx ) { if ( ! ( node . getOutputValue ( ) instanceof Path ) ) return ; Path dots = new Path ( ) ; dots . setFillColor ( HANDLE_COLOR ) ; dots . setStrokeWidth ( 0f ) ; drawDots ( ctx , ( Path ) node . getOutputValue ( ) , dots ) ; ctx . draw ( dots ) ; } 
public void draw ( GraphicsContext ctx ) { float cx = node . asFloat ( xName ) ; float cy = node . asFloat ( yName ) ; float width = node . asFloat ( widthName ) ; float height = node . asFloat ( heightName ) ; float left = cx - width / 2 ; float right = cx + width / 2 ; float top = cy - height / 2 ; float bottom = cy + height / 2 ; Path cornerPath = new Path ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0 ) ; drawDot ( cornerPath , left , top ) ; drawDot ( cornerPath , right , top ) ; drawDot ( cornerPath , right , bottom ) ; drawDot ( cornerPath , left , bottom ) ; drawDot ( cornerPath , cx , cy ) ; ctx . getCanvas ( ) . add ( cornerPath ) ; Path strokePath = new Path ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . rect ( cx , cy , width , height ) ; ctx . draw ( strokePath ) ; } 
public void draw ( GraphicsContext ctx ) { float x = node . asFloat ( xName ) ; float y = node . asFloat ( yName ) ; drawDot ( ctx , x , y ) ; } 
public void testPointAt ( ) { Contour c1 = new Contour ( ) ; c1 . addPoint ( 0 , 0 ) ; c1 . addPoint ( 100 , 0 ) ; assertEquals ( new Point ( 0 , 0 ) , c1 . pointAt ( 0 ) ) ; assertEquals ( new Point ( 50 f , 0 ) , c1 . pointAt ( 0.5f ) ) ; assertEquals ( new Point ( 100 , 0 ) , c1 . pointAt ( 1f ) ) ; assertEquals ( new Point ( - 50 , 0 ) , c1 . pointAt ( - 0.5f ) ) ; assertEquals ( new Point ( 150 , 0 ) , c1 . pointAt ( 1.5f ) ) ; Contour c2 = new Contour ( ) ; c2 . addPoint ( new Point ( 0 , 0 , Point . LINE_TO ) ) ; c2 . addPoint ( new Point ( 0 , 0 , Point . CURVE_DATA ) ) ; c2 . addPoint ( new Point ( 100 , 0 , Point . CURVE_DATA ) ) ; c2 . addPoint ( new Point ( 100 , 0 , Point . CURVE_TO ) ) ; assertEquals ( new Point ( 0 , 0 ) , c2 . pointAt ( 0 ) ) ; assertEquals ( new Point ( 50 f , 0 ) , c2 . pointAt ( 0.5f ) ) ; assertEquals ( new Point ( 100 , 0 ) , c2 . pointAt ( 1f ) ) ; assertEquals(new Point(-50, 0), c2.pointAt(-0.5f)); 
public void testLength ( ) { Contour c = new Contour ( ) ; c . addPoint ( 0 , 0 ) ; c . addPoint ( 100 , 0 ) ; assertEquals ( 100 f , c . getLength ( ) ) ; c . close ( ) ; assertEquals ( 200 f , c . getLength ( ) ) ; } 
public void testPointAtClosed ( ) { Contour c = new Contour ( ) ; c . addPoint ( 0 , 0 ) ; c . addPoint ( 50 , 0 ) ; c . addPoint ( 50 , 50 ) ; Point [ ] points = c . resample ( 3 ) ; assertEquals ( 3 , points . length ) ; assertEquals ( new Point ( 0 , 0 ) , points [ 0 ] ) ; assertEquals ( new Point ( 50 , 0 ) , points [ 1 ] ) ; assertEquals ( new Point ( 50 , 50 ) , points [ 2 ] ) ; c . close ( ) ; points = c . resample ( 3 ) ; assertEquals ( 3 , points . length ) ; assertEquals ( new Point ( 0 , 0 ) , points [ 0 ] ) ; assertEquals ( new Point ( 50 , 6.9035587f ) , points [ 1 ] ) ; assertEquals ( new Point ( 50 , 9.763106f ) , points [ 2 ] ) ; } 
public void testInheritFromContext ( ) { GraphicsContext ctx = new GraphicsContext ( ) ; Color c = new Color ( ) ; assertEquals ( c , ctx . getFillColor ( ) ) ; ctx . rect ( 0 , 0 , 100 , 100 ) ; Path p = ( Path ) ctx . getCanvas ( ) . getItems ( ) . get ( 0 ) ; assertEquals ( c , p . getFillColor ( ) ) ; Color red = new Color ( 1 , 0 , 0 ) ; ctx . setFillColor ( red ) ; ctx . setAlign ( Text . Align . RIGHT ) ; Text = ctx . text ( " hello " , 20 , 20 ) ; assertEquals ( red , . getFillColor ( ) ) ; assertEquals ( Text . Align . RIGHT , . getAlign ( ) ) ; } 
private Path cornerRect ( float x , float y , float width , float height ) { Path p = new Path ( ) ; p . rect ( x + width / 2 , y + height / 2 , width , height ) ; return p ; } 
public void testIntersected ( ) { Create two non-overlapping rectangles. Path p1 = cornerRect(0, 0, 100, 100); Path p2 = cornerRect(100, 0, 100, 100); The intersection of the two is empty. assertEquals(new Rect(), p1.intersected(p2).getBounds()); Create two paths were one is entirely enclosed within the other. p1 = cornerRect(0, 0, 100, 100); p2 = cornerRect(20, 30, 10, 10); The intersection is the smaller path. assertEquals(p2.getBounds(), p1.intersected(p2).getBounds()); } 
public void testMapPath ( ) { Path p = new Path ( ) ; p . addPoint ( 0 , 0 ) ; p . addPoint ( 10 , 20 ) ; Transform = new Transform ( ) ; . translate ( 10 , 5 ) ; Path newPath = . map ( p ) ; List < Point > oldPoints = p . getPoints ( ) ; assertEquals ( new Point ( 0 , 0 ) , oldPoints . get ( 0 ) ) ; assertEquals ( new Point ( 10 , 20 ) , oldPoints . get ( 1 ) ) ; List < Point > newPoints = newPath . getPoints ( ) ; assertEquals ( new Point ( 10 , 5 ) , newPoints . get ( 0 ) ) ; assertEquals ( new Point ( 20 , 25 ) , newPoints . get ( 1 ) ) ; } 
private void loadBasicTypes ( ) { NodeLibrary testlib = new NodeLibrary ( " testlib " ) ; Node dot = Node . ROOT_NODE . newInstance ( testlib , " dot " , Path . class ) ; testlib . add ( dot ) ; dot . addParameter ( " x " , Parameter . Type . FLOAT , 0F ) ; dot . addParameter ( " y " , Parameter . Type . FLOAT , 0F ) ; Node rotate = Node . ROOT_NODE . newInstance ( testlib , " rotate " , Path . class ) ; testlib . add ( rotate ) ; rotate . addPort ( " shape " , Path . class ) ; rotate . addParameter ( " rotation " , Parameter . Type . FLOAT , 0F ) ; manager . add ( testlib ) ; } 
public void testExpressionPropagation ( ) { Inheritance: A <- B Node nodeA = Node.ROOT_NODE.newInstance(testLibrary, "A"); Parameter pF = nodeA.addParameter("f", Parameter.Type.INT, 0); String expr1 = "12 + 5"; pF.setExpression(expr1); Node nodeB = nodeA.newInstance(testLibrary, "B"); assertEquals(expr1, nodeB.getParameter("f").getExpression()); Changing the expression of A does not automatically change that of B. String expr2 = "4 * 2"; pF.setExpression(expr2); assertEquals(expr1, nodeB.getParameter("f").getExpression()); Reverting to default does. nodeB.getParameter("f").revertToDefault(); assertEquals(expr2, nodeB.getParameter("f").getExpression()); } 
public void testPortPropagation ( ) { Node nodeA = Node . ROOT_NODE . newInstance ( testLibrary , " A " ) ; nodeA . addPort ( " path " , Path . class ) ; Node nodeB = nodeA . newInstance ( testLibrary , " B " ) ; assertTrue ( nodeB . hasPort ( " path " ) ) ; } 
public void testDowncasting ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; Port ptGrob = . addPort ( " grob " , Grob . class ) ; Port ptCanvas = . addPort ( " canvas " , Canvas . class ) ; Port ptGroup = . addPort ( " group " , OldGroup . class ) ; Port ptImage = . addPort ( " image " , Image . class ) ; Port ptPath = . addPort ( " path " , Path . class ) ; Port ptText = . addPort ( " text " , Text . class ) ; Canvas canvas = new Canvas ( ) ; OldGroup group = new OldGroup ( ) ; Image image = new Image ( ) ; Path path = new Path ( ) ; Text text = new Text ( " " , 0 , 0 ) ; assertValidValue ( ptGrob , canvas ) ; assertValidValue ( ptGrob , group ) ; assertValidValue ( ptGrob , image ) ; assertValidValue ( ptGrob , path ) ; assertValidValue ( ptGrob , text ) ; assertValidValue ( ptCanvas , canvas ) ; assertInvalidValue ( ptCanvas , group ) ; assertInvalidValue ( ptCanvas , image ) ; assertInvalidValue ( ptCanvas , path ) ; assertInvalidValue ( ptCanvas , text ) ; assertValidValue ( ptGroup , canvas ) ; assertValidValue ( ptGroup , group ) ; assertInvalidValue ( ptGroup , image ) ; assertInvalidValue ( ptGroup , path ) ; assertInvalidValue ( ptGroup , text ) ; assertInvalidValue ( ptImage , canvas ) ; assertInvalidValue ( ptImage , group ) ; assertValidValue ( ptImage , image ) ; assertInvalidValue ( ptImage , path ) ; assertInvalidValue ( ptImage , text ) ; assertInvalidValue ( ptPath , canvas ) ; assertInvalidValue ( ptPath , group ) ; assertInvalidValue ( ptPath , image ) ; assertValidValue ( ptPath , path ) ; assertInvalidValue ( ptPath , text ) ; assertInvalidValue ( ptText , canvas ) ; assertInvalidValue ( ptText , group ) ; assertInvalidValue ( ptText , image ) ; assertInvalidValue ( ptText , path ) ; assertValidValue ( ptText , text ) ; 
private void registerForMacOSXEvents ( ) { if ( ! PlatformUtils . onMac ( ) ) return ; try { Generate and register the OSXAdapter, passing it a hash of all the methods we wish to use as delegates for various com.apple.eawt.ApplicationListener methods OSXAdapter.setQuitHandler(this, getClass().getDeclaredMethod("quit", (Class[]) null)); OSXAdapter.setAboutHandler(this, getClass().getDeclaredMethod("showAbout", (Class[]) null)); OSXAdapter.setPreferencesHandler(this, getClass().getDeclaredMethod("showPreferences", (Class[]) null)); OSXAdapter.setFileHandler(this, getClass().getDeclaredMethod("readFromFile", String.class)); } catch (Exception e) { System.err.println("Error while loading the OSXAdapter:"); e.printStackTrace(); } Create hidden window. hiddenFrame = new JFrame(); hiddenFrame.setJMenuBar(new NodeBoxMenuBar(false)); hiddenFrame.setUndecorated(true); hiddenFrame.setSize(0, 0); hiddenFrame.pack(); hiddenFrame.setVisible(true); } 
public void revert ( ) { TODO: Implement revert JOptionPane.showMessageDialog(this, "Revert is not implemented yet.", "NodeBox", JOptionPane.ERROR_MESSAGE); } 
public boolean saveToFile ( File file ) { try { nodeLibrary . store ( file ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , " An error occurred while saving the file. " , " NodeBox " , JOptionPane . ERROR_MESSAGE ) ; logger . log ( Level . SEVERE , " An error occurred while saving the file. " , e ) ; return false ; } documentChanged = false ; updateTitle ( ) ; return true ; 
public void undo ( ) { TODO: Implement undo JOptionPane.showMessageDialog(this, "Undo is not implemented yet.", "NodeBox", JOptionPane.ERROR_MESSAGE); } 
public void redo ( ) { TODO: Implement redo JOptionPane.showMessageDialog(this, "Redo is not implemented yet.", "NodeBox", JOptionPane.ERROR_MESSAGE); } 
public void cut ( ) { TODO: Implement cut/copy/paste JOptionPane.showMessageDialog(this, "Cut/copy/paste is not implemented yet.", "NodeBox", JOptionPane.ERROR_MESSAGE); } 
public void copy ( ) { JOptionPane . showMessageDialog ( this , " Cut/copy/paste is not implemented yet. " , " NodeBox " , JOptionPane . ERROR_MESSAGE ) ; } 
public void paste ( ) { JOptionPane . showMessageDialog ( this , " Cut/copy/paste is not implemented yet. " , " NodeBox " , JOptionPane . ERROR_MESSAGE ) ; } 
public void deleteSelected ( ) { TODO: Find network view, delete selected. JOptionPane.showMessageDialog(this, "Delete selected.", "NodeBox", JOptionPane.ERROR_MESSAGE); } 
public void close ( ) { if ( shouldClose ( ) ) { renderThread.shutdown(); 
public void windowOpened ( WindowEvent e ) { } public void windowClosing ( WindowEvent e ) { close ( ) ; } public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(Node node) { if (node != activeNetwork) return; markChanged(); updateActiveNetwork(); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(Node node) { if (node != activeNetwork) return; markChanged(); updateActiveNetwork(); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(Node node) { if (node != activeNetwork) return; markChanged(); updateActiveNetwork(); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(Node node) { if (node != activeNetwork) return; markChanged(); updateActiveNetwork(); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(Node node) { if (node != activeNetwork) return; markChanged(); updateActiveNetwork(); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(Node node) { if (node != activeNetwork) return; markChanged(); updateActiveNetwork(); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
private void doRender ( ) { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void nodeUpdated ( Node node , ProcessingContext context ) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public static void addRecentFile ( File f ) { File canonicalFile ; try { canonicalFile = f . getCanonicalFile ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , " Could not get canonical file name " , e ) ; return ; } ArrayList < File > fileList = getRecentFiles ( ) ; If the recent file was already in the list, remove it and add it to the top. If the list did not contain the file, the remove call does nothing. fileList.remove(canonicalFile); fileList.add(0, canonicalFile); writeRecentFiles(fileList); buildRecentFileMenu(); } 
public static void writeRecentFiles ( ArrayList < File > fileList ) { int i = 1 ; for ( File f : fileList ) { try { recentFilesPreferences . put ( String . valueOf ( i ) , f . getCanonicalPath ( ) ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , " Could not get canonical file name " , e ) ; return ; } i + + ; if ( i > 10 ) break ; } try { recentFilesPreferences . flush ( ) ; 
private static void buildRecentFileMenu ( ) { for ( JMenu recentFileMenu : recentFileMenus ) { recentFileMenu . removeAll ( ) ; 
public boolean isEnabled ( ) { return NodeBoxMenuBar . this . enabled ; } 
public void actionPerformed ( ActionEvent e ) { File chosenFile = FileUtils . showOpenDialog ( getCurrentDocument ( ) , NodeBoxDocument . lastFilePath , " ndbx " , " NodeBox Document " ) ; if ( chosenFile ! = null ) { NodeBoxDocument . open ( chosenFile ) ; 
public void actionPerformed ( ActionEvent e ) { NodeBoxDocument . open ( file ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . close ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . save ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . saveAs ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . revert ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . export ( ) ; } 
public boolean isEnabled ( ) { return super . isEnabled ( ) & & getCurrentDocument ( ) ! = null & & getCurrentDocument ( ) . getUndoManager ( ) . canUndo ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . undo ( ) ; } 
public boolean isEnabled ( ) { return super . isEnabled ( ) & & getCurrentDocument ( ) ! = null & & getCurrentDocument ( ) . getUndoManager ( ) . canRedo ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . redo ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . cut ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . copy ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . paste ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . deleteSelected ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . reloadActiveNode ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getCurrentDocument ( ) . setState ( Frame . ICONIFIED ) ; } 
private void moveDown ( ) { if ( selectedParameter = = null ) return ; java . util . List < Parameter > parameters = node . getParameters ( ) ; int index = parameters . indexOf ( selectedParameter ) ; assert ( index > = 0 ) ; if ( index > = parameters . size ( ) - 1 ) return ; parameters . remove ( selectedParameter ) ; parameters . add ( index + 1 , selectedParameter ) ; reloadParameterList ( ) ; parameterList . setSelectedIndex ( index + 1 ) ; } 
private void moveUp ( ) { if ( selectedParameter = = null ) return ; java . util . List < Parameter > parameters = node . getParameters ( ) ; int index = parameters . indexOf ( selectedParameter ) ; assert ( index > = 0 ) ; if ( index = = 0 ) return ; parameters . remove ( selectedParameter ) ; parameters . add ( index - 1 , selectedParameter ) ; reloadParameterList ( ) ; parameterList . setSelectedIndex ( index - 1 ) ; } 
public void initPanel ( ) { setLayout(new BoxLayout(this, BoxLayout.Y_AXIS)); setLayout(new BorderLayout(0, 0)); setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5)); FormPanel form = new FormPanel(); contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.PAGE_AXIS)); Name contentPanel.add(new JLabel("Name")); nameField = new JFormattedTextField(20); nameField.setEditable(false); form.addRow("Name", nameField); contentPanel.add(nameField); Label contentPanel.add(new JLabel("Label")); labelField = new JTextField(20); labelField.addActionListener(this); labelField.addFocusListener(this); form.addRow("Label", labelField); contentPanel.add(labelField); Help Text contentPanel.add(new JLabel("Help Text")); helpTextField = new JTextField(20); helpTextField.addActionListener(this); helpTextField.addFocusListener(this); contentPanel.add(helpTextField); form.addRow("Help Text", helpTextField); Type contentPanel.add(new JLabel("Type")); typeBox = new JComboBox(Parameter.Type.values()); typeBox.addActionListener(this); contentPanel.add(typeBox); form.addRow("Type", typeBox); Widget contentPanel.add(new JLabel("Widget")); widgetBox = new JComboBox(Parameter.Widget.values()); widgetBox.addActionListener(this); contentPanel.add(widgetBox); form.addRow("Widget", widgetBox); Value contentPanel.add(new JLabel("Value")); valueField = new JTextField(20); valueField.addActionListener(this); valueField.addFocusListener(this); contentPanel.add(valueField); form.addRow("Value", valueField); Bounding Method contentPanel.add(new JLabel("Bounding")); boundingMethodBox = new JComboBox(new String[]{"none", "soft", "hard"}); boundingMethodBox.addActionListener(this); contentPanel.add(boundingMethodBox); form.addRow("Bounding", boundingMethodBox); Minimum Value contentPanel.add(new JLabel("Minimum")); minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); minimumValueField.addFocusListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); contentPanel.add(minimumValuePanel); form.addRow("Minimum", minimumValuePanel); Maximum Value contentPanel.add(new JLabel("Maximum")); maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); maximumValueField.addFocusListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); contentPanel.add(maximumValuePanel); form.addRow("Maximum", maximumValuePanel); Display Level contentPanel.add(new JLabel("Display Level")); displayLevelBox = new JComboBox(new String[]{"hud", "detail", "hidden"}); displayLevelBox.addActionListener(this); contentPanel.add(displayLevelBox); form.addRow("Display Level", displayLevelBox); Menu Items contentPanel.add(new JLabel("Menu Items")); menuItemsTable = new JTable(new MenuItemsModel()); menuItemsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); JPanel tablePanel = new JPanel(new BorderLayout(5, 5)); JScrollPane tableScroll = new JScrollPane(menuItemsTable, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); tableScroll.setSize(200, 200); tableScroll.setPreferredSize(new Dimension(200, 200)); tableScroll.setMaximumSize(new Dimension(200, 200)); tableScroll.setMinimumSize(new Dimension(200, 200)); tablePanel.add(tableScroll, BorderLayout.CENTER); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 5)); addButton = new JButton(new Icons.PlusIcon()); addButton.addActionListener(this); removeButton = new JButton(new Icons.MinusIcon()); removeButton.addActionListener(this); upButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.NORTH)); upButton.addActionListener(this); downButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.SOUTH)); downButton.addActionListener(this); buttonPanel.add(addButton); buttonPanel.add(removeButton); buttonPanel.add(upButton); buttonPanel.add(downButton); tablePanel.add(buttonPanel, BorderLayout.SOUTH); form.addRow("Menu Items", tablePanel); add(form, BorderLayout.CENTER); 
public void updateValues ( ) { nameField . setText ( parameter . getName ( ) ) ; labelField . setText ( parameter . getLabel ( ) ) ; helpTextField . setText ( parameter . getHelpText ( ) ) ; typeBox . setSelectedItem ( parameter . getType ( ) ) ; widgetBox . setSelectedItem ( parameter . getWidget ( ) ) ; valueField . setText ( parameter . getValue ( ) . toString ( ) ) ; Parameter . BoundingMethod boundingMethod = parameter . getBoundingMethod ( ) ; boundingMethodBox . setSelectedItem ( boundingMethod . toString ( ) . toLowerCase ( ) ) ; Object minimumValue = parameter . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = parameter . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; displayLevelBox . setSelectedItem ( parameter . getDisplayLevel ( ) . toString ( ) . toLowerCase ( ) ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
private void moveItemDown ( ) { int index = menuItemsTable . getSelectedRow ( ) ; Return if nothing was selected. if (index == -1) return; java.util.List<Parameter.MenuItem> items = parameter.getMenuItems(); Return if the last item is selected. if (index >= items.size() - 1) return; Parameter.MenuItem selectedItem = items.get(index); items.remove(selectedItem); items.add(index + 1, selectedItem); parameter.fireAttributeChanged(); TODO: Changing the selection doesn't have any effect on Mac. menuItemsTable.changeSelection(index + 1, 1, false, false); } 
private void moveItemUp ( ) { int index = menuItemsTable . getSelectedRow ( ) ; Return if nothing was selected. if (index == -1) return; Return if the first item is selected. if (index == 0) return; java.util.List<Parameter.MenuItem> items = parameter.getMenuItems(); Parameter.MenuItem selectedItem = items.get(index); items.remove(selectedItem); items.add(index - 1, selectedItem); parameter.fireAttributeChanged(); TODO: Changing the selection doesn't have any effect on Mac. menuItemsTable.changeSelection(index - 1, 1, false, false); } 
public void addRow ( String label , JComponent component ) { GridBagConstraints labelConstraints = new GridBagConstraints ( ) ; labelConstraints . gridx = 0 ; labelConstraints . gridy = rowCount ; labelConstraints . insets = new Insets ( 0 , 0 , 5 , 5 ) ; labelConstraints . anchor = GridBagConstraints . BASELINE_TRAILING ; GridBagConstraints componentConstraints = new GridBagConstraints ( ) ; componentConstraints . gridx = 1 ; componentConstraints . gridy = rowCount ; componentConstraints . gridwidth = GridBagConstraints . REMAINDER ; componentConstraints . fill = GridBagConstraints . HORIZONTAL ; componentConstraints . insets = new Insets ( 0 , 0 , 5 , 0 ) ; componentConstraints . anchor = GridBagConstraints . BASELINE_LEADING ; JLabel l = new JLabel ( label + " : " ) ; add ( l , labelConstraints ) ; add ( component , componentConstraints ) ; rowCount + + ; Add another column/row that takes up all available space. This moves the layout to the top-left corner. layout.columnWidths = new int[]{0, 0, 0}; layout.columnWeights = new double[]{0.0, 0.0, 1.0E-4}; layout.rowHeights = new int[rowCount + 1]; layout.rowWeights = new double[rowCount + 1]; layout.rowWeights[rowCount] = 1.0E-4; } 
public void actionPerformed ( ActionEvent e ) { Commit key and label. successful = true; MenuItemDialog.this.setVisible(false); } 
public void actionPerformed ( ActionEvent e ) { MenuItemDialog . this . setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; } 
public boolean isSuccessful ( ) { return successful ; } 
public void fireAttributeChanged ( ) { node . fireParameterAttributeChanged ( this ) ; } 
public void removeMenuItem ( MenuItem item ) { menuItems . remove ( item ) ; fireAttributeChanged ( ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(Path2D.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); int pointCount = getPointCount(); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); } } if (closed) gp.closePath(); } public void transform(Transform t) { t.map(getPoints()); markDirty(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
 void _extendPath ( GeneralPath gp ) { Point pt = points . get ( 0 ) ; Point ctrl1 , ctrl2 ; gp . moveTo ( pt . x , pt . y ) ; int pointCount = getPointCount ( ) ; for ( int i = 1 ; i < pointCount ; i + + ) { pt = points . get ( i ) ; if ( pt . isLineTo ( ) ) { gp . lineTo ( pt . x , pt . y ) ; } else if ( pt . isCurveTo ( ) ) { ctrl1 = points . get ( i - 2 ) ; ctrl2 = points . get ( i - 1 ) ; gp . curveTo ( ctrl1 . x , ctrl1 . y , ctrl2 . x , ctrl2 . y , pt . x , pt . y ) ; } } if ( closed ) gp . closePath ( ) ; 
public void draw ( Graphics2D g ) { If we can't fill or stroke the path, there's nothing to draw. if (fillColor == null && strokeColor == null) return; GeneralPath gp = getGeneralPath(); if (fillColor != null) { g.setColor(fillColor.getAwtColor()); g.fill(gp); } if (strokeWidth > 0 && strokeColor != null) { try { 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Fill the background with a neutral grey. g2.setColor(new Color(232, 232, 232)); Rectangle clip = g.getClipBounds(); g2.fillRect(clip.x, clip.y, clip.width, clip.height); if (canvasImage != null) g2.drawImage(canvasImage,0, 0, null); if (getNode() == null) return; Object outputValue = getNode().getOutputValue(); if (outputValue instanceof Grob) { g2.translate(getWidth() / 2.0, getHeight() / 2.0); ((Grob) outputValue).draw(g2); } else if (outputValue != null) { String s = outputValue.toString(); g2.setColor(SwingUtils.COLOR_NORMAL); g2.setFont(PlatformUtils.getEditorFont()); g2.drawString(s, 5, 20); } Draw the handle. if (handle != null && showHandle) { Create a canvas with a transparent background nodebox.graphics.Canvas canvas = new nodebox.graphics.Canvas(); canvas.setBackground(new nodebox.graphics.Color(0, 0, 0, 0)); GraphicsContext ctx = new GraphicsContext(canvas); handle.draw(ctx); ctx.getCanvas().draw(g2); } Draw the points. if (showPoints && outputValue instanceof Path) { Create a canvas with a transparent background 
private nodebox . graphics . Point pointForEvent ( MouseEvent e ) { double cx = - getWidth ( ) / 2.0 + e . getX ( ) ; double cy = - getHeight ( ) / 2.0 + e . getY ( ) ; return new nodebox . graphics . Point ( ( float ) cx , ( float ) cy ) ; } 
public void togglePoints ( ) { viewer . setShowPoints ( pointsCheck . isChecked ( ) ) ; } 
public void addRow ( String label , JComponent component ) { GridBagConstraints labelConstraints = new GridBagConstraints ( ) ; labelConstraints . gridx = 0 ; labelConstraints . gridy = rowCount ; labelConstraints . insets = new Insets ( 0 , 0 , 5 , 5 ) ; labelConstraints . anchor = GridBagConstraints . LINE_END ; GridBagConstraints componentConstraints = new GridBagConstraints ( ) ; componentConstraints . gridx = 1 ; componentConstraints . gridy = rowCount ; componentConstraints . gridwidth = GridBagConstraints . REMAINDER ; componentConstraints . fill = GridBagConstraints . HORIZONTAL ; componentConstraints . insets = new Insets ( 0 , 0 , 5 , 0 ) ; componentConstraints . anchor = GridBagConstraints . LINE_START ; JLabel l = new JLabel ( label + " : " ) ; add ( l , labelConstraints ) ; add ( component , componentConstraints ) ; rowCount + + ; Add another column/row that takes up all available space. This moves the layout to the top-left corner. layout.columnWidths = new int[]{0, 0, 0}; layout.columnWeights = new double[]{0.0, 0.0, 1.0E-4}; layout.rowHeights = new int[rowCount + 1]; layout.rowWeights = new double[rowCount + 1]; layout.rowWeights[rowCount] = 1.0E-4; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(GeneralPath.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); int pointCount = getPointCount(); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); } } if (closed) gp.closePath(); } public void transform(Transform t) { t.map(getPoints()); markDirty(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(GeneralPath.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } 
public void updateIcon ( ) { Image icon = getImageForNode ( node ) ; Create the icon. We include only the parts that are not changed by state. This means leaving off the error and rendered image. Also, we draw the rim at the very end, above the error and rendered, so we can't draw it here yet. fullIcon = new BufferedImage(NODE_FULL_SIZE, NODE_FULL_SIZE, BufferedImage.TYPE_INT_ARGB); Graphics2D fg = fullIcon.createGraphics(); Count the input ports and draw them. java.util.List<Port> inputs = node.getPorts(); if (inputs.size() > 0) { int portY = (NODE_FULL_SIZE - NODE_PORT_HEIGHT) / 2 - 1; fg.drawImage(nodeInPort, 0, portY, null); } Draw the other layers. fg.drawImage(nodeOutPort, 0, 0, null); fg.drawImage(nodeMask, 0, 0, null); fg.setComposite(AlphaComposite.SrcIn); fg.drawImage(icon, 10, 10, NODE_IMAGE_SIZE, NODE_IMAGE_SIZE, null); fg.setComposite(AlphaComposite.SrcOver); fg.drawImage(nodeReflection, 0, 0, null); fg.dispose(); } 
private static double snap ( double value ) { value = Math . round ( value ) ; return Math . round ( value / GRID_SIZE ) * GRID_SIZE ; } 
public boolean isShowPointNumbers ( ) { return showPointNumbers ; } 
public void togglePointNumbers ( ) { viewer . setShowPointNumbers ( pointNumbersCheck . isChecked ( ) ) ; } 
public void extend ( Iterator < Point > points ) { while ( points . hasNext ( ) ) { Point point = points . next ( ) ; 
public void extend ( Point [ ] points ) { for ( Point point : points ) { addPoint ( point . clone ( ) ) ; 
public Point [ ] makePoints ( ) { return makePoints ( 100 ) ; } 
public void rotateRadians ( float radians ) { transform . rotateRadians ( radians ) ; } 
public void translate ( float tx , float ty ) { Transform = Transform . translated ( tx , ty ) ; transform ( ) ; } 
public void rotate ( float degrees ) { Transform = Transform . rotated ( degrees ) ; transform ( ) ; } 
public void rotateRadians ( float radians ) { Transform = Transform . rotatedRadians ( radians ) ; transform ( ) ; } 
public void scale ( float scale ) { Transform = Transform . scaled ( scale ) ; transform ( ) ; } 
public void scale ( float sx , float sy ) { Transform = Transform . scaled ( sx , sy ) ; transform ( ) ; } 
public void skew ( float skew ) { Transform = Transform . skewed ( skew ) ; transform ( ) ; } 
public void skew ( float kx , float ky ) { Transform = Transform . skewed ( kx , ky ) ; transform ( ) ; } 
public void draw ( Graphics2D g ) { float halfWidth = width / 2 ; float halfHeight = height / 2 ; float left = - halfWidth ; float top = - halfHeight ; g . setColor ( background . getAwtColor ( ) ) ; g . fillRect ( ( int ) left , ( int ) top , ( int ) width , ( int ) height ) ; Rectangle clip = g.getClipBounds(); int clipwidth = clip != null && width > clip.width ? clip.width : (int) height; int clipheight = clip != null && height > clip.height ? clip.height : (int) width; g.setClip(clip != null ? clip.x : 0, clip != null ? clip.y : 0, clipwidth, clipheight); for (Grob grob : items) { grob.draw(g); 
public Point pointAt ( float ) { if ( segmentLengths = = null ) updateSegmentLengths ( ) ; Check if there is a path. if (points.isEmpty()) throw new NodeBoxError("The path is empty."); If the path has no length, return the position of the first point. if (length == 0) return points.get(0).clone(); Since t is relative, convert it to the absolute length. float absT = t * length; The resT is what remains of t after we traversed all segments. float resT = t; Find the segment that contains t. int segnum = -1; for (Float seglength : segmentLengths) { segnum++; if (absT <= seglength || segnum == segmentLengths.size() - 1) break; absT -= seglength; resT -= seglength / length; } resT /= (segmentLengths.get(segnum) / length); Find the point index for the segment. int pi = pointIndexForSegment(segnum + 1); Point pt1 = points.get(pi); If the path is closed, the point index is set to zero. Set the index to the last point to get the one-but-last point for pt0. if (pi == 0) { pi = points.size(); } if (pt1.isLineTo()) { Point pt0 = points.get(pi - 1); 
private int pointIndexForSegment ( int segnum ) { int pointIndex = 0 ; for ( Point pt : points ) { if ( pt . isCurveTo ( ) | | pt . isLineTo ( ) ) { if ( segnum = = 0 ) break ; segnum - - ; } pointIndex + + ; } int pointCount = points . size ( ) ; if ( pointIndex < pointCount ) { return pointIndex ; 
public Point [ ] makePoints ( int amount ) { If the contour is empty, pointAt will fail. Return an empty array. if (points.isEmpty()) return new Point[0]; Point[] points = new Point[amount]; float delta = 1; if (closed) { if (amount > 0) { delta = 1f / amount; } } else { The delta value is divided by amount - 1, because we also want the last point (t=1.0) If I wouldn't use amount - 1, I fall one point short of the end. E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0, if amount = 2, I want point at t 0.0 and t 1.0 if (amount > 2) { delta = 1f / (amount - 1f); } } for (int i = 0; i < amount; i++) { points[i] = pointAt(delta * i); } return points; } 
public Contour resampleByAmount ( int amount , boolean perContour ) { return resampleByAmount ( amount ) ; } 
public Contour resampleByAmount ( int amount ) { Contour c = new Contour ( ) ; c . extend ( makePoints ( amount ) ) ; c . closed = closed ; return c ; } 
public Contour resampleByLength ( float segmentLength ) { if ( segmentLength < = 0.0000001f ) { throw new IllegalArgumentException ( " Segment length must be greater than zero. " ) ; } float contourLength = getLength ( ) ; int amount = ( int ) Math . ceil ( contourLength / segmentLength ) ; if ( closed ) { return resampleByAmount ( amount ) ; 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(GeneralPath.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { if (points.size() == 0) return; Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); int pointCount = getPointCount(); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); } } if (closed) gp.closePath(); } public void transform(Transform t) { t.map(getPoints()); markDirty(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
 void _extendPath ( GeneralPath gp ) { if ( points . size ( ) = = 0 ) return ; Point pt = points . get ( 0 ) ; Point ctrl1 , ctrl2 ; gp . moveTo ( pt . x , pt . y ) ; int pointCount = getPointCount ( ) ; for ( int i = 1 ; i < pointCount ; i + + ) { pt = points . get ( i ) ; if ( pt . isLineTo ( ) ) { gp . lineTo ( pt . x , pt . y ) ; } else if ( pt . isCurveTo ( ) ) { ctrl1 = points . get ( i - 2 ) ; ctrl2 = points . get ( i - 1 ) ; gp . curveTo ( ctrl1 . x , ctrl1 . y , ctrl2 . x , ctrl2 . y , pt . x , pt . y ) ; } } if ( closed ) gp . closePath ( ) ; 
public void inheritFromContext ( GraphicsContext ctx ) ; public void draw ( Graphics2D g ) ; Geometric queries public Rect getBounds(); Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky);} 
public void draw ( Graphics2D g ) ; Geometric queries public Rect getBounds(); Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky);} 
public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky);} 
public void transform ( Transform ) ; Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky);} 
public Grob clone ( ) ; void translate ( float tx , float ty ) ; void rotate ( float degrees ) ; void rotateRadians ( float radians ) ; void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; } 
void translate ( float tx , float ty ) ; void rotate ( float degrees ) ; void rotateRadians ( float radians ) ; void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; } 
void rotate ( float degrees ) ; void rotateRadians ( float radians ) ; void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; } 
void rotateRadians ( float radians ) ; void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; } 
void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; } 
void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; } 
public Point [ ] makePoints ( int amount ) { return new Point [ 0 ] ; } 
public IGeometry resampleByAmount ( int amount , boolean perContour ) { return null ; } 
public IGeometry resampleByLength ( float segmentLength ) { return null ; } 
public int getPointCount ( ) ; public IGeometry clone();} 
public List < Point > getPoints ( ) ; public IGeometry clone();} 
public void addPoint ( Point pt ) ; public IGeometry clone();} 
public void addPoint ( float x , float y ) ; public IGeometry clone();} 
public void extend ( Iterator < Point > points ) ; public IGeometry clone();} 
public void extend ( Point [ ] points ) ; Geometric operations public IGeometry clone();} 
public Point [ ] makePoints ( ) ; public IGeometry clone ( ) ; } 
public Point [ ] makePoints ( int amount ) ; public IGeometry clone ( ) ; } 
public IGeometry resampleByAmount ( int amount , boolean perContour ) ; public IGeometry clone ( ) ; } 
public IGeometry resampleByLength ( float segmentLength ) ; public IGeometry clone ( ) ; } 
public void flatten ( ) ; public IGeometry clone ( ) ; } 
public IGeometry flattened ( ) ; public IGeometry clone ( ) ; } 
public void moveto ( float x , float y ) { Stop using the current contour. addPoint will automatically create a new contour. currentContour = null; addPoint(x, y); } 
public Point [ ] makePoints ( int amount ) { return makePoints ( amount , false ) ; } 
public Point [ ] makePoints ( int amount , boolean perContour ) { if ( perContour ) { Point [ ] points = new Point [ amount * contours . size ( ) ] ; 
public IGeometry resampleByAmount ( int amount , boolean perContour ) { if ( perContour ) { Path p = cloneAndClear ( ) ; 
public IGeometry resampleByLength ( float segmentLength ) { Path p = cloneAndClear ( ) ; for ( Contour c : contours ) { p . add ( c . resampleByLength ( segmentLength ) ) ; } return p ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public Path clone ( ) { return new Path ( this ) ; } public Path cloneAndClear ( ) { return new Path ( this , false ) ; } } 
public Path cloneAndClear ( ) { return new Path ( this , false ) ; } 
public static Transform rotated ( float degrees ) { Transform = new Transform ( ) ; . rotate ( degrees ) ; return ; } 
public static Transform rotatedRadians ( float radians ) { Transform = new Transform ( ) ; . rotateRadians ( radians ) ; return ; } 
public static Transform scaled ( float scale ) { Transform = new Transform ( ) ; . scale ( scale ) ; return ; } 
public static Transform scaled ( float sx , float sy ) { Transform = new Transform ( ) ; . scale ( sx , sy ) ; return ; } 
public static Transform skewed ( float skew ) { Transform = new Transform ( ) ; . skew ( skew ) ; return ; } 
public static Transform skewed ( float kx , float ky ) { Transform = new Transform ( ) ; . skew ( kx , ky ) ; return ; } 
public void testPointAtEmptyPath ( ) { Contour c = new Contour ( ) ; try { c . pointAt ( 0.1f ) ; fail ( " Should have thrown an error. " ) ; } catch ( NodeBoxError e ) { } c . addPoint ( 33 , 44 ) ; assertPointEquals ( 33 , 44 , c . pointAt ( 0.1f ) ) ; assertPointEquals ( 33 , 44 , c . pointAt ( 100 f ) ) ; assertPointEquals ( 33 , 44 , c . pointAt ( - 12 f ) ) ; } 
public void testPointAtClosed ( ) { Contour c = new Contour ( ) ; c . addPoint ( 0 , 0 ) ; c . addPoint ( SIDE , 0 ) ; c . addPoint ( SIDE , SIDE ) ; c . addPoint ( 0 , SIDE ) ; assertEquals ( SIDE * 3 , c . getLength ( ) ) ; assertPointEquals ( 0 , 0 , c . pointAt ( 0f ) ) ; assertPointEquals ( SIDE , SIDE / 2 , c . pointAt ( 0.5f ) ) ; assertPointEquals ( 0 , SIDE , c . pointAt ( 1f ) ) ; c . close ( ) ; assertEquals ( SIDE * 4 , c . getLength ( ) ) ; assertPointEquals ( 0 , 0 , c . pointAt ( 0f ) ) ; assertPointEquals ( SIDE , SIDE , c . pointAt ( 0.5f ) ) ; assertPointEquals ( 0 , 0 , c . pointAt ( 1f ) ) ; } 
public void testLength ( ) { testLength ( 0 , 0 ) ; testLength ( 100 , 200 ) ; } 
private void testLength ( float x , float y ) { Contour c = new Contour ( ) ; c . addPoint ( x , y ) ; c . addPoint ( x + SIDE , y ) ; c . addPoint ( x + SIDE , y + SIDE ) ; c . addPoint ( x , y + SIDE ) ; assertEquals ( SIDE * 3 , c . getLength ( ) ) ; c . close ( ) ; assertEquals ( SIDE * 4 , c . getLength ( ) ) ; } 
public void testMakePoints ( ) { Point [ ] points ; A contour that is "open", which means it doesn't describe the last point. Contour c = new Contour(); c.addPoint(0, 0); c.addPoint(SIDE, 0); c.addPoint(SIDE, SIDE); c.addPoint(0, SIDE); assertEquals(SIDE * 3, c.getLength()); points = c.makePoints(7); assertPointEquals(0, 0, points[0]); assertPointEquals(SIDE / 2, 0, points[1]); assertPointEquals(SIDE, 0, points[2]); assertPointEquals(0, SIDE, points[6]); Closing the contour will encrease the length of the path and thus will also have an effect on point positions. c.close(); assertEquals(SIDE * 4, c.getLength()); points = c.makePoints(8); assertEquals(new Point(0, 0), points[0]); assertPointEquals(SIDE / 2, 0, points[1]); assertPointEquals(SIDE, 0, points[2]); assertPointEquals(0, SIDE, points[6]); assertPointEquals(0, SIDE / 2, points[7]); 
public void testMakePointsEmptyPath ( ) { Contour c = new Contour ( ) ; Point [ ] points = c . makePoints ( 10 ) ; assertEquals ( 0 , points . length ) ; } 
public void testResample ( ) { Contour r ; List < Point > points ; Contour c1 = new Contour ( ) ; r = c1 . resampleByAmount ( 10 ) ; assertEquals ( 0 , r . getPointCount ( ) ) ; assertFalse ( r . isClosed ( ) ) ; Contour c2 = new Contour ( ) ; addRect ( c2 , 0 , 0 , SIDE , SIDE ) ; r = c2 . resampleByAmount ( 4 ) ; assertEquals ( 4 , r . getPointCount ( ) ) ; assertFalse ( r . isClosed ( ) ) ; points = r . getPoints ( ) ; assertPointEquals ( 0 , 0 , points . get ( 0 ) ) ; assertPointEquals ( SIDE , 0 , points . get ( 1 ) ) ; assertPointEquals ( SIDE , SIDE , points . get ( 2 ) ) ; assertPointEquals ( 0 , SIDE , points . get ( 3 ) ) ; c2 . close ( ) ; r = c2 . resampleByAmount ( 4 ) ; assertEquals ( 4 , r . getPointCount ( ) ) ; assertTrue ( r . isClosed ( ) ) ; points = r . getPoints ( ) ; assertPointEquals ( 0 , 0 , points . get ( 0 ) ) ; assertPointEquals ( 0 , SIDE , points . get ( 3 ) ) ; } 
public void testResampleByLength ( ) { Contour r ; Contour c1 = new Contour ( ) ; r = c1 . resampleByLength ( 1 ) ; assertEquals ( 0 , r . getPointCount ( ) ) ; assertFalse ( r . isClosed ( ) ) ; Contour c2 = new Contour ( ) ; addRect ( c2 , 0 , 0 , SIDE , SIDE ) ; r = c2 . resampleByLength ( SIDE ) ; assertFalse ( r . isClosed ( ) ) ; assertRectPoints ( r , 0 , 0 , SIDE , SIDE ) ; c2 . close ( ) ; r = c2 . resampleByLength ( SIDE ) ; assertTrue ( r . isClosed ( ) ) ; assertRectPoints ( r , 0 , 0 , SIDE , SIDE ) ; } 
private void assertRectPoints ( IGeometry g , float x , float y , float width , float height ) { assertEquals ( 4 , g . getPointCount ( ) ) ; List < Point > points = g . getPoints ( ) ; assertPointEquals ( x , y , points . get ( 0 ) ) ; assertPointEquals ( x + width , y , points . get ( 1 ) ) ; assertPointEquals ( x + width , y + height , points . get ( 2 ) ) ; assertPointEquals ( x , y + height , points . get ( 3 ) ) ; } 
protected void assertPointEquals ( float x , float y , Point actual ) { assertEquals ( x , actual . x , 0.001f ) ; assertEquals ( y , actual . y , 0.001f ) ; } 
protected void addRect ( IGeometry g , float x , float y , float width , float height ) { g . addPoint ( x , y ) ; g . addPoint ( x + width , y ) ; g . addPoint ( x + width , y + height ) ; g . addPoint ( x , y + height ) ; } 
public void testDummy ( ) { One test necessary to keep JUnit happy. }} 
public void testLength ( ) { testLength ( 0 , 0 ) ; testLength ( 200 , 300 ) ; Path p = new Path ( ) ; p . line ( 0 , 0 , 50 , 0 ) ; p . line ( 50 , 0 , 100 , 0 ) ; assertEquals ( 100 f , p . getLength ( ) ) ; } 
private void testLength ( float x , float y ) { Path p = new Path ( ) ; addRect ( p , x , y , SIDE , SIDE ) ; assertEquals ( SIDE * 3 , p . getLength ( ) ) ; p . close ( ) ; assertEquals ( SIDE * 4 , p . getLength ( ) ) ; } 
public void testPointAtMultipleContours ( ) { Path p = new Path ( ) ; float x1 = 0 ; float y1 = 0 ; float x2 = 200 ; float y2 = 0 ; addRect ( p , x1 , y1 , SIDE , SIDE ) ; p . newContour ( ) ; addRect ( p , x2 , y2 , SIDE , SIDE ) ; assertEquals ( 2 , p . getContours ( ) . size ( ) ) ; assertEquals ( 8 , p . getPointCount ( ) ) ; assertPointEquals ( x1 , y1 , p . pointAt ( 0f ) ) ; At the beginning of the second contour. assertPointEquals(x2, y2, p.pointAt(1f / 8f)); assertPointEquals(x2, y2 + SIDE, p.pointAt(1f)); } 
public void testContour ( ) { final float SIDE = 50 ; Point [ ] points ; Path p = new Path ( ) ; addRect ( p , 0 , 0 , SIDE , SIDE ) ; assertEquals ( SIDE * 3 , p . getLength ( ) ) ; points = p . makePoints ( 7 ) ; assertPointEquals ( 0 , 0 , points [ 0 ] ) ; assertPointEquals ( SIDE / 2 , 0 , points [ 1 ] ) ; assertPointEquals ( SIDE , 0 , points [ 2 ] ) ; assertPointEquals ( 0 , SIDE , points [ 6 ] ) ; Closing the contour will encrease the length of the path and thus will also have an effect on point positions. p.close(); assertEquals(SIDE * 4, p.getLength()); points = p.makePoints(8); assertEquals(new Point(0, 0), points[0]); assertPointEquals(SIDE / 2, 0, points[1]); assertPointEquals(SIDE, 0, points[2]); assertPointEquals(0, SIDE, points[6]); assertPointEquals(0, SIDE / 2, points[7]); } 
public void testMultipleContours ( ) { final float SIDE = 50 ; final float x2 = 200 ; final float y2 = 300 ; Point [ ] points ; Path p1 = new Path ( ) ; Build the path using separate contours. You can also build two contours using moveto/lineto/lineto/lineto/moveto/... Contour c1 = new Contour(); Contour c2 = new Contour(); addRect(c1, 0, 0, SIDE, SIDE); addRect(c2, x2, y2, SIDE, SIDE); p1.add(c1); p1.add(c2); assertEquals(SIDE * 6, p1.getLength()); points = p1.makePoints(14); assertPointEquals(0, 0, points[0]); assertPointEquals(SIDE / 2, 0, points[1]); assertPointEquals(SIDE, 0, points[2]); assertPointEquals(0, SIDE, points[6]); assertPointEquals(x2, y2, points[7]); Create a path with two closed contours. Path p2 = new Path(); c1 = new Contour(); c2 = new Contour(); addRect(c1, 0, 0, SIDE, SIDE); addRect(c2, x2, y2, SIDE, SIDE); c1.close(); c2.close(); p2.add(c1); p2.add(c2); assertEquals(SIDE * 8, p2.getLength()); } 
private Path cornerRect ( float x , float y , float width , float height ) { Path p = new Path ( ) ; p . rect ( x + width / 2 , y + height / 2 , width , height ) ; return p ; } 
public void testDowncasting ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; Port ptGrob = . addPort ( " grob " , Grob . class ) ; Port ptCanvas = . addPort ( " canvas " , Canvas . class ) ; Port ptImage = . addPort ( " image " , Image . class ) ; Port ptPath = . addPort ( " path " , Path . class ) ; Port ptText = . addPort ( " text " , Text . class ) ; Canvas canvas = new Canvas ( ) ; Image image = new Image ( ) ; Path path = new Path ( ) ; Text text = new Text ( " " , 0 , 0 ) ; assertValidValue ( ptGrob , canvas ) ; assertValidValue ( ptGrob , image ) ; assertValidValue ( ptGrob , path ) ; assertValidValue ( ptGrob , text ) ; assertValidValue ( ptCanvas , canvas ) ; assertInvalidValue ( ptCanvas , image ) ; assertInvalidValue ( ptCanvas , path ) ; assertInvalidValue ( ptCanvas , text ) ; assertInvalidValue ( ptImage , canvas ) ; assertValidValue ( ptImage , image ) ; assertInvalidValue ( ptImage , path ) ; assertInvalidValue ( ptImage , text ) ; assertInvalidValue ( ptPath , canvas ) ; assertInvalidValue ( ptPath , image ) ; assertValidValue ( ptPath , path ) ; assertInvalidValue ( ptPath , text ) ; assertInvalidValue ( ptText , canvas ) ; assertInvalidValue ( ptText , image ) ; assertInvalidValue ( ptText , path ) ; assertValidValue ( ptText , text ) ; 
public void testPointAtMultipleContours ( ) { Create two contours that look like a single line. Path p = new Path(); p.addPoint(0, 0); p.addPoint(50, 0); p.newContour(); p.addPoint(50, 0); p.addPoint(100, 0); assertEquals(2, p.getContours().size()); assertEquals(4, p.getPointCount()); assertEquals(100f, p.getLength()); assertPointEquals(0, 0, p.pointAt(0f)); assertPointEquals(25, 0, p.pointAt(0.25f)); assertPointEquals(50, 0, p.pointAt(0.5f)); assertPointEquals(100, 0, p.pointAt(1.0f)); } 
public void testMultipleContours ( ) { Point [ ] points ; Create a path with separate contours. Each contour describes a side of a rectangle. Path p1 = new Path(); p1.addPoint(0, 0); p1.addPoint(SIDE, 0); p1.newContour(); p1.addPoint(SIDE, 0); p1.addPoint(SIDE, SIDE); p1.newContour(); p1.addPoint(SIDE, SIDE); p1.addPoint(0, SIDE); assertEquals(SIDE * 3, p1.getLength()); points = p1.makePoints(4); assertPointEquals(0, 0, points[0]); assertPointEquals(SIDE, 0, points[1]); assertPointEquals(SIDE, SIDE, points[2]); assertPointEquals(0, SIDE, points[3]); } 
public Point [ ] makePoints ( ) { return makePoints ( DEFAULT_POINT_AMOUNT , false ) ; } 
protected float pointDelta ( int amount , boolean closed ) { float delta = 1 ; if ( closed ) { if ( amount > 0 ) { delta = 1f / amount ; } } else { The delta value is divided by amount - 1, because we also want the last point (t=1.0) If I wouldn't use amount - 1, I fall one point short of the end. E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0, if amount = 2, I want point at t 0.0 and t 1.0 if (amount > 2) { delta = 1f / (amount - 1f); } } return delta; } 
public Point [ ] makePoints ( int amount , boolean perContour ) { return makePoints ( amount ) ; } 
public void add ( Path path ) { paths . add ( path ) ; currentPath = path ; } 
public void clear ( ) { paths . clear ( ) ; currentPath = null ; } 
public void extend ( Group g ) { for ( Path path : g . paths ) { paths . add ( path . clone ( ) ) ; 
public boolean isClosed ( ) { if ( isEmpty ( ) ) return false ; Path lastPath = paths . get ( paths . size ( ) - 1 ) ; return lastPath . isClosed ( ) ; } 
private void updatePathLengths ( ) { pathLengths = new ArrayList < Float > ( paths . size ( ) ) ; groupLength = 0 ; float length ; for ( Path p : paths ) { length = p . getLength ( ) ; pathLengths . add ( length ) ; groupLength + = length ; } lengthDirty = false ; } 
public Point pointAt ( float ) { float length = getLength ( ) ; Since t is relative, convert it to the absolute length. float absT = t * length; The resT is what remains of t after we traversed all segments. float resT = t; Find the contour that contains t. float cLength; Path currentPath = null; for (Path p : paths) { currentPath = p; cLength = p.getLength(); if (absT <= cLength) break; absT -= cLength; resT -= cLength / length; } if (currentPath == null) return new Point(); resT /= (currentPath.getLength() / length); return currentPath.pointAt(resT); } 
public Point [ ] makePoints ( int amount , boolean perContour ) { if ( perContour ) { ArrayList < Point > points = new ArrayList < Point > ( ) ; 
public Group resampleByAmount ( int amount , boolean perContour ) { if ( perContour ) { Group g = new Group ( ) ; 
public Group resampleByLength ( float segmentLength ) { Group g = new Group ( ) ; for ( Path p : paths ) { g . add ( p . resampleByLength ( segmentLength ) ) ; } return g ; } 
public void transform ( Transform ) { for ( Grob grob : paths ) { grob . transform ( ) ; 
public void draw ( Graphics2D g ) { for ( Grob grob : paths ) { grob . draw ( g ) ; 
public int getPointCount ( ) ; public IGeometry clone();} 
public List < Point > getPoints ( ) ; public IGeometry clone();} 
public void addPoint ( Point pt ) ; public IGeometry clone();} 
public void addPoint ( float x , float y ) ; public IGeometry clone();} 
public void extend ( Iterator < Point > points ) ; public IGeometry clone();} 
public void extend ( Point [ ] points ) ; Geometric operations public IGeometry clone();} 
public Point [ ] makePoints ( ) ; public IGeometry clone ( ) ; } 
public Point [ ] makePoints ( int amount ) ; public IGeometry clone ( ) ; } 
public Point [ ] makePoints ( int amount , boolean perContour ) ; public IGeometry clone ( ) ; } 
public IGeometry resampleByAmount ( int amount , boolean perContour ) ; public IGeometry clone ( ) ; } 
public IGeometry resampleByLength ( float segmentLength ) ; public IGeometry clone ( ) ; } 
public void flatten ( ) ; public IGeometry clone ( ) ; } 
public IGeometry flattened ( ) ; public IGeometry clone ( ) ; } 
public boolean isEmpty ( ) { return contours . isEmpty ( ) ; } 
public boolean isClosed ( ) { if ( isEmpty ( ) ) return false ; Contour lastContour = contours . get ( contours . size ( ) - 1 ) ; return lastContour . isClosed ( ) ; } 
public Path resampleByAmount ( int amount , boolean perContour ) { if ( perContour ) { Path p = cloneAndClear ( ) ; 
public Path resampleByLength ( float segmentLength ) { Path p = cloneAndClear ( ) ; for ( Contour c : contours ) { p . add ( c . resampleByLength ( segmentLength ) ) ; } return p ; } 
public void testMakePoints ( ) { Create a continuous line from 0,0 to 100,0. The line is composed of one path from 0-50 and another path with two contours, from 50-75 and 75-100. Path p1 = new Path(); p1.line(0, 0, 50, 0); Path p2 = new Path(); p2.line(50, 0, 75, 0); p2.line(75, 0, 100, 0); Group g = new Group(); g.add(p1); g.add(p2); assertEquals(100f, g.getLength()); Point[] points = g.makePoints(5); assertPointEquals(0, 0, points[0]); assertPointEquals(25, 0, points[1]); assertPointEquals(50, 0, points[2]); assertPointEquals(75, 0, points[3]); assertPointEquals(100, 0, points[4]); Achieve the same result using resampleByAmount. Group resampledGroup = g.resampleByAmount(5, false); List<Point> resampledPoints = resampledGroup.getPoints(); assertPointEquals(0, 0, resampledPoints.get(0)); assertPointEquals(25, 0, resampledPoints.get(1)); assertPointEquals(50, 0, resampledPoints.get(2)); assertPointEquals(75, 0, resampledPoints.get(3)); assertPointEquals(100, 0, resampledPoints.get(4)); } 
public void testMultipleContours ( ) { Point [ ] points ; Create a path with separate contours. Each contour describes a side of a rectangle. Path path = new Path(); path.addPoint(0, 0); path.addPoint(SIDE, 0); path.newContour(); path.addPoint(SIDE, 0); path.addPoint(SIDE, SIDE); path.newContour(); path.addPoint(SIDE, SIDE); path.addPoint(0, SIDE); assertEquals(SIDE * 3, path.getLength()); points = path.makePoints(4); assertPointEquals(0, 0, points[0]); assertPointEquals(SIDE, 0, points[1]); assertPointEquals(SIDE, SIDE, points[2]); assertPointEquals(0, SIDE, points[3]); Get the same result by resampling the path. Path resampled = path.resampleByAmount(4, false); List<Point> resampledPoints = resampled.getPoints(); assertPointEquals(0, 0, resampledPoints.get(0)); assertPointEquals(SIDE, 0, resampledPoints.get(1)); assertPointEquals(SIDE, SIDE, resampledPoints.get(2)); assertPointEquals(0, SIDE, resampledPoints.get(3)); } 
public void inheritFromContext ( GraphicsContext ctx ) { } Object methods public abstract Grob clone();} 
public void map ( java . util . List < Point > points ) { float [ ] coords = new float [ points . size ( ) * 2 ] ; int i = 0 ; for ( Point pt : points ) { coords [ i + + ] = pt . x ; coords [ i + + ] = pt . y ; } affineTransform . transform ( coords , 0 , coords , 0 , points . size ( ) ) ; i = 0 ; for ( Point pt : points ) { pt . x = coords [ i + + ] ; 
public void addPoint ( Point pt ) { points . add ( pt . clone ( ) ) ; invalidate ( ) ; } 
public void addPoint ( float x , float y ) { points . add ( new Point ( x , y ) ) ; invalidate ( ) ; } 
public void close ( ) { this . closed = true ; invalidate ( ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(GeneralPath.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { if (points.size() == 0) return; Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); int pointCount = getPointCount(); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); } } if (closed) gp.closePath(); } public void transform(Transform t) { t.map(getPoints()); invalidate(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
public void transform ( Transform ) { . map ( getPoints ( ) ) ; invalidate ( ) ; } 
public void add ( Path path ) { paths . add ( path ) ; currentPath = path ; invalidate ( false ) ; } 
public void clear ( ) { paths . clear ( ) ; currentPath = null ; invalidate ( false ) ; } 
public void extend ( Group g ) { for ( Path path : g . paths ) { paths . add ( path . clone ( ) ) ; } invalidate ( false ) ; } 
public void addPoint ( Point pt ) { ensureCurrentPath ( ) ; currentPath . addPoint ( pt ) ; invalidate ( false ) ; } 
public void addPoint ( float x , float y ) { ensureCurrentPath ( ) ; currentPath . addPoint ( x , y ) ; invalidate ( false ) ; } 
private void invalidate ( boolean recursive ) { lengthDirty = true ; if ( recursive ) { for ( Path path : paths ) { 
public void transform ( Transform ) { for ( Path path : paths ) { path . transform ( ) ; } invalidate ( true ) ; } 
public void close ( ) { if ( currentContour ! = null ) currentContour . close ( ) ; currentContour = null ; invalidate ( false ) ; } 
public void addPoint ( Point pt ) { ensureCurrentContour ( ) ; currentContour . addPoint ( pt ) ; invalidate ( false ) ; } 
public void addPoint ( float x , float y ) { ensureCurrentContour ( ) ; currentContour . addPoint ( x , y ) ; invalidate ( false ) ; } 
private void invalidate ( boolean recursive ) { pathDirty = true ; lengthDirty = true ; if ( recursive ) { for ( Contour c : contours ) { 
public void add ( Contour c ) { contours . add ( c ) ; currentContour = c ; invalidate ( false ) ; } 
public void clear ( ) { contours . clear ( ) ; currentContour = null ; invalidate ( false ) ; } 
public void extend ( Path p ) { for ( Contour c : p . contours ) { contours . add ( c . clone ( ) ) ; } invalidate ( false ) ; } 
public void extend ( Shape s ) { PathIterator pi = s . getPathIterator ( new AffineTransform ( ) ) ; float px = 0 ; float py = 0 ; while ( ! pi . isDone ( ) ) { float [ ] points = new float [ 6 ] ; int cmd = pi . currentSegment ( points ) ; if ( cmd = = PathIterator . SEG_MOVETO ) { px = points [ 0 ] ; py = points [ 1 ] ; moveto ( px , py ) ; } else if ( cmd = = PathIterator . SEG_LINETO ) { px = points [ 0 ] ; py = points [ 1 ] ; lineto ( px , py ) ; } else if ( cmd = = PathIterator . SEG_QUADTO ) { Convert the quadratic bezier to a cubic bezier. float c1x = px + (points[0] - px) * 2f / 3f; float c1y = py + (points[1] - py) * 2f / 3f; float c2x = points[0] + (points[2] - points[0]) / 3f; float c2y = points[1] + (points[3] - points[1]) / 3f; curveto(c1x, c1y, c2x, c2y, points[2], points[3]); px = points[2]; py = points[3]; } else if (cmd == PathIterator.SEG_CUBICTO) { px = points[4]; py = points[5]; curveto(points[0], points[1], points[2], points[3], px, py); } else if (cmd == PathIterator.SEG_CLOSE) { px = py = 0; close(); } else { throw new AssertionError("Unknown path command " + cmd); } pi.next(); } invalidate(false); } 
public void transform ( Transform ) { . map ( getPoints ( ) ) ; invalidate ( true ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public Path clone ( ) { return new Path ( this ) ; } public Path cloneAndClear ( ) { return new Path ( this , false ) ; } } 
public void testCacheInvalidation ( ) { Contour c = new Contour ( ) ; c . addPoint ( 0 , 0 ) ; c . addPoint ( 50 , 0 ) ; assertEquals ( 50 f , c . getLength ( ) ) ; Manually change the last point. Point lastPoint = c.getPoints().get(1); lastPoint.x = 100; This change is not detected by the contour and thus the length is not updated. assertEquals(50f, c.getLength()); Manually invalidate the contour. c.invalidate(); This time, the length is correct. assertEquals(100f, c.getLength()); } 
public void testCacheInvalidation ( ) { Group g = new Group ( ) ; assertEquals ( 0f , g . getLength ( ) ) ; Path p1 = new Path ( ) ; p1 . line ( 0 , 0 , 50 , 0 ) ; g . add ( p1 ) ; assertEquals ( 50 f , g . getLength ( ) ) ; Change the Path after it was added to the Group. p1.line(50, 0, 75, 0); This change is not detected by the Group, and thus the length is not updated. assertEquals(50f, g.getLength()); Manually invalidate the group. g.invalidate(); This time, the length is correct. assertEquals(75f, g.getLength()); Manually change the position of the last point. Point pt = g.getPoints().get(3); pt.x = 100; This change is not detected by the Path, and thus the length is not updated. assertEquals(75f, g.getLength()); Manually invalidate the path. g.invalidate(); This time, the length is correct. assertEquals(100f, g.getLength()); } 
public void testCacheInvalidation ( ) { Path p = new Path ( ) ; assertEquals ( 0f , p . getLength ( ) ) ; p . line ( 0 , 0 , 50 , 0 ) ; assertEquals ( 50 f , p . getLength ( ) ) ; Contour c = new Contour ( ) ; c . addPoint ( 50 , 0 ) ; c . addPoint ( 75 , 0 ) ; p . add ( c ) ; assertEquals ( 75 f , p . getLength ( ) ) ; Manually change the position of the last point. Point pt = c.getPoints().get(1); pt.x = 100; This change is not detected by the Path, and thus the length is not updated. assertEquals(75f, p.getLength()); Manually invalidate the path. p.invalidate(); This time, the length is correct. assertEquals(100f, p.getLength()); } 
public void testWidgetChanges ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter alpha will be converted from a float to a string widget. Parameter pAlpha = n.addParameter("alpha", Parameter.Type.FLOAT); pAlpha.setValue(12.5f); assertEquals(Parameter.Widget.FLOAT, pAlpha.getWidget()); Change the widget to a string. pAlpha.setWidget(Parameter.Widget.STRING); This should change the underlying type and value. assertEquals(Parameter.Type.STRING, pAlpha.getType()); assertEquals(String.class, pAlpha.getValue().getClass()); assertEquals("12.5", pAlpha.getValue()); Parameter beta will be converted from color to int. Parameter pBeta = n.addParameter("beta", Parameter.Type.COLOR); assertEquals(Parameter.Widget.COLOR, pBeta.getWidget()); pBeta.setValue(new Color(0.1, 0.2, 0.3, 0.4)); Change the widget to int. pBeta.setWidget(Parameter.Widget.INT); This will change the type and widget to int. assertEquals(Parameter.Type.INT, pBeta.getType()); assertEquals(Parameter.Widget.INT, pBeta.getWidget()); The value can't be migrated, so the default value for int is used. assertEquals(Parameter.getDefaultValue(Parameter.Type.INT), pBeta.getValue()); } 
public static void main ( String [ ] args ) { JFrame editorFrame = new JFrame ( ) ; Node node = new NodeBoxDocument . AllControlsType ( ) . createInstance ( ) ; node . addPort ( " shape " , Object . class ) ; editorFrame . getContentPane ( ) . add ( new NodeAttributesEditor ( node ) ) ; editorFrame . setSize ( 580 , 710 ) ; editorFrame . setResizable ( false ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; editorFrame . setVisible ( true ) ; } 
private void addRow ( String label , JComponent component ) { JLabel l = new JLabel ( label ) ; l . setFont ( PlatformUtils . getSmallBoldFont ( ) ) ; l . setBounds ( 18 , y , 400 , 18 ) ; add ( l ) ; y + = 18 ; int componentHeight = ( int ) component . getPreferredSize ( ) . getHeight ( ) ; component . setBounds ( 16 , y , 400 , componentHeight ) ; y + = componentHeight ; y + = 2 ; vertical gap add(component); } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Name nameField = new JFormattedTextField(20); nameField.setEditable(false); addRow("Name", nameField); Label labelField = new JTextField(20); labelField.addActionListener(this); labelField.addFocusListener(this); addRow("Label", labelField); Help Text helpTextField = new JTextField(20); helpTextField.addActionListener(this); helpTextField.addFocusListener(this); addRow("Help Text", helpTextField); Widget widgetBox = new JComboBox(Parameter.Widget.values()); widgetBox.addActionListener(this); addRow("Type", widgetBox); Value valueField = new JTextField(20); valueField.addActionListener(this); valueField.addFocusListener(this); addRow("Value", valueField); Bounding Method boundingMethodBox = new JComboBox(new String[]{"none", "soft", "hard"}); boundingMethodBox.addActionListener(this); addRow("Bounding", boundingMethodBox); Minimum Value minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); minimumValueField.addFocusListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); addRow("Minimum", minimumValuePanel); Maximum Value maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); maximumValueField.addFocusListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); addRow("Maximum", maximumValuePanel); Display Level displayLevelBox = new JComboBox(new String[]{"hud", "detail", "hidden"}); displayLevelBox.addActionListener(this); addRow("Display Level", displayLevelBox); Menu Items menuItemsTable = new JTable(new MenuItemsModel()); menuItemsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); JPanel tablePanel = new JPanel(new BorderLayout(5, 5)); JScrollPane tableScroll = new JScrollPane(menuItemsTable, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); tableScroll.setSize(200, 200); tableScroll.setPreferredSize(new Dimension(200, 200)); tableScroll.setMaximumSize(new Dimension(200, 200)); tableScroll.setMinimumSize(new Dimension(200, 200)); tablePanel.add(tableScroll, BorderLayout.CENTER); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 5)); addButton = new JButton(new Icons.PlusIcon()); addButton.addActionListener(this); removeButton = new JButton(new Icons.MinusIcon()); removeButton.addActionListener(this); upButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.NORTH)); upButton.addActionListener(this); downButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.SOUTH)); downButton.addActionListener(this); buttonPanel.add(addButton); buttonPanel.add(removeButton); buttonPanel.add(upButton); buttonPanel.add(downButton); tablePanel.add(buttonPanel, BorderLayout.SOUTH); addRow("Menu Items", tablePanel); } 
public void updateValues ( ) { nameField . setText ( parameter . getName ( ) ) ; labelField . setText ( parameter . getLabel ( ) ) ; helpTextField . setText ( parameter . getHelpText ( ) ) ; widgetBox . setSelectedItem ( parameter . getWidget ( ) ) ; valueField . setText ( parameter . getValue ( ) . toString ( ) ) ; Parameter . BoundingMethod boundingMethod = parameter . getBoundingMethod ( ) ; boundingMethodBox . setSelectedItem ( boundingMethod . toString ( ) . toLowerCase ( ) ) ; Object minimumValue = parameter . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = parameter . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; displayLevelBox . setSelectedItem ( parameter . getDisplayLevel ( ) . toString ( ) . toLowerCase ( ) ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
public void editMetadata ( ) { if ( node = = null ) return ; NodeAttributesEditor editor = new NodeAttributesEditor ( node ) ; JFrame editorFrame = new JFrame ( node . getName ( ) + " Metadata " ) ; editorFrame . getContentPane ( ) . add ( editor ) ; editorFrame . setSize ( 580 , 710 ) ; editorFrame . setResizable ( false ) ; Center the frame based on the current window. Window w = SwingUtilities.getWindowAncestor(this); if (w == null) { If the current window could not be found, set to the default location. editorFrame.setLocationByPlatform(true); } else { int ancestorCenterX = w.getX() + w.getWidth() / 2; int ancestorCenterY = w.getY() + w.getHeight() / 2; int x = ancestorCenterX - editorFrame.getWidth() / 2; int y = ancestorCenterY - editorFrame.getHeight() / 2; editorFrame.setLocation(x, y); } editorFrame.setVisible(true); } 
public static double radians ( double degrees ) { return degrees * Math . PI / 180 ; } 
public static double degrees ( double radians ) { return radians * 180 / Math . PI ; } 
public static double angle ( double x0 , double y0 , double x1 , double y1 ) { return degrees ( Math . atan2 ( y1 - y0 , x1 - x0 ) ) ; } 
public static double distance ( double x0 , double y0 , double x1 , double y1 ) { return Math . sqrt ( Math . pow ( x1 - x0 , 2 ) + Math . pow ( y1 - y0 , 2 ) ) ; } 
public static double [ ] coordinates ( double x0 , double y0 , double distance , double angle ) { double [ ] point = new double [ 2 ] ; point [ 0 ] = x0 + Math . cos ( radians ( angle ) ) * distance ; point [ 1 ] = y0 + Math . sin ( radians ( angle ) ) * distance ; return point ; } 
public static double [ ] reflect ( double x0 , double y0 , double x1 , double y1 , double d , double a ) { d * = distance ( x0 , y0 , x1 , y1 ) ; a + = angle ( x0 , y0 , x1 , y1 ) ; return coordinates ( x0 , y0 , d , a ) ; } 
public void mouseClicked ( MouseEvent e ) { requestFocus ( ) ; if ( handle = = null ) return ; handle . mouseClicked ( pointForEvent ( e ) ) ; } 
public void mousePressed ( MouseEvent e ) { requestFocus ( ) ; if ( handle = = null ) return ; handle . mousePressed ( pointForEvent ( e ) ) ; } 
public void mouseReleased ( MouseEvent e ) { requestFocus ( ) ; if ( handle = = null ) return ; handle . mouseReleased ( pointForEvent ( e ) ) ; } 
public void mouseEntered ( MouseEvent e ) { requestFocus ( ) ; if ( handle = = null ) return ; handle . mouseEntered ( pointForEvent ( e ) ) ; } 
public void mouseExited ( MouseEvent e ) { requestFocus ( ) ; if ( handle = = null ) return ; handle . mouseExited ( pointForEvent ( e ) ) ; } 
public void mouseDragged ( MouseEvent e ) { requestFocus ( ) ; if ( handle = = null ) return ; handle . mouseDragged ( pointForEvent ( e ) ) ; } 
public void mouseMoved ( MouseEvent e ) { requestFocus ( ) ; if ( handle = = null ) return ; handle . mouseMoved ( pointForEvent ( e ) ) ; } 
public void keyTyped ( KeyEvent e ) { if ( handle = = null ) return ; handle . keyTyped ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; } 
public void keyPressed ( KeyEvent e ) { if ( handle = = null ) return ; handle . keyPressed ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; } 
public void keyReleased ( KeyEvent e ) { if ( handle = = null ) return ; handle . keyReleased ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; } 
public void mouseClicked ( Point pt ) { } public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void keyReleased ( int keyCode , int modifiers ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public boolean hasDragState ( ) { return dragState ! = DragState . NONE ; } 
public Node getNode ( ) ; public void draw ( GraphicsContext ctx ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void draw ( GraphicsContext ctx ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void mouseClicked ( Point pt ) ; public void mousePressed ( Point pt ) ; public void mouseReleased ( Point pt ) ; public void mouseEntered ( Point pt ) ; public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public void mousePressed ( Point pt ) ; public void mouseReleased ( Point pt ) ; public void mouseEntered ( Point pt ) ; public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public void mouseReleased ( Point pt ) ; public void mouseEntered ( Point pt ) ; public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public void mouseEntered ( Point pt ) ; public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public void mouseExited ( Point pt ) ; public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public void mouseDragged ( Point pt ) ; public void mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public void mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public boolean reload ( ) { if ( node = = null ) return false ; Parameter pCode = node . getParameter ( codeType ) ; Parameter pCode = node.getParameter("_code"); if (pCode == null) return false; NodeCode code = new PythonCode(editor.getSource()); pCode.set(code); if (codeType.equals("_handle")) getDocument().setActiveNode(node); to make Viewer reload handle return true; } 
public void mousePressed ( MouseEvent e ) { Rectangle bounds = getBounds ( ) ; paneTypePopup.show(this, bounds.x, bounds.y + bounds.height - 4); paneCodePopup.show(this, 5, bounds.y + bounds.height - 4); } 
public void actionPerformed ( ActionEvent e ) { ( ( EditorPane ) getPane ( ) ) . setCodeType ( codeName , codeType ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Full width minus left side and right side int contentWidth = getWidth() - 9 - 21; g.drawImage(paneMenuLeft, 0, 0, null); g.drawImage(paneMenuBackground, 9, 0, contentWidth, 21, null); g.drawImage(paneMenuRight, 9 + contentWidth, 0, null); g2.setFont(SwingUtils.FONT_BOLD); g2.setColor(SwingUtils.COLOR_NORMAL); SwingUtils.drawShadowText(g2, getMenuName(), 9, 14); } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } 
public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } 
public void mousePressed ( MouseEvent e ) { Rectangle bounds = getBounds ( ) ; paneTypePopup.show(this, bounds.x, bounds.y + bounds.height - 4); paneTypePopup.show(this, 5, bounds.y + bounds.height - 4); } 
public void actionPerformed ( ActionEvent e ) { getPane ( ) . changePaneType ( paneType ) ; } 
public Iterator iterator ( ) { List list = new ArrayList ( ) ; list . add ( x ) ; list . add ( y ) ; list . add ( width ) ; list . add ( height ) ; return list . iterator ( ) ; } 
public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) { NodeView nv = getNodeView ( child ) ; if ( nv = = null ) return ; The port is part of the icon. If a port was added or removed, also update the icon. if (attribute == NodeAttributeListener.Attribute.PORT) { nv.updateIcon(); } if (attribute == NodeAttributeListener.Attribute.NAME || attribute == NodeAttributeListener.Attribute.IMAGE 
public Port addPort ( String name , Class dataClass , Port . Cardinality cardinality ) { Port p = new Port ( this , name , dataClass , cardinality ) ; ports . put ( name , p ) ; if ( parent ! = null ) { if ( parent . childGraph = = null ) parent . childGraph = new DependencyGraph < Port , Connection > ( ) ; parent . childGraph . addDependency ( p , outputPort ) ; } fireNodeAttributeChanged ( Attribute . PORT ) ; return p ; } 
private static void showException ( Thread , Throwable e ) { String msg = String . format ( Locale . US , " Unexpected problem on thread %s: %s " , . getName ( ) , e . getMessage ( ) ) ; logException ( , e ) ; note: in a real app, you should locate the currently focused frame or dialog and use it as the parent. In this example, I'm just passing a null owner, which means this dialog may get buried behind some other screen. ExceptionDialog ed = new ExceptionDialog(null, e); ed.setVisible(true); } 
public String toString ( ) { return String . format ( Locale . US , " InvalidNameException on %s name %s: %s " , source , name , getMessage ( ) ) ; } 
public String toString ( ) { if ( prototype = = null ) { return String . format ( Locale . US , " <Node %s> " , getIdentifier ( ) ) ; 
public void noParameterOrPortError ( String name ) { throw Py . AttributeError ( String . format ( Locale . US , " Node '%.50s' has no parameter or port '%.400s' " , node . getIdentifier ( ) , name ) ) ; 
public void testLocale ( ) { Locale savedLocale = Locale . getDefault ( ) ; The german locale uses a comma to separate the decimals, which makes expressions fail. Locale.setDefault(Locale.GERMAN); Node n = Node.ROOT_NODE.newInstance(testLibrary, "allControls"); Parameter pColor = n.addParameter("color", Parameter.Type.COLOR); assertEquals("color(0.00, 0.00, 0.00, 1.00)", pColor.asExpression()); Locale.setDefault(savedLocale); } 
public static void initializePython ( ) { Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = PlatformUtils.getUserDataDirectory() + PlatformUtils.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. String workingDirectory = System.getProperty("user.dir"); File pythonLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "python.zip"); File svgLibrary = new File(workingDirectory, "lib" + PlatformUtils.SEP + "svg.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Py.getSystemState().path.add(new PyString(svgLibrary.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(PlatformUtils.getUserPythonDirectory().getAbsolutePath())); } 
public static void write ( NodeLibrary library , File file ) { StreamResult streamResult = new StreamResult ( file ) ; write ( library , streamResult ) ; 
public static void write ( NodeLibrary library , Writer writer ) { StreamResult streamResult = new StreamResult ( writer ) ; write ( library , streamResult ) ; } 
public static void write ( NodeLibrary library , StreamResult streamResult ) { try { DocumentBuilder builder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; 
public static String asString ( NodeLibrary library ) { StringWriter writer = new StringWriter ( ) ; write ( library , writer ) ; return writer . toString ( ) ; } 
private static void writeOrderedChild ( NodeLibrary library , Document doc , Element parent , List < Node > children , Node child ) { Node prototype = child . getPrototype ( ) ; if ( prototype . getLibrary ( ) = = library & & children . contains ( prototype ) ) writeOrderedChild ( library , doc , parent , children , prototype ) ; writeNode ( doc , parent , child ) ; children . remove ( child ) ; } 
private static void writePort ( Document doc , Element parent , Port port ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = port.getNode().getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getPort(port.getName()); If the port and its prototype are equal, don't write anything. if (protoPort != null && protoPort.getName().equals(port.getName()) && protoPort.getDataClass().equals(port.getDataClass()) && protoPort.getDirection().equals(port.getDirection()) && protoPort.getCardinality().equals(port.getCardinality())) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); el.setAttribute("type", port.getDataClass().getName()); if (port.getCardinality() != Port.Cardinality.SINGLE) el.setAttribute("cardinality", port.getCardinality().toString().toLowerCase()); parent.appendChild(el); } 
private static void attributeToXml ( Parameter param , Element el , String attrName , String xmlName , Parameter protoParam , Object defaultValue ) { try { String methodName = " get " + attrName . substring ( 0 , 1 ) . toUpperCase ( ) + attrName . substring ( 1 ) ; 
private static void appendText ( Document doc , Element parent , String name , Object text ) { Element el = doc . createElement ( name ) ; el . appendChild ( doc . createTextNode ( text . toString ( ) ) ) ; parent . appendChild ( el ) ; } 
public void setExpression ( String parameterName , String expression ) throws ExpressionError { Parameter p = parameters . get ( parameterName ) ; if ( p = = null ) throw new IllegalArgumentException ( " Parameter " + parameterName + " does not exist. " ) ; p . setExpression ( expression ) ; } 
public void store ( File f ) throws IOException { NDBXWriter . write ( this , f ) ; } 
public String toXml ( ) { return NDBXWriter . asString ( this ) ; } 
public boolean prototypeEquals ( Parameter o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Parameter parameter = ( Parameter ) o ; if ( boundingMethod ! = parameter . boundingMethod ) return false ; if ( displayLevel ! = parameter . displayLevel ) return false ; if ( expression ! = null ? ! expression . equals ( parameter . expression ) : parameter . expression ! = null ) return false ; if ( helpText ! = null ? ! helpText . equals ( parameter . helpText ) : parameter . helpText ! = null ) return false ; if ( ! label . equals ( parameter . label ) ) return false ; if ( maximumValue ! = null ? ! maximumValue . equals ( parameter . maximumValue ) : parameter . maximumValue ! = null ) return false ; if ( ! menuItems . equals ( parameter . menuItems ) ) return false ; if ( minimumValue ! = null ? ! minimumValue . equals ( parameter . minimumValue ) : parameter . minimumValue ! = null ) return false ; if ( ! name . equals ( parameter . name ) ) return false ; if ( type ! = parameter . type ) return false ; if ( expression = = null ) if ( value ! = null ? ! value . equals ( parameter . value ) : parameter . value ! = null ) return false ; if ( widget ! = parameter . widget ) return false ; return true ; } 
public void testPortTypes ( ) { NodeLibrary typeLib = new NodeLibrary ( " typeLib " ) ; Node . ROOT_NODE . newInstance ( typeLib , " alpha " , Polygon . class ) ; String xml = typeLib . toXml ( ) ; NodeLibrary library = parseXml ( xml ) ; Node alpha = library . get ( " alpha " ) ; assertEquals ( Polygon . class , alpha . getOutputPort ( ) . getDataClass ( ) ) ; Create a new instance with the same output type. Store it in a temporary node library. NodeLibrary betaLibrary = new NodeLibrary("xxx"); alpha.newInstance(betaLibrary, "beta"); String s = betaLibrary.toXml(); The output type is the same, so should not be persisted. assertFalse(s.contains("Polygon")); Check if ports have their types persisted. Node n = Node.ROOT_NODE.newInstance(typeLib, "gamma"); n.addPort("string", String.class); n.addPort("polygon", Polygon.class); xml = typeLib.toXml(); library = parseXml(xml); Node gamma = library.get("gamma"); assertEquals(String.class, gamma.getPort("string").getDataClass()); assertEquals(Polygon.class, gamma.getPort("polygon").getDataClass()); } 
public void testStoreChildren ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node net = Node . ROOT_NODE . newInstance ( library , " net " , Polygon . class ) ; Node alpha = net . create ( Node . ROOT_NODE , " alpha " , Polygon . class ) ; Node beta = net . create ( Node . ROOT_NODE , " beta " , Polygon . class ) ; Port pPolygon = beta . addPort ( " polygon " , Polygon . class ) ; pPolygon . connect ( alpha ) ; String xml = library . toXml ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , xml , manager ) ; Node newNet = newLibrary . get ( " net " ) ; assertTrue ( newNet . hasChildren ( ) ) ; Node newAlpha = newNet . getChild ( " alpha " ) ; Node newBeta = newNet . getChild ( " beta " ) ; assertTrue ( newBeta . isConnectedTo ( newAlpha ) ) ; } 
public void testEntityEncoding ( ) { String [ ] testStrings = { " test " , A regular string, for sanity checking "&", The ampersand is used to encode entities "\"", Double quote needs to be escaped in XML attributes "\'", Single quote could cause some problems also "<", XML open tag needs to be escaped in XML text ">", XML close tag needs to be escaped in XML text "<![CDATA[", Beginning CDATA section "]]>", End of CDATA section "<![CDATA[test]]>", Full CDATA section }; for (String testString : testStrings) { assertCanStoreValue(Parameter.Type.STRING, testString); 
public void assertCanStoreHelpText ( String helpText ) { Create a library and node to store the value. NodeLibrary library = new NodeLibrary("test"); Node alpha = Node.ROOT_NODE.newInstance(library, "alpha", Polygon.class); Parameter pValue = alpha.addParameter("value", Parameter.Type.STRING); pValue.setHelpText(helpText); Store the library to XML. String xml = library.toXml(); Load the library from the XML, and retrieve the value. NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.get("alpha"); Parameter newValue = newAlpha.getParameter("value"); assertEquals(helpText, newValue.getHelpText()); } 
public void assertCanStoreValue ( Parameter . Type type , Object value ) { Create a library and node to store the value. NodeLibrary library = new NodeLibrary("test"); Node alpha = Node.ROOT_NODE.newInstance(library, "alpha", Polygon.class); alpha.addParameter("value", type, value); Store the library to XML. String xml = library.toXml(); Load the library from the XML, and retrieve the value. NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.get("alpha"); assertEquals(value, newAlpha.getValue("value")); } 
public int asInt ( ) throws ExpressionError { Object value = evaluate ( ) ; if ( value instanceof Number ) { return ( Integer ) value ; 
public double asFloat ( ) throws ExpressionError { Object value = evaluate ( ) ; if ( value instanceof Number ) { return ( Double ) value ; 
public String asString ( ) throws ExpressionError { Object value = evaluate ( ) ; if ( value instanceof String ) { return ( String ) value ; 
public Color asColor ( ) throws ExpressionError { Object value = evaluate ( ) ; if ( value instanceof Color ) { return ( Color ) value ; 
public void compile ( ) throws ExpressionError { ExpressionCompiler compiler = new ExpressionCompiler ( expression ) ; try { this . compiledExpression = compiler . compile ( parserContext ) ; 
public Object evaluate ( ProcessingContext context ) throws ExpressionError { If there was an error with the expression, throw it before doing anything. if (hasError()) { throw new ExpressionError("Cannot compile expression '" + expression + "' on " + getParameter().getAbsolutePath(), getError()); } If the expression was not compiled, compile it first. This can throw an ExpressionError, which will be forwarded to the caller. if (compiledExpression == null) { compile(); } Set up state variables in the expression utilities class. TODO: This is not thread-safe. ExpressionHelper.currentContext = context; ExpressionHelper.currentParameter = parameter; Marked parameter references are used to find which parameters this expression references. markedParameterReferences = new HashSet<WeakReference<Parameter>>(); ProxyResolverFactory prf = new ProxyResolverFactory(parameter.getNode(), context, markedParameterReferences); try { error = null; 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Expression other = ( Expression ) o ; return expression . equals ( other . expression ) ; } 
public void update ( ProcessingContext ctx ) throws ProcessingError { if ( ! dirty ) return ; try { updateDependencies ( ctx ) ; } catch ( ProcessingError e ) { Updating the dependencies causes this node to fail as well. dirty = false; error = e; outputPort.setValue(null); throw e; } All dependencies are up-to-date. Process the node. ProcessingError pe = null; try { process(ctx); } catch (ProcessingError e) { pe = e; } Even if an error occurred the node is still marked as clean, and events are fired. Only after these steps is the error thrown. It is important to mark the node as clean so that subsequent changes to the node mark it as dirty, triggering an event. This allows you to fix the cause of the error in the node. dirty = false; fireNodeUpdated(ctx); If exception occurs, throw it. if (pe != null) throw pe; 
public boolean hasExpressionError ( ) { return hasExpression ( ) & & expression . hasError ( ) ; } 
public boolean dependsOn ( Parameter other ) { return getLibrary ( ) . getParameterDependencies ( this ) . contains ( other ) ; } 
private void dependencyChangedEvent ( Parameter p ) { markDirty ( ) ; } 
public void testSimple ( ) throws ExpressionError { Node = numberNode . newInstance ( testLibrary , " number " ) ; Parameter pValue = . getParameter ( " value " ) ; Expression e = new Expression ( pValue , " 1 + 2 " ) ; assertEquals ( 3 , e . asInt ( ) ) ; } 
public void testNodeLocal ( ) throws ExpressionError { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node addDirect = net . create ( addDirectNode ) ; Parameter p1 = addDirect . getParameter ( " v1 " ) ; Parameter p2 = addDirect . getParameter ( " v2 " ) ; p2 . setValue ( 12 ) ; assertExpressionEquals ( 12 , p1 , " v2 " ) ; } 
public void testExpressionErrors ( ) throws ExpressionError { Setting an expression immediately evaluates it, but does not throw an exception if the expression is invalid. Instead, you need to check hasParameterExpression. Node test = Node.ROOT_NODE.newInstance(testLibrary, "test"); Parameter pX = test.addParameter("x", Parameter.Type.INT, 3); assertInvalidExpression(pX, "y", "could not access: y"); Parameter pY = test.addParameter("y", Parameter.Type.INT, 5); assertExpressionEquals(5, pX, "y"); Expression of parameter x is still set to "y" assertEquals("y", pX.getExpression()); } 
public void testDependencyRemoval ( ) throws ExpressionError { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Node beta = Node . ROOT_NODE . newInstance ( testLibrary , " beta " ) ; Node gamma = Node . ROOT_NODE . newInstance ( testLibrary , " gamma " ) ; Parameter aValue = alpha . addParameter ( " value " , Parameter . Type . INT , 42 ) ; Parameter bValue = beta . addParameter ( " value " , Parameter . Type . INT , 33 ) ; Parameter gValue = gamma . addParameter ( " value " , Parameter . Type . INT ) ; gamma.value depends on alpha.value. gamma.setExpression("value", "alpha.value"); assertTrue(gValue.dependsOn(aValue)); gamma.update(); assertEquals(42, gamma.getValue("value")); gamma.value depends on beta.value. gamma.setExpression("value", "beta.value"); assertFalse(gValue.dependsOn(aValue)); assertTrue(gValue.dependsOn(bValue)); gamma.update(); assertEquals(33, gamma.getValue("value")); gamma.value no longer depends on alpha or beta. gamma.setExpression("value", "10 + 1"); assertFalse(gValue.dependsOn(aValue)); assertFalse(gValue.dependsOn(bValue)); gamma.update(); assertEquals(11, gamma.getValue("value")); } 
public void testDependencyRemovalOnError ( ) throws ExpressionError { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Node beta = Node . ROOT_NODE . newInstance ( testLibrary , " beta " ) ; Parameter aValue = alpha . addParameter ( " value " , Parameter . Type . INT , 42 ) ; Parameter bValue = beta . addParameter ( " value " , Parameter . Type . INT ) ; Create a good expression, replace it with a bad expression. beta.setExpression("value", "alpha.value"); assertTrue(bValue.dependsOn(aValue)); beta.update(); assertEquals(42, beta.getValue("value")); Replace the good expression with an invalid expression. assertInvalidExpression(bValue, "****", "not a statement"); Check that the dependency was removed. assertFalse(bValue.dependsOn(aValue)); Create a "semi-good" expression: one that can evaluate up to a certain point. assertInvalidExpression(bValue, "alpha.value + xxx", "could not access: xxx"); assertFalse(bValue.dependsOn(aValue)); } 
public void testDirtyOnError ( ) { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter aValue = alpha . addParameter ( " value " , Parameter . Type . INT , 42 ) ; assertTrue ( alpha . isDirty ( ) ) ; alpha . update ( ) ; assertFalse ( alpha . isDirty ( ) ) ; assertInvalidExpression ( aValue , " **** " , " not a statement " ) ; assertTrue ( alpha . isDirty ( ) ) ; try { alpha . update ( ) ; } catch ( ProcessingError e ) { assertTrue ( e . getMessage ( ) . toLowerCase ( ) . contains ( " cannot compile expression " ) ) ; } assertEquals ( 42 , aValue . getValue ( ) ) ; } 
public void testDeadDependencies ( ) throws ExpressionError { Node test = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pX = test . addParameter ( " x " , Parameter . Type . INT , 3 ) ; Parameter pY = test . addParameter ( " y " , Parameter . Type . INT , 5 ) ; pX . setExpression ( " y " ) ; assertTrue ( pX . dependsOn ( pY ) ) ; pX . update ( new ProcessingContext ( ) ) ; assertEquals ( 5 , pX . getValue ( ) ) ; test . removeParameter ( " y " ) ; At this point, the parameter dependency should no longer exist. assertFalse(pX.getDependencies().contains(pY)); try { pX.update(new ProcessingContext()); fail(); } catch (ExpressionError e) { update throws an error since the expression references a parameter that cannot be found. throw e; assertTrue(e.getCause().getMessage().toLowerCase().contains("unable to resolve variable 'y'")); } The value hasn't changed. assertEquals(5, pX.getValue()); } 
public void testCycles ( ) throws ExpressionError { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node number1 = net . create ( numberNode ) ; Node addDirect1 = net . create ( addDirectNode ) ; Parameter pValue = number1 . getParameter ( " value " ) ; Parameter pV1 = addDirect1 . getParameter ( " v1 " ) ; Parameter pV2 = addDirect1 . getParameter ( " v2 " ) ; Create a direct cycle. assertInvalidExpression(pValue, "value", "refers to itself"); This should not have created any connections assertTrue(pValue.getDependencies().isEmpty()); Set a direct value to number1.value. Clear the expression first. pValue.clearExpression(); pValue.set(42); assertExpressionEquals(42, pV1, "number1.value"); Create a 2-node cycle with expressions assertInvalidExpression(pValue, "addDirect1.v1", "cyclic dependency"); Now create a 2-parameter cycle within the same node. pV1.setExpression("v2"); addDirect1.update(); assertInvalidExpression(pV2, "v1", "cyclic dependency"); } 
public void testNetworkLocal ( ) throws ExpressionError { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; net . addParameter ( " pn " , Parameter . Type . INT , 33 ) ; Node number1 = net . create ( numberNode ) ; Parameter pValue1 = number1 . getParameter ( " value " ) ; pValue1 . set ( 84 ) ; assertEquals ( " number1 " , number1 . getName ( ) ) ; Parameter p1 = test1.addParameter("p1", Parameter.Type.INT); Node number2 = net.create(numberNode); assertEquals("number2", number2.getName()); Parameter p2 = number2.addParameter("p2", Parameter.Type.INT); Parameter pValue2 = number2.getParameter("value"); pValue2.set(12); Trying to get the value of number2 by just using the expression "value" is impossible, since it will retrieve the value parameter of number1, which will cause a cycle. assertInvalidExpression(pValue1, "value", "refers to itself"); Access p2 through the node name. assertExpressionEquals(12, pValue1, "number2.value"); Access p2 through the network. assertExpressionEquals(12, pValue1, "parent.number2.value"); Access the pn Parameter on the network. assertExpressionEquals(33, pValue1, "parent.pn"); } 
public void assertExpressionEquals ( Object expected , Parameter p , String expression ) throws ExpressionError { We don't catch the ExpressionError but let it bubble up. p.setExpression(expression); p.update(new ProcessingContext()); assertEquals(expected, p.getValue()); } 
private void assertInvalidExpression ( Parameter p , String expression , String expectedMessage ) { p . setExpression ( expression ) ; if ( ! p . hasExpressionError ( ) ) { fail ( " Expression should have failed with \" " + expectedMessage + " \" " ) ; 
public void testChildDataPropagation ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " , Integer . class ) ; Node n1 = net . create ( numberNode ) ; n1 . setRendered ( ) ; net . update ( ) ; assertEquals ( 0 , net . getOutputValue ( ) ) ; This should mark the net as dirty. n1.setValue("value", 42); assertTrue(net.isDirty()); net.update(); assertEquals(42, net.getOutputValue()); n1.setExpression("value", "10 + 1"); assertTrue(net.isDirty()); net.update(); assertEquals(11, net.getOutputValue()); n1.clearExpression("value"); n1.setValue("value", 33); assertTrue(net.isDirty()); net.update(); assertEquals(33, net.getOutputValue()); } 
public void testErrorPropagation ( ) { Node net = Node . ROOT_NODE . newInstance ( testLibrary , " net " , Integer . class ) ; Node number1 = net . create ( numberNode ) ; Set an invalid expression. This error is caused by a parameter on the number1 node, therefore the number1 node should have its error flag set. number1.setExpression("value", "***"); number1.setRendered(); try { net.update(); fail("Update should have thrown an error."); } catch (ProcessingError e) { The network also has its error flag set since errors propagate. assertTrue(net.hasError()); assertTrue(number1.hasError()); assertFalse(net.isDirty()); assertFalse(number1.isDirty()); } Fix the error by clearing the expression and setting a regular value. number1.clearExpression("value"); number1.setValue("value", 42); assertTrue(net.isDirty()); net.update(); assertFalse(net.hasError()); assertFalse(number1.hasError()); assertEquals(42, number1.getOutputValue()); assertEquals(42, net.getOutputValue()); } 
public void testStoreWithExpressionErrors ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " ) ; Parameter pValue = alpha . addParameter ( " value " , Parameter . Type . INT ) ; assertCanStoreExpression ( pValue , " 10 + 1 " ) ; Correct expression. assertCanStoreExpression(pValue, "12 + ????"); Compilation error. assertCanStoreExpression(pValue, "y"); Evaluation error: y does not exist. alpha.addParameter("bob", Parameter.Type.INT); assertCanStoreExpression(pValue, "bob"); Correct since bob exists. alpha.removeParameter("bob"); assertCanStoreExpression(pValue, "bob"); Bob is gone, but the script still needs to save. } 
public void assertCanStoreExpression ( Parameter p , String expression ) { String nodeName = p . getNode ( ) . getName ( ) ; String parameterName = p . getName ( ) ; p . setExpression ( expression ) ; String xml = p . getLibrary ( ) . toXml ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , xml , manager ) ; Node newAlpha = newLibrary . get ( nodeName ) ; Parameter newParameter = newAlpha . getParameter ( parameterName ) ; assertEquals ( expression , newParameter . getExpression ( ) ) ; } 
public void testExpressionError ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; . setExpression ( " value " , " *** " ) ; try { . update ( ) ; fail ( " Should have caused an exception. " ) ; } catch ( ProcessingError e ) { assertTrue ( e . getCause ( ) . toString ( ) . toLowerCase ( ) . contains ( " cannot compile expression " ) ) ; assertTrue ( . hasError ( ) ) ; As stated in Node#update(ProcessingContext), even if an error occurred the node is still marked as clean and events are fired. It is important to mark the node as clean so that subsequent changes to the node mark it as dirty, triggering an event. This allows you to fix the cause of the error in the node. assertFalse(n.isDirty()); assertNull(n.getOutputValue()); } n.setExpression("value", "10 + 1"); assertTrue(n.isDirty()); n.update(); assertFalse(n.hasError()); assertFalse(n.isDirty()); assertEquals(11, n.getOutputValue()); } 
public void testDependencyError ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node negate1 = net . create ( negateNode ) ; Node crash1 = net . create ( crashNode ) ; negate1 . getPort ( " value " ) . connect ( crash1 ) ; try { negate1 . update ( ) ; 
public void testRemoveExpressionDependency ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node number1 = net . create ( numberNode ) ; number1 . addParameter ( " bob " , Parameter . Type . INT , 10 ) ; number1 . setExpression ( " value " , " bob " ) ; number1 . setRendered ( ) ; net . update ( ) ; assertEquals ( 10 , net . getOutputValue ( ) ) ; number1 . removeParameter ( " bob " ) ; try { net . update ( ) ; fail ( ) ; } catch ( ProcessingError e ) { assertTrue ( e . getCause ( ) . getMessage ( ) . toLowerCase ( ) . contains ( " cannot evaluate expression " ) ) ; } assertTrue ( net . hasError ( ) ) ; assertTrue ( number1 . hasError ( ) ) ; assertNull ( net . getOutputValue ( ) ) ; } 
public void testMarkStampedDirty ( ) throws ExpressionError { Setup a graph where a <- b <- c. Node a = Node.ROOT_NODE.newInstance(testLibrary, "a", Integer.class); Node b = Node.ROOT_NODE.newInstance(testLibrary, "b", Integer.class); Node c = Node.ROOT_NODE.newInstance(testLibrary, "c", Integer.class); a.addParameter("a", Parameter.Type.INT); b.addParameter("b", Parameter.Type.INT); Port bIn = b.addPort("in", Integer.class); Port cIn = c.addPort("in", Integer.class); bIn.connect(a); cIn.connect(b); Update the graph. This will make a, b and c clean. c.update(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); Set b to a stamped expression. This will make node b, and all of its dependencies, dirty. b.setExpression("b", "stamp(\"my_b\", 55)"); assertTrue(b.hasStampExpression()); assertFalse(a.isDirty()); assertTrue(b.isDirty()); assertTrue(c.isDirty()); Update the graph, cleaning all of the nodes. c.update(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); Mark only stamped upstream nodes as dirty. This will make b dirty, and all of its dependencies. c.stampDirty(); assertFalse(a.isDirty()); assertTrue(b.isDirty()); assertTrue(c.isDirty()); Remove the expression and update. This will make all nodes clean again. b.clearExpression("b"); c.update(); Node b will not be dirty, since everything was updated. assertFalse(b.isDirty()); Since there are no nodes with stamp expressions, marking the stamped upstream nodes will have no effect. c.stampDirty(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; manager = new NodeLibraryManager ( ) ; testNodes = new TestNodes ( ) ; testLibrary = new NodeLibrary ( " test " ) ; polygraphLibrary = new PolygraphLibrary ( ) ; manager . add ( testNodes ) ; manager . add ( polygraphLibrary ) ; numberNode = manager . getNode ( " testlib.number " ) ; negateNode = manager . getNode ( " testlib.negate " ) ; addNode = manager . getNode ( " testlib.add " ) ; addDirectNode = manager . getNode ( " testlib.addDirect " ) ; addConstantNode = manager . getNode ( " testlib.addConstant " ) ; multiplyNode = manager . getNode ( " testlib.multiply " ) ; multiAddNode = manager . getNode ( " testlib.multiAdd " ) ; floatNegateNode = manager . getNode ( " testlib.floatNegate " ) ; convertToUppercaseNode = manager . getNode ( " testlib.convertToUppercase " ) ; crashNode = manager . getNode ( " testlib.crash " ) ; testNetworkNode = manager . getNode ( " testlib.testnet " ) ; polygonNode = manager . getNode ( " polygraph.polygon " ) ; rectNode = manager . getNode ( " polygraph.rect " ) ; translateNode = manager . getNode ( " polygraph.translate " ) ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " crash " , Integer . class ) ; . addPort ( " value " , Integer . class ) ; return ; } 
public Object cook ( Node node , ProcessingContext context ) { int a = 0 ; return 1 / a ; } 
public void windowOpened ( WindowEvent e ) { } public void windowClosing ( WindowEvent e ) { close ( ) ; } public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!node.isDirty()) return; markChanged(); updateActiveNetwork(); } }); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!node.isDirty()) return; markChanged(); updateActiveNetwork(); } }); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!node.isDirty()) return; markChanged(); updateActiveNetwork(); } }); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!node.isDirty()) return; markChanged(); updateActiveNetwork(); } }); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!node.isDirty()) return; markChanged(); updateActiveNetwork(); } }); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!node.isDirty()) return; markChanged(); updateActiveNetwork(); } }); } private void updateActiveNetwork() { try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void nodeDirty ( final Node node ) { if ( node ! = activeNetwork ) return ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { If meanwhile the node has been marked clean, ignore the event. if (!node.isDirty()) return; markChanged(); updateActiveNetwork(); } 
public void testLoadingErrors ( ) { Use one manager with the polynodes library loaded in, and restore it using a manager without the polynodes library. NodeLibraryManager manager = new NodeLibraryManager(); manager.load(new File("test/polynodes.ndbx")); NodeLibrary testLibrary = new NodeLibrary("test"); Node polyRect = manager.getNode("polynodes.rect"); polyRect.newInstance(testLibrary, "myrect"); String xml = testLibrary.toXml(); NodeLibraryManager emptyManager = new NodeLibraryManager(); try { emptyManager.load("test", xml); 
public void update ( ProcessingContext ctx ) throws ProcessingError { if ( ! dirty ) return ; Update the dependencies. This might cause an exception which we don't catch, instead letting it boil up. updateDependencies(ctx); All dependencies are up-to-date. Process the node. ProcessingError pe = null; try { process(ctx); } catch (ProcessingError e) { pe = e; } Even if an error occurred the node is still marked as clean, and events are fired. Only after these steps is the error thrown. It is important to mark the node as clean so that subsequent changes to the node mark it as dirty, triggering an event. This allows you to fix the cause of the error in the node. dirty = false; fireNodeUpdated(ctx); If exception occurs, throw it. if (pe != null) throw pe; 
public void updateDependencies ( ProcessingContext ctx ) throws ProcessingError { Update the ports try { updatePorts(ctx); } catch (ProcessingError e) { If an error occurs while updating the ports, this node will fail as well. The error is not saved in this node since it occurred on a dependency. This makes it easier to track down the error. dirty = false; outputPort.setValue(null); throw e; } Update the parameters try { updateParameters(ctx); 
private void updateParameters ( ProcessingContext ctx ) throws ProcessingError { Update all parameter expressions. for (Parameter param : parameters.values()) { try { 
private void updatePorts ( ProcessingContext ctx ) throws ProcessingError { Update all upstream nodes. if (parent != null && parent.childGraph != null) { for (Port port : ports.values()) { 
public void testLength ( ) { Group g = new Group ( ) ; Path p1 = new Path ( ) ; p1 . line ( 0 , 0 , 100 , 0 ) ; Path p2 = new Path ( ) ; p2 . line ( 0 , 100 , 100 , 100 ) ; g . add ( p1 ) ; g . add ( p2 ) ; assertEquals ( 200 , g . getLength ( ) ) ; } 
public void testLengthMultipleContours ( ) { Path p = new Path ( ) ; p . line ( 0 , 0 , 100 , 0 ) ; assertEquals ( 100 f , p . getLength ( ) ) ; p . line ( 0 , 100 , 100 , 100 ) ; assertEquals ( 200 f , p . getLength ( ) ) ; p . close ( ) ; assertEquals ( 300 f , p . getLength ( ) ) ; } 
private boolean smartConnect ( Node activeNode , Node newNode ) { Check if there is an active node. if (activeNode == null) return false; Check if there are compatible ports on the new node that can be connected to the output of the active node. List<Port> compatibles = newNode.getCompatibleInputs(activeNode); if (compatibles.size() == 0) return false; Connect the output of the active node to the first compatible input of the new node. compatibles.get(0).connect(activeNode); Move the node next to the active node. newNode.setPosition(activeNode.getX() + NodeView.NODE_FULL_SIZE + 10, activeNode.getY()); Return true to indicate the connection was created successfully. return true; } 
public void testLength ( ) { Group g = new Group ( ) ; Path p1 = new Path ( ) ; p1 . line ( 0 , 0 , 100 , 0 ) ; Path p2 = new Path ( ) ; p2 . line ( 0 , 100 , 100 , 100 ) ; g . add ( p1 ) ; g . add ( p2 ) ; assertEquals ( 200 f , g . getLength ( ) ) ; } 
public Iterator < Float > iterator ( ) { List < Float > list = new ArrayList < Float > ( ) ; list . add ( x ) ; list . add ( y ) ; list . add ( width ) ; list . add ( height ) ; return list . iterator ( ) ; } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; PopupHandler popupHandler = new PopupHandler ( ) ; addInputEventListener ( popupHandler ) ; } 
private void goDown ( ) { if ( selection . size ( ) ! = 1 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } NodeView selectedNode = selection . iterator ( ) . next ( ) ; NodeBoxDocument . getCurrentDocument ( ) . setActiveNetwork ( selectedNode . getNode ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { goUp ( ) ; } 
public void processEvent ( PInputEvent e , int i ) { if ( ! e . isPopupTrigger ( ) ) return ; JPopupMenu menu = new JPopupMenu ( ) ; menu . add ( new SetRenderedAction ( ) ) ; menu . add ( new RenameAction ( ) ) ; menu . add ( new DeleteAction ( ) ) ; menu . add ( new GoInAction ( ) ) ; Point2D p = e . getCanvasPosition ( ) ; menu . show ( NodeView . this . networkView , ( int ) p . getX ( ) , ( int ) p . getY ( ) ) ; e . setHandled ( true ) ; } 
public void actionPerformed ( ActionEvent e ) { NodeBoxDocument . getCurrentDocument ( ) . setActiveNetwork ( node ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.resetContext(); context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("g", context); interpreter.set("Path", nodebox.graphics.Path.class); interpreter.set("Canvas", nodebox.graphics.Canvas.class); interpreter.set("Color", nodebox.graphics.Color.class); interpreter.set("GraphicsContext", nodebox.graphics.GraphicsContext.class); interpreter.set("Grob", nodebox.graphics.Grob.class); interpreter.set("Path", Path.class); interpreter.set("Geometry", Geometry.class); interpreter.set("Image", nodebox.graphics.Image.class); interpreter.set("NodeBoxError", nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", nodebox.graphics.PathElement.class); interpreter.set("Point", nodebox.graphics.Point.class); interpreter.set("Rect", nodebox.graphics.Rect.class); interpreter.set("Text", nodebox.graphics.Text.class); interpreter.set("Transform", nodebox.graphics.Transform.class); interpreter.set("LEFT", Text.Align.LEFT); interpreter.set("RIGHT", Text.Align.RIGHT); interpreter.set("CENTER", Text.Align.CENTER); interpreter.set("JUSTIFY", Text.Align.JUSTIFY); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
public static NodeBoxDocument createNewGeometryDocument ( ) { tNodeLibrary nodeLibrary = new NodeLibrary ( " untitled " ) ; tNodeLibraryManager manager = Application . getInstance ( ) . getManager ( ) ; tNode geonet = nodeLibrary . getRootNode ( ) . create ( manager . getNode ( " corevector.geonet " ) ) ; geonet . setRendered ( ) ; Node geonet = Node.ROOT_NODE.newInstance(nodeLibrary, "geonet", Geometry.class); NodeBoxDocument doc = new NodeBoxDocument(nodeLibrary); doc.setActiveNetwork(geonet); return doc; } 
public void extend ( Geometry g ) { for ( Path path : g . paths ) { paths . add ( path . clone ( ) ) ; } invalidate ( false ) ; } 
public boolean contains ( Point pt ) { for ( Path p : paths ) { if ( p . contains ( pt ) ) { return true ; } } return false ; } 
public boolean contains ( float x , float y ) { for ( Path p : paths ) { if ( p . contains ( x , y ) ) { return true ; } } return false ; } 
public boolean contains ( Rect r ) { for ( Path p : paths ) { if ( p . contains ( r ) ) { return true ; } } return false ; } 
public Geometry resampleByAmount ( int amount , boolean perContour ) { if ( perContour ) { Geometry g = new Geometry ( ) ; 
public Geometry resampleByLength ( float segmentLength ) { Geometry g = new Geometry ( ) ; for ( Path p : paths ) { g . add ( p . resampleByLength ( segmentLength ) ) ; } return g ; } 
public Geometry asGeometry ( ) { Geometry g = new Geometry ( ) ; g . add ( this ) ; return g ; } 
public Geometry map ( Geometry g ) { Geometry newGeometry = new Geometry ( g ) ; map ( newGeometry . getPoints ( ) ) ; return newGeometry ; } 
public void testBounds ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Geometry g1 = new Geometry ( ) ; g1 . add ( r1 ) ; assertEquals ( Rect . centeredRect ( 10 , 20 , 30 , 40 ) , g1 . getBounds ( ) ) ; } 
public void testTransformedBounds ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Transform = new Transform ( ) ; . translate ( 200 , 300 ) ; r1 . transform ( ) ; Geometry g = new Geometry ( ) ; g . add ( r1 ) ; assertEquals ( Rect . centeredRect ( 210 , 320 , 30 , 40 ) , g . getBounds ( ) ) ; } 
public void testTransformedElements ( ) { Path r1 = new Path ( ) ; r1 . rect ( 10 , 20 , 30 , 40 ) ; Path r2 = new Path ( ) ; r2 . rect ( 10 , 120 , 30 , 40 ) ; Geometry g = new Geometry ( ) ; g . add ( r1 ) ; g . add ( r2 ) ; Rect rect1 = Rect . centeredRect ( 10 , 20 , 30 , 40 ) ; Rect rect2 = Rect . centeredRect ( 10 , 120 , 30 , 40 ) ; assertEquals ( rect1 . united ( rect2 ) , g . getBounds ( ) ) ; } 
public void testAdd ( ) { Path p = new Path ( ) ; p . rect ( 10 , 20 , 30 , 40 ) ; Geometry g = new Geometry ( ) ; g . add ( p ) ; p . transform ( Transform . translated ( 5 , 7 ) ) ; Since the path is in the group and not cloned, the bounds of the group will be those of the translated path. assertEquals(Rect.centeredRect(15, 27, 30, 40), g.getBounds()); } 
public void testColors ( ) { Path p1 = new Path ( ) ; Path p2 = new Path ( ) ; p1 . rect ( 0 , 0 , 100 , 100 ) ; p2 . rect ( 150 , 150 , 100 , 100 ) ; Geometry g = new Geometry ( ) ; g . add ( p1 ) ; g . add ( p2 ) ; assertEquals ( 2 , g . size ( ) ) ; Each path has 4 points. assertEquals(8, g.getPointCount()); Color red = new Color(1, 0, 0); g.setFill(red); assertEquals(red, p1.getFillColor()); assertEquals(red, p2.getFillColor()); } 
public void testMakePoints ( ) { Create a continuous line from 0,0 to 100,0. The line is composed of one path from 0-50 and another path with two contours, from 50-75 and 75-100. Path p1 = new Path(); p1.line(0, 0, 50, 0); Path p2 = new Path(); p2.line(50, 0, 75, 0); p2.line(75, 0, 100, 0); Geometry g = new Geometry(); g.add(p1); g.add(p2); assertEquals(100f, g.getLength()); Point[] points = g.makePoints(5); assertPointEquals(0, 0, points[0]); assertPointEquals(25, 0, points[1]); assertPointEquals(50, 0, points[2]); assertPointEquals(75, 0, points[3]); assertPointEquals(100, 0, points[4]); Achieve the same result using resampleByAmount. Geometry resampledGeometry = g.resampleByAmount(5, false); List<Point> resampledPoints = resampledGeometry.getPoints(); assertPointEquals(0, 0, resampledPoints.get(0)); assertPointEquals(25, 0, resampledPoints.get(1)); assertPointEquals(50, 0, resampledPoints.get(2)); assertPointEquals(75, 0, resampledPoints.get(3)); assertPointEquals(100, 0, resampledPoints.get(4)); } 
public void testCacheInvalidation ( ) { Geometry g = new Geometry ( ) ; assertEquals ( 0f , g . getLength ( ) ) ; Path p1 = new Path ( ) ; p1 . line ( 0 , 0 , 50 , 0 ) ; g . add ( p1 ) ; assertEquals ( 50 f , g . getLength ( ) ) ; Change the Path after it was added to the Geometry. p1.line(50, 0, 75, 0); This change is not detected by the Geometry, and thus the length is not updated. assertEquals(50f, g.getLength()); Manually invalidate the group. g.invalidate(); This time, the length is correct. assertEquals(75f, g.getLength()); Manually change the position of the last point. Point pt = g.getPoints().get(3); pt.x = 100; This change is not detected by the Path, and thus the length is not updated. assertEquals(75f, g.getLength()); Manually invalidate the path. g.invalidate(); This time, the length is correct. assertEquals(100f, g.getLength()); } 
public void testLength ( ) { Geometry g = new Geometry ( ) ; Path p1 = new Path ( ) ; p1 . line ( 0 , 0 , 100 , 0 ) ; Path p2 = new Path ( ) ; p2 . line ( 0 , 100 , 100 , 100 ) ; g . add ( p1 ) ; g . add ( p2 ) ; assertEquals ( 200 f , g . getLength ( ) ) ; } 
private Node createNode ( String name ) { Node prototype = manager . getNode ( " corevector. " + name ) ; return rootNode . create ( prototype ) ; } 
private Geometry updateNode ( Node ) { . update ( ) ; assertNotNull ( . getOutputValue ( ) ) ; assertEquals ( Geometry . class , . getOutputValue ( ) . getClass ( ) ) ; return ( Geometry ) . getOutputValue ( ) ; } 
private void assertUpdateNull ( Node ) { . update ( ) ; assertNull ( . getOutputValue ( ) ) ; } 
public void testGenerator ( ) { Node generator = createNode ( " generator " ) ; Geometry geo = updateNode ( generator ) ; assertEquals ( Rect . centeredRect ( 0 , 0 , 100 , 100 ) , geo . getBounds ( ) ) ; } 
public void testFilter ( ) { Node filter = createNode ( " filter " ) ; assertUpdateNull ( filter ) ; Node generator = createNode ( " generator " ) ; filter . getPort ( " shape " ) . connect ( generator ) ; Geometry geo = updateNode ( filter ) ; Transform = Transform . rotated ( 45 f ) ; Rect r = . map ( Rect . centeredRect ( 0 , 0 , 100 , 100 ) ) ; TODO: Check geometry on this. 
public void testEllipse ( ) { Node ellipse = createNode ( " ellipse " ) ; Geometry geo = updateNode ( ellipse ) ; assertEquals ( Rect . centeredRect ( 0 , 0 , 100 , 100 ) , geo . getBounds ( ) ) ; } 
public static void main ( String [ ] args ) { JFrame editorFrame = new JFrame ( ) ; Node node = new NodeBoxDocument . AllControlsType ( ) . createInstance ( ) ; node . addPort ( " shape " ) ; editorFrame . getContentPane ( ) . add ( new NodeAttributesEditor ( node ) ) ; editorFrame . setSize ( 580 , 710 ) ; editorFrame . setResizable ( false ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; editorFrame . setVisible ( true ) ; } 
public void initPanel ( ) { setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; JPanel contentPanel = new JPanel ( new GridLayout ( 3 , 2 , 10 , 5 ) ) ; Name contentPanel.add(new JLabel("Name")); nameField = new JTextField(20); nameField.setEnabled(false); contentPanel.add(nameField); Cardinality contentPanel.add(new JLabel("Cardinality")); cardinalityBox = new JComboBox(Port.Cardinality.values()); cardinalityBox.setEnabled(false); contentPanel.add(cardinalityBox); add(contentPanel); Dimension fillDimension = new Dimension(0, Integer.MAX_VALUE); add(new Box.Filler(fillDimension, fillDimension, fillDimension)); } 
public void updateValues ( ) { nameField . setText ( port . getName ( ) ) ; cardinalityBox . setSelectedItem ( port . getCardinality ( ) ) ; revalidate ( ) ; } 
private void startPortTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( PORT_NAME ) ; String cardinalityAsString = attributes . getValue ( PORT_CARDINALITY ) ; if ( name = = null ) throw new SAXException ( " Name is required for port on node ' " + currentNode . getName ( ) + " '. " ) ; Port . Cardinality cardinality = Port . Cardinality . SINGLE ; if ( cardinalityAsString ! = null ) { try { cardinality = Port . Cardinality . valueOf ( cardinalityAsString . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { throw new SAXException ( " Invalid cardinality attribute in port tag: should be single or multiple, not " + cardinalityAsString + " . " ) ; } } currentNode . addPort ( name , cardinality ) ; } 
private static void writePort ( Document doc , Element parent , Port port ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = port.getNode().getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getPort(port.getName()); If the port and its prototype are equal, don't write anything. if (protoPort != null && protoPort.getName().equals(port.getName()) && protoPort.getDirection().equals(port.getDirection()) && protoPort.getCardinality().equals(port.getCardinality())) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); if (port.getCardinality() != Port.Cardinality.SINGLE) el.setAttribute("cardinality", port.getCardinality().toString().toLowerCase()); parent.appendChild(el); } 
public Node create ( Node prototype , String name , Class dataClass ) { if ( prototype = = null ) throw new IllegalArgumentException ( " Prototype cannot be null. " ) ; if ( dataClass = = null ) dataClass = prototype . getDataClass ( ) ; if ( name = = null ) name = uniqueName ( prototype . getName ( ) ) ; Node newNode = prototype . rawInstance ( library , name , dataClass ) ; add ( newNode ) ; return newNode ; } 
public void validate ( Object value ) throws IllegalArgumentException { Null is accepted as a default value. if (value == null) return; if (!getDataClass().isAssignableFrom(value.getClass())) throw new IllegalArgumentException("Value " + value + " is not of required class (was " + value.getClass() + ", required " + getDataClass()); 
public Port addPort ( String name ) { return addPort ( name , Port . Cardinality . SINGLE ) ; } 
public Port addPort ( String name , Port . Cardinality cardinality ) { Port p = new Port ( this , name , cardinality ) ; ports . put ( name , p ) ; if ( parent ! = null ) { if ( parent . childGraph = = null ) parent . childGraph = new DependencyGraph < Port , Connection > ( ) ; parent . childGraph . addDependency ( p , outputPort ) ; } fireNodeAttributeChanged ( Attribute . PORT ) ; return p ; } 
public Node newInstance ( NodeLibrary library , String name ) { return newInstance ( library , name , getDataClass ( ) ) ; } 
private Node rawInstance ( NodeLibrary library , String name , Class dataClass ) { if ( library = = null ) throw new IllegalArgumentException ( " Library parameter cannot be null. " ) ; if ( dataClass = = null ) dataClass = getDataClass ( ) ; Node = new Node ( library , name , dataClass ) ; . prototype = this ; . dirty = true ; Clone all parameters. for (Parameter p : parameters.values()) { n.parameters.put(p.getName(), p.clone(n)); } Clone all ports. for (Port p : ports.values()) { n.ports.put(p.getName(), p.clone(n)); } return n; } 
public void validate ( Object value ) throws IllegalArgumentException { node . validate ( value ) ; } 
public boolean canConnectTo ( Port outputPort ) { if ( outputPort = = null ) return false ; if ( outputPort = = this ) return false ; if ( outputPort . getDirection ( ) ! = Direction . OUT ) return false ; An input port can only be connected to an output port. Since we just checked the direction of the output port, we need to make sure if this port is an input. if (direction != Direction.IN) return false; Check if the data classes match. They can either be equal, or the output type can be downcasted to the input type. Class inputClass = node.getDataClass(); Class outputClass = outputPort.node.getDataClass(); return inputClass.isAssignableFrom(outputClass); } 
public Port clone ( Node ) { return new Port ( , getName ( ) , getCardinality ( ) , getDirection ( ) ) ; } 
public void testConnectCasting ( ) { Node upstream , downstream ; Both are of the same type. Should be able to connect. upstream = Node.ROOT_NODE.newInstance(testLibrary, "upstream", HashMap.class); downstream = Node.ROOT_NODE.newInstance(testLibrary, "downstream", HashMap.class); downstream.addPort("value"); downstream.getPort("value").connect(upstream); Reset the library testLibrary = new NodeLibrary("test"); Upstream is a more specific type, which is allowed. upstream = Node.ROOT_NODE.newInstance(testLibrary, "upstream", LinkedHashMap.class); downstream = Node.ROOT_NODE.newInstance(testLibrary, "downstream", HashMap.class); downstream.addPort("value"); downstream.getPort("value").connect(upstream); Reset the library testLibrary = new NodeLibrary("test"); Now downstream is more specific, which is NOT allowed. upstream = Node.ROOT_NODE.newInstance(testLibrary, "upstream", HashMap.class); downstream = Node.ROOT_NODE.newInstance(testLibrary, "downstream", LinkedHashMap.class); downstream.addPort("value"); assertConnectionError(downstream, "value", upstream, "Downstream is a more specific type."); Reset the library testLibrary = new NodeLibrary("test"); Downstream is an interface which upstream implements. upstream = Node.ROOT_NODE.newInstance(testLibrary, "upstream", LinkedHashMap.class); downstream = Node.ROOT_NODE.newInstance(testLibrary, "downstream", Map.class); downstream.addPort("value"); downstream.getPort("value").connect(upstream); } 
public void testPortTypes ( ) { NodeLibrary typeLib = new NodeLibrary ( " typeLib " ) ; Node . ROOT_NODE . newInstance ( typeLib , " alpha " , Polygon . class ) ; String xml = typeLib . toXml ( ) ; NodeLibrary library = parseXml ( xml ) ; Node alpha = library . get ( " alpha " ) ; assertEquals ( Polygon . class , alpha . getDataClass ( ) ) ; Create a new instance with the same output type. Store it in a temporary node library. NodeLibrary betaLibrary = new NodeLibrary("xxx"); alpha.newInstance(betaLibrary, "beta"); String s = betaLibrary.toXml(); The output type is the same, so should not be persisted. assertFalse(s.contains("Polygon")); Check if ports have their types persisted. Node n = Node.ROOT_NODE.newInstance(typeLib, "gamma", Polygon.class); n.addPort("polygon"); xml = typeLib.toXml(); library = parseXml(xml); Node gamma = library.get("gamma"); assertEquals(Polygon.class, gamma.getDataClass()); } 
private void loadBasicTypes ( ) { NodeLibrary testlib = new NodeLibrary ( " testlib " ) ; Node dot = Node . ROOT_NODE . newInstance ( testlib , " dot " , Polygon . class ) ; testlib . add ( dot ) ; dot . addParameter ( " x " , Parameter . Type . FLOAT , 0F ) ; dot . addParameter ( " y " , Parameter . Type . FLOAT , 0F ) ; Node rotate = Node . ROOT_NODE . newInstance ( testlib , " rotate " , Polygon . class ) ; testlib . add ( rotate ) ; rotate . addPort ( " shape " ) ; rotate . addParameter ( " rotation " , Parameter . Type . FLOAT , 0F ) ; manager . add ( testlib ) ; } 
public void testStoreConnections ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " , Polygon . class ) ; Node beta = Node . ROOT_NODE . newInstance ( library , " beta " , Polygon . class ) ; beta . addPort ( " polygon " ) ; beta . getPort ( " polygon " ) . connect ( alpha ) ; assertTrue ( alpha . isConnectedTo ( beta ) ) ; assertTrue ( beta . isConnectedTo ( alpha ) ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , library . toXml ( ) , manager ) ; Node newAlpha = newLibrary . get ( " alpha " ) ; Node newBeta = newLibrary . get ( " beta " ) ; assertTrue ( newAlpha . isConnectedTo ( newBeta ) ) ; assertTrue ( newBeta . isConnectedTo ( newAlpha ) ) ; } 
public void testStoreChildren ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node net = Node . ROOT_NODE . newInstance ( library , " net " , Polygon . class ) ; Node alpha = net . create ( Node . ROOT_NODE , " alpha " , Polygon . class ) ; Node beta = net . create ( Node . ROOT_NODE , " beta " , Polygon . class ) ; Port pPolygon = beta . addPort ( " polygon " ) ; pPolygon . connect ( alpha ) ; String xml = library . toXml ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , xml , manager ) ; Node newNet = newLibrary . get ( " net " ) ; assertTrue ( newNet . hasChildren ( ) ) ; Node newAlpha = newNet . getChild ( " alpha " ) ; Node newBeta = newNet . getChild ( " beta " ) ; assertTrue ( newBeta . isConnectedTo ( newAlpha ) ) ; } 
public void testPortAttributes ( ) { Node nodeA = Node . ROOT_NODE . newInstance ( testLibrary , " A " , String . class ) ; assertEquals ( String . class , nodeA . getDataClass ( ) ) ; Port outputPort = nodeA . getOutputPort ( ) ; assertEquals ( " output " , outputPort . getName ( ) ) ; assertEquals ( Port . Direction . OUT , outputPort . getDirection ( ) ) ; assertEquals ( null , outputPort . getValue ( ) ) ; Port stringPort = nodeA . addPort ( " stringPort " ) ; assertEquals ( " stringPort " , stringPort . getName ( ) ) ; assertEquals ( Port . Direction . IN , stringPort . getDirection ( ) ) ; assertEquals ( null , stringPort . getValue ( ) ) ; } 
public void testPortPropagation ( ) { Node nodeA = Node . ROOT_NODE . newInstance ( testLibrary , " A " , Polygon . class ) ; nodeA . addPort ( " polygon " ) ; Node nodeB = nodeA . newInstance ( testLibrary , " B " ) ; assertTrue ( nodeB . hasPort ( " polygon " ) ) ; assertEquals ( Polygon . class , nodeB . getDataClass ( ) ) ; } 
public void testStampExpression ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node stamp1 = Node . ROOT_NODE . newInstance ( testLibrary , " stamp1 " , Integer . class ) ; stamp1 . addPort ( " value " ) ; stamp1 . getPort ( " value " ) . connect ( number1 ) ; The code prepares upstream dependencies for stamping, processes them and negates the output. String stampCode = "def cook(self):" + " context.put('my_a', 99)" + " self.node.stampDirty()" + " self.node.updateDependencies(context)" + " return -self.value # Negate the output"; stamp1.setValue("_code", new PythonCode(stampCode)); Parameter pValue = number1.getParameter("value"); Set number1 to a regular value. This should not influence the stamp operation. pValue.set(12); stamp1.update(); assertEquals(-12, stamp1.getOutputValue()); Set number1 to an expression. Since we're not using stamp, nothing strange should happen to the output. pValue.setExpression("2 + 1"); stamp1.update(); assertEquals(-3, stamp1.getOutputValue()); Set number1 to an unknown stamp expression. The default value will be picked. pValue.setExpression("stamp(\"xxx\", 19)"); stamp1.update(); assertEquals(-19, stamp1.getOutputValue()); Set number1 to the my_a stamp expression. The expression will be picked up. pValue.setExpression("stamp(\"my_a\", 33)"); stamp1.update(); assertEquals(-99, stamp1.getOutputValue()); } 
public void testMarkStampedDirty ( ) throws ExpressionError { Setup a graph where a <- b <- c. Node a = Node.ROOT_NODE.newInstance(testLibrary, "a", Integer.class); Node b = Node.ROOT_NODE.newInstance(testLibrary, "b", Integer.class); Node c = Node.ROOT_NODE.newInstance(testLibrary, "c", Integer.class); a.addParameter("a", Parameter.Type.INT); b.addParameter("b", Parameter.Type.INT); Port bIn = b.addPort("in"); Port cIn = c.addPort("in"); bIn.connect(a); cIn.connect(b); Update the graph. This will make a, b and c clean. c.update(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); Set b to a stamped expression. This will make node b, and all of its dependencies, dirty. b.setExpression("b", "stamp(\"my_b\", 55)"); assertTrue(b.hasStampExpression()); assertFalse(a.isDirty()); assertTrue(b.isDirty()); assertTrue(c.isDirty()); Update the graph, cleaning all of the nodes. c.update(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); Mark only stamped upstream nodes as dirty. This will make b dirty, and all of its dependencies. c.stampDirty(); assertFalse(a.isDirty()); assertTrue(b.isDirty()); assertTrue(c.isDirty()); Remove the expression and update. This will make all nodes clean again. b.clearExpression("b"); c.update(); Node b will not be dirty, since everything was updated. assertFalse(b.isDirty()); Since there are no nodes with stamp expressions, marking the stamped upstream nodes will have no effect. c.stampDirty(); assertFalse(a.isDirty()); assertFalse(b.isDirty()); assertFalse(c.isDirty()); } 
public void testNaming ( ) { Node = numberNode . newInstance ( testLibrary , " number1 " ) ; assertInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; assertInvalidName ( , " node " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " root " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " network " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " context " , " names can not be one of the reserved words. " ) ; assertInvalidName ( , " __reserved " , " names cannot start with double underscores " ) ; assertInvalidName ( , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " " , " names cannot be empty " ) ; assertInvalidName ( , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; assertValidName ( , " radius " ) ; assertValidName ( , " _test " ) ; assertValidName ( , " _ " ) ; assertValidName ( , " _1234 " ) ; assertValidName ( , " a1234 " ) ; assertValidName ( , " UPPERCASE " ) ; assertValidName ( , " uPpercase " ) ; assertInvalidName ( , " radius " , " parameter names must be unique for the node " ) ; . addPort ( " myport " ) ; assertInvalidName ( , " myport " , " parameter names must be unique across parameters and ports " ) ; } 
public void testValidate ( ) { Node customType = numberNode . newInstance ( testLibrary , " number1 " ) ; Parameter pFloat = customType . addParameter ( " float " , Parameter . Type . FLOAT ) ; assertInvalidValue ( pFloat , " A " ) ; assertInvalidValue ( pFloat , new Color ( ) ) ; assertInvalidValue ( pFloat , new Polygon ( ) ) ; assertValidValue ( pFloat , 1F ) ; As a special exception, floating-point parameters can also accept integers assertValidValue(pFloat, 1); Parameter pInt = customType.addParameter("int", Parameter.Type.INT); assertInvalidValue(pInt, "A"); assertInvalidValue(pInt, new Color()); assertInvalidValue(pInt, new Polygon()); assertValidValue(pInt, 1); You cannot assign floating-point values to integers, so the above exception to the rule only works in one way. assertInvalidValue(pInt, 1F); Parameter pColor = customType.addParameter("color", Parameter.Type.COLOR); assertInvalidValue(pColor, "A"); assertInvalidValue(pColor, 2); assertValidValue(pColor, new Color()); Toggle has a hard bounded range between 0 and 1. Parameter ptToggle = customType.addParameter("toggle", Parameter.Type.INT); ptToggle.setBoundingMethod(Parameter.BoundingMethod.HARD); ptToggle.setMinimumValue(0F); ptToggle.setMaximumValue(1F); assertInvalidValue(ptToggle, "A"); assertInvalidValue(ptToggle, -1); assertInvalidValue(ptToggle, 100); assertValidValue(ptToggle, 0); assertValidValue(ptToggle, 1); } 
private Node nodeWithDataClass ( String name , Class dataClass ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , name , dataClass ) ; . addPort ( " p " ) ; return ; } 
public void testDowncasting ( ) { Node grobNode = nodeWithDataClass ( " grob " , Grob . class ) ; Node canvasNode = nodeWithDataClass ( " canvas " , Canvas . class ) ; Node imageNode = nodeWithDataClass ( " image " , Image . class ) ; Node pathNode = nodeWithDataClass ( " path " , Path . class ) ; Node textNode = nodeWithDataClass ( " text " , Text . class ) ; Canvas canvas = new Canvas ( ) ; Image image = new Image ( ) ; Path path = new Path ( ) ; Text text = new Text ( " " , 0 , 0 ) ; assertValidValue ( grobNode , canvas ) ; assertValidValue ( grobNode , image ) ; assertValidValue ( grobNode , path ) ; assertValidValue ( grobNode , text ) ; assertValidValue ( canvasNode , canvas ) ; assertInvalidValue ( canvasNode , image ) ; assertInvalidValue ( canvasNode , path ) ; assertInvalidValue ( canvasNode , text ) ; assertInvalidValue ( imageNode , canvas ) ; assertValidValue ( imageNode , image ) ; assertInvalidValue ( imageNode , path ) ; assertInvalidValue ( imageNode , text ) ; assertInvalidValue ( pathNode , canvas ) ; assertInvalidValue ( pathNode , image ) ; assertValidValue ( pathNode , path ) ; assertInvalidValue ( pathNode , text ) ; assertInvalidValue ( textNode , canvas ) ; assertInvalidValue ( textNode , image ) ; assertInvalidValue ( textNode , path ) ; assertValidValue ( textNode , text ) ; 
public void testCardinality ( ) { Node test = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; test . addPort ( " single " ) ; test . addPort ( " multiple " , Port . Cardinality . MULTIPLE ) ; assertEquals ( Port . Cardinality . SINGLE , test . getPort ( " single " ) . getCardinality ( ) ) ; assertEquals ( Port . Cardinality . MULTIPLE , test . getPort ( " multiple " ) . getCardinality ( ) ) ; Now clone this instance and check cardinality. Node cloned = test.newInstance(testLibrary, "cloned"); assertEquals(Port.Cardinality.SINGLE, cloned.getPort("single").getCardinality()); assertEquals(Port.Cardinality.MULTIPLE, cloned.getPort("multiple").getCardinality()); } 
private void assertInvalidName ( Node , String newName , String reason ) { try { . addPort ( newName ) ; 
private void assertValidName ( Node , String newName ) { try { . addPort ( newName ) ; 
private void assertValidValue ( Node , Object value ) { try { . getPort ( " p " ) . validate ( value ) ; 
private void assertInvalidValue ( Node , Object value ) { try { . getPort ( " p " ) . validate ( value ) ; 
public void testSelf ( ) { Node node1 = Node . ROOT_NODE . newInstance ( testLibrary , " node1 " , Polygon . class ) ; node1 . addParameter ( " alpha " , Parameter . Type . INT , 42 ) ; assertSnippetEquals ( 42 , " self.alpha " , node1 ) ; node1 . addPort ( " polygon " ) ; node1 . setPortValue ( " polygon " , Polygon . rect ( 20 , 30 , 40 , 50 ) ) ; assertSnippetEquals ( new Rectangle ( 20 , 30 , 40 , 50 ) , " self.polygon.bounds " , node1 ) ; } 
public void testBasicFilter ( ) { Node rect1 = rectNode . newInstance ( testLibrary , " rect1 " ) ; Node mover = Node . ROOT_NODE . newInstance ( testLibrary , " mover " , Polygon . class ) ; mover . addPort ( " polygon " ) ; mover . addParameter ( " tx " , Parameter . Type . INT , 10 ) ; mover . addParameter ( " ty " , Parameter . Type . INT , 20 ) ; PythonCode code = new PythonCode ( " def cook(self): " + " return self.polygon.translated(self.tx, self.ty) " ) ; mover . setValue ( " _code " , code ) ; mover . getPort ( " polygon " ) . connect ( rect1 ) ; mover . update ( ) ; Polygon polygon = ( Polygon ) mover . getOutputValue ( ) ; assertEquals ( new Rectangle ( 10 , 20 , 100 , 100 ) , polygon . getBounds ( ) ) ; } 
public void testMultiPort ( ) { Node multiAdd = Node . ROOT_NODE . newInstance ( testLibrary , " multiAdd " , Integer . class ) ; Port pValues = multiAdd . addPort ( " values " , Port . Cardinality . MULTIPLE ) ; PythonCode code = new PythonCode ( " def cook(self): return sum(self.values) " ) ; multiAdd . setValue ( " _code " , code ) ; multiAdd . update ( ) ; No values were given, so the output returns 0. assertEquals(0, multiAdd.getOutputValue()); Node number1 = numberNode.newInstance(testLibrary, "number1"); Node number2 = numberNode.newInstance(testLibrary, "number2"); Node number3 = numberNode.newInstance(testLibrary, "number3"); number1.setValue("value", 1); number2.setValue("value", 3); number3.setValue("value", 5); pValues.connect(number1); pValues.connect(number2); pValues.connect(number3); multiAdd.update(); assertEquals(9, multiAdd.getOutputValue()); pValues.disconnect(); multiAdd.update(); assertEquals(0, multiAdd.getOutputValue()); } 
public void testConnecting ( ) { Node stringIn = Node . ROOT_NODE . newInstance ( testLibrary , " stringIn " , String . class ) ; stringIn . addParameter ( " string " , Parameter . Type . STRING ) ; PythonCode stringInCode = new PythonCode ( " def cook(self): n return self.string " ) ; stringIn . setValue ( " _code " , stringInCode ) ; Node upper = Node . ROOT_NODE . newInstance ( testLibrary , " upper " , String . class ) ; upper . addPort ( " string " ) ; PythonCode upperCode = new PythonCode ( " def cook(self): n return self.string.upper() " ) ; upper . setValue ( " _code " , upperCode ) ; upper . getPort ( " string " ) . connect ( stringIn ) ; stringIn . setValue ( " string " , " hello " ) ; upper . update ( ) ; assertEquals ( " HELLO " , upper . getOutputValue ( ) ) ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " number " , Integer . class ) ; . addParameter ( " value " , Parameter . Type . INT ) ; . addPort ( " valuePort " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " negate " , Integer . class ) ; . addPort ( " value " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " add " , Integer . class ) ; . addPort ( " v1 " ) ; . addPort ( " v2 " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " addConstant " , Integer . class ) ; . addPort ( " value " ) ; . addParameter ( " constant " , Parameter . Type . INT ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " multiply " , Integer . class ) ; . addPort ( " v1 " ) ; . addPort ( " v2 " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " multiAdd " , Integer . class ) ; . addPort ( " values " , Port . Cardinality . MULTIPLE ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " floatNegate " , Float . class ) ; . addPort ( " value " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " convertToUppercase " , String . class ) ; . addPort ( " value " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " crash " , Integer . class ) ; . addPort ( " value " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " translate " , Polygon . class ) ; . addPort ( " polygon " ) ; . addParameter ( " tx " , Parameter . Type . FLOAT ) ; . addParameter ( " ty " , Parameter . Type . FLOAT ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " merge " , Polygon . class ) ; . addPort ( " polygons " , Port . Cardinality . MULTIPLE ) ; return ; } 
public int compare ( Node node1 , Node node2 ) { return node1 . getName ( ) . compareTo ( node2 . getName ( ) ) ; } 
public void testStoreOrder ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node . ROOT_NODE . newInstance ( library , " a " ) ; Node . ROOT_NODE . newInstance ( library , " b " ) ; Node . ROOT_NODE . newInstance ( library , " c " ) ; String xml = library . toXml ( ) ; Pattern p = Pattern . compile ( " <node name= \" (.*?) \" " ) ; Matcher m = p . matcher ( xml ) ; m . find ( ) ; assertEquals ( " a " , m . group ( 1 ) ) ; m . find ( ) ; assertEquals ( " b " , m . group ( 1 ) ) ; m . find ( ) ; assertEquals ( " c " , m . group ( 1 ) ) ; } 
public void testStoreOrderPrototypes ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node z = Node . ROOT_NODE . newInstance ( library , " z " ) ; z . newInstance ( library , " a " ) ; z . newInstance ( library , " b " ) ; z . newInstance ( library , " c " ) ; String xml = library . toXml ( ) ; Pattern p = Pattern . compile ( " <node name= \" (.*?) \" " ) ; Matcher m = p . matcher ( xml ) ; m . find ( ) ; assertEquals ( " z " , m . group ( 1 ) ) ; m . find ( ) ; assertEquals ( " a " , m . group ( 1 ) ) ; m . find ( ) ; assertEquals ( " b " , m . group ( 1 ) ) ; m . find ( ) ; assertEquals ( " c " , m . group ( 1 ) ) ; } 
public void reorderOutput ( Port port , int deltaIndex ) { int index = outputs . indexOf ( port ) ; int newIndex = index + deltaIndex ; newIndex = Math . max ( 0 , Math . min ( outputs . size ( ) - 1 , newIndex ) ) ; if ( index = = newIndex ) return ; outputs . remove ( port ) ; outputs . add ( newIndex , port ) ; markDirtyDownstream ( ) ; } 
public void testDisconnectOutputNode ( ) { Setup a simple network where number1 <- addConstant1. Node root = testLibrary.getRootNode(); Node number1 = root.create(numberNode); Node addConstant1 = root.create(addConstantNode); Port pValue = addConstant1.getPort("value"); pValue.connect(number1); Remove the specific connection and check if everything was removed. addConstant1.disconnect(pValue, number1); assertFalse(number1.isConnected()); assertFalse(addConstant1.isConnected()); assertNull(pValue.getConnection()); } 
public void testReorder ( ) { Node root = testLibrary . getRootNode ( ) ; Node number1 = root . create ( numberNode ) ; Node number2 = root . create ( numberNode ) ; Node number3 = root . create ( numberNode ) ; Node multiAdd = root . create ( multiAddNode ) ; Port pValues = multiAdd . getPort ( " values " ) ; pValues . connect ( number1 ) ; pValues . connect ( number2 ) ; pValues . connect ( number3 ) ; assertOrder ( pValues , number1 , number2 , number3 ) ; Move number 2 up. pValues.getConnection().reorderOutput(number2.getOutputPort(), -1); assertOrder(pValues, number2, number1, number3); assertDirtyAndUpdate(multiAdd); Move number 3 down. It was already last, so shouldn't change anything. pValues.getConnection().reorderOutput(number3.getOutputPort(), 1); assertOrder(pValues, number2, number1, number3); assertFalse(multiAdd.isDirty()); Move number 3 up by a large amount. It should just move it to the first position. pValues.getConnection().reorderOutput(number3.getOutputPort(), -5000); assertOrder(pValues, number3, number2, number1); assertDirtyAndUpdate(multiAdd); Move number 2 by a large amount, moving it to the end. pValues.getConnection().reorderOutput(number2.getOutputPort(), 5000); assertOrder(pValues, number3, number1, number2); assertDirtyAndUpdate(multiAdd); Move number 1 by zero places. This should not move anything and not mark the node as dirty. pValues.getConnection().reorderOutput(number1.getOutputPort(), 0); assertOrder(pValues, number3, number1, number2); assertFalse(multiAdd.isDirty()); } 
private void assertOrder ( Port port , Node . . . nodes ) { List < Port > outputs = port . getConnection ( ) . getOutputs ( ) ; for ( int i = 0 ; i < nodes . length ; i + + ) { assertEquals ( nodes [ i ] , outputs . get ( i ) . getNode ( ) ) ; 
private void assertDirtyAndUpdate ( Node node ) { assertTrue ( node . isDirty ( ) ) ; node . update ( ) ; assertFalse ( node . isDirty ( ) ) ; } 
private void moveDown ( ) { Connection c = getConnection ( ) ; if ( c = = null ) return ; Port selectedPort = ( Port ) outputList . getSelectedValue ( ) ; if ( selectedPort = = null ) return ; java . util . List < Port > ports = c . getOutputs ( ) ; int index = ports . indexOf ( selectedPort ) ; assert ( index > = 0 ) ; if ( index > = ports . size ( ) - 1 ) return ; c . reorderOutput ( selectedPort , 1 ) ; reloadList ( ) ; outputList . setSelectedIndex ( index + 1 ) ; input . getNode ( ) . markDirty ( ) ; } 
private void moveUp ( ) { Connection c = getConnection ( ) ; if ( c = = null ) return ; Port selectedPort = ( Port ) outputList . getSelectedValue ( ) ; if ( selectedPort = = null ) return ; java . util . List < Port > ports = c . getOutputs ( ) ; int index = ports . indexOf ( selectedPort ) ; assert ( index > = 0 ) ; if ( index = = 0 ) return ; c . reorderOutput ( selectedPort , - 1 ) ; reloadList ( ) ; outputList . setSelectedIndex ( index - 1 ) ; input . getNode ( ) . markDirty ( ) ; } 
public static void main ( String [ ] args ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node mergeShapes = Node . ROOT_NODE . newInstance ( library , " mergeshapes " , Polygon . class ) ; Node poly1 = Node . ROOT_NODE . newInstance ( library , " poly1 " , Polygon . class ) ; Node poly2 = Node . ROOT_NODE . newInstance ( library , " poly2 " , Polygon . class ) ; Node poly3 = Node . ROOT_NODE . newInstance ( library , " poly3 " , Polygon . class ) ; Port shapesPort = mergeShapes . addPort ( " shapes " , Port . Cardinality . MULTIPLE ) ; shapesPort . connect ( poly1 ) ; shapesPort . connect ( poly2 ) ; shapesPort . connect ( poly3 ) ; JDialog d = new JDialog ( ) ; d . setModal ( true ) ; d . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; MultiConnectionPanel panel = new MultiConnectionPanel ( shapesPort ) ; d . getContentPane ( ) . add ( panel , BorderLayout . CENTER ) ; d . setSize ( 400 , 400 ) ; d . setVisible ( true ) ; } 
public void renderedChildChanged ( Node source , Node child ) { } public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) { } } private class ControlPanel extends JPanel { private ControlPanel ( LayoutManager layout ) { super ( layout ) ; } @Override protected void paintComponent ( Graphics g ) { if ( node = = null ) { Rectangle clip = g . getClipBounds ( ) ; g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; } else { int height = getHeight ( ) ; int width = getWidth ( ) ; g . setColor ( new Color ( 153 , 153 , 153 ) ) ; g . fillRect ( 0 , 0 , LABEL_WIDTH - 3 , height ) ; g . setColor ( new Color ( 146 , 146 , 146 ) ) ; g . fillRect ( LABEL_WIDTH - 3 , 0 , 1 , height ) ; g . setColor ( new Color ( 133 , 133 , 133 ) ) ; g . fillRect ( LABEL_WIDTH - 2 , 0 , 1 , height ) ; g . setColor ( new Color ( 112 , 112 , 112 ) ) ; g . fillRect ( LABEL_WIDTH - 1 , 0 , 1 , height ) ; g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( LABEL_WIDTH , 0 , width - LABEL_WIDTH , height ) ; } } } public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node = manager . getNode ( " corevector.rect " ) . newInstance ( testLibrary , " myrect " ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } } 
public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) { } } private class ControlPanel extends JPanel { private ControlPanel ( LayoutManager layout ) { super ( layout ) ; } @Override protected void paintComponent ( Graphics g ) { if ( node = = null ) { Rectangle clip = g . getClipBounds ( ) ; g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; } else { int height = getHeight ( ) ; int width = getWidth ( ) ; g . setColor ( new Color ( 153 , 153 , 153 ) ) ; g . fillRect ( 0 , 0 , LABEL_WIDTH - 3 , height ) ; g . setColor ( new Color ( 146 , 146 , 146 ) ) ; g . fillRect ( LABEL_WIDTH - 3 , 0 , 1 , height ) ; g . setColor ( new Color ( 133 , 133 , 133 ) ) ; g . fillRect ( LABEL_WIDTH - 2 , 0 , 1 , height ) ; g . setColor ( new Color ( 112 , 112 , 112 ) ) ; g . fillRect ( LABEL_WIDTH - 1 , 0 , 1 , height ) ; g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( LABEL_WIDTH , 0 , width - LABEL_WIDTH , height ) ; } } } public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node = manager . getNode ( " corevector.rect " ) . newInstance ( testLibrary , " myrect " ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { int labelWidth = ParameterView . LABEL_WIDTH ; Draw border on the side of the label g.setColor(labelUp); g.fillRect(x, y + height - 2, labelWidth - 2, 1); g.setColor(labelDown); g.fillRect(x, y + height - 1, labelWidth - 2, 1); Draw border on parameter side g.setColor(parameterUp); g.fillRect(x + labelWidth + 1, y + height - 2, width - labelWidth - 1, 1); g.setColor(parameterDown); g.fillRect(x + labelWidth + 1, y + height - 1, width - labelWidth - 1, 1); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setColor ( SwingUtils . COLOR_NORMAL ) ; g2 . setFont ( SwingUtils . FONT_BOLD ) ; int textX = ParameterView . LABEL_WIDTH - g2 . getFontMetrics ( ) . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = (getHeight() - g2.getFont().getSize()) / 2 + 10; SwingUtils.drawShadowText(g2, getText(), textX, textY, new Color(176, 176, 176), 1); } 
public boolean exportToFile ( File file ) { Make sure the file ends with ".pdf". String fullPath = null; try { fullPath = file.getCanonicalPath(); } catch (IOException e) { throw new RuntimeException("Unable to access file " + file, e); } if (!fullPath.toLowerCase().endsWith(".pdf")) { fullPath = fullPath.concat(".pdf"); } file = new File(fullPath); todo: file export only works on grobs. if (activeNetwork == null || activeNetwork.getRenderedChild() == null) return false; Object outputValue = activeNetwork.getRenderedChild().getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; 
public static void render ( Grob g , File file ) { Rect bounds = g . getBounds ( ) ; I'm using fully qualified class names here so as not to polute the class' namespace. com.lowagie.text.Rectangle size = new com.lowagie.text.Rectangle(bounds.getWidth(), bounds.getHeight()); com.lowagie.text.Document document = new com.lowagie.text.Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } com.lowagie.text.pdf.PdfWriter writer; try { writer = com.lowagie.text.pdf.PdfWriter.getInstance(document, fos); } catch (com.lowagie.text.DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); com.lowagie.text.pdf.PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = contentByte.createGraphics(bounds.getWidth(), bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); g.draw(graphics); graphics.dispose(); document.close(); } 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void draw(GraphicsContext ctx); Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void draw(GraphicsContext ctx); Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void testNegativeBounds ( ) { Path p1 = new Path ( ) ; p1 . rect ( 10 , 20 , 30 , 40 ) ; assertEquals ( Rect . centeredRect ( 10 , 20 , 30 , 40 ) , p1 . getBounds ( ) ) ; Path p2 = new Path ( ) ; p2 . rect ( - 80 , - 200 , 100 , 100 ) ; assertEquals ( Rect . centeredRect ( - 80 , - 200 , 100 , 100 ) , p2 . getBounds ( ) ) ; } 
public void mouseClicked ( Point pt ) { } public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mousePressed ( Point pt ) { } public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseReleased ( Point pt ) { } public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseEntered ( Point pt ) { } public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseExited ( Point pt ) { } public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseDragged ( Point pt ) { } public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void mouseMoved ( Point pt ) { } public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void keyTyped ( int keyCode , int modifiers ) { } public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void keyPressed ( int keyCode , int modifiers ) { } public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void keyReleased ( int keyCode , int modifiers ) { } Node events public void update() { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void update ( ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { Path p = new Path(); p.setFillColor(HANDLE_COLOR); p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); ctx.draw(p); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public Node getNode ( ) ; public void update ( ) ; public void draw ( GraphicsContext ctx ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
protected void paintComponent ( Graphics g ) { java . util . List < Node > nodes = getNetworkParts ( ) ; positions = new int [ nodes . size ( ) ] ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; g2 . drawImage ( addressGradient , 0 , 0 , getWidth ( ) , 25 , null ) ; int x = 14 ; for ( int i = 0 ; i < nodes . size ( ) ; i + + ) { Node part = nodes . get ( i ) ; 
private void init ( ) { this . setMargin ( new Insets ( 0 , 5 , 0 , 5 ) ) ; setFont ( Theme . EDITOR_FONT ) ; setEditorKit ( new PythonEditorKit ( ) ) ; rootElement = getDocument ( ) . getDefaultRootElement ( ) ; todo:this code should be in the kit for (KeyStroke ks : defaultInputMap.allKeys()) { getInputMap().put(ks, defaultInputMap.get(ks)); } addMouseListener(new DragDetector()); } 
public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); Rectangle r = getBounds(); int centerWidth = r.width - draggerLeftWidth - draggerRightWidth; g2.drawImage(draggerLeft, 0, 0, null); g2.drawImage(draggerRight, r.width - draggerRightWidth, 0, null); g2.drawImage(draggerBackground, draggerLeftWidth, 0, centerWidth, draggerHeight, null); g2.setFont(Theme.SMALL_BOLD_FONT); g2.setColor(Theme.TEXT_NORMAL_COLOR); SwingUtils.drawCenteredShadowText(g2, valueAsString(), r.width / 2, 14, Theme.DRAGGABLE_NUMBER_HIGLIGHT_COLOR); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( checked ) { g2 . drawImage ( checkedImage , 0 , 0 , null ) ; } else { g2 . drawImage ( normalImage , 0 , 0 , null ) ; } int w = normalImage . getWidth ( null ) ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; if ( armed ) { g2 . setColor ( Theme . TEXT_ARMED_COLOR ) ; } else { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } SwingUtils . drawShadowText ( g2 , text , w + IMAGE_TEXT_MARGIN , TEXT_BASELINE ) ; } 
protected void paint ( PPaintContext c ) { Graphics2D g = c . getGraphics ( ) ; g . setColor ( Theme . NETWORK_SELECTION_COLOR ) ; PBounds b = getBounds ( ) ; Inset the bounds so we don't draw outside the refresh region. b.inset(1, 1); g.fill(b); g.setColor(Theme.NETWORK_SELECTION_BORDER_COLOR); g.draw(b); } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( selected ) { Rectangle clip = g2 . getClipBounds ( ) ; g2 . setColor ( Theme . NODE_ATTRIBUTES_PARAMETER_COLOR ) ; g2 . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; } g2 . setFont ( Theme . SMALL_FONT ) ; if ( selected ) { g2 . setColor ( Color . WHITE ) ; } else { g2 . setColor ( Color . BLACK ) ; } g2 . drawString ( text , 15 , 18 ) ; } 
public void addHeader ( String s ) { JLabel header = new JLabel ( s ) ; header . setEnabled ( false ) ; header . setForeground ( Theme . TEXT_DISABLED_COLOR ) ; header . setFont ( Theme . SMALL_BOLD_FONT ) ; header . setMinimumSize ( new Dimension ( 100 , 25 ) ) ; header . setMaximumSize ( new Dimension ( 500 , 25 ) ) ; header . setPreferredSize ( new Dimension ( 140 , 25 ) ) ; add ( header ) ; } 
public void updateIcon ( ) { fullIcon = getFullImageForNode ( node , true ) ; } 
protected void paint ( PPaintContext ctx ) { Graphics2D g = ctx . getGraphics ( ) ; Shape clip = g . getClip ( ) ; g . clip ( getBounds ( ) ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; Draw the selection/connection border if (selected && networkView.getConnectionTarget() != this) g.drawImage(nodeGlow, 0, 0, null); if (networkView.getConnectionTarget() == this) g.drawImage(nodeConnectionGlow, 0, 0, null); g.drawImage(fullIcon, 0, 0, null); if (node.hasError()) g.drawImage(nodeError, 0, 0, null); if (node.isRendered()) g.drawImage(nodeRendered, 0, 0, null); g.drawImage(nodeRim, 0, 0, null); Draw the node name. g.setFont(Theme.SMALL_BOLD_FONT); g.setColor(Theme.NETWORK_NODE_NAME_COLOR); int textWidth = g.getFontMetrics().stringWidth(node.getName()); int x = (int) ((NODE_FULL_SIZE - textWidth) / 2f); SwingUtils.drawShadowText(g, node.getName(), x, NODE_FULL_SIZE + 5, Theme.NETWORK_NODE_NAME_SHADOW_COLOR, -1); Reset the clipping. g.setClip(clip); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Full width minus left side and right side int contentWidth = getWidth() - 9 - 21; g.drawImage(paneMenuLeft, 0, 0, null); g.drawImage(paneMenuBackground, 9, 0, contentWidth, 21, null); g.drawImage(paneMenuRight, 9 + contentWidth, 0, null); g2.setFont(Theme.SMALL_BOLD_FONT); g2.setColor(Theme.TEXT_NORMAL_COLOR); SwingUtils.drawShadowText(g2, getMenuName(), 9, 14); } 
private void addRow ( String label , JComponent component ) { JLabel l = new JLabel ( label ) ; l . setFont ( Theme . SMALL_BOLD_FONT ) ; l . setBounds ( 18 , y , 400 , 18 ) ; add ( l ) ; y + = 18 ; int componentHeight = ( int ) component . getPreferredSize ( ) . getHeight ( ) ; component . setBounds ( 16 , y , 400 , componentHeight ) ; y + = componentHeight ; y + = 2 ; vertical gap add(component); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; int textX = ParameterView . LABEL_WIDTH - g2 . getFontMetrics ( ) . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = (getHeight() - g2.getFont().getSize()) / 2 + 10; SwingUtils.drawShadowText(g2, getText(), textX, textY, Theme.DEFAULT_SHADOW_COLOR, 1); } 
public static void drawShadowText ( Graphics2D g2 , String s , int x , int y ) { drawShadowText ( g2 , s , x , y , Theme . TEXT_SHADOW_COLOR , 1 ) ; } 
public static void drawCenteredShadowText ( Graphics2D g2 , String s , int x , int y ) { drawCenteredShadowText ( g2 , s , x , y , Theme . TEXT_SHADOW_COLOR ) ; } 
public void paintIcon ( Component c , Graphics g , int x , int y ) { g . setColor ( Theme . DEFAULT_ARROW_COLOR ) ; g . drawLine ( x + 1 , y , x + 1 , y ) ; g . drawLine ( x + 1 , y + 1 , x + 2 , y + 1 ) ; g . drawLine ( x + 1 , y + 2 , x + 3 , y + 2 ) ; g . drawLine ( x + 1 , y + 3 , x + 4 , y + 3 ) ; g . drawLine ( x + 1 , y + 4 , x + 3 , y + 4 ) ; g . drawLine ( x + 1 , y + 5 , x + 2 , y + 5 ) ; g . drawLine ( x + 1 , y + 6 , x + 1 , y + 6 ) ; } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . setColor ( topColor ) ; g . drawLine ( x , y , x + width , y ) ; g . setColor ( bottomColor ) ; g . drawLine ( x , y + height - 1 , x + width , y + height - 1 ) ; } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . setColor ( bottomColor ) ; g . drawLine ( x , y + height - 1 , x + width , y + height - 1 ) ; } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { int labelWidth = ParameterView . LABEL_WIDTH ; Draw border on the side of the label g.setColor(LABEL_UP_COLOR); g.fillRect(x, y + height - 2, labelWidth - 2, 1); g.setColor(LABEL_DOWN_COLOR); g.fillRect(x, y + height - 1, labelWidth - 2, 1); Draw border on parameter side g.setColor(PARAMETER_UP_COLOR); g.fillRect(x + labelWidth + 1, y + height - 2, width - labelWidth - 1, 1); g.setColor(PARAMETER_DOWN_COLOR); g.fillRect(x + labelWidth + 1, y + height - 1, width - labelWidth - 1, 1); } 
public boolean hasVisibleHandle ( ) { if ( handle = = null ) return false ; if ( showHandle = = false ) return false ; return handle . isVisible ( ) ; } 
public void nodeDirty ( Node node ) { The node is dirty, but we wait for the document to update the network. This will send the nodeUpdated event. } public void nodeUpdated(Node node, ProcessingContext context) { if (node != getNode()) return; Note that we don't use check handle visibility here, since the update might change handle visibility. if (handle != null && showHandle) { handle.update(); } repaint(); } Mouse events private nodebox.graphics.Point pointForEvent(MouseEvent e) { double cx = -getWidth() / 2.0 + e.getX(); double cy = -getHeight() / 2.0 + e.getY(); return new nodebox.graphics.Point((float) cx, (float) cy); } public void mouseClicked(MouseEvent e) { requestFocus(); if (hasVisibleHandle()) handle.mouseClicked(pointForEvent(e)); } public void mousePressed(MouseEvent e) { requestFocus(); if (hasVisibleHandle()) handle.mousePressed(pointForEvent(e)); } public void mouseReleased(MouseEvent e) { requestFocus(); if (hasVisibleHandle()) handle.mouseReleased(pointForEvent(e)); } public void mouseEntered(MouseEvent e) { requestFocus(); if (hasVisibleHandle()) handle.mouseEntered(pointForEvent(e)); } public void mouseExited(MouseEvent e) { requestFocus(); if (hasVisibleHandle()) handle.mouseExited(pointForEvent(e)); } public void mouseDragged(MouseEvent e) { requestFocus(); if (hasVisibleHandle()) handle.mouseDragged(pointForEvent(e)); } public void mouseMoved(MouseEvent e) { requestFocus(); if (hasVisibleHandle()) handle.mouseMoved(pointForEvent(e)); } public void keyTyped(KeyEvent e) { if (hasVisibleHandle()) handle.keyTyped(e.getKeyCode(), e.getModifiersEx()); } public void keyPressed(KeyEvent e) { if (hasVisibleHandle()) handle.keyPressed(e.getKeyCode(), e.getModifiersEx()); } public void keyReleased(KeyEvent e) { if (hasVisibleHandle()) handle.keyReleased(e.getKeyCode(), e.getModifiersEx()); } @Override public boolean isFocusable() { return true; }} 
public void nodeUpdated ( Node node , ProcessingContext context ) { if ( node ! = getNode ( ) ) return ; Note that we don't use check handle visibility here, since the update might change handle visibility. if (handle != null && showHandle) { handle.update(); } repaint(); /* 
public void mouseClicked ( MouseEvent e ) { requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseClicked ( pointForEvent ( e ) ) ; 
public void mousePressed ( MouseEvent e ) { requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mousePressed ( pointForEvent ( e ) ) ; 
public void mouseReleased ( MouseEvent e ) { requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseReleased ( pointForEvent ( e ) ) ; 
public void mouseEntered ( MouseEvent e ) { requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseEntered ( pointForEvent ( e ) ) ; 
public void mouseExited ( MouseEvent e ) { requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseExited ( pointForEvent ( e ) ) ; 
public void mouseDragged ( MouseEvent e ) { requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseDragged ( pointForEvent ( e ) ) ; 
public void mouseMoved ( MouseEvent e ) { requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseMoved ( pointForEvent ( e ) ) ; 
public void keyTyped ( KeyEvent e ) { if ( hasVisibleHandle ( ) ) handle . keyTyped ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public void keyPressed ( KeyEvent e ) { if ( hasVisibleHandle ( ) ) handle . keyPressed ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public void keyReleased ( KeyEvent e ) { if ( hasVisibleHandle ( ) ) handle . keyReleased ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public Node getNode ( ) ; public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public boolean isVisible ( ) ; Mouse events public void mouseClicked(Point pt); public void mousePressed(Point pt); public void mouseReleased(Point pt); public void mouseEntered(Point pt); public void mouseExited(Point pt); public void mouseDragged(Point pt); public void mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void actionPerformed ( ActionEvent e ) { String newValue = keyField . getText ( ) + " = " + expressionField . getText ( ) ; if ( ! newValue . equals ( parameter . asString ( ) ) ) { parameter . set ( newValue ) ; 
public void stampExpressions ( ProcessingContext ctx ) { stampDirty ( ) ; updateDependencies ( ctx ) ; } 
public void evaluate ( ProcessingContext context ) throws ExpressionError { if ( expression = = null ) return ; Object result = expression . evaluate ( context ) ; context . put ( stampKey , result ) ; } 
public String toString ( ) { return StringUtils . humanizeConstant ( widget . toString ( ) ) ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Name nameField = new JFormattedTextField(20); nameField.setEditable(false); addRow("Name", nameField); Label labelField = new JTextField(20); labelField.addActionListener(this); labelField.addFocusListener(this); addRow("Label", labelField); Help Text helpTextField = new JTextField(20); helpTextField.addActionListener(this); helpTextField.addFocusListener(this); addRow("Help Text", helpTextField); Widget widgetBox = new JComboBox(humanizedWidgets); widgetBox.addActionListener(this); addRow("Type", widgetBox); Value valueField = new JTextField(20); valueField.addActionListener(this); valueField.addFocusListener(this); addRow("Value", valueField); Bounding Method boundingMethodBox = new JComboBox(new String[]{"none", "soft", "hard"}); boundingMethodBox.addActionListener(this); addRow("Bounding", boundingMethodBox); Minimum Value minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); minimumValueField.addFocusListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); addRow("Minimum", minimumValuePanel); Maximum Value maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); maximumValueField.addFocusListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); addRow("Maximum", maximumValuePanel); Display Level displayLevelBox = new JComboBox(new String[]{"hud", "detail", "hidden"}); displayLevelBox.addActionListener(this); addRow("Display Level", displayLevelBox); Menu Items menuItemsTable = new JTable(new MenuItemsModel()); menuItemsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); JPanel tablePanel = new JPanel(new BorderLayout(5, 5)); JScrollPane tableScroll = new JScrollPane(menuItemsTable, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); tableScroll.setSize(200, 200); tableScroll.setPreferredSize(new Dimension(200, 200)); tableScroll.setMaximumSize(new Dimension(200, 200)); tableScroll.setMinimumSize(new Dimension(200, 200)); tablePanel.add(tableScroll, BorderLayout.CENTER); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 5)); addButton = new JButton(new Icons.PlusIcon()); addButton.addActionListener(this); removeButton = new JButton(new Icons.MinusIcon()); removeButton.addActionListener(this); upButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.NORTH)); upButton.addActionListener(this); downButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.SOUTH)); downButton.addActionListener(this); buttonPanel.add(addButton); buttonPanel.add(removeButton); buttonPanel.add(upButton); buttonPanel.add(downButton); tablePanel.add(buttonPanel, BorderLayout.SOUTH); addRow("Menu Items", tablePanel); } 
public void updateValues ( ) { nameField . setText ( parameter . getName ( ) ) ; labelField . setText ( parameter . getLabel ( ) ) ; helpTextField . setText ( parameter . getHelpText ( ) ) ; widgetBox . setSelectedItem ( getHumanizedWidget ( parameter . getWidget ( ) ) ) ; valueField . setText ( parameter . getValue ( ) . toString ( ) ) ; Parameter . BoundingMethod boundingMethod = parameter . getBoundingMethod ( ) ; boundingMethodBox . setSelectedItem ( boundingMethod . toString ( ) . toLowerCase ( ) ) ; Object minimumValue = parameter . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = parameter . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; displayLevelBox . setSelectedItem ( parameter . getDisplayLevel ( ) . toString ( ) . toLowerCase ( ) ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
public static String humanizeConstant ( String constant ) { return humanizeName ( constant . toLowerCase ( ) ) ; } 
public void componentResized ( ComponentEvent e ) { splitter.setDividerLocation(splitter.getHeight()); } public void componentMoved(ComponentEvent e) { } public void componentShown(ComponentEvent e) { } public void componentHidden(ComponentEvent e) { } public void caretUpdate(CaretEvent e) { JEditorPane editArea = (JEditorPane) e.getSource(); int caretpos = editArea.getCaretPosition(); Element root = editArea.getDocument().getDefaultRootElement(); int linenum = root.getElementIndex(caretpos) + 1; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } private void updatePosition(int linenum, int columnnum) { splitter.setLocation(linenum, columnnum); } private class ReloadAction extends AbstractAction { private ReloadAction() { super("Reload"); ImageIcon icon = new ImageIcon("res/code-reload.png", "Reload"); putValue(Action.SMALL_ICON, icon); } public void actionPerformed(ActionEvent e) { if (node == null) return; Parameter pCode = node.getParameter("_code"); if (pCode == null) return; NodeCode code = new PythonCode(editor.getSource()); pCode.set(code); } }} 
protected Divider createDivider ( ) { return new EditorSpliterDivider ( ) ; } 
protected Divider createDivider ( ) { return new Divider ( ) ; } 
public Component add ( Component comp ) { throw new UnsupportedOperationException ( " Use setFirstComponent or setSecondComponent to change components. " ) ; } 
public void remove ( Component comp ) { throw new UnsupportedOperationException ( " Use setFirstComponent or setSecondComponent to change components. " ) ; } 
public void doLayout ( ) { final int width = getWidth ( ) ; final int height = getHeight ( ) ; if ( firstComponent ! = null & & secondComponent ! = null ) { Rectangle firstRect = new Rectangle ( ) ; Rectangle dividerRect = new Rectangle ( ) ; Rectangle secondRect = new Rectangle ( ) ; final int componentSize = getOrientation ( ) = = Orientation . VERTICAL ? height : width ; int firstComponentSize , secondComponentSize ; int dividerWidth = getDividerSize ( ) ; if ( componentSize < = dividerWidth ) { firstComponentSize = 0 ; secondComponentSize = 0 ; dividerWidth = componentSize ; } else { firstComponentSize = ( int ) ( position * ( float ) ( componentSize - dividerWidth ) ) ; secondComponentSize = getOrientation ( ) = = Orientation . VERTICAL ? height - firstComponentSize - dividerWidth : width - firstComponentSize - dividerWidth ; } if ( orientation = = Orientation . VERTICAL ) { firstRect . setBounds ( 0 , 0 , width , firstComponentSize ) ; dividerRect . setBounds ( 0 , firstComponentSize , width , dividerWidth ) ; secondRect . setBounds ( 0 , firstComponentSize + dividerWidth , width , secondComponentSize ) ; } else { firstRect . setBounds ( 0 , 0 , firstComponentSize , height ) ; dividerRect . setBounds ( firstComponentSize , 0 , dividerWidth , height ) ; secondRect . setBounds ( firstComponentSize + dividerWidth , 0 , secondComponentSize , height ) ; } divider . setVisible ( true ) ; firstComponent . setBounds ( firstRect ) ; divider . setBounds ( dividerRect ) ; secondComponent . setBounds ( secondRect ) ; firstComponent . validate ( ) ; secondComponent . validate ( ) ; } else if ( firstComponent ! = null & & secondComponent = = null ) { divider . setVisible ( false ) ; firstComponent . setBounds ( 0 , 0 , width , height ) ; firstComponent . validate ( ) ; } else if ( firstComponent = = null & & secondComponent ! = null ) { divider . setVisible ( false ) ; secondComponent . setBounds ( 0 , 0 , width , height ) ; secondComponent . validate ( ) ; } else { divider . setVisible ( false ) ; } divider . doLayout ( ) ; } 
public void splitTopBottom ( ) { split ( NSplitter . Orientation . VERTICAL ) ; } 
public void splitLeftRight ( ) { split ( NSplitter . Orientation . HORIZONTAL ) ; } 
private void split ( NSplitter . Orientation orientation ) { Container parent = getParent ( ) ; if ( parent instanceof PaneSplitter ) { PaneSplitter parentSplit = ( PaneSplitter ) parent ; 
public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { newPane = ( Pane ) paneType . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } newPane . setDocument ( getDocument ( ) ) ; Container parent = getParent ( ) ; if ( parent instanceof PaneSplitter ) { PaneSplitter parentSplit = ( PaneSplitter ) parent ; boolean first = parentSplit . getFirstComponent ( ) = = this ; if ( first ) { parentSplit . setFirstComponent ( newPane ) ; } else { parentSplit . setSecondComponent ( newPane ) ; } } else { Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; } parent . validate ( ) ; } 
protected Divider createDivider ( ) { return new PaneSpliterDivider ( ) ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { pressed = true ; armed = true ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { pressed = false ; if ( armed ) { armed = false ; if ( mode = = Mode . CHECK ) checked = ! checked ; try { actionMethod . invoke ( actionObject ) ; } catch ( Exception e1 ) { throw new RuntimeException ( " Could not invoke method " + actionMethod + " on object " + actionObject ) ; } repaint ( ) ; } } public void mouseEntered ( MouseEvent e ) { if ( pressed ) { armed = true ; repaint ( ) ; } } public void mouseExited ( MouseEvent e ) { armed = false ; repaint ( ) ; } } 
public void mousePressed ( MouseEvent e ) { pressed = true ; armed = true ; repaint ( ) ; } 
public void mouseReleased ( MouseEvent e ) { pressed = false ; if ( armed ) { armed = false ; 
public void mouseEntered ( MouseEvent e ) { if ( pressed ) { armed = true ; 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { int mx = e . getX ( ) ; armed = partIndex ( mx ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; java . util . List < Node > nodes = getNetworkParts ( ) ; Node selectedNode = nodes . get ( partIndex ) ; System.out.println("part = " + selectedNode); if (selectedNode != null) document.setActiveNetwork(selectedNode); repaint(); } public void mouseEntered(MouseEvent e) { } public void mouseExited(MouseEvent e) { armed = -1; repaint(); } private int partIndex(int x) { if (positions == null) return -1; for (int i = 0; i < positions.length; i++) { if (x < positions[i]) return i; } return -1; } @Override public void doLayout() { final int width = getWidth(); progressBar.setBounds(width-23, 3, 20, 20); }} 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } @Override public void doLayout ( ) { final int width = getWidth ( ) ; progressBar . setBounds ( width - 23 , 3 , 20 , 20 ) ; } } 
public void doLayout ( ) { final int width = getWidth ( ) ; progressBar . setBounds ( width - 23 , 3 , 20 , 20 ) ; } 
public static NodeBoxDocument createNewGeometryDocument ( ) { NodeLibrary nodeLibrary = new NodeLibrary ( " untitled " ) ; NodeLibraryManager manager = Application . getInstance ( ) . getManager ( ) ; Node geonet = nodeLibrary . getRootNode ( ) . create ( manager . getNode ( " corevector.geonet " ) ) ; geonet . setRendered ( ) ; Node geonet = Node.ROOT_NODE.newInstance(nodeLibrary, "geonet", Geometry.class); NodeBoxDocument doc = new NodeBoxDocument(nodeLibrary); doc.setActiveNetwork(geonet); return doc; } 
public void deleteSelected ( ) { TODO: Find network view, delete selected. JOptionPane.showMessageDialog(this, "Delete selected.", "NodeBox", JOptionPane.ERROR_MESSAGE); } 
public void windowOpened ( WindowEvent e ) { } public void windowClosing ( WindowEvent e ) { close ( ) ; } public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowActivated ( WindowEvent e ) { } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void nodeDirty ( final Node node ) { if ( node ! = activeNetwork ) return ; requestActiveNetworkUpdate ( ) ; } 
private void requestActiveNetworkUpdate ( ) { addressBar . setProgressVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); 
public void run ( ) { addressBar . setProgressVisible ( false ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; super . paintComponent ( g ) ; } 
private int measureWidth ( ) { To measure text we need a graphics context. Create an image and use its' graphics context. BufferedImage tmp = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB); Graphics2D g2 = tmp.createGraphics(); g2.setFont(Theme.SMALL_BOLD_FONT); int width = normalImage.getWidth(null); width += IMAGE_TEXT_MARGIN; width += (int) g2.getFontMetrics().stringWidth(text); width += 1; Anti-aliasing can take up an extra pixel. return width; } 
public void renderedChildChanged ( Node source , Node child ) { } public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) { } } private class ControlPanel extends JPanel { private ControlPanel ( LayoutManager layout ) { super ( layout ) ; } @Override protected void paintComponent ( Graphics g ) { if ( node = = null ) { Rectangle clip = g . getClipBounds ( ) ; g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; } else { int height = getHeight ( ) ; int width = getWidth ( ) ; g . setColor ( Theme . PARAMETER_LABEL_BACKGROUND ) ; g . fillRect ( 0 , 0 , LABEL_WIDTH - 3 , height ) ; g . setColor ( new Color ( 146 , 146 , 146 ) ) ; g . fillRect ( LABEL_WIDTH - 3 , 0 , 1 , height ) ; g . setColor ( new Color ( 133 , 133 , 133 ) ) ; g . fillRect ( LABEL_WIDTH - 2 , 0 , 1 , height ) ; g . setColor ( new Color ( 112 , 112 , 112 ) ) ; g . fillRect ( LABEL_WIDTH - 1 , 0 , 1 , height ) ; g . setColor ( Theme . PARAMETER_VALUE_BACKGROUND ) ; g . fillRect ( LABEL_WIDTH , 0 , width - LABEL_WIDTH , height ) ; } } } public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node = manager . getNode ( " corevector.rect " ) . newInstance ( testLibrary , " myrect " ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } } 
public void childAttributeChanged ( Node source , Node child , NodeAttributeListener . Attribute attribute ) { } } private class ControlPanel extends JPanel { private ControlPanel ( LayoutManager layout ) { super ( layout ) ; } @Override protected void paintComponent ( Graphics g ) { if ( node = = null ) { Rectangle clip = g . getClipBounds ( ) ; g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; } else { int height = getHeight ( ) ; int width = getWidth ( ) ; g . setColor ( Theme . PARAMETER_LABEL_BACKGROUND ) ; g . fillRect ( 0 , 0 , LABEL_WIDTH - 3 , height ) ; g . setColor ( new Color ( 146 , 146 , 146 ) ) ; g . fillRect ( LABEL_WIDTH - 3 , 0 , 1 , height ) ; g . setColor ( new Color ( 133 , 133 , 133 ) ) ; g . fillRect ( LABEL_WIDTH - 2 , 0 , 1 , height ) ; g . setColor ( new Color ( 112 , 112 , 112 ) ) ; g . fillRect ( LABEL_WIDTH - 1 , 0 , 1 , height ) ; g . setColor ( Theme . PARAMETER_VALUE_BACKGROUND ) ; g . fillRect ( LABEL_WIDTH , 0 , width - LABEL_WIDTH , height ) ; } } } public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node = manager . getNode ( " corevector.rect " ) . newInstance ( testLibrary , " myrect " ) ; ParameterView p = new ParameterView ( ) ; p . setNode ( ) ; frame . setContentPane ( p ) ; frame . setSize ( 500 , 500 ) ; frame . setVisible ( true ) ; } } 
public static void drawShadowText ( Graphics2D g2 , String s , int x , int y , Color shadowColor , int offset ) { g2 . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; Color c = g2 . getColor ( ) ; g2 . setColor ( shadowColor ) ; g2 . drawString ( s , x , y + offset ) ; g2 . setColor ( c ) ; g2 . drawString ( s , x , y ) ; } 
public String toString ( ) { if ( node = = null ) { return " <Empty proxy> " ; 
private Object convertToType ( Object value ) { if ( type = = Type . INT ) { if ( value instanceof Integer ) { 
public void testOnlyReferenceParameters ( ) { Node net = Node . ROOT_NODE . newInstance ( testLibrary , " net " ) ; Node number1 = net . create ( numberNode ) ; Node number2 = net . create ( numberNode ) ; Parameter pValue2 = number2 . getParameter ( " value " ) ; Setting the expression does not throw an error. pValue2.setExpression("number1"); Evaluating the node does. assertProcessingError(number2, "cannot be converted to int"); } 
public void testLenientTypes ( ) { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Integer Parameter pInt = alpha.addParameter("int", Parameter.Type.INT); pInt.setExpression("12.9"); Note that values are not rounded. The floating-point part is just cut off. alpha.update(); assertEquals(12, pInt.getValue()); Float Parameter pFloat = alpha.addParameter("float", Parameter.Type.FLOAT); pFloat.setExpression("100"); alpha.update(); assertEquals(100f, pFloat.getValue()); String Parameter pString = alpha.addParameter("string", Parameter.Type.STRING); pString.setExpression("10 + 5"); Any value is converted to a string. alpha.update(); assertEquals("15", pString.getValue()); Color Parameter pColor = alpha.addParameter("color", Parameter.Type.COLOR); pColor.setExpression("128"); Integers are converted to the 0-255 range alpha.update(); assertEquals(new Color(0.5, 0.5, 0.5), pColor.getValue()); pColor.setExpression("0.7"); Floats are converted to the 0-1 range alpha.update(); assertEquals(new Color(0.7, 0.7, 0.7), pColor.getValue()); } 
public void testGeometry ( ) { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pAlpha = alpha . addParameter ( " v " , Parameter . Type . FLOAT ) ; 
public static int randint ( long seed , int min , int max ) { randomGenerator . setSeed ( seed * 100000000 ) ; nextInt's specified value is exclusive, whereas we want to include it, so add 1. return min + randomGenerator.nextInt(max - min + 1); } 
public static double toFloat ( int v ) { return ( double ) v ; } 
public void testGeometry ( ) { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pAlpha = alpha . addParameter ( " v " , Parameter . Type . FLOAT ) ; } 
public void testMath ( ) throws ExpressionError { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pFloat = alpha . addParameter ( " float " , Parameter . Type . FLOAT ) ; assertExpressionEquals ( ( float ) Math . PI , pFloat , " math.PI " ) ; assertExpressionEquals ( ( float ) Math . sin ( 12 ) , pFloat , " math.sin(12) " ) ; } 
public void testFrame ( ) throws ExpressionError { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pInt = alpha . addParameter ( " int " , Parameter . Type . INT ) ; assertExpressionEquals ( 1 , pInt , " FRAME " ) ; } 
public void testRandint ( ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; Since these values are essentially random, we just have to generate enough to get a good distribution that reaches the edges. for (int i = 0; i < 50; i++) { int v = ExpressionHelper.randint(i, 20, 30); min = v < min ? v : min; max = v > max ? v : max; } assertEquals(20, min); assertEquals(30, max); } 
public void testImmutableValues ( ) { Node color1 = Node . ROOT_NODE . newInstance ( testLibrary , " color1 " , Color . class ) ; color1 . addParameter ( " color " , Parameter . Type . COLOR ) ; color1 . setValue ( " _code " , new PythonCode ( " def cook(self): return self.color " ) ) ; Color original = new Color ( 0.1 , 0.2 , 0.3 , 0.4 ) ; color1 . setValue ( " color " , original ) ; Retrieving the value should make a copy. assertNotSame(original, color1.asColor("color")); assertNotSame(original, color1.getValue("color")); Returning the cooked color should create a copy. color1.update(); assertNotSame(original, color1.getOutputValue()); } 
public void testParameterValueEvents ( ) { TestParameterValueListener l ; Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; l = new TestParameterValueListener ( ) ; . addParameterValueListener ( l ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; Parameter pBeta = . addParameter ( " beta " , Parameter . Type . FLOAT ) ; Initialization has triggered the parameter value event. assertEquals(1, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); Update the node so new events will get fired. n.update(); pAlpha.setValue(100); assertEquals(2, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); Change the value to the current value. This should not trigger the event. pAlpha.setValue(100); assertEquals(2, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); The node is already dirty, and parameters will not receive any new events. Update the node so it becomes clean again. Set an expression for beta. This triggers the event. n.update(); pAlpha.setValue(3); pBeta.setExpression("alpha + 1"); assertEquals(2, l.getCounter(pBeta)); Now change alpha. This will not trigger beta, since the node is not updated yet. assertEquals(3, l.getCounter(pAlpha)); assertEquals(2, l.getCounter(pBeta)); Update the node, which will trigger the value changed event. n.update(); assertEquals(3, l.getCounter(pAlpha)); assertEquals(3, l.getCounter(pBeta)); } 
public void testRevertToDefault ( ) { Create a prototype node with an int parameter with an expression. Node proto = Node.ROOT_NODE.newInstance(testLibrary, "proto"); Parameter pAlpha = proto.addParameter("alpha", Parameter.Type.INT); pAlpha.setExpression("40 + 2"); Parameter pBeta = proto.addParameter("beta", Parameter.Type.INT, 88); Create an instance of this prototype. Node test = proto.newInstance(testLibrary, "test"); Parameter tAlpha = test.getParameter("alpha"); Check if the instance inherits the expression. assertTrue(tAlpha.hasExpression()); assertEquals("40 + 2", tAlpha.getExpression()); Update the node so the expression gets evaluated. test.update(); Remove the expression. tAlpha.clearExpression(); assertEquals(42, tAlpha.getValue()); Revert to default. The expression should be restored. tAlpha.revertToDefault(); assertTrue(tAlpha.hasExpression()); assertEquals("40 + 2", tAlpha.getExpression()); Now test the other way around. If the prototype has no expression, but the instance does, remove the expression and set the value. Parameter tBeta = test.getParameter("beta"); assertFalse(tBeta.hasExpression()); tBeta.setExpression("3 - 2"); test.update(); assertEquals(1, tBeta.getValue()); Revert to default. The beta parameter should have a regular value instead of an expression. tBeta.revertToDefault(); assertFalse(tBeta.hasExpression()); assertEquals(88, tBeta.getValue()); } 
private void createNodeBoxDataDirectories ( ) throws RuntimeException { PlatformUtils . getUserDataDirectory ( ) . mkdir ( ) ; PlatformUtils . getUserScriptsDirectory ( ) . mkdir ( ) ; PlatformUtils . getUserPythonDirectory ( ) . mkdir ( ) ; } 
private void registerForMacOSXEvents ( ) throws RuntimeException { if ( ! PlatformUtils . onMac ( ) ) return ; try { Generate and register the OSXAdapter, passing it a hash of all the methods we wish to use as delegates for various com.apple.eawt.ApplicationListener methods OSXAdapter.setQuitHandler(this, getClass().getDeclaredMethod("quit", (Class[]) null)); OSXAdapter.setAboutHandler(this, getClass().getDeclaredMethod("showAbout", (Class[]) null)); OSXAdapter.setPreferencesHandler(this, getClass().getDeclaredMethod("showPreferences", (Class[]) null)); OSXAdapter.setFileHandler(this, getClass().getDeclaredMethod("readFromFile", String.class)); } catch (Exception e) { throw new RuntimeException("Error while loading the OS X Adapter.", e); } Create hidden window. hiddenFrame = new JFrame(); hiddenFrame.setJMenuBar(new NodeBoxMenuBar(false)); hiddenFrame.setUndecorated(true); hiddenFrame.setSize(0, 0); hiddenFrame.pack(); hiddenFrame.setVisible(true); } 
public void showAbout ( ) { JOptionPane . showMessageDialog ( null , NAME + " version " + getVersion ( ) , NAME , JOptionPane . INFORMATION_MESSAGE ) ; } 
private void load ( ) { manager = new NodeLibraryManager ( ) ; manager . addSearchPath ( PlatformUtils . getApplicationScriptsDirectory ( ) ) ; manager . addSearchPath ( PlatformUtils . getUserScriptsDirectory ( ) ) ; manager . lookForLibraries ( ) ; int tasks = manager . getLibraries ( ) . size ( ) + 1 ; startupDialog = new ProgressDialog ( null , " Starting " + NAME , tasks ) ; startupDialog . setVisible ( true ) ; Initialize Jython startupDialog.setMessage("Loading Python"); Thread t = new Thread(new PythonLoader()); t.start(); } 
public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . showAbout ( ) ; } 
public static File getUserDataDirectory ( ) throws RuntimeException { if ( userDataDirectory ! = null ) return userDataDirectory ; if ( onMac ( ) ) { userDataDirectory = new File ( getHomeDirectory ( ) , " Library/ " + Application . NAME ) ; } else if ( onWindows ( ) ) { userDataDirectory = new File ( readWindowsRegistryValue ( REG_SHELL_FOLDERS , REG_LOCAL_APPDATA ) + " \\ " + Application . NAME ) ; } else { userDataDirectory = new File ( getHomeDirectory ( ) , Application . NAME . toLowerCase ( ) ) ; } return userDataDirectory ; } 
public static String readWindowsRegistryValue ( String key , String valueKey ) { String command = REG_QUERY_COMMAND + " \" " + key + " \" /v \" " + valueKey + " \" " ; try { Process process = Runtime . getRuntime ( ) . exec ( command ) ; 
private Object convertToType ( Object value ) { if ( type = = Type . INT ) { if ( value instanceof Integer ) { 
public void testDirtyOnError ( ) throws ExpressionError { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter aValue = alpha . addParameter ( " value " , Parameter . Type . INT , 42 ) ; assertTrue ( alpha . isDirty ( ) ) ; alpha . update ( ) ; assertFalse ( alpha . isDirty ( ) ) ; assertInvalidExpression ( aValue , " **** " , " not a statement " ) ; assertTrue ( alpha . isDirty ( ) ) ; try { alpha . update ( ) ; } catch ( ProcessingError e ) { assertTrue ( e . getMessage ( ) . toLowerCase ( ) . contains ( " cannot compile expression " ) ) ; } assertEquals ( 42 , aValue . getValue ( ) ) ; } 
public void testLenientTypes ( ) throws ExpressionError { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Integer Parameter pInt = alpha.addParameter("int", Parameter.Type.INT); assertExpressionEquals(5, pInt, "5"); Note that values are not rounded. The floating-point part is just cut off. assertExpressionEquals(12, pInt, "12.9"); assertUpdateError(pInt, "\"hello\"", "cannot be converted to int"); assertUpdateError(pInt, "color(0.5)", "cannot be converted to int"); Float Parameter pFloat = alpha.addParameter("float", Parameter.Type.FLOAT); assertExpressionEquals(1.234f, pFloat, "1.234"); assertExpressionEquals(100f, pFloat, "100"); assertUpdateError(pFloat, "\"hello\"", "cannot be converted to float"); assertUpdateError(pFloat, "color(0.1, 0.2, 0.3)", "cannot be converted to float"); String Parameter pString = alpha.addParameter("string", Parameter.Type.STRING); Any value is converted to a string. assertExpressionEquals("15", pString, "10 + 5"); Color Parameter pColor = alpha.addParameter("color", Parameter.Type.COLOR); assertExpressionEquals(new Color(0.1, 0.2, 0.3, 0.4), pColor, "color(0.1, 0.2, 0.3, 0.4)"); Integers are converted to the 0-255 range assertExpressionEquals(new Color(0.5, 0.5, 0.5), pColor, "128"); Floats are converted to the 0-1 range assertExpressionEquals(new Color(0.7, 0.7, 0.7), pColor, "0.7"); } 
private void assertInvalidExpression ( Parameter p , String expression , String expectedMessage ) throws ExpressionError { p . setExpression ( expression ) ; if ( ! p . hasExpressionError ( ) ) { fail ( " Expression should have failed with \" " + expectedMessage + " \" " ) ; 
private void assertUpdateError ( Parameter p , String expression , String expectedMessage ) throws ExpressionError { p . setExpression ( expression ) ; try { p . update ( new ProcessingContext ( ) ) ; 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " value " ) ; . addParameter ( " int " , Parameter . Type . INT ) ; . addParameter ( " float " , Parameter . Type . FLOAT ) ; . addParameter ( " string " , Parameter . Type . STRING ) ; . addParameter ( " color " , Parameter . Type . COLOR ) ; return ; } 
private boolean fuzzyCompare ( float p1 , float p2 ) { return Math . abs ( p1 - p2 ) < = ( 0.000000000001 * Math . min ( Math . abs ( p1 ) , Math . abs ( p2 ) ) ) ; } 
public Point pointAt ( float ) { float coeff [ ] , a , b , c , d ; coeff = coefficients ( ) ; a = coeff [ 0 ] ; b = coeff [ 1 ] ; c = coeff [ 2 ] ; d = coeff [ 3 ] ; return new Point ( a * x1 + b * x2 + c * x3 + d * x4 , a * y1 + b * y2 + c * y3 + d * y4 ) ; } 
private float [ ] coefficients ( float ) { float m_t , a , b , c , d ; m_t = 1 - ; b = m_t * m_t ; c = * ; d = c * ; a = b * m_t ; b * = ( 3. * ) ; c * = ( 3. * m_t ) ; return new float [ ] { a , b , c , d } ; } 
private void bezierCheck ( float ) { if ( > = 0 & & < = 1 ) { Point p = pointAt ( ) ; 
public Rect extrema ( ) { float ax , bx , cx , ay , by , cy ; if ( x1 < x4 ) { minx = x1 ; maxx = x4 ; } else { minx = x4 ; maxx = x1 ; } if ( y1 < y4 ) { miny = y1 ; maxy = y4 ; } else { miny = y4 ; maxy = y1 ; } ax = 3 * ( - x1 + 3 * x2 - 3 * x3 + x4 ) ; bx = 6 * ( x1 - 2 * x2 + x3 ) ; cx = 3 * ( - x1 + x2 ) ; if ( fuzzyCompare ( ax + 1 , 1 ) ) { if ( ! fuzzyCompare ( bx + 1 , 1 ) ) { float = - cx / bx ; bezierCheck ( ) ; } } else { float tx = bx * bx - 4 * ax * cx ; if ( tx > = 0 ) { float temp , rcp , t1 , t2 ; temp = ( float ) Math . sqrt ( tx ) ; rcp = 1 / ( 2 * ax ) ; t1 = ( - bx + temp ) * rcp ; bezierCheck ( t1 ) ; t2 = ( - bx - temp ) * rcp ; bezierCheck ( t2 ) ; } } ay = 3 * ( - y1 + 3 * y2 - 3 * y3 + y4 ) ; by = 6 * ( y1 - 2 * y2 + y3 ) ; cy = 3 * ( - y1 + y2 ) ; if ( fuzzyCompare ( ay + 1 , 1 ) ) { if ( ! fuzzyCompare ( by + 1 , 1 ) ) { float = - cy / by ; bezierCheck ( ) ; } } else { float ty = by * by - 4 * ay * cy ; if ( ty > 0 ) { float temp , rcp , t1 , t2 ; temp = ( float ) Math . sqrt ( ty ) ; rcp = 1 / ( 2 * ay ) ; t1 = ( - by + temp ) * rcp ; bezierCheck ( t1 ) ; t2 = ( - by - temp ) * rcp ; bezierCheck ( t2 ) ; } } return new Rect ( minx , miny , maxx - minx , maxy - miny ) ; } 
public void inheritFromContext ( GraphicsContext ctx ) { } public Path clone ( ) { return new Path ( this ) ; } public Path cloneAndClear ( ) { return new Path ( this , false ) ; } private class Bezier { private float x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ; private float minx , maxx , miny , maxy ; public Bezier ( Point p1 , Point p2 , Point p3 , Point p4 ) { x1 = p1 . getX ( ) ; y1 = p1 . getY ( ) ; x2 = p2 . getX ( ) ; y2 = p2 . getY ( ) ; x3 = p3 . getX ( ) ; y3 = p3 . getY ( ) ; x4 = p4 . getX ( ) ; y4 = p4 . getY ( ) ; } private boolean fuzzyCompare ( float p1 , float p2 ) { return Math . abs ( p1 - p2 ) < = ( 0.000000000001 * Math . min ( Math . abs ( p1 ) , Math . abs ( p2 ) ) ) ; } public Point pointAt ( float ) { float coeff [ ] , a , b , c , d ; coeff = coefficients ( ) ; a = coeff [ 0 ] ; b = coeff [ 1 ] ; c = coeff [ 2 ] ; d = coeff [ 3 ] ; return new Point ( a * x1 + b * x2 + c * x3 + d * x4 , a * y1 + b * y2 + c * y3 + d * y4 ) ; } private float [ ] coefficients ( float ) { float m_t , a , b , c , d ; m_t = 1 - ; b = m_t * m_t ; c = * ; d = c * ; a = b * m_t ; b * = ( 3. * ) ; c * = ( 3. * m_t ) ; return new float [ ] { a , b , c , d } ; } private void bezierCheck ( float ) { if ( > = 0 & & < = 1 ) { Point p = pointAt ( ) ; if ( p . getX ( ) < minx ) minx = p . getX ( ) ; else if ( p . getX ( ) > maxx ) maxx = p . getX ( ) ; if ( p . getY ( ) < miny ) miny = p . getY ( ) ; else if ( p . getY ( ) > maxy ) maxy = p . getY ( ) ; } } public Rect extrema ( ) { float ax , bx , cx , ay , by , cy ; if ( x1 < x4 ) { minx = x1 ; maxx = x4 ; } else { minx = x4 ; maxx = x1 ; } if ( y1 < y4 ) { miny = y1 ; maxy = y4 ; } else { miny = y4 ; maxy = y1 ; } ax = 3 * ( - x1 + 3 * x2 - 3 * x3 + x4 ) ; bx = 6 * ( x1 - 2 * x2 + x3 ) ; cx = 3 * ( - x1 + x2 ) ; if ( fuzzyCompare ( ax + 1 , 1 ) ) { if ( ! fuzzyCompare ( bx + 1 , 1 ) ) { float = - cx / bx ; bezierCheck ( ) ; } } else { float tx = bx * bx - 4 * ax * cx ; if ( tx > = 0 ) { float temp , rcp , t1 , t2 ; temp = ( float ) Math . sqrt ( tx ) ; rcp = 1 / ( 2 * ax ) ; t1 = ( - bx + temp ) * rcp ; bezierCheck ( t1 ) ; t2 = ( - bx - temp ) * rcp ; bezierCheck ( t2 ) ; } } ay = 3 * ( - y1 + 3 * y2 - 3 * y3 + y4 ) ; by = 6 * ( y1 - 2 * y2 + y3 ) ; cy = 3 * ( - y1 + y2 ) ; if ( fuzzyCompare ( ay + 1 , 1 ) ) { if ( ! fuzzyCompare ( by + 1 , 1 ) ) { float = - cy / by ; bezierCheck ( ) ; } } else { float ty = by * by - 4 * ay * cy ; if ( ty > 0 ) { float temp , rcp , t1 , t2 ; temp = ( float ) Math . sqrt ( ty ) ; rcp = 1 / ( 2 * ay ) ; t1 = ( - by + temp ) * rcp ; bezierCheck ( t1 ) ; t2 = ( - by - temp ) * rcp ; bezierCheck ( t2 ) ; } } return new Rect ( minx , miny , maxx - minx , maxy - miny ) ; } } } 
public Point pointAt ( float ) { float coeff [ ] , a , b , c , d ; coeff = coefficients ( ) ; a = coeff [ 0 ] ; b = coeff [ 1 ] ; c = coeff [ 2 ] ; d = coeff [ 3 ] ; return new Point ( a * x1 + b * x2 + c * x3 + d * x4 , a * y1 + b * y2 + c * y3 + d * y4 ) ; } 
private float [ ] coefficients ( float ) { float m_t , a , b , c , d ; m_t = 1 - ; b = m_t * m_t ; c = * ; d = c * ; a = b * m_t ; b * = ( 3. * ) ; c * = ( 3. * m_t ) ; return new float [ ] { a , b , c , d } ; } 
public Rect extrema ( ) { float ax , bx , cx , ay , by , cy ; if ( x1 < x4 ) { minx = x1 ; maxx = x4 ; } else { minx = x4 ; maxx = x1 ; } if ( y1 < y4 ) { miny = y1 ; maxy = y4 ; } else { miny = y4 ; maxy = y1 ; } ax = 3 * ( - x1 + 3 * x2 - 3 * x3 + x4 ) ; bx = 6 * ( x1 - 2 * x2 + x3 ) ; cx = 3 * ( - x1 + x2 ) ; if ( fuzzyCompare ( ax + 1 , 1 ) ) { if ( ! fuzzyCompare ( bx + 1 , 1 ) ) { float = - cx / bx ; bezierCheck ( ) ; } } else { float tx = bx * bx - 4 * ax * cx ; if ( tx > = 0 ) { float temp , rcp , t1 , t2 ; temp = ( float ) Math . sqrt ( tx ) ; rcp = 1 / ( 2 * ax ) ; t1 = ( - bx + temp ) * rcp ; bezierCheck ( t1 ) ; t2 = ( - bx - temp ) * rcp ; bezierCheck ( t2 ) ; } } ay = 3 * ( - y1 + 3 * y2 - 3 * y3 + y4 ) ; by = 6 * ( y1 - 2 * y2 + y3 ) ; cy = 3 * ( - y1 + y2 ) ; if ( fuzzyCompare ( ay + 1 , 1 ) ) { if ( ! fuzzyCompare ( by + 1 , 1 ) ) { float = - cy / by ; bezierCheck ( ) ; } } else { float ty = by * by - 4 * ay * cy ; if ( ty > 0 ) { float temp , rcp , t1 , t2 ; temp = ( float ) Math . sqrt ( ty ) ; rcp = 1 / ( 2 * ay ) ; t1 = ( - by + temp ) * rcp ; bezierCheck ( t1 ) ; t2 = ( - by - temp ) * rcp ; bezierCheck ( t2 ) ; } } return new Rect ( minx , miny , maxx - minx , maxy - miny ) ; } 
public boolean readFromFile ( String path ) { This method looks unused, but is actually called using reflection by the OS X adapter. NodeBoxDocument doc = createNewDocument(); doc.readFromFile(path); return true; } 
private void librariesLoadedEvent ( ) { startupDialog . setVisible ( false ) ; if ( documents . isEmpty ( ) ) instance . createNewDocument ( ) ; updater . checkForUpdatesInBackground ( ) ; } 
public void actionPerformed ( ActionEvent e ) { PlatformUtils . openURL ( " http:beta.nodebox.net/documentation/getting-started/ " ) ; } 
public void actionPerformed ( ActionEvent e ) { PlatformUtils . openURL ( " http:beta.nodebox.net/documentation/ " ) ; } 
public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . getUpdater ( ) . checkForUpdates ( ) ; } 
public static void openURL ( String url ) { if ( Desktop . isDesktopSupported ( ) ) { URI uri = URI . create ( url ) ; 
public void updateProgress ( ) { progressBar . setValue ( tasksCompleted ) ; double percentage = ( double ) ( tasksCompleted ) / ( double ) ( taskCount ) ; int ip = ( int ) ( percentage * 100 ) ; progressLabel . setText ( ip + " % " ) ; repaint ( ) ; } 
public static void centerOnScreen ( Window w ) { centerOnScreen ( w , null ) ; } 
public static void centerOnScreen ( Window w , Window parent ) { Rectangle r = new Rectangle ( ) ; if ( parent = = null ) { r . setSize ( Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ) ; } else { r . setLocation ( parent . getLocation ( ) ) ; r . setSize ( parent . getSize ( ) ) ; } Determine the new location of the alert int x = r.x + (r.width - w.getWidth()) / 2; int y = r.y + (r.height - w.getHeight()) / 2; Move the alert w.setLocation(x, y); } 
public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { characterData = new StringBuffer ( ) ; if ( qName . equals ( TAG_ITEM ) ) { currentItemProperties = new Properties ( ) ; 
public void endElement ( String uri , String localName , String qName ) throws SAXException { String text = characterData . toString ( ) ; if ( qName . equals ( TAG_ITEM ) ) { AppcastItem item = new AppcastItem ( currentItemProperties ) ; 
public void characters ( char [ ] ch , int start , int length ) throws SAXException { We have a valid character state, so we can safely append to characterData. characterData.append(ch, start, length); } 
public String toString ( ) { return " AppcastItem{ " + " title=' " + title + '\'' + 
public boolean isNewerThan ( Host host ) { return version . compareTo ( host . getVersion ( ) ) > 0 ; } 
public String getName ( ) ; public Version getVersion ( ) ; public String getIconFile ( ) ; public String getAppcastURL ( ) ; } 
public Version getVersion ( ) ; public String getIconFile ( ) ; public String getAppcastURL ( ) ; } 
public String getIconFile ( ) ; public String getAppcastURL ( ) ; } 
public void actionPerformed ( ActionEvent e ) { remindMeLaterClicked ( ) ; } 
public void actionPerformed ( ActionEvent e ) { downloadClicked ( ) ; } 
private void remindMeLaterClicked ( ) { setVisible ( false ) ; dispose ( ) ; } 
private void downloadClicked ( ) { setVisible ( false ) ; dispose ( ) ; Open download link URL. PlatformUtils.openURL(appcast.getDownloadLink()); } 
private void forceSize ( Component c , int width , int height ) { c . setSize ( width , height ) ; Dimension d = new Dimension ( width , height ) ; c . setMinimumSize ( d ) ; c . setMaximumSize ( d ) ; c . setPreferredSize ( d ) ; } 
public void downloadReleaseNotes ( ) { Thread = new Thread ( new ReleaseNotesDownloader ( ) ) ; . start ( ) ; } 
private void releaseNotesDownloaded ( String releaseNotes ) { notesArea . setText ( releaseNotes ) ; } 
private void releaseNotesError ( Exception e ) { notesArea . setText ( e . toString ( ) ) ; } 
public void run ( ) { try { Get contents of URL 
public void run ( ) { releaseNotesDownloaded ( releaseNotes . toString ( ) ) ; } 
public void run ( ) { releaseNotesError ( e ) ; } 
public static void main ( String [ ] args ) { Updater updater = new Updater ( new MockHost ( ) ) ; UpdateCheckDialog d = new UpdateCheckDialog ( null , updater ) ; d . setVisible ( true ) ; } 
public void actionPerformed ( ActionEvent e ) { updater . cancelUpdateCheck ( ) ; dispose ( ) ; } 
public void run ( ) { try { URL appcastURL = new URL ( updater . getHost ( ) . getAppcastURL ( ) ) ; 
public void run ( ) { updater . checkPerformed ( appcast ) ; } 
public void run ( ) { updater . checkerFoundValidUpdate ( appcast ) ; } 
public void run ( ) { updater . checkerEncounteredError ( e ) ; } 
private Appcast parseAppcastXML ( InputStream is ) throws Exception { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; SAXParser parser = spf . newSAXParser ( ) ; AppcastHandler handler = new AppcastHandler ( ) ; parser . parse ( is , handler ) ; return handler . getAppcast ( ) ; } 
public boolean checkPerformed ( Appcast appcast ) { return false ; } 
public boolean checkerFoundValidUpdate ( Appcast appcast ) { return false ; } 
public boolean checkerEncounteredError ( Exception e ) { return false ; } 
public void applicationDidFinishLaunching ( ) { checkForUpdatesInBackground ( ) ; } 
public boolean isAutomaticCheck ( ) { return automaticCheck ; } 
public void checkForUpdates ( ) { checkForUpdates ( true ) ; } 
public void checkForUpdates ( boolean showProgressWindow ) { if ( updateChecker ! = null & & updateChecker . isAlive ( ) ) return ; if ( showProgressWindow ) { updateCheckDialog = new UpdateCheckDialog ( null , this ) ; Window win = KeyboardFocusManager . getCurrentKeyboardFocusManager ( ) . getFocusedWindow ( ) ; SwingUtils . centerOnScreen ( updateCheckDialog , win ) ; updateCheckDialog . setVisible ( true ) ; } updateChecker = new UpdateChecker ( this ) ; updateChecker . start ( ) ; } 
public void checkForUpdatesInBackground ( ) { if ( shouldCheckForUpdate ( ) ) { updateChecker = new UpdateChecker ( this ) ; 
public boolean shouldCheckForUpdate ( ) { long lastTime = getPreferences ( ) . getLong ( LAST_UPDATE_CHECK , 0 ) ; long deltaTime = System . currentTimeMillis ( ) - lastTime ; return deltaTime > UPDATE_INTERVAL ; } 
public void checkPerformed ( Appcast appcast ) { if ( updateCheckDialog ! = null ) { updateCheckDialog . setVisible ( false ) ; updateCheckDialog = null ; } Delegate method. if (delegate != null) if (delegate.checkPerformed(appcast)) return; Store last check update check time. getPreferences().putLong(LAST_UPDATE_CHECK, System.currentTimeMillis()); try { getPreferences().flush(); 
public void checkerFoundValidUpdate ( Appcast appcast ) { Delegate method. if (delegate != null) if (delegate.checkerFoundValidUpdate(appcast)) return; UpdateAlert alert = new UpdateAlert(this, appcast); Window win = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow(); SwingUtils.centerOnScreen(alert, win); alert.setVisible(true); alert.downloadReleaseNotes(); } 
public void checkerEncounteredError ( Exception e ) { if ( updateCheckDialog ! = null ) { updateCheckDialog . setVisible ( false ) ; updateCheckDialog = null ; } Delegate method. if (delegate != null) if (delegate.checkerEncounteredError(e)) return; throw new RuntimeException(e); } 
public void waitForCheck ( int timeoutMillis ) { try { updateChecker . join ( timeoutMillis ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } if ( updateChecker . isAlive ( ) ) { updateChecker . interrupt ( ) ; 
public void cancelUpdateCheck ( ) { if ( updateChecker ! = null & & updateChecker . isAlive ( ) ) { updateChecker . interrupt ( ) ; 
private static Integer parseInt ( String s ) { try { return Integer . parseInt ( s ) ; 
public int compareTo ( Object o ) { if ( ! ( o instanceof Version ) ) return - 1 ; Version other = ( Version ) o ; String [ ] thisParts = this . versionString . split ( " \\ . " ) ; String [ ] otherParts = other . versionString . split ( " \\ . " ) ; if ( this . versionString . equals ( other . versionString ) ) return EQUAL ; int partCount = Math . min ( thisParts . length , otherParts . length ) ; for ( int i = 0 ; i < partCount ; i + + ) { String thisPart = thisParts [ i ] ; String otherPart = otherParts [ i ] ; Integer thisPartInt = parseInt ( thisPart ) ; Integer otherPartInt = parseInt ( otherPart ) ; if ( thisPartInt ! = null & & otherPartInt ! = null ) { Two numbers, can compare. if (thisPartInt > otherPartInt) { return LARGER_THAN; } else if (thisPartInt < otherPartInt) { return SMALLER_THAN; } } else { if (thisPartInt == null && otherPartInt != null) { This is a string, the other part is a number. String wins. return LARGER_THAN; } else if (thisPartInt != null && otherPartInt == null) { This is a number, the other part is not. String wins. return SMALLER_THAN; } else { Two strings. Compare them. int comparison = thisPart.compareTo(otherPart); Only return if they are equal, otherwise keep on checking. if (comparison != 0) { return comparison; } } } } We're still here. Version string with most segments wins. if (thisParts.length > otherParts.length) { return LARGER_THAN; 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Version version = ( Version ) o ; if ( ! versionString . equals ( version . versionString ) ) return false ; return true ; } 
public int hashCode ( ) { return versionString . hashCode ( ) ; } 
public void run ( ) { running = true ; try { server = new ServerSocket ( port ) ; 
public void stop ( ) { if ( ! running ) return ; running = false ; if ( server ! = null ) { try { server . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } server = null ; } 
private void handleRequest ( Socket socket ) throws IOException { PrintStream os = new PrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; BufferedReader is = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; String line = is . readLine ( ) ; if ( line = = null ) return ; String version = " " ; StringTokenizer st = new StringTokenizer ( line ) ; String method = st . nextToken ( ) ; String fileName = st . nextToken ( ) ; if ( st . hasMoreTokens ( ) ) { version = st . nextToken ( ) ; } read header but ignore while ((line = is.readLine()) != null) { if (line.trim().equals("")) break; } we only do GET if (method.equals("GET") || method.equals("HEAD")) { boolean headOnly = false; if (method.equals("HEAD")) { headOnly = true; } byte[] data; File f = new File(mediaRoot, fileName); data = readFileAsString(f).getBytes(); if (version.startsWith("HTTP/")) { send headers String header = "HTTP/1.0 200 OK\r"; header += standardHeaders(); header += "Content-length: " + data.length + "\r"; header += "Content-type: text/xml\r\r"; os.print(header); } if (!headOnly) { os.write(data); } os.flush(); os.close(); } else { not a get/head so output error if (version.startsWith("HTTP/")) { send headers String header = "HTTP/1.0 501 Not Implemented\r"; header += standardHeaders(); header += "Content-type: text/html\r\r"; os.print(header); } os.println("<HTML><HEAD><TITLE>Not Implemented</TITLE><HEAD>"); os.println("<BODY><H1>HTTP Error 501: Not Implemented</H1></BODY></HTML>"); } os.close(); socket.close(); } 
private String standardHeaders ( ) { Date now = LazyDate.getDate(); Date now = new Date(); return "Date: " + now + "\rServer: MockAppcastServer http 1.0\r"; } 
private static String readFileAsString ( File f ) throws java . io . IOException { StringBuffer fileData = new StringBuffer ( 1000 ) ; BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; char [ ] buf = new char [ 1024 ] ; int numRead ; while ( ( numRead = reader . read ( buf ) ) ! = - 1 ) { String readData = String . valueOf ( buf , 0 , numRead ) ; fileData . append ( readData ) ; buf = new char [ 1024 ] ; } reader . close ( ) ; return fileData . toString ( ) ; } 
public static void main ( String [ ] args ) { MockAppcastServer server = new MockAppcastServer ( 8080 ) ; server . run ( ) ; } 
public void start ( ) { JFrame mainFrame = new JFrame ( " MockBox " ) ; mainFrame . setSize ( 700 , 500 ) ; mainFrame . setLocationByPlatform ( true ) ; mainFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; mainFrame . setVisible ( true ) ; updater . applicationDidFinishLaunching ( ) ; } 
public static void main ( String [ ] args ) { MockBox mb = new MockBox ( ) ; mb . start ( ) ; } 
protected void setUp ( ) throws Exception { host = new MockHost ( ) ; updater = new Updater ( host ) ; server = new MockAppcastServer ( MockHost . APPCAST_SERVER_PORT ) ; serverThread = new Thread ( server ) ; serverThread . start ( ) ; } 
public void testCheckForUpdates ( ) { TestUpdateDelegate delegate = new TestUpdateDelegate ( ) ; updater . setDelegate ( delegate ) ; updater . checkForUpdates ( false ) ; try { updater . getUpdateChecker ( ) . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } assertTrue ( delegate . checkPerformed ) ; assertNull ( delegate . exception ) ; AppcastItem item = delegate . appcast . getLatest ( ) ; assertNotNull ( item ) ; assertEquals ( new Version ( " 2.0 " ) , item . getVersion ( ) ) ; assertTrue ( item . isNewerThan ( host ) ) ; } 
public boolean checkPerformed ( Appcast appcast ) { checkPerformed = true ; return true ; } 
public boolean checkerFoundValidUpdate ( Appcast appcast ) { this . appcast = appcast ; return true ; } 
public boolean checkerEncounteredError ( Exception e ) { this . exception = e ; return true ; } 
public void testBasic ( ) { Version v1 = new Version ( " 2.0 " ) ; assertEquals ( LARGER_THAN , v1 . compareTo ( new Version ( " 1.0 " ) ) ) ; assertEquals ( SMALLER_THAN , v1 . compareTo ( new Version ( " 3.0 " ) ) ) ; assertEquals ( LARGER_THAN , v1 . compareTo ( new Version ( " 1.9.9 " ) ) ) ; assertEquals ( SMALLER_THAN , v1 . compareTo ( new Version ( " 2.1 " ) ) ) ; assertEquals ( SMALLER_THAN , v1 . compareTo ( new Version ( " 2.0.0.1 " ) ) ) ; Version v2 = new Version ( " 0.1.2.3 " ) ; assertEquals ( LARGER_THAN , v2 . compareTo ( new Version ( " 0 " ) ) ) ; assertEquals ( LARGER_THAN , v2 . compareTo ( new Version ( " 0.0 " ) ) ) ; assertEquals ( LARGER_THAN , v2 . compareTo ( new Version ( " 0.0.0.1 " ) ) ) ; assertEquals ( LARGER_THAN , v2 . compareTo ( new Version ( " 0.1.2.1 " ) ) ) ; assertEquals ( SMALLER_THAN , v2 . compareTo ( new Version ( " 0.1.2.4 " ) ) ) ; assertEquals ( SMALLER_THAN , v2 . compareTo ( new Version ( " 0.2.1.1 " ) ) ) ; assertEquals ( SMALLER_THAN , v2 . compareTo ( new Version ( " 0.1.2.3.4 " ) ) ) ; assertEquals ( EQUAL , v2 . compareTo ( new Version ( " 0.1.2.3 " ) ) ) ; Version v3 = new Version ( " 1.2.3.snapshot " ) ; assertEquals ( LARGER_THAN , v3 . compareTo ( new Version ( " 0 " ) ) ) ; assertEquals ( LARGER_THAN , v3 . compareTo ( new Version ( " 1.2.3 " ) ) ) ; assertEquals ( LARGER_THAN , v3 . compareTo ( new Version ( " 1.2.3.99 " ) ) ) ; assertEquals ( SMALLER_THAN , v3 . compareTo ( new Version ( " 1.2.3.snapshot.9 " ) ) ) ; assertEquals ( SMALLER_THAN , v3 . compareTo ( new Version ( " hello " ) ) ) ; } 
public void run ( ) { updater . checkPerformed ( UpdateChecker . this , appcast ) ; } 
public void run ( ) { updater . checkerFoundValidUpdate ( UpdateChecker . this , appcast ) ; } 
public void run ( ) { updater . checkerEncounteredError ( UpdateChecker . this , e ) ; } 
public boolean checkPerformed ( UpdateChecker checker , Appcast appcast ) { return false ; } 
public boolean checkerFoundValidUpdate ( UpdateChecker checker , Appcast appcast ) { return false ; } 
public boolean checkerEncounteredError ( UpdateChecker checker , Throwable ) { return false ; } 
public void checkForUpdates ( boolean showProgressWindow ) { if ( updateChecker ! = null & & updateChecker . isAlive ( ) ) return ; if ( showProgressWindow ) { updateCheckDialog = new UpdateCheckDialog ( null , this ) ; Window win = KeyboardFocusManager . getCurrentKeyboardFocusManager ( ) . getFocusedWindow ( ) ; SwingUtils . centerOnScreen ( updateCheckDialog , win ) ; updateCheckDialog . setVisible ( true ) ; } updateChecker = new UpdateChecker ( this , false ) ; updateChecker . start ( ) ; } 
public void checkForUpdatesInBackground ( ) { if ( shouldCheckForUpdate ( ) ) { updateChecker = new UpdateChecker ( this , true ) ; 
public void checkPerformed ( UpdateChecker checker , Appcast appcast ) { if ( updateCheckDialog ! = null ) { updateCheckDialog . setVisible ( false ) ; updateCheckDialog = null ; } Delegate method. if (delegate != null) if (delegate.checkPerformed(checker, appcast)) return; Store last check update check time. getPreferences().putLong(LAST_UPDATE_CHECK, System.currentTimeMillis()); try { getPreferences().flush(); 
public void checkerFoundValidUpdate ( UpdateChecker checker , Appcast appcast ) { Delegate method. if (delegate != null) if (delegate.checkerFoundValidUpdate(checker, appcast)) return; UpdateAlert alert = new UpdateAlert(this, appcast); Window win = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow(); SwingUtils.centerOnScreen(alert, win); alert.setVisible(true); alert.downloadReleaseNotes(); } 
public void checkerEncounteredError ( UpdateChecker checker , Throwable ) { if ( updateCheckDialog ! = null ) { updateCheckDialog . setVisible ( false ) ; updateCheckDialog = null ; } Delegate method. if (delegate != null) if (delegate.checkerEncounteredError(checker, t)) return; if (checker.isSilent()) { Logger.getLogger(getClass().getName()).log(Level.WARNING, "Update checker encountered error.", t); 
public void testCheckForUpdates ( ) { TestUpdateDelegate delegate = new TestUpdateDelegate ( ) ; updater . setDelegate ( delegate ) ; updater . checkForUpdates ( false ) ; try { updater . getUpdateChecker ( ) . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } assertTrue ( delegate . checkPerformed ) ; assertNull ( delegate . throwable ) ; AppcastItem item = delegate . appcast . getLatest ( ) ; assertNotNull ( item ) ; assertEquals ( new Version ( " 2.0 " ) , item . getVersion ( ) ) ; assertTrue ( item . isNewerThan ( host ) ) ; } 
public boolean checkPerformed ( UpdateChecker checker , Appcast appcast ) { checkPerformed = true ; return true ; } 
public boolean checkerFoundValidUpdate ( UpdateChecker checker , Appcast appcast ) { this . appcast = appcast ; return true ; } 
public boolean checkerEncounteredError ( UpdateChecker checker , Throwable ) { this . throwable = ; return true ; } 
public void run ( ) { updater . checkCompleted ( UpdateChecker . this , appcast ) ; } 
public boolean checkCompleted ( UpdateChecker checker , Appcast appcast ) { return false ; } 
public void checkCompleted ( UpdateChecker checker , Appcast appcast ) { if ( updateCheckDialog ! = null ) { updateCheckDialog . setVisible ( false ) ; updateCheckDialog = null ; } Delegate method. if (delegate != null) if (delegate.checkCompleted(checker, appcast)) return; Store last check update check time. getPreferences().putLong(LAST_UPDATE_CHECK, System.currentTimeMillis()); try { getPreferences().flush(); 
private void handleRequest ( Socket socket ) throws IOException { PrintStream os = new PrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; BufferedReader is = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; String line = is . readLine ( ) ; if ( line = = null ) return ; String version = " " ; StringTokenizer st = new StringTokenizer ( line ) ; String method = st . nextToken ( ) ; String fileName = st . nextToken ( ) ; if ( st . hasMoreTokens ( ) ) { version = st . nextToken ( ) ; } read header but ignore while ((line = is.readLine()) != null) { if (line.trim().equals("")) break; } we only do GET if (method.equals("GET") || method.equals("HEAD")) { boolean headOnly = false; if (method.equals("HEAD")) { headOnly = true; } byte[] data; File f = new File(mediaRoot, fileName); try { data = readFileAsString(f).getBytes(); String header = "HTTP/1.0 200 OK\r"; header += standardHeaders(); header += "Content-length: " + data.length + "\r"; header += "Content-type: text/xml\r\r"; os.print(header); if (!headOnly) { os.write(data); } } catch (IOException e) { String header = "HTTP/1.0 404 Not Found\r"; header += standardHeaders(); os.print(header); } os.flush(); os.close(); } else { not a get/head so output error if (version.startsWith("HTTP/")) { send headers String header = "HTTP/1.0 501 Not Implemented\r"; header += standardHeaders(); header += "Content-type: text/html\r\r"; os.print(header); } os.println("<HTML><HEAD><TITLE>Not Implemented</TITLE><HEAD>"); os.println("<BODY><H1>HTTP Error 501: Not Implemented</H1></BODY></HTML>"); } os.close(); socket.close(); } 
protected void setUp ( ) throws Exception { server = new MockAppcastServer ( MockHost . APPCAST_SERVER_PORT ) ; serverThread = new Thread ( server ) ; serverThread . start ( ) ; } 
protected void tearDown ( ) throws Exception { server . stop ( ) ; serverThread . join ( ) ; } 
public void testCheckForUpdates ( ) { Updater updater = new Updater ( new MockHost ( ) ) ; TestUpdateDelegate delegate = checkForUpdates ( updater ) ; assertTrue ( delegate . checkPerformed ) ; assertNull ( delegate . throwable ) ; AppcastItem item = delegate . appcast . getLatest ( ) ; assertNotNull ( item ) ; assertEquals ( new Version ( " 2.0 " ) , item . getVersion ( ) ) ; assertTrue ( item . isNewerThan ( updater . getHost ( ) ) ) ; } 
public void testNotFound ( ) { Updater updater = new Updater ( new NotFoundHost ( ) ) ; TestUpdateDelegate delegate = checkForUpdates ( updater ) ; assertFalse ( delegate . checkPerformed ) ; assertEquals ( FileNotFoundException . class , delegate . throwable . getClass ( ) ) ; } 
public void testUnreadableAppcast ( ) { Updater updater = new Updater ( new UnreadableHost ( ) ) ; TestUpdateDelegate delegate = checkForUpdates ( updater ) ; assertFalse ( delegate . checkPerformed ) ; assertEquals ( SAXParseException . class , delegate . throwable . getClass ( ) ) ; } 
private TestUpdateDelegate checkForUpdates ( Updater updater ) { TestUpdateDelegate delegate = new TestUpdateDelegate ( ) ; updater . setDelegate ( delegate ) ; updater . checkForUpdates ( false ) ; try { updater . getUpdateChecker ( ) . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } return delegate ; } 
public boolean checkCompleted ( UpdateChecker checker , Appcast appcast ) { checkPerformed = true ; return true ; } 
private TestUpdateDelegate checkForUpdates ( Updater updater ) { TestUpdateDelegate delegate = new TestUpdateDelegate ( ) ; updater . setDelegate ( delegate ) ; updater . checkForUpdates ( false ) ; try { updater . getUpdateChecker ( ) . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } The update checker calls invokeLater on the AWT event dispatch thread. We need to make sure this call finishes before we continue our test. By using invokeAndWait to place an empty action on the thread, we know that the calls will have finished. try { SwingUtilities.invokeAndWait(new Runnable() { public void run() { Do nothing; } }); } catch (Exception e) { throw new RuntimeException(e); } return delegate; } 
public void checkerFoundValidUpdate ( UpdateChecker checker , Appcast appcast ) { Delegate method. if (delegate != null) if (delegate.checkerFoundValidUpdate(checker, appcast)) return; UpdateAlert alert = new UpdateAlert(this, appcast); Window win = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow(); SwingUtils.centerOnScreen(alert, win); alert.setVisible(true); } 
public void testCheckForUpdates ( ) { Updater updater = new Updater ( new MockHost ( ) ) ; TestUpdateDelegate delegate = checkForUpdates ( updater ) ; assertTrue ( delegate . checkPerformed ) ; assertNull ( delegate . throwable ) ; AppcastItem item = delegate . appcast . getLatest ( ) ; assertNotNull ( item ) ; assertEquals ( new Version ( " 2.0 " ) , item . getVersion ( ) ) ; assertEquals ( " Version 2.0 " , item . getTitle ( ) ) ; assertEquals ( " 2.0 Release Notes. " , item . getDescription ( ) ) ; Months start from zero. GregorianCalendar c = new GregorianCalendar(2006, 0, 9, 19, 20, 11); c.setTimeZone(TimeZone.getTimeZone("UTC")); assertEquals(c.getTime(), item.getDate()); assertTrue(item.isNewerThan(updater.getHost())); } 
public void actionPerformed ( ActionEvent e ) { updater . cancelUpdateCheck ( ) ; setVisible ( false ) ; } 
public void run ( ) { updater . checkerDetectedLatestVersion ( UpdateChecker . this , appcast ) ; } 
public boolean checkerDetectedLatestVersion ( UpdateChecker checker , Appcast appcast ) { return false ; } 
public void checkCompleted ( UpdateChecker checker , Appcast appcast ) { hideUpdateCheckDialog ( ) ; Delegate method. if (delegate != null) if (delegate.checkCompleted(checker, appcast)) return; Store last check update check time. getPreferences().putLong(LAST_UPDATE_CHECK, System.currentTimeMillis()); try { getPreferences().flush(); 
public void checkerDetectedLatestVersion ( UpdateChecker checker , Appcast appcast ) { Delegate method. if (delegate != null) if (delegate.checkerDetectedLatestVersion(checker, appcast)) return; Show a message that you're using the latest version if you've explicitly checked for updates. if (!checker.isSilent()) { JOptionPane.showMessageDialog(null, "<html><b>You're up to date!</b><br>" + host.getName() + " " + host.getVersion() + " is the latest version available.", "", JOptionPane.INFORMATION_MESSAGE, getHostIcon()); 
public void checkerEncounteredError ( UpdateChecker checker , Throwable ) { hideUpdateCheckDialog ( ) ; Delegate method. if (delegate != null) if (delegate.checkerEncounteredError(checker, t)) return; if (checker.isSilent()) { Logger.getLogger(getClass().getName()).log(Level.WARNING, "Update checker encountered error.", t); 
private void hideUpdateCheckDialog ( ) { if ( updateCheckDialog ! = null ) { updateCheckDialog . setVisible ( false ) ; 
public void testCheckForUpdates ( ) { Updater updater = new Updater ( new MockHost ( ) ) ; TestUpdateDelegate delegate = checkForUpdates ( updater ) ; assertTrue ( delegate . checkPerformed ) ; assertTrue ( delegate . updateAvailable ) ; assertNull ( delegate . throwable ) ; AppcastItem item = delegate . appcast . getLatest ( ) ; assertNotNull ( item ) ; assertEquals ( new Version ( " 2.0 " ) , item . getVersion ( ) ) ; assertEquals ( " Version 2.0 " , item . getTitle ( ) ) ; assertEquals ( " 2.0 Release Notes. " , item . getDescription ( ) ) ; Months start from zero. GregorianCalendar c = new GregorianCalendar(2006, 0, 9, 19, 20, 11); c.setTimeZone(TimeZone.getTimeZone("UTC")); assertEquals(c.getTime(), item.getDate()); assertTrue(item.isNewerThan(updater.getHost())); } 
public void testLatestVersion ( ) { Updater updater = new Updater ( new LatestVersionHost ( ) ) ; TestUpdateDelegate delegate = checkForUpdates ( updater ) ; assertTrue ( delegate . checkPerformed ) ; assertFalse ( delegate . updateAvailable ) ; } 
public boolean checkerFoundValidUpdate ( UpdateChecker checker , Appcast appcast ) { this . appcast = appcast ; updateAvailable = true ; return true ; } 
public boolean checkerDetectedLatestVersion ( UpdateChecker checker , Appcast appcast ) { this . appcast = appcast ; updateAvailable = false ; return true ; } 
private void startNodeTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( NODE_NAME ) ; String prototypeId = attributes . getValue ( NODE_PROTOTYPE ) ; String typeAsString = attributes . getValue ( NODE_TYPE ) ; if ( name = = null ) throw new SAXException ( " Name attribute is required in node tags. " ) ; if ( prototypeId = = null ) throw new SAXException ( " Prototype attribute is required in node tags. " ) ; Class dataClass = null ; if ( typeAsString ! = null ) { try { dataClass = Class . forName ( typeAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Given type " + typeAsString + " not found. " ) ; } } Switch between relative and long identifiers. Long identifiers (e.g. "polygraph.rect") contain both a library and name and should be looked up using the manager. Only exported nodes will qualify. Short identifiers (e.g. "beta") contain only a name and are in the same library as this node. They should be looked up using the library. These can be non-exported nodes as well. Node prototype; if (prototypeId.contains(".")) { Long identifier prototype = manager.getNode(prototypeId); } else { Short identifier prototype = library.getRootNode().getChild(prototypeId); } if (prototype == null) throw new SAXException("Unknown prototype " + prototypeId + " for node " + name); Node newNode = prototype.newInstance(library, name, dataClass); Add the child to the node library or its parent if (currentNode == null) { library.add(newNode); } else { currentNode.add(newNode); } Parse additional node flags. String x = attributes.getValue(NODE_X); String y = attributes.getValue(NODE_Y); if (x != null) newNode.setX(Double.parseDouble(x)); if (y != null) newNode.setY(Double.parseDouble(y)); if ("true".equals(attributes.getValue(NODE_RENDERED))) newNode.setRendered(); if ("true".equals(attributes.getValue(NODE_EXPORTED))) newNode.setExported(true); Go down into the current node; this will now become the current network. currentNode = newNode; } 
private void startParameterTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( PARAMETER_NAME ) ; String typeAsString = attributes . getValue ( PARAMETER_TYPE ) ; if ( currentNode = = null ) throw new SAXException ( " Parameter tag encountered without a current node. " ) ; if ( name = = null ) throw new SAXException ( " Name is required for parameter on node ' " + currentNode . getName ( ) + " '. " ) ; if ( typeAsString = = null ) { No type attribute was given, so the parameter should already exist. currentParameter = currentNode.getParameter(name); if (currentParameter == null) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' does not exist."); } else { Type was given, so this is a new parameter. TODO: If type is given and parameter exists, migrate type. if (currentNode.hasParameter(name)) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' already exists."); Parameter.Type type = Parameter.Type.valueOf(typeAsString.toUpperCase()); currentParameter = currentNode.addParameter(name, type); } Parse parameter attributes. String widget = attributes.getValue(PARAMETER_WIDGET); String label = attributes.getValue(PARAMETER_LABEL); String helpText = attributes.getValue(PARAMETER_HELP_TEXT); String displayLevel = attributes.getValue(PARAMETER_DISPLAY_LEVEL); String boundingMethod = attributes.getValue(PARAMETER_BOUNDING_METHOD); String minimumValue = attributes.getValue(PARAMETER_MINIMUM_VALUE); String maximumValue = attributes.getValue(PARAMETER_MAXIMUM_VALUE); if (widget != null) currentParameter.setWidget(Parameter.Widget.valueOf(widget.toUpperCase())); if (label != null) currentParameter.setLabel(label); if (helpText != null) currentParameter.setHelpText(helpText); if (displayLevel != null) currentParameter.setDisplayLevel(Parameter.DisplayLevel.valueOf(displayLevel.toUpperCase())); if (boundingMethod != null) currentParameter.setBoundingMethod(Parameter.BoundingMethod.valueOf(boundingMethod.toUpperCase())); if (minimumValue != null) currentParameter.setMinimumValue(Float.parseFloat(minimumValue)); if (maximumValue != null) currentParameter.setMaximumValue(Float.parseFloat(maximumValue)); 
private void startConnectionTag ( Attributes attributes ) throws SAXException { output node identifier, without package String outputAsString = attributes.getValue(CONNECTION_OUTPUT); input node identifier, without package String inputAsString = attributes.getValue(CONNECTION_INPUT); input port identifier String portAsString = attributes.getValue(CONNECTION_PORT); String currentNodeString = currentNode == null ? "<null>" : currentNode.getName(); if (outputAsString == null) throw new SAXException("Output is required for connection in node '" + currentNodeString + "'."); if (inputAsString == null) throw new SAXException("Input is required for connection in node '" + currentNodeString + "'."); if (portAsString == null) throw new SAXException("Port is required for connection in node '" + currentNodeString + "'."); Node output, input; if (currentNode == null) { output = rootNode.getChild(outputAsString); input = rootNode.getChild(inputAsString); } else { output = currentNode.getChild(outputAsString); input = currentNode.getChild(inputAsString); } if (output == null) throw new SAXException("Output node '" + outputAsString + "' does not exist."); if (input == null) throw new SAXException("Input node '" + inputAsString + "' does not exist."); Port port = input.getPort(portAsString); if (port == null) throw new SAXException("Port '" + portAsString + "' on node '" + inputAsString + "' does not exist."); port.connect(output); } 
public Node get ( String name ) { if ( " root " . equals ( name ) ) return rootNode ; return rootNode . getExportedChild ( name ) ; } 
public void testPosition ( ) { NodeLibrary l = new NodeLibrary ( " test " ) ; Node = Node . ROOT_NODE . newInstance ( l , " test " ) ; . setPosition ( 25 , 50 ) ; NodeLibrary lib = parseXml ( l . toXml ( ) ) ; Node test = lib . getRootNode ( ) . getChild ( " test " ) ; assertEquals ( 25.0 , test . getX ( ) ) ; assertEquals ( 50.0 , test . getY ( ) ) ; } 
public void testOnlyDefaults ( ) { String xml = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" type= \" nodebox.node.polygraph.Polygon \" ></node> " + NDBX_FOOTER ; NodeLibrary library = parseXml ( xml ) ; Node protoDot = manager . getNode ( " testlib.dot " ) ; assertTrue ( library . contains ( " dot1 " ) ) ; Node dot1 = library . getRootNode ( ) . getChild ( " dot1 " ) ; assertEquals ( protoDot , dot1 . getPrototype ( ) ) ; Since dot1 inherits from the prototype, it has all the parameters of the prototype. assertTrue(dot1.hasParameter("x")); assertTrue(dot1.hasParameter("y")); This is really an implementation detail. We should not make guarantees about the "same-ness" of parameters. assertNotSame(protoDot.getParameter("x"), dot1.getParameter("x")); assertEquals(0F, dot1.getValue("x")); assertEquals(0F, dot1.getValue("y")); } 
public void testPortTypes ( ) { NodeLibrary typeLib = new NodeLibrary ( " typeLib " ) ; Node . ROOT_NODE . newInstance ( typeLib , " alpha " , Polygon . class ) ; String xml = typeLib . toXml ( ) ; NodeLibrary library = parseXml ( xml ) ; Node alpha = library . getRootNode ( ) . getChild ( " alpha " ) ; assertEquals ( Polygon . class , alpha . getDataClass ( ) ) ; Create a new instance with the same output type. Store it in a temporary node library. NodeLibrary betaLibrary = new NodeLibrary("xxx"); alpha.newInstance(betaLibrary, "beta"); String s = betaLibrary.toXml(); The output type is the same, so should not be persisted. assertFalse(s.contains("Polygon")); Check if ports have their types persisted. Node n = Node.ROOT_NODE.newInstance(typeLib, "gamma", Polygon.class); n.addPort("polygon"); xml = typeLib.toXml(); library = parseXml(xml); Node gamma = library.getRootNode().getChild("gamma"); assertEquals(Polygon.class, gamma.getDataClass()); } 
private void loadBasicTypes ( ) { NodeLibrary testlib = new NodeLibrary ( " testlib " ) ; Node dot = Node . ROOT_NODE . newInstance ( testlib , " dot " , Polygon . class ) ; dot . setExported ( true ) ; testlib . add ( dot ) ; dot . addParameter ( " x " , Parameter . Type . FLOAT , 0F ) ; dot . addParameter ( " y " , Parameter . Type . FLOAT , 0F ) ; Node rotate = Node . ROOT_NODE . newInstance ( testlib , " rotate " , Polygon . class ) ; rotate . setExported ( true ) ; testlib . add ( rotate ) ; rotate . addPort ( " shape " ) ; rotate . addParameter ( " rotation " , Parameter . Type . FLOAT , 0F ) ; manager . add ( testlib ) ; } 
public void testCodeLoading ( ) { Node hello = Node . ROOT_NODE . newInstance ( testLibrary , " hello " ) ; String code = " def cook(self): n return 'hello' " ; hello . setValue ( " _code " , new PythonCode ( code ) ) ; hello . update ( ) ; assertEquals ( " hello " , hello . getOutputValue ( ) ) ; Store/load library NodeLibrary newLibrary = storeAndLoad(testLibrary); Node newHello = newLibrary.getRootNode().getChild("hello"); newHello.update(); assertEquals("hello", newHello.getOutputValue()); } 
public void testTypeLoading ( ) { Node allTypes = Node . ROOT_NODE . newInstance ( testLibrary , " allTypes " ) ; allTypes . addParameter ( " i " , Parameter . Type . INT , 42 ) ; allTypes . addParameter ( " f " , Parameter . Type . FLOAT , 42 F ) ; allTypes . addParameter ( " s " , Parameter . Type . STRING , " 42 " ) ; allTypes . addParameter ( " c " , Parameter . Type . COLOR , new Color ( 0.4 , 0.2 , 0.1 , 0.9 ) ) ; NodeLibrary newLibrary = storeAndLoad ( testLibrary ) ; Node newAllTypes = newLibrary . getRootNode ( ) . getChild ( " allTypes " ) ; Parameter pI = newAllTypes . getParameter ( " i " ) ; Parameter pF = newAllTypes . getParameter ( " f " ) ; Parameter pS = newAllTypes . getParameter ( " s " ) ; Parameter pC = newAllTypes . getParameter ( " c " ) ; assertEquals ( Parameter . Type . INT , pI . getType ( ) ) ; assertEquals ( Parameter . Type . FLOAT , pF . getType ( ) ) ; assertEquals ( Parameter . Type . STRING , pS . getType ( ) ) ; assertEquals ( Parameter . Type . COLOR , pC . getType ( ) ) ; assertEquals ( " i " , pI . getName ( ) ) ; assertEquals ( 42 , pI . getValue ( ) ) ; assertEquals ( 42 F , pF . getValue ( ) ) ; assertEquals ( " 42 " , pS . getValue ( ) ) ; assertEquals ( new Color ( 0.4 , 0.2 , 0.1 , 0.9 ) , pC . getValue ( ) ) ; } 
public void testNodeNameChange ( ) { NodeLibrary test = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( test , " alpha " ) ; We export the node since we want to test the NodeLibrary#get method, which only returns exported nodes. alpha.setExported(true); test.add(alpha); assertEquals(alpha, test.get("alpha")); now change the name alpha.setName("beta"); assertEquals(alpha, test.get("beta")); } 
public void testStoreConnections ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " , Polygon . class ) ; Node beta = Node . ROOT_NODE . newInstance ( library , " beta " , Polygon . class ) ; beta . addPort ( " polygon " ) ; beta . getPort ( " polygon " ) . connect ( alpha ) ; assertTrue ( alpha . isConnectedTo ( beta ) ) ; assertTrue ( beta . isConnectedTo ( alpha ) ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , library . toXml ( ) , manager ) ; Node newAlpha = newLibrary . getRootNode ( ) . getChild ( " alpha " ) ; Node newBeta = newLibrary . getRootNode ( ) . getChild ( " beta " ) ; assertTrue ( newAlpha . isConnectedTo ( newBeta ) ) ; assertTrue ( newBeta . isConnectedTo ( newAlpha ) ) ; } 
public void testStoreExpressions ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " ) ; alpha . addParameter ( " v " , Parameter . Type . INT ) ; alpha . setValue ( " v " , 10 ) ; alpha . getParameter ( " v " ) . setExpression ( " 44 - 2 " ) ; Inherit from alpha. Node beta = alpha.newInstance(library, "beta"); Check if the expression tag only appears once. String xml = library.toXml(); assertOnlyOnce(xml, "<expression>"); NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.getRootNode().getChild("alpha"); assertEquals("44 - 2", newAlpha.getParameter("v").getExpression()); newAlpha.update(); assertEquals(42, newAlpha.getValue("v")); } 
public void testStoreParameterAttributes ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " , Polygon . class ) ; Parameter pAngle = alpha . addParameter ( " angle " , Parameter . Type . FLOAT , 42 ) ; pAngle . setWidget ( Parameter . Widget . ANGLE ) ; pAngle . setMinimumValue ( - 360 f ) ; pAngle . setMaximumValue ( 360 f ) ; pAngle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; Parameter pMenu = alpha . addParameter ( " menu " , Parameter . Type . STRING , " es " ) ; pMenu . setWidget ( Parameter . Widget . MENU ) ; pMenu . addMenuItem ( " en " , " English " ) ; pMenu . addMenuItem ( " es " , " Spanish " ) ; Parameter pHidden = alpha . addParameter ( " hidden " , Parameter . Type . STRING , " invisible " ) ; pHidden . setDisplayLevel ( Parameter . DisplayLevel . HIDDEN ) ; Parameter pLabel = alpha . addParameter ( " label " , Parameter . Type . STRING , " label + help text " ) ; pLabel . setLabel ( " My Label " ) ; pLabel . setHelpText ( " My Help Text " ) ; Inherit from alpha. This is used to test if prototype data is stored only once. alpha.newInstance(library, "beta"); String xml = library.toXml(); assertOnlyOnce(xml, "<param name=\"menu\""); NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.getRootNode().getChild("alpha"); Parameter newAngle = newAlpha.getParameter("angle"); assertEquals(Parameter.Widget.ANGLE, newAngle.getWidget()); assertEquals(Parameter.BoundingMethod.HARD, newAngle.getBoundingMethod()); assertEquals(-360f, newAngle.getMinimumValue()); assertEquals(360f, newAngle.getMaximumValue()); Parameter newMenu = newAlpha.getParameter("menu"); assertEquals(Parameter.Widget.MENU, newMenu.getWidget()); Parameter.MenuItem item0 = newMenu.getMenuItems().get(0); Parameter.MenuItem item1 = newMenu.getMenuItems().get(1); assertEquals("en", item0.getKey()); assertEquals("English", item0.getLabel()); assertEquals("es", item1.getKey()); assertEquals("Spanish", item1.getLabel()); Parameter newHidden = newAlpha.getParameter("hidden"); assertEquals(Parameter.DisplayLevel.HIDDEN, newHidden.getDisplayLevel()); assertEquals("invisible", newHidden.getValue()); Parameter newLabel = newAlpha.getParameter("label"); assertEquals("My Label", newLabel.getLabel()); assertEquals("My Help Text", newLabel.getHelpText()); } 
public void testStoreChildren ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node net = Node . ROOT_NODE . newInstance ( library , " net " , Polygon . class ) ; Node alpha = net . create ( Node . ROOT_NODE , " alpha " , Polygon . class ) ; Node beta = net . create ( Node . ROOT_NODE , " beta " , Polygon . class ) ; Port pPolygon = beta . addPort ( " polygon " ) ; pPolygon . connect ( alpha ) ; String xml = library . toXml ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , xml , manager ) ; Node newNet = newLibrary . getRootNode ( ) . getChild ( " net " ) ; assertTrue ( newNet . hasChildren ( ) ) ; Node newAlpha = newNet . getChild ( " alpha " ) ; Node newBeta = newNet . getChild ( " beta " ) ; assertTrue ( newBeta . isConnectedTo ( newAlpha ) ) ; } 
public void testExportFlag ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node exportMe = Node . ROOT_NODE . newInstance ( library , " exportMe " ) ; exportMe . setExported ( true ) ; Node hideMe = Node . ROOT_NODE . newInstance ( library , " hideMe " ) ; List < Node > exportedNodes = library . getExportedNodes ( ) ; assertEquals ( 1 , exportedNodes . size ( ) ) ; assertEquals ( exportMe , exportedNodes . get ( 0 ) ) ; assertTrue ( exportMe . isExported ( ) ) ; assertFalse ( hideMe . isExported ( ) ) ; Test if the exported flag is persisted. String xml = library.toXml(); NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); List<Node> newExportedNodes = newLibrary.getExportedNodes(); assertEquals(1, newExportedNodes.size()); Node newExportMe = newExportedNodes.get(0); assertEquals("exportMe", newExportMe.getName()); assertTrue(newExportMe.isExported()); You can still access the non-exported nodes using getRootNode().getChildren() Node newHideMe = newLibrary.getRootNode().getChild("hideMe"); assertEquals("hideMe", newHideMe.getName()); assertFalse(newHideMe.isExported()); Try accessing through the library assertEquals(newExportMe, newLibrary.get("exportMe")); assertNull(newLibrary.get("hideMe")); Test if a new instance based on this prototype loses the flag. NodeLibrary doc = new NodeLibrary("doc"); Node myExportInstance = exportMe.newInstance(doc, "myExportInstance"); assertFalse(myExportInstance.isExported()); Note that you can create instances of non-exported nodes as well. They just don't show up in library.getExportedNodes(). Node myHideMeInstance = hideMe.newInstance(doc, "myHideMeInstance"); assertFalse(myHideMeInstance.isExported()); } 
public void testExportInternalInstances ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Alpha and beta are both non-exported. Node alpha = Node.ROOT_NODE.newInstance(library, "alpha"); Node beta = alpha.newInstance(library, "beta"); Store and load this library. String xml = library.toXml(); NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); assertEquals(0, newLibrary.getExportedNodes().size()); Node newAlpha = newLibrary.getRootNode().getChild("alpha"); Node newBeta = newLibrary.getRootNode().getChild("beta"); assertEquals(newAlpha, newBeta.getPrototype()); } 
public void assertCanStoreHelpText ( String helpText ) { Create a library and node to store the value. NodeLibrary library = new NodeLibrary("test"); Node alpha = Node.ROOT_NODE.newInstance(library, "alpha", Polygon.class); Parameter pValue = alpha.addParameter("value", Parameter.Type.STRING); pValue.setHelpText(helpText); Store the library to XML. String xml = library.toXml(); Load the library from the XML, and retrieve the value. NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.getRootNode().getChild("alpha"); Parameter newValue = newAlpha.getParameter("value"); assertEquals(helpText, newValue.getHelpText()); } 
public void assertCanStoreValue ( Parameter . Type type , Object value ) { Create a library and node to store the value. NodeLibrary library = new NodeLibrary("test"); Node alpha = Node.ROOT_NODE.newInstance(library, "alpha", Polygon.class); alpha.addParameter("value", type, value); Store the library to XML. String xml = library.toXml(); Load the library from the XML, and retrieve the value. NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.getRootNode().getChild("alpha"); assertEquals(value, newAlpha.getValue("value")); } 
public void assertCanStoreExpression ( Parameter p , String expression ) { String nodeName = p . getNode ( ) . getName ( ) ; String parameterName = p . getName ( ) ; p . setExpression ( expression ) ; String xml = p . getLibrary ( ) . toXml ( ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , xml , manager ) ; Node newAlpha = newLibrary . getRootNode ( ) . getChild ( nodeName ) ; Parameter newParameter = newAlpha . getParameter ( parameterName ) ; assertEquals ( expression , newParameter . getExpression ( ) ) ; } 
public void testLoad ( ) { The example.ndbx references polygraph nodes, so make sure those are loaded. PolygraphLibrary polygraph = new PolygraphLibrary(); manager.add(polygraph); manager.load(new File("test/demo.ndbx")); assertNotNull(manager.get("demo")); assertNotNull(manager.getNode("demo.root")); assertNull(manager.getNode("demo.rect1")); assertNull(manager.getNode("demo.move1")); assertNotNull(manager.getNode("demo.exportedRect")); Node rect1 = manager.get("demo").getRootNode().getChild("rect1"); Node move1 = manager.get("demo").getRootNode().getChild("move1"); assertEquals(polygraph.get("rect"), rect1.getPrototype()); assertEquals(Node.ROOT_NODE, move1.getPrototype()); assertTrue(rect1.hasParameter("x")); assertTrue(rect1.hasParameter("y")); assertFalse(rect1.hasParameter("tx")); assertTrue(move1.hasParameter("tx")); assertTrue(move1.hasParameter("ty")); assertFalse(move1.hasParameter("x")); Test connections assertTrue(move1.getPort("polygon").isConnectedTo(rect1)); assertTrue(rect1.isConnectedTo(move1)); Try executing rect1.update(); Object obj = rect1.getOutputValue(); assertEquals(Polygon.class, obj.getClass()); assertEquals(new Rectangle(0, 0, 100, 100), ((Polygon) obj).getBounds()); move1.update(); obj = move1.getOutputValue(); assertEquals(Polygon.class, obj.getClass()); assertEquals(new Rectangle(15, -40, 100, 100), ((Polygon) obj).getBounds()); } 
public void testStoreAndLoad ( ) throws IOException { Create a temporary file to store the nodes in. File f = temporaryLibraryFile(); The name of the library without extension is how the library will be stored in the manager. Since we generate a temporary file, we need to know its name to retrieve it from the manager. String basename = FileUtils.stripExtension(f); NodeLibrary storedLibrary = new NodeLibrary(basename); Node dotNode = Node.ROOT_NODE.newInstance(storedLibrary, "dot"); dotNode.setExported(true); dotNode.addParameter("x", Parameter.Type.FLOAT); dotNode.addParameter("y", Parameter.Type.FLOAT); Node circleNode = dotNode.newInstance(storedLibrary, "circle"); circleNode.setExported(true); circleNode.addParameter("size", Parameter.Type.FLOAT, 50F); storedLibrary.add(dotNode); storedLibrary.add(circleNode); try { Store the node library 
public void testOrderedDependencies ( ) throws IOException { Create a temporary file to store the nodes in. File f = temporaryLibraryFile(); try { The library stores nodes in a Set so we can't know the exact ordering of the nodes. 
private void testOrderedDependencies ( File f , String [ ] names ) throws IOException { resetManager ( ) ; The name of the library without extension is how the library will be stored in the manager. Since we generate a temporary file, we need to know its name to retrieve it from the manager. String basename = FileUtils.stripExtension(f); NodeLibrary library = new NodeLibrary(basename); Node prototype = Node.ROOT_NODE; for (String name : names) { Node instance = prototype.newInstance(library, name); library.add(instance); prototype = instance; } library.store(f); manager.load(f); NodeLibrary newLib = manager.get(basename); Node newPrototype = Node.ROOT_NODE; for (String name : names) { Node newInstance = newLib.getRootNode().getChild(name); 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " number " , Integer . class ) ; . setExported ( true ) ; . addParameter ( " value " , Parameter . Type . INT ) ; . addPort ( " valuePort " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " negate " , Integer . class ) ; . setExported ( true ) ; . addPort ( " value " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " add " , Integer . class ) ; . setExported ( true ) ; . addPort ( " v1 " ) ; . addPort ( " v2 " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " addDirect " , Integer . class ) ; . setExported ( true ) ; . addParameter ( " v1 " , Parameter . Type . INT ) ; . addParameter ( " v2 " , Parameter . Type . INT ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " addConstant " , Integer . class ) ; . setExported ( true ) ; . addPort ( " value " ) ; . addParameter ( " constant " , Parameter . Type . INT ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " multiply " , Integer . class ) ; . setExported ( true ) ; . addPort ( " v1 " ) ; . addPort ( " v2 " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " multiAdd " , Integer . class ) ; . setExported ( true ) ; . addPort ( " values " , Port . Cardinality . MULTIPLE ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " floatNegate " , Float . class ) ; . setExported ( true ) ; . addPort ( " value " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " convertToUppercase " , String . class ) ; . setExported ( true ) ; . addPort ( " value " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " crash " , Integer . class ) ; . setExported ( true ) ; . addPort ( " value " ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( TestNodes . this , " testnet " , Integer . class ) ; . setExported ( true ) ; return ; } 
public Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " polygon " , Polygon . class ) ; . setExported ( true ) ; . addParameter ( " path " , Parameter . Type . STRING ) ; return ; } 
public Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " rect " , Polygon . class ) ; . setExported ( true ) ; . addParameter ( " x " , Parameter . Type . FLOAT , 0 ) ; . addParameter ( " y " , Parameter . Type . FLOAT , 0 ) ; . addParameter ( " width " , Parameter . Type . FLOAT , 100 ) ; . addParameter ( " height " , Parameter . Type . FLOAT , 100 ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " translate " , Polygon . class ) ; . setExported ( true ) ; . addPort ( " polygon " ) ; . addParameter ( " tx " , Parameter . Type . FLOAT ) ; . addParameter ( " ty " , Parameter . Type . FLOAT ) ; return ; } 
protected Node createInstance ( ) { Node = Node . ROOT_NODE . newInstance ( PolygraphLibrary . this , " merge " , Polygon . class ) ; . setExported ( true ) ; . addPort ( " polygons " , Port . Cardinality . MULTIPLE ) ; return ; } 
private void settingsSelected ( ) { editorPanel . removeAll ( ) ; NodeSettingsEditor editor = new NodeSettingsEditor ( node ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; selectedPort = null ; selectedParameter = null ; } 
public void addNodeSettings ( ) { final SourceLabel label = new SourceLabel ( NODE_SETTINGS , NODE_SETTINGS ) ; label . addMouseListener ( new MouseInputAdapter ( ) { public void mouseClicked ( MouseEvent e ) { setSelectedLabel ( label ) ; } } ) ; labelMap . put ( NODE_SETTINGS , label ) ; add ( label ) ; } 
public void addPort ( final Port p ) { final SourceLabel label = new SourceLabel ( p . getName ( ) , p ) ; label . addMouseListener ( new MouseInputAdapter ( ) { public void mouseClicked ( MouseEvent e ) { setSelectedLabel ( label ) ; } } ) ; labelMap . put ( p , label ) ; add ( label ) ; } 
public void addParameter ( final Parameter p ) { final SourceLabel label = new SourceLabel ( p . getName ( ) , p ) ; label . addMouseListener ( new MouseInputAdapter ( ) { public void mouseClicked ( MouseEvent e ) { setSelectedLabel ( label ) ; } } ) ; labelMap . put ( p , label ) ; add ( label ) ; } 
public void addHeader ( String s ) { JLabel header = new JLabel ( s ) ; header . setForeground ( Theme . TEXT_HEADER_COLOR ) ; header . setFont ( Theme . SMALL_BOLD_FONT ) ; header . setMinimumSize ( new Dimension ( 100 , 25 ) ) ; header . setMaximumSize ( new Dimension ( 500 , 25 ) ) ; header . setPreferredSize ( new Dimension ( 140 , 25 ) ) ; header . setAlignmentX ( JComponent . LEFT_ALIGNMENT ) ; header . setBorder ( BorderFactory . createEmptyBorder ( 0 , 10 , 0 , 0 ) ) ; add ( header ) ; } 
private void initPanel ( ) { setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; JPanel contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new BoxLayout ( contentPanel , BoxLayout . Y_AXIS ) ) ; Exported exportBox = new JCheckBox("Exported (available to users of this library)"); exportBox.addActionListener(this); contentPanel.add(exportBox); contentPanel.add(Box.createVerticalGlue()); add(contentPanel); } 
public void updateValues ( ) { exportBox . setSelected ( node . isExported ( ) ) ; revalidate ( ) ; } 
public void focusGained ( FocusEvent e ) { Do nothing. } public void focusLost(FocusEvent e) { actionPerformed(new ActionEvent(e.getSource(), 0, "focusLost")); }} 
public void stateChanged ( ChangeEvent e ) { float zoomFactor = zoomSlider . getValue ( ) / 100 f ; viewer . setZoomFactor ( zoomFactor ) ; } 
private void initMenus ( ) { viewerMenu = new JPopupMenu ( ) ; viewerMenu . add ( new ResetViewAction ( ) ) ; PopupHandler popupHandler = new PopupHandler ( ) ; addInputEventListener ( popupHandler ) ; } 
private nodebox . graphics . Point pointForEvent ( MouseEvent e ) { Point2D originalPoint = new Point2D . Float ( e . getX ( ) , e . getY ( ) ) ; PAffineTransform transform = getCamera ( ) . getViewTransform ( ) ; Point2D transformedPoint ; try { transformedPoint = transform . inverseTransform ( originalPoint , null ) ; } catch ( NoninvertibleTransformException ex ) { return new nodebox . graphics . Point ( 0 , 0 ) ; } double cx = - getWidth ( ) / 2.0 + transformedPoint . getX ( ) ; double cy = - getHeight ( ) / 2.0 + transformedPoint . getY ( ) ; return new nodebox . graphics . Point ( ( float ) cx , ( float ) cy ) ; } 
public void mouseClicked ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseClicked ( pointForEvent ( e ) ) ; 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mousePressed ( pointForEvent ( e ) ) ; 
public void mouseReleased ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseReleased ( pointForEvent ( e ) ) ; 
public void mouseEntered ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseEntered ( pointForEvent ( e ) ) ; 
public void mouseExited ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseExited ( pointForEvent ( e ) ) ; 
public void mouseDragged ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseDragged ( pointForEvent ( e ) ) ; 
public void mouseMoved ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; requestFocus ( ) ; if ( hasVisibleHandle ( ) ) handle . mouseMoved ( pointForEvent ( e ) ) ; 
public void processEvent ( PInputEvent e , int i ) { if ( ! e . isPopupTrigger ( ) ) return ; if ( e . isHandled ( ) ) return ; Point2D p = e . getCanvasPosition ( ) ; viewerMenu . show ( Viewer . this , ( int ) p . getX ( ) , ( int ) p . getY ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { Font font = ( Font ) fontChooser . getSelectedItem ( ) ; if ( font = = null ) return ; String fontName = font . getFontName ( ) ; if ( ! fontName . equals ( parameter . asString ( ) ) ) { parameter . setValue ( font . getFontName ( ) ) ; 
public void copy ( ) { Find current network view. JOptionPane.showMessageDialog(this, "Cut/copy/paste is not implemented yet.", "NodeBox", JOptionPane.ERROR_MESSAGE); } 
public Parameter copyWithUpstream ( Node newNode ) { Parameter p = new Parameter ( newNode , getName ( ) , getType ( ) ) ; p . setValue ( getValue ( ) ) ; copyAttributes ( p ) ; return p ; } 
public Parameter clone ( Node ) { This will call revertToDefault, which will set the value/expression to that of the prototype. Parameter p = new Parameter(n, getName(), getType()); copyAttributes(p); return p; } 
public void testCopyWithUpstream ( ) { We create a simple network where alpha <- beta <- gamma beta will be the node to copy. This checks if upstreams/downstreams are handled correctly. Node net1 = testNetworkNode.newInstance(testLibrary, "net1"); Node net2 = testNetworkNode.newInstance(testLibrary, "net2"); Node alpha = net1.create(Node.ROOT_NODE, "alpha", Integer.class); Node beta = net1.create(Node.ROOT_NODE, "beta", Integer.class); String originalDescription = "Beta description"; beta.setDescription(originalDescription); beta.setValue("_code", new PythonCode("def cook(self): return self.value")); Node gamma = net1.create(Node.ROOT_NODE, "gamma", Integer.class); int originalValue = 5; beta.addParameter("value", Parameter.Type.INT, originalValue); Port betaPort1 = beta.addPort("betaPort1"); Port gammaPort1 = gamma.addPort("gammaPort1"); betaPort1.connect(alpha); gammaPort1.connect(beta); Update and clean the network. gamma.update(); assertFalse(beta.isDirty()); assertEquals(originalValue, beta.getOutputValue()); Copying under the same parent will give the node a unique name. Node beta1 = beta.copyWithUpstream(net1); assertEquals("beta1", beta1.getName()); Copying under a different parent keep the original name. Node beta2 = beta.copyWithUpstream(net2); assertEquals("beta", beta2.getName()); The node inherits from the same prototype as the original. assertSame(beta.getPrototype(), beta1.getPrototype()); It also retains all the same changes as the original. assertSame(beta.getDataClass(), beta1.getDataClass()); assertTrue(beta1.hasParameter("value")); assertEquals(originalValue, beta1.asInt("value")); assertTrue(beta1.hasPort("betaPort1")); Some other properties. assertEquals(0.0, beta1.getX()); assertEquals(0.0, beta1.getY()); assertEquals(originalDescription, beta1.getDescription()); The new node will be dirty and won't have any output data. assertTrue(beta1.isDirty()); assertNull(beta1.getOutputValue()); It also retains connections to the upstream nodes, although the connection objects differ. It does not retain connections to the downstream nodes since that would replace existing connections. assertTrue(beta1.isConnectedTo(alpha)); Connection newConn = beta1.getPort("betaPort1").getConnection(); assertNotSame(betaPort1.getConnection(), newConn); assertFalse(beta1.isConnectedTo(gamma)); If the new node is under a different parent connections cannot be retained. assertFalse(beta2.isConnected()); Try updating the node to see if the results are still correct. beta1.update(); assertEquals(originalValue, beta1.getOutputValue()); Changes to the copy should not affect the original and vice versa. int newValueForOriginal = 11; int newValueForCopy = 33; beta.setValue("value", newValueForOriginal); assertEquals(originalValue, beta1.asInt("value")); beta1.setValue("value", newValueForCopy); assertEquals(newValueForOriginal, beta.asInt("value")); } 
public void testParameterCloning ( ) { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter aAngle = createCustomAngleParameter ( alpha ) ; Node beta = alpha . newInstance ( testLibrary , " beta " ) ; Parameter bAngle = beta . getParameter ( " angle " ) ; assertEqualsParameter ( aAngle , bAngle ) ; } 
public void testCopyWithUpstream ( ) { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Node beta = Node . ROOT_NODE . newInstance ( testLibrary , " beta " ) ; Parameter aAngle = createCustomAngleParameter ( alpha ) ; Parameter bAngle = aAngle . copyWithUpstream ( beta ) ; assertEqualsParameter ( aAngle , bAngle ) ; } 
private Parameter createCustomAngleParameter ( Node ) { Parameter aAngle = . addParameter ( " angle " , Parameter . Type . FLOAT , 42 F ) ; aAngle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; aAngle . setMinimumValue ( 0F ) ; aAngle . setMaximumValue ( 360 F ) ; aAngle . setLabel ( " My Angle " ) ; aAngle . setDisplayLevel ( Parameter . DisplayLevel . HUD ) ; aAngle . setHelpText ( " The angle of the node. " ) ; aAngle . setWidget ( Parameter . Widget . ANGLE ) ; return aAngle ; } 
private void assertEqualsParameter ( Parameter original , Parameter actual ) { assertNotNull ( actual ) ; assertNotSame ( original , actual ) ; assertEquals ( original . getValue ( ) , actual . getValue ( ) ) ; assertEquals ( original . getBoundingMethod ( ) , actual . getBoundingMethod ( ) ) ; assertEquals ( original . getMinimumValue ( ) , actual . getMinimumValue ( ) ) ; assertEquals ( original . getMaximumValue ( ) , actual . getMaximumValue ( ) ) ; assertEquals ( original . getLabel ( ) , actual . getLabel ( ) ) ; assertEquals ( original . getDisplayLevel ( ) , actual . getDisplayLevel ( ) ) ; assertEquals ( original . getHelpText ( ) , actual . getHelpText ( ) ) ; assertEquals ( original . getWidget ( ) , actual . getWidget ( ) ) ; } 
public void select ( Node node ) { NodeView nodeView = getNodeView ( node ) ; addToSelection ( nodeView ) ; } 
public void select ( Set < NodeView > newSelection ) { boolean selectionChanged = false ; ArrayList < NodeView > nodeViewsToRemove = new ArrayList < NodeView > ( ) ; for ( NodeView nodeView : selection ) { if ( ! newSelection . contains ( nodeView ) ) { selectionChanged = true ; nodeView . setSelected ( false ) ; nodeViewsToRemove . add ( nodeView ) ; } } for ( NodeView nodeView : nodeViewsToRemove ) { selection . remove ( nodeView ) ; } for ( NodeView nodeView : newSelection ) { if ( ! selection . contains ( nodeView ) ) { selectionChanged = true ; nodeView . setSelected ( true ) ; selection . add ( nodeView ) ; } } if ( selectionChanged ) firePropertyChange ( SELECT_PROPERTY , null , selection ) ; 
public void addToSelection ( NodeView nodeView ) { if ( nodeView = = null ) return ; If the selection already contained the object, bail out. This is to prevent the select event from firing. if (selection.contains(nodeView)) return; selection.add(nodeView); nodeView.setSelected(true); firePropertyChange(SELECT_PROPERTY, null, selection); } 
public void addToSelection ( Set < NodeView > newSelection ) { boolean selectionChanged = false ; for ( NodeView nodeView : newSelection ) { if ( ! selection . contains ( nodeView ) ) { selectionChanged = true ; nodeView . setSelected ( true ) ; selection . add ( nodeView ) ; } } if ( selectionChanged ) firePropertyChange ( SELECT_PROPERTY , null , selection ) ; 
public void deleteSelected ( ) { Set < NodeView > nodesToRemove = new HashSet < NodeView > ( selection ) ; for ( NodeView nodeView : nodesToRemove ) { node . remove ( nodeView . getNode ( ) ) ; } connectionLayer . deleteSelected ( ) ; } 
public void cutSelected ( ) { Node parent = getNode ( ) ; ArrayList < Node > nodesToCopy = new ArrayList < Node > ( selection . size ( ) ) ; for ( NodeView nv : selection ) { Node = nv . getNode ( ) ; nodesToCopy . add ( ) ; } for ( Node : nodesToCopy ) { parent . remove ( ) ; } Application . getInstance ( ) . setNodeClipboard ( nodesToCopy ) ; } 
public void copySelected ( ) { ArrayList < Node > nodesToCopy = new ArrayList < Node > ( selection . size ( ) ) ; for ( NodeView nv : selection ) { Node = nv . getNode ( ) ; nodesToCopy . add ( ) ; } Application . getInstance ( ) . setNodeClipboard ( nodesToCopy ) ; } 
public void pasteSelected ( ) { Node newParent = getNode ( ) ; List < Node > nodesToCopy = Application . getInstance ( ) . getNodeClipboard ( ) ; if ( nodesToCopy = = null | | nodesToCopy . size ( ) = = 0 ) return ; Node parent = nodesToCopy . get ( 0 ) . getParent ( ) ; TODO: Cut operation removes parent from child nodes, so no parent is available. This is a problem for connections. if (parent == null) return; Collection<Node> newNodes = parent.copyChildren(nodesToCopy, newParent); deselectAll(); for (Node newNode : newNodes) { NodeView nv = getNodeView(newNode); 
public void mousePressed ( PInputEvent e ) { if ( e . getButton ( ) ! = MouseEvent . BUTTON1 ) return ; temporarySelection . clear ( ) ; Make sure no Node View is under the mouse cursor. In that case, we're not selecting, but moving a node. Point2D p = e.getPosition(); NodeView nv = getNodeViewAt(p); if (nv == null) { selectionMarker = new SelectionMarker(p); 
public void cut ( ) { NetworkView networkView = currentNetworkView ( ) ; if ( networkView = = null ) { beep ( ) ; return ; } networkView . cutSelected ( ) ; } 
public void copy ( ) { NetworkView networkView = currentNetworkView ( ) ; if ( networkView = = null ) { beep ( ) ; return ; } networkView . copySelected ( ) ; } 
public void paste ( ) { NetworkView networkView = currentNetworkView ( ) ; if ( networkView = = null ) { beep ( ) ; return ; } networkView . pasteSelected ( ) ; } 
private NetworkView currentNetworkView ( ) { Find current network view. Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner(); if (focusOwner == null) return null; Pane pane = (Pane) SwingUtilities.getAncestorOfClass(Pane.class, focusOwner); if (pane == null) return null; PaneView paneView = pane.getPaneView(); if (!(paneView instanceof NetworkView)) return null; return (NetworkView) paneView; } 
public void deleteSelected ( ) { NetworkView networkView = currentNetworkView ( ) ; if ( networkView = = null ) { beep ( ) ; return ; } networkView . deleteSelected ( ) ; } 
private void beep ( ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; } 
public String uniqueName ( String prefix ) { Matcher m = NUMBER_AT_THE_END . matcher ( prefix ) ; m . find ( ) ; String namePrefix = m . group ( 1 ) ; String number = m . group ( 2 ) ; int counter ; if ( number . length ( ) > 0 ) { counter = Integer . parseInt ( number ) ; } else { counter = 1 ; } while ( true ) { String suggestedName = namePrefix + counter ; 
public Node copyChild ( Node child , Node newParent ) { ArrayList < Node > children = new ArrayList < Node > ( 1 ) ; children . add ( child ) ; Collection < Node > newChildren = copyChildren ( children , newParent ) ; assert newChildren . size ( ) = = 1 ; return newChildren . iterator ( ) . next ( ) ; } 
public Port copy ( Node newNode ) { return new Port ( newNode , getName ( ) , getCardinality ( ) , getDirection ( ) ) ; } 
public void testUniqueName ( ) { Node net = Node . ROOT_NODE . newInstance ( testLibrary , " net " ) ; Node node = Node . ROOT_NODE . newInstance ( testLibrary , " node " ) ; Node node1 = net . create ( node ) ; assertEquals ( " node1 " , node1 . getName ( ) ) ; assertEquals ( " node2 " , net . uniqueName ( " node " ) ) ; assertEquals ( " node2 " , net . uniqueName ( " node1 " ) ) ; assertEquals ( " node33 " , net . uniqueName ( " node33 " ) ) ; Node node99 = net . create ( node , " node99 " ) ; assertEquals ( " node2 " , net . uniqueName ( " node " ) ) ; assertEquals ( " node100 " , net . uniqueName ( " node99 " ) ) ; assertEquals ( " node12a1 " , net . uniqueName ( " node12a " ) ) ; } 
public void testCopyWithUpstream ( ) { We create a simple network where alpha1 <- beta1 <- gamma1 beta1 will be the node to copy. This checks if upstreams/downstreams are handled correctly. Node net1 = testNetworkNode.newInstance(testLibrary, "net1"); Node net2 = testNetworkNode.newInstance(testLibrary, "net2"); Node alpha1 = net1.create(Node.ROOT_NODE, "alpha1", Integer.class); Node beta1 = net1.create(Node.ROOT_NODE, "beta1", Integer.class); String originalDescription = "Beta description"; beta1.setDescription(originalDescription); beta1.setValue("_code", new PythonCode("def cook(self): return self.value")); Node gamma1 = net1.create(Node.ROOT_NODE, "gamma1", Integer.class); int originalValue = 5; beta1.addParameter("value", Parameter.Type.INT, originalValue); Port betaPort1 = beta1.addPort("betaPort1"); Port gammaPort1 = gamma1.addPort("gammaPort1"); betaPort1.connect(alpha1); gammaPort1.connect(beta1); Update and clean the network. gamma1.update(); assertFalse(beta1.isDirty()); assertEquals(originalValue, beta1.getOutputValue()); Copying under the same parent will give the node a unique name. Node beta2 = net1.copyChild(beta1, net1); assertEquals("beta2", beta2.getName()); Copying under a different parent keep the original name. Node beta3 = net1.copyChild(beta1, net2); assertEquals("beta1", beta3.getName()); The node inherits from the same prototype as the original. assertSame(beta1.getPrototype(), beta2.getPrototype()); It also retains all the same changes as the original. assertSame(beta1.getDataClass(), beta2.getDataClass()); assertTrue(beta2.hasParameter("value")); assertEquals(originalValue, beta2.asInt("value")); assertTrue(beta2.hasPort("betaPort1")); Some other properties. assertEquals(0.0, beta2.getX()); assertEquals(0.0, beta2.getY()); assertEquals(originalDescription, beta2.getDescription()); The new node will be dirty and won't have any output data. assertTrue(beta2.isDirty()); assertNull(beta2.getOutputValue()); It also retains connections to the upstream nodes, although the connection objects differ. It does not retain connections to the downstream nodes since that would replace existing connections. assertTrue(beta2.isConnectedTo(alpha1)); Connection newConn = beta2.getPort("betaPort1").getConnection(); assertNotSame(betaPort1.getConnection(), newConn); assertFalse(beta2.isConnectedTo(gamma1)); If the new node is under a different parent connections cannot be retained. assertFalse(beta3.isConnected()); Try updating the node to see if the results are still correct. beta2.update(); assertEquals(originalValue, beta2.getOutputValue()); Changes to the copy should not affect the original and vice versa. int newValueForOriginal = 11; int newValueForCopy = 33; beta1.setValue("value", newValueForOriginal); assertEquals(originalValue, beta2.asInt("value")); beta2.setValue("value", newValueForCopy); assertEquals(newValueForOriginal, beta1.asInt("value")); } 
public void testCopyComplex ( ) { number1-> negate1 -> addConstant1 -> multiAdd1 We'll copy negate1 and addConstant1. Node net1 = testNetworkNode.newInstance(testLibrary, "net1"); Node number1 = net1.create(numberNode); Node negate1 = net1.create(negateNode); Node addConstant1 = net1.create(addConstantNode); Node multiAdd1 = net1.create(multiAddNode); Wire up the network. multiAdd1.getPort("values").connect(addConstant1); addConstant1.getPort("value").connect(negate1); negate1.getPort("value").connect(number1); Set some values. number1.setValue("value", 42); addConstant1.setValue("constant", 2); multiAdd1.setRendered(); Check the output. net1.update(); assertEquals(-40, net1.getOutputValue()); Copy negate1 and addConstant1. ArrayList<Node> children = new ArrayList<Node>(); children.add(negate1); children.add(addConstant1); Collection<Node> newChildren = net1.copyChildren(children, net1); assertEquals(2, newChildren.size()); Node negate2 = net1.getChild("negate2"); Node addConstant2 = net1.getChild("addConstant2"); assertNotNull(negate2); assertNotNull(addConstant2); assertTrue(negate2.isConnectedTo(number1)); assertTrue(addConstant2.isConnectedTo(negate2)); assertFalse(addConstant2.isConnectedTo(negate1)); assertFalse(multiAdd1.isConnectedTo(addConstant2)); Connect the copies to multiAdd1 and update. multiAdd1.getPort("values").connect(addConstant2); net1.update(); assertEquals(-80, net1.getOutputValue()); Copy negate1 and addConstant1 into a different network. Node net2 = testNetworkNode.newInstance(testLibrary, "net2"); Collection<Node> net2Children = net1.copyChildren(children, net2); assertEquals(2, net2Children.size()); Node net2Negate1 = net2.getChild("negate1"); Node net2AddConstant1 = net2.getChild("addConstant1"); assertNotNull(net2Negate1); assertNotNull(net2AddConstant1); assertFalse(net2Negate1.isConnectedTo(number1)); assertTrue(net2AddConstant1.isConnectedTo(net2Negate1)); assertFalse(multiAdd1.isConnectedTo(net2AddConstant1)); } 
public Object cook ( Node node , ProcessingContext context ) { List < Object > values = node . getPortValues ( " values " ) ; int sum = 0 ; for ( Object obj : values ) { int v = ( Integer ) obj ; sum + = v ; } return sum ; } 
public Parameter copyWithUpstream ( Node newNode ) { Parameter p = new Parameter ( newNode , getName ( ) , getType ( ) ) ; if ( hasExpression ( ) ) { p . setExpression ( getExpression ( ) ) ; } else { p . setValue ( getValue ( ) ) ; } copyAttributes ( p ) ; return p ; } 
public void testCopyWithUpstream ( ) { We create a simple network where alpha1 <- beta1 <- gamma1 beta1 will be the node to copy. This checks if upstreams/downstreams are handled correctly. Node net1 = testNetworkNode.newInstance(testLibrary, "net1"); Node net2 = testNetworkNode.newInstance(testLibrary, "net2"); Node alpha1 = net1.create(Node.ROOT_NODE, "alpha1", Integer.class); Node beta1 = net1.create(Node.ROOT_NODE, "beta1", Integer.class); String originalDescription = "Beta description"; beta1.setDescription(originalDescription); beta1.setValue("_code", new PythonCode("def cook(self): return self.value")); Node gamma1 = net1.create(Node.ROOT_NODE, "gamma1", Integer.class); int originalValue = 5; beta1.addParameter("value", Parameter.Type.INT, originalValue); Port betaPort1 = beta1.addPort("betaPort1"); Port gammaPort1 = gamma1.addPort("gammaPort1"); betaPort1.connect(alpha1); gammaPort1.connect(beta1); Update and clean the network. gamma1.update(); assertFalse(beta1.isDirty()); assertEquals(originalValue, beta1.getOutputValue()); Copying under the same parent will give the node a unique name. Node beta2 = net1.copyChild(beta1, net1); assertEquals("beta2", beta2.getName()); Copying under a different parent keep the original name. Node beta3 = net1.copyChild(beta1, net2); assertEquals("beta1", beta3.getName()); The node inherits from the same prototype as the original. assertSame(beta1.getPrototype(), beta2.getPrototype()); It also retains all the same changes as the original. assertSame(beta1.getDataClass(), beta2.getDataClass()); assertTrue(beta2.hasParameter("value")); assertEquals(originalValue, beta2.asInt("value")); assertTrue(beta2.hasPort("betaPort1")); Some other properties. assertEquals(20.0, beta2.getX()); assertEquals(80.0, beta2.getY()); assertEquals(originalDescription, beta2.getDescription()); The new node will be dirty and won't have any output data. assertTrue(beta2.isDirty()); assertNull(beta2.getOutputValue()); It also retains connections to the upstream nodes, although the connection objects differ. It does not retain connections to the downstream nodes since that would replace existing connections. assertTrue(beta2.isConnectedTo(alpha1)); Connection newConn = beta2.getPort("betaPort1").getConnection(); assertNotSame(betaPort1.getConnection(), newConn); assertFalse(beta2.isConnectedTo(gamma1)); If the new node is under a different parent connections cannot be retained. assertFalse(beta3.isConnected()); Try updating the node to see if the results are still correct. beta2.update(); assertEquals(originalValue, beta2.getOutputValue()); Changes to the copy should not affect the original and vice versa. int newValueForOriginal = 11; int newValueForCopy = 33; beta1.setValue("value", newValueForOriginal); assertEquals(originalValue, beta2.asInt("value")); beta2.setValue("value", newValueForCopy); assertEquals(newValueForOriginal, beta1.asInt("value")); } 
public void testCopyWithUpstream ( ) { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Node beta = Node . ROOT_NODE . newInstance ( testLibrary , " beta " ) ; Node gamma = Node . ROOT_NODE . newInstance ( testLibrary , " gamma " ) ; Parameter aAngle = createCustomAngleParameter ( alpha ) ; Parameter bAngle = aAngle . copyWithUpstream ( beta ) ; assertEqualsParameter ( aAngle , bAngle ) ; aAngle . setExpression ( " 42 * 2 " ) ; Parameter gAngle = aAngle . copyWithUpstream ( beta ) ; assertEqualsParameter ( aAngle , gAngle ) ; } 
private void assertEqualsParameter ( Parameter original , Parameter actual ) { assertNotNull ( actual ) ; assertNotSame ( original , actual ) ; if ( original . hasExpression ( ) ) { assertEquals ( original . getExpression ( ) , actual . getExpression ( ) ) ; } else { assertEquals ( original . getValue ( ) , actual . getValue ( ) ) ; } assertEquals ( original . getBoundingMethod ( ) , actual . getBoundingMethod ( ) ) ; assertEquals ( original . getMinimumValue ( ) , actual . getMinimumValue ( ) ) ; assertEquals ( original . getMaximumValue ( ) , actual . getMaximumValue ( ) ) ; assertEquals ( original . getLabel ( ) , actual . getLabel ( ) ) ; assertEquals ( original . getDisplayLevel ( ) , actual . getDisplayLevel ( ) ) ; assertEquals ( original . getHelpText ( ) , actual . getHelpText ( ) ) ; assertEquals ( original . getWidget ( ) , actual . getWidget ( ) ) ; } 
public void testCopyChild ( ) { Node net1 = testNetworkNode . newInstance ( testLibrary , " net1 " ) ; Node net2 = testNetworkNode . newInstance ( testLibrary , " net2 " ) ; Node number1 = net1 . create ( numberNode ) ; Node newNumber1 = net1 . copyChild ( number1 , net2 ) ; assertEquals ( net2 , newNumber1 . getParent ( ) ) ; } 
public void testCopyChildren ( ) { Node root = testLibrary . getRootNode ( ) ; Node net1 = testNetworkNode . newInstance ( testLibrary , " net1 " ) ; Node number1 = net1 . create ( numberNode ) ; Node negate1 = net1 . create ( negateNode ) ; Node subnet1 = net1 . create ( testNetworkNode , " subnet1 " ) ; Node subNumber1 = subnet1 . create ( numberNode ) ; negate1 . getPort ( " value " ) . connect ( number1 ) ; negate1 . setRendered ( ) ; number1 . setValue ( " value " , 42 ) ; subNumber1 . setValue ( " value " , 33 ) ; net1 . update ( ) ; assertEquals ( - 42 , net1 . getOutputValue ( ) ) ; try { root . copyChild ( negate1 , root ) ; fail ( " Should have thrown error. " ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) . contains ( " not a child of this parent " ) ) ; } Node net2 = root . copyChild ( net1 , root ) ; assertEquals ( " net2 " , net2 . getName ( ) ) ; Node net2number1 = net2 . getChild ( " number1 " ) ; Node net2negate1 = net2 . getChild ( " negate1 " ) ; assertEquals ( " negate1 " , net2negate1 . getName ( ) ) ; assertTrue ( net2negate1 . getPort ( " value " ) . isConnectedTo ( net2number1 ) ) ; assertEquals ( 33 , net2 . getChild ( " subnet1 " ) . getChild ( " number1 " ) . getValue ( " value " ) ) ; Not updated yet. assertNull(net2.getOutputValue()); net2.update(); assertEquals(-42, net1.getOutputValue()); } 
private Node rawInstance ( NodeLibrary library , String name , Class dataClass ) { if ( library = = null ) throw new IllegalArgumentException ( " Library parameter cannot be null. " ) ; if ( dataClass = = null ) dataClass = getDataClass ( ) ; Node = new Node ( library , name , dataClass ) ; . prototype = this ; . dirty = true ; Clone all parameters. for (Parameter p : parameters.values()) { n.parameters.put(p.getName(), p.clone(n)); } Clone all ports. for (Port p : ports.values()) { n.ports.put(p.getName(), p.clone(n)); } Copy all children. copyChildren(n); return n; } 
public void testNewInstanceChildren ( ) { Node root = testLibrary . getRootNode ( ) ; Test if children of the prototype are copied as well. Node protoNet = root.create(testNetworkNode, "protoNet"); Node number1 = protoNet.create(numberNode); Node negate1 = protoNet.create(negateNode); number1.setExpression("value", "40+2"); negate1.getPort("value").connect(number1); negate1.setRendered(); Create new node based on prototype. Node protoNet1 = root.create(protoNet); assertEquals("protoNet1", protoNet1.getName()); assertTrue(protoNet1.contains("number1")); assertTrue(protoNet1.contains("negate1")); assertTrue(protoNet1.getChild("negate1").isConnectedTo(protoNet1.getChild("number1"))); assertEquals(0, protoNet1.getChild("number1").getValue("value")); assertEquals("40+2", protoNet1.getChild("number1").getParameter("value").getExpression()); protoNet1.update(); assertEquals(42, protoNet1.getChild("number1").getValue("value")); assertEquals(-42, protoNet1.getOutputValue()); } 
public void testNewInstanceExpression ( ) { Node protoNumber = numberNode . newInstance ( testLibrary , " protoNumber " ) ; protoNumber . setExpression ( " value " , " 40+2 " ) ; Node proto1 = protoNumber . newInstance ( testLibrary , " proto1 " ) ; assertEquals ( 0 , proto1 . getValue ( " value " ) ) ; assertEquals ( " 40+2 " , proto1 . getParameter ( " value " ) . getExpression ( ) ) ; proto1 . update ( ) ; assertEquals ( 42 , proto1 . getValue ( " value " ) ) ; assertEquals ( 42 , proto1 . getOutputValue ( ) ) ; } 
public static void initializePython ( ) { Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = PlatformUtils.getUserDataDirectory() + PlatformUtils.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. String workingDirectory = System.getProperty("user.dir"); File pythonLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "python.zip"); File nodeBoxLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "nodeboxlibs.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Py.getSystemState().path.add(new PyString(nodeBoxLibraries.getAbsolutePath())); This folder contains unarchived NodeBox libraries. Only used in development. Py.getSystemState().path.add(new PyString("src-python")); Add the user's Python directory. Py.getSystemState().path.add(new PyString(PlatformUtils.getUserPythonDirectory().getAbsolutePath())); } 
public static File getUserDataDirectory ( ) throws RuntimeException { if ( userDataDirectory ! = null ) return userDataDirectory ; if ( onMac ( ) ) { userDataDirectory = new File ( getHomeDirectory ( ) , " Library/ " + Application . NAME ) ; } else if ( onWindows ( ) ) { Try to read the local application data from the system environment first. This environment variable is only available on Windows Vista/7. If this fails, try to read the registry, which works on most systems, but is deprecated, and has been known to be missing. String localAppData = System.getenv("LOCALAPPDATA"); if (localAppData != null) { userDataDirectory = new File(localAppData, Application.NAME); } else { userDataDirectory = new File(readWindowsRegistryValue(REG_SHELL_FOLDERS, REG_LOCAL_APPDATA), Application.NAME); } } else { userDataDirectory = new File(getHomeDirectory(), Application.NAME.toLowerCase()); } return userDataDirectory; } 
public static File getUserDataDirectory ( ) throws RuntimeException { if ( userDataDirectory ! = null ) return userDataDirectory ; if ( onMac ( ) ) { userDataDirectory = new File ( getHomeDirectory ( ) , " Library/ " + Application . NAME ) ; } else if ( onWindows ( ) ) { Try to read the local application data from the system environment first. This environment variable is only available on Windows Vista/7. String localAppData = System.getenv("LOCALAPPDATA"); if (localAppData == null) { If this fails, try to read the registry, which works on most systems, but is deprecated, and has been known to be missing. localAppData = readWindowsRegistryValue(REG_SHELL_FOLDERS, REG_LOCAL_APPDATA); if (localAppData == null) { If reading the registry fails, use the home directory. localAppData = getHomeDirectory().getPath(); } } userDataDirectory = new File(localAppData, Application.NAME); } else { userDataDirectory = new File(getHomeDirectory(), Application.NAME.toLowerCase()); } return userDataDirectory; } 
public void resetView ( ) { getCamera ( ) . setViewTransform ( new AffineTransform ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { resetView ( ) ; } 
public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Draw the origin. Point2D origin = getCamera().getViewTransform().transform(viewerLayer.getOffset(), null); int x = (int) Math.round(origin.getX()); int y = (int) Math.round(origin.getY()); if (showOrigin) { g.setColor(Color.DARK_GRAY); 
public void toggleOrigin ( ) { viewer . setShowOrigin ( originCheck . isChecked ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { PlatformUtils . openURL ( " http:beta.nodebox.net/ " ) ; } 
private void startNodeTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( NODE_NAME ) ; String prototypeId = attributes . getValue ( NODE_PROTOTYPE ) ; String typeAsString = attributes . getValue ( NODE_TYPE ) ; if ( name = = null ) throw new SAXException ( " Name attribute is required in node tags. " ) ; if ( prototypeId = = null ) throw new SAXException ( " Prototype attribute is required in node tags. " ) ; Class dataClass = null ; if ( typeAsString ! = null ) { try { dataClass = Class . forName ( typeAsString ) ; } catch ( ClassNotFoundException e ) { throw new SAXException ( " Given type " + typeAsString + " not found. " ) ; } } Switch between relative and long identifiers. Long identifiers (e.g. "polygraph.rect") contain both a library and name and should be looked up using the manager. Only exported nodes will qualify. Short identifiers (e.g. "beta") contain only a name and are in the same library as this node. They should be looked up using the library. These can be non-exported nodes as well. Node prototype; if (prototypeId.contains(".")) { Long identifier prototype = manager.getNode(prototypeId); } else { Short identifier prototype = library.getRootNode().getChild(prototypeId); } if (prototype == null) throw new SAXException("Unknown prototype " + prototypeId + " for node " + name); Create the child at the root of the node library or the current parent Node newNode; if (currentNode == null) { newNode = library.getRootNode().create(prototype, name, dataClass); } else { newNode = currentNode.create(prototype, name, dataClass); } Parse additional node flags. String x = attributes.getValue(NODE_X); String y = attributes.getValue(NODE_Y); if (x != null) newNode.setX(Double.parseDouble(x)); if (y != null) newNode.setY(Double.parseDouble(y)); if ("true".equals(attributes.getValue(NODE_RENDERED))) newNode.setRendered(); if ("true".equals(attributes.getValue(NODE_EXPORTED))) newNode.setExported(true); Go down into the current node; this will now become the current network. currentNode = newNode; } 
public void testSameNameChild ( ) { resetManager ( ) ; NodeLibrary test = new NodeLibrary ( " test " ) ; Node rect1 = Node . ROOT_NODE . newInstance ( test , " rect1 " , Polygon . class ) ; Node innerRect1 = rect1 . create ( Node . ROOT_NODE , " rect1 " ) ; NodeLibrary newTest = NodeLibrary . load ( " newTest " , test . toXml ( ) , manager ) ; Node newRect1 = newTest . getRootNode ( ) . getChild ( " rect1 " ) ; assertNotNull ( newRect1 ) ; assertNotNull ( newRect1 . getChild ( " rect1 " ) ) ; } 
public void actionPerformed ( ActionEvent e ) { setColor ( color ) ; dispose ( ) ; } 
public void windowClosing ( WindowEvent e ) { setColor ( newColor ) ; } 
public void stateChanged ( ChangeEvent e ) { if ( changeDisabled ) return ; } 
private void updateRGB ( ) { Color c = Color . getHSBColor ( hue , saturation , brightness ) ; red = clamp ( ( float ) ( c . getRed ( ) / 255.0 ) ) ; green = clamp ( ( float ) ( c . getGreen ( ) / 255.0 ) ) ; blue = clamp ( ( float ) ( c . getBlue ( ) / 255.0 ) ) ; } 
private void updateHSB ( ) { float [ ] hsb = new float [ 3 ] ; Color . RGBtoHSB ( Math . round ( red * 255 ) , Math . round ( green * 255 ) , Math . round ( blue * 255 ) , hsb ) ; hue = clamp ( hsb [ 0 ] ) ; saturation = clamp ( hsb [ 1 ] ) ; brightness = clamp ( hsb [ 2 ] ) ; } 
private void updateColor ( ) { newColor = new Color ( red , green , blue , alpha ) ; updatePanels ( ) ; fireStateChanged ( ) ; } 
private void updatePanels ( ) { colorField . repaint ( ) ; for ( ColorPanel panel : panels ) { panel . updateDraggableNumber ( ) ; 
public void mouseClicked ( MouseEvent e ) { if ( e . getX ( ) > = 2 & & e . getX ( ) < = 70 & & e . getY ( ) > = 38 & & e . getY ( ) < = 70 ) setColor ( color ) ; 
protected void paintComponent ( Graphics g ) { g . setColor ( newColor ) ; g . fillRect ( 2 , 2 , 68 , 35 ) ; g . setColor ( color ) ; g . fillRect ( 2 , 37 , 68 , 34 ) ; g . setColor ( Color . LIGHT_GRAY ) ; g . drawRect ( 2 , 2 , 67 , 67 ) ; g . setColor ( new Color ( 0.6F , 0.6F , 0.6F ) ) ; g . drawLine ( 3 , 2 , 68 , 2 ) ; } 
public void updateDraggableNumber ( ) { float range = 0.0F ; if ( colorRange = = ColorRange . ABSOLUTE ) range = 255.0F ; else if ( colorRange = = ColorRange . PERCENTAGE ) range = 100.0F ; switch ( colorComponent ) { case RED : 
private void drawRed ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; int width = r . width - WIDTH_OFFSET ; for ( int i = 0 ; i < width ; i + + ) { Color c = new Color ( ( float ) i / width , green , blue ) ; 
private void drawGreen ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; int width = r . width - WIDTH_OFFSET ; for ( int i = 0 ; i < width ; i + + ) { Color c = new Color ( red , ( float ) i / width , blue ) ; 
private void drawBlue ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; int width = r . width - WIDTH_OFFSET ; for ( int i = 0 ; i < width ; i + + ) { Color c = new Color ( red , green , ( float ) i / width ) ; 
private void drawAlpha ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; int width = r . width - WIDTH_OFFSET ; for ( int i = 0 ; i < width ; i + + ) { Color c = new Color ( red , green , blue , ( float ) i / width ) ; 
private void drawHue ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; int width = r . width - WIDTH_OFFSET ; for ( int i = 0 ; i < width ; i + + ) { Color hsb = Color . getHSBColor ( ( float ) i / width , saturation , brightness ) ; 
private void drawSaturation ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; int width = r . width - WIDTH_OFFSET ; for ( int i = 0 ; i < width ; i + + ) { Color hsb = Color . getHSBColor ( hue , ( float ) i / width , brightness ) ; 
private void drawBrightness ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; int width = r . width - WIDTH_OFFSET ; for ( int i = 0 ; i < width ; i + + ) { Color hsb = Color . getHSBColor ( hue , saturation , ( float ) i / width ) ; 
public void mousePressed ( MouseEvent e ) { colorRangePopup . show ( this , - 15 , 20 ) ; } 
public void actionPerformed ( ActionEvent e ) { setColorRange ( colorRange ) ; ColorRangeMenu . this . repaint ( ) ; } 
public void actionPerformed ( ActionEvent e ) { setColor ( newColor ) ; ColorDialog . this . setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { setColor ( color ) ; ColorDialog . this . setVisible ( false ) ; } 
public void mousePressed ( MouseEvent e ) { colorRangePopup . show ( this , 0 , 20 ) ; } 
public void focusLost ( FocusEvent e ) { commitNumberField ( ) ; numberField . setVisible ( false ) ; } 
public void focusLost ( FocusEvent e ) { commitNumberField ( ) ; } 
public NodeBoxDocument createNewDocument ( ) { NodeBoxDocument doc = new NodeBoxDocument ( ) ; doc . setVisible ( true ) ; doc . requestFocus ( ) ; documents . add ( doc ) ; currentDocument = doc ; return doc ; } 
public static File getUserDataDirectory ( ) throws RuntimeException { if ( userDataDirectory ! = null ) return userDataDirectory ; if ( onMac ( ) ) { userDataDirectory = new File ( getHomeDirectory ( ) , " Library/ " + Application . NAME ) ; } else if ( onWindows ( ) ) { String localAppData ; HWND hwndOwner = null ; int nFolder = Shell32 . CSIDL_LOCAL_APPDATA ; HANDLE hToken = null ; int dwFlags = Shell32 . SHGFP_TYPE_CURRENT ; char [ ] pszPath = new char [ Shell32 . MAX_PATH ] ; int hResult = Shell32 . INSTANCE . SHGetFolderPath ( hwndOwner , nFolder , hToken , dwFlags , pszPath ) ; if ( Shell32 . S_OK = = hResult ) { String path = new String ( pszPath ) ; int len = path . indexOf ( '\0' ) ; localAppData = path . substring ( 0 , len ) ; } else { If the native call fails, use the home directory. localAppData = getHomeDirectory().getPath(); } userDataDirectory = new File(localAppData, Application.NAME); } else { userDataDirectory = new File(getHomeDirectory(), Application.NAME.toLowerCase()); } return userDataDirectory; } 
public int SHGetFolderPath ( HWND hwndOwner , int nFolder , HANDLE hToken , int dwFlags , char [ ] pszPath ) ; } } 
public void addSearchPath ( File f ) { if ( ! f . isDirectory ( ) ) throw new IllegalArgumentException ( " The given file should be a directory: " + f ) ; searchPaths . add ( f ) ; } 
public static void render ( Grob g , File file ) { Rect bounds = g . getBounds ( ) ; I'm using fully qualified class names here so as not to polute the class' namespace. com.itextpdf.text.Rectangle size = new com.itextpdf.text.Rectangle(bounds.getWidth(), bounds.getHeight()); com.itextpdf.text.Document document = new com.itextpdf.text.Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } com.itextpdf.text.pdf.PdfWriter writer; try { writer = com.itextpdf.text.pdf.PdfWriter.getInstance(document, fos); } catch (com.itextpdf.text.DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); com.itextpdf.text.pdf.PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = contentByte.createGraphics(bounds.getWidth(), bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); g.draw(graphics); graphics.dispose(); document.close(); } 
public void inheritFromContext ( GraphicsContext ctx ) { } public void draw ( Graphics2D g ) { if ( getPointCount ( ) < 2 ) return ; Since a contour has no fill or stroke information, draw it in black. We save the current color so as not to disrupt the context. java.awt.Color savedColor = g.getColor(); Stroke savedStroke = g.getStroke(); GeneralPath gp = new GeneralPath(GeneralPath.WIND_EVEN_ODD, getPointCount()); _extendPath(gp); g.setColor(java.awt.Color.BLACK); g.setStroke(DEFAULT_STROKE); g.draw(gp); g.setColor(savedColor); g.setStroke(savedStroke); } void _extendPath(GeneralPath gp) { if (points.size() == 0) return; Point pt = points.get(0); Point ctrl1, ctrl2; gp.moveTo(pt.x, pt.y); int pointCount = getPointCount(); for (int i = 1; i < pointCount; i++) { pt = points.get(i); if (pt.isLineTo()) { gp.lineTo(pt.x, pt.y); } else if (pt.isCurveTo()) { ctrl1 = points.get(i - 2); ctrl2 = points.get(i - 1); gp.curveTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, pt.x, pt.y); } } if (closed) gp.closePath(); } public void transform(Transform t) { t.map(getPoints()); invalidate(); } Conversions public Path toPath() { return new Path(this); } Object operations public Contour clone() { return new Contour(this); }} 
void _extendPath ( GeneralPath gp ) { if ( points . size ( ) = = 0 ) return ; Point pt = points . get ( 0 ) ; Point ctrl1 , ctrl2 ; gp . moveTo ( pt . x , pt . y ) ; int pointCount = getPointCount ( ) ; for ( int i = 1 ; i < pointCount ; i + + ) { pt = points . get ( i ) ; if ( pt . isLineTo ( ) ) { gp . lineTo ( pt . x , pt . y ) ; } else if ( pt . isCurveTo ( ) ) { ctrl1 = points . get ( i - 2 ) ; ctrl2 = points . get ( i - 1 ) ; gp . curveTo ( ctrl1 . x , ctrl1 . y , ctrl2 . x , ctrl2 . y , pt . x , pt . y ) ; } } if ( closed ) gp . closePath ( ) ; 
public void inheritFromContext ( GraphicsContext ctx ) ; public void draw ( Graphics2D g ) ; Geometric queries public boolean isEmpty(); public Rect getBounds(); Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky);} 
public void draw ( Graphics2D g ) ; Geometric queries public boolean isEmpty(); public Rect getBounds(); Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky);} 
public boolean isEmpty ( ) ; public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky);} 
public boolean isEmpty ( ) { return image = = null | | image . getWidth ( ) = = 0 | | image . getHeight ( ) = = 0 ; } 
public boolean isEmpty ( ) { return getPointCount ( ) = = 0 ; } 
public void draw ( Graphics2D g ) { If we can't fill or stroke the path, there's nothing to draw. if (fillColor == null && strokeColor == null) return; GeneralPath gp = getGeneralPath(); Rect r = getBounds(); If there are no points, there's nothing to draw. if (getPointCount() == 0) return; if (fillColor != null) { g.setColor(fillColor.getAwtColor()); g.fill(gp); } if (strokeWidth > 0 && strokeColor != null) { try { 
public boolean isEmpty ( ) { return text . trim ( ) . length ( ) = = 0 ; } 
public void testEmptyBounds ( ) { Contour c = new Contour ( ) ; Rect r = c . getBounds ( ) ; assertEquals ( new Rect ( ) , r ) ; } 
private void assertRectPoints ( IGeometry g , float x , float y , float width , float height ) { assertEquals ( 4 , g . getPointCount ( ) ) ; List < Point > points = g . getPoints ( ) ; assertPointEquals ( x , y , points . get ( 0 ) ) ; assertPointEquals ( x + width , y , points . get ( 1 ) ) ; assertPointEquals ( x + width , y + height , points . get ( 2 ) ) ; assertPointEquals ( x , y + height , points . get ( 3 ) ) ; } 
public void testEmptyBounds ( ) { assertEquals ( new Rect ( ) , new Geometry ( ) . getBounds ( ) ) ; Path p1 = new Path ( ) ; p1 . rect ( 100 , 200 , 30 , 40 ) ; Geometry g1 = new Geometry ( ) ; g1 . add ( p1 ) ; Rect r = Rect . centeredRect ( 100 , 200 , 30 , 40 ) ; assertEquals ( r , g1 . getBounds ( ) ) ; Path p2 = new Path ( ) ; Geometry g2 = new Geometry ( ) ; g2 . add ( p1 ) ; g2 . add ( p2 ) ; assertEquals ( r , g2 . getBounds ( ) ) ; } 
public void testIsEmpty ( ) { Geometry g1 = new Geometry ( ) ; assertTrue ( g1 . isEmpty ( ) ) ; Geometry g2 = new Geometry ( ) ; Adding even an empty path makes the geometry not empty. g2.add(new Path()); assertFalse(g2.isEmpty()); } 
public void testEmptyBounds ( ) { Path p1 = new Path ( ) ; assertEquals ( new Rect ( ) , p1 . getBounds ( ) ) ; Construct a path with an empty contour. Path p2 = new Path(); p2.add(new Contour()); assertEquals(new Rect(), p2.getBounds()); Construct a path with an empty and filled contour. Path p3 = new Path(); p3.add(new Contour()); Contour c2 = new Contour(); Rect r = new Rect(20, 30, 40, 50); c2.addPoint(r.getX(), r.getY()); c2.addPoint(r.getX() + r.getWidth(), r.getY() + r.getHeight()); p3.add(c2); assertEquals(r, p3.getBounds()); } 
private void updateRGB ( ) { if ( saturation = = 0 ) red = green = blue = brightness ; 
private void updateHSB ( ) { float h = 0 ; float s = 0 ; float v = Math . max ( Math . max ( red , green ) , blue ) ; float d = v - Math . min ( Math . min ( red , green ) , blue ) ; if ( v ! = 0 ) s = d / v ; if ( s ! = 0 ) { if ( red = = v ) h = 0 + ( green - blue ) / d ; else if ( green = = v ) h = 2 + ( blue - red ) / d ; else h = 4 + ( red - green ) / d ; } h = h * ( float ) ( 60.0 / 360 ) ; if ( h < 0 ) h = h + 1 ; hue = h ; saturation = s ; brightness = v ; } 
public static void paintConnection ( Graphics2D g , Node outputNode , Port input ) { GeneralPath p = connectionPath ( outputNode , input ) ; paintConnectionPath ( g , p ) ; } 
public static GeneralPath connectionPath ( Node outputNode , Port input ) { float x1 = ( float ) ( input . getNode ( ) . getX ( ) + 1 ) ; Compensate for selection border float y1 = (float) (input.getNode().getY() + NodeView.getVerticalOffsetForPort(input) + NodeView.NODE_PORT_HEIGHT / 2); return connectionPath(outputNode, x1, y1); } 
public void mouseDragged ( PInputEvent e ) { if ( isPanningEvent ( e ) ) return ; if ( isDragging ) { Point2D pt = e . getPosition ( ) ; double dx = pt . getX ( ) - dragPoint . getX ( ) ; double dy = pt . getY ( ) - dragPoint . getY ( ) ; getNetworkView ( ) . dragSelection ( dx , dy ) ; dragPoint = pt ; } else if ( networkView . isConnecting ( ) ) { Point2D p = e . getPosition ( ) ; networkView . dragConnectionPoint ( p ) ; } e . setHandled ( true ) ; } 
private boolean isPanningEvent ( PInputEvent event ) { return ( event . getModifiers ( ) & MouseEvent . ALT_MASK ) ! = 0 ; } 
public void store ( File f ) throws IOException { file = f ; NDBXWriter . write ( this , f ) ; } 
public static void initializePython ( ) { Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = PlatformUtils.getUserDataDirectory() + PlatformUtils.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. String workingDirectory = System.getProperty("user.dir"); File pythonLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "python.zip"); File nodeBoxLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "nodeboxlibs.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Py.getSystemState().path.add(new PyString(nodeBoxLibraries.getAbsolutePath())); This folder contains unarchived NodeBox libraries. Only used in development. File developmentLibraries = new File("src-python"); Py.getSystemState().path.add(new PyString(developmentLibraries.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(PlatformUtils.getUserPythonDirectory().getAbsolutePath())); } 
private static File showFileDialog ( Frame owner , String pathName , String extensions , String description , int fileDialogType ) { FileDialog fileDialog = new FileDialog ( owner , pathName , fileDialogType ) ; if ( pathName = = null | | pathName . trim ( ) . length ( ) = = 0 ) { File documentFile = NodeBoxDocument . getCurrentDocument ( ) . getDocumentFile ( ) ; if ( documentFile ! = null ) { fileDialog . setFile ( documentFile . getParentFile ( ) . getPath ( ) ) ; } } else { fileDialog . setFile ( pathName ) ; } fileDialog . setFilenameFilter ( new FileExtensionFilter ( extensions , description ) ) ; fileDialog . setVisible ( true ) ; String chosenFile = fileDialog . getFile ( ) ; String dir = fileDialog . getDirectory ( ) ; if ( chosenFile ! = null ) { return new File ( dir + chosenFile ) ; 
public void actionPerformed ( ActionEvent e ) { JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( this ) ; File f = FileUtils . showOpenDialog ( frame , parameter . asString ( ) , acceptedExtensions ( ) , acceptedDescription ( ) ) ; if ( f ! = null ) { File libraryFile = parameter . getLibrary ( ) . getFile ( ) ; 
public void testGetRelativePaths ( ) { assertEquals ( " stuff/xyz.dat " , FileUtils . getRelativePath ( new File ( " /var/data/stuff/xyz.dat " ) , new File ( " /var/data/ " ) ) ) ; assertEquals ( " ../../b/c " , FileUtils . getRelativePath ( new File ( " /a/b/c " ) , new File ( " /a/x/y/ " ) ) ) ; assertEquals ( " ../../b/c " , FileUtils . getRelativePath ( new File ( " /m/n/o/a/b/c " ) , new File ( " /m/n/o/a/x/y/ " ) ) ) ; 
public void compile ( ) throws ExpressionError { try { this . compiledExpression = MVEL . compileExpression ( expression , parserContext ) ; 
public boolean asBoolean ( ) throws ExpressionError { Object value = evaluate ( ) ; if ( value instanceof Boolean ) { return ( Boolean ) value ; 
public boolean isDisabled ( ) { if ( disableExpression = = null ) return false ; try { return disableExpression . asBoolean ( ) ; 
public void testDisabled ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; Parameter pBeta = . addParameter ( " beta " , Parameter . Type . INT ) ; By default, the parameter is enabled. assertFalse(pAlpha.isDisabled()); The disable expression requires something that returns a boolean. pAlpha.setDisableExpression("true"); assertTrue(pAlpha.isDisabled()); It can refer to other parameters. pAlpha.setDisableExpression("beta > 5"); pBeta.set(2); assertFalse(pAlpha.isDisabled()); Changing the dependent parameter will change the disabled state. pBeta.set(10); assertTrue(pAlpha.isDisabled()); Create a syntax error. This re-enables the parameter. pAlpha.setDisableExpression("#$%^"); assertFalse(pAlpha.isDisabled()); } 
public boolean isEnabled ( ) { if ( enableExpression = = null ) return false ; try { return enableExpression . asBoolean ( ) ; 
public void testEnabled ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; Parameter pBeta = . addParameter ( " beta " , Parameter . Type . INT ) ; By default, the parameter is enabled. assertFalse(pAlpha.isEnabled()); The disable expression requires something that returns a boolean. pAlpha.setEnableExpression("true"); assertTrue(pAlpha.isEnabled()); It can refer to other parameters. pAlpha.setEnableExpression("beta > 5"); pBeta.set(2); assertFalse(pAlpha.isEnabled()); Changing the dependent parameter will change the disabled state. pBeta.set(10); assertTrue(pAlpha.isEnabled()); Create a syntax error. This re-enables the parameter. pAlpha.setEnableExpression("#$%^"); assertTrue(pAlpha.isEnabled()); } 
private void startParameterTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( PARAMETER_NAME ) ; String typeAsString = attributes . getValue ( PARAMETER_TYPE ) ; if ( currentNode = = null ) throw new SAXException ( " Parameter tag encountered without a current node. " ) ; if ( name = = null ) throw new SAXException ( " Name is required for parameter on node ' " + currentNode . getName ( ) + " '. " ) ; if ( typeAsString = = null ) { No type attribute was given, so the parameter should already exist. currentParameter = currentNode.getParameter(name); if (currentParameter == null) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' does not exist."); } else { Type was given, so this is a new parameter. TODO: If type is given and parameter exists, migrate type. if (currentNode.hasParameter(name)) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' already exists."); Parameter.Type type = Parameter.Type.valueOf(typeAsString.toUpperCase()); currentParameter = currentNode.addParameter(name, type); } Parse parameter attributes. String widget = attributes.getValue(PARAMETER_WIDGET); String label = attributes.getValue(PARAMETER_LABEL); String helpText = attributes.getValue(PARAMETER_HELP_TEXT); String displayLevel = attributes.getValue(PARAMETER_DISPLAY_LEVEL); String enableExpression = attributes.getValue(PARAMETER_ENABLE_EXPRESSION); String boundingMethod = attributes.getValue(PARAMETER_BOUNDING_METHOD); String minimumValue = attributes.getValue(PARAMETER_MINIMUM_VALUE); String maximumValue = attributes.getValue(PARAMETER_MAXIMUM_VALUE); if (widget != null) currentParameter.setWidget(Parameter.Widget.valueOf(widget.toUpperCase())); if (label != null) currentParameter.setLabel(label); if (helpText != null) currentParameter.setHelpText(helpText); if (displayLevel != null) currentParameter.setDisplayLevel(Parameter.DisplayLevel.valueOf(displayLevel.toUpperCase())); if (enableExpression != null) currentParameter.setEnableExpression(enableExpression); if (boundingMethod != null) currentParameter.setBoundingMethod(Parameter.BoundingMethod.valueOf(boundingMethod.toUpperCase())); if (minimumValue != null) currentParameter.setMinimumValue(Float.parseFloat(minimumValue)); if (maximumValue != null) currentParameter.setMaximumValue(Float.parseFloat(maximumValue)); 
public boolean isEnabled ( ) { if ( enableExpression = = null ) return true ; try { return enableExpression . asBoolean ( ) ; 
public boolean prototypeEquals ( Parameter o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Parameter parameter = ( Parameter ) o ; if ( boundingMethod ! = parameter . boundingMethod ) return false ; if ( displayLevel ! = parameter . displayLevel ) return false ; if ( expression ! = null ? ! expression . equals ( parameter . expression ) : parameter . expression ! = null ) return false ; if ( helpText ! = null ? ! helpText . equals ( parameter . helpText ) : parameter . helpText ! = null ) return false ; if ( ! label . equals ( parameter . label ) ) return false ; if ( enableExpression ! = null ? ! enableExpression . equals ( parameter . enableExpression ) : parameter . enableExpression ! = null ) return false ; if ( maximumValue ! = null ? ! maximumValue . equals ( parameter . maximumValue ) : parameter . maximumValue ! = null ) return false ; if ( ! menuItems . equals ( parameter . menuItems ) ) return false ; if ( minimumValue ! = null ? ! minimumValue . equals ( parameter . minimumValue ) : parameter . minimumValue ! = null ) return false ; if ( ! name . equals ( parameter . name ) ) return false ; if ( type ! = parameter . type ) return false ; if ( expression = = null ) if ( value ! = null ? ! value . equals ( parameter . value ) : parameter . value ! = null ) return false ; if ( widget ! = parameter . widget ) return false ; return true ; } 
public void testStoreParameterAttributes ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " , Polygon . class ) ; Parameter pAngle = alpha . addParameter ( " angle " , Parameter . Type . FLOAT , 42 ) ; pAngle . setWidget ( Parameter . Widget . ANGLE ) ; pAngle . setEnableExpression ( " 5 > 10 " ) ; pAngle . setMinimumValue ( - 360 f ) ; pAngle . setMaximumValue ( 360 f ) ; pAngle . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; Parameter pMenu = alpha . addParameter ( " menu " , Parameter . Type . STRING , " es " ) ; pMenu . setWidget ( Parameter . Widget . MENU ) ; pMenu . addMenuItem ( " en " , " English " ) ; pMenu . addMenuItem ( " es " , " Spanish " ) ; Parameter pHidden = alpha . addParameter ( " hidden " , Parameter . Type . STRING , " invisible " ) ; pHidden . setDisplayLevel ( Parameter . DisplayLevel . HIDDEN ) ; Parameter pLabel = alpha . addParameter ( " label " , Parameter . Type . STRING , " label + help text " ) ; pLabel . setLabel ( " My Label " ) ; pLabel . setHelpText ( " My Help Text " ) ; Inherit from alpha. This is used to test if prototype data is stored only once. alpha.newInstance(library, "beta"); String xml = library.toXml(); assertOnlyOnce(xml, "<param name=\"menu\""); NodeLibraryManager manager = new NodeLibraryManager(); NodeLibrary newLibrary = NodeLibrary.load("test", xml, manager); Node newAlpha = newLibrary.getRootNode().getChild("alpha"); Parameter newAngle = newAlpha.getParameter("angle"); assertEquals(Parameter.Widget.ANGLE, newAngle.getWidget()); assertEquals("5 > 10", newAngle.getEnableExpression()); assertFalse(newAngle.isEnabled()); assertEquals(Parameter.BoundingMethod.HARD, newAngle.getBoundingMethod()); assertEquals(-360f, newAngle.getMinimumValue()); assertEquals(360f, newAngle.getMaximumValue()); Parameter newMenu = newAlpha.getParameter("menu"); assertEquals(Parameter.Widget.MENU, newMenu.getWidget()); Parameter.MenuItem item0 = newMenu.getMenuItems().get(0); Parameter.MenuItem item1 = newMenu.getMenuItems().get(1); assertEquals("en", item0.getKey()); assertEquals("English", item0.getLabel()); assertEquals("es", item1.getKey()); assertEquals("Spanish", item1.getLabel()); Parameter newHidden = newAlpha.getParameter("hidden"); assertEquals(Parameter.DisplayLevel.HIDDEN, newHidden.getDisplayLevel()); assertEquals("invisible", newHidden.getValue()); Parameter newLabel = newAlpha.getParameter("label"); assertEquals("My Label", newLabel.getLabel()); assertEquals("My Help Text", newLabel.getHelpText()); } 
public void testEnabled ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; Parameter pBeta = . addParameter ( " beta " , Parameter . Type . INT ) ; By default, the parameter is enabled. assertTrue(pAlpha.isEnabled()); The disable expression requires something that returns a boolean. pAlpha.setEnableExpression("true"); assertTrue(pAlpha.isEnabled()); It can refer to other parameters. pAlpha.setEnableExpression("beta > 5"); pBeta.set(2); assertFalse(pAlpha.isEnabled()); Changing the dependent parameter will change the disabled state. pBeta.set(10); assertTrue(pAlpha.isEnabled()); Create a syntax error. This re-enables the parameter. pAlpha.setEnableExpression("#$%^"); assertTrue(pAlpha.isEnabled()); } 
public void testEnableExpressionEvents ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; CountingNodeAttributeListener listener = new CountingNodeAttributeListener ( ) ; . addNodeAttributeListener ( listener ) ; pAlpha . setEnableExpression ( " " ) ; assertEquals ( 0 , listener . count ) ; pAlpha . setEnableExpression ( null ) ; assertEquals ( 0 , listener . count ) ; pAlpha . setEnableExpression ( " false " ) ; assertEquals ( 1 , listener . count ) ; pAlpha . setEnableExpression ( " false " ) ; assertEquals ( 1 , listener . count ) ; pAlpha . setEnableExpression ( null ) ; assertEquals ( 2 , listener . count ) ; pAlpha . setEnableExpression ( " " ) ; assertEquals ( 2 , listener . count ) ; } 
public void attributeChanged ( Node source , Attribute attribute ) { count + + ; } 
public Object evaluate ( ProcessingContext context ) throws ExpressionError { If there was an error with the expression, throw it before doing anything. if (hasError()) { throw new ExpressionError("Cannot compile expression '" + expression + "' on " + getParameter().getAbsolutePath() + ": " + getError().getMessage(), getError()); } If the expression was not compiled, compile it first. This can throw an ExpressionError, which will be forwarded to the caller. if (compiledExpression == null) { compile(); } Set up state variables in the expression utilities class. TODO: This is not thread-safe. ExpressionHelper.currentContext = context; ExpressionHelper.currentParameter = parameter; Marked parameter references are used to find which parameters this expression references. markedParameterReferences = new HashSet<WeakReference<Parameter>>(); ProxyResolverFactory prf = new ProxyResolverFactory(parameter.getNode(), context, markedParameterReferences); try { error = null; 
private void cancelNumberField ( ) { numberField . setVisible ( false ) ; } 
public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); Rectangle r = getBounds(); int centerWidth = r.width - draggerLeftWidth - draggerRightWidth; g2.drawImage(draggerLeft, 0, 0, null); g2.drawImage(draggerRight, r.width - draggerRightWidth, 0, null); g2.drawImage(draggerBackground, draggerLeftWidth, 0, centerWidth, draggerHeight, null); g2.setFont(Theme.SMALL_BOLD_FONT); if (isEnabled()) { g2.setColor(Theme.TEXT_NORMAL_COLOR); } else { g2.setColor(Theme.TEXT_DISABLED_COLOR); } SwingUtils.drawCenteredShadowText(g2, valueAsString(), r.width / 2, 14, Theme.DRAGGABLE_NUMBER_HIGLIGHT_COLOR); } 
public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; if ( oldValue ! = value ) fireStateChanged ( ) ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( isEnabled ( ) ) { if ( checked ) { g2 . drawImage ( checkedImage , 0 , 0 , null ) ; } else { g2 . drawImage ( normalImage , 0 , 0 , null ) ; } } else { if ( checked ) { g2 . drawImage ( checkDisabledOn , 0 , 0 , null ) ; } else { g2 . drawImage ( checkDisabledOff , 0 , 0 , null ) ; } } int w = normalImage . getWidth ( null ) ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; if ( armed ) { g2 . setColor ( Theme . TEXT_ARMED_COLOR ) ; } else if ( ! isEnabled ( ) ) { g2 . setColor ( Theme . TEXT_DISABLED_COLOR ) ; } else { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } SwingUtils . drawShadowText ( g2 , text , w + IMAGE_TEXT_MARGIN , TEXT_BASELINE ) ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; pressed = true ; armed = true ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; pressed = false ; if ( armed ) { armed = false ; if ( mode = = Mode . CHECK ) checked = ! checked ; try { actionMethod . invoke ( actionObject ) ; } catch ( Exception e1 ) { throw new RuntimeException ( " Could not invoke method " + actionMethod + " on object " + actionObject ) ; } repaint ( ) ; } } public void mouseEntered ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; if ( pressed ) { armed = true ; repaint ( ) ; } } public void mouseExited ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; armed = false ; repaint ( ) ; } } 
public void mousePressed ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; pressed = true ; armed = true ; repaint ( ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; pressed = false ; if ( armed ) { armed = false ; 
public void mouseEntered ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; if ( pressed ) { armed = true ; 
public void mouseExited ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; armed = false ; repaint ( ) ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Name nameField = new JFormattedTextField(20); nameField.setEditable(false); addRow("Name", nameField); Label labelField = new JTextField(20); labelField.addActionListener(this); labelField.addFocusListener(this); addRow("Label", labelField); Help Text helpTextField = new JTextField(20); helpTextField.addActionListener(this); helpTextField.addFocusListener(this); addRow("Help Text", helpTextField); Widget widgetBox = new JComboBox(humanizedWidgets); widgetBox.addActionListener(this); addRow("Type", widgetBox); Value valueField = new JTextField(20); valueField.addActionListener(this); valueField.addFocusListener(this); addRow("Value", valueField); Enable If enableIfField = new JTextField(20); enableIfField.addActionListener(this); enableIfField.addFocusListener(this); addRow("Enable If", enableIfField); Bounding Method boundingMethodBox = new JComboBox(new String[]{"none", "soft", "hard"}); boundingMethodBox.addActionListener(this); addRow("Bounding", boundingMethodBox); Minimum Value minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); minimumValueField.addFocusListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); addRow("Minimum", minimumValuePanel); Maximum Value maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); maximumValueField.addFocusListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); addRow("Maximum", maximumValuePanel); Display Level displayLevelBox = new JComboBox(new String[]{"hud", "detail", "hidden"}); displayLevelBox.addActionListener(this); addRow("Display Level", displayLevelBox); Menu Items menuItemsTable = new JTable(new MenuItemsModel()); menuItemsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); JPanel tablePanel = new JPanel(new BorderLayout(5, 5)); JScrollPane tableScroll = new JScrollPane(menuItemsTable, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); tableScroll.setSize(200, 200); tableScroll.setPreferredSize(new Dimension(200, 200)); tableScroll.setMaximumSize(new Dimension(200, 200)); tableScroll.setMinimumSize(new Dimension(200, 200)); tablePanel.add(tableScroll, BorderLayout.CENTER); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 5)); addButton = new JButton(new Icons.PlusIcon()); addButton.addActionListener(this); removeButton = new JButton(new Icons.MinusIcon()); removeButton.addActionListener(this); upButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.NORTH)); upButton.addActionListener(this); downButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.SOUTH)); downButton.addActionListener(this); buttonPanel.add(addButton); buttonPanel.add(removeButton); buttonPanel.add(upButton); buttonPanel.add(downButton); tablePanel.add(buttonPanel, BorderLayout.SOUTH); addRow("Menu Items", tablePanel); } 
public void updateValues ( ) { nameField . setText ( parameter . getName ( ) ) ; labelField . setText ( parameter . getLabel ( ) ) ; helpTextField . setText ( parameter . getHelpText ( ) ) ; widgetBox . setSelectedItem ( getHumanizedWidget ( parameter . getWidget ( ) ) ) ; valueField . setText ( parameter . getValue ( ) . toString ( ) ) ; enableIfField . setText ( parameter . getEnableExpression ( ) ) ; Parameter . BoundingMethod boundingMethod = parameter . getBoundingMethod ( ) ; boundingMethodBox . setSelectedItem ( boundingMethod . toString ( ) . toLowerCase ( ) ) ; Object minimumValue = parameter . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = parameter . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; displayLevelBox . setSelectedItem ( parameter . getDisplayLevel ( ) . toString ( ) . toLowerCase ( ) ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
public void editMetadata ( ) { if ( node = = null ) return ; NodeAttributesEditor editor = new NodeAttributesEditor ( node ) ; JFrame editorFrame = new JFrame ( node . getName ( ) + " Metadata " ) ; editorFrame . getContentPane ( ) . add ( editor ) ; editorFrame . setSize ( 580 , 751 ) ; editorFrame . setResizable ( false ) ; Center the frame based on the current window. Window w = SwingUtilities.getWindowAncestor(this); if (w == null) { If the current window could not be found, set to the default location. editorFrame.setLocationByPlatform(true); } else { int ancestorCenterX = w.getX() + w.getWidth() / 2; int ancestorCenterY = w.getY() + w.getHeight() / 2; int x = ancestorCenterX - editorFrame.getWidth() / 2; int y = ancestorCenterY - editorFrame.getHeight() / 2; editorFrame.setLocation(x, y); } editorFrame.setVisible(true); } 
public void addNotify ( ) { super . addNotify ( ) ; parameter . getNode ( ) . addParameterValueListener ( this ) ; parameter . getNode ( ) . addNodeAttributeListener ( this ) ; } 
public void removeNotify ( ) { super . removeNotify ( ) ; parameter . getNode ( ) . removeParameterValueListener ( this ) ; parameter . getNode ( ) . removeNodeAttributeListener ( this ) ; } 
public void valueChanged ( Parameter source ) { setEnabled ( parameter . isEnabled ( ) ) ; if ( parameter ! = source ) return ; setExpressionStatus ( ) ; } 
public void attributeChanged ( Node source , Attribute attribute ) { setEnabled ( parameter . isEnabled ( ) ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( isEnabled ( ) ) { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } else { g2 . setColor ( Theme . TEXT_DISABLED_COLOR ) ; } g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; int textX = ParameterView . LABEL_WIDTH - g2 . getFontMetrics ( ) . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = (getHeight() - g2.getFont().getSize()) / 2 + 10; SwingUtils.drawShadowText(g2, getText(), textX, textY, Theme.DEFAULT_SHADOW_COLOR, 1); } 
public void currentNodeChanged ( Node node ) { } public void focusedNodeChanged ( Node node ) { if ( colorDialog ! = null ) { colorDialog . dispose ( ) ; } } private class ColorButton extends JButton { private ColorButton ( ) { addActionListener ( ColorControl . this ) ; } @Override protected void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; if ( ColorControl . this . isEnabled ( ) ) { g . setColor ( Color . darkGray ) ; } else { g . setColor ( Theme . PARAMETER_LABEL_BACKGROUND ) ; } g . fillRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; if ( ColorControl . this . isEnabled ( ) ) { r . grow ( 1 , 1 ) ; } else { r . grow ( - 5 , - 5 ) ; } g . setColor ( parameter . asColor ( ) . getAwtColor ( ) ) ; g . fillRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; } } } 
protected void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; if ( ColorControl . this . isEnabled ( ) ) { g . setColor ( Color . darkGray ) ; } else { g . setColor ( Theme . PARAMETER_LABEL_BACKGROUND ) ; } g . fillRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; if ( ColorControl . this . isEnabled ( ) ) { r . grow ( 1 , 1 ) ; } else { r . grow ( - 5 , - 5 ) ; } g . setColor ( parameter . asColor ( ) . getAwtColor ( ) ) ; g . fillRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; } 
public Parameter getParameter ( ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; } 
public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; } 
public boolean hasEnableExpressionError ( ) { return enableExpression ! = null & & enableExpression . getError ( ) ! = null ; } 
public boolean prototypeEquals ( Parameter o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Parameter parameter = ( Parameter ) o ; if ( boundingMethod ! = parameter . boundingMethod ) return false ; if ( displayLevel ! = parameter . displayLevel ) return false ; if ( expression ! = null ? ! expression . equals ( parameter . expression ) : parameter . expression ! = null ) return false ; if ( helpText ! = null ? ! helpText . equals ( parameter . helpText ) : parameter . helpText ! = null ) return false ; if ( ! label . equals ( parameter . label ) ) return false ; if ( enableExpression ! = null ? ! enableExpression . equals ( parameter . enableExpression ) : parameter . enableExpression ! = null ) return false ; if ( maximumValue ! = null ? ! maximumValue . equals ( parameter . maximumValue ) : parameter . maximumValue ! = null ) return false ; if ( ! menuItems . equals ( parameter . menuItems ) ) return false ; if ( minimumValue ! = null ? ! minimumValue . equals ( parameter . minimumValue ) : parameter . minimumValue ! = null ) return false ; if ( ! name . equals ( parameter . name ) ) return false ; if ( type ! = parameter . type ) return false ; if ( expression = = null ) if ( value ! = null ? ! value . equals ( parameter . value ) : parameter . value ! = null ) return false ; if ( widget ! = parameter . widget ) return false ; return true ; } 
public void setValue ( Object value ) throws IllegalArgumentException { if ( hasExpression ( ) ) { throw new IllegalArgumentException ( " The parameter has an expression set. " ) ; } validate throws IllegalArgumentException when the value fails validation. validate(value); As a special exception, integer values can be cast up to floating-point values, and double values can be cast down (losing precision). Object castValue; if (value instanceof Integer && type == Type.FLOAT) { castValue = (float) ((Integer) value); } else if (value instanceof Double && type == Type.FLOAT) { castValue = (float) ((Double) value).doubleValue(); } else { castValue = value; } if (this.value != null && this.value.equals(castValue)) return; this.value = castValue; markDirty(); } 
public boolean hasVisibleHandle ( ) { if ( handle = = null ) return false ; if ( ! showHandle ) return false ; if ( ! handleEnabled ) return false ; return handle . isVisible ( ) ; } 
private void checkIfHandleEnabled ( ) { if ( activeNode = = null ) return ; Parameter handleParameter = activeNode . getParameter ( " _handle " ) ; if ( handleParameter = = null ) return ; handleEnabled = handleParameter . isEnabled ( ) ; } 
public void attributeChanged ( Node source , Attribute attribute ) { checkIfHandleEnabled ( ) ; repaint ( ) ; } 
private boolean checkIfHandleEnabled ( ) { if ( activeNode = = null ) return false ; Parameter handleParameter = activeNode . getParameter ( " _handle " ) ; if ( handleParameter = = null ) return false ; boolean newEnabled = handleParameter . isEnabled ( ) ; if ( newEnabled = = handleEnabled ) return false ; handleEnabled = newEnabled ; return true ; } 
public void attributeChanged ( Node source , Attribute attribute ) { if ( attribute ! = Attribute . PARAMETER ) return ; if ( checkIfHandleEnabled ( ) ) { repaint ( ) ; 
public boolean mouseClicked ( Point pt ) { return false ; } 
public boolean mousePressed ( Point pt ) { return false ; } 
public boolean mouseReleased ( Point pt ) { return false ; } 
public boolean mouseEntered ( Point pt ) { return false ; } 
public boolean mouseDragged ( Point pt ) { return false ; } 
public boolean mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; ocx = node . asFloat ( xName ) ; ocy = node . asFloat ( yName ) ; owidth = node . asFloat ( widthName ) ; oheight = node . asFloat ( heightName ) ; float left = ocx - owidth / 2 ; float right = ocx + owidth / 2 ; float top = ocy - oheight / 2 ; float bottom = ocy + oheight / 2 ; Rect topLeft = createHitRectangle ( left , top ) ; Rect topRight = createHitRectangle ( right , top ) ; Rect bottomLeft = createHitRectangle ( left , bottom ) ; Rect bottomRight = createHitRectangle ( right , bottom ) ; Rect center = new Rect ( left , top , owidth , oheight ) ; if ( topLeft . contains ( pt ) ) { dragState = DragState . TOP_LEFT ; } else if ( topRight . contains ( pt ) ) { dragState = DragState . TOP_RIGHT ; } else if ( bottomLeft . contains ( pt ) ) { dragState = DragState . BOTTOM_LEFT ; } else if ( bottomRight . contains ( pt ) ) { dragState = DragState . BOTTOM_RIGHT ; } else if ( center . contains ( pt ) ) { dragState = DragState . CENTER ; } else { dragState = DragState . NONE ; return false ; } return true ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float x = pt . getX ( ) ; float y = pt . getY ( ) ; float dx = x - px ; float dy = y - py ; The delta value is multiplied by 2 to create the float effect of moving the top left corner down and the bottom left corner up (in the case of the top left handle). if (dx == 0 && dy == 0) return false; switch (dragState) { case TOP_LEFT: node.silentSet(widthName, owidth - dx * 2); node.silentSet(heightName, oheight - dy * 2); break; case TOP_RIGHT: node.silentSet(heightName, oheight - dy * 2); node.silentSet(widthName, owidth + dx * 2); break; case BOTTOM_LEFT: node.silentSet(widthName, owidth - dx * 2); node.silentSet(heightName, oheight + dy * 2); break; case BOTTOM_RIGHT: node.silentSet(widthName, owidth + dx * 2); node.silentSet(heightName, oheight + dy * 2); break; case CENTER: node.silentSet(xName, ocx + dx); node.silentSet(yName, ocy + dy); } return true; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; dragState = DragState . NONE ; return true ; } 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public Node getNode ( ) ; public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public void keyTyped(int keyCode, int modifiers); public void keyPressed(int keyCode, int modifiers); public void keyReleased(int keyCode, int modifiers);} 
public boolean mouseClicked ( Point pt ) ; public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseMoved ( Point pt ) ; public void keyTyped ( int keyCode , int modifiers ) ; public void keyPressed ( int keyCode , int modifiers ) ; public void keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; ox = node . asFloat ( xName ) ; oy = node . asFloat ( yName ) ; Rect hitRect = createHitRectangle ( ox , oy ) ; dragging = hitRect . contains ( pt ) ; return dragging ; } 
public boolean mouseDragged ( Point e ) { if ( ! dragging ) return false ; double x = e . getX ( ) ; double y = e . getY ( ) ; double dx = x - px ; double dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; TODO: Temporary float fix to get a working compile. Doubles will be removed. node.setValue(xName, (float) (ox + dx)); node.setValue(yName, (float) (oy + dy)); return true; } 
public boolean mouseReleased ( Point pt ) { if ( ! dragging ) return false ; dragging = false ; return true ; } 
public boolean keyTyped ( int keyCode , int modifiers ) { return false ; } 
public boolean keyPressed ( int keyCode , int modifiers ) { return false ; } 
public boolean keyReleased ( int keyCode , int modifiers ) { return false ; } 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public Node getNode ( ) ; public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public boolean mouseClicked ( Point pt ) ; public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; } 
public void addHandle ( Handle handle ) { handles . add ( handle ) ; } 
public boolean mousePressed ( Point pt ) { for ( Handle handle : handles ) { boolean pressed = handle . mousePressed ( pt ) ; if ( pressed ) return true ; } return false ; } 
public boolean mouseDragged ( Point pt ) { for ( Handle handle : handles ) { boolean dragged = handle . mouseDragged ( pt ) ; if ( dragged ) return true ; } return false ; } 
public boolean mouseReleased ( Point pt ) { for ( Handle handle : handles ) { boolean released = handle . mouseReleased ( pt ) ; if ( released ) return true ; } return false ; } 
public void update ( ) { for ( Handle handle : handles ) handle . update ( ) ; setVisible ( true ) ; } 
public void draw ( GraphicsContext ctx ) { for ( Handle handle : handles ) handle . draw ( ctx ) ; 
public boolean mouseClicked ( Point pt ) { for ( Handle handle : handles ) { boolean clicked = handle . mouseClicked ( pt ) ; if ( clicked ) return true ; } return false ; } 
public boolean mouseEntered ( Point pt ) { for ( Handle handle : handles ) { boolean entered = handle . mouseEntered ( pt ) ; if ( entered ) return true ; } return false ; } 
public boolean mouseExited ( Point pt ) { for ( Handle handle : handles ) { boolean exited = handle . mouseExited ( pt ) ; if ( exited ) return true ; } return false ; } 
public boolean keyTyped ( int keyCode , int modifiers ) { for ( Handle handle : handles ) { boolean keyTyed = handle . keyTyped ( keyCode , modifiers ) ; if ( keyTyed ) return true ; } return false ; } 
public boolean keyPressed ( int keyCode , int modifiers ) { for ( Handle handle : handles ) { boolean keyPressed = handle . keyPressed ( keyCode , modifiers ) ; if ( keyPressed ) return true ; } return false ; } 
public boolean keyReleased ( int keyCode , int modifiers ) { for ( Handle handle : handles ) { boolean keyReleased = handle . keyReleased ( keyCode , modifiers ) ; if ( keyReleased ) return true ; } return false ; } 
public void draw ( Graphics2D g ) { If we can't fill or stroke the path, there's nothing to draw. if (fillColor == null && strokeColor == null) return; GeneralPath gp = getGeneralPath(); If there are no points, there's nothing to draw. if (getPointCount() == 0) return; if (fillColor != null) { g.setColor(fillColor.getAwtColor()); g.fill(gp); } if (strokeWidth > 0 && strokeColor != null) { try { 
public void createNewNode ( ) { networkView . showNodeSelectionDialog ( ) ; } 
public void windowOpened ( WindowEvent e ) { } public void windowClosing ( WindowEvent e ) { close ( ) ; } public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void nodeDirty(final Node node) { if (node != activeNetwork) return; requestActiveNetworkUpdate(); } private void requestActiveNetworkUpdate() { addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } private void doRender() { renderThread.render(activeNetwork); } public void nodeUpdated(Node node, ProcessingContext context) { Just here to statisfy DirtyListener interface. } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } 
private static File showFileDialog ( Frame owner , String pathName , String extensions , String description , int fileDialogType ) { FileDialog fileDialog = new FileDialog ( owner , pathName , fileDialogType ) ; if ( pathName = = null | | pathName . trim ( ) . length ( ) = = 0 ) { NodeBoxDocument document = NodeBoxDocument . getCurrentDocument ( ) ; if ( document ! = null ) { File documentFile = document . getDocumentFile ( ) ; if ( documentFile ! = null ) { fileDialog . setFile ( documentFile . getParentFile ( ) . getPath ( ) ) ; } } } else { File f = new File ( pathName ) ; if ( f . isDirectory ( ) ) { fileDialog . setDirectory ( pathName ) ; } else { fileDialog . setFile ( pathName ) ; } } fileDialog . setFilenameFilter ( new FileExtensionFilter ( extensions , description ) ) ; fileDialog . setVisible ( true ) ; String chosenFile = fileDialog . getFile ( ) ; String dir = fileDialog . getDirectory ( ) ; if ( chosenFile ! = null ) { return new File ( dir + chosenFile ) ; 
private void registerForMacOSXEvents ( ) throws RuntimeException { if ( ! PlatformUtils . onMac ( ) ) return ; try { Generate and register the OSXAdapter, passing it a hash of all the methods we wish to use as delegates for various com.apple.eawt.ApplicationListener methods OSXAdapter.setQuitHandler(this, getClass().getDeclaredMethod("quit", (Class[]) null)); OSXAdapter.setAboutHandler(this, getClass().getDeclaredMethod("showAbout", (Class[]) null)); OSXAdapter.setPreferencesHandler(this, getClass().getDeclaredMethod("showPreferences", (Class[]) null)); OSXAdapter.setFileHandler(this, getClass().getDeclaredMethod("readFromFile", String.class)); } catch (Exception e) { throw new RuntimeException("Error while loading the OS X Adapter.", e); } Create hidden window. hiddenFrame = new JFrame(); hiddenFrame.setJMenuBar(new NodeBoxMenuBar()); hiddenFrame.setUndecorated(true); hiddenFrame.setSize(0, 0); hiddenFrame.pack(); hiddenFrame.setVisible(true); } 
public boolean isEnabled ( ) { return document ! = null ; } 
public boolean isEnabled ( ) { return NodeBoxMenuBar . this . isEnabled ( ) ; } 
public void actionPerformed ( ActionEvent e ) { File chosenFile = FileUtils . showOpenDialog ( getDocument ( ) , NodeBoxDocument . lastFilePath , " ndbx " , " NodeBox Document " ) ; if ( chosenFile ! = null ) { NodeBoxDocument . open ( chosenFile ) ; 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . close ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . save ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . saveAs ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . revert ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . export ( ) ; } 
public boolean isEnabled ( ) { return super . isEnabled ( ) & & getDocument ( ) ! = null & & getDocument ( ) . getUndoManager ( ) . canUndo ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . undo ( ) ; } 
public boolean isEnabled ( ) { return super . isEnabled ( ) & & getDocument ( ) ! = null & & getDocument ( ) . getUndoManager ( ) . canRedo ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . redo ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . cut ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . copy ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . paste ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . deleteSelected ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . reloadActiveNode ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . setState ( Frame . ICONIFIED ) ; } 
public void mouseClicked ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) handle . mouseClicked ( pointForEvent ( e ) ) ; 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) handle . mousePressed ( pointForEvent ( e ) ) ; 
public void mouseReleased ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) handle . mouseReleased ( pointForEvent ( e ) ) ; 
public void mouseEntered ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; Window w = SwingUtilities . getWindowAncestor ( this ) ; if ( w ! = null & & w . isActive ( ) ) { requestFocus ( ) ; } if ( hasVisibleHandle ( ) ) handle . mouseEntered ( pointForEvent ( e ) ) ; 
public void mouseExited ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) handle . mouseExited ( pointForEvent ( e ) ) ; 
public void mouseDragged ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) handle . mouseDragged ( pointForEvent ( e ) ) ; 
public void mouseMoved ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) handle . mouseMoved ( pointForEvent ( e ) ) ; 
public void mouseEntered ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) handle . mouseEntered ( pointForEvent ( e ) ) ; 
private java . util . List < Node > sortNodes ( java . util . List < Node > nodes , String searchString ) { java . util . List < Node > sortedNodes = new ArrayList < Node > ( ) ; java . util . List < Node > startsWithNodes = new ArrayList < Node > ( ) ; java . util . List < Node > containsNodes = new ArrayList < Node > ( ) ; java . util . List < Node > descriptionNodes = new ArrayList < Node > ( ) ; for ( Node node : nodes ) { if ( node . getName ( ) . equals ( searchString ) ) sortedNodes . add ( node ) ; else if ( node . getName ( ) . startsWith ( searchString ) ) startsWithNodes . add ( node ) ; else if ( node . getName ( ) . contains ( searchString ) ) containsNodes . add ( node ) ; else descriptionNodes . add ( node ) ; } Collections . sort ( startsWithNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( startsWithNodes ) ; sortedNodes . addAll ( containsNodes ) ; sortedNodes . addAll ( descriptionNodes ) ; return sortedNodes ; } 
public int compare ( Object o1 , Object o2 ) { Node node1 = ( Node ) o1 ; Node node2 = ( Node ) o2 ; return node1 . getName ( ) . compareTo ( node2 . getName ( ) ) ; } 
private void changedEvent ( ) { if ( filteredNodeListModel . getSearchString ( ) . equals ( searchField . getText ( ) ) ) return ; filteredNodeListModel . setSearchString ( searchField . getText ( ) ) ; Trigger a model reload. nodeList.setModel(filteredNodeListModel); nodeList.setSelectedIndex(0); nodeList.ensureIndexIsVisible(0); repaint(); } 
public void draw ( GraphicsContext ctx ) { float x = node . asFloat ( txName ) ; float y = node . asFloat ( tyName ) ; Path p = new Path ( ) ; p . setFillColor ( HANDLE_COLOR ) ; ctx . setStrokeColor ( HANDLE_COLOR ) ; p . setStrokeColor ( null ) ; ctx . setFillColor ( null ) ; drawDot ( ctx , x , y ) ; if ( dragState = = DragState . NONE ) { Horizontal and vertical direction lines. ctx.line(x, y, x + handleLength, y); ctx.line(x, y, x, y + handleLength); Vertical arrow p.moveto(x, y + handleLength + 3); p.lineto(x - 5, y + handleLength - 3); p.lineto(x + 5, y + handleLength - 3); Horizontal arrow p.moveto(x + handleLength + 3, y); p.lineto(x + handleLength - 3, y - 5); p.lineto(x + handleLength - 3, y + 5); } else if (dragState == DragState.CENTER) { ctx.line(px, py, x, y); drawDot(ctx, x, y); } else if (dragState == DragState.HORIZONTAL) { float x0, x1; ctx.line(px - handleLength, y, x + handleLength, y); if (x + handleLength > px - handleLength) { arrow points right x0 = x + handleLength + 3; x1 = x + handleLength - 3; } else { arrow points left x0 = x + handleLength - 3; x1 = x + handleLength + 3; } p.moveto(x0, y); p.lineto(x1, y - 5); p.lineto(x1, y + 5); } else if (dragState == DragState.VERTICAL) { float y0, y1; ctx.line(x, py - handleLength, x, y + handleLength); if (y + handleLength > py - handleLength) { arrow points down y0 = y + handleLength + 3; y1 = y + handleLength - 3; } else { arrow points up y0 = y + handleLength - 3; y1 = y + handleLength + 3; } p.moveto(x, y0); p.lineto(x - 5, y1); p.lineto(x + 5, y1); } ctx.setStrokeColor(null); ctx.draw(p); } 
public boolean mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; float x = ox = node . asFloat ( txName ) ; float y = oy = node . asFloat ( tyName ) ; Rect centerRect = createHitRectangle ( x , y ) ; Rect horRect = createHitRectangle ( x + handleLength , y ) ; Rect vertRect = createHitRectangle ( x , y + handleLength ) ; if ( centerRect . contains ( pt ) ) dragState = DragState . CENTER ; else if ( horRect . contains ( pt ) ) dragState = DragState . HORIZONTAL ; else if ( vertRect . contains ( pt ) ) dragState = DragState . VERTICAL ; return ( dragState ! = DragState . NONE ) ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float dx = pt . x - px ; float dy = pt . y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; if ( dragState = = DragState . CENTER ) { node . silentSet ( txName , ox + dx ) ; node . silentSet ( tyName , oy + dy ) ; } else if ( dragState = = DragState . HORIZONTAL ) node . silentSet ( txName , ox + dx ) ; else if ( dragState = = DragState . VERTICAL ) node . silentSet ( tyName , oy + dy ) ; return true ; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; dragState = DragState . NONE ; viewer . repaint ( ) ; return true ; } 
public void draw ( GraphicsContext ctx ) { float cx = getCenterX ( ) ; float cy = getCenterY ( ) ; ctx . setFillColor ( null ) ; ctx . setStrokeColor ( HANDLE_COLOR ) ; ctx . ellipse ( cx , cy , handleLength * 2 , handleLength * 2 ) ; double [ ] xy ; if ( dragState = = DragState . NONE | | dragState = = DragState . HANDLE ) xy = Geometry . coordinates ( cx , cy , handleLength , node . asFloat ( angleName ) ) ; else { xy = Geometry . coordinates ( cx , cy , handleLength , pa ) ; ctx . line ( cx , cy , ( float ) xy [ 0 ] , ( float ) xy [ 1 ] ) ; xy = Geometry . coordinates ( cx , cy , handleLength , ca ) ; } float x = ( float ) xy [ 0 ] ; float y = ( float ) xy [ 1 ] ; ctx . line ( cx , cy , x , y ) ; ctx . setFillColor ( new Color ( 1 , 1 , 1 ) ) ; ctx . ellipse ( x , y , 6 , 6 ) ; if ( dragState = = DragState . HANDLE ) { xy = Geometry . coordinates ( cx , cy , handleLength , oa ) ; 
public boolean mousePressed ( Point pt ) { float cx = getCenterX ( ) ; float cy = getCenterY ( ) ; original angle oa = node.asFloat(angleName); double[] xy = Geometry.coordinates(cx, cy, handleLength, oa); float x = (float) xy[0]; float y = (float) xy[1]; Path p = new Path(); p.ellipse(cx, cy, handleLength * 2, handleLength * 2); Rect handleRect = createHitRectangle(x, y); float a = (float) Geometry.angle(cx, cy, pt.x, pt.y); xy = Geometry.coordinates(cx, cy, handleLength, a); float x1 = (float) xy[0]; float y1 = (float) xy[1]; Rect circleRect = createHitRectangle(x1, y1); if (handleRect.contains(pt)) dragState = DragState.HANDLE; else if (circleRect.contains(pt)) { pa = a; pressed angle dragState = DragState.CIRCLE; } else dragState = DragState.NONE; return (dragState != DragState.NONE); } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float cx = getCenterX ( ) ; float cy = getCenterY ( ) ; float a = ( float ) Geometry . angle ( cx , cy , pt . x , pt . y ) ; ca = a ; current angle handleLength = (float) Geometry.distance(cx, cy, pt.x, pt.y); if (dragState == DragState.HANDLE) node.silentSet(angleName, a); else if (dragState == DragState.CIRCLE) node.silentSet(angleName, oa + a - pa); return true; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; dragState = DragState . NONE ; handleLength = HANDLE_LENGTH ; viewer . repaint ( ) ; return true ; } 
public void draw ( GraphicsContext ctx ) { ctx . setFillColor ( null ) ; ctx . setStrokeColor ( HANDLE_COLOR ) ; float halfWidth = handleWidth / 2 ; float halfHeight = handleHeight / 2 ; ctx . rect ( 0 , 0 , handleWidth , handleHeight ) ; drawDot ( ctx , - halfWidth , - halfHeight ) ; drawDot ( ctx , halfWidth , - halfHeight ) ; drawDot ( ctx , - halfWidth , halfHeight ) ; drawDot ( ctx , halfWidth , halfHeight ) ; } 
public boolean mousePressed ( Point pt ) { float left = - handleWidth / 2 ; float right = handleWidth / 2 ; float top = - handleHeight / 2 ; float bottom = handleHeight / 2 ; Rect topLeft = createHitRectangle ( left , top ) ; Rect topRight = createHitRectangle ( right , top ) ; Rect bottomLeft = createHitRectangle ( left , bottom ) ; Rect bottomRight = createHitRectangle ( right , bottom ) ; px = pt . getX ( ) ; py = pt . getY ( ) ; ox = node . asFloat ( sxName ) ; oy = node . asFloat ( syName ) ; if ( topLeft . contains ( pt ) ) dragState = DragState . TOP_LEFT ; else if ( topRight . contains ( pt ) ) dragState = DragState . TOP_RIGHT ; else if ( bottomLeft . contains ( pt ) ) dragState = DragState . BOTTOM_LEFT ; else if ( bottomRight . contains ( pt ) ) dragState = DragState . BOTTOM_RIGHT ; else dragState = DragState . NONE ; return ( dragState ! = DragState . NONE ) ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float x = pt . getX ( ) ; float y = pt . getY ( ) ; float dx = x - px ; float dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; if ( dragState = = DragState . TOP_LEFT ) { handleWidth = HANDLE_WIDTH - dx * 2 ; handleHeight = HANDLE_HEIGHT - dy * 2 ; } else if ( dragState = = DragState . TOP_RIGHT ) { handleWidth = HANDLE_WIDTH + dx * 2 ; handleHeight = HANDLE_HEIGHT - dy * 2 ; } else if ( dragState = = DragState . BOTTOM_LEFT ) { handleWidth = HANDLE_WIDTH - dx * 2 ; handleHeight = HANDLE_HEIGHT + dy * 2 ; } else if ( dragState = = DragState . BOTTOM_RIGHT ) { handleWidth = HANDLE_WIDTH + dx * 2 ; handleHeight = HANDLE_HEIGHT + dy * 2 ; } float pctX = handleWidth / HANDLE_WIDTH ; float pctY = handleHeight / HANDLE_HEIGHT ; if ( scaleHorizontal ) node . silentSet ( sxName , ox * pctX ) ; else handleWidth = HANDLE_WIDTH ; if ( scaleVertical ) node . silentSet ( syName , oy * pctY ) ; else handleHeight = HANDLE_HEIGHT ; return true ; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; handleWidth = HANDLE_WIDTH ; handleHeight = HANDLE_HEIGHT ; dragState = DragState . NONE ; viewer . repaint ( ) ; return true ; } 
public boolean keyPressed ( int keyCode , int modifiers ) { if ( ( modifiers & SHIFT_DOWN ) ! = 0 ) scaleVertical = false ; else if ( ( modifiers & META_DOWN ) ! = 0 ) scaleHorizontal = false ; return true ; } 
public boolean keyReleased ( int keyCode , int modifiers ) { scaleHorizontal = true ; scaleVertical = true ; return false ; } 
public boolean mouseMoved ( Point pt ) { boolean moved = false ; for ( Handle handle : handles ) { if ( handle . mouseMoved ( pt ) ) moved = true ; } return false ; } 
public void draw ( GraphicsContext ctx ) { float x = getCenterX ( ) ; float y = getCenterY ( ) ; float radius = getRadius ( ) ; ctx . setFillColor ( null ) ; ctx . setStrokeColor ( HANDLE_COLOR ) ; ctx . ellipse ( x , y , radius * 2 , radius * 2 ) ; if ( pt ! = null ) drawDot ( ctx , pt . x , pt . y ) ; 
public boolean mousePressed ( Point pt ) { this . pt = null ; float radius = getRadius ( ) ; float d = ( float ) Geometry . distance ( getCenterX ( ) , getCenterY ( ) , pt . x , pt . y ) ; dragging = ( radius - 4 < = d & & d < = radius + 4 ) ; return dragging ; } 
public boolean mouseDragged ( Point pt ) { if ( ! dragging ) return false ; float newSize = ( float ) Geometry . distance ( getCenterX ( ) , getCenterY ( ) , pt . x , pt . y ) ; if ( mode = = Mode . DIAMETER ) newSize * = 2 ; if ( newSize = = getRadius ( ) ) return false ; node . silentSet ( radiusName , newSize ) ; this . pt = pt ; return true ; } 
public boolean mouseReleased ( Point pt ) { if ( ! dragging ) return false ; dragging = false ; this . pt = null ; viewer . repaint ( ) ; return true ; } 
public boolean mouseMoved ( Point pt ) { float x = getCenterX ( ) ; float y = getCenterY ( ) ; float radius = getRadius ( ) ; float d = ( float ) Geometry . distance ( x , y , pt . x , pt . y ) ; if ( radius - 4 < = d & & d < = radius + 4 ) { float a = ( float ) Geometry . angle ( x , y , pt . x , pt . y ) ; double [ ] xy ; xy = Geometry . coordinates ( x , y , radius , a ) ; this . pt = new Point ( ( float ) xy [ 0 ] , ( float ) xy [ 1 ] ) ; } else { this . pt = null ; } viewer . repaint ( ) ; return true ; } 
public Color background ( ) { return canvas . getBackground ( ) ; } 
public Color background ( float x ) { return canvas . setBackground ( new Color ( x , x , x ) ) ; } 
public Color background ( float x , float y ) { return canvas . setBackground ( new Color ( x , x , x , y ) ) ; } 
public Color background ( float x , float y , float z ) { return canvas . setBackground ( new Color ( x , y , z ) ) ; } 
public Color background ( float x , float y , float z , float a ) { return canvas . setBackground ( new Color ( x , y , z , a ) ) ; } 
public Color background ( Color c ) { return canvas . setBackground ( c = = null ? null : c . clone ( ) ) ; } 
public void nobackground ( ) { canvas . setBackground ( null ) ; } 
public void beginpath ( ) { path = new Path ( ) ; pathClosed = false ; } 
public void beginpath ( float x , float y ) { beginpath ( ) ; moveto ( x , y ) ; } 
public void moveto ( float x , float y ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginpath() first. " ) ; path . moveto ( x , y ) ; } 
public void lineto ( float x , float y ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginpath() first. " ) ; path . lineto ( x , y ) ; } 
public void closepath ( ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginpath() first. " ) ; if ( ! pathClosed ) { path . close ( ) ; 
public Path endpath ( boolean draw ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginpath() first. " ) ; if ( autoClosePath ) closepath ( ) ; Path p = path ; inheritFromContext ( p ) ; if ( draw ) canvas . add ( p ) ; Initialize a new path path = null; pathClosed = false; return p; } 
public void drawpath ( Path path ) { inheritFromContext ( path ) ; canvas . add ( path ) ; } 
public boolean autoclosepath ( ) { return autoClosePath ; } 
public boolean autoclosepath ( boolean c ) { return autoClosePath = c ; } 
public Path findpath ( List < Point > points ) { return findpath ( points , 1 ) ; } 
public Path findpath ( List < Point > points , float curvature ) { throw new RuntimeException ( " findpath is not implemented yet. " ) ; } 
public void beginclip ( Path p ) { throw new RuntimeException ( " beginclip is not implemented yet. " ) ; } 
public void endclip ( ) { throw new RuntimeException ( " endclip is not implemented yet. " ) ; } 
public void pop ( ) { if ( transformStack . isEmpty ( ) ) throw new NodeBoxError ( " Pop: too many pops! " ) ; transform = transformStack . get ( 0 ) ; transformStack . remove ( 0 ) ; } 
public void reset ( ) { transformStack . clear ( ) ; transform = new Transform ( ) ; } 
public String outputmode ( ) { throw new RuntimeException ( " outputmode is not implemented yet. " ) ; } 
public String outputmode ( String mode ) { throw new RuntimeException ( " outputmode is not implemented yet. " ) ; } 
public String colormode ( ) { throw new RuntimeException ( " colormode is not implemented yet. " ) ; } 
public String colormode ( String mode ) { throw new RuntimeException ( " colormode is not implemented yet. " ) ; } 
public Color color ( float x ) { return new Color ( x , x , x ) ; } 
public Color color ( float x , float y ) { return new Color ( x , x , x , y ) ; } 
public Color color ( float x , float y , float z ) { return new Color ( x , y , z ) ; } 
public Color color ( float x , float y , float z , float a ) { return new Color ( x , y , z , a ) ; } 
public Color color ( Color c ) { return c = = null ? new Color ( 0 , 0 , 0 , 0 ) : c . clone ( ) ; } 
public Color fill ( float x ) { return fillColor = new Color ( x , x , x ) ; } 
public Color fill ( float x , float y ) { return fillColor = new Color ( x , x , x , y ) ; } 
public Color fill ( float x , float y , float z ) { return fillColor = new Color ( x , y , z ) ; } 
public Color fill ( float x , float y , float z , float a ) { return fillColor = new Color ( x , y , z , a ) ; } 
public Color fill ( Color c ) { return fillColor = c = = null ? null : c . clone ( ) ; } 
public Color stroke ( float x ) { return strokeColor = new Color ( x , x , x ) ; } 
public Color stroke ( float x , float y ) { return strokeColor = new Color ( x , x , x , y ) ; } 
public Color stroke ( float x , float y , float z ) { return strokeColor = new Color ( x , y , z ) ; } 
public Color stroke ( float x , float y , float z , float a ) { return strokeColor = new Color ( x , y , z , a ) ; } 
public Color stroke ( Color c ) { return strokeColor = c = = null ? null : c . clone ( ) ; } 
public float strokewidth ( float w ) { return strokeWidth = w ; } 
public String font ( String fontName ) { if ( ! Text . fontExists ( fontName ) ) throw new NodeBoxError ( " Font ' " + fontName + " ' does not exist. " ) ; return this . fontName = fontName ; } 
public String font ( String fontName , float fontSize ) { font ( fontName ) ; fontsize ( fontSize ) ; return fontName ; } 
public float fontsize ( float s ) { return fontSize = s ; } 
public float lineheight ( float lineHeight ) { return this . lineHeight = lineHeight ; } 
public void align ( Text . Align align ) { this . align = align ; } 
public Path textpath ( String text , float x , float y ) { return textpath ( text , x , y , 0 , 0 ) ; } 
public Path textpath ( String text , float x , float y , float width ) { return textpath ( text , x , y , width , 0 ) ; } 
public Path textpath ( String text , float x , float y , float width , float height ) { Text = new Text ( text , x , y , width , height ) ; inheritFromContext ( ) ; Path p = new Path ( ) ; p . text ( ) ; inheritFromContext ( p ) ; return p ; } 
public Rect textmetrics ( String text ) { return textmetrics ( text , 0 , 0 ) ; } 
public Rect textmetrics ( String text , float width ) { return textmetrics ( text , width , 0 ) ; } 
public Rect textmetrics ( String text , float width , float height ) { Text = new Text ( text , 0 , 0 , width , height ) ; inheritFromContext ( ) ; return . getMetrics ( ) ; } 
public float textwidth ( String text ) { return textmetrics ( text , 0 , 0 ) . getWidth ( ) ; } 
public float textwidth ( String text , float width ) { return textmetrics ( text , width ) . getWidth ( ) ; } 
public float textheight ( String text ) { return textmetrics ( text , 0 , 0 ) . getHeight ( ) ; } 
public float textheight ( String text , float width ) { return textmetrics ( text , width ) . getHeight ( ) ; } 
public Size imagesize ( String path ) { Image img = new Image ( path ) ; return img . getSize ( ) ; } 
public void var ( Object . . . args ) { throw new RuntimeException ( " var is no longer supported. Create parameters on the node instead. " ) ; } 
public long random ( int max ) { return Math . round ( Math . random ( ) * max ) ; } 
public long random ( int min , int max ) { return Math . round ( min + ( Math . random ( ) * ( max - min ) ) ) ; } 
public double random ( double max ) { return Math . random ( ) * max ; } 
public double random ( double min , double max ) { return min + ( Math . random ( ) * ( max - min ) ) ; } 
public Object choice ( List objects ) { if ( objects = = null | | objects . isEmpty ( ) ) return null ; return objects . get ( ( int ) random ( objects . size ( ) ) ) ; } 
public void draw ( GraphicsContext ctx ) { float cx = getCenterX ( ) ; float cy = getCenterY ( ) ; ctx . fill ( null ) ; ctx . stroke ( HANDLE_COLOR ) ; ctx . ellipse ( cx , cy , handleLength * 2 , handleLength * 2 ) ; double [ ] xy ; if ( dragState = = DragState . NONE | | dragState = = DragState . HANDLE ) xy = Geometry . coordinates ( cx , cy , handleLength , node . asFloat ( angleName ) ) ; else { xy = Geometry . coordinates ( cx , cy , handleLength , pa ) ; ctx . line ( cx , cy , ( float ) xy [ 0 ] , ( float ) xy [ 1 ] ) ; xy = Geometry . coordinates ( cx , cy , handleLength , ca ) ; } float x = ( float ) xy [ 0 ] ; float y = ( float ) xy [ 1 ] ; ctx . line ( cx , cy , x , y ) ; ctx . fill ( new Color ( 1 , 1 , 1 ) ) ; ctx . ellipse ( x , y , 6 , 6 ) ; if ( dragState = = DragState . HANDLE ) { xy = Geometry . coordinates ( cx , cy , handleLength , oa ) ; 
public void draw ( GraphicsContext ctx ) { ctx . nofill ( ) ; ctx . stroke ( HANDLE_COLOR ) ; float halfWidth = handleWidth / 2 ; float halfHeight = handleHeight / 2 ; ctx . rect ( 0 , 0 , handleWidth , handleHeight ) ; drawDot ( ctx , - halfWidth , - halfHeight ) ; drawDot ( ctx , halfWidth , - halfHeight ) ; drawDot ( ctx , - halfWidth , halfHeight ) ; drawDot ( ctx , halfWidth , halfHeight ) ; } 
public void draw ( GraphicsContext ctx ) { float x = node . asFloat ( txName ) ; float y = node . asFloat ( tyName ) ; Path p = new Path ( ) ; p . setFillColor ( HANDLE_COLOR ) ; ctx . stroke ( HANDLE_COLOR ) ; p . setStrokeColor ( null ) ; ctx . fill ( null ) ; drawDot ( ctx , x , y ) ; if ( dragState = = DragState . NONE ) { Horizontal and vertical direction lines. ctx.line(x, y, x + handleLength, y); ctx.line(x, y, x, y + handleLength); Vertical arrow p.moveto(x, y + handleLength + 3); p.lineto(x - 5, y + handleLength - 3); p.lineto(x + 5, y + handleLength - 3); Horizontal arrow p.moveto(x + handleLength + 3, y); p.lineto(x + handleLength - 3, y - 5); p.lineto(x + handleLength - 3, y + 5); } else if (dragState == DragState.CENTER) { ctx.line(px, py, x, y); drawDot(ctx, x, y); } else if (dragState == DragState.HORIZONTAL) { float x0, x1; ctx.line(px - handleLength, y, x + handleLength, y); if (x + handleLength > px - handleLength) { arrow points right x0 = x + handleLength + 3; x1 = x + handleLength - 3; } else { arrow points left x0 = x + handleLength - 3; x1 = x + handleLength + 3; } p.moveto(x0, y); p.lineto(x1, y - 5); p.lineto(x1, y + 5); } else if (dragState == DragState.VERTICAL) { float y0, y1; ctx.line(x, py - handleLength, x, y + handleLength); if (y + handleLength > py - handleLength) { arrow points down y0 = y + handleLength + 3; y1 = y + handleLength - 3; } else { arrow points up y0 = y + handleLength - 3; y1 = y + handleLength + 3; } p.moveto(x, y0); p.lineto(x - 5, y1); p.lineto(x + 5, y1); } ctx.stroke(null); ctx.draw(p); } 
public void testInheritFromContext ( ) { GraphicsContext ctx = new GraphicsContext ( ) ; Color c = new Color ( ) ; assertEquals ( c , ctx . fill ( ) ) ; ctx . rect ( 0 , 0 , 100 , 100 ) ; Path p = ( Path ) ctx . getCanvas ( ) . getItems ( ) . get ( 0 ) ; assertEquals ( c , p . getFillColor ( ) ) ; Color red = new Color ( 1 , 0 , 0 ) ; ctx . fill ( red ) ; ctx . align ( Text . Align . RIGHT ) ; Text = ctx . text ( " hello " , 20 , 20 ) ; assertEquals ( red , . getFillColor ( ) ) ; assertEquals ( Text . Align . RIGHT , . getAlign ( ) ) ; } 
public void addNotify ( ) { super . addNotify ( ) ; parameter . getLibrary ( ) . addListener ( this ) ; } 
public void removeNotify ( ) { super . removeNotify ( ) ; parameter . getLibrary ( ) . removeListener ( this ) ; } 
public void receive ( NodeEvent event ) { if ( ! ( event instanceof ValueChangedEvent ) ) return ; if ( ( ( ValueChangedEvent ) event ) . getParameter ( ) ! = this . parameter ) return ; valueChanged ( ( ( ValueChangedEvent ) event ) . getParameter ( ) ) ; } 
public void currentNodeChanged ( Node node ) { this . node = node ; repaint ( ) ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { int mx = e . getX ( ) ; armed = partIndex ( mx ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; java . util . List < Node > nodes = getNetworkParts ( ) ; Node selectedNode = nodes . get ( partIndex ) ; System.out.println("part = " + selectedNode); if (selectedNode != null) document.setActiveNetwork(selectedNode); repaint(); } public void mouseEntered(MouseEvent e) { } public void mouseExited(MouseEvent e) { armed = -1; repaint(); } private int partIndex(int x) { if (positions == null) return -1; for (int i = 0; i < positions.length; i++) { if (x < positions[i]) return i; } return -1; } @Override public void doLayout() { final int width = getWidth(); progressBar.setBounds(width - 23, 3, 20, 20); }} 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } @Override public void doLayout ( ) { final int width = getWidth ( ) ; progressBar . setBounds ( width - 23 , 3 , 20 , 20 ) ; } } 
public void doLayout ( ) { final int width = getWidth ( ) ; progressBar . setBounds ( width - 23 , 3 , 20 , 20 ) ; } 
public boolean reload ( ) { if ( node = = null ) return false ; Parameter pCode = node . getParameter ( codeType ) ; if ( pCode = = null ) return false ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; if ( codeType . equals ( " _handle " ) ) getDocument ( ) . setActiveNode ( node ) ; to make Viewer reload handle return true; } 
public void receive ( NodeEvent event ) { if ( event . getSource ( ) ! = this . node ) return ; if ( event instanceof NodeUpdatedEvent ) { updateMessages ( event . getSource ( ) , ( ( NodeUpdatedEvent ) event ) . getContext ( ) ) ; 
public void componentResized ( ComponentEvent e ) { splitter.setDividerLocation(splitter.getHeight()); } public void componentMoved(ComponentEvent e) { } public void componentShown(ComponentEvent e) { } public void componentHidden(ComponentEvent e) { } public void caretUpdate(CaretEvent e) { JEditorPane editArea = (JEditorPane) e.getSource(); int caretpos = editArea.getCaretPosition(); Element root = editArea.getDocument().getDefaultRootElement(); int linenum = root.getElementIndex(caretpos) + 1; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } private void updatePosition(int linenum, int columnnum) { splitter.setLocation(linenum, columnnum); }} 
public void componentMoved ( ComponentEvent e ) { } public void componentShown ( ComponentEvent e ) { } public void componentHidden ( ComponentEvent e ) { } public void caretUpdate ( CaretEvent e ) { JEditorPane editArea = ( JEditorPane ) e . getSource ( ) ; int caretpos = editArea . getCaretPosition ( ) ; Element root = editArea . getDocument ( ) . getDefaultRootElement ( ) ; int linenum = root . getElementIndex ( caretpos ) + 1 ; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } private void updatePosition(int linenum, int columnnum) { splitter.setLocation(linenum, columnnum); }} 
public void componentShown ( ComponentEvent e ) { } public void componentHidden ( ComponentEvent e ) { } public void caretUpdate ( CaretEvent e ) { JEditorPane editArea = ( JEditorPane ) e . getSource ( ) ; int caretpos = editArea . getCaretPosition ( ) ; Element root = editArea . getDocument ( ) . getDefaultRootElement ( ) ; int linenum = root . getElementIndex ( caretpos ) + 1 ; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } private void updatePosition(int linenum, int columnnum) { splitter.setLocation(linenum, columnnum); }} 
public void componentHidden ( ComponentEvent e ) { } public void caretUpdate ( CaretEvent e ) { JEditorPane editArea = ( JEditorPane ) e . getSource ( ) ; int caretpos = editArea . getCaretPosition ( ) ; Element root = editArea . getDocument ( ) . getDefaultRootElement ( ) ; int linenum = root . getElementIndex ( caretpos ) + 1 ; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int columnnum = 1 + caretpos - root.getElement(linenum - 1).getStartOffset(); updatePosition(linenum, columnnum); } private void updatePosition(int linenum, int columnnum) { splitter.setLocation(linenum, columnnum); }} 
public void currentNodeChanged ( Node activeNetwork ) { this . node = activeNetwork ; } 
public void receive ( NodeEvent event ) { if ( event . getSource ( ) ! = this . node ) return ; if ( event instanceof NodeUpdatedEvent ) { StringBuffer sb = new StringBuffer ( ) ; 
public void receive ( NodeEvent event ) { if ( event instanceof NodeAttributeChangedEvent ) { if ( event . getSource ( ) . getParent ( ) ! = node ) return ; childAttributeChanged ( event . getSource ( ) , ( ( NodeAttributeChangedEvent ) event ) . getAttribute ( ) ) ; } if ( event . getSource ( ) ! = node ) return ; if ( event instanceof ChildAddedEvent ) { childAdded ( ( ( ChildAddedEvent ) event ) . getChild ( ) ) ; 
public void childAdded ( Node child ) { NodeView nv = new NodeView ( this , child ) ; getLayer ( ) . addChild ( nv ) ; } 
public void childRemoved ( Node child ) { NodeView nv = getNodeView ( child ) ; if ( nv = = null ) return ; getLayer ( ) . removeChild ( nv ) ; if ( selection . contains ( nv ) ) { deselect ( nv ) ; } If this child was connected, it is now disconnected. This means we should repaint the connection layer. connectionLayer.repaint(); } 
public void childAttributeChanged ( Node child , Node . Attribute attribute ) { NodeView nv = getNodeView ( child ) ; if ( nv = = null ) return ; The port is part of the icon. If a port was added or removed, also update the icon. if (attribute == Node.Attribute.PORT) { nv.updateIcon(); 
public void checkErrorAndRepaint ( ) { if ( ! networkError & & ! node . hasError ( ) ) return ; networkError = node . hasError ( ) ; repaint ( ) ; } 
public static void main ( String [ ] args ) { JFrame editorFrame = new JFrame ( ) ; Node node = new AllControlsType ( ) . createInstance ( ) ; node . addPort ( " shape " ) ; editorFrame . getContentPane ( ) . add ( new NodeAttributesEditor ( node ) ) ; editorFrame . setSize ( 580 , 710 ) ; editorFrame . setResizable ( false ) ; editorFrame . setLocationByPlatform ( true ) ; editorFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; editorFrame . setVisible ( true ) ; } 
public void windowOpened ( WindowEvent e ) { } public void windowClosing ( WindowEvent e ) { close ( ) ; } public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); } Document Action classes public class OpenAction extends AbstractAction { public OpenAction() { putValue(NAME, "Open..."); putValue(ACCELERATOR_KEY, PlatformUtils.getKeyStroke(KeyEvent.VK_O)); } public void actionPerformed(ActionEvent e) { File chosenFile = FileUtils.showOpenDialog(NodeBoxDocument.this, lastFilePath, "ndbx", "NodeBox Document"); if (chosenFile != null) { open(chosenFile); } } }} 
public void receive ( NodeEvent event ) { if ( event . getSource ( ) ! = activeNetwork ) return ; if ( event instanceof NodeDirtyEvent ) { requestActiveNetworkUpdate ( ) ; 
private void requestActiveNetworkUpdate ( ) { if ( ! loaded ) return ; addressBar . setProgressVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; Pane newPane ; try { Constructor c = paneType . getConstructor ( NodeBoxDocument . class ) ; newPane = ( Pane ) c . newInstance ( this . document ) ; } catch ( Exception e ) { throw new RuntimeException ( " Could not instantiate new " + paneType , e ) ; } Container parent = getParent ( ) ; if ( parent instanceof PaneSplitter ) { PaneSplitter parentSplit = ( PaneSplitter ) parent ; boolean first = parentSplit . getFirstComponent ( ) = = this ; if ( first ) { parentSplit . setFirstComponent ( newPane ) ; } else { parentSplit . setSecondComponent ( newPane ) ; } } else { Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; } parent . validate ( ) ; } 
public void receive ( NodeEvent event ) { if ( event . getSource ( ) ! = parameter . getNode ( ) ) return ; if ( event instanceof ValueChangedEvent ) { Check if the value change triggered a change in expression status. 
public void receive ( NodeEvent event ) { if ( event instanceof NodeUpdatedEvent ) { if ( event . getSource ( ) ! = node ) return ; 
public void receive ( NodeEvent event ) { if ( ! ( event instanceof ValueChangedEvent ) ) return ; if ( ( ( ValueChangedEvent ) event ) . getParameter ( ) ! = parameter ) return ; setValueForControl ( parameter . getValue ( ) ) ; } 
public void setName ( String name ) throws InvalidNameException { if ( this . name . equals ( name ) ) return ; validateName ( name ) ; this . parent . children . remove ( this . name ) ; this . name = name ; this . parent . children . put ( this . name , this ) ; getLibrary ( ) . fireNodeAttributeChanged ( this , Attribute . NAME ) ; } 
public void add ( Node node ) { if ( node = = null ) throw new IllegalArgumentException ( " The node cannot be null. " ) ; node . setParent ( this ) ; } 
public boolean remove ( Node node ) { assert ( node ! = null ) ; if ( ! contains ( node ) ) return false ; node . markDirty ( ) ; node . disconnect ( ) ; node . parent = null ; children . remove ( node . getName ( ) ) ; if ( node = = renderedChild ) { setRenderedChild ( null ) ; } getLibrary ( ) . fireChildRemoved ( this , node ) ; return true ; } 
public Parameter addParameter ( String name , Parameter . Type type ) { Parameter p = new Parameter ( this , name , type ) ; parameters . put ( name , p ) ; getLibrary ( ) . fireNodeAttributeChanged ( this , Attribute . PARAMETER ) ; return p ; } 
public Parameter addParameter ( String name , Parameter . Type type , Object value ) { Parameter p = addParameter ( name , type ) ; p . setValue ( value ) ; getLibrary ( ) . fireNodeAttributeChanged ( this , Attribute . PARAMETER ) ; return p ; } 
public boolean removeParameter ( String name ) { First remove all dependencies to and from this parameter. Don't rewrite any expressions. Parameter p = parameters.get(name); if (p == null) return false; p.removedEvent(); parameters.remove(name); getLibrary().fireNodeAttributeChanged(this, Attribute.PARAMETER); markDirty(); return true; } 
public Port addPort ( String name , Port . Cardinality cardinality ) { Port p = new Port ( this , name , cardinality ) ; ports . put ( name , p ) ; if ( parent ! = null ) { if ( parent . childGraph = = null ) parent . childGraph = new DependencyGraph < Port , Connection > ( ) ; parent . childGraph . addDependency ( p , outputPort ) ; } getLibrary ( ) . fireNodeAttributeChanged ( this , Attribute . PORT ) ; return p ; } 
public boolean disconnect ( Port input , Node outputNode ) { if ( input = = null ) throw new IllegalArgumentException ( " The input port cannot be null. " ) ; if ( outputNode = = null ) throw new IllegalArgumentException ( " The output node cannot be null. " ) ; if ( input . getParentNode ( ) ! = outputNode . getParent ( ) ) throw new IllegalArgumentException ( " The input and output are not under the same parent. " ) ; if ( ! input . isInputPort ( ) ) throw new IllegalArgumentException ( " The given port is not an input. " ) ; Node parent = input . getParentNode ( ) ; if ( parent = = null ) return false ; DependencyGraph < Port , Connection > dg = parent . childGraph ; if ( dg = = null ) return false ; Connection c = dg . getInfo ( input ) ; Port output = outputNode . outputPort ; boolean removedSomething = dg . removeDependency ( output , input ) ; if ( removedSomething ) { We remove the output port from the connection. c.removeOutput(output); If the connection has no more output ports, remove the connection entirely. if (!c.hasOutputs()) dg.removeInfo(input); input.reset(); This port was changed. Mark the node as dirty. input.getNode().markDirty(); getLibrary().fireConnectionRemoved(parent, c); } return removedSomething; } 
public void update ( ProcessingContext ctx ) throws ProcessingError { if ( ! dirty ) return ; Update the dependencies. This might cause an exception which we don't catch, instead letting it boil up. updateDependencies(ctx); All dependencies are up-to-date. Process the node. ProcessingError pe = null; try { process(ctx); } catch (ProcessingError e) { pe = e; } Even if an error occurred the node is still marked as clean, and events are fired. Only after these steps is the error thrown. It is important to mark the node as clean so that subsequent changes to the node mark it as dirty, triggering an event. This allows you to fix the cause of the error in the node. dirty = false; getLibrary().fireNodeUpdated(this, ctx); If exception occurs, throw it. if (pe != null) throw pe; 
public String toString ( ) { return " NodeEvent{ " + " source= " + source + 
public void addListener ( NodeEventListener l ) { listeners . add ( new WeakReference < NodeEventListener > ( l ) ) ; } 
public boolean removeListener ( NodeEventListener l ) { Iterator < WeakReference < NodeEventListener > > it = listeners . iterator ( ) ; WeakReference < NodeEventListener > toRemove = null ; while ( it . hasNext ( ) ) { WeakReference < NodeEventListener > ref = it . next ( ) ; if ( l = = ref . get ( ) ) { toRemove = ref ; break ; } } if ( toRemove ! = null ) { listeners . remove ( toRemove ) ; return true ; } return false ; } 
public void send ( NodeEvent event ) { for ( WeakReference < NodeEventListener > ref : listeners ) { NodeEventListener l = ref . get ( ) ; 
public void addListener ( NodeEventListener l ) { eventBus . addListener ( l ) ; } 
public boolean removeListener ( NodeEventListener l ) { return eventBus . removeListener ( l ) ; } 
public void fireNodeDirty ( Node source ) { eventBus . send ( new NodeDirtyEvent ( source ) ) ; } 
public void fireNodeUpdated ( Node source , ProcessingContext context ) { eventBus . send ( new NodeUpdatedEvent ( source , context ) ) ; } 
public void fireNodeAttributeChanged ( Node source , Node . Attribute attribute ) { eventBus . send ( new NodeAttributeChangedEvent ( source , attribute ) ) ; } 
public void fireChildAdded ( Node source , Node child ) { eventBus . send ( new ChildAddedEvent ( source , child ) ) ; } 
public void fireChildRemoved ( Node source , Node child ) { eventBus . send ( new ChildRemovedEvent ( source , child ) ) ; } 
public void fireConnectionAdded ( Node source , Connection c ) { eventBus . send ( new ConnectionAddedEvent ( source , c ) ) ; } 
public void fireConnectionRemoved ( Node source , Connection c ) { eventBus . send ( new ConnectionRemovedEvent ( source , c ) ) ; } 
public void fireRenderedChildChanged ( Node source , Node child ) { eventBus . send ( new RenderedChildChangedEvent ( source , child ) ) ; } 
public void fireValueChanged ( Node source , Parameter parameter ) { eventBus . send ( new ValueChangedEvent ( source , parameter ) ) ; } 
public void setName ( String name ) throws InvalidNameException { if ( name ! = null & & getName ( ) . equals ( name ) ) return ; validateName ( name ) ; String oldName = this . name ; this . name = name ; node . renameParameter ( this , oldName , name ) ; fireAttributeChanged ( ) ; } 
public void fireAttributeChanged ( ) { getLibrary ( ) . fireNodeAttributeChanged ( node , Node . Attribute . PARAMETER ) ; } 
private void removeDependencies ( ) { getLibrary ( ) . removeParameterDependencies ( this ) ; } 
public String toString ( ) { return " ChildAddedEvent{ " + " child= " + child + 
public String toString ( ) { return " ChildRemovedEvent{ " + " source= " + getSource ( ) + 
public String toString ( ) { return " ConnectionAddedEvent{ " + " source= " + getSource ( ) + 
public String toString ( ) { return " ConnectionRemovedEvent{ " + " source= " + getSource ( ) + 
public String toString ( ) { return " NodeAttributeChangedEvent{ " + " source= " + getSource ( ) + 
public String toString ( ) { return " NodeDirtyEvent{ " + " source= " + getSource ( ) + 
public String toString ( ) { return " NodeUpdatedEvent{ " + " source= " + getSource ( ) + 
public String toString ( ) { return " RenderedChildChangedEvent{ " + " source= " + getSource ( ) + 
public String toString ( ) { return " ValueChangedEvent{ " + " source= " + getSource ( ) + 
public void receive ( NodeEvent event ) { if ( event instanceof ConnectionAddedEvent ) { connectCounter + + ; 
public void testConnectionEvents ( ) { ConnectListener l = new ConnectListener ( ) ; Setup a basic network with number1 <- addConstant1 Node root = testLibrary.getRootNode(); testLibrary.addListener(l); Node number1 = root.create(numberNode); Node addConstant1 = root.create(addConstantNode); No connect/disconnect events have been fired. assertEquals(0, l.connectCounter); assertEquals(0, l.disconnectCounter); Creating a connection fires the event. addConstant1.getPort("value").connect(number1); assertEquals(1, l.connectCounter); assertEquals(0, l.disconnectCounter); Create a second number and connect it to the add constant. This should fire a disconnect event from number1, and a connect event to number2. Node number2 = root.create(numberNode); addConstant1.getPort("value").connect(number2); assertEquals(2, l.connectCounter); assertEquals(1, l.disconnectCounter); Disconnect the constant node. This should remove all (1) connections, and cause one disconnect event. addConstant1.disconnect(); assertEquals(2, l.connectCounter); assertEquals(2, l.disconnectCounter); testLibrary.removeListener(l); } 
public void receive ( NodeEvent event ) { if ( event . getSource ( ) ! = source ) return ; if ( event instanceof NodeDirtyEvent ) { dirtyCounter + + ; 
public void receive ( NodeEvent event ) { if ( event . getSource ( ) ! = this . source ) return ; if ( event instanceof ChildAddedEvent ) { childAddedCounter + + ; 
public void testDataEvent ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; TestDataListener l = new TestDataListener ( net ) ; testLibrary . addListener ( l ) ; Node n1 = net . create ( numberNode ) ; Node n2 = net . create ( numberNode ) ; assertEquals ( 0 , l . dirtyCounter ) ; assertEquals ( 0 , l . updatedCounter ) ; n1 . setRendered ( ) ; Network was already dirty from the start, counter is not updated. assertEquals(0, l.dirtyCounter); assertEquals(0, l.updatedCounter); net.update(); assertEquals(0, l.dirtyCounter); assertEquals(1, l.updatedCounter); n2.setRendered(); assertEquals(1, l.dirtyCounter); assertEquals(1, l.updatedCounter); net.update(); assertEquals(1, l.dirtyCounter); assertEquals(2, l.updatedCounter); } 
public void testChildEvent ( ) { Node parent1 = Node . ROOT_NODE . newInstance ( testLibrary , " parent1 " ) ; Node parent2 = Node . ROOT_NODE . newInstance ( testLibrary , " parent2 " ) ; TestChildListener l1 = new TestChildListener ( parent1 ) ; TestChildListener l2 = new TestChildListener ( parent2 ) ; testLibrary . addListener ( l1 ) ; testLibrary . addListener ( l2 ) ; Node n1 = parent1 . create ( numberNode ) ; assertEquals ( 1 , l1 . childAddedCounter ) ; n1 . setParent ( parent2 ) ; assertEquals ( 1 , l1 . childAddedCounter ) ; assertEquals ( 1 , l2 . childAddedCounter ) ; assertEquals ( 1 , l1 . childRemovedCounter ) ; } 
public void receive ( NodeEvent event ) { if ( ! ( event instanceof NodeAttributeChangedEvent ) ) return ; Node . Attribute attribute = ( ( NodeAttributeChangedEvent ) event ) . getAttribute ( ) ; switch ( attribute ) { case LIBRARY : 
public void testError ( ) { Node bad = addDirectNode . newInstance ( testLibrary , " bad " ) ; TestDirtyListener listener = new TestDirtyListener ( bad ) ; testLibrary . addListener ( listener ) ; bad . setValue ( " v1 " , 12 ) ; bad . setValue ( " v2 " , 3 ) ; Since the node starts out as dirty, setting values doesn't increase the counter. assertEquals(0, listener.dirtyCounter); This code inherits the default code, which doesn't throw an error. bad.update(); assertEquals(15, bad.getOutputValue()); Updating the code marks it as clean. assertFalse(bad.isDirty()); assertEquals(1, listener.updatedCounter); assertEquals(0, listener.dirtyCounter); This code causes a division by zero. bad.setValue("_code", new PythonCode("def cook(self): return 1 / 0")); assertEquals(1, listener.dirtyCounter); We just changed a parameter value, so the node is dirty. assertTrue(bad.isDirty()); Processing will fail. assertProcessingError(bad, "integer division or modulo by zero"); After processing failed, events are still called, and the node is marked clean. Output is set to null. assertFalse(bad.isDirty()); assertNull(bad.getOutputValue()); assertEquals(2, listener.updatedCounter); assertEquals(1, listener.dirtyCounter); } 
public void testNodeAttributeEvent ( ) { TestAttributeListener l = new TestAttributeListener ( ) ; Node test = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; testLibrary . addListener ( l ) ; Setting the name to itself does not trigger an event. test.setName("test"); assertEquals(0, l.nameCounter); test.setName("newname"); assertEquals(1, l.nameCounter); Parameter p1 = test.addParameter("p1", Parameter.Type.FLOAT); assertEquals(1, l.parameterCounter); p1.setName("parameter1"); assertEquals(2, l.parameterCounter); TODO: These trigger ParameterAttributeChanged p1.setBoundingMethod(Parameter.BoundingMethod.HARD); assertEquals(3, l.parameterCounter); p1.setMinimumValue(0F); assertEquals(4, l.parameterCounter); Changing the value does not trigger the event. The event only happens for metadata, not data. If you want to catch that, listen for NodeDirtyEvents. p1.setValue(20F); assertEquals(2, l.parameterCounter); test.removeParameter("parameter1"); assertEquals(3, l.parameterCounter); } 
public void receive ( NodeEvent event ) { if ( event instanceof ValueChangedEvent ) { valueChanged ( ( ( ValueChangedEvent ) event ) . getParameter ( ) ) ; 
public void receive ( NodeEvent event ) { if ( event instanceof NodeAttributeChangedEvent ) { changeCounter + + ; 
public void testParameterValueEvents ( ) { TestParameterValueListener l ; Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; l = new TestParameterValueListener ( ) ; testLibrary . addListener ( l ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; Parameter pBeta = . addParameter ( " beta " , Parameter . Type . FLOAT ) ; Initialization has triggered the parameter value event. assertEquals(1, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); Update the node so new events will get fired. n.update(); pAlpha.setValue(100); assertEquals(2, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); Change the value to the current value. This should not trigger the event. pAlpha.setValue(100); assertEquals(2, l.getCounter(pAlpha)); assertEquals(1, l.getCounter(pBeta)); The node is already dirty, and parameters will not receive any new events. Update the node so it becomes clean again. Set an expression for beta. This triggers the event. n.update(); pAlpha.setValue(3); pBeta.setExpression("alpha + 1"); assertEquals(2, l.getCounter(pBeta)); Now change alpha. This will not trigger beta, since the node is not updated yet. assertEquals(3, l.getCounter(pAlpha)); assertEquals(2, l.getCounter(pBeta)); Update the node, which will trigger the value changed event. n.update(); assertEquals(3, l.getCounter(pAlpha)); assertEquals(3, l.getCounter(pBeta)); } 
public void testParameterMetaEvents ( ) { TestParameterAttributeListener l ; Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pMenu = alpha . addParameter ( " menu " , Parameter . Type . STRING ) ; l = new TestParameterAttributeListener ( ) ; testLibrary . addListener ( l ) ; assertEquals ( 0 , l . changeCounter ) ; pMenu . setWidget ( Parameter . Widget . MENU ) ; assertEquals ( 1 , l . changeCounter ) ; pMenu . addMenuItem ( " en " , " English " ) ; pMenu . addMenuItem ( " es " , " Spanis " ) ; assertEquals ( 3 , l . changeCounter ) ; testLibrary . removeListener ( l ) ; Parameter pFloat = alpha . addParameter ( " float " , Parameter . Type . FLOAT ) ; l = new TestParameterAttributeListener ( ) ; testLibrary . addListener ( l ) ; assertEquals ( 0 , l . changeCounter ) ; pFloat . setBoundingMethod ( Parameter . BoundingMethod . HARD ) ; assertEquals ( 1 , l . changeCounter ) ; pFloat . setMinimumValue ( - 100 f ) ; pFloat . setMaximumValue ( 100 f ) ; assertEquals ( 3 , l . changeCounter ) ; testLibrary . removeListener ( l ) ; } 
public void testEnableExpressionEvents ( ) { Node = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; Parameter pAlpha = . addParameter ( " alpha " , Parameter . Type . FLOAT ) ; CountingNodeAttributeListener listener = new CountingNodeAttributeListener ( ) ; testLibrary . addListener ( listener ) ; pAlpha . setEnableExpression ( " " ) ; assertEquals ( 0 , listener . count ) ; pAlpha . setEnableExpression ( null ) ; assertEquals ( 0 , listener . count ) ; pAlpha . setEnableExpression ( " false " ) ; assertEquals ( 1 , listener . count ) ; pAlpha . setEnableExpression ( " false " ) ; assertEquals ( 1 , listener . count ) ; pAlpha . setEnableExpression ( null ) ; assertEquals ( 2 , listener . count ) ; pAlpha . setEnableExpression ( " " ) ; assertEquals ( 2 , listener . count ) ; } 
public void receive ( NodeEvent event ) { if ( event instanceof NodeAttributeChangedEvent ) { count + + ; 
public boolean readFromFile ( String path ) { This method looks unused, but is actually called using reflection by the OS X adapter. return openDocument(new File(path)); } 
public NodeBoxDocument createNewDocument ( ) { NodeBoxDocument doc = new NodeBoxDocument ( new NodeLibrary ( " untitled " ) ) ; addDocument ( doc ) ; return doc ; } 
private void addDocument ( NodeBoxDocument doc ) { doc . setVisible ( true ) ; doc . requestFocus ( ) ; documents . add ( doc ) ; currentDocument = doc ; } 
public void windowOpened ( WindowEvent e ) { } public void windowClosing ( WindowEvent e ) { close ( ) ; } public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); }} 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); }} 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); }} 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); }} 
public void windowDeactivated ( WindowEvent e ) { } Network events public void receive(NodeEvent event) { if (event.getSource() != activeNetwork) return; if (event instanceof NodeDirtyEvent) { requestActiveNetworkUpdate(); } } private void requestActiveNetworkUpdate() { if (!loaded) return; addressBar.setProgressVisible(true); SwingUtilities.invokeLater(new Runnable() { public void run() { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; markChanged(); try { activeNetwork.update(); } catch (ProcessingError processingError) { Logger.getLogger("NodeBoxDocument").log(Level.WARNING, "Error while processing", processingError); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { addressBar.setProgressVisible(false); } }); } } }); }} 
public void actionPerformed ( ActionEvent e ) { File chosenFile = FileUtils . showOpenDialog ( getDocument ( ) , NodeBoxDocument . lastFilePath , " ndbx " , " NodeBox Document " ) ; if ( chosenFile ! = null ) { Application . getInstance ( ) . openDocument ( chosenFile ) ; 
public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . openDocument ( file ) ; } 
public void receive ( NodeEvent event ) { if ( event . getSource ( ) ! = node ) return ; if ( ! ( event instanceof NodeAttributeChangedEvent ) ) return ; if ( ( ( NodeAttributeChangedEvent ) event ) . getAttribute ( ) = = Node . Attribute . POSITION ) return ; rebuildInterface ( ) ; } 
public void markChanged ( ) { if ( ! documentChanged & & loaded ) { documentChanged = true ; 
public void run ( ) { If meanwhile the node has been marked clean, ignore the event. if (!activeNetwork.isDirty()) return; try { activeNetwork.update(); 
public void draw ( GraphicsContext ctx ) { float x = getCenterX ( ) ; float y = getCenterY ( ) ; float radius = getRadius ( ) ; ctx . fill ( null ) ; ctx . stroke ( HANDLE_COLOR ) ; ctx . ellipse ( x , y , radius * 2 , radius * 2 ) ; if ( pt ! = null ) drawDot ( ctx , pt . x , pt . y ) ; 
public static void checkArgument ( boolean expression ) { if ( ! expression ) { throw new IllegalArgumentException ( ) ; 
public static void checkArgument ( boolean expression , Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; 
public static void checkArgument ( boolean expression , String errorMessageTemplate , Object . . . errorMessageArgs ) { if ( ! expression ) { throw new IllegalArgumentException ( 
public static void checkState ( boolean expression ) { if ( ! expression ) { throw new IllegalStateException ( ) ; 
public static void checkState ( boolean expression , Object errorMessage ) { if ( ! expression ) { throw new IllegalStateException ( String . valueOf ( errorMessage ) ) ; 
public static void checkState ( boolean expression , String errorMessageTemplate , Object . . . errorMessageArgs ) { if ( ! expression ) { throw new IllegalStateException ( 
public static < T > T checkNotNull ( T reference ) { if ( reference = = null ) { throw new NullPointerException ( ) ; } return reference ; } 
public static < T > T checkNotNull ( T reference , Object errorMessage ) { if ( reference = = null ) { throw new NullPointerException ( String . valueOf ( errorMessage ) ) ; } return reference ; } 
public static < T > T checkNotNull ( T reference , String errorMessageTemplate , Object . . . errorMessageArgs ) { if ( reference = = null ) { If either of these parameters is null, the right thing happens anyway throw new NullPointerException( format(errorMessageTemplate, errorMessageArgs)); } return reference; } 
public static int checkElementIndex ( int index , int size ) { return checkElementIndex ( index , size , " index " ) ; } 
public static int checkElementIndex ( int index , int size , String desc ) { Carefully optimized for execution by hotspot (explanatory comment above) if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(badElementIndex(index, size, desc)); } return index; } 
private static String badElementIndex ( int index , int size , String desc ) { if ( index < 0 ) { return format ( " %s (%s) must not be negative " , desc , index ) ; 
public static int checkPositionIndex ( int index , int size ) { return checkPositionIndex ( index , size , " index " ) ; } 
public static int checkPositionIndex ( int index , int size , String desc ) { Carefully optimized for execution by hotspot (explanatory comment above) if (index < 0 || index > size) { throw new IndexOutOfBoundsException(badPositionIndex(index, size, desc)); } return index; } 
private static String badPositionIndex ( int index , int size , String desc ) { if ( index < 0 ) { return format ( " %s (%s) must not be negative " , desc , index ) ; 
public static void checkPositionIndexes ( int start , int end , int size ) { Carefully optimized for execution by hotspot (explanatory comment above) if (start < 0 || end < start || end > size) { throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size)); 
private static String badPositionIndexes ( int start , int end , int size ) { if ( start < 0 | | start > size ) { return badPositionIndex ( start , size , " start index " ) ; } if ( end < 0 | | end > size ) { return badPositionIndex ( end , size , " end index " ) ; } end < start return format("end index (%s) must not be less than start index (%s)", end, start); 
static String format ( String template , Object . . . args ) { start substituting the arguments into the '%s' placeholders StringBuilder builder = new StringBuilder( template.length() + 16 * args.length); int templateStart = 0; int i = 0; while (i < args.length) { int placeholderStart = template.indexOf("%s", templateStart); if (placeholderStart == -1) { break; } builder.append(template.substring(templateStart, placeholderStart)); builder.append(args[i++]); templateStart = placeholderStart + 2; } builder.append(template.substring(templateStart)); if we run out of placeholders, append the extra args in square braces if (i < args.length) { builder.append(" ["); builder.append(args[i++]); while (i < args.length) { builder.append(", "); builder.append(args[i++]); } builder.append("]"); } return builder.toString(); } 
public void deleteSelected ( ) { if ( selection = = null ) return ; networkView . getNode ( ) . disconnect ( selection ) ; } 
private void moveDelta ( int delta ) { Connection selectedConnection = ( Connection ) connectionList . getSelectedValue ( ) ; if ( selectedConnection = = null ) return ; java . util . List < Connection > connections = getConnections ( ) ; int index = connections . indexOf ( selectedConnection ) ; checkState ( index > = 0 , " Selected connection %s could not be found. " , selectedConnection ) ; boolean reordered = input . getParentNode ( ) . reorderConnection ( selectedConnection , delta ) ; if ( reordered ) { reloadList ( ) ; 
private void removeSelected ( ) { Connection selectedConnection = ( Connection ) connectionList . getSelectedValue ( ) ; if ( selectedConnection = = null ) return ; input . getParentNode ( ) . disconnect ( selectedConnection ) ; int lastIndex = connectionList . getSelectedIndex ( ) ; reloadList ( ) ; connectionList . setSelectedIndex ( Math . max ( 0 , lastIndex - 1 ) ) ; } 
private void reloadList ( ) { connectionList . setModel ( connectionListModel ) ; connectionList . repaint ( ) ; } 
public static void main ( String [ ] args ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node mergeShapes = Node . ROOT_NODE . newInstance ( library , " mergeshapes " , Polygon . class ) ; Node poly1 = Node . ROOT_NODE . newInstance ( library , " poly1 " , Polygon . class ) ; Node poly2 = Node . ROOT_NODE . newInstance ( library , " poly2 " , Polygon . class ) ; Node poly3 = Node . ROOT_NODE . newInstance ( library , " poly3 " , Polygon . class ) ; Node poly4 = Node . ROOT_NODE . newInstance ( library , " poly4 " , Polygon . class ) ; Port shapesPort = mergeShapes . addPort ( " shapes " , Port . Cardinality . MULTIPLE ) ; shapesPort . connect ( poly1 ) ; shapesPort . connect ( poly2 ) ; shapesPort . connect ( poly3 ) ; shapesPort . connect ( poly4 ) ; JDialog d = new JDialog ( ) ; d . setModal ( true ) ; d . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; MultiConnectionPanel panel = new MultiConnectionPanel ( shapesPort ) ; d . getContentPane ( ) . add ( panel , BorderLayout . CENTER ) ; d . setSize ( 400 , 400 ) ; d . setVisible ( true ) ; } 
public String toString ( ) { return String . format ( " %s <= %s " , getOutput ( ) , getInput ( ) ) ; } 
private boolean visit ( Node node ) { marks . put ( node , Color . GRAY ) ; for ( Connection c : connections ) { Node outputNode = c . getOutputNode ( ) ; Only use the ones I'm the input for (downstream connections for this node). if (c.getInputNode() != node) continue; if (!marks.containsKey(outputNode)) continue; if (marks.get(outputNode) == Color.GRAY) { return true; } else if (marks.get(outputNode) == Color.WHITE) { if (visit(outputNode)) { return true; } } else { Visiting black vertices is okay. } } marks.put(node, Color.BLACK); return false; } 
private static void writeConnection ( Document doc , Element parent , Connection conn ) { Port output = conn . getOutput ( ) ; Element connElement = doc . createElement ( " conn " ) ; connElement . setAttribute ( " output " , output . getNode ( ) . getName ( ) ) ; connElement . setAttribute ( " input " , conn . getInputNode ( ) . getName ( ) ) ; connElement . setAttribute ( " port " , conn . getInput ( ) . getName ( ) ) ; parent . appendChild ( connElement ) ; } 
public boolean remove ( Node node ) { assert ( node ! = null ) ; if ( ! containsChildNode ( node ) ) return false ; node . markDirty ( ) ; node . disconnect ( ) ; node . parent = null ; children . remove ( node . getName ( ) ) ; if ( node = = renderedChild ) { setRenderedChild ( null ) ; } getLibrary ( ) . fireChildRemoved ( this , node ) ; return true ; } 
public boolean containsChildNode ( String nodeName ) { return children . containsKey ( nodeName ) ; } 
public boolean containsChildNode ( Node node ) { return children . containsValue ( node ) ; } 
public boolean containsChildPort ( Port port ) { TODO: This check will need to change once we move to readonly. return port.getParentNode() == this; } 
public Port addPort ( String name , Port . Cardinality cardinality ) { Port p = new Port ( this , name , cardinality ) ; ports . put ( name , p ) ; TODO: Test this removal! if (parent != null) { if (parent.childGraph == null) parent.childGraph = new DependencyGraph<Port, Connection>(); parent.childGraph.addDependency(p, outputPort); } getLibrary().fireNodeAttributeChanged(this, Attribute.PORT); return p; } 
public boolean canConnectChildren ( Port input , Port output ) { TODO: Move implementation from Port here once we move to readonly. checkNotNull(input); checkNotNull(output); return input.canConnectTo(output); } 
public Connection connectChildren ( Node inputNode , String portName , Node outputNode ) { Port inputPort = inputNode . getPort ( portName ) ; Port outputPort = outputNode . getOutputPort ( ) ; return connectChildren ( inputPort , outputPort ) ; } 
public boolean reorderConnection ( Connection connection , int deltaIndex ) { int index = connections . indexOf ( connection ) ; int newIndex = index + deltaIndex ; newIndex = Math . max ( 0 , Math . min ( connections . size ( ) - 1 , newIndex ) ) ; if ( index = = newIndex ) return false ; connections . remove ( connection ) ; connections . add ( newIndex , connection ) ; connection . getInputNode ( ) . markDirty ( ) ; return true ; } 
public boolean disconnect ( ) { if ( ! hasParent ( ) ) return false ; return parent . disconnectChildren ( this ) ; } 
public void disconnect ( Connection c ) { checkNotNull ( c ) ; checkArgument ( connections . contains ( c ) , " Connection %s is not one of my connections. " , c ) ; connections . remove ( c ) ; Port input = c . getInput ( ) ; input . reset ( ) ; input . getNode ( ) . markDirty ( ) ; getLibrary ( ) . fireConnectionRemoved ( this , c ) ; } 
public boolean isConnected ( ) { if ( ! hasParent ( ) ) return false ; return getParent ( ) . isChildConnected ( this ) ; } 
public boolean isOutputConnectedTo ( Node inputNode ) { checkNotNull ( inputNode ) ; if ( ! inputNode . hasParent ( ) ) return false ; if ( ! hasParent ( ) ) return false ; return getParent ( ) . areChildrenConnected ( this , inputNode ) ; } 
public boolean isOutputConnectedTo ( Port input ) { checkNotNull ( input ) ; checkArgument ( input . isInputPort ( ) , " Port %s is not an input. " , input ) ; if ( ! input . hasParentNode ( ) ) return false ; return input . getParentNode ( ) . isChildConnectedTo ( input , this ) ; } 
public void stampDirty ( ) { if ( ! hasParent ( ) ) return ; getParent ( ) . stampChildDirty ( this , false ) ; } 
private void updatePorts ( ProcessingContext ctx ) throws ProcessingError { Update all upstream nodes. if (!hasParent()) return; for (Port port : ports.values()) { port.reset(); 
public boolean contains ( String nodeName ) { return rootNode . containsChildNode ( nodeName ) ; } 
public boolean hasParentNode ( ) { return getParentNode ( ) ! = null ; } 
public boolean isConnected ( ) { checkState ( hasParentNode ( ) , " Port %s has no parent node. " , this ) ; return getParentNode ( ) . isChildConnected ( this ) ; } 
public boolean isConnectedTo ( Port port ) { if ( ! isConnected ( ) ) return false ; if ( ! hasParentNode ( ) ) return false ; return getParentNode ( ) . isChildConnectedTo ( this , port ) ; } 
public Connection connect ( Node outputNode ) throws IllegalArgumentException { if ( outputNode = = null ) throw new IllegalArgumentException ( " Output node cannot be null. " ) ; if ( getParentNode ( ) = = null ) throw new IllegalArgumentException ( " This port has no parent node. " ) ; return getParentNode ( ) . connectChildren ( this , outputNode . getOutputPort ( ) ) ; } 
public void disconnect ( ) { getParentNode ( ) . disconnectChildPort ( this ) ; } 
public void testDisconnect ( ) { Node number1 = numberNode . newInstance ( testLibrary , " number1 " ) ; Node number2 = numberNode . newInstance ( testLibrary , " number2 " ) ; Node m = multiplyNode . newInstance ( testLibrary , " multiply1 " ) ; number1 . setValue ( " value " , 5 ) ; number2 . setValue ( " value " , 2 ) ; m . getPort ( " v1 " ) . connect ( number1 ) ; m . getPort ( " v2 " ) . connect ( number2 ) ; assertTrue ( m . getPort ( " v1 " ) . isConnected ( ) ) ; assertTrue ( number1 . isOutputConnected ( ) ) ; m . update ( ) ; assertEquals ( 5 , m . getPort ( " v1 " ) . getValue ( ) ) ; assertEquals ( 10 , m . getOutputValue ( ) ) ; assertFalse ( m . getPort ( " v1 " ) . getConnections ( ) . isEmpty ( ) ) ; Disconnecting a port makes the dependent nodes dirty, but not the upstream nodes. "Dirt flows downstream" m.getPort("v1").disconnect(); assertTrue(m.isDirty()); assertFalse(number1.isDirty()); assertFalse(m.getPort("v1").isConnected()); assertFalse(number1.isOutputConnected()); assertTrue(m.getPort("v1").getConnections().isEmpty()); The value of the input port is set to null after disconnection. Since our simple multiply node doesn't handle null, it throws a NullPointerException, which gets wrapped in a ProcessingError. assertProcessingError(m, NullPointerException.class); assertNull(m.getOutputValue()); } 
public void testDisconnectOutputNode ( ) { Setup a simple network where number1 <- addConstant1. Node root = testLibrary.getRootNode(); Node number1 = root.create(numberNode); Node addConstant1 = root.create(addConstantNode); Port pValue = addConstant1.getPort("value"); pValue.connect(number1); Remove the specific connection and check if everything was removed. root.disconnectChildPort(pValue, number1); assertFalse(number1.isConnected()); assertFalse(addConstant1.isConnected()); assertFalse(pValue.isConnected()); } 
public void testConnectionEvents ( ) { ConnectListener l = new ConnectListener ( ) ; Setup a basic network with number1 <- addConstant1 Node root = testLibrary.getRootNode(); testLibrary.addListener(l); Node number1 = root.create(numberNode); Node addConstant1 = root.create(addConstantNode); No connect/disconnectChildPort events have been fired. assertEquals(0, l.connectCounter); assertEquals(0, l.disconnectCounter); Creating a connection fires the event. addConstant1.getPort("value").connect(number1); assertEquals(1, l.connectCounter); assertEquals(0, l.disconnectCounter); Create a second number and connect it to the add constant. This should fire a disconnectChildPort event from number1, and a connect event to number2. Node number2 = root.create(numberNode); addConstant1.getPort("value").connect(number2); assertEquals(2, l.connectCounter); assertEquals(1, l.disconnectCounter); Disconnect the constant node. This should remove all (1) connections, and cause one disconnectChildPort event. addConstant1.disconnect(); assertEquals(2, l.connectCounter); assertEquals(2, l.disconnectCounter); testLibrary.removeListener(l); } 
public void testReorder ( ) { Node root = testLibrary . getRootNode ( ) ; Node number1 = root . create ( numberNode ) ; Node number2 = root . create ( numberNode ) ; Node number3 = root . create ( numberNode ) ; Node multiAdd = root . create ( multiAddNode ) ; Port pValues = multiAdd . getPort ( " values " ) ; Connection c1 = pValues . connect ( number1 ) ; Connection c2 = pValues . connect ( number2 ) ; Connection c3 = pValues . connect ( number3 ) ; assertOrder ( pValues , number1 , number2 , number3 ) ; Move number 2 up. root.reorderConnection(c2, -1); assertOrder(pValues, number2, number1, number3); assertDirtyAndUpdate(multiAdd); Move number 3 down. It was already last, so shouldn't change anything. root.reorderConnection(c3, 1); assertOrder(pValues, number2, number1, number3); assertFalse(multiAdd.isDirty()); Move number 3 up by a large amount. It should just move it to the first position. root.reorderConnection(c3, -5000); assertOrder(pValues, number3, number2, number1); assertDirtyAndUpdate(multiAdd); Move number 2 by a large amount, moving it to the end. root.reorderConnection(c2, 5000); assertOrder(pValues, number3, number1, number2); assertDirtyAndUpdate(multiAdd); Move number 1 by zero places. This should not move anything and not mark the node as dirty. root.reorderConnection(c1, 0); assertOrder(pValues, number3, number1, number2); assertFalse(multiAdd.isDirty()); } 
private void assertOrder ( Port port , Node . . . nodes ) { List < Connection > connections = port . getConnections ( ) ; for ( int i = 0 ; i < nodes . length ; i + + ) { assertEquals ( nodes [ i ] , connections . get ( i ) . getOutputNode ( ) ) ; 
public void testCreate ( ) { Node grandParent = testNetworkNode . newInstance ( testLibrary , " grandParent " ) ; Node parent = grandParent . create ( testNetworkNode , " parent " ) ; Node child = parent . create ( numberNode ) ; assertTrue ( grandParent . containsChildNode ( parent ) ) ; assertTrue ( parent . containsChildNode ( child ) ) ; Contains doesn't go into child networks. assertFalse(grandParent.containsChildNode(child)); assertTrue(child.hasParent()); assertTrue(grandParent.hasParent()); assertTrue(child.hasParent()); assertFalse(testLibrary.getRootNode().hasParent()); assertEquals(testLibrary.getRootNode(), grandParent.getParent()); assertEquals(grandParent, parent.getParent()); assertEquals(parent, child.getParent()); } 
public void testPersistence ( ) { Node polynet1 = manager . getNode ( " polygraph.network " ) . newInstance ( testLibrary , " polynet1 " ) ; Node polynet1 = testLibrary.getRootNode().create(manager.getNode("polygraph.network"), "polynet1"); polynet1.setPosition(10, 10); assertEquals("polynet1", polynet1.getName()); polynet1.setRendered(); Node polygon1 = polynet1.create(manager.getNode("polygraph.polygon")); assertEquals("polygon1", polygon1.getName()); polygon1.setRendered(); polygon1.setPosition(100, 30); Node translate1 = polynet1.create(manager.getNode("polygraph.translate")); assertEquals("translate1", translate1.getName()); translate1.setPosition(40, 80); translate1.setRendered(); translate1.getPort("polygon").connect(polygon1); Node rect1 = polynet1.create(manager.getNode("polygraph.rect")); assertEquals("rect1", rect1.getName()); rect1.setPosition(180, 30); Node merge1 = polynet1.create(manager.getNode("polygraph.merge")); assertEquals("merge1", merge1.getName()); merge1.getPort("polygons").connect(translate1); merge1.getPort("polygons").connect(rect1); NodeLibrary newLibrary = storeAndLoad(testLibrary); Node newRoot = newLibrary.getRootNode(); assertEquals("root", newRoot.getName()); assertTrue(newRoot.containsChildNode("polynet1")); Node nPolynet1 = newRoot.getChild("polynet1"); assertTrue(nPolynet1.containsChildNode("polygon1")); assertTrue(nPolynet1.containsChildNode("translate1")); Node nPolygon1 = nPolynet1.getChild("polygon1"); Node nTranslate1 = nPolynet1.getChild("translate1"); Node nRect1 = nPolynet1.getChild("rect1"); Node nMerge1 = nPolynet1.getChild("merge1"); assertEquals(polygon1.getValue("x"), nPolygon1.getValue("x")); assertEquals(polygon1.getValue("fill"), nPolygon1.getValue("fill")); assertEquals(polygon1.getValue("stroke"), nPolygon1.getValue("stroke")); assertTrue(nPolygon1.isConnected()); assertTrue(nTranslate1.isConnected()); assertTrue(nTranslate1.getPort("polygon").isConnectedTo(nPolygon1)); assertTrue(nMerge1.getPort("polygons").isConnectedTo(nRect1)); assertTrue(nMerge1.getPort("polygons").isConnectedTo(nTranslate1)); Check if this is the same connection Port nPolygons = nMerge1.getPort("polygons"); assertEquals(1, nTranslate1.getOutputPort().getConnections().size()); assertEquals(1, nRect1.getOutputPort().getConnections().size()); Connection c1 = nTranslate1.getOutputPort().getConnections().get(0); Connection c2 = nRect1.getOutputPort().getConnections().get(0); assertTrue(c1 != c2); This tests for a bug where the connection would be created twice. nMerge1.getPort("polygons").disconnect(); assertFalse(nPolygons.isConnectedTo(nRect1)); assertFalse(nPolygons.isConnectedTo(nTranslate1)); } 
private NodeLibrary storeAndLoad ( NodeLibrary lib ) { String xml = lib . toXml ( ) ; return manager . load ( " newLibrary " , xml ) ; } 
public void testNewInstance ( ) { NodeLibrary test = new NodeLibrary ( " test " ) ; Node alpha = Node . ROOT_NODE . newInstance ( test , " alpha " ) ; assertTrue ( test . contains ( " alpha " ) ) ; assertTrue ( test . getRootNode ( ) . containsChildNode ( " alpha " ) ) ; assertTrue ( test . getRootNode ( ) . containsChildNode ( alpha ) ) ; } 
public void testChildNodes ( ) { Node net = Node . ROOT_NODE . newInstance ( testLibrary , " net " ) ; Node rect = Node . ROOT_NODE . newInstance ( testLibrary , " rect " ) ; rect . setParent ( net ) ; assertTrue ( net . containsChildNode ( " rect " ) ) ; } 
public void testCopyWithUpstream ( ) { We create a simple network where alpha1 <- beta1 <- gamma1 beta1 will be the node to copy. This checks if upstreams/downstreams are handled correctly. Node net1 = testNetworkNode.newInstance(testLibrary, "net1"); Node net2 = testNetworkNode.newInstance(testLibrary, "net2"); Node alpha1 = net1.create(Node.ROOT_NODE, "alpha1", Integer.class); Node beta1 = net1.create(Node.ROOT_NODE, "beta1", Integer.class); String originalDescription = "Beta description"; beta1.setDescription(originalDescription); beta1.setValue("_code", new PythonCode("def cook(self): return self.value")); Node gamma1 = net1.create(Node.ROOT_NODE, "gamma1", Integer.class); int originalValue = 5; beta1.addParameter("value", Parameter.Type.INT, originalValue); Port betaPort1 = beta1.addPort("betaPort1"); Port gammaPort1 = gamma1.addPort("gammaPort1"); betaPort1.connect(alpha1); gammaPort1.connect(beta1); Update and clean the network. gamma1.update(); assertFalse(beta1.isDirty()); assertEquals(originalValue, beta1.getOutputValue()); Copying under the same parent will give the node a unique name. Node beta2 = net1.copyChild(beta1, net1); assertEquals("beta2", beta2.getName()); Copying under a different parent keep the original name. Node beta3 = net1.copyChild(beta1, net2); assertEquals("beta1", beta3.getName()); The node inherits from the same prototype as the original. assertSame(beta1.getPrototype(), beta2.getPrototype()); It also retains all the same changes as the original. assertSame(beta1.getDataClass(), beta2.getDataClass()); assertTrue(beta2.hasParameter("value")); assertEquals(originalValue, beta2.asInt("value")); assertTrue(beta2.hasPort("betaPort1")); Some other properties. assertEquals(20.0, beta2.getX()); assertEquals(80.0, beta2.getY()); assertEquals(originalDescription, beta2.getDescription()); The new node will be dirty and won't have any output data. assertTrue(beta2.isDirty()); assertNull(beta2.getOutputValue()); It also retains connections to the upstream nodes, although the connection objects differ. It does not retain connections to the downstream nodes since that would replace existing connections. assertTrue(beta2.isConnectedTo(alpha1)); Connection newConn = beta2.getPort("betaPort1").getConnections().get(0); assertNotSame(betaPort1.getConnections().get(0), newConn); assertFalse(beta2.isConnectedTo(gamma1)); If the new node is under a different parent connections cannot be retained. assertFalse(beta3.isConnected()); Try updating the node to see if the results are still correct. beta2.update(); assertEquals(originalValue, beta2.getOutputValue()); Changes to the copy should not affect the original and vice versa. int newValueForOriginal = 11; int newValueForCopy = 33; beta1.setValue("value", newValueForOriginal); assertEquals(originalValue, beta2.asInt("value")); beta2.setValue("value", newValueForCopy); assertEquals(newValueForOriginal, beta1.asInt("value")); } 
public void testNewInstanceChildren ( ) { Node root = testLibrary . getRootNode ( ) ; Test if children of the prototype are copied as well. Node protoNet = root.create(testNetworkNode, "protoNet"); Node number1 = protoNet.create(numberNode); Node negate1 = protoNet.create(negateNode); number1.setExpression("value", "40+2"); negate1.getPort("value").connect(number1); negate1.setRendered(); Create new node based on prototype. Node protoNet1 = root.create(protoNet); assertEquals("protoNet1", protoNet1.getName()); assertTrue(protoNet1.containsChildNode("number1")); assertTrue(protoNet1.containsChildNode("negate1")); assertTrue(protoNet1.getChild("negate1").isConnectedTo(protoNet1.getChild("number1"))); assertEquals(0, protoNet1.getChild("number1").getValue("value")); assertEquals("40+2", protoNet1.getChild("number1").getParameter("value").getExpression()); protoNet1.update(); assertEquals(42, protoNet1.getChild("number1").getValue("value")); assertEquals(-42, protoNet1.getOutputValue()); } 
public void testMultiParameters ( ) { Node net1 = Node . ROOT_NODE . newInstance ( testLibrary , " net1 " ) ; Node number1 = net1 . create ( numberNode ) ; number1 . setValue ( " value " , 1 ) ; Node number2 = net1 . create ( numberNode ) ; number2 . setValue ( " value " , 2 ) ; Node number3 = net1 . create ( numberNode ) ; number3 . setValue ( " value " , 3 ) ; Node multiAdd = net1 . create ( multiAddNode ) ; Connection c1 = multiAdd . getPort ( " values " ) . connect ( number1 ) ; Connection c2 = multiAdd . getPort ( " values " ) . connect ( number2 ) ; Connection c3 = multiAdd . getPort ( " values " ) . connect ( number3 ) ; assertFalse ( c1 = = c2 ) ; assertFalse ( c1 = = c3 ) ; multiAdd . update ( ) ; assertEquals ( 1 + 2 + 3 , multiAdd . getOutputValue ( ) ) ; Check dirty propagation assertFalse(multiAdd.isDirty()); number2.setValue("value", 200); assertTrue(multiAdd.isDirty()); multiAdd.update(); assertEquals(1 + 200 + 3, multiAdd.getOutputValue()); Check disconnectChildPort number2.disconnect(); assertFalse(number2.isConnected()); assertTrue(number1.isConnected()); assertTrue(number3.isConnected()); assertTrue(multiAdd.isConnected()); multiAdd.update(); assertEquals(1 + 3, multiAdd.getOutputValue()); multiAdd.disconnect(); assertFalse(number2.isConnected()); assertFalse(number1.isConnected()); assertFalse(number3.isConnected()); assertFalse(multiAdd.isConnected()); } 
public void testDowncasting ( ) { Node grobNode = nodeWithDataClass ( " grob " , Grob . class ) ; Node canvasNode = nodeWithDataClass ( " canvas " , Canvas . class ) ; Node imageNode = nodeWithDataClass ( " image " , Image . class ) ; Node pathNode = nodeWithDataClass ( " path " , Path . class ) ; Node textNode = nodeWithDataClass ( " text " , Text . class ) ; Canvas canvas = new Canvas ( ) ; Image image = new Image ( ) ; Path path = new Path ( ) ; Text text = new Text ( " " , 0 , 0 ) ; assertValidValue ( grobNode , canvas ) ; assertValidValue ( grobNode , image ) ; assertValidValue ( grobNode , path ) ; assertValidValue ( grobNode , text ) ; assertValidValue ( canvasNode , canvas ) ; assertInvalidValue ( canvasNode , image ) ; assertInvalidValue ( canvasNode , path ) ; assertInvalidValue ( canvasNode , text ) ; assertInvalidValue ( imageNode , canvas ) ; assertValidValue ( imageNode , image ) ; assertInvalidValue ( imageNode , path ) ; assertInvalidValue ( imageNode , text ) ; assertInvalidValue ( pathNode , canvas ) ; assertInvalidValue ( pathNode , image ) ; assertValidValue ( pathNode , path ) ; assertInvalidValue ( pathNode , text ) ; assertInvalidValue ( textNode , canvas ) ; assertInvalidValue ( textNode , image ) ; assertInvalidValue ( textNode , path ) ; assertValidValue ( textNode , text ) ; 
public void testAccessors ( ) { Node rect1 = rectNode . newInstance ( testLibrary , " rect1 " ) ; Node trans1 = translateNode . newInstance ( testLibrary , " trans1 " ) ; Port pPolygon = trans1 . getPort ( " polygon " ) ; assertFalse ( pPolygon . isConnected ( ) ) ; pPolygon . connect ( rect1 ) ; Connection c = pPolygon . getConnections ( ) . get ( 0 ) ; assertNotNull ( c ) ; assertEquals ( rect1 , c . getOutputNode ( ) ) ; assertEquals ( trans1 , c . getInputNode ( ) ) ; assertEquals ( pPolygon , c . getInput ( ) ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2.translate(getWidth() / 2, getHeight() / 2); context.getCanvas().draw(g2); } 
public void actionPerformed ( ActionEvent actionEvent ) { Clear out feedback area context.resetContext(); context.getCanvas().clear(); feedbackArea.setText(""); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); interpreter.set("g", context); interpreter.set("Path", nodebox.graphics.Path.class); interpreter.set("Canvas", nodebox.graphics.Canvas.class); interpreter.set("Color", nodebox.graphics.Color.class); interpreter.set("GraphicsContext", CanvasContext.class); interpreter.set("Grob", nodebox.graphics.Grob.class); interpreter.set("Path", Path.class); interpreter.set("Geometry", Geometry.class); interpreter.set("Image", nodebox.graphics.Image.class); interpreter.set("NodeBoxError", nodebox.graphics.NodeBoxError.class); interpreter.set("PathElement", nodebox.graphics.PathElement.class); interpreter.set("Point", nodebox.graphics.Point.class); interpreter.set("Rect", nodebox.graphics.Rect.class); interpreter.set("Text", nodebox.graphics.Text.class); interpreter.set("Transform", nodebox.graphics.Transform.class); interpreter.set("LEFT", Text.Align.LEFT); interpreter.set("RIGHT", Text.Align.RIGHT); interpreter.set("CENTER", Text.Align.CENTER); interpreter.set("JUSTIFY", Text.Align.JUSTIFY); interpreter.setOut(outputStream); interpreter.setErr(errorStream); Exception pythonException = null; String pythonCode = codeArea.getText(); pythonCode = "_g = globals()for n in dir(g): _g[n] = getattr(g, n)" + pythonCode; try { interpreter.exec(pythonCode); } catch (Exception e) { pythonException = e; logger.log(Level.INFO, "Error on exec", e); } String os = outputStream.toString(); if (os.length() > 0) addString(os); if (!os.endsWith("")) addString(""); if (pythonException != null) addString(pythonException.toString() + ""); viewer.repaint(); } 
public void resetContext ( ) { colorMode = Color . Mode . RGB ; colorRange = 1f ; fillColor = new Color ( ) ; strokeColor = null ; strokeWidth = 1f ; path = null ; autoClosePath = true ; transformMode = Transform . Mode . CENTER ; transform = new Transform ( ) ; transformStack = new ArrayList < Transform > ( ) ; fontName = " Helvetica " ; fontSize = 24 ; lineHeight = 1.2f ; align = Text . Align . LEFT ; } 
public RectMode rectmode ( RectMode m ) { return rectMode = m ; } 
public RectMode rectmode ( String m ) { try { RectMode newMode = RectMode . valueOf ( m . toUpperCase ( ) ) ; 
public RectMode rectmode ( int m ) { try { RectMode newMode = RectMode . values ( ) [ m ] ; 
public Path rect ( Rect r ) { return rect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , true ) ; } 
public Path rect ( Rect r , boolean draw ) { return rect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , draw ) ; } 
public Path rect ( float x , float y , float width , float height ) { return rect ( x , y , width , height , true ) ; } 
public Path rect ( float x , float y , float width , float height , boolean draw ) { Path p = new Path ( ) ; switch ( rectMode ) { case CENTER : p . rect ( x , y , width , height ) ; break ; case CORNER : p . cornerRect ( x , y , width , height ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path rect ( Rect r , float roundness ) { return rect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , roundness , roundness , true ) ; } 
public Path rect ( Rect r , float roundness , boolean draw ) { return rect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , roundness , roundness , draw ) ; } 
public Path rect ( float x , float y , float width , float height , float roundness ) { return rect ( x , y , width , height , roundness , roundness , true ) ; } 
public Path rect ( float x , float y , float width , float height , float roundness , boolean draw ) { return rect ( x , y , width , height , roundness , roundness , draw ) ; } 
public Path rect ( float x , float y , float width , float height , float rx , float ry ) { return rect ( x , y , width , height , rx , ry , true ) ; } 
public Path rect ( float x , float y , float width , float height , float rx , float ry , boolean draw ) { Path p = new Path ( ) ; switch ( rectMode ) { case CENTER : p . rect ( x , y , width , height , rx , ry ) ; break ; case CORNER : p . cornerRect ( x , y , width , height , rx , ry ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public EllipseMode ellipsemode ( ) { return ellipseMode ; } 
public EllipseMode ellipsemode ( EllipseMode m ) { return ellipseMode = m ; } 
public EllipseMode ellipsemode ( String m ) { try { EllipseMode newMode = EllipseMode . valueOf ( m . toUpperCase ( ) ) ; 
public EllipseMode ellipsemode ( int m ) { try { EllipseMode newMode = EllipseMode . values ( ) [ m ] ; 
public Path oval ( float x , float y , float width , float height ) { TODO: Deprecation warning return ellipse(x, y, width, height, true); } 
public Path oval ( float x , float y , float width , float height , boolean draw ) { TODO: Deprecation warning return ellipse(x, y, width, height, draw); } 
public Path ellipse ( float x , float y , float width , float height ) { return ellipse ( x , y , width , height , true ) ; } 
public Path ellipse ( float x , float y , float width , float height , boolean draw ) { Path p = new Path ( ) ; switch ( ellipseMode ) { case CENTER : p . ellipse ( x , y , width , height ) ; break ; case CORNER : p . cornerEllipse ( x , y , width , height ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path line ( float x1 , float y1 , float x2 , float y2 ) { return line ( x1 , y1 , x2 , y2 , true ) ; } 
public Path line ( float x1 , float y1 , float x2 , float y2 , boolean draw ) { Path p = new Path ( ) ; p . line ( x1 , y1 , x2 , y2 ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path star ( float cx , float cy ) { return star ( cx , cy , 20 , 100 , 50 , true ) ; } 
public Path star ( float cx , float cy , int points ) { return star ( cx , cy , points , 100 , 50 , true ) ; } 
public Path star ( float cx , float cy , int points , float outer ) { return star ( cx , cy , points , outer , 50 , true ) ; } 
public Path star ( float cx , float cy , int points , float outer , float inner ) { return star ( cx , cy , points , outer , inner , true ) ; } 
public Path star ( float cx , float cy , int points , float outer , float inner , boolean draw ) { float PI = ( float ) Math . PI ; Path p = new Path ( ) ; p . moveto ( cx , cy + outer ) ; for ( int i = 1 ; i < points * 2 ; i + + ) { float angle = i * PI / points ; float x = ( float ) Math . sin ( angle ) ; float y = ( float ) Math . cos ( angle ) ; float radius = i % 2 = = 0 ? outer : inner ; x + = cx + radius * x ; y + = cy + radius * y ; p . lineto ( x , y ) ; } p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path arrow ( float x , float y ) { return arrow ( x , y , 100 , ArrowType . NORMAL , true ) ; } 
public Path arrow ( float x , float y , ArrowType type ) { return arrow ( x , y , 100 , type , true ) ; } 
public Path arrow ( float x , float y , String type ) { return arrow ( x , y , 100 , type , true ) ; } 
public Path arrow ( float x , float y , int type ) { return arrow ( x , y , 100 , type , true ) ; } 
public Path arrow ( float x , float y , float width ) { return arrow ( x , y , width , NORMAL , true ) ; } 
public Path arrow ( float x , float y , float width , boolean draw ) { return arrow ( x , y , width , NORMAL , draw ) ; } 
public Path arrow ( float x , float y , float width , ArrowType type ) { return arrow ( x , y , width , type , true ) ; } 
public Path arrow ( float x , float y , float width , String type ) { return arrow ( x , y , width , type , true ) ; } 
public Path arrow ( float x , float y , float width , int type ) { return arrow ( x , y , width , type , true ) ; } 
public Path arrow ( float x , float y , float width , String type , boolean draw ) { try { ArrowType arrowType = ArrowType . valueOf ( type . toUpperCase ( ) ) ; 
public Path arrow ( float x , float y , float width , int type , boolean draw ) { try { ArrowType arrowType = ArrowType . values ( ) [ type ] ; 
public Path arrow ( float x , float y , float width , ArrowType type , boolean draw ) { if ( type = = ArrowType . NORMAL ) return arrowNormal ( x , y , width , draw ) ; 
private Path arrowNormal ( float x , float y , float width , boolean draw ) { float head = width * .4f ; float tail = width * .2f ; Path p = new Path ( ) ; p . moveto ( x , y ) ; p . lineto ( x - head , y + head ) ; p . lineto ( x - head , y + tail ) ; p . lineto ( x - width , y + tail ) ; p . lineto ( x - width , y - tail ) ; p . lineto ( x - head , y - tail ) ; p . lineto ( x - head , y - head ) ; p . lineto ( x , y ) ; p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
private Path arrowFortyFive ( float x , float y , float width , boolean draw ) { float head = .3f ; float tail = 1 + head ; Path p = new Path ( ) ; p . moveto ( x , y ) ; p . lineto ( x , y + width * ( 1 - head ) ) ; p . lineto ( x - width * head , y + width ) ; p . lineto ( x - width * head , y + width * tail * .4f ) ; p . lineto ( x - width * tail * .6f , y + width ) ; p . lineto ( x - width , y + width * tail * .6f ) ; p . lineto ( x - width * tail * .4f , y + width * head ) ; p . lineto ( x - width , y + width * head ) ; p . lineto ( x - width * ( 1 - head ) , y ) ; p . lineto ( x , y ) ; p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path endpath ( boolean draw ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginpath() first. " ) ; if ( autoClosePath ) closepath ( ) ; Path p = path ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; Initialize a new path path = null; pathClosed = false; return p; } 
public void drawpath ( Path path ) { inheritFromContext ( path ) ; addPath ( path ) ; } 
public void drawpath ( Iterable < Point > points ) { Path path = new Path ( ) ; for ( Point pt : points ) { path . addPoint ( pt ) ; } inheritFromContext ( path ) ; addPath ( path ) ; } 
public Path findpath ( List < Point > points , float curvature ) { Path path = Path . findPath ( points , curvature ) ; inheritFromContext ( path ) ; addPath ( path ) ; return path ; } 
public Transform . Mode transform ( ) { return transformMode ; } 
public Transform . Mode transform ( Transform . Mode mode ) { return transformMode = mode ; } 
public Transform . Mode transform ( String mode ) { try { Transform . Mode newMode = Transform . Mode . valueOf ( mode . toUpperCase ( ) ) ; 
public Transform . Mode transform ( int mode ) { try { Transform . Mode newMode = Transform . Mode . values ( ) [ mode ] ; 
public Color . Mode colormode ( Color . Mode mode ) { return colormode ( mode , null ) ; } 
public Color . Mode colormode ( Color . Mode mode , Float range ) { if ( range ! = null ) colorRange = range ; return colorMode = mode ; } 
public Color . Mode colormode ( String mode ) { return colormode ( mode , null ) ; } 
public Color . Mode colormode ( String mode , Float range ) { try { Color . Mode newMode = Color . Mode . valueOf ( mode . toUpperCase ( ) ) ; 
public Color . Mode colormode ( int mode ) { return colormode ( mode , null ) ; } 
public Color . Mode colormode ( int mode , Float range ) { try { Color . Mode newMode = Color . Mode . values ( ) [ mode ] ; 
public float colorrange ( float range ) { return colorRange = range ; } 
public Color color ( float x ) { float nx = normalize ( x ) ; return new Color ( nx , nx , nx ) ; } 
public Color color ( float x , float y ) { float nx = normalize ( x ) ; return new Color ( nx , nx , nx , normalize ( y ) ) ; } 
public Color color ( float x , float y , float z ) { return new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , colormode ( ) ) ; } 
public Color color ( float x , float y , float z , float a ) { return new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , normalize ( a ) , colormode ( ) ) ; } 
public Color fill ( float x ) { float nx = normalize ( x ) ; return fillColor = new Color ( nx , nx , nx ) ; } 
public Color fill ( float x , float y ) { float nx = normalize ( x ) ; return fillColor = new Color ( nx , nx , nx , normalize ( y ) ) ; } 
public Color fill ( float x , float y , float z ) { return fillColor = new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , colormode ( ) ) ; } 
public Color fill ( float x , float y , float z , float a ) { return fillColor = new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , normalize ( a ) , colormode ( ) ) ; } 
public Color stroke ( float x ) { float nx = normalize ( x ) ; return strokeColor = new Color ( nx , nx , nx ) ; } 
public Color stroke ( float x , float y ) { float nx = normalize ( x ) ; return strokeColor = new Color ( nx , nx , nx , normalize ( y ) ) ; } 
public Color stroke ( float x , float y , float z ) { return strokeColor = new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , colormode ( ) ) ; } 
public Color stroke ( float x , float y , float z , float a ) { return strokeColor = new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , normalize ( a ) , colormode ( ) ) ; } 
public Image image ( String path , float x , float y ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , float x , float y , Float width ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , float x , float y , Float width , Float height ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Size imagesize ( String path ) { throw new RuntimeException ( " 'imagesize' is not applicable to this type of GrqphicsContext. " ) ; } 
public Text . Align align ( Text . Align align ) { return this . align = align ; } 
public Text . Align align ( String align ) { try { Text . Align newAlign = Text . Align . valueOf ( align . toUpperCase ( ) ) ; 
public Text . Align align ( int align ) { try { Text . Align newAlign = Text . Align . values ( ) [ align ] ; 
public Text text ( String text , float x , float y ) { return text ( text , x , y , 0 , 0 , true ) ; } 
public Text text ( String text , float x , float y , float width ) { return text ( text , x , y , width , 0 , true ) ; } 
public Text text ( String text , float x , float y , float width , float height ) { return text ( text , x , y , width , height , true ) ; } 
public Text text ( String text , float x , float y , float width , float height , boolean draw ) { Text = new Text ( text , x , y , width , height ) ; inheritFromContext ( ) ; if ( draw ) addText ( ) ; return ; } 
public Path textpath ( String text , float x , float y , float width , float height ) { Text = new Text ( text , x , y , width , height ) ; return . getPath ( ) ; } 
public void var ( String name , VarType type ) { var ( name , type , null , null , null ) ; } 
public void var ( String name , String type ) { var ( name , type , null , null , null ) ; } 
public void var ( String name , int type ) { var ( name , type , null , null , null ) ; } 
public void var ( String name , VarType type , Object value ) { var ( name , type , value , null , null ) ; } 
public void var ( String name , String type , Object value ) { var ( name , type , value , null , null ) ; } 
public void var ( String name , int type , Object value ) { var ( name , type , value , null , null ) ; } 
public void var ( String name , String type , Object value , Float min , Float max ) { try { var ( name , VarType . valueOf ( type . toUpperCase ( ) ) , value , min , max ) ; 
public void var ( String name , int type , Object value , Float min , Float max ) { try { var ( name , VarType . values ( ) [ type ] , value , min , max ) ; 
protected float normalize ( float v ) { Bring the color into the 0-1 scale for the current colorrange if (colorRange == 1f) return v; return v / colorRange; 
public Object choice ( List objects ) { if ( objects = = null | | objects . isEmpty ( ) ) return null ; return objects . get ( ( int ) random ( objects . size ( ) - 1 ) ) ; } 
public Iterator < Point > grid ( int columns , int rows ) { return grid ( columns , rows , 1 , 1 ) ; } 
public Iterator < Point > grid ( float columns , float rows ) { return grid ( Math . round ( columns ) , Math . round ( rows ) , 1 , 1 ) ; } 
public Iterator < Point > grid ( float columns , float rows , double columnSize , double rowSize ) { return grid ( Math . round ( columns ) , Math . round ( rows ) , columnSize , rowSize ) ; } 
public Iterator < Point > grid ( final int columns , final int rows , final double columnSize , final double rowSize ) { return new Iterator < Point > ( ) { int x = 0 ; 
public boolean hasNext ( ) { return y < rows ; } 
public Point next ( ) { Point pt = new Point ( ( float ) ( x * columnSize ) , ( float ) ( y * rowSize ) ) ; x + + ; if ( x > = columns ) { x = 0 ; y + + ; } return pt ; } 
public void draw ( Grob g ) { if ( g instanceof Path ) { addPath ( ( Path ) g ) ; 
protected abstract void addPath ( Path p ) ; protected abstract void addText ( Text ) ; protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; Rect r = p . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform = new Transform ( ) ; . translate ( dx , dy ) ; . append ( transform ) ; . translate ( - dx , - dy ) ; . map ( p . getPoints ( ) ) ; } else { transform . map ( p . getPoints ( ) ) ; } } protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; Rect r = . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform trans = new Transform ( ) ; trans . translate ( dx , dy ) ; trans . append ( transform ) ; trans . translate ( - dx , - dy ) ; . setTransform ( trans ) ; } else { . setTransform ( transform ) ; } } } 
protected abstract void addText ( Text ) ; protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; Rect r = p . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform = new Transform ( ) ; . translate ( dx , dy ) ; . append ( transform ) ; . translate ( - dx , - dy ) ; . map ( p . getPoints ( ) ) ; } else { transform . map ( p . getPoints ( ) ) ; } } protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; Rect r = . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform trans = new Transform ( ) ; trans . translate ( dx , dy ) ; trans . append ( transform ) ; trans . translate ( - dx , - dy ) ; . setTransform ( trans ) ; } else { . setTransform ( transform ) ; } } } 
protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; Rect r = p . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform = new Transform ( ) ; 
protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; Rect r = . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform trans = new Transform ( ) ; 
public void draw ( Graphics2D g ) { if ( background ! = null ) { g . setColor ( background . getAwtColor ( ) ) ; g . fillRect ( 0 , 0 , Math . round ( width ) , Math . round ( height ) ) ; } Rectangle clip = g.getClipBounds(); int clipwidth = clip != null && width > clip.width ? clip.width : (int) height; int clipheight = clip != null && height > clip.height ? clip.height : (int) width; g.setClip(clip != null ? clip.x : 0, clip != null ? clip.y : 0, clipwidth, clipheight); for (Grob grob : items) { grob.draw(g); 
public void resetContext ( boolean resetBackground ) { super . resetContext ( ) ; if ( resetBackground ) canvas . setBackground ( new Color ( 1 , 1 , 1 ) ) ; 
public ImageMode imagemode ( ImageMode m ) { return imageMode = m ; } 
public Color background ( float x ) { float nx = normalize ( x ) ; return canvas . setBackground ( new Color ( nx , nx , nx ) ) ; } 
public Color background ( float x , float y ) { float nx = normalize ( x ) ; return canvas . setBackground ( new Color ( nx , nx , nx , normalize ( y ) ) ) ; } 
public Color background ( float x , float y , float z ) { return canvas . setBackground ( new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , colormode ( ) ) ) ; } 
public Color background ( float x , float y , float z , float a ) { return canvas . setBackground ( new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , normalize ( a ) , colormode ( ) ) ) ; } 
public Image image ( String path , float x , float y ) { return image ( path , x , y , null , null , 1.0f , true ) ; } 
public Image image ( String path , float x , float y , Float width ) { return image ( path , x , y , width , null , 1.0f , true ) ; } 
public Image image ( String path , float x , float y , Float width , Float height ) { return image ( path , x , y , width , height , 1.0f , true ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha ) { return image ( path , x , y , width , height , alpha , true ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) { return image ( path , x , y , width , height , 1.0f , draw ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) { Image img = new Image ( path ) ; if ( width ! = null ) img . setWidth ( width ) ; if ( height ! = null ) img . setHeight ( height ) ; switch ( imageMode ) { case CORNER : float w = img . getWidth ( ) ; float h = img . getHeight ( ) ; img . setX ( x + w / 2 ) ; img . setY ( y + h / 2 ) ; break ; case CENTER : img . setX ( x ) ; img . setY ( y ) ; } inheritFromContext ( img ) ; if ( alpha ! = 1.0 ) img . setAlpha ( alpha ) ; if ( draw ) canvas . add ( img ) ; return img ; } 
private void inheritFromContext ( Image i ) { if ( transformMode = = Transform . Mode . CENTER ) { Transform = new Transform ( ) ; 
private void updateRGB ( ) { if ( s = = 0 ) this . r = this . g = this . b = this . v ; 
private void updateHSB ( ) { double h = 0 ; double s = 0 ; double v = Math . max ( Math . max ( r , g ) , b ) ; double d = v - Math . min ( Math . min ( r , g ) , b ) ; if ( v ! = 0 ) s = d / v ; if ( s ! = 0 ) { if ( r = = v ) h = 0 + ( g - b ) / d ; else if ( g = = v ) h = 2 + ( b - r ) / d ; else h = 4 + ( r - g ) / d ; } h = h * ( float ) ( 60.0 / 360 ) ; if ( h < 0 ) h = h + 1 ; this . h = h ; this . s = s ; this . v = v ; } 
protected void addText ( Text ) { addPath ( . getPath ( ) ) ; } 
public void skew ( float skew ) ; public void skew ( float kx , float ky ) ; public String outputmode ( ) ; public String outputmode ( String mode ) ; public Color . Mode colormode ( ) ; public Color . Mode colormode ( Color . Mode mode ) ; public Color . Mode colormode ( Color . Mode mode , Float range ) ; public Color . Mode colormode ( String mode ) ; public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void skew ( float kx , float ky ) ; public String outputmode ( ) ; public String outputmode ( String mode ) ; public Color . Mode colormode ( ) ; public Color . Mode colormode ( Color . Mode mode ) ; public Color . Mode colormode ( Color . Mode mode , Float range ) ; public Color . Mode colormode ( String mode ) ; public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String outputmode ( ) ; public String outputmode ( String mode ) ; public Color . Mode colormode ( ) ; public Color . Mode colormode ( Color . Mode mode ) ; public Color . Mode colormode ( Color . Mode mode , Float range ) ; public Color . Mode colormode ( String mode ) ; public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String outputmode ( String mode ) ; public Color . Mode colormode ( ) ; public Color . Mode colormode ( Color . Mode mode ) ; public Color . Mode colormode ( Color . Mode mode , Float range ) ; public Color . Mode colormode ( String mode ) ; public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( ) ; public Color . Mode colormode ( Color . Mode mode ) ; public Color . Mode colormode ( Color . Mode mode , Float range ) ; public Color . Mode colormode ( String mode ) ; public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( Color . Mode mode ) ; public Color . Mode colormode ( Color . Mode mode , Float range ) ; public Color . Mode colormode ( String mode ) ; public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( Color . Mode mode , Float range ) ; public Color . Mode colormode ( String mode ) ; public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( String mode ) ; public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nofill ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( String path ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
protected void setupTransform ( Graphics2D g ) { saveTransform ( g ) ; AffineTransform trans = g . getTransform ( ) ; trans . concatenate ( getTransform ( ) . getAffineTransform ( ) ) ; g . setTransform ( trans ) ; } 
public void cornerRect ( float x , float y , float width , float height ) { addPoint ( x , y ) ; addPoint ( x + width , y ) ; addPoint ( x + width , y + height ) ; addPoint ( x , y + height ) ; close ( ) ; } 
public void cornerRect ( Rect r , float roundness ) { roundedRect ( Rect . corneredRect ( r ) , roundness ) ; } 
public void cornerRect ( Rect r , float rx , float ry ) { roundedRect ( Rect . corneredRect ( r ) , rx , ry ) ; } 
public void cornerRect ( float cx , float cy , float width , float height , float r ) { roundedRect ( Rect . corneredRect ( cx , cy , width , height ) , r ) ; } 
public void cornerRect ( float cx , float cy , float width , float height , float rx , float ry ) { roundedRect ( Rect . corneredRect ( cx , cy , width , height ) , rx , ry ) ; } 
public void roundedRect ( float cx , float cy , float width , float height , float rx , float ry ) { float halfWidth = width / 2f ; float halfHeight = height / 2f ; float dx = rx ; float dy = ry ; float left = cx - halfWidth ; float right = cx + halfWidth ; float top = cy - halfHeight ; float bottom = cy + halfHeight ; rx/ry cannot be greater than half of the width of the rectangle (required by SVG spec) dx = Math.min(dx, width * 0.5f); dy = Math.min(dy, height * 0.5f); moveto(left + dx, top); if (dx < width * 0.5) lineto(right - rx, top); curveto(right - dx * ONE_MINUS_QUARTER, top, right, top + dy * ONE_MINUS_QUARTER, right, top + dy); if (dy < height * 0.5) lineto(right, bottom - dy); curveto(right, bottom - dy * ONE_MINUS_QUARTER, right - dx * ONE_MINUS_QUARTER, bottom, right - dx, bottom); if (dx < width * 0.5) lineto(left + dx, bottom); curveto(left + dx * ONE_MINUS_QUARTER, bottom, left, bottom - dy * ONE_MINUS_QUARTER, left, bottom - dy); if (dy < height * 0.5) lineto(left, top + dy); curveto(left, top + dy * ONE_MINUS_QUARTER, left + dx * ONE_MINUS_QUARTER, top, left + dx, top); close(); } 
public void cornerEllipse ( float x , float y , float width , float height ) { Ellipse2D . Float e = new Ellipse2D . Float ( x , y , width , height ) ; extend ( e ) ; } 
public static Path findPath ( java . util . List < Point > points ) { Point [ ] pts = new Point [ points . size ( ) ] ; points . toArray ( pts ) ; return findPath ( pts , 1 ) ; } 
public static Path findPath ( java . util . List < Point > points , float curvature ) { Point [ ] pts = new Point [ points . size ( ) ] ; points . toArray ( pts ) ; return findPath ( pts , curvature ) ; } 
public static Path findPath ( Point [ ] points ) { return findPath ( points , 1 ) ; } 
public static Path findPath ( Point [ ] points , float curvature ) { if ( points . length = = 0 ) return null ; if ( points . length = = 1 ) { Path path = new Path ( ) ; path . moveto ( points [ 0 ] . x , points [ 0 ] . y ) ; return path ; } if ( points . length = = 2 ) { Path path = new Path ( ) ; path . moveto ( points [ 0 ] . x , points [ 0 ] . y ) ; path . lineto ( points [ 1 ] . x , points [ 1 ] . y ) ; return path ; } Zero curvature means straight lines. curvature = Math.max(0, Math.min(1, curvature)); if (curvature == 0) { Path path = new Path(); path.moveto(points[0].x, points[0].y); for (int i = 0; i < points.length; i++) path.lineto(points[i].x, points[i].y); return path; } curvature = (float) (4 + (1.0-curvature)*40); HashMap<Integer, Float> dx, dy, bi, ax, ay; dx = new HashMap<Integer, Float>(); dy = new HashMap<Integer, Float>(); bi = new HashMap<Integer, Float>(); ax = new HashMap<Integer, Float>(); ay = new HashMap<Integer, Float>(); dx.put(0, 0f); dx.put(points.length-1, 0f); dy.put(0, 0f); dy.put(points.length-1, 0f); bi.put(1, -0.25f); ax.put(1, (points[2].x-points[0].x-dx.get(0)) / 4); ay.put(1, (points[2].y-points[0].y-dy.get(0)) / 4); for (int i = 2; i < points.length-1; i++) { bi.put(i, -1 / (curvature + bi.get(i-1))); ax.put(i, -(points[i+1].x-points[i-1].x-ax.get(i-1)) * bi.get(i)); ay.put(i, -(points[i+1].y-points[i-1].y-ay.get(i-1)) * bi.get(i)); } for (int i = points.length - 2; i >= 1; i--) { dx.put(i, ax.get(i) + dx.get(i+1) * bi.get(i)); dy.put(i, ay.get(i) + dy.get(i+1) * bi.get(i)); } Path path = new Path(); path.moveto(points[0].x, points[0].y); for (int i = 0; i < points.length-1; i++) { path.curveto(points[i].x + dx.get(i), points[i].y + dy.get(i), points[i+1].x - dx.get(i+1), points[i+1].y - dy.get(i+1), points[i+1].x, points[i+1].y); } return path; } 
public Iterator < Point > iterator ( ) { return getPoints ( ) . iterator ( ) ; } 
public Iterator < Float > iterator ( ) { return new Iterator < Float > ( ) { int pos = 0 ; 
public boolean hasNext ( ) { return pos < 2 ; } 
public Float next ( ) { if ( pos > = 2 ) throw new NoSuchElementException ( " A point has only two elements. " ) ; return ( pos + + ) = = 0 ? x : y ; } 
public static Rect centeredRect ( Rect r ) { return centeredRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) ) ; } 
public static Rect corneredRect ( float cx , float cy , float width , float height ) { return new Rect ( cx + width / 2 , cy + height / 2 , width , height ) ; } 
public static Rect corneredRect ( Rect r ) { return corneredRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) ) ; } 
public boolean hasNext ( ) { if ( currentMeasurer . getPosition ( ) < currentText . length ( ) ) return true ; 
public void skew ( double kx , double ky ) { kx = Math . PI * kx / 180.0 ; ky = Math . PI * ky / 180.0 ; affineTransform . concatenate ( new AffineTransform ( 1 , Math . tan ( ky ) , - Math . tan ( kx ) , 1 , 0 , 0 ) ) ; } 
public void update ( ) { } Utility methods protected void drawDot(GraphicsContext ctx, float x, float y) { ctx.rectmode(GraphicsContext.RectMode.CENTER); ctx.fill(HANDLE_COLOR); ctx.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected void drawDot(Path p, float x, float y) { p.rect(x, y, HANDLE_SIZE, HANDLE_SIZE); } protected Rect createHitRectangle(double x, double y) { int ix = (int) x; int iy = (int) y; return new Rect(ix - HALF_HANDLE_SIZE, iy - HALF_HANDLE_SIZE, HANDLE_SIZE, HANDLE_SIZE); }} 
protected void drawDot ( GraphicsContext ctx , float x , float y ) { ctx . rectmode ( GraphicsContext . RectMode . CENTER ) ; ctx . fill ( HANDLE_COLOR ) ; ctx . rect ( x , y , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void draw ( GraphicsContext ctx ) { float cx = node . asFloat ( xName ) ; float cy = node . asFloat ( yName ) ; float width = node . asFloat ( widthName ) ; float height = node . asFloat ( heightName ) ; float left = cx - width / 2 ; float right = cx + width / 2 ; float top = cy - height / 2 ; float bottom = cy + height / 2 ; Path cornerPath = new Path ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0 ) ; drawDot ( cornerPath , left , top ) ; drawDot ( cornerPath , right , top ) ; drawDot ( cornerPath , right , bottom ) ; drawDot ( cornerPath , left , bottom ) ; drawDot ( cornerPath , cx , cy ) ; ctx . draw ( cornerPath ) ; Path strokePath = new Path ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . rect ( cx , cy , width , height ) ; ctx . draw ( strokePath ) ; } 
public void draw ( GraphicsContext ctx ) { float cx = getCenterX ( ) ; float cy = getCenterY ( ) ; ctx . ellipsemode ( GraphicsContext . EllipseMode . CENTER ) ; ctx . nofill ( ) ; ctx . stroke ( HANDLE_COLOR ) ; ctx . ellipse ( cx , cy , handleLength * 2 , handleLength * 2 ) ; double [ ] xy ; if ( dragState = = DragState . NONE | | dragState = = DragState . HANDLE ) xy = Geometry . coordinates ( cx , cy , handleLength , node . asFloat ( angleName ) ) ; else { xy = Geometry . coordinates ( cx , cy , handleLength , pa ) ; ctx . line ( cx , cy , ( float ) xy [ 0 ] , ( float ) xy [ 1 ] ) ; xy = Geometry . coordinates ( cx , cy , handleLength , ca ) ; } float x = ( float ) xy [ 0 ] ; float y = ( float ) xy [ 1 ] ; ctx . line ( cx , cy , x , y ) ; ctx . fill ( 1 ) ; ctx . ellipse ( x , y , 6 , 6 ) ; if ( dragState = = DragState . HANDLE ) { xy = Geometry . coordinates ( cx , cy , handleLength , oa ) ; 
public void draw ( GraphicsContext ctx ) { ctx . nofill ( ) ; ctx . stroke ( HANDLE_COLOR ) ; float halfWidth = handleWidth / 2 ; float halfHeight = handleHeight / 2 ; ctx . rectmode ( GraphicsContext . RectMode . CENTER ) ; ctx . rect ( 0 , 0 , handleWidth , handleHeight ) ; drawDot ( ctx , - halfWidth , - halfHeight ) ; drawDot ( ctx , halfWidth , - halfHeight ) ; drawDot ( ctx , - halfWidth , halfHeight ) ; drawDot ( ctx , halfWidth , halfHeight ) ; } 
public void draw ( GraphicsContext ctx ) { float x = node . asFloat ( txName ) ; float y = node . asFloat ( tyName ) ; ctx . rectmode ( GraphicsContext . RectMode . CENTER ) ; Path p = new Path ( ) ; p . setFillColor ( HANDLE_COLOR ) ; ctx . stroke ( HANDLE_COLOR ) ; p . setStrokeColor ( null ) ; ctx . nofill ( ) ; drawDot ( ctx , x , y ) ; if ( dragState = = DragState . NONE ) { Horizontal and vertical direction lines. ctx.line(x, y, x + handleLength, y); ctx.line(x, y, x, y + handleLength); Vertical arrow p.moveto(x, y + handleLength + 3); p.lineto(x - 5, y + handleLength - 3); p.lineto(x + 5, y + handleLength - 3); Horizontal arrow p.moveto(x + handleLength + 3, y); p.lineto(x + handleLength - 3, y - 5); p.lineto(x + handleLength - 3, y + 5); } else if (dragState == DragState.CENTER) { ctx.line(px, py, x, y); drawDot(ctx, x, y); } else if (dragState == DragState.HORIZONTAL) { float x0, x1; ctx.line(px - handleLength, y, x + handleLength, y); if (x + handleLength > px - handleLength) { arrow points right x0 = x + handleLength + 3; x1 = x + handleLength - 3; } else { arrow points left x0 = x + handleLength - 3; x1 = x + handleLength + 3; } p.moveto(x0, y); p.lineto(x1, y - 5); p.lineto(x1, y + 5); } else if (dragState == DragState.VERTICAL) { float y0, y1; ctx.line(x, py - handleLength, x, y + handleLength); if (y + handleLength > py - handleLength) { arrow points down y0 = y + handleLength + 3; y1 = y + handleLength - 3; } else { arrow points up y0 = y + handleLength - 3; y1 = y + handleLength + 3; } p.moveto(x, y0); p.lineto(x - 5, y1); p.lineto(x + 5, y1); } ctx.nostroke(); ctx.draw(p); } 
public Object evaluate ( ) throws ExpressionError { return evaluate ( new ProcessingContext ( parameter . getNode ( ) ) ) ; } 
public void update ( ) throws ProcessingError { update ( new ProcessingContext ( this ) ) ; } 
public void update ( ProcessingContext ctx ) throws ProcessingError { if ( ! dirty ) return ; Set the current context global. ProcessingContext.setCurrentContext(ctx); Set the current node as the one being processed. ctx.setNode(this); Update the dependencies. This might cause an exception which we don't catch, instead letting it boil up. updateDependencies(ctx); All dependencies are up-to-date. Process the node. ProcessingError pe = null; try { process(ctx); } catch (ProcessingError e) { pe = e; } Even if an error occurred the node is still marked as clean, and events are fired. Only after these steps is the error thrown. It is important to mark the node as clean so that subsequent changes to the node mark it as dirty, triggering an event. This allows you to fix the cause of the error in the node. dirty = false; getLibrary().fireNodeUpdated(this, ctx); If exception occurs, throw it. if (pe != null) throw pe; 
public Handle createHandle ( ) { NodeCode handleCode = asCode ( " _handle " ) ; if ( handleCode = = null ) return null ; TODO: Do we need the ProcessingContext in the handle or can we pass null? Object handleObj = handleCode.cook(this, new ProcessingContext(this)); if (handleObj == null) return null; if (!(handleObj instanceof Handle)) throw new AssertionError("Handle code for node " + getName() + " does not return Handle object."); return (Handle) handleObj; } 
public void update ( ProcessingContext context ) throws ExpressionError { if ( ! dirty ) return ; context . setNode ( node ) ; To avoid infinite recursion, we set dirty to false before processing any of the dependencies. If we come by this parameter again, we have already updated it. dirty = false; if (hasExpression()) { Update all dependencies. 
private void preCook ( ) { The namespace will remain bound to the interpreter. Changes to this dictionary will affect the namespace of the interpreter. PythonInterpreter interpreter = new PythonInterpreter(namespace); Immediately run the code to extract the cook(self) method. interpreter.exec("from nodebox1.graphics import Context" + "_g = globals()" + "_ctx = Context(ns=_g)" + "for n in dir(_ctx):" + " _g[n] = getattr(_ctx, n)"); PyCode code = interpreter.compile(source); code.__call__(); interpreter.exec(source); ctx = (CanvasContext) interpreter.get("_ctx").__tojava__(CanvasContext.class); try { cookFunction = (PyFunction) interpreter.get("cook"); 
public void testSize ( ) { CanvasContext ctx = new CanvasContext ( ) ; ctx . size ( 200 , 300 ) ; assertEquals ( 200 f , ctx . getWIDTH ( ) ) ; assertEquals ( 300 f , ctx . getHeight ( ) ) ; assertEquals ( 200 f , ctx . getCanvas ( ) . getWidth ( ) ) ; assertEquals ( 300 f , ctx . getCanvas ( ) . getHeight ( ) ) ; } 
public void testInheritFromContext ( ) { CanvasContext ctx = new CanvasContext ( ) ; Color c = new Color ( ) ; assertEquals ( c , ctx . fill ( ) ) ; ctx . rect ( 0 , 0 , 100 , 100 ) ; Path p = ( Path ) ctx . getCanvas ( ) . getItems ( ) . get ( 0 ) ; assertEquals ( c , p . getFillColor ( ) ) ; Color red = new Color ( 1 , 0 , 0 ) ; ctx . fill ( red ) ; ctx . align ( Text . Align . RIGHT ) ; Text = ctx . text ( " hello " , 20 , 20 ) ; assertEquals ( red , . getFillColor ( ) ) ; assertEquals ( Text . Align . RIGHT , . getAlign ( ) ) ; } 
public void testGrid ( ) { CanvasContext ctx = new CanvasContext ( ) ; Iterator < Point > points = ctx . grid ( 2 , 3 , 3 , 5 ) ; assertNextPoint ( points , 0 , 0 ) ; assertNextPoint ( points , 3 , 0 ) ; assertNextPoint ( points , 0 , 5 ) ; assertNextPoint ( points , 3 , 5 ) ; assertNextPoint ( points , 0 , 10 ) ; assertNextPoint ( points , 3 , 10 ) ; assertFalse ( points . hasNext ( ) ) ; } 
private void assertNextPoint ( Iterator < Point > points , float x , float y ) { assertTrue ( points . hasNext ( ) ) ; assertEquals ( new Point ( x , y ) , points . next ( ) ) ; } 
public void testIterator ( ) { Point pt = new Point ( 22 , 33 ) ; Iterator < Float > iter = pt . iterator ( ) ; assertEquals ( 22 f , iter . next ( ) ) ; assertEquals ( 33 f , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; try { iter . next ( ) ; 
public void assertExpressionEquals ( Object expected , Parameter p , String expression ) throws ExpressionError { We don't catch the ExpressionError but let it bubble up. p.setExpression(expression); p.update(new ProcessingContext(p.getNode())); assertEquals(expected, p.getValue()); } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; PythonUtils . initializePython ( ) ; manager = new NodeLibraryManager ( ) ; testNodes = new TestNodes ( ) ; testLibrary = new NodeLibrary ( " test " ) ; polygraphLibrary = new PolygraphLibrary ( ) ; manager . add ( testNodes ) ; manager . add ( polygraphLibrary ) ; numberNode = manager . getNode ( " testlib.number " ) ; negateNode = manager . getNode ( " testlib.negate " ) ; addNode = manager . getNode ( " testlib.add " ) ; addDirectNode = manager . getNode ( " testlib.addDirect " ) ; addConstantNode = manager . getNode ( " testlib.addConstant " ) ; multiplyNode = manager . getNode ( " testlib.multiply " ) ; multiAddNode = manager . getNode ( " testlib.multiAdd " ) ; floatNegateNode = manager . getNode ( " testlib.floatNegate " ) ; convertToUppercaseNode = manager . getNode ( " testlib.convertToUppercase " ) ; crashNode = manager . getNode ( " testlib.crash " ) ; testNetworkNode = manager . getNode ( " testlib.testnet " ) ; polygonNode = manager . getNode ( " polygraph.polygon " ) ; rectNode = manager . getNode ( " polygraph.rect " ) ; translateNode = manager . getNode ( " polygraph.translate " ) ; } 
public void testErrors ( ) { Node node1 = Node . ROOT_NODE . newInstance ( testLibrary , " node1 " ) ; Test for initialization errors. assertSnippetFails("/ hello?", null, "SyntaxError"); Change the cook function to a number. assertCodeFails("cook = 5", null, "not a function."); Cook with too many parameters. The error here is a bit backwards but correct. assertCodeFails("def cook(moe, curly, larry): pass", null, "takes exactly 3 arguments (1 given)"); Test for errors in the cook function. assertSnippetFails("1 / 0", null, "ZeroDivisionError"); assertSnippetFails("self.x", null, "'NoneType' object has no attribute 'x'"); assertSnippetFails("self.alpha", node1, "Node 'test.node1' has no parameter or port 'alpha'"); node1.addParameter("alpha", Parameter.Type.INT, 42); assertSnippetEquals(42, "self.alpha", node1); } 
public void draw ( GraphicsContext ctx ) { float x = getCenterX ( ) ; float y = getCenterY ( ) ; float radius = getRadius ( ) ; ctx . nofill ( ) ; ctx . ellipsemode ( GraphicsContext . EllipseMode . CENTER ) ; ctx . stroke ( HANDLE_COLOR ) ; ctx . ellipse ( x , y , radius * 2 , radius * 2 ) ; if ( pt ! = null ) drawDot ( ctx , pt . x , pt . y ) ; 
private nodebox . graphics . Point pointForEvent ( MouseEvent e ) { Point2D originalPoint = new Point2D . Float ( e . getX ( ) , e . getY ( ) ) ; PAffineTransform transform = getCamera ( ) . getViewTransform ( ) ; Point2D transformedPoint ; try { transformedPoint = transform . inverseTransform ( originalPoint , null ) ; } catch ( NoninvertibleTransformException ex ) { return new nodebox . graphics . Point ( 0 , 0 ) ; } Point2D offset = viewerLayer . getOffset ( ) ; double cx = - offset . getX ( ) + transformedPoint . getX ( ) ; double cy = - offset . getY ( ) + transformedPoint . getY ( ) ; double cx = -getWidth() / 2.0 + transformedPoint.getX(); double cy = -getHeight() / 2.0 + transformedPoint.getY(); return new nodebox.graphics.Point((float) cx, (float) cy); } 
public Iterator < Double > iterator ( ) { List < Double > list = new ArrayList < Double > ( ) ; list . add ( width ) ; list . add ( height ) ; return list . iterator ( ) ; } 
public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Size imagesize ( Image img ) { throw new RuntimeException ( " 'imagesize' is not applicable to this type of GrqphicsContext. " ) ; } 
public Size imagesize ( BufferedImage img ) { throw new RuntimeException ( " 'imagesize' is not applicable to this type of GrqphicsContext. " ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) { return loadImage ( new Image ( path ) , x , y , width , height , alpha , draw ) ; } 
public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) { return loadImage ( img . clone ( ) , x , y , width , height , alpha , draw ) ; } 
public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) { return loadImage ( new Image ( img ) , x , y , width , height , alpha , draw ) ; } 
private Image loadImage ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) { if ( width ! = null ) img . setWidth ( width ) ; if ( height ! = null ) img . setHeight ( height ) ; switch ( imageMode ) { case CORNER : float w = img . getWidth ( ) ; float h = img . getHeight ( ) ; img . setX ( x + w / 2 ) ; img . setY ( y + h / 2 ) ; break ; case CENTER : img . setX ( x ) ; img . setY ( y ) ; } inheritFromContext ( img ) ; if ( alpha ! = 1.0 ) img . setAlpha ( alpha ) ; if ( draw ) canvas . add ( img ) ; return img ; } 
public Size imagesize ( Image img ) { return img . getSize ( ) ; } 
public Size imagesize ( BufferedImage img ) { return new Size ( img . getWidth ( ) , img . getHeight ( ) ) ; } 
public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nofill ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public static Image fromData ( byte [ ] data ) { InputStream istream = new BufferedInputStream ( new ByteArrayInputStream ( data ) ) ; try { return new Image ( ImageIO . read ( istream ) ) ; 
public Path textpath ( String text , float x , float y , float width , float height ) { Text = new Text ( text , x , y , width , height ) ; inheritFontAttributesFromContext ( ) ; return . getPath ( ) ; } 
protected abstract void addPath ( Path p ) ; protected abstract void addText ( Text ) ; protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; Rect r = p . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform = new Transform ( ) ; . translate ( dx , dy ) ; . append ( transform ) ; . translate ( - dx , - dy ) ; . map ( p . getPoints ( ) ) ; } else { transform . map ( p . getPoints ( ) ) ; } } protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; inheritFontAttributesFromContext ( ) ; Rect r = . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform trans = new Transform ( ) ; trans . translate ( dx , dy ) ; trans . append ( transform ) ; trans . translate ( - dx , - dy ) ; . setTransform ( trans ) ; } else { . setTransform ( transform ) ; } } private void inheritFontAttributesFromContext ( Text ) { . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; } } 
protected abstract void addText ( Text ) ; protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; Rect r = p . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform = new Transform ( ) ; . translate ( dx , dy ) ; . append ( transform ) ; . translate ( - dx , - dy ) ; . map ( p . getPoints ( ) ) ; } else { transform . map ( p . getPoints ( ) ) ; } } protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; inheritFontAttributesFromContext ( ) ; Rect r = . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform trans = new Transform ( ) ; trans . translate ( dx , dy ) ; trans . append ( transform ) ; trans . translate ( - dx , - dy ) ; . setTransform ( trans ) ; } else { . setTransform ( transform ) ; } } private void inheritFontAttributesFromContext ( Text ) { . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; } } 
protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; inheritFontAttributesFromContext ( ) ; Rect r = . getBounds ( ) ; float dx = r . getX ( ) + r . getWidth ( ) / 2 ; float dy = r . getY ( ) + r . getHeight ( ) / 2 ; if ( transformMode = = Transform . Mode . CENTER ) { Transform trans = new Transform ( ) ; 
private void inheritFontAttributesFromContext ( Text ) { . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setLineHeight ( lineHeight ) ; . setAlign ( align ) ; } 
private Path createPath ( ) { Path p = new Path ( ) ; return p ; } 
public Path rect ( float x , float y , float width , float height , boolean draw ) { Path p = createPath ( ) ; switch ( rectMode ) { case CENTER : p . rect ( x , y , width , height ) ; break ; case CORNER : p . cornerRect ( x , y , width , height ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path rect ( float x , float y , float width , float height , float rx , float ry , boolean draw ) { Path p = createPath ( ) ; switch ( rectMode ) { case CENTER : p . rect ( x , y , width , height , rx , ry ) ; break ; case CORNER : p . cornerRect ( x , y , width , height , rx , ry ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path ellipse ( float x , float y , float width , float height , boolean draw ) { Path p = createPath ( ) ; switch ( ellipseMode ) { case CENTER : p . ellipse ( x , y , width , height ) ; break ; case CORNER : p . cornerEllipse ( x , y , width , height ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path line ( float x1 , float y1 , float x2 , float y2 , boolean draw ) { Path p = createPath ( ) ; p . line ( x1 , y1 , x2 , y2 ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path star ( float cx , float cy , int points , float outer , float inner , boolean draw ) { float PI = ( float ) Math . PI ; Path p = createPath ( ) ; p . moveto ( cx , cy + outer ) ; for ( int i = 1 ; i < points * 2 ; i + + ) { float angle = i * PI / points ; float x = ( float ) Math . sin ( angle ) ; float y = ( float ) Math . cos ( angle ) ; float radius = i % 2 = = 0 ? outer : inner ; x + = cx + radius * x ; y + = cy + radius * y ; p . lineto ( x , y ) ; } p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
private Path arrowNormal ( float x , float y , float width , boolean draw ) { float head = width * .4f ; float tail = width * .2f ; Path p = createPath ( ) ; p . moveto ( x , y ) ; p . lineto ( x - head , y + head ) ; p . lineto ( x - head , y + tail ) ; p . lineto ( x - width , y + tail ) ; p . lineto ( x - width , y - tail ) ; p . lineto ( x - head , y - tail ) ; p . lineto ( x - head , y - head ) ; p . lineto ( x , y ) ; p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
private Path arrowFortyFive ( float x , float y , float width , boolean draw ) { float head = .3f ; float tail = 1 + head ; Path p = createPath ( ) ; p . moveto ( x , y ) ; p . lineto ( x , y + width * ( 1 - head ) ) ; p . lineto ( x - width * head , y + width ) ; p . lineto ( x - width * head , y + width * tail * .4f ) ; p . lineto ( x - width * tail * .6f , y + width ) ; p . lineto ( x - width , y + width * tail * .6f ) ; p . lineto ( x - width * tail * .4f , y + width * head ) ; p . lineto ( x - width , y + width * head ) ; p . lineto ( x - width * ( 1 - head ) , y ) ; p . lineto ( x , y ) ; p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public void beginpath ( ) { path = createPath ( ) ; pathClosed = false ; } 
public void drawpath ( Iterable < Point > points ) { Path path = createPath ( ) ; for ( Point pt : points ) { path . addPoint ( pt ) ; } inheritFromContext ( path ) ; addPath ( path ) ; } 
public void focusLost ( FocusEvent e ) { if ( numberField . isVisible ( ) ) commitNumberField ( ) ; 
protected void setUp ( ) throws Exception { PythonUtils . initializePython ( ) ; } 
protected void setUp ( ) throws Exception { PythonUtils . initializePython ( ) ; manager = new NodeLibraryManager ( ) ; testLibrary = new NodeLibrary ( " test " ) ; TODO: manager.add(testLibrary); 
protected void setUp ( ) throws Exception { PythonUtils . initializePython ( ) ; testLibrary = new NodeLibrary ( " test " ) ; } 
public static void openURL ( String url ) { try { if ( onMac ( ) ) { 
private Path createPath ( ) { Path p = new Path ( ) ; p . setTransformDelegate ( new ContextTransformDelegate ( this ) ) ; return p ; } 
public Text text ( String text , float x , float y , float width , float height , boolean draw ) { Text = new Text ( text , x , y , width , height ) ; . setTransformDelegate ( new ContextTransformDelegate ( this ) ) ; inheritFromContext ( ) ; if ( draw ) addText ( ) ; return ; } 
public Path textpath ( String text , float x , float y , float width , float height ) { Text = new Text ( text , x , y , width , height ) ; inheritFontAttributesFromContext ( ) ; Path path = . getPath ( ) ; path . setTransformDelegate ( new ContextTransformDelegate ( this ) ) ; inheritFromContext ( path ) ; return path ; } 
protected abstract void addPath ( Path p ) ; protected abstract void addText ( Text ) ; protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; TransformDelegate d = p . getTransformDelegate ( ) ; d . transform ( p , transform , true ) ; } protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; inheritFontAttributesFromContext ( ) ; todo: check if this is sufficient. TransformDelegate d = t.getTransformDelegate(); d.transform(t, transform, true); } private void inheritFontAttributesFromContext(Text t) { t.setFontName(fontName); t.setFontSize(fontSize); t.setLineHeight(lineHeight); t.setAlign(align); }} 
protected abstract void addText ( Text ) ; protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; TransformDelegate d = p . getTransformDelegate ( ) ; d . transform ( p , transform , true ) ; } protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; inheritFontAttributesFromContext ( ) ; todo: check if this is sufficient. TransformDelegate d = t.getTransformDelegate(); d.transform(t, transform, true); } private void inheritFontAttributesFromContext(Text t) { t.setFontName(fontName); t.setFontSize(fontSize); t.setLineHeight(lineHeight); t.setAlign(align); }} 
protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; TransformDelegate d = p . getTransformDelegate ( ) ; d . transform ( p , transform , true ) ; } 
protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; inheritFontAttributesFromContext ( ) ; todo: check if this is sufficient. TransformDelegate d = t.getTransformDelegate(); d.transform(t, transform, true);/* Rect r = t.getBounds(); 
public void translate ( float tx , float ty ) { Transform = Transform . translated ( tx , ty ) ; transformDelegate . transform ( this , ) ; } 
public void rotate ( float degrees ) { Transform = Transform . rotated ( degrees ) ; transformDelegate . transform ( this , ) ; } 
public void rotateRadians ( float radians ) { Transform = Transform . rotatedRadians ( radians ) ; transformDelegate . transform ( this , ) ; } 
public void scale ( float scale ) { Transform = Transform . scaled ( scale ) ; transformDelegate . transform ( this , ) ; } 
public void scale ( float sx , float sy ) { Transform = Transform . scaled ( sx , sy ) ; transformDelegate . transform ( this , ) ; } 
public void skew ( float skew ) { Transform = Transform . skewed ( skew ) ; transformDelegate . transform ( this , ) ; } 
public void skew ( float kx , float ky ) { Transform = Transform . skewed ( kx , ky ) ; transformDelegate . transform ( this , ) ; } 
private Image loadImage ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) { if ( width ! = null ) img . setWidth ( width ) ; if ( height ! = null ) img . setHeight ( height ) ; switch ( imageMode ) { case CORNER : float w = img . getWidth ( ) ; float h = img . getHeight ( ) ; img . setX ( x + w / 2 ) ; img . setY ( y + h / 2 ) ; break ; case CENTER : img . setX ( x ) ; img . setY ( y ) ; } todo: differentiate between newly constructed objects and copies. img.setTransformDelegate(new ContextTransformDelegate(this)); inheritFromContext(img); if (alpha != 1.0) img.setAlpha(alpha); if (draw) canvas.add(img); return img; } 
protected void inheritFromContext ( Image i ) { TransformDelegate d = i . getTransformDelegate ( ) ; d . transform ( i , transform , true ) ; } } 
public void transform ( Grob g , Transform ) { transform ( g , , false ) ; } 
public void transform ( Grob g , Transform ) { g . transform ( ) ; } 
public void transform ( Grob g , Transform , boolean override ) { g . transform ( ) ; } 
public void draw ( Graphics2D g ) ; Geometric queries public boolean isEmpty(); public Rect getBounds(); Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public boolean isEmpty ( ) ; public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public void transform ( Transform ) ; Cloning public Grob clone(); void translate(float tx, float ty); void rotate(float degrees); void rotateRadians(float radians); void scale(float scale); void scale(float sx, float sy); void skew(float skew); void skew(float kx, float ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public Grob clone ( ) ; void translate ( float tx , float ty ) ; void rotate ( float degrees ) ; void rotateRadians ( float radians ) ; void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void translate ( float tx , float ty ) ; void rotate ( float degrees ) ; void rotateRadians ( float radians ) ; void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void rotate ( float degrees ) ; void rotateRadians ( float radians ) ; void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void rotateRadians ( float radians ) ; void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void scale ( float scale ) ; void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void scale ( float sx , float sy ) ; void skew ( float skew ) ; void skew ( float kx , float ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void skew ( float skew ) ; void skew ( float kx , float ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void skew ( float kx , float ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void setTransformDelegate ( TransformDelegate d ) ; TransformDelegate getTransformDelegate ( ) ; } 
public void transform ( Grob g , Transform ) ; public void transform ( Grob g , Transform , boolean override ) ; } 
public boolean exportToFile ( File file ) { Make sure the file ends with ".pdf". String fullPath = null; try { fullPath = file.getCanonicalPath(); } catch (IOException e) { throw new RuntimeException("Unable to access file " + file, e); } if (!fullPath.toLowerCase(Locale.US).endsWith(".pdf")) { fullPath = fullPath.concat(".pdf"); } file = new File(fullPath); todo: file export only works on grobs. if (activeNetwork == null || activeNetwork.getRenderedChild() == null) return false; Object outputValue = activeNetwork.getRenderedChild().getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; 
public void updateValues ( ) { nameField . setText ( parameter . getName ( ) ) ; labelField . setText ( parameter . getLabel ( ) ) ; helpTextField . setText ( parameter . getHelpText ( ) ) ; widgetBox . setSelectedItem ( getHumanizedWidget ( parameter . getWidget ( ) ) ) ; valueField . setText ( parameter . getValue ( ) . toString ( ) ) ; enableIfField . setText ( parameter . getEnableExpression ( ) ) ; Parameter . BoundingMethod boundingMethod = parameter . getBoundingMethod ( ) ; boundingMethodBox . setSelectedItem ( boundingMethod . toString ( ) . toLowerCase ( Locale . US ) ) ; Object minimumValue = parameter . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = parameter . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; displayLevelBox . setSelectedItem ( parameter . getDisplayLevel ( ) . toString ( ) . toLowerCase ( Locale . US ) ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
public static File getUserDataDirectory ( ) throws RuntimeException { if ( userDataDirectory ! = null ) return userDataDirectory ; if ( onMac ( ) ) { userDataDirectory = new File ( getHomeDirectory ( ) , " Library/ " + Application . NAME ) ; } else if ( onWindows ( ) ) { String localAppData ; HWND hwndOwner = null ; int nFolder = Shell32 . CSIDL_LOCAL_APPDATA ; HANDLE hToken = null ; int dwFlags = Shell32 . SHGFP_TYPE_CURRENT ; char [ ] pszPath = new char [ Shell32 . MAX_PATH ] ; int hResult = Shell32 . INSTANCE . SHGetFolderPath ( hwndOwner , nFolder , hToken , dwFlags , pszPath ) ; if ( Shell32 . S_OK = = hResult ) { String path = new String ( pszPath ) ; int len = path . indexOf ( '\0' ) ; localAppData = path . substring ( 0 , len ) ; } else { If the native call fails, use the home directory. localAppData = getHomeDirectory().getPath(); } userDataDirectory = new File(localAppData, Application.NAME); } else { userDataDirectory = new File(getHomeDirectory(), Application.NAME.toLowerCase(Locale.US)); } return userDataDirectory; } 
public RectMode rectmode ( String m ) { try { RectMode newMode = RectMode . valueOf ( m . toUpperCase ( Locale . US ) ) ; 
public EllipseMode ellipsemode ( String m ) { try { EllipseMode newMode = EllipseMode . valueOf ( m . toUpperCase ( Locale . US ) ) ; 
public Path arrow ( float x , float y , float width , String type , boolean draw ) { try { ArrowType arrowType = ArrowType . valueOf ( type . toUpperCase ( Locale . US ) ) ; 
public Transform . Mode transform ( String mode ) { try { Transform . Mode newMode = Transform . Mode . valueOf ( mode . toUpperCase ( Locale . US ) ) ; 
public Color . Mode colormode ( String mode , Float range ) { try { Color . Mode newMode = Color . Mode . valueOf ( mode . toUpperCase ( Locale . US ) ) ; 
public Text . Align align ( String align ) { try { Text . Align newAlign = Text . Align . valueOf ( align . toUpperCase ( Locale . US ) ) ; 
public void var ( String name , String type , Object value , Float min , Float max ) { try { var ( name , VarType . valueOf ( type . toUpperCase ( Locale . US ) ) , value , min , max ) ; 
private void startCodeTag ( Attributes attributes ) throws SAXException { String type = attributes . getValue ( CODE_TYPE ) ; if ( type = = null ) throw new SAXException ( " Type attribute is required in code tags. " ) ; try { currentCodeType = CodeType . valueOf ( type . toUpperCase ( Locale . US ) ) ; } catch ( IllegalArgumentException e ) { throw new SAXException ( " Invalid type attribute in code tag: should be python or java, not " + type + " . " ) ; } state = ParseState . IN_CODE ; characterData = new StringBuffer ( ) ; } 
private void startParameterTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( PARAMETER_NAME ) ; String typeAsString = attributes . getValue ( PARAMETER_TYPE ) ; if ( currentNode = = null ) throw new SAXException ( " Parameter tag encountered without a current node. " ) ; if ( name = = null ) throw new SAXException ( " Name is required for parameter on node ' " + currentNode . getName ( ) + " '. " ) ; if ( typeAsString = = null ) { No type attribute was given, so the parameter should already exist. currentParameter = currentNode.getParameter(name); if (currentParameter == null) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' does not exist."); } else { Type was given, so this is a new parameter. TODO: If type is given and parameter exists, migrate type. if (currentNode.hasParameter(name)) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' already exists."); Parameter.Type type = Parameter.Type.valueOf(typeAsString.toUpperCase(Locale.US)); currentParameter = currentNode.addParameter(name, type); } Parse parameter attributes. String widget = attributes.getValue(PARAMETER_WIDGET); String label = attributes.getValue(PARAMETER_LABEL); String helpText = attributes.getValue(PARAMETER_HELP_TEXT); String displayLevel = attributes.getValue(PARAMETER_DISPLAY_LEVEL); String enableExpression = attributes.getValue(PARAMETER_ENABLE_EXPRESSION); String boundingMethod = attributes.getValue(PARAMETER_BOUNDING_METHOD); String minimumValue = attributes.getValue(PARAMETER_MINIMUM_VALUE); String maximumValue = attributes.getValue(PARAMETER_MAXIMUM_VALUE); if (widget != null) currentParameter.setWidget(Parameter.Widget.valueOf(widget.toUpperCase(Locale.US))); if (label != null) currentParameter.setLabel(label); if (helpText != null) currentParameter.setHelpText(helpText); if (displayLevel != null) currentParameter.setDisplayLevel(Parameter.DisplayLevel.valueOf(displayLevel.toUpperCase(Locale.US))); if (enableExpression != null) currentParameter.setEnableExpression(enableExpression); if (boundingMethod != null) currentParameter.setBoundingMethod(Parameter.BoundingMethod.valueOf(boundingMethod.toUpperCase(Locale.US))); if (minimumValue != null) currentParameter.setMinimumValue(Float.parseFloat(minimumValue)); if (maximumValue != null) currentParameter.setMaximumValue(Float.parseFloat(maximumValue)); 
private void startValueTag ( Attributes attributes ) throws SAXException { if ( currentParameter = = null ) throw new SAXException ( " Value tag encountered without current parameter. " ) ; state = ParseState . IN_VALUE ; characterData = new StringBuffer ( ) ; The value tag should be empty except when the parameter type is code. Then the value tag has a type attribute that specifies the code type. if (currentParameter.getType() != Parameter.Type.CODE) return; String type = attributes.getValue(VALUE_TYPE); if (type == null) throw new SAXException("Type attribute is required in code type parameters."); try { currentCodeType = CodeType.valueOf(type.toUpperCase(Locale.US)); 
private void startPortTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( PORT_NAME ) ; String cardinalityAsString = attributes . getValue ( PORT_CARDINALITY ) ; if ( name = = null ) throw new SAXException ( " Name is required for port on node ' " + currentNode . getName ( ) + " '. " ) ; Port . Cardinality cardinality = Port . Cardinality . SINGLE ; if ( cardinalityAsString ! = null ) { try { cardinality = Port . Cardinality . valueOf ( cardinalityAsString . toUpperCase ( Locale . US ) ) ; } catch ( IllegalArgumentException e ) { throw new SAXException ( " Invalid cardinality attribute in port tag: should be single or multiple, not " + cardinalityAsString + " . " ) ; } } currentNode . addPort ( name , cardinality ) ; } 
private static void writePort ( Document doc , Element parent , Port port ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = port.getNode().getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getPort(port.getName()); If the port and its prototype are equal, don't write anything. if (protoPort != null && protoPort.getName().equals(port.getName()) && protoPort.getDirection().equals(port.getDirection()) && protoPort.getCardinality().equals(port.getCardinality())) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); if (port.getCardinality() != Port.Cardinality.SINGLE) el.setAttribute("cardinality", port.getCardinality().toString().toLowerCase(Locale.US)); parent.appendChild(el); } 
private static void attributeToXml ( Parameter param , Element el , String attrName , String xmlName , Parameter protoParam , Object defaultValue ) { try { String methodName = " get " + attrName . substring ( 0 , 1 ) . toUpperCase ( Locale . US ) + attrName . substring ( 1 ) ; 
public String toString ( ) { return " <Parameter " + getNode ( ) . getName ( ) + " . " + getName ( ) + " ( " + getType ( ) . toString ( ) . toLowerCase ( Locale . US ) + " )> " ; } 
public static String humanizeName ( String name ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] tokens = name . split ( " _ " ) ; for ( String : tokens ) { if ( . length ( ) = = 0 ) continue ; sb . append ( . substring ( 0 , 1 ) . toUpperCase ( Locale . US ) ) ; sb . append ( . substring ( 1 ) ) ; sb . append ( " " ) ; } return sb . toString ( ) . trim ( ) ; } 
public static String humanizeConstant ( String constant ) { return humanizeName ( constant . toLowerCase ( Locale . US ) ) ; } 
private void moveDelta ( int delta ) { Connection selectedConnection = ( Connection ) connectionList . getSelectedValue ( ) ; if ( selectedConnection = = null ) return ; java . util . List < Connection > connections = getConnections ( ) ; int index = connections . indexOf ( selectedConnection ) ; checkState ( index > = 0 , " Selected connection %s could not be found. " , selectedConnection ) ; boolean reordered = input . getParentNode ( ) . reorderConnection ( selectedConnection , delta , true ) ; if ( reordered ) { reloadList ( ) ; 
public boolean reorderConnection ( Connection connection , int deltaIndex , boolean multi ) { if ( multi ) { List < Connection > mConnections = connection . getInput ( ) . getConnections ( ) ; 
public void testReorderMultiple ( ) { Node root = testLibrary . getRootNode ( ) ; addNewConnection ( root ) ; Node number1 = root . create ( numberNode ) ; Node number2 = root . create ( numberNode ) ; Node number3 = root . create ( numberNode ) ; Node multiAdd = root . create ( multiAddNode ) ; Port pValues = multiAdd . getPort ( " values " ) ; Connection c1 = pValues . connect ( number1 ) ; Connection c2 = pValues . connect ( number2 ) ; Connection c3 = pValues . connect ( number3 ) ; addNewConnection ( root ) ; assertOrder ( pValues , number1 , number2 , number3 ) ; assertDirtyAndUpdate ( multiAdd ) ; Move number 1 up within the multiport. It was already first, so shouldn't change anything. root.reorderConnection(c1, -1, true); assertOrder(pValues, number1, number2, number3); assertFalse(multiAdd.isDirty()); Move number 1 up within the multiport. root.reorderConnection(c1, 1, true); assertOrder(pValues, number2, number1, number3); assertDirtyAndUpdate(multiAdd); Move number 3 down within the multiport. It was already last, so shouldn't change anything. root.reorderConnection(c3, 1, true); assertOrder(pValues, number2, number1, number3); assertFalse(multiAdd.isDirty()); Move number 3 down within the multiport. root.reorderConnection(c3, -1, true); assertOrder(pValues, number2, number3, number1); assertDirtyAndUpdate(multiAdd); } 
private void addNewConnection ( Node root ) { Node number = root . create ( numberNode ) ; Node add = root . create ( addNode ) ; Port addValue = add . getPort ( " v1 " ) ; addValue . connect ( number ) ; } 
public void receive ( NodeEvent event ) { if ( event instanceof ConnectionAddedEvent ) { if ( ( ( ConnectionAddedEvent ) event ) . getConnection ( ) . getInputNode ( ) = = node ) rebuildInterface ( ) ; return ; } if ( event . getSource ( ) ! = node ) return ; if ( ! ( event instanceof NodeAttributeChangedEvent ) ) return ; if ( ( ( NodeAttributeChangedEvent ) event ) . getAttribute ( ) = = Node . Attribute . POSITION ) return ; rebuildInterface ( ) ; } 
public Geometry asGeometry ( ) { Geometry g = new Geometry ( ) ; for ( Grob item : items ) { if ( item instanceof Path ) g . add ( ( Path ) item . clone ( ) ) ; else if ( item instanceof Geometry ) g . extend ( ( Geometry ) item . clone ( ) ) ; } return g ; } 
public void deleteSelected ( ) { if ( selection = = null ) return ; getDocument ( ) . disconnect ( selection ) ; } 
public void deleteSelected ( ) { Set < NodeView > nodesToRemove = new HashSet < NodeView > ( selection ) ; for ( NodeView nodeView : nodesToRemove ) { getDocument ( ) . removeNode ( nodeView . getNode ( ) ) ; } connectionLayer . deleteSelected ( ) ; } 
public void cutSelected ( ) { Node parent = getNode ( ) ; ArrayList < Node > nodesToCopy = new ArrayList < Node > ( selection . size ( ) ) ; for ( NodeView nv : selection ) { Node = nv . getNode ( ) ; nodesToCopy . add ( ) ; } for ( Node : nodesToCopy ) { getDocument ( ) . removeNode ( ) ; } Application . getInstance ( ) . setNodeClipboard ( nodesToCopy ) ; } 
public void pasteSelected ( ) { Node newParent = getNode ( ) ; List < Node > nodesToCopy = Application . getInstance ( ) . getNodeClipboard ( ) ; if ( nodesToCopy = = null | | nodesToCopy . size ( ) = = 0 ) return ; Node parent = nodesToCopy . get ( 0 ) . getParent ( ) ; TODO: Cut operation removes parent from child nodes, so no parent is available. This is a problem for connections. if (parent == null) return; Collection<Node> newNodes = getDocument().copyChildren(nodesToCopy, parent, newParent); deselectAll(); for (Node newNode : newNodes) { NodeView nv = getNodeView(newNode); 
public void connect ( Port output , Port input ) { getDocument ( ) . connect ( output , input ) ; 
private void goDown ( ) { if ( selection . size ( ) ! = 1 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; return ; } NodeView selectedNode = selection . iterator ( ) . next ( ) ; getDocument ( ) . setActiveNetwork ( selectedNode . getNode ( ) ) ; } 
public void removeNode ( Node node ) { getDocument ( ) . removeNode ( node ) ; } 
public Node createNode ( Node prototype ) { return getActiveNetwork ( ) . create ( prototype ) ; } 
public void removeNode ( Node node ) { getActiveNetwork ( ) . remove ( node ) ; } 
public Connection connect ( Port output , Port input ) { return getActiveNetwork ( ) . connectChildren ( input , output ) ; } 
public void disconnect ( Connection connection ) { getActiveNetwork ( ) . disconnect ( connection ) ; } 
public Collection < Node > copyChildren ( Collection < Node > children , Node oldParent , Node newParent ) { return oldParent . copyChildren ( children , newParent ) ; } 
public void actionPerformed ( ActionEvent e ) { try { getDocument ( ) . connect ( outputNode . getOutputPort ( ) , inputPort ) ; 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . setRenderedNode ( node ) ; networkView . repaint ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . removeNode ( node ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . setActiveNetwork ( node ) ; } 
private ParameterControl constructControl ( Class controlClass , Parameter p ) { try { Constructor constructor = controlClass . getConstructor ( NodeBoxDocument . class , Parameter . class ) ; 
public void actionPerformed ( ActionEvent e ) { Font font = ( Font ) fontChooser . getSelectedItem ( ) ; if ( font = = null ) return ; String fontName = font . getFontName ( ) ; if ( ! fontName . equals ( parameter . asString ( ) ) ) { setParameterValue ( font . getFontName ( ) ) ; 
public void actionPerformed ( ActionEvent e ) { String newPath = PathDialog . choosePath ( parameter . getNode ( ) . getRoot ( ) , parameter . asString ( ) ) ; setParameterValue ( newPath ) ; } 
public void actionPerformed ( ActionEvent e ) { String newValue = keyField . getText ( ) + " = " + expressionField . getText ( ) ; if ( ! newValue . equals ( parameter . asString ( ) ) ) { setParameterValue ( newValue ) ; 
public void actionPerformed ( ActionEvent e ) { String newValue = textField . getText ( ) ; if ( ! newValue . equals ( parameter . asString ( ) ) ) { setParameterValue ( newValue ) ; 
public void toggle ( ) { setParameterValue ( checkBox . isChecked ( ) ? 1 : 0 ) ; 
private void init ( ) { this . setMargin ( new Insets ( 0 , 5 , 0 , 5 ) ) ; setFont ( Theme . EDITOR_FONT ) ; setEditorKit ( new PythonEditorKit ( ) ) ; rootElement = getDocument ( ) . getDefaultRootElement ( ) ; getDocument().addUndoableEditListener(this); todo:this code should be in the kit for (KeyStroke ks : defaultInputMap.allKeys()) { getInputMap().put(ks, defaultInputMap.get(ks)); } defaultInputMap.put(PlatformUtils.getKeyStroke(KeyEvent.VK_Z), new UndoAction()); defaultInputMap.put(PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK), new RedoAction()); addMouseListener(new DragDetector()); } 
public void undoableEditHappened ( UndoableEditEvent e ) { undoManager . addEdit ( e . getEdit ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { try { undoManager . undo ( ) ; 
public void actionPerformed ( ActionEvent e ) { try { undoManager . redo ( ) ; 
public void addNodeLibraryListener ( NodeEventListener listener ) { nodeLibrary . addListener ( listener ) ; } 
public void removeNodeLibraryListener ( NodeEventListener listener ) { nodeLibrary . removeListener ( listener ) ; } 
public void startEdits ( String command ) { addEdit ( command ) ; holdEdits = true ; } 
public void addEdit ( String command ) { if ( ! holdEdits ) { undoManager . addEdit ( new NodeLibraryUndoableEdit ( this , command ) ) ; 
public void undo ( ) { if ( ! undoManager . canUndo ( ) ) return ; undoManager . undo ( ) ; menuBar . updateUndoRedoState ( ) ; } 
public void redo ( ) { if ( ! undoManager . canRedo ( ) ) return ; undoManager . redo ( ) ; menuBar . updateUndoRedoState ( ) ; } 
public void paste ( ) { addEdit ( " Paste node " ) ; NetworkView networkView = currentNetworkView ( ) ; if ( networkView = = null ) { beep ( ) ; return ; } networkView . pasteSelected ( ) ; } 
public Node createNode ( Node prototype ) { addEdit ( " Create Node " ) ; return getActiveNetwork ( ) . create ( prototype ) ; } 
public void removeNode ( Node node ) { addEdit ( " Remove Node " ) ; getActiveNetwork ( ) . remove ( node ) ; } 
public Connection connect ( Port output , Port input ) { addEdit ( " Connect " ) ; return getActiveNetwork ( ) . connectChildren ( input , output ) ; } 
public void disconnect ( Connection connection ) { addEdit ( " Disconnect " ) ; getActiveNetwork ( ) . disconnect ( connection ) ; } 
public Collection < Node > copyChildren ( Collection < Node > children , Node oldParent , Node newParent ) { addEdit ( " Copy " ) ; return oldParent . copyChildren ( children , newParent ) ; } 
public void updateUndoRedoState ( ) { undoAction . update ( ) ; redoAction . update ( ) ; } 
public boolean isEnabled ( ) { return NodeBoxMenuBar . this . isEnabled ( ) & & super . isEnabled ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . undo ( ) ; updateUndoRedoState ( ) ; } 
public void update ( ) { if ( undoManager ! = null & & undoManager . canUndo ( ) ) { setEnabled ( true ) ; 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . redo ( ) ; updateUndoRedoState ( ) ; } 
public void update ( ) { if ( undoManager ! = null & & undoManager . canRedo ( ) ) { setEnabled ( true ) ; 
public void undo ( ) throws CannotUndoException { super . undo ( ) ; if ( redoXml = = null ) redoXml = saveState ( ) ; restoreState ( undoXml ) ; } 
public void redo ( ) throws CannotRedoException { super . redo ( ) ; restoreState ( redoXml ) ; } 
public String saveState ( ) { return document . getNodeLibrary ( ) . toXml ( ) ; } 
public void restoreState ( String xml ) { NodeLibrary nodeLibrary = NodeLibrary . load ( document . getNodeLibrary ( ) . getName ( ) , xml , document . getManager ( ) ) ; document . setNodeLibrary ( nodeLibrary ) ; } 
public void clearParameterExpression ( Parameter parameter ) { addEdit ( " Clear Parameter Expression " ) ; parameter . clearExpression ( ) ; } 
public void revertParameterToDefault ( Parameter parameter ) { addEdit ( " Revert Parameter to Default " ) ; parameter . revertToDefault ( ) ; } 
public void actionPerformed ( ActionEvent e ) { document . startEdits ( " Toggle Parameter Expression " ) ; if ( parameter . hasExpression ( ) ) { document . clearParameterExpression ( parameter ) ; } else { document . setParameterExpression ( parameter , parameter . asExpression ( ) ) ; } document . stopEdits ( ) ; We don't have to change the expression status here. 
public void actionPerformed ( ActionEvent e ) { document . revertParameterToDefault ( parameter ) ; Reverting to default could cause an expression to be set/cleared. 
public void actionPerformed ( ActionEvent e ) { try { document . setParameterExpression ( parameter , expressionField . getText ( ) ) ; 
public void receive ( NodeEvent event ) { if ( event instanceof ConnectionAddedEvent ) { if ( ( ( ConnectionAddedEvent ) event ) . getConnection ( ) . getInputNode ( ) = = node ) rebuildInterface ( ) ; return ; } if ( event . getSource ( ) ! = node ) return ; if ( ! ( event instanceof NodeAttributeChangedEvent ) ) return ; if ( ( ( NodeAttributeChangedEvent ) event ) . getAttribute ( ) = = Node . Attribute . POSITION ) return ; rebuildInterface ( ) ; } 
public void addEdit ( String command , String type , Object object ) { if ( ! holdEdits ) { if ( lastEditType . equals ( type ) & & lastEditObject = = object ) { 
public void deleteSelected ( ) { Set < NodeView > nodesToRemove = new HashSet < NodeView > ( selection ) ; getDocument ( ) . startEdits ( " Delete Nodes " ) ; for ( NodeView nodeView : nodesToRemove ) { getDocument ( ) . removeNode ( nodeView . getNode ( ) ) ; } getDocument ( ) . stopEdits ( ) ; connectionLayer . deleteSelected ( ) ; } 
public void addEdit ( String command , String type , Object object ) { if ( ! holdEdits ) { if ( lastEditType ! = null & & lastEditType . equals ( type ) & & lastEditObject = = object ) { 
public void stopCombiningEdits ( ) { We just reset the last edit type and object so that addEdit will be forced to create a new edit. lastEditType = null; lastEditObject = null; 
public void mouseClicked ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) { getDocument ( ) . addEdit ( HANDLE_UNDO_TEXT , HANDLE_UNDO_TYPE , activeNode ) ; 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) { getDocument ( ) . addEdit ( HANDLE_UNDO_TEXT , HANDLE_UNDO_TYPE , activeNode ) ; 
public void mouseReleased ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) { getDocument ( ) . addEdit ( HANDLE_UNDO_TEXT , HANDLE_UNDO_TYPE , activeNode ) ; 
public void mouseEntered ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) { getDocument ( ) . addEdit ( HANDLE_UNDO_TEXT , HANDLE_UNDO_TYPE , activeNode ) ; 
public void mouseExited ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) { getDocument ( ) . addEdit ( HANDLE_UNDO_TEXT , HANDLE_UNDO_TYPE , activeNode ) ; 
public void mouseDragged ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) { getDocument ( ) . addEdit ( HANDLE_UNDO_TEXT , HANDLE_UNDO_TYPE , activeNode ) ; 
public void mouseMoved ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; if ( hasVisibleHandle ( ) ) { getDocument ( ) . addEdit ( HANDLE_UNDO_TEXT , HANDLE_UNDO_TYPE , activeNode ) ; 
public void editMetadata ( ) { if ( node = = null ) return ; getDocument ( ) . addEdit ( " Node Metadata " ) ; NodeAttributesEditor editor = new NodeAttributesEditor ( node ) ; Window w = SwingUtilities . getWindowAncestor ( this ) ; JDialog editorDialog = new JDialog ( w , node . getName ( ) + " Metadata " ) ; editorDialog . getContentPane ( ) . add ( editor ) ; editorDialog . setSize ( 580 , 751 ) ; editorDialog . setResizable ( false ) ; editorDialog . setModal ( true ) ; editorDialog . setModalityType ( Dialog . ModalityType . DOCUMENT_MODAL ) ; Center the frame based on the current window. if (w == null) { If the current window could not be found, set to the default location. editorDialog.setLocationByPlatform(true); } else { int ancestorCenterX = w.getX() + w.getWidth() / 2; int ancestorCenterY = w.getY() + w.getHeight() / 2; int x = ancestorCenterX - editorDialog.getWidth() / 2; int y = ancestorCenterY - editorDialog.getHeight() / 2; editorDialog.setLocation(x, y); } editorDialog.setVisible(true); } 
public void mouseClicked ( MouseEvent e ) { We register the mouse click as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void mousePressed ( MouseEvent e ) { We register the mouse press as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void mouseReleased ( MouseEvent e ) { We register the mouse release as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void mouseEntered ( MouseEvent e ) { Entering the viewer with your mouse should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { handle.mouseEntered(pointForEvent(e)); 
public void mouseExited ( MouseEvent e ) { Exiting the viewer with your mouse should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { handle.mouseExited(pointForEvent(e)); 
public void mouseDragged ( MouseEvent e ) { We register the mouse drag as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void mouseMoved ( MouseEvent e ) { Moving the mouse in the viewer area should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { handle.mouseMoved(pointForEvent(e)); 
public void propertyChange ( PropertyChangeEvent evt ) { if ( ! evt . getPropertyName ( ) . equals ( NetworkView . SELECT_PROPERTY ) ) return ; Set < NodeView > selection = ( Set < NodeView > ) evt . getNewValue ( ) ; If there is no selection, set the active node to null. if (selection == null || selection.isEmpty()) { getDocument().setActiveNode((Node) null); 
public void undo ( ) throws CannotUndoException { super . undo ( ) ; if ( redoState = = null ) redoState = saveState ( ) ; restoreState ( undoState ) ; } 
public void redo ( ) throws CannotRedoException { super . redo ( ) ; restoreState ( redoState ) ; } 
public UndoState saveState ( ) { UndoState state = new UndoState ( ) ; state . xml = document . getNodeLibrary ( ) . toXml ( ) ; state . activeNetworkPath = document . getActiveNetworkPath ( ) ; Node activeNode = document . getActiveNode ( ) ; if ( activeNode = = null ) { state . activeNodeName = null ; } else { state . activeNodeName = activeNode . getName ( ) ; } return state ; } 
public void restoreState ( UndoState state ) { NodeLibrary nodeLibrary = NodeLibrary . load ( document . getNodeLibrary ( ) . getName ( ) , state . xml , document . getManager ( ) ) ; document . setNodeLibrary ( nodeLibrary ) ; document . setActiveNetwork ( state . activeNetworkPath ) ; if ( state . activeNodeName ! = null ) { Node child = document . getActiveNetwork ( ) . getChild ( state . activeNodeName ) ; 
public void testGetNodeForPath ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node root = library . getRootNode ( ) ; Node alpha = root . create ( Node . ROOT_NODE , " alpha " ) ; Node beta = alpha . create ( Node . ROOT_NODE , " beta " ) ; assertSame ( root , library . getNodeForPath ( root . getAbsolutePath ( ) ) ) ; assertSame ( alpha , library . getNodeForPath ( alpha . getAbsolutePath ( ) ) ) ; assertSame ( beta , library . getNodeForPath ( beta . getAbsolutePath ( ) ) ) ; assertSame ( root , library . getNodeForPath ( " xxx " ) ) ; assertSame ( alpha , library . getNodeForPath ( " /alpha/xxx " ) ) ; assertSame ( beta , library . getNodeForPath ( " /alpha/beta/ " ) ) ; If you forget the first slash, the path cannot be interpreted. assertSame(root, library.getNodeForPath("alpha/beta")); } 
public void testAbsolutePath ( ) { Node root = testLibrary . getRootNode ( ) ; Node alpha = root . create ( Node . ROOT_NODE , " alpha " ) ; Node beta = alpha . create ( Node . ROOT_NODE , " beta " ) ; assertEquals ( " / " , root . getAbsolutePath ( ) ) ; assertEquals ( " /alpha " , alpha . getAbsolutePath ( ) ) ; assertEquals ( " /alpha/beta " , beta . getAbsolutePath ( ) ) ; } 
public void editMetadata ( ) { if ( node = = null ) return ; getDocument ( ) . addEdit ( " Node Metadata " ) ; NodeAttributesEditor editor = new NodeAttributesEditor ( node ) ; Frame frame = ( Frame ) SwingUtilities . getRoot ( this ) ; JDialog editorDialog = new JDialog ( frame , node . getName ( ) + " Metadata " ) ; editorDialog . getContentPane ( ) . add ( editor ) ; editorDialog . setSize ( 580 , 751 ) ; editorDialog . setResizable ( false ) ; editorDialog . setModal ( true ) ; editorDialog . setModalityType ( Dialog . ModalityType . DOCUMENT_MODAL ) ; Center the frame based on the current window. if (frame == null) { If the current window could not be found, set to the default location. editorDialog.setLocationByPlatform(true); } else { int ancestorCenterX = frame.getX() + frame.getWidth() / 2; int ancestorCenterY = frame.getY() + frame.getHeight() / 2; int x = ancestorCenterX - editorDialog.getWidth() / 2; int y = ancestorCenterY - editorDialog.getHeight() / 2; editorDialog.setLocation(x, y); } editorDialog.setVisible(true); } 
public void stopCombiningEdits ( ) { NodeBoxDocument document = NodeBoxDocument . getCurrentDocument ( ) ; if ( document ! = null ) { document . stopCombiningEdits ( ) ; 
public boolean keyTyped ( int keyCode , int modifiers ) { return false ; } 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void stopCombiningEdits(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void stopCombiningEdits(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public Node getNode ( ) ; public void update ( ) ; public void stopCombiningEdits ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public void update ( ) ; public void stopCombiningEdits ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
public void stopCombiningEdits ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers);} 
private boolean contains ( Node node , String searchString ) { String description = node . getDescription ( ) = = null ? " " : node . getDescription ( ) . toLowerCase ( ) ; return node . getName ( ) . toLowerCase ( ) . contains ( searchString ) | | description . contains ( searchString ) ; } 
public void stateChanged ( ChangeEvent changeEvent ) { frame = ( float ) frameNumber . getValue ( ) ; document . setFrame ( frame ) ; } 
public void startAnimation ( ) { document . startAnimation ( ) ; } 
public void stopAnimation ( ) { document . stopAnimation ( ) ; } 
public void resetAnimation ( ) { document . resetAnimation ( ) ; } 
protected void paintComponent ( Graphics g ) { g . drawImage ( animationBackground , 0 , 0 , getWidth ( ) , ANIMATION_BAR_HEIGHT , null ) ; } 
public void actionPerformed ( ActionEvent e ) { Timer has fired. document.nextFrame(); } 
public void startAnimation ( ) { animationTimer . start ( ) ; } 
public void resetAnimation ( ) { stopAnimation ( ) ; setFrame ( 1 ) ; } 
public void markDirty ( ) { if ( dirty ) return ; dirty = true ; fireValueChanged ( ) ; } 
public void testIsTimeDependent ( ) { Node root = testLibrary . getRootNode ( ) ; Node alpha = root . create ( Node . ROOT_NODE , " alpha " ) ; alpha . addParameter ( " x " , Parameter . Type . FLOAT ) ; Node beta = root . create ( Node . ROOT_NODE , " beta " ) ; alpha . addParameter ( " y " , Parameter . Type . FLOAT ) ; } 
public static void main ( String [ ] args ) { for ( String arg : args ) { if ( arg . contains ( " --enable-animation " ) ) { FLAG_ENABLE_ANIMATION = true ; } } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void testGlobals ( ) { assertSnippetEquals ( 11.0 , " FRAME + 10 " , null , new ProcessingContext ( ) ) ; } 
public static Color fromHSB ( double hue , double saturation , double brightness ) { return new Color ( hue , saturation , brightness , Mode . HSB ) ; } 
public static Color fromHSB ( double hue , double saturation , double brightness , double alpha ) { return new Color ( hue , saturation , brightness , alpha , Mode . HSB ) ; } 
public static Color hsb ( double . . . values ) { switch ( values . length ) { case 0 : 
public static Color hsb ( double gray ) { return new Color ( gray , gray , gray ) ; } 
public static Color hsb ( double gray , double alpha ) { return new Color ( gray , gray , gray , alpha ) ; } 
public static Color hsb ( double hue , double saturation , double brightness ) { return Color . fromHSB ( hue , saturation , brightness ) ; } 
public static Color hsb ( double hue , double saturation , double brightness , double alpha ) { return Color . fromHSB ( hue , saturation , brightness , alpha ) ; } 
public void addEdit ( String command ) { if ( ! holdEdits ) { markChanged ( ) ; 
public void addEdit ( String command , String type , Object object ) { if ( ! holdEdits ) { markChanged ( ) ; 
public void mouseClicked ( MouseEvent mouseEvent ) { consolePrompt . requestFocus ( ) ; } 
private void addMessage ( String s , AttributeSet attributes ) { try { messagesDocument . insertString ( messagesDocument . getLength ( ) , s , attributes ) ; 
private void addMessage ( String s ) { addMessage ( s , ATTRIBUTES_REGULAR ) ; } 
private void addCommandMessage ( String s ) { addMessage ( s , ATTRIBUTES_COMMAND ) ; } 
private void addErrorMessage ( String s ) { addMessage ( s , ATTRIBUTES_ERROR ) ; } 
public void doEnter ( ) { String command = getCommand ( ) ; addCommandToHistory ( command ) ; setCommand ( " " ) ; addCommandMessage ( command + " " ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; ByteArrayOutputStream errorStream = new ByteArrayOutputStream ( ) ; interpreter . setOut ( outputStream ) ; interpreter . setErr ( errorStream ) ; interpreter . set ( " document " , pane . getDocument ( ) ) ; interpreter . set ( " root " , pane . getDocument ( ) . getActiveNetwork ( ) . getRoot ( ) ) ; interpreter . set ( " parent " , pane . getDocument ( ) . getActiveNetwork ( ) ) ; interpreter . set ( " node " , pane . getDocument ( ) . getActiveNode ( ) ) ; interpreter . exec ( " from nodebox.node import * " ) ; for ( Parameter . Type type : Parameter . Type . values ( ) ) { interpreter . set ( type . name ( ) , type ) ; } for ( Parameter . Type : Parameter . Type . values ( ) ) interpreter . set ( . name ( ) , ) ; Exception pythonException = null ; try { Object result = interpreter . eval ( command ) ; if ( result ! = null ) { addMessage ( result . toString ( ) + " " ) ; } } catch ( Exception e ) { pythonException = e ; } String os = outputStream . toString ( ) ; if ( os . length ( ) > 0 ) { addMessage ( os ) ; if ( ! os . endsWith ( " " ) ) addMessage ( " " ) ; } if ( pythonException ! = null ) addErrorMessage ( pythonException . toString ( ) ) ; 
public void moveBackInHistory ( ) { if ( historyOffset = = history . size ( ) ) return ; if ( historyOffset = = 0 ) { temporarySavedCommand = getCommand ( ) ; } historyOffset + + ; setCommand ( history . get ( history . size ( ) - historyOffset ) ) ; } 
public void moveForwardInHistory ( ) { if ( historyOffset = = 0 ) return ; historyOffset - - ; if ( historyOffset = = 0 ) { Preconditions . checkNotNull ( temporarySavedCommand , " temporarySavedCommand is null. " ) ; 
public void addCommandToHistory ( String command ) { history . add ( command ) ; historyOffset = 0 ; } 
public void focusGained ( FocusEvent focusEvent ) { consolePrompt . requestFocus ( ) ; } 
public void actionPerformed ( ActionEvent e ) { moveBackInHistory ( ) ; } 
public void actionPerformed ( ActionEvent e ) { moveForwardInHistory ( ) ; } 
public void paintBorder ( Component component , Graphics g , int x , int y , int width , int height ) { g . setColor ( PROMPT_BORDER_TOP_COLOR ) ; g . drawLine ( 0 , 0 , width , 0 ) ; g . setColor ( PROMPT_COLOR ) ; g . drawString ( " > " , 5 , 14 ) ; } 
public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; final Pane newPane ; try { Constructor c = paneType . getConstructor ( NodeBoxDocument . class ) ; newPane = ( Pane ) c . newInstance ( this . document ) ; } catch ( Exception e ) { throw new RuntimeException ( " Could not instantiate new " + paneType , e ) ; } Container parent = getParent ( ) ; if ( parent instanceof PaneSplitter ) { PaneSplitter parentSplit = ( PaneSplitter ) parent ; boolean first = parentSplit . getFirstComponent ( ) = = this ; if ( first ) { parentSplit . setFirstComponent ( newPane ) ; } else { parentSplit . setSecondComponent ( newPane ) ; } } else { Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; } parent . validate ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { newPane . requestFocus ( ) ; } 
public void focusGained ( FocusEvent focusEvent ) { if ( mainComponent ! = null ) { mainComponent . requestFocus ( ) ; 
public static void main ( String [ ] args ) { for ( String arg : args ) { if ( arg . contains ( " --enable-animation " ) ) { FLAG_ENABLE_ANIMATION = true ; } } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void cutSelected ( ) { copySelected ( ) ; List < Node > nodes = getSelectedNodes ( ) ; for ( Node : nodes ) { getDocument ( ) . removeNode ( ) ; 
public void copySelected ( ) { When copying, create copies of all the nodes and store them under a new parent. The parent is used to preserve the connections, and also to save the state of the copied nodes. This parent is the root of a new library. NodeLibrary clipboardLibrary = new NodeLibrary("clipboard"); Node clipboardRoot = clipboardLibrary.getRootNode(); getDocument().copyChildren(getSelectedNodes(), getNode(), clipboardRoot); Application.getInstance().setNodeClipboard(clipboardLibrary); } 
public void pasteSelected ( ) { Node newParent = getNode ( ) ; NodeLibrary clipboardLibrary = Application . getInstance ( ) . getNodeClipboard ( ) ; if ( clipboardLibrary = = null ) return ; Node clipboardRoot = clipboardLibrary . getRootNode ( ) ; if ( clipboardRoot . size ( ) = = 0 ) return ; Collection < Node > newNodes = getDocument ( ) . copyChildren ( clipboardRoot . getChildren ( ) , clipboardRoot , newParent ) ; deselectAll ( ) ; for ( Node newNode : newNodes ) { NodeView nv = getNodeView ( newNode ) ; 
private void preCook ( ) { The namespace will remain bound to the interpreter. Changes to this dictionary will affect the namespace of the interpreter. PythonInterpreter interpreter = new PythonInterpreter(namespace); Immediately run the code to extract the cook(self) method. interpreter.exec("from nodebox1.graphics import Context" + "_g = globals()" + "_ctx = Context(ns=_g)" + "for n in dir(_ctx):" + " _g[n] = getattr(_ctx, n)"); if (code == null) code = new PythonInterpreter().compile(source); interpreter.exec(code); ctx = (CanvasContext) interpreter.get("_ctx").__tojava__(CanvasContext.class); try { cookFunction = (PyFunction) interpreter.get("cook"); 
public Parameter findVar ( String name ) { Node node = ProcessingContext . getCurrentContext ( ) . getNode ( ) ; if ( node = = null ) return null ; return node . getParameter ( name ) ; } 
public Color . Mode colormode ( String mode , Float range ) ; public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( int mode ) ; public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color . Mode colormode ( int mode , Float range ) ; public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float colorrange ( ) ; public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float colorrange ( float range ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nofill ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y , float z ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( float x , float y , float z , float a ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( Color c ) ; public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nostroke ( ) ; public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float strokewidth ( ) ; public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float strokewidth ( float w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName ) ; public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName , float fontSize ) ; public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float fontsize ( ) ; public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float fontsize ( float s ) ; public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float lineheight ( ) ; public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float lineheight ( float lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( int align ) ; public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y ) ; public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width ) ; public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha ) ; public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , boolean draw ) ; public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( Image img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( BufferedImage img , float x , float y , Float width , Float height , float alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( BufferedImage img ) ; public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , float x , float y ) ; public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , float x , float y , float width ) ; public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , float x , float y , float width , float height ) ; public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , float x , float y , float width , float height , boolean draw ) ; public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , float x , float y ) ; public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , float x , float y , float width ) ; public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , float x , float y , float width , float height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text , float width ) ; public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text , float width , float height ) ; public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float textwidth ( String text ) ; public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float textwidth ( String text , float width ) ; public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float textheight ( String text ) ; public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public float textheight ( String text , float width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type , Object value , Float min , Float max ) ; public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type , Object value , Float min , Float max ) ; public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type , Object value , Float min , Float max ) ; public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Parameter findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Geometry asGeometry ( ) { Geometry g = new Geometry ( ) ; for ( Grob item : items ) { if ( item instanceof Path ) g . add ( ( Path ) item . clone ( ) ) ; else if ( item instanceof Text ) g . add ( ( ( Text ) item ) . getPath ( ) ) ; else if ( item instanceof Geometry ) g . extend ( ( Geometry ) item . clone ( ) ) ; } return g ; } 
public boolean reload ( ) { if ( node = = null ) return false ; Parameter pCode = node . getParameter ( codeType ) ; if ( pCode = = null ) return false ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; if ( codeType . equals ( " _handle " ) ) getDocument ( ) . setActiveNode ( node ) ; to make Viewer reload handle setChanged(false); getDocument().removeChangedCodeForParameter(pCode); return true; } 
public void stateChanged ( ChangeEvent changeEvent ) { The document has changed. setChanged(node != null); } 
public void removeChangedCodeForParameter ( Parameter parameter ) { changedCodeParameters . remove ( parameter ) ; } 
public void addChangeListener ( ChangeListener l ) { changeListeners . add ( l ) ; } 
public void removeChangeListener ( ChangeListener l ) { changeListeners . remove ( l ) ; } 
public void fireDocumentChanged ( ) { ChangeEvent e = new ChangeEvent ( this ) ; for ( ChangeListener l : changeListeners ) { l . stateChanged ( e ) ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( isEnabled ( ) ) { if ( checked ) { g2 . drawImage ( checkedImage , 0 , 0 , null ) ; } else { g2 . drawImage ( normalImage , 0 , 0 , null ) ; } } else { if ( checked ) { g2 . drawImage ( checkDisabledOn , 0 , 0 , null ) ; } else { g2 . drawImage ( checkDisabledOff , 0 , 0 , null ) ; } } int w = normalImage . getWidth ( null ) ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; if ( warn ) { g2 . setColor ( Theme . TEXT_WARNING_COLOR ) ; } else if ( armed ) { g2 . setColor ( Theme . TEXT_ARMED_COLOR ) ; } else if ( ! isEnabled ( ) ) { g2 . setColor ( Theme . TEXT_DISABLED_COLOR ) ; } else { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } SwingUtils . drawShadowText ( g2 , text , w + IMAGE_TEXT_MARGIN , TEXT_BASELINE ) ; } 
public boolean reload ( ) { if ( node = = null ) return false ; Parameter pCode = node . getParameter ( codeType ) ; if ( pCode = = null ) return false ; NodeCode code = new PythonCode ( editor . getSource ( ) ) ; pCode . set ( code ) ; if ( codeType . equals ( " _handle " ) ) getDocument ( ) . setActiveNode ( node ) ; to make Viewer reload handle setCodeChanged(false); getDocument().removeChangedCodeForParameter(pCode); return true; } 
public void stateChanged ( ChangeEvent changeEvent ) { The document has changed. setCodeChanged(node != null); } 
public void actionPerformed ( ActionEvent actionEvent ) { doExport ( ) ; } 
private void doExport ( ) { exportPrefix = prefixField . getText ( ) ; try { fromValue = Integer . valueOf ( fromField . getText ( ) ) ; } catch ( NumberFormatException e ) { fromValue = 1 ; } try { toValue = Integer . valueOf ( toField . getText ( ) ) ; } catch ( NumberFormatException e ) { toValue = 100 ; } setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { FileDialog fileDialog = new FileDialog ( ( Frame ) null ) ; System . setProperty ( " apple.awt.fileDialogForDirectories " , " true " ) ; fileDialog . setVisible ( true ) ; System . setProperty ( " apple.awt.fileDialogForDirectories " , " false " ) ; String chosenFile = fileDialog . getFile ( ) ; if ( chosenFile = = null ) { setExportDirectory ( null ) ; return ; } String dir = fileDialog . getDirectory ( ) ; File f = new File ( dir , chosenFile ) ; if ( ! f . isDirectory ( ) ) { setExportDirectory ( f . getParentFile ( ) ) ; 
public static void main ( String [ ] args ) { ExportRangeDialog d = new ExportRangeDialog ( null , null ) ; d . setVisible ( true ) ; } 
public boolean exportRange ( ) { File exportDirectory = lastExportPath = = null ? null : new File ( lastExportPath ) ; ExportRangeDialog d = new ExportRangeDialog ( this , exportDirectory ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; String exportPrefix = d . getExportPrefix ( ) ; File directory = d . getExportDirectory ( ) ; int fromValue = d . getFromValue ( ) ; int toValue = d . getToValue ( ) ; if ( directory = = null ) return false ; lastExportPath = directory . getAbsolutePath ( ) ; exportRange ( exportPrefix , directory , fromValue , toValue ) ; return true ; } 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue ) { Shield off all input final Component oldGlassPane = getGlassPane(); final JPanel progressGlassPane = new JPanel(); progressGlassPane.setBackground(new Color(0, 0, 0, 100)); progressGlassPane.setOpaque(true); setGlassPane(progressGlassPane); progressGlassPane.setVisible(true); Show the progress dialog final ProgressDialog d = new ProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { final int theFrame = frame; try { SwingUtilities.invokeAndWait(new Runnable() { public void run() { setFrame(theFrame); activeNetwork.update(); d.tick(); } }); } catch (Exception e) { e.printStackTrace(); } File exportFile = new File(directory, exportPrefix + "-" + frame); exportToFile(exportFile); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); setGlassPane(oldGlassPane); progressGlassPane.setVisible(false); } }); } } }); t.start(); } 
public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { 
public void run ( ) { setFrame ( theFrame ) ; activeNetwork . update ( ) ; d . tick ( ) ; } 
public void run ( ) { d . setVisible ( false ) ; setGlassPane ( oldGlassPane ) ; progressGlassPane . setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . exportRange ( ) ; } 
public void codeChanged ( Node node , boolean changed ) { NodeView nv = getNodeView ( node ) ; if ( nv = = null ) return ; nv . setCodeChanged ( changed ) ; repaint ( ) ; } 
public void addCodeChangeListener ( CodeChangeListener l ) { codeChangeListeners . add ( CodeChangeListener . class , l ) ; } 
public void removeCodeChangeListener ( CodeChangeListener l ) { codeChangeListeners . remove ( CodeChangeListener . class , l ) ; } 
public void removeChangedCodeForParameter ( Parameter parameter ) { changedCodeParameters . remove ( parameter ) ; Node node = parameter . getNode ( ) ; for ( Parameter p : changedCodeParameters . keySet ( ) ) { if ( p . getNode ( ) = = node ) return ; } fireCodeChanged ( node , false ) ; } 
protected void paint ( PPaintContext ctx ) { Graphics2D g = ctx . getGraphics ( ) ; Shape clip = g . getClip ( ) ; g . clip ( getBounds ( ) ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; Draw the selection/connection border if (selected && networkView.getConnectionTarget() != this) g.drawImage(nodeGlow, 0, 0, null); if (networkView.getConnectionTarget() == this) g.drawImage(nodeConnectionGlow, 0, 0, null); g.drawImage(fullIcon, 0, 0, null); if (codeChanged) g.drawImage(nodeCodeChanged, 0, 0, null); if (node.hasError()) g.drawImage(nodeError, 0, 0, null); if (node.isRendered()) g.drawImage(nodeRendered, 0, 0, null); g.drawImage(nodeRim, 0, 0, null); Draw the node name. g.setFont(Theme.SMALL_BOLD_FONT); g.setColor(Theme.NETWORK_NODE_NAME_COLOR); int textWidth = g.getFontMetrics().stringWidth(node.getName()); int x = (int) ((NODE_FULL_SIZE - textWidth) / 2f); SwingUtils.drawShadowText(g, node.getName(), x, NODE_FULL_SIZE + 5, Theme.NETWORK_NODE_NAME_SHADOW_COLOR, -1); Reset the clipping. g.setClip(clip); } 
public boolean hasCodeChanged ( ) { return codeChanged ; } 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue ) { Show the progress dialog final ProgressDialog d = new ProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); TODO: Make thread interruptable. Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { TODO: Check if rendered node is not null. TODO: Export activeNetwork. try { exportLibrary.setFrame(frame); TODO: Make nodes that have parameters referring to FRAME dirty. See NodeBoxDocument#setFrame(frame) exportLibrary.getRootNode().update(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); TODO: Make sure this code is not repeated from exportToFile. File exportFile = new File(directory, exportPrefix + "-" + frame + ".pdf"); Object outputValue = exportLibrary.getRootNode().getRenderedChild().getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; PDFRenderer.render(g, exportFile); } else { throw new RuntimeException("This type of output cannot be exported " + outputValue); } } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); } }); } } }); t.start(); } 
public void run ( ) { d . tick ( ) ; } 
public void run ( ) { d . setVisible ( false ) ; } 
private void startValueTag ( Attributes attributes ) throws SAXException { if ( currentParameter = = null ) throw new SAXException ( " Value tag encountered without current parameter. " ) ; If the prototype parameter has an expression clear it, or the node will fail to load. if (currentParameter.hasExpression()) currentParameter.clearExpression(); state = ParseState.IN_VALUE; characterData = new StringBuffer(); The value tag should be empty except when the parameter type is code. Then the value tag has a type attribute that specifies the code type. if (currentParameter.getType() != Parameter.Type.CODE) return; String type = attributes.getValue(VALUE_TYPE); if (type == null) throw new SAXException("Type attribute is required in code type parameters."); try { currentCodeType = CodeType.valueOf(type.toUpperCase(Locale.US)); 
public void testLoadingOverriddenExpression ( ) { NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary library = manager . load ( new File ( " test/polynodes.ndbx " ) ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node rect = manager . getNode ( " polynodes.rect " ) ; Node rect1 = rect . newInstance ( testLibrary , " rect1 " ) ; rect1 . clearExpression ( " height " ) ; rect1 . setValue ( " height " , 120 ) ; rect1 . setExpression ( " y " , " x+20 " ) ; rect1 . setExported ( true ) ; manager = new NodeLibraryManager ( ) ; manager . add ( library ) ; NodeLibrary newLibrary = null ; try { newLibrary = NodeLibrary . load ( " test " , testLibrary . toXml ( ) , manager ) ; assertNotNull ( newLibrary ) ; manager . add ( newLibrary ) ; } catch ( RuntimeException e ) { fail ( e . getMessage ( ) ) ; } Perform the same check for a parameter without expression but whose parent have an expression set, but whose original prototype doesn't. rect = manager.getNode("test.rect1"); Node rect2 = rect.newInstance(newLibrary, "rect2"); assertEquals("x+20", rect2.getParameter("y").getExpression()); rect2.clearExpression("y"); rect2.setValue("y", 20); manager = new NodeLibraryManager(); manager.add(library); manager.add(newLibrary); try { newLibrary = NodeLibrary.load("test", newLibrary.toXml(), manager); 
public boolean exportToFile ( File file ) { return exportToFile ( file , activeNetwork ) ; } 
public boolean exportToFile ( File file , Node exportNetwork ) { Make sure the file ends with ".pdf". String fullPath = null; try { fullPath = file.getCanonicalPath(); } catch (IOException e) { throw new RuntimeException("Unable to access file " + file, e); } if (!fullPath.toLowerCase(Locale.US).endsWith(".pdf")) { fullPath = fullPath.concat(".pdf"); } file = new File(fullPath); todo: file export only works on grobs. if (exportNetwork == null || exportNetwork.getRenderedChild() == null) return false; Object outputValue = exportNetwork.getRenderedChild().getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue ) { Show the progress dialog final ProgressDialog d = new ProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); TODO: Make thread interruptable. Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { TODO: Check if rendered node is not null. TODO: Export activeNetwork. try { exportLibrary.setFrame(frame); TODO: Make nodes that have parameters referring to FRAME dirty. See NodeBoxDocument#setFrame(frame) exportLibrary.getRootNode().update(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); File exportFile = new File(directory, exportPrefix + "-" + frame + ".pdf"); exportToFile(exportFile, exportLibrary.getRootNode()); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); } }); } } }); t.start(); } 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue ) { Show the progress dialog final ProgressDialog d = new ProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); TODO: Make thread interruptable. Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { TODO: Check if rendered node is not null. Node exportNetwork = exportLibrary.getRootNode(); try { exportLibrary.setFrame(frame); markTimeDependentNodesDirty(exportNetwork, frame); exportNetwork.update(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); File exportFile = new File(directory, exportPrefix + "-" + frame + ".pdf"); exportToFile(exportFile, exportNetwork); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); } }); } } }); t.start(); } 
public void actionPerformed ( ActionEvent actionEvent ) { if ( thread ! = null ) thread . interrupt ( ) ; 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue ) { Show the progress dialog final ProgressDialog d = new InterruptableProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { if (Thread.currentThread().isInterrupted()) break; TODO: Check if rendered node is not null. Node exportNetwork = exportLibrary.getRootNode(); try { exportLibrary.setFrame(frame); markTimeDependentNodesDirty(exportNetwork, frame); exportNetwork.update(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); File exportFile = new File(directory, exportPrefix + "-" + frame + ".pdf"); exportToFile(exportFile, exportNetwork); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Object outputValue = network . getOutputValue ( ) ; g2 . translate ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; if ( outputValue instanceof Grob ) { if ( outputValue instanceof nodebox . graphics . Canvas ) 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue ) { Show the progress dialog final ProgressDialog d = new InterruptableProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); final Node exportNetwork = exportLibrary.getRootNode(); final ExportViewer viewer = new ExportViewer(exportNetwork); Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { if (Thread.currentThread().isInterrupted()) break; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); markTimeDependentNodesDirty(exportNetwork, frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); File exportFile = new File(directory, exportPrefix + "-" + frame + ".pdf"); exportToFile(exportFile, exportNetwork); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } 
private void startParameterTag ( Attributes attributes ) throws SAXException { String name = attributes . getValue ( PARAMETER_NAME ) ; String typeAsString = attributes . getValue ( PARAMETER_TYPE ) ; if ( currentNode = = null ) throw new SAXException ( " Parameter tag encountered without a current node. " ) ; if ( name = = null ) throw new SAXException ( " Name is required for parameter on node ' " + currentNode . getName ( ) + " '. " ) ; if ( typeAsString = = null ) { No type attribute was given, so the parameter should already exist. currentParameter = currentNode.getParameter(name); if (currentParameter == null) throw new SAXException("Parameter '" + name + "' for node '" + currentNode.getName() + "' does not exist."); } else { Parameter.Type type = Parameter.Type.valueOf(typeAsString.toUpperCase(Locale.US)); if (currentNode.hasParameter(name)) { currentParameter = currentNode.getParameter(name); currentParameter.setType(type); } else { Type was given, so this is a new parameter. currentParameter = currentNode.addParameter(name, type); } } Parse parameter attributes. String widget = attributes.getValue(PARAMETER_WIDGET); String label = attributes.getValue(PARAMETER_LABEL); String helpText = attributes.getValue(PARAMETER_HELP_TEXT); String displayLevel = attributes.getValue(PARAMETER_DISPLAY_LEVEL); String enableExpression = attributes.getValue(PARAMETER_ENABLE_EXPRESSION); String boundingMethod = attributes.getValue(PARAMETER_BOUNDING_METHOD); String minimumValue = attributes.getValue(PARAMETER_MINIMUM_VALUE); String maximumValue = attributes.getValue(PARAMETER_MAXIMUM_VALUE); if (widget != null) currentParameter.setWidget(Parameter.Widget.valueOf(widget.toUpperCase(Locale.US))); if (label != null) currentParameter.setLabel(label); if (helpText != null) currentParameter.setHelpText(helpText); if (displayLevel != null) currentParameter.setDisplayLevel(Parameter.DisplayLevel.valueOf(displayLevel.toUpperCase(Locale.US))); if (enableExpression != null) currentParameter.setEnableExpression(enableExpression); if (boundingMethod != null) currentParameter.setBoundingMethod(Parameter.BoundingMethod.valueOf(boundingMethod.toUpperCase(Locale.US))); if (minimumValue != null) currentParameter.setMinimumValue(Float.parseFloat(minimumValue)); if (maximumValue != null) currentParameter.setMaximumValue(Float.parseFloat(maximumValue)); 
public void testInvalidParameterFormat ( ) { String NODE_HEADER = NDBX_HEADER + " <node name= \" dot1 \" prototype= \" testlib.dot \" > " ; String NODE_FOOTER = " </node> " + NDBX_FOOTER ; Name is required assertParsingFails(NODE_HEADER + "<param></param>" + NODE_FOOTER, ""); Strictly speaking, mentioning an existing parameter is not invalid, just useless. parseXml(NODE_HEADER + "<param name=\"x\"/>" + NODE_FOOTER); Unknown name, and no value or type given assertParsingFails(NODE_HEADER + "<param name=\"test\"></param>" + NODE_FOOTER, "does not exist"); Unknown name, and no type given assertParsingFails(NODE_HEADER + "<param name=\"test\"><value>hello</value></param>" + NODE_FOOTER, "does not exist"); Valid name, but value is of wrong type assertParsingFails(NODE_HEADER + "<param name=\"x\"><value>hello</value></param>" + NODE_FOOTER, "could not parse"); Valid name, but value is in invalid tag assertParsingFails(NODE_HEADER + "<param name=\"x\"><float>hello</float></param>" + NODE_FOOTER, "unknown tag float"); TODO: check if these checks can go Type parameter indicates a new parameter needs to be created, but a parameter with this name already exists assertParsingFails(NODE_HEADER + "<param name=\"x\" type=\"string\"><value>hello</value></param>" + NODE_FOOTER, "already exists"); Same as above, but type is now the same as prototype's. This should not make a difference though. assertParsingFails(NODE_HEADER + "<param name=\"x\" type=\"float\"><value>20.0</value></param>" + NODE_FOOTER, "already exists"); Unknown name, but type and value given, so new parameter was created. parseXml(NODE_HEADER + "<param name=\"test\" type=\"string\"><value>hello</value></param>" + NODE_FOOTER); } 
public void testLoadingChangedType ( ) { NodeLibraryManager manager = new NodeLibraryManager ( ) ; manager . load ( new File ( " test/polynodes.ndbx " ) ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node polyRect = manager . getNode ( " polynodes.rect " ) ; Node myrect = polyRect . newInstance ( testLibrary , " myrect " ) ; myrect . getParameter ( " x " ) . setType ( Parameter . Type . INT ) ; String xml = testLibrary . toXml ( ) ; assertOnlyOnce ( xml , " name= \" x \" " ) ; try { manager . load ( " test " , xml ) ; 
public void testLoadingChangedWidget ( ) { NodeLibrary library = new NodeLibrary ( " lib " ) ; Node alpha = Node . ROOT_NODE . newInstance ( library , " alpha " ) ; alpha . addParameter ( " x " , Parameter . Type . FLOAT ) ; alpha . setValue ( " x " , 20 ) ; alpha . addParameter ( " y " , Parameter . Type . INT ) ; alpha . setValue ( " x " , 30 ) ; alpha . addParameter ( " s " , Parameter . Type . STRING ) ; alpha . setValue ( " s " , " hello " ) ; alpha . setExported ( true ) ; NodeLibraryManager manager = new NodeLibraryManager ( ) ; NodeLibrary newLibrary = manager . load ( " newlib " , library . toXml ( ) ) ; Node = manager . getNode ( " newlib.alpha " ) ; NodeLibrary testLibrary = new NodeLibrary ( " test " ) ; Node alpha1 = . newInstance ( testLibrary , " alpha1 " ) ; alpha1 . getParameter ( " x " ) . setWidget ( Parameter . Widget . INT ) ; alpha1 . getParameter ( " y " ) . setWidget ( Parameter . Widget . TOGGLE ) ; alpha1 . getParameter ( " s " ) . setWidget ( Parameter . Widget . MENU ) ; String xml = testLibrary . toXml ( ) ; assertOnlyOnce ( xml , " name= \" x \" " ) ; assertOnlyOnce ( xml , " name= \" y \" " ) ; assertOnlyOnce ( xml , " name= \" s \" " ) ; try { manager . load ( " test " , xml ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { doCancel ( ) ; } 
private void doExport ( ) { exportPrefix = prefixField . getText ( ) ; try { fromValue = Integer . valueOf ( fromField . getText ( ) ) ; } catch ( NumberFormatException e ) { fromValue = 1 ; } try { toValue = Integer . valueOf ( toField . getText ( ) ) ; } catch ( NumberFormatException e ) { toValue = 100 ; } dialogSuccessful = true ; setVisible ( false ) ; } 
public boolean isDialogSuccessful ( ) { return dialogSuccessful ; } 
public boolean exportRange ( ) { File exportDirectory = lastExportPath = = null ? null : new File ( lastExportPath ) ; ExportRangeDialog d = new ExportRangeDialog ( this , exportDirectory ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; String exportPrefix = d . getExportPrefix ( ) ; File directory = d . getExportDirectory ( ) ; int fromValue = d . getFromValue ( ) ; int toValue = d . getToValue ( ) ; if ( directory = = null ) return false ; lastExportPath = directory . getAbsolutePath ( ) ; exportRange ( exportPrefix , directory , fromValue , toValue ) ; return true ; } 
public void actionPerformed ( ActionEvent e ) { if ( PlatformUtils . onMac ( ) ) { On Mac, we can use the native FileDialog to choose a directory using a special property. 
public boolean exportRange ( ) { File exportDirectory = lastExportPath = = null ? null : new File ( lastExportPath ) ; if ( exportDirectory ! = null & & ! exportDirectory . exists ( ) ) exportDirectory = null ; ExportRangeDialog d = new ExportRangeDialog ( this , exportDirectory ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; String exportPrefix = d . getExportPrefix ( ) ; File directory = d . getExportDirectory ( ) ; int fromValue = d . getFromValue ( ) ; int toValue = d . getToValue ( ) ; if ( directory = = null ) return false ; lastExportPath = directory . getAbsolutePath ( ) ; exportRange ( exportPrefix , directory , fromValue , toValue ) ; return true ; } 
public void showAbout ( ) { String javaVersion = System . getProperty ( " java.runtime.version " ) ; JOptionPane . showMessageDialog ( null , NAME + " version " + getVersion ( ) + " nJava " + javaVersion , NAME , JOptionPane . INFORMATION_MESSAGE ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( isEnabled ( ) ) { if ( checked ) { g2 . drawImage ( checkedImage , 0 , 0 , null ) ; } else { g2 . drawImage ( normalImage , 0 , 0 , null ) ; } } else { if ( mode = = Mode . CHECK & & checked ) { g2 . drawImage ( checkDisabledOn , 0 , 0 , null ) ; } else if ( mode = = Mode . CHECK & & ! checked ) { g2 . drawImage ( checkDisabledOff , 0 , 0 , null ) ; } else { Composite oldComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 0.5f ) ) ; g2 . drawImage ( normalImage , 0 , 0 , null ) ; g2 . setComposite ( oldComposite ) ; } } int w = normalImage . getWidth ( null ) ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; if ( warn ) { g2 . setColor ( Theme . TEXT_WARNING_COLOR ) ; } else if ( armed ) { g2 . setColor ( Theme . TEXT_ARMED_COLOR ) ; } else if ( ! isEnabled ( ) ) { g2 . setColor ( Theme . TEXT_DISABLED_COLOR ) ; } else { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } SwingUtils . drawShadowText ( g2 , text , w + IMAGE_TEXT_MARGIN , TEXT_BASELINE ) ; } 
public static SawtoothWave from ( float min , float max , float period ) { float amplitude = ( max - min ) / 2 ; float offset = min + amplitude ; return new SawtoothWave ( period , 0f , amplitude , offset ) ; } 
protected float computeValue ( float phase ) { return ( ( phase / TWO_PI ) * 2 - 1 ) * amplitude ; } 
public static SineWave from ( float min , float max , float period ) { float amplitude = ( max - min ) / 2 ; float offset = min + amplitude ; return new SineWave ( period , 0f , amplitude , offset ) ; } 
protected float computeValue ( float phase ) { return ( float ) Math . sin ( phase ) * amplitude ; } 
public static SquareWave from ( float min , float max , float period ) { float amplitude = ( max - min ) / 2 ; float offset = min + amplitude ; return new SquareWave ( period , 0f , amplitude , offset ) ; } 
protected float computeValue ( float phase ) { return ( phase / TWO_PI < 0.5 ? 1 : - 1 ) * amplitude ; } 
public static TriangleWave from ( float min , float max , float period ) { float amplitude = ( max - min ) / 2 ; float offset = min + amplitude ; return new TriangleWave ( period , 0f , amplitude , offset ) ; } 
protected float computeValue ( float phase ) { return Math . abs ( ( phase / TWO_PI ) * 2 - 1 ) * amplitude * 2 - amplitude ; } 
public static double sinewave ( double frame , double min , double max , double speed ) { AbstractWave wave = SineWave . from ( ( float ) min , ( float ) max , ( float ) speed ) ; return wave . getValueAt ( ( float ) frame ) ; } 
public static double trianglewave ( double frame , double min , double max , double speed ) { AbstractWave wave = TriangleWave . from ( ( float ) min , ( float ) max , ( float ) speed ) ; return wave . getValueAt ( ( float ) frame ) ; } 
public static double squarewave ( double frame , double min , double max , double speed ) { AbstractWave wave = SquareWave . from ( ( float ) min , ( float ) max , ( float ) speed ) ; return wave . getValueAt ( ( float ) frame ) ; } 
public static double sawtoothwave ( double frame , double min , double max , double speed ) { AbstractWave wave = SawtoothWave . from ( ( float ) min , ( float ) max , ( float ) speed ) ; return wave . getValueAt ( ( float ) frame ) ; } 
public static double hold ( double frame , double minFrame , double functionValue , double defaultValue ) { return frame < minFrame ? defaultValue : functionValue ; } 
public void testConvertFromMinMax ( ) { AbstractWave w = SineWave . from ( - 20 , 20 , 100 ) ; assertEquals ( 20 f , w . getAmplitude ( ) ) ; assertEquals ( 0f , w . getOffset ( ) ) ; w = SineWave . from ( - 25 , 35 , 100 ) ; assertEquals ( 30 f , w . getAmplitude ( ) ) ; assertEquals ( 5f , w . getOffset ( ) ) ; w = SineWave . from ( - 35 , 25 , 100 ) ; assertEquals ( 30 f , w . getAmplitude ( ) ) ; assertEquals ( - 5f , w . getOffset ( ) ) ; assertEquals ( 100 f , w . getPeriod ( ) ) ; w = SawtoothWave . from ( - 20 , 20 , 100 ) ; assertEquals ( 20 f , w . getAmplitude ( ) ) ; assertEquals ( 0f , w . getOffset ( ) ) ; w = SquareWave . from ( - 25 , 35 , 100 ) ; assertEquals ( 30 f , w . getAmplitude ( ) ) ; assertEquals ( 5f , w . getOffset ( ) ) ; w = TriangleWave . from ( - 35 , 25 , 100 ) ; assertEquals ( 30 f , w . getAmplitude ( ) ) ; assertEquals ( - 5f , w . getOffset ( ) ) ; } 
public void testSineWave ( ) { SineWave w = new SineWave ( 120 , 20 ) ; assertEquals ( 0f , w . getValueAt ( 0 ) ) ; assertEquals ( 20 f , w . getValueAt ( 30 ) ) ; todo: assertAlmostEquals(0f, w.getValueAt(60)); assertEquals(-20f, w.getValueAt(90)); assertEquals(0f, w.getValueAt(120)); } 
public static double wave ( AbstractWave . Type type , double min , double max , double speed , double frame ) { float fmin = ( float ) min ; float fmax = ( float ) max ; float fspeed = ( float ) speed ; AbstractWave wave ; switch ( type ) { case TRIANGLE : wave = TriangleWave . from ( fmin , fmax , fspeed ) ; break ; case SQUARE : wave = SquareWave . from ( fmin , fmax , fspeed ) ; break ; case SAWTOOTH : wave = SawtoothWave . from ( fmin , fmax , fspeed ) ; break ; case SINE : default : wave = SineWave . from ( fmin , fmax , fspeed ) ; break ; } return wave . getValueAt ( ( float ) frame ) ; } 
public static double wave ( AbstractWave . Type type , double . . . values ) { double frame = currentContext . getFrame ( ) ; switch ( values . length ) { case 0 : 
public static double wave ( AbstractWave . Type type ) { return wave ( type , 0 , 1 , 60 , currentContext . getFrame ( ) ) ; } 
public static double wave ( AbstractWave . Type type , double min ) { return wave ( type , min , 1 , 60 , currentContext . getFrame ( ) ) ; } 
public static double wave ( AbstractWave . Type type , double min , double max ) { return wave ( type , min , max , 60 , currentContext . getFrame ( ) ) ; } 
public static double wave ( AbstractWave . Type type , double min , double max , double speed ) { return wave ( type , min , max , speed , currentContext . getFrame ( ) ) ; } 
public static double wave ( ) { return wave ( AbstractWave . Type . SINE , 0 , 1 , 60 , currentContext . getFrame ( ) ) ; } 
public static double wave ( AbstractWave . Type type , double max ) { return wave ( type , 0 , max , 60 , currentContext . getFrame ( ) ) ; } 
public static double hold ( double minFrame , double functionValue , double . . . values ) { double frame = currentContext . getFrame ( ) ; switch ( values . length ) { case 1 : 
public static double hold ( double minFrame , double functionValue ) { return hold ( minFrame , functionValue , 0 , currentContext . getFrame ( ) ) ; } 
public static double hold ( double minFrame , double functionValue , double defaultValue ) { return hold ( minFrame , functionValue , defaultValue , currentContext . getFrame ( ) ) ; } 
public static double hold ( double minFrame , double functionValue , double defaultValue , double frame ) { return frame < minFrame ? defaultValue : functionValue ; } 
public static double schedule ( double start , double end , double functionValue , double . . . values ) { double frame = currentContext . getFrame ( ) ; switch ( values . length ) { case 1 : 
public static double schedule ( double start , double end , double functionValue ) { return schedule ( start , end , functionValue , 0 , currentContext . getFrame ( ) ) ; } 
public static double schedule ( double start , double end , double functionValue , double defaultValue ) { return schedule ( start , end , functionValue , defaultValue , currentContext . getFrame ( ) ) ; } 
public static double schedule ( double start , double end , double functionValue , double defaultValue , double frame ) { return start < = frame & & frame < end ? functionValue : defaultValue ; } 
public static double timeloop ( double speed , List < Number > values ) { return timeloop ( speed , values , currentContext . getFrame ( ) ) ; } 
public static double timeloop ( double speed , List < Number > values , double frame ) { if ( values . size ( ) = = 0 ) return 0 ; int index = ( int ) ( frame / speed ) ; try { return values . get ( index % values . size ( ) ) . doubleValue ( ) ; 
public static void render ( Grob g , File file ) { render ( g , g . getBounds ( ) , null , file ) ; } 
public static void render ( Grob g , Rect bounds , Color background , File file ) { I'm using fully qualified class names here so as not to polute the class' namespace. com.itextpdf.text.Rectangle size = new com.itextpdf.text.Rectangle(bounds.getWidth(), bounds.getHeight()); com.itextpdf.text.Document document = new com.itextpdf.text.Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } com.itextpdf.text.pdf.PdfWriter writer; try { writer = com.itextpdf.text.pdf.PdfWriter.getInstance(document, fos); } catch (com.itextpdf.text.DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); com.itextpdf.text.pdf.PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = contentByte.createGraphics(bounds.getWidth(), bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); if (background != null) { graphics.setColor(background.getAwtColor()); graphics.fillRect((int) bounds.getX(), (int) bounds.getY(), (int) bounds.getWidth(), (int) bounds.getHeight()); } g.draw(graphics); graphics.dispose(); document.close(); } 
public boolean exportToFile ( File file , Node exportNetwork ) { Make sure the file ends with ".pdf". String fullPath = null; try { fullPath = file.getCanonicalPath(); } catch (IOException e) { throw new RuntimeException("Unable to access file " + file, e); } if (!fullPath.toLowerCase(Locale.US).endsWith(".pdf")) { fullPath = fullPath.concat(".pdf"); } file = new File(fullPath); todo: file export only works on grobs. if (exportNetwork == null) return false; Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; 
public void draw ( Graphics2D g ) { if ( background ! = null ) { g . setColor ( background . getAwtColor ( ) ) ; g . fill ( getBounds ( ) . getRectangle2D ( ) ) ; g.fillRect(0, 0, Math.round(width), Math.round(height)); } Rectangle clip = g.getClipBounds(); int clipwidth = clip != null && width > clip.width ? clip.width : (int) height; int clipheight = clip != null && height > clip.height ? clip.height : (int) width; g.setClip(clip != null ? clip.x : 0, clip != null ? clip.y : 0, clipwidth, clipheight); g.clip(getBounds().getRectangle2D()); for (Grob grob : items) { grob.draw(g); 
public static void render ( Grob g , File file ) { I'm using fully qualified class names here so as not to polute the class' namespace. Rect bounds = g.getBounds(); com.itextpdf.text.Rectangle size = new com.itextpdf.text.Rectangle(bounds.getWidth(), bounds.getHeight()); com.itextpdf.text.Document document = new com.itextpdf.text.Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } com.itextpdf.text.pdf.PdfWriter writer; try { writer = com.itextpdf.text.pdf.PdfWriter.getInstance(document, fos); } catch (com.itextpdf.text.DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); com.itextpdf.text.pdf.PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = contentByte.createGraphics(bounds.getWidth(), bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); g.draw(graphics); graphics.dispose(); document.close(); } 
private static void load ( NodeLibrary library , InputStream is , NodeLibraryManager manager ) throws IOException , ParserConfigurationException , SAXException { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; SAXParser parser = spf . newSAXParser ( ) ; NDBXHandler handler = new NDBXHandler ( library , manager ) ; parser . parse ( is , handler ) ; setCanvasParameter ( library , " canvasX " ) ; setCanvasParameter ( library , " canvasY " ) ; setCanvasParameter ( library , " canvasWidth " ) ; setCanvasParameter ( library , " canvasHeight " ) ; setCanvasParameter ( library , " canvasBackground " ) ; } 
public Object cook ( Node node , ProcessingContext context ) { Object o = Node . ROOT_NODE . cook ( node , context ) ; if ( o instanceof Geometry ) { Geometry geo = ( Geometry ) o ; 
public void draw ( Graphics2D g ) { if ( background ! = null ) { g . setColor ( background . getAwtColor ( ) ) ; g . fill ( getBounds ( ) . getRectangle2D ( ) ) ; } g . clip ( getBounds ( ) . getRectangle2D ( ) ) ; for ( Grob grob : items ) { grob . draw ( g ) ; 
public static void render ( Grob g , File file ) { I'm using fully qualified class names here so as not to pollute the class' namespace. Rect bounds = g.getBounds(); com.itextpdf.text.Rectangle size = new com.itextpdf.text.Rectangle(bounds.getWidth(), bounds.getHeight()); com.itextpdf.text.Document document = new com.itextpdf.text.Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } com.itextpdf.text.pdf.PdfWriter writer; try { writer = com.itextpdf.text.pdf.PdfWriter.getInstance(document, fos); } catch (com.itextpdf.text.DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); com.itextpdf.text.pdf.PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = contentByte.createGraphics(bounds.getWidth(), bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); g.draw(graphics); graphics.dispose(); document.close(); } 
public void showAbout ( ) { String javaVersion = System . getProperty ( " java.runtime.version " ) ; JOptionPane . showMessageDialog ( null , NAME + " version " + getVersion ( ) + " nJava " + javaVersion , NAME , JOptionPane . INFORMATION_MESSAGE ) ; } 
public boolean exportRange ( ) { File exportDirectory = lastExportPath = = null ? null : new File ( lastExportPath ) ; if ( exportDirectory ! = null & & ! exportDirectory . exists ( ) ) exportDirectory = null ; ExportRangeDialog d = new ExportRangeDialog ( this , exportDirectory ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; String exportPrefix = d . getExportPrefix ( ) ; File directory = d . getExportDirectory ( ) ; int fromValue = d . getFromValue ( ) ; int toValue = d . getToValue ( ) ; if ( directory = = null ) return false ; lastExportPath = directory . getAbsolutePath ( ) ; exportRange ( exportPrefix , directory , fromValue , toValue ) ; return true ; } 
public Object cook ( Node node , ProcessingContext context ) { Object o = Node . ROOT_NODE . cook ( node , context ) ; We also wrap null, which is the result if there are no child nodes. if (o == null || o instanceof Geometry) { Canvas canvas = new Canvas(); 
public NodeBoxDocument createNewDocument ( ) { NodeLibrary newLibrary = new NodeLibrary ( " untitled " ) ; Node root = newLibrary . getRootNode ( ) ; Node rectNode = root . create ( manager . getNode ( " corevector.rect " ) ) ; rectNode . setPosition ( 40 , 40 ) ; rectNode . setRendered ( ) ; NodeBoxDocument doc = new NodeBoxDocument ( newLibrary ) ; addDocument ( doc ) ; return doc ; } 
public void receive ( NodeEvent event ) { if ( ! ( event instanceof ValueChangedEvent ) ) return ; if ( ( ( ValueChangedEvent ) event ) . getParameter ( ) ! = parameter ) return ; if ( ! isVisible ( ) ) return ; setValueForControl ( parameter . getValue ( ) ) ; } 
public void receive ( NodeEvent event ) { if ( event instanceof ValueChangedEvent ) { if ( event . getSource ( ) ! = node ) return ; 
public Parameter getParameter ( ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; } 
public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; } 
private static void load ( NodeLibrary library , InputStream is , NodeLibraryManager manager ) throws IOException , ParserConfigurationException , SAXException { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; SAXParser parser = spf . newSAXParser ( ) ; NDBXHandler handler = new NDBXHandler ( library , manager ) ; parser . parse ( is , handler ) ; setCanvasParameter ( library , CANVAS_X ) ; setCanvasParameter ( library , CANVAS_Y ) ; setCanvasParameter ( library , CANVAS_WIDTH ) ; setCanvasParameter ( library , CANVAS_HEIGHT ) ; setCanvasParameter ( library , CANVAS_BACKGROUND ) ; } 
private void putBounds ( float x , float y , float width , float height ) { put ( WIDTH , width ) ; put ( HEIGHT , height ) ; put ( TOP , y - height / 2 ) ; put ( LEFT , x - width / 2 ) ; put ( BOTTOM , y + height / 2 ) ; put ( RIGHT , x + width / 2 ) ; } 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue ) { Show the progress dialog final ProgressDialog d = new InterruptableProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); final Node exportNetwork = exportLibrary.getRootNode(); final ExportViewer viewer = new ExportViewer(exportNetwork); Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { if (Thread.currentThread().isInterrupted()) break; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); File exportFile = new File(directory, exportPrefix + "-" + frame + ".pdf"); exportToFile(exportFile, exportNetwork); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public void addExternalDependency ( Parameter p , ExternalEvent event ) { HashSet < Parameter > parameters = externalDependencies . get ( event ) ; if ( parameters = = null ) { parameters = new HashSet < Parameter > ( ) ; externalDependencies . put ( event , parameters ) ; } parameters . add ( p ) ; } 
public void removeExternalDependencies ( Parameter p ) { for ( HashSet < Parameter > parameters : externalDependencies . values ( ) ) { for ( Iterator < Parameter > iterator = parameters . iterator ( ) ; iterator . hasNext ( ) ; ) { 
public void externalDependencyTriggered ( ExternalEvent event ) { HashSet < Parameter > parameters = externalDependencies . get ( event ) ; if ( parameters ! = null ) { for ( Parameter p : parameters ) { 
public void receive ( NodeEvent event ) { if ( event . getSource ( ) ! = getRootNode ( ) ) return ; if ( ! ( event instanceof ValueChangedEvent ) ) return ; ValueChangedEvent vce = ( ValueChangedEvent ) event ; if ( ! vce . getParameter ( ) . getName ( ) . startsWith ( " canvas " ) ) return ; externalDependencyTriggered ( ExternalEvent . CANVAS ) ; } 
public void clearExpression ( ) { this . expression = null ; hasStampExpression = false ; removeDependencies ( ) ; removeExternalDependencies ( ) ; markDirty ( ) ; } 
private void removeExternalDependencies ( ) { getLibrary ( ) . removeExternalDependencies ( this ) ; } 
public void removedEvent ( ) { removeDependencies ( ) ; removeExternalDependencies ( ) ; removeDependents ( ) ; } 
public void testExternalDependencies ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node root = library . getRootNode ( ) ; Node = root . create ( Node . ROOT_NODE , " " ) ; Parameter p = . addParameter ( " p " , Parameter . Type . FLOAT ) ; . update ( ) ; assertFalse ( . isDirty ( ) ) ; After setting the external dependency on the parameter, triggering the dependency makes the node dirty. library.addExternalDependency(p, NodeLibrary.ExternalEvent.FRAME); library.externalDependencyTriggered(NodeLibrary.ExternalEvent.FRAME); assertTrue(n.isDirty()); Updating the node makes it clean. n.update(); assertFalse(n.isDirty()); After removing all external dependencies on the parameter, triggering an external dependency does not make the node dirty. library.removeExternalDependencies(p); library.externalDependencyTriggered(NodeLibrary.ExternalEvent.FRAME); assertFalse(n.isDirty()); } 
public void testFrameDependency ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node root = library . getRootNode ( ) ; Node = root . create ( Node . ROOT_NODE , " " ) ; Parameter p = . addParameter ( " p " , Parameter . Type . FLOAT ) ; Setting the expression to frame declares an external dependency on the parameter. p.setExpression("FRAME + 5"); n.update(); assertFalse(n.isDirty()); Changing the frame should trigger the external dependency. library.setFrame(100); assertTrue(n.isDirty()); n.update(); assertFalse(n.isDirty()); assertEquals(105f, p.asFloat()); Clearing the expression removes the external dependency. p.clearExpression(); Update the node again to make it clean. n.update(); assertFalse(n.isDirty()); assertEquals(105f, p.asFloat()); Because we no longer refer to frame, setting the frame does not mark the node dirty. library.setFrame(200); assertFalse(n.isDirty()); } 
public void testCanvasDependency ( ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node root = library . getRootNode ( ) ; Node = root . create ( Node . ROOT_NODE , " " ) ; . setRendered ( ) ; Parameter p = . addParameter ( " p " , Parameter . Type . FLOAT ) ; Setting the expression to WIDTH declares an external dependency on the parameter. p.setExpression("WIDTH / 2"); root.update(); assertFalse(n.isDirty()); Changing the canvas values should trigger the external dependency. root.setValue(NodeLibrary.CANVAS_WIDTH, 500f); assertTrue(n.isDirty()); n.update(); assertFalse(n.isDirty()); assertEquals(250f, p.asFloat()); Clearing the expression removes the external dependency. p.clearExpression(); Update the node again to make it clean. n.update(); assertFalse(n.isDirty()); assertEquals(250f, p.asFloat()); Because we no longer refer to frame, setting the frame does not mark the node dirty. root.setValue(NodeLibrary.CANVAS_WIDTH, 400f); assertFalse(n.isDirty()); } 
public File temporaryFileForFrame ( int frame ) { return new File ( String . format ( temporaryFileTemplate , frame ) ) ; } 
public void save ( ) { StringWriter sw = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( sw , true ) ; String type = codecTypeMap . get ( codecType ) ; int bitRate = bitRateForSize ( width , height ) ; String quality = compressionQualityMap . get ( compressionQuality ) ; ArrayList < String > commandList = new ArrayList < String > ( ) ; commandList . add ( FFMPEG_BINARY . getAbsolutePath ( ) ) ; commandList . add ( " -y " ) ; Overwrite target if exists commandList.add("-i"); commandList.add(temporaryFileTemplate); Input images commandList.add("-vcodec"); commandList.add(type); Target video codec if (codecType == CodecType.H264) { commandList.add("-fpre"); commandList.add(String.format(FFMPEG_PRESET_TEMPLATE, quality)); } else { commandList.add("-b"); commandList.add(bitRate + "k"); Target bit rate } commandList.add(movieFilename); Target file name ProcessBuilder pb = new ProcessBuilder(commandList); if (verbose) { for (String cmd : pb.command()) { System.out.print(cmd + " "); } System.out.println(); } pb.redirectErrorStream(true); Process p; try { p = pb.start(); p.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = in.readLine()) != null) out.println(line); p.waitFor(); if (verbose) { System.out.println(sw.toString()); } } catch (IOException e) { cleanupAndThrowException(e); } catch (InterruptedException e) { cleanupAndThrowException(e); } cleanup(); } 
private int bitRateForSize ( int width , int height ) { return 1000 ; } 
public void cleanup ( ) { for ( int i = 0 ; i < frameCount ; i + + ) { temporaryFileForFrame ( i ) . delete ( ) ; 
private void cleanupAndThrowException ( Throwable ) { cleanup ( ) ; throw new RuntimeException ( ) ; } 
public static void main ( String [ ] args ) { int width = 640 ; int height = 480 ; Create a new movie. Movie movie = new Movie("test.mov", width, height); movie.setVerbose(true); / Initialize an image to draw on. BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); Graphics2D g = (Graphics2D) img.getGraphics(); g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); for (int frame = 0; frame < 20; frame++) { System.out.println("frame = " + frame); Clear the canvas and draw some simple circles. g.setColor(Color.WHITE); g.fillRect(0, 0, width, height); Random r = new Random(0); for (int j = 0; j < 100; j++) { g.setColor(new Color(r.nextInt(255), 255, r.nextInt(255))); g.fillOval(r.nextInt(width) + frame, r.nextInt(height) + frame, 30, 30); } Add the image to the movie. movie.addFrame(img); } Export the movie. movie.save(); } 
public boolean exportMovie ( ) { File chosenFile = FileUtils . showSaveDialog ( this , lastExportPath , " mov " , " MOV file " ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; return exportToMovieFile ( chosenFile ) ; } return false ; } 
private boolean exportToMovieFile ( File file ) { String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = exportNetwork . getRoot ( ) . getParameter ( NodeLibrary . CANVAS_WIDTH ) . asInt ( ) ; final int height = exportNetwork . getRoot ( ) . getParameter ( NodeLibrary . CANVAS_HEIGHT ) . asInt ( ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; for ( int frame = 0 ; frame < = 100 ; frame + + ) { exportLibrary . setFrame ( frame ) ; markTimeDependentNodesDirty ( exportNetwork , frame ) ; exportNetwork . update ( ) ; Object outputValue = exportNetwork . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2d = img . createGraphics ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . translate ( width / 2 , height / 2 ) ; g . draw ( g2d ) ; img . flush ( ) ; movie . addFrame ( img ) ; } else return false ; } movie . save ( ) ; return true ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . exportMovie ( ) ; } 
public static void main ( String [ ] args ) { for ( String arg : args ) { if ( arg . contains ( " --enable-movie-export " ) ) { FLAG_ENABLE_MOVIE_EXPORT = true ; } } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
private boolean exportToMovieFile ( File file ) { String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = exportNetwork . getRoot ( ) . getParameter ( NodeLibrary . CANVAS_WIDTH ) . asInt ( ) ; final int height = exportNetwork . getRoot ( ) . getParameter ( NodeLibrary . CANVAS_HEIGHT ) . asInt ( ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; for ( int frame = 0 ; frame < = 100 ; frame + + ) { exportLibrary . setFrame ( frame ) ; exportNetwork . update ( ) ; Object outputValue = exportNetwork . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2d = img . createGraphics ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . translate ( width / 2 , height / 2 ) ; g . draw ( g2d ) ; img . flush ( ) ; movie . addFrame ( img ) ; } else return false ; } movie . save ( ) ; return true ; } 
public NodeBoxDocument createNewDocument ( ) { NodeLibrary newLibrary = new NodeLibrary ( " untitled " ) ; NodeBoxDocument doc = new NodeBoxDocument ( newLibrary ) ; addDocument ( doc ) ; return doc ; } 
private boolean exportToMovieFile ( File file ) { String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = exportNetwork . getRoot ( ) . getParameter ( NodeLibrary . CANVAS_WIDTH ) . asInt ( ) ; final int height = exportNetwork . getRoot ( ) . getParameter ( NodeLibrary . CANVAS_HEIGHT ) . asInt ( ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; for ( int frame = 0 ; frame < = 100 ; frame + + ) { exportLibrary . setFrame ( frame ) ; exportNetwork . update ( ) ; Object outputValue = exportNetwork . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2d = img . createGraphics ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . translate ( width / 2 , height / 2 ) ; g . draw ( g2d ) ; img . flush ( ) ; movie . addFrame ( img ) ; } else return false ; } movie . save ( ) ; return true ; } 
private void hideSpotlightPanel ( ) { setVisible ( false ) ; We don't need the glass pane anymore. Toolkit.getDefaultToolkit().removeAWTEventListener(this.eventListener); Remove our reference to the network pane. Since panes can change, holding on to the network pane would cause a memory leak. networkPane = null; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Mask out the spotlight The point refers to the location of the "new node" button in the network pane. This position is hard-coded. Point pt = SwingUtilities.convertPoint(networkPane, 159, 12, getRootPane()); Rectangle2D screen = new Rectangle2D.Double(0, 0, getWidth(), getHeight()); Ellipse2D spotlight = new Ellipse2D.Float(pt.x - 42, pt.y - 42, 84, 84); Area mask = new Area(screen); mask.subtract(new Area(spotlight)); Fill the mask g2.setColor(new Color(0, 0, 0, 100)); g2.fill(mask); } 
private void doExport ( ) { try { fromValue = Integer . valueOf ( fromField . getText ( ) ) ; } catch ( NumberFormatException e ) { fromValue = 1 ; } try { toValue = Integer . valueOf ( toField . getText ( ) ) ; } catch ( NumberFormatException e ) { toValue = 100 ; } dialogSuccessful = true ; setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { String path = exportPath = = null ? null : exportPath . getAbsolutePath ( ) ; File chosenFile = FileUtils . showSaveDialog ( NodeBoxDocument . getCurrentDocument ( ) , path , " mov " , " MOV file " ) ; setExportPath ( chosenFile ! = null ? chosenFile : this . exportPath ) ; } 
public static void main ( String [ ] args ) { ExportMovieDialog d = new ExportMovieDialog ( null , null ) ; d . setVisible ( true ) ; } 
public boolean exportMovie ( ) { ExportMovieDialog d = new ExportMovieDialog ( this , lastExportPath = = null ? null : new File ( lastExportPath ) ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; File chosenFile = d . getExportPath ( ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; return exportToMovieFile ( chosenFile , d . getFromValue ( ) , d . getToValue ( ) ) ; } return false ; } 
private boolean exportToMovieFile ( File file , final int fromValue , final int toValue ) { String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { exportLibrary . setFrame ( frame ) ; exportNetwork . update ( ) ; Object outputValue = exportNetwork . getOutputValue ( ) ; if ( outputValue instanceof Grob ) { Grob g = ( Grob ) outputValue ; BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2d = img . createGraphics ( ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . translate ( width / 2 , height / 2 ) ; g . draw ( g2d ) ; img . flush ( ) ; movie . addFrame ( img ) ; } else return false ; } movie . save ( ) ; return true ; } 
public boolean exportMovie ( ) { ExportMovieDialog d = new ExportMovieDialog ( this , lastExportPath = = null ? null : new File ( lastExportPath ) ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; File chosenFile = d . getExportPath ( ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; exportToMovieFile ( chosenFile , d . getFromValue ( ) , d . getToValue ( ) ) ; return true ; } return false ; } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , " Exporting... " , toValue - fromValue + 1 ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); Graphics2D g2d = img.createGraphics(); g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g2d.translate(width / 2, height / 2); g.draw(g2d); img.flush(); movie.addFrame(img); } else break; } movie.save(); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , " Exporting... " , toValue - fromValue + 1 ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); Graphics2D g2d = img.createGraphics(); g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); Rect bounds = g.getBounds(); g2d.translate(-bounds.getX(), -bounds.getY()); g.draw(g2d); img.flush(); movie.addFrame(img); } else break; } movie.save(); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public void save ( StringWriter sw ) { PrintWriter out = new PrintWriter ( sw , true ) ; String type = codecTypeMap . get ( codecType ) ; int bitRate = bitRateForSize ( width , height ) ; String quality = compressionQualityMap . get ( compressionQuality ) ; ArrayList < String > commandList = new ArrayList < String > ( ) ; commandList . add ( FFMPEG_BINARY . getAbsolutePath ( ) ) ; commandList . add ( " -y " ) ; Overwrite target if exists commandList.add("-i"); commandList.add(temporaryFileTemplate); Input images commandList.add("-vcodec"); commandList.add(type); Target video codec if (codecType == CodecType.H264) { commandList.add("-fpre"); commandList.add(String.format(FFMPEG_PRESET_TEMPLATE, quality)); } else { commandList.add("-b"); commandList.add(bitRate + "k"); Target bit rate } commandList.add(movieFilename); Target file name ProcessBuilder pb = new ProcessBuilder(commandList); if (verbose) { for (String cmd : pb.command()) { System.out.print(cmd + " "); } System.out.println(); } pb.redirectErrorStream(true); Process p; try { p = pb.start(); p.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = in.readLine()) != null) out.println(line); p.waitFor(); if (verbose) { System.out.println(sw.toString()); } } catch (IOException e) { cleanupAndThrowException(e); } catch (InterruptedException e) { cleanupAndThrowException(e); } cleanup(); } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , null , toValue - fromValue + 1 ) ; d . setTitle ( " Exporting " + ( toValue - fromValue + 1 ) + " frames... " ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); Graphics2D g2d = img.createGraphics(); g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); Rect bounds = g.getBounds(); g2d.translate(-bounds.getX(), -bounds.getY()); g.draw(g2d); img.flush(); movie.addFrame(img); } else break; } d.setTitle("Converting frames to movie..."); d.reset(); FramesWriter w = new FramesWriter(d); movie.save(w); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; 
public void reset ( int taskCount ) { this . taskCount = taskCount ; this . tasksCompleted = 0 ; } 
public void updateProgress ( ) { updateProgress ( this . tasksCompleted ) ; } 
public void updateProgress ( int tasksCompleted ) { progressBar . setValue ( tasksCompleted ) ; double percentage = ( double ) ( tasksCompleted ) / ( double ) ( taskCount ) ; int ip = ( int ) ( percentage * 100 ) ; progressLabel . setText ( ip + " % " ) ; repaint ( ) ; } 
public static double random ( Object seed , double . . . minmax ) { switch ( minmax . length ) { case 0 : 
public static double random ( Object seed ) { randomGenerator . setSeed ( seed . hashCode ( ) ) ; return randomGenerator . nextDouble ( ) ; } 
public static double random ( Object seed , double max ) { return random ( seed ) * max ; } 
public static double random ( Object seed , double min , double max ) { return min + random ( seed ) * ( max - min ) ; } 
public static int randint ( Object seed , int min , int max ) { randomGenerator . setSeed ( seed . hashCode ( ) ) ; nextInt's specified value is exclusive, whereas we want to include it, so add 1. return min + randomGenerator.nextInt(max - min + 1); } 
public void testRandom ( ) throws ExpressionError { Node alpha = Node . ROOT_NODE . newInstance ( testLibrary , " alpha " ) ; Parameter pFloat = alpha . addParameter ( " float " , Parameter . Type . FLOAT ) ; assertExpressionAlmostEquals ( ExpressionHelper . random ( 1 ) , pFloat , " random(1) " ) ; assertExpressionAlmostEquals ( ExpressionHelper . random ( ( double ) 1 ) , pFloat , " random((double)1) " ) ; } 
public void assertExpressionAlmostEquals ( double expected , Parameter p , String expression ) throws ExpressionError { We don't catch the ExpressionError but let it bubble up. p.setExpression(expression); p.update(new ProcessingContext(p.getNode())); assertEquals(expected, p.asFloat(), 0.001); } 
public Geometry asGeometry ( ) { return asGeometry ( true ) ; } 
public Geometry asGeometry ( boolean clone ) { Geometry g = new Geometry ( ) ; for ( Grob item : items ) { if ( item instanceof Path ) g . add ( ( Path ) ( clone ? item . clone ( ) : item ) ) ; else if ( item instanceof Text ) g . add ( ( ( Text ) item ) . getPath ( ) ) ; else if ( item instanceof Geometry ) g . extend ( ( Geometry ) ( clone ? item . clone ( ) : item ) ) ; } return g ; } 
public static double random ( Object seed ) { if ( seed instanceof Number ) { Number number = ( Number ) seed ; randomGenerator . setSeed ( number . longValue ( ) * 100000000 ) ; } else { randomGenerator . setSeed ( seed . hashCode ( ) ) ; } return randomGenerator . nextDouble ( ) ; } 
public static int randint ( Object seed , int min , int max ) { if ( seed instanceof Number ) { Number number = ( Number ) seed ; randomGenerator . setSeed ( number . longValue ( ) * 100000000 ) ; } else { randomGenerator . setSeed ( seed . hashCode ( ) ) ; } nextInt's specified value is exclusive, whereas we want to include it, so add 1. return min + randomGenerator.nextInt(max - min + 1); } 
public PyObject __findattr_ex__ ( String name ) { if ( " node " . equals ( name ) ) return Py . java2py ( node ) ; if ( " context " . equals ( name ) ) return Py . java2py ( context ) ; Parameter p = node . getParameter ( name ) ; if ( p = = null ) { Port port = node . getPort ( name ) ; 
public void pasteSelected ( ) { Node newParent = getNode ( ) ; NodeLibrary clipboardLibrary = Application . getInstance ( ) . getNodeClipboard ( ) ; if ( clipboardLibrary = = null ) return ; Node clipboardRoot = clipboardLibrary . getRootNode ( ) ; if ( clipboardRoot . size ( ) = = 0 ) return ; Collection < Node > newNodes = getDocument ( ) . copyChildren ( clipboardRoot . getChildren ( ) , clipboardRoot , newParent ) ; deselectAll ( ) ; for ( Node newNode : newNodes ) { nodebox . graphics . Point pt = newNode . getPosition ( ) ; 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue ) { Show the progress dialog final ProgressDialog d = new InterruptableProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); exportLibrary.setFile(nodeLibrary.getFile()); final Node exportNetwork = exportLibrary.getRootNode(); final ExportViewer viewer = new ExportViewer(exportNetwork); Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { if (Thread.currentThread().isInterrupted()) break; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); File exportFile = new File(directory, exportPrefix + "-" + frame + ".pdf"); exportToFile(exportFile, exportNetwork); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , null , toValue - fromValue + 1 ) ; d . setTitle ( " Exporting " + ( toValue - fromValue + 1 ) + " frames... " ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; exportLibrary . setFile ( nodeLibrary . getFile ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof Grob) { Grob g = (Grob) outputValue; BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); Graphics2D g2d = img.createGraphics(); g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); Rect bounds = g.getBounds(); g2d.translate(-bounds.getX(), -bounds.getY()); g.draw(g2d); img.flush(); movie.addFrame(img); } else break; } d.setTitle("Converting frames to movie..."); d.reset(); FramesWriter w = new FramesWriter(d); movie.save(w); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; 
protected void paintComponent ( Graphics g ) { g . drawImage ( notesBackgroundImage , ParameterView . LABEL_WIDTH , 0 , getWidth ( ) , 20 , null ) ; } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { int labelWidth = ParameterView . LABEL_WIDTH ; Draw border on the side of the label g.setColor(LABEL_UP_COLOR); g.fillRect(x, y + height - 2, labelWidth - 2, 1); g.setColor(LABEL_DOWN_COLOR); g.fillRect(x, y + height - 1, labelWidth - 2, 1); Draw border on parameter side g.setColor(PARAMETER_UP_COLOR); g.fillRect(x + labelWidth, y + height - 2, width - labelWidth, 1); g.setColor(PARAMETER_DOWN_COLOR); g.fillRect(x + labelWidth + 1, y + height - 1, width - labelWidth - 1, 1); } 
public static ImageFormat of ( String name ) { return FORMAT_MAP . get ( name . toUpperCase ( ) ) ; } 
public File ensureFileExtension ( File file ) { return new File ( ensureFileExtension ( file . getPath ( ) ) ) ; } 
public String ensureFileExtension ( String file ) { String baseName = nodebox . util . FileUtils . stripExtension ( file ) ; return baseName + " . " + getExtension ( ) ; } 
public boolean exportToFile ( File file , ImageFormat format ) { return exportToFile ( file , activeNetwork , format ) ; } 
public boolean exportToFile ( File file , Node exportNetwork , ImageFormat format ) { file = format . ensureFileExtension ( file ) ; if ( exportNetwork = = null ) return false ; Object outputValue = exportNetwork . getOutputValue ( ) ; if ( outputValue instanceof nodebox . graphics . Canvas ) { nodebox . graphics . Canvas c = ( nodebox . graphics . Canvas ) outputValue ; 
public boolean export ( ) { File chosenFile = FileUtils . showSaveDialog ( this , lastExportPath , " pdf " , " PDF file " ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; return exportToFile ( chosenFile , ImageFormat . PDF ) ; } return false ; } 
public boolean exportRange ( ) { File exportDirectory = lastExportPath = = null ? null : new File ( lastExportPath ) ; if ( exportDirectory ! = null & & ! exportDirectory . exists ( ) ) exportDirectory = null ; ExportRangeDialog d = new ExportRangeDialog ( this , exportDirectory ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; String exportPrefix = d . getExportPrefix ( ) ; File directory = d . getExportDirectory ( ) ; int fromValue = d . getFromValue ( ) ; int toValue = d . getToValue ( ) ; ImageFormat format = d . getFormat ( ) ; if ( directory = = null ) return false ; lastExportPath = directory . getAbsolutePath ( ) ; exportRange ( exportPrefix , directory , fromValue , toValue , format ) ; return true ; } 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue , final ImageFormat format ) { Show the progress dialog final ProgressDialog d = new InterruptableProgressDialog(this, "Exporting...", toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); exportLibrary.setFile(nodeLibrary.getFile()); final Node exportNetwork = exportLibrary.getRootNode(); final ExportViewer viewer = new ExportViewer(exportNetwork); Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { if (Thread.currentThread().isInterrupted()) break; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); File exportFile = new File(directory, exportPrefix + "-" + frame); exportToFile(exportFile, exportNetwork, format); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , null , toValue - fromValue + 1 ) ; d . setTitle ( " Exporting " + ( toValue - fromValue + 1 ) + " frames... " ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; exportLibrary . setFile ( nodeLibrary . getFile ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof nodebox.graphics.Canvas) { nodebox.graphics.Canvas c = (nodebox.graphics.Canvas) outputValue; movie.addFrame(c.asImage()); } else break; } d.setTitle("Converting frames to movie..."); d.reset(); FramesWriter w = new FramesWriter(d); movie.save(w); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public BufferedImage asImage ( ) { Rect bounds = getBounds ( ) ; BufferedImage img = new BufferedImage ( Math . round ( bounds . getWidth ( ) ) , Math . round ( bounds . getHeight ( ) ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = img . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . translate ( - bounds . getX ( ) , - bounds . getY ( ) ) ; draw ( g ) ; img . flush ( ) ; return img ; } 
public void testEnsureFileFormat ( ) { assertEquals ( " test.pdf " , ImageFormat . PDF . ensureFileExtension ( " test " ) ) ; assertEquals ( " test.pdf " , ImageFormat . PDF . ensureFileExtension ( " test. " ) ) ; assertEquals ( " test.pdf " , ImageFormat . PDF . ensureFileExtension ( " test.png " ) ) ; assertEquals ( " test.pdf " , ImageFormat . PDF . ensureFileExtension ( " test.png " ) ) ; assertEquals ( " test.pdf " , ImageFormat . PDF . ensureFileExtension ( " test.something " ) ) ; assertEquals ( " test.something.pdf " , ImageFormat . PDF . ensureFileExtension ( " test.something.png " ) ) ; assertEquals ( " /a/b/c.pdf " , ImageFormat . PDF . ensureFileExtension ( " /a/b/c " ) ) ; assertEquals ( " /a/b/c.pdf " , ImageFormat . PDF . ensureFileExtension ( " /a/b/c.png " ) ) ; } 
public String ensureFileExtension ( String file ) { if ( file . endsWith ( " . " + getExtension ( ) ) ) return file ; return file + " . " + getExtension ( ) ; } 
public void testEnsureFileFormat ( ) { assertEquals ( " test.pdf " , ImageFormat . PDF . ensureFileExtension ( " test " ) ) ; assertEquals ( " test.pdf " , ImageFormat . PDF . ensureFileExtension ( " test.pdf " ) ) ; assertEquals ( " test..pdf " , ImageFormat . PDF . ensureFileExtension ( " test. " ) ) ; assertEquals ( " test.png.pdf " , ImageFormat . PDF . ensureFileExtension ( " test.png " ) ) ; assertEquals ( " test.something.pdf " , ImageFormat . PDF . ensureFileExtension ( " test.something " ) ) ; assertEquals ( " a.b.c.pdf " , ImageFormat . PDF . ensureFileExtension ( " a.b.c " ) ) ; assertEquals ( " /a/b/c.pdf " , ImageFormat . PDF . ensureFileExtension ( " /a/b/c " ) ) ; assertEquals ( " /a/b/c.png.pdf " , ImageFormat . PDF . ensureFileExtension ( " /a/b/c.png " ) ) ; assertEquals ( new File ( " /a/b.test/c.pdf " ) . getAbsolutePath ( ) , ImageFormat . PDF . ensureFileExtension ( new File ( " /a/b.test/c " ) ) . getAbsolutePath ( ) ) ; } 
public void testStripExtension ( ) { assertEquals ( " test " , FileUtils . stripExtension ( " test.ndbx " ) ) ; assertEquals ( " MixedCase " , FileUtils . stripExtension ( " MixedCase.GIF " ) ) ; Retain case assertEquals("a.lot.of.dots", FileUtils.stripExtension("a.lot.of.dots.dot")); Extension = last dot assertEquals("noextension", FileUtils.stripExtension("noextension")); assertEquals("/a/b/c.d/some", FileUtils.stripExtension("/a/b/c.d/some.file")); Dots in path name assertEquals("", FileUtils.stripExtension("")); Retain case } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { if ( Application . ENABLE_PANE_CUSTOMIZATION ) { if ( e . getX ( ) < this . getWidth ( ) - 20 ) return ; paneOptionsMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; if ( Application . ENABLE_PANE_CUSTOMIZATION ) { g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; } } } 
public void mousePressed ( MouseEvent e ) { if ( Application . ENABLE_PANE_CUSTOMIZATION ) { if ( e . getX ( ) < this . getWidth ( ) - 20 ) return ; 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; if ( Application . ENABLE_PANE_CUSTOMIZATION ) { g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; } } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } @Override protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; if ( Application . ENABLE_PANE_CUSTOMIZATION ) { g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; } } } 
public void mouseExited ( MouseEvent e ) { } @Override protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; if ( Application . ENABLE_PANE_CUSTOMIZATION ) { g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; } } } 
protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; if ( Application . ENABLE_PANE_CUSTOMIZATION ) { g . drawImage ( paneHeaderOptions , getWidth ( ) - 20 , 0 , null ) ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Full width minus left side and right side int contentWidth = getWidth() - 9 - 21; if (isEnabled()) { g.drawImage(paneMenuLeft, 0, 0, null); g.drawImage(paneMenuBackground, 9, 0, contentWidth, 21, null); g.drawImage(paneMenuRight, 9 + contentWidth, 0, null); } g2.setFont(Theme.SMALL_BOLD_FONT); g2.setColor(Theme.TEXT_NORMAL_COLOR); int textPosition = 9; if (!isEnabled()) { textPosition += 18; } SwingUtils.drawShadowText(g2, getMenuName(), textPosition, 14); } 
private void applyPreferences ( ) { Preferences preferences = Preferences . userNodeForPackage ( this . getClass ( ) ) ; ENABLE_PANE_CUSTOMIZATION = Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_PANE_CUSTOMIZATION , " false " ) ) ; } 
public void showPreferences ( ) { PreferencesDialog dialog = new PreferencesDialog ( ) ; dialog . setModal ( true ) ; dialog . setVisible ( true ) ; } 
public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . showPreferences ( ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Full width minus left side and right side int contentWidth = getWidth() - 9 - 21; if (isEnabled()) { g.drawImage(paneMenuLeft, 0, 0, null); g.drawImage(paneMenuBackground, 9, 0, contentWidth, 21, null); g.drawImage(paneMenuRight, 9 + contentWidth, 0, null); } g2.setFont(Theme.SMALL_BOLD_FONT); g2.setColor(Theme.TEXT_NORMAL_COLOR); int textPosition = isEnabled() ? 9 : 5; SwingUtils.drawShadowText(g2, getMenuName(), textPosition, 14); } 
private void readPreferences ( ) { this . preferences = Preferences . userNodeForPackage ( Application . class ) ; enablePaneCustomizationCheck . setSelected ( Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_PANE_CUSTOMIZATION , " false " ) ) ) ; 
public void run ( ) { startupDialog = new ProgressDialog ( null , " Starting " + NAME ) ; startupDialog . setVisible ( true ) ; } 
public void run ( ) { Create the user's NodeBox library directories. try { setNodeBoxVersion(); 
private void load ( ) { Initialize Jython Thread t = new Thread(new PythonLoader()); t.start(); } 
public void run ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { startupDialog . setMessage ( " Loading Python " ) ; } } ) ; manager = new NodeLibraryManager ( ) ; manager . addSearchPath ( PlatformUtils . getApplicationScriptsDirectory ( ) ) ; manager . addSearchPath ( PlatformUtils . getUserScriptsDirectory ( ) ) ; manager . lookForLibraries ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { int tasks = manager . getLibraries ( ) . size ( ) + 1 ; startupDialog . setTaskCount ( tasks ) ; startupDialog . setMessage ( " Loading Python " ) ; } } ) ; PythonUtils . initializePython ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { startupDialog . setMessage ( " Loading Python " ) ; } 
public void run ( ) { int tasks = manager . getLibraries ( ) . size ( ) + 1 ; startupDialog . setTaskCount ( tasks ) ; startupDialog . setMessage ( " Loading Python " ) ; 
public void exportRange ( final String exportPrefix , final File directory , final int fromValue , final int toValue , final ImageFormat format ) { Show the progress dialog final ProgressDialog d = new InterruptableProgressDialog(this, "Exporting..."); d.setTaskCount(toValue - fromValue + 1); d.setVisible(true); d.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); d.setAlwaysOnTop(true); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); exportLibrary.setFile(nodeLibrary.getFile()); final Node exportNetwork = exportLibrary.getRootNode(); final ExportViewer viewer = new ExportViewer(exportNetwork); Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { if (Thread.currentThread().isInterrupted()) break; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); File exportFile = new File(directory, exportPrefix + "-" + frame); exportToFile(exportFile, exportNetwork, format); } } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , null ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setTitle ( " Exporting " + ( toValue - fromValue + 1 ) + " frames... " ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; exportLibrary . setFile ( nodeLibrary . getFile ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof nodebox.graphics.Canvas) { nodebox.graphics.Canvas c = (nodebox.graphics.Canvas) outputValue; movie.addFrame(c.asImage()); } else break; } d.setTitle("Converting frames to movie..."); d.reset(); FramesWriter w = new FramesWriter(d); movie.save(w); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public void close ( ) { stopAnimation ( ) ; if ( shouldClose ( ) ) { renderThread.shutdown(); 
private void run ( ) { showProgressDialog ( ) ; startupWorker = new SwingWorker < Throwable , String > ( ) { @Override protected Throwable doInBackground ( ) throws Exception { try { publish ( " Starting NodeBox " ) ; setNodeBoxVersion ( ) ; createNodeBoxDataDirectories ( ) ; applyPreferences ( ) ; registerForMacOSXEvents ( ) ; updater = new Updater ( Application . this ) ; updater . checkForUpdatesInBackground ( ) ; publish ( " Loading Python " ) ; initPython ( ) ; } catch ( RuntimeException ex ) { return ex ; } return null ; } @Override protected void process ( List < String > strings ) { final String firstString = strings . get ( 0 ) ; startupDialog . setMessage ( firstString ) ; } @Override protected void done ( ) { startingUp . set ( false ) ; startupDialog . setVisible ( false ) ; See if application startup has generated an exception. Throwable t; try { t = get(); } catch (Exception e) { t = e; } if (t != null) { ExceptionDialog ed = new ExceptionDialog(null, t); ed.setVisible(true); System.exit(-1); } if (documents.isEmpty() && filesToLoad.isEmpty()) { instance.createNewDocument(); } else { for (File f : filesToLoad) { openDocument(f); } } } }; startupWorker.execute(); } 
protected Throwable doInBackground ( ) throws Exception { try { publish ( " Starting NodeBox " ) ; setNodeBoxVersion ( ) ; createNodeBoxDataDirectories ( ) ; applyPreferences ( ) ; registerForMacOSXEvents ( ) ; updater = new Updater ( Application . this ) ; updater . checkForUpdatesInBackground ( ) ; publish ( " Loading Python " ) ; initPython ( ) ; } catch ( RuntimeException ex ) { return ex ; } return null ; } 
protected void process ( List < String > strings ) { final String firstString = strings . get ( 0 ) ; startupDialog . setMessage ( firstString ) ; } 
protected void done ( ) { startingUp . set ( false ) ; startupDialog . setVisible ( false ) ; See if application startup has generated an exception. Throwable t; try { t = get(); } catch (Exception e) { t = e; } if (t != null) { ExceptionDialog ed = new ExceptionDialog(null, t); ed.setVisible(true); System.exit(-1); } if (documents.isEmpty() && filesToLoad.isEmpty()) { instance.createNewDocument(); 
private void initLastResortHandler ( ) { Thread . currentThread ( ) . setUncaughtExceptionHandler ( new LastResortHandler ( ) ) ; } 
private void initLookAndFeel ( ) { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception ignored ) { } System . setProperty ( " apple.laf.useScreenMenuBar " , " true " ) ; } 
private void showProgressDialog ( ) { startupDialog = new ProgressDialog ( null , " Starting " + NAME ) ; startupDialog . setVisible ( true ) ; } 
private void setNodeBoxVersion ( ) throws RuntimeException { Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( " version.properties " ) ) ; 
private void registerForMacOSXEvents ( ) throws RuntimeException { if ( ! PlatformUtils . onMac ( ) ) return ; try { Generate and register the OSXAdapter, passing it a hash of all the methods we wish to use as delegates for various com.apple.eawt.ApplicationListener methods OSXAdapter.setQuitHandler(this, getClass().getDeclaredMethod("quit", (Class[]) null)); OSXAdapter.setAboutHandler(this, getClass().getDeclaredMethod("showAbout", (Class[]) null)); OSXAdapter.setPreferencesHandler(this, getClass().getDeclaredMethod("showPreferences", (Class[]) null)); OSXAdapter.setFileHandler(this, getClass().getDeclaredMethod("readFromFile", String.class)); } catch (Exception e) { throw new RuntimeException("Error while loading the OS X Adapter.", e); } On the Mac, if all windows are closed the menu bar will be empty. To solve this, we create an off-screen window with the same menu bar as visible windows. hiddenFrame = new JFrame(); hiddenFrame.setJMenuBar(new NodeBoxMenuBar()); hiddenFrame.setUndecorated(true); hiddenFrame.setSize(0, 0); hiddenFrame.setLocation(-100, -100); hiddenFrame.pack(); hiddenFrame.setVisible(true); } 
private void initPython ( ) { manager = new NodeLibraryManager ( ) ; manager . addSearchPath ( PlatformUtils . getApplicationScriptsDirectory ( ) ) ; manager . addSearchPath ( PlatformUtils . getUserScriptsDirectory ( ) ) ; manager . lookForLibraries ( ) ; PythonUtils . initializePython ( ) ; } 
public void readFromFile ( String path ) { This method looks unused, but is actually called using reflection by the OS X adapter. If the application is still starting up, don't open the document immediately but place it in a file loading queue. if (startingUp.get()) { filesToLoad.add(new File(path)); 
public static void main ( String [ ] args ) { for ( String arg : args ) { if ( arg . contains ( " --enable-movie-export " ) ) { FLAG_ENABLE_MOVIE_EXPORT = true ; } } final Application app = new Application ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { app . run ( ) ; } 
public void restoreState ( UndoState state ) { NodeLibrary nodeLibrary = NodeLibrary . load ( document . getNodeLibrary ( ) . getName ( ) , state . xml , document . getManager ( ) ) ; nodeLibrary . setFile ( document . getNodeLibrary ( ) . getFile ( ) ) ; document . setNodeLibrary ( nodeLibrary ) ; document . setActiveNetwork ( state . activeNetworkPath ) ; if ( state . activeNodeName ! = null ) { Node child = document . getActiveNetwork ( ) . getChild ( state . activeNodeName ) ; 
public void actionPerformed ( ActionEvent e ) { String path = exportPath = = null ? null : exportPath . getAbsolutePath ( ) ; File chosenFile = FileUtils . showSaveDialog ( NodeBoxDocument . getCurrentDocument ( ) , path , " mov,avi,mp4 " , " Movie files " ) ; setExportPath ( chosenFile ! = null ? chosenFile : this . exportPath ) ; } 
public void save ( StringWriter sw ) { PrintWriter out = new PrintWriter ( sw , true ) ; String type = codecTypeMap . get ( codecType ) ; int bitRate = bitRateForSize ( width , height ) ; String quality = compressionQualityMap . get ( compressionQuality ) ; ArrayList < String > commandList = new ArrayList < String > ( ) ; commandList . add ( FFMPEG_BINARY . getAbsolutePath ( ) ) ; commandList . add ( " -y " ) ; Overwrite target if exists commandList.add("-i"); commandList.add(temporaryFileTemplate); Input images commandList.add("-vcodec"); commandList.add(type); Target video codec if (codecType == CodecType.H264) { commandList.add("-fpre"); commandList.add(String.format(FFMPEG_PRESET_TEMPLATE, quality)); } else { commandList.add("-b"); commandList.add(bitRate + "k"); Target bit rate } commandList.add("-f"); commandList.add(formatMap.get(format)); commandList.add(movieFilename); Target file name ProcessBuilder pb = new ProcessBuilder(commandList); if (verbose) { for (String cmd : pb.command()) { System.out.print(cmd + " "); } System.out.println(); } pb.redirectErrorStream(true); Process p; try { p = pb.start(); p.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = in.readLine()) != null) out.println(line); p.waitFor(); if (verbose) { System.out.println(sw.toString()); } } catch (IOException e) { cleanupAndThrowException(e); } catch (InterruptedException e) { cleanupAndThrowException(e); } cleanup(); } 
public static MovieFormat of ( String name ) { return FORMAT_MAP . get ( name . toUpperCase ( ) ) ; } 
public boolean exportMovie ( ) { ExportMovieDialog d = new ExportMovieDialog ( this , lastExportPath = = null ? null : new File ( lastExportPath ) ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; File chosenFile = d . getExportPath ( ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; TODO: support different codec types as well. exportToMovieFile(chosenFile, d.getFromValue(), d.getToValue(), d.getQuality(), d.getFormat()); return true; } return false; } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue , final Movie . CompressionQuality quality , final MovieFormat format ) { final ProgressDialog d = new InterruptableProgressDialog ( this , null ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setTitle ( " Exporting " + ( toValue - fromValue + 1 ) + " frames... " ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; file = format . ensureFileExtension ( file ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; exportLibrary . setFile ( nodeLibrary . getFile ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height , Movie . CodecType . H264 , quality , format , false ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof nodebox.graphics.Canvas) { nodebox.graphics.Canvas c = (nodebox.graphics.Canvas) outputValue; movie.addFrame(c.asImage()); } else break; } d.setTitle("Converting frames to movie..."); d.reset(); FramesWriter w = new FramesWriter(d); movie.save(w); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
private java . util . List < Node > sortNodes ( java . util . List < Node > nodes , String searchString ) { java . util . List < Node > sortedNodes = new ArrayList < Node > ( ) ; java . util . List < Node > startsWithNodes = new ArrayList < Node > ( ) ; java . util . List < Node > containsNodes = new ArrayList < Node > ( ) ; java . util . List < Node > descriptionNodes = new ArrayList < Node > ( ) ; for ( Node node : nodes ) { if ( node . getName ( ) . equals ( searchString ) ) sortedNodes . add ( node ) ; else if ( node . getName ( ) . startsWith ( searchString ) ) startsWithNodes . add ( node ) ; else if ( node . getName ( ) . contains ( searchString ) ) containsNodes . add ( node ) ; else descriptionNodes . add ( node ) ; } Collections . sort ( startsWithNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( startsWithNodes ) ; Collections . sort ( containsNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( containsNodes ) ; Collections . sort ( descriptionNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( descriptionNodes ) ; return sortedNodes ; } 
private void applyPreferences ( ) { Preferences preferences = Preferences . userNodeForPackage ( this . getClass ( ) ) ; ENABLE_PANE_CUSTOMIZATION = Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_PANE_CUSTOMIZATION , " false " ) ) ; ENABLE_MOVIE_EXPORT = Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_MOVIE_EXPORT , " false " ) ) ; } 
public static void main ( String [ ] args ) { final Application app = new Application ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
private void readPreferences ( ) { this . preferences = Preferences . userNodeForPackage ( Application . class ) ; enablePaneCustomizationCheck . setSelected ( Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_PANE_CUSTOMIZATION , " false " ) ) ) ; enableMovieExportCheck . setSelected ( Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_MOVIE_EXPORT , " false " ) ) ) ; } 
public void actionPerformed ( ActionEvent e ) { java . util . List < Pane > documentPanes = getDocument ( ) . getDocumentPanes ( ) ; for ( Pane pane : documentPanes ) { if ( pane instanceof NetworkPane ) { ( ( NetworkPane ) pane ) . createNewNode ( ) ; return ; } } JOptionPane . showMessageDialog ( getDocument ( ) , " Please make sure a network view is present in the document. " , " Warning " , JOptionPane . WARNING_MESSAGE ) ; } 
public void playAnimation ( ) { document . playAnimation ( ) ; } 
public void rewindAnimation ( ) { document . rewindAnimation ( ) ; } 
public void playAnimation ( ) { animationTimer . start ( ) ; } 
public void rewindAnimation ( ) { stopAnimation ( ) ; setFrame ( 1 ) ; } 
public void playAnimation ( ) { if ( ! playButton . isChecked ( ) ) playButton . setChecked ( true ) ; document . playAnimation ( ) ; playButton . setText ( " Stop " ) ; playButton . setToolTipText ( " Stop Animation " ) ; playButton . setActionMethod ( this , " stopAnimation " ) ; forcePlayButtonWidth ( 45 ) ; } 
public void stopAnimation ( ) { if ( playButton . isChecked ( ) ) playButton . setChecked ( false ) ; document . stopAnimation ( ) ; playButton . setText ( " Play " ) ; playButton . setToolTipText ( " Play Animation " ) ; playButton . setActionMethod ( this , " playAnimation " ) ; forcePlayButtonWidth ( 45 ) ; } 
public void rewindAnimation ( ) { stopAnimation ( ) ; document . rewindAnimation ( ) ; } 
private void forcePlayButtonWidth ( int width ) { Dimension d = new Dimension ( width , NButton . BUTTON_HEIGHT ) ; playButton . setSize ( d ) ; playButton . setPreferredSize ( d ) ; playButton . setMinimumSize ( d ) ; playButton . setMaximumSize ( d ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; setCursor ( Cursor . getDefaultCursor ( ) ) ; if ( oldValue ! = value ) fireStateChanged ( ) ; 
public void mouseDragged ( PInputEvent e ) { if ( selectionMarker = = null ) return ; Point2D prev = selectionMarker . getOffset ( ) ; Point2D p = e . getPosition ( ) ; double width = p . getX ( ) - prev . getX ( ) ; double absWidth = Math . abs ( width ) ; double height = p . getY ( ) - prev . getY ( ) ; double absHeight = Math . abs ( height ) ; selectionMarker . setWidth ( absWidth ) ; selectionMarker . setHeight ( absHeight ) ; selectionMarker . setX ( absWidth ! = width ? width : 0 ) ; selectionMarker . setY ( absHeight ! = height ? height : 0 ) ; ListIterator childIter = getLayer ( ) . getChildrenIterator ( ) ; connectionLayer . deselect ( ) ; temporarySelection . clear ( ) ; while ( childIter . hasNext ( ) ) { Object o = childIter . next ( ) ; 
public void mouseEntered ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; if ( ! getCursor ( ) . equals ( draggerCursor ) ) setCursor ( hoverCursor ) ; 
public void mouseExited ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; if ( ! getCursor ( ) . equals ( draggerCursor ) ) setCursor ( Cursor . getDefaultCursor ( ) ) ; 
public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; setCursor ( isDragAreaHovered ( e . getPoint ( ) ) ? hoverCursor : defaultCursor ) ; if ( oldValue ! = value ) fireStateChanged ( ) ; 
private boolean isDragAreaHovered ( Point pt ) { return ( ! getLeftButtonRect ( null ) . contains ( pt ) & & ! getRightButtonRect ( null ) . contains ( pt ) & & 
public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; NodeBoxDocument doc = NodeBoxDocument . getCurrentDocument ( ) ; if ( oldValue ! = value ) fireStateChanged ( ) ; 
public void mouseExited ( MouseEvent e ) { setCursor ( defaultCursor ) ; } 
public void processEvent ( final PInputEvent evt , final int i ) { if ( evt . isMouseEvent ( ) & & evt . isLeftMouseButton ( ) & & panEnabled ) super . processEvent ( evt , i ) ; 
public void keyPressed ( KeyEvent e ) { panEnabled = e . getKeyCode ( ) = = KeyEvent . VK_SPACE ; } 
public void keyReleased ( KeyEvent e ) { panEnabled = false ; } 
public void keyPressed ( KeyEvent e ) { panEnabled = e . getKeyCode ( ) = = KeyEvent . VK_SPACE ; if ( hasVisibleHandle ( ) ) handle . keyPressed ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public void keyReleased ( KeyEvent e ) { panEnabled = false ; if ( hasVisibleHandle ( ) ) handle . keyReleased ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public void keyReleased ( KeyEvent e ) { panEnabled = false ; setCursor ( Cursor . getDefaultCursor ( ) ) ; if ( hasVisibleHandle ( ) ) handle . keyReleased ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
private static File showFileDialog ( Frame owner , String pathName , String extensions , String description , int fileDialogType ) { FileDialog fileDialog = new FileDialog ( owner , pathName , fileDialogType ) ; if ( pathName = = null | | pathName . trim ( ) . length ( ) = = 0 ) { NodeBoxDocument document = NodeBoxDocument . getCurrentDocument ( ) ; if ( document ! = null ) { File documentFile = document . getDocumentFile ( ) ; if ( documentFile ! = null ) { fileDialog . setDirectory ( documentFile . getParentFile ( ) . getPath ( ) ) ; } } } else { File f = new File ( pathName ) ; if ( f . isDirectory ( ) ) { fileDialog . setDirectory ( pathName ) ; } else { fileDialog . setDirectory ( f . getParentFile ( ) . getPath ( ) ) ; fileDialog . setFile ( f . getName ( ) ) ; } } fileDialog . setFilenameFilter ( new FileExtensionFilter ( extensions , description ) ) ; fileDialog . setVisible ( true ) ; String chosenFile = fileDialog . getFile ( ) ; String dir = fileDialog . getDirectory ( ) ; if ( chosenFile ! = null ) { return new File ( dir + chosenFile ) ; 
public void keyPressed ( KeyEvent e ) { panEnabled = e . getKeyCode ( ) = = KeyEvent . VK_SPACE ; if ( panEnabled & & ! getCursor ( ) . equals ( panCursor ) ) setCursor ( panCursor ) ; 
public void keyReleased ( KeyEvent e ) { panEnabled = false ; if ( ! getCursor ( ) . equals ( defaultCursor ) ) setCursor ( defaultCursor ) ; 
public void keyReleased ( KeyEvent e ) { panEnabled = false ; if ( ! getCursor ( ) . equals ( defaultCursor ) ) setCursor ( defaultCursor ) ; if ( hasVisibleHandle ( ) ) handle . keyReleased ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public boolean exportMovie ( ) { ExportMovieDialog d = new ExportMovieDialog ( this , lastExportPath = = null ? null : new File ( lastExportPath ) ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; File chosenFile = d . getExportPath ( ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; TODO: support different codec types as well. exportToMovieFile(chosenFile, d.getFromValue(), d.getToValue(), Movie.CompressionQuality.HIGH, MovieFormat.MP4); return true; } return false; } 
public void save ( StringWriter sw ) { PrintWriter out = new PrintWriter ( sw , true ) ; String type = codecTypeMap . get ( codecType ) ; int bitRate = bitRateForSize ( width , height ) ; ArrayList < String > commandList = new ArrayList < String > ( ) ; commandList . add ( FFMPEG_BINARY . getAbsolutePath ( ) ) ; commandList . add ( " -y " ) ; Overwrite target if exists commandList.add("-i"); commandList.add(temporaryFileTemplate); Input images commandList.add("-vcodec"); commandList.add(type); Target video codec commandList.add("-fpre"); commandList.add(String.format(FFMPEG_PRESET_TEMPLATE, "main")); commandList.add("-fpre"); commandList.add(String.format(FFMPEG_PRESET_TEMPLATE, "slow")); commandList.add("-f"); commandList.add(formatMap.get(format)); commandList.add(movieFilename); Target file name ProcessBuilder pb = new ProcessBuilder(commandList); if (verbose) { for (String cmd : pb.command()) { System.out.print(cmd + " "); } System.out.println(); } pb.redirectErrorStream(true); Process p; try { p = pb.start(); p.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = in.readLine()) != null) out.println(line); p.waitFor(); if (verbose) { System.out.println(sw.toString()); } } catch (IOException e) { cleanupAndThrowException(e); } catch (InterruptedException e) { cleanupAndThrowException(e); } cleanup(); } 
public boolean exportMovie ( ) { ExportMovieDialog d = new ExportMovieDialog ( this , lastExportPath = = null ? null : new File ( lastExportPath ) ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; File chosenFile = d . getExportPath ( ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; TODO: support different codec types as well. exportToMovieFile(chosenFile, d.getFromValue(), d.getToValue()); return true; } return false; } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , null ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setTitle ( " Exporting " + ( toValue - fromValue + 1 ) + " frames... " ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; file = MovieFormat . MP4 . ensureFileExtension ( file ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; exportLibrary . setFile ( nodeLibrary . getFile ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , width , height , Movie . CodecType . H264 , MovieFormat . MP4 , false ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof nodebox.graphics.Canvas) { nodebox.graphics.Canvas c = (nodebox.graphics.Canvas) outputValue; movie.addFrame(c.asImage()); } else break; } d.setTitle("Converting frames to movie..."); d.reset(); FramesWriter w = new FramesWriter(d); movie.save(w); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public void save ( StringWriter sw ) { PrintWriter out = new PrintWriter ( sw , true ) ; String type = DEFAULT_CODEC ; int bitRate = bitRateForSize ( width , height ) ; ArrayList < String > commandList = new ArrayList < String > ( ) ; commandList . add ( FFMPEG_BINARY . getAbsolutePath ( ) ) ; commandList . add ( " -y " ) ; Overwrite target if exists commandList.add("-i"); commandList.add(temporaryFileTemplate); Input images commandList.add("-vcodec"); commandList.add(type); Target video codec commandList.add("-fpre"); commandList.add(String.format(FFMPEG_PRESET_TEMPLATE, "main")); commandList.add("-fpre"); commandList.add(String.format(FFMPEG_PRESET_TEMPLATE, "slow")); commandList.add("-f"); commandList.add(DEFAULT_FORMAT); commandList.add(movieFilename); Target file name ProcessBuilder pb = new ProcessBuilder(commandList); if (verbose) { for (String cmd : pb.command()) { System.out.print(cmd + " "); } System.out.println(); } pb.redirectErrorStream(true); Process p; try { p = pb.start(); p.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = in.readLine()) != null) out.println(line); p.waitFor(); if (verbose) { System.out.println(sw.toString()); } } catch (IOException e) { cleanupAndThrowException(e); } catch (InterruptedException e) { cleanupAndThrowException(e); } cleanup(); } 
private void exportToMovieFile ( File file , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , null ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setTitle ( " Exporting " + ( toValue - fromValue + 1 ) + " frames... " ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; file = MovieFormat.MP4.ensureFileExtension(file); String xml = nodeLibrary.toXml(); final NodeLibrary exportLibrary = NodeLibrary.load(nodeLibrary.getName(), xml, getManager()); exportLibrary.setFile(nodeLibrary.getFile()); final Node exportNetwork = exportLibrary.getRootNode(); final int width = (int) exportNetwork.asFloat(NodeLibrary.CANVAS_WIDTH); final int height = (int) exportNetwork.asFloat(NodeLibrary.CANVAS_HEIGHT); final Movie movie = new Movie(file.getAbsolutePath(), width, height, false); final ExportViewer viewer = new ExportViewer(exportNetwork); Thread t = new Thread(new Runnable() { public void run() { try { for (int frame = fromValue; frame <= toValue; frame++) { if (Thread.currentThread().isInterrupted()) break; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof nodebox.graphics.Canvas) { nodebox.graphics.Canvas c = (nodebox.graphics.Canvas) outputValue; movie.addFrame(c.asImage()); } else break; } d.setTitle("Converting frames to movie..."); d.reset(); FramesWriter w = new FramesWriter(d); movie.save(w); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public boolean exportMovie ( ) { ExportMovieDialog d = new ExportMovieDialog ( this , lastExportPath = = null ? null : new File ( lastExportPath ) ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; File chosenFile = d . getExportPath ( ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; TODO: support different codec types as well. exportToMovieFile(chosenFile, d.getVideoFormat(), d.getFromValue(), d.getToValue()); return true; } return false; } 
private void exportToMovieFile ( File file , final VideoFormat videoFormat , final int fromValue , final int toValue ) { final ProgressDialog d = new InterruptableProgressDialog ( this , null ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setTitle ( " Exporting " + ( toValue - fromValue + 1 ) + " frames... " ) ; d . setVisible ( true ) ; d . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; d . setAlwaysOnTop ( true ) ; file = videoFormat . ensureFileExtension ( file ) ; String xml = nodeLibrary . toXml ( ) ; final NodeLibrary exportLibrary = NodeLibrary . load ( nodeLibrary . getName ( ) , xml , getManager ( ) ) ; exportLibrary . setFile ( nodeLibrary . getFile ( ) ) ; final Node exportNetwork = exportLibrary . getRootNode ( ) ; final int width = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_WIDTH ) ; final int height = ( int ) exportNetwork . asFloat ( NodeLibrary . CANVAS_HEIGHT ) ; final Movie movie = new Movie ( file . getAbsolutePath ( ) , videoFormat , width , height , false ) ; final ExportViewer viewer = new ExportViewer ( exportNetwork ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; TODO: Check if rendered node is not null. try { exportLibrary.setFrame(frame); exportNetwork.update(); viewer.updateFrame(); } catch (Exception e) { e.printStackTrace(); } SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); Object outputValue = exportNetwork.getOutputValue(); if (outputValue instanceof nodebox.graphics.Canvas) { nodebox.graphics.Canvas c = (nodebox.graphics.Canvas) outputValue; movie.addFrame(c.asImage()); } else break; } d.setTitle("Converting frames to movie..."); d.reset(); FramesWriter w = new FramesWriter(d); movie.save(w); } catch (Exception e) { e.printStackTrace(); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); viewer.setVisible(false); } }); } } }); ((InterruptableProgressDialog) d).setThread(t); t.start(); viewer.setVisible(true); } 
public void save ( StringWriter sw ) { PrintWriter out = new PrintWriter ( sw , true ) ; ArrayList < String > commandList = new ArrayList < String > ( ) ; commandList . add ( FFMPEG_BINARY . getAbsolutePath ( ) ) ; commandList . add ( " -y " ) ; Overwrite target if exists commandList.add("-i"); commandList.add(temporaryFileTemplate); Input images commandList.addAll(videoFormat.getArgumentList(this)); Video format specific arguments commandList.add(movieFilename); Target file name ProcessBuilder pb = new ProcessBuilder(commandList); if (verbose) { for (String cmd : pb.command()) { System.out.print(cmd + " "); } System.out.println(); } pb.redirectErrorStream(true); Process p; try { p = pb.start(); p.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = in.readLine()) != null) out.println(line); p.waitFor(); if (verbose) { System.out.println(sw.toString()); } } catch (IOException e) { cleanupAndThrowException(e); } catch (InterruptedException e) { cleanupAndThrowException(e); } cleanup(); } 
public static void main ( String [ ] args ) { int width = 640 ; int height = 480 ; Create a new movie. Movie movie = new Movie("test.mov", MP4VideoFormat.MP4Format, width, height); movie.setVerbose(true); / Initialize an image to draw on. BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); Graphics2D g = (Graphics2D) img.getGraphics(); g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); for (int frame = 0; frame < 20; frame++) { System.out.println("frame = " + frame); Clear the canvas and draw some simple circles. g.setColor(Color.WHITE); g.fillRect(0, 0, width, height); Random r = new Random(0); for (int j = 0; j < 100; j++) { g.setColor(new Color(r.nextInt(255), 255, r.nextInt(255))); g.fillOval(r.nextInt(width) + frame, r.nextInt(height) + frame, 30, 30); } Add the image to the movie. movie.addFrame(img); } Export the movie. movie.save(); } 
public String getDisplayName ( ) ; public String getExtension ( ) ; public int getWidth ( ) ; public int getHeight ( ) ; public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public String getExtension ( ) ; public int getWidth ( ) ; public int getHeight ( ) ; public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public int getWidth ( ) ; public int getHeight ( ) ; public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public int getHeight ( ) ; public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
private void readPreferences ( ) { this . preferences = Preferences . userNodeForPackage ( Application . class ) ; enablePaneCustomizationCheck . setSelected ( Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_PANE_CUSTOMIZATION , " false " ) ) ) ; enableMovieExportCheck . setSelected ( Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_MOVIE_EXPORT , " true " ) ) ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; SwingUtilities . getRootPane ( this ) . setCursor ( Cursor . getDefaultCursor ( ) ) ; if ( oldValue ! = value ) fireStateChanged ( ) ; 
public void actionPerformed ( ActionEvent e ) { java . util . List < Pane > documentPanes = getDocument ( ) . getDocumentPanes ( ) ; for ( Pane pane : documentPanes ) { if ( pane instanceof NetworkPane ) { ( ( NetworkPane ) pane ) . createNewNode ( ) ; return ; } } JOptionPane . showMessageDialog ( getDocument ( ) , " Please make sure a network view is present in the document. " , " Warning " , JOptionPane . WARNING_MESSAGE ) ; } 
private void readPreferences ( ) { this . preferences = Preferences . userNodeForPackage ( Application . class ) ; enablePaneCustomizationCheck . setSelected ( Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_PANE_CUSTOMIZATION , " false " ) ) ) ; } 
public void testGetRelativePaths ( ) { String sep = System . getProperty ( " file.separator " ) ; assertEquals ( " stuff " + sep + " xyz.dat " , FileUtils . getRelativePath ( new File ( " /var/data/stuff/xyz.dat " ) , new File ( " /var/data/ " ) ) ) ; assertEquals ( " .. " + sep + " .. " + sep + " b " + sep + " c " , FileUtils . getRelativePath ( new File ( " /a/b/c " ) , new File ( " /a/x/y/ " ) ) ) ; assertEquals ( " .. " + sep + " .. " + sep + " b " + sep + " c " , FileUtils . getRelativePath ( new File ( " /m/n/o/a/b/c " ) , new File ( " /m/n/o/a/x/y/ " ) ) ) ; 
public void testOutput ( ) { final String expectedOutput = " hello " + System . getProperty ( " line.separator " ) ; ProcessingContext ctx ; PythonCode helloCode = new PythonCode ( " def cook(self): print 'hello' " ) ; Node test = Node . ROOT_NODE . newInstance ( testLibrary , " test " ) ; test . setValue ( " _code " , helloCode ) ; ctx = new ProcessingContext ( ) ; test . update ( ctx ) ; assertEquals ( expectedOutput , ctx . getOutput ( ) ) ; Try this in a network. All the output of the nodes should be merged. Node parent = Node.ROOT_NODE.newInstance(testLibrary, "parent"); Node child = parent.create(Node.ROOT_NODE, "child"); child.setValue("_code", helloCode); child.setRendered(); ctx = new ProcessingContext(); parent.update(ctx); assertEquals(expectedOutput, ctx.getOutput()); } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { int mx = e . getX ( ) ; armed = partIndex ( mx ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; java . util . List < Node > nodes = getNetworkParts ( ) ; Node selectedNode = nodes . get ( partIndex ) ; if ( selectedNode ! = null & & onPartClickListener ! = null ) onPartClickListener . onPartClicked ( selectedNode ) ; repaint ( ) ; } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } @Override public void doLayout ( ) { final int width = getWidth ( ) ; progressBar . setBounds ( width - 23 , 3 , 20 , 20 ) ; } public void onPartClicked ( Node ) ; } } 
public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; java . util . List < Node > nodes = getNetworkParts ( ) ; Node selectedNode = nodes . get ( partIndex ) ; if ( selectedNode ! = null & & onPartClickListener ! = null ) onPartClickListener . onPartClicked ( selectedNode ) ; repaint ( ) ; } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } @Override public void doLayout ( ) { final int width = getWidth ( ) ; progressBar . setBounds ( width - 23 , 3 , 20 , 20 ) ; } public void onPartClicked ( Node ) ; } } 
public boolean quit ( ) { Because documents will disappear from the list once they are closed, make a copy of the list. java.util.List<NodeBoxDocument> documents = new ArrayList<NodeBoxDocument>(getDocuments()); for (NodeBoxDocument d : documents) { if (!d.close()) return false; } System.exit(0); return true; } 
public void doEnter ( ) { String command = getCommand ( ) ; addCommandToHistory ( command ) ; setCommand ( " " ) ; addCommandMessage ( command + " " ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; ByteArrayOutputStream errorStream = new ByteArrayOutputStream ( ) ; interpreter . setOut ( outputStream ) ; interpreter . setErr ( errorStream ) ; HACK Indirect way to access the current document. NodeBoxDocument document = Application.getInstance().getCurrentDocument(); interpreter.set("document", document); interpreter.set("root", document.getNodeLibrary().getRootNode()); interpreter.set("parent", document.getActiveNetwork()); interpreter.set("node", document.getActiveNode()); interpreter.exec("from nodebox.node import *"); for (Parameter.Type type : Parameter.Type.values()) { interpreter.set(type.name(), type); } for (Parameter.Type t : Parameter.Type.values()) interpreter.set(t.name(), t); Exception pythonException = null; try { Object result = interpreter.eval(command); if (result != null) { addMessage(result.toString() + ""); } } catch (Exception e) { pythonException = e; } String os = outputStream.toString(); if (os.length() > 0) { addMessage(os); if (!os.endsWith("")) addMessage(""); } if (pythonException != null) addErrorMessage(pythonException.toString()); 
public void onCodeParameterChanged ( String codeParameter ) { delegate . codeParameterChanged ( this , codeParameter ) ; paneHeader . repaint ( ) ; } 
public void reload ( ) { delegate . codeReloaded ( this , editor . getSource ( ) ) ; } 
public void caretUpdate ( CaretEvent e ) { JEditorPane editArea = ( JEditorPane ) e . getSource ( ) ; int caretPosition = editArea . getCaretPosition ( ) ; Element root = editArea . getDocument ( ) . getDefaultRootElement ( ) ; int line = root . getElementIndex ( caretPosition ) + 1 ; Subtract the offset of the start of the line from the caret position. Add one because line numbers are zero-based. int column = 1 + caretPosition - root.getElement(line - 1).getStartOffset(); updatePosition(line, column); } 
private void updatePosition ( int line , int column ) { splitter . setLocation ( line , column ) ; } 
public void stateChanged ( ChangeEvent changeEvent ) { TODO: This gets fired way too much, for example, once for every line when using setSource(s). The document has changed. reloadButton.setEnabled(true); reloadButton.setWarning(true); TODO Re-enable the delegate call when the method is not called so often. 
public void codeEdited ( EditorPane editorPane , String source ) ; public void codeParameterChanged ( EditorPane editorPane , String codeParameter ) ; } } 
public void codeReloaded ( EditorPane editorPane , String source ) ; public void codeParameterChanged ( EditorPane editorPane , String codeParameter ) ; } } 
public void codeParameterChanged ( EditorPane editorPane , String codeParameter ) ; } } 
public void setEventListener ( ViewerEventListener e ) ; public void repaint ( ) ; Object getOutputValue ( ) ; void setOutputValue ( Object outputValue ) ; boolean isHandleEnabled ( ) ; void setHandleEnabled ( boolean handleEnabled ) ; } 
public void repaint ( ) ; Object getOutputValue ( ) ; void setOutputValue ( Object outputValue ) ; boolean isHandleEnabled ( ) ; void setHandleEnabled ( boolean handleEnabled ) ; } 
Object getOutputValue ( ) ; void setOutputValue ( Object outputValue ) ; boolean isHandleEnabled ( ) ; void setHandleEnabled ( boolean handleEnabled ) ; } 
void setOutputValue ( Object outputValue ) ; boolean isHandleEnabled ( ) ; void setHandleEnabled ( boolean handleEnabled ) ; } 
boolean isHandleEnabled ( ) ; void setHandleEnabled ( boolean handleEnabled ) ; } 
private void moveDelta ( int delta ) { Connection selectedConnection = ( Connection ) connectionList . getSelectedValue ( ) ; if ( selectedConnection = = null ) return ; java . util . List < Connection > connections = getConnections ( ) ; int index = connections . indexOf ( selectedConnection ) ; checkState ( index > = 0 , " Selected connection %s could not be found. " , selectedConnection ) ; getDocument ( ) . reorderConnection ( selectedConnection , delta , true ) ; update ( ) ; connectionList . setSelectedValue ( selectedConnection , true ) ; } 
private void removeSelected ( ) { Connection selectedConnection = ( Connection ) connectionList . getSelectedValue ( ) ; if ( selectedConnection = = null ) return ; getDocument ( ) . disconnect ( selectedConnection ) ; int lastIndex = connectionList . getSelectedIndex ( ) ; update ( ) ; connectionList . setSelectedIndex ( Math . max ( 0 , lastIndex - 1 ) ) ; } 
public void update ( ) { fireContentsChanged ( this , 0 , getSize ( ) ) ; } 
public static void main ( String [ ] args ) { NodeLibrary library = new NodeLibrary ( " test " ) ; Node mergeShapes = Node . ROOT_NODE . newInstance ( library , " mergeshapes " , Polygon . class ) ; Node poly1 = Node . ROOT_NODE . newInstance ( library , " poly1 " , Polygon . class ) ; Node poly2 = Node . ROOT_NODE . newInstance ( library , " poly2 " , Polygon . class ) ; Node poly3 = Node . ROOT_NODE . newInstance ( library , " poly3 " , Polygon . class ) ; Node poly4 = Node . ROOT_NODE . newInstance ( library , " poly4 " , Polygon . class ) ; Port shapesPort = mergeShapes . addPort ( " shapes " , Port . Cardinality . MULTIPLE ) ; shapesPort . connect ( poly1 ) ; shapesPort . connect ( poly2 ) ; shapesPort . connect ( poly3 ) ; shapesPort . connect ( poly4 ) ; JDialog d = new JDialog ( ) ; d . setModal ( true ) ; d . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; MultiConnectionPanel panel = new MultiConnectionPanel ( null , shapesPort ) ; d . getContentPane ( ) . add ( panel , BorderLayout . CENTER ) ; d . setSize ( 400 , 400 ) ; d . setVisible ( true ) ; } 
public void updateAll ( ) { updateNodes ( ) ; updateConnections ( ) ; } 
public void updateConnections ( ) { connectionLayer . repaint ( ) ; } 
public void updatePosition ( Node node ) { NodeView nv = getNodeView ( node ) ; if ( nv = = null ) return ; TODO Make this work. nv.setOffset(node.getX(), node.getY()); updateConnections(); } 
public void singleSelect ( Node node ) { NodeView nodeView = getNodeView ( node ) ; singleSelect ( nodeView ) ; } 
public void singleSelect ( NodeView nodeView ) { connectionLayer . deselect ( ) ; if ( nodeView = = null ) return ; if ( selection . size ( ) = = 1 & & selection . contains ( nodeView ) ) return ; for ( NodeView nv : selection ) { nv . setSelected ( false ) ; } selection . clear ( ) ; selection . add ( nodeView ) ; nodeView . setSelected ( true ) ; firePropertyChange ( SELECT_PROPERTY , null , selection ) ; delegate . activeNodeChanged ( nodeView . getNode ( ) ) ; } 
public void deselectAll ( ) { If the selection was already empty, we don't need to do anything. if (selection.isEmpty()) return; for (NodeView nodeView : selection) { nodeView.setSelected(false); } selection.clear(); connectionLayer.deselect(); } 
private Set < Node > nodeViewsToNodes ( Iterable < NodeView > nodeViews ) { Set < Node > nodes = new HashSet < Node > ( ) ; for ( NodeView nodeView : nodeViews ) { nodes . add ( nodeView . getNode ( ) ) ; } return nodes ; } 
public void deleteSelected ( ) { Set < NodeView > nodeViews = new HashSet < NodeView > ( selection ) ; Set < Node > nodes = nodeViewsToNodes ( nodeViews ) ; getDocument ( ) . removeNodes ( nodes ) ; connectionLayer . deleteSelected ( ) ; } 
public void copySelected ( ) { When copying, create copies of all the nodes and store them under a new parent. The parent is used to preserve the connections, and also to save the state of the copied nodes. This parent is the root of a new library. NodeLibrary clipboardLibrary = new NodeLibrary("clipboard"); Node clipboardRoot = clipboardLibrary.getRootNode(); getDocument().copyChildren(getSelectedNodes(), getActiveNetwork(), clipboardRoot); Application.getInstance().setNodeClipboard(clipboardLibrary); } 
public void pasteSelected ( ) { Node newParent = getActiveNetwork ( ) ; NodeLibrary clipboardLibrary = Application . getInstance ( ) . getNodeClipboard ( ) ; if ( clipboardLibrary = = null ) return ; Node clipboardRoot = clipboardLibrary . getRootNode ( ) ; if ( clipboardRoot . size ( ) = = 0 ) return ; Collection < Node > newNodes = getDocument ( ) . copyChildren ( clipboardRoot . getChildren ( ) , clipboardRoot , newParent ) ; deselectAll ( ) ; for ( Node newNode : newNodes ) { nodebox . graphics . Point pt = newNode . getPosition ( ) ; 
public void checkErrorAndRepaint ( ) { if (!networkError && !activeNetwork.hasError()) return; networkError = activeNetwork.hasError(); repaint(); } 
public void connect ( Port output , Port input ) { getDocument ( ) . connect ( output , input ) ; } 
public void mouseClicked ( PInputEvent e ) { if ( e . getButton ( ) ! = MouseEvent . BUTTON1 ) return ; deselectAll ( ) ; getDocument ( ) . setActiveNode ( null ) ; connectionLayer . mouseClickedEvent ( e ) ; } 
public void codeEdited ( EditorPane editorPane , String source ) { Parameter codeParameter = activeNode . getParameter ( activeCodeParameter ) ; String currentSource = codeParameter . asCode ( ) . getSource ( ) ; if ( ! currentSource . equals ( source ) ) { workingCodeMap . put ( activeNode , source ) ; 
public void codeReloaded ( EditorPane editorPane , String source ) { setActiveNodeCode ( source ) ; } 
public void onEditMetadata ( ) { if ( activeNode = = null ) return ; addEdit ( " Node Metadata " ) ; NodeAttributesEditor editor = new NodeAttributesEditor ( activeNode ) ; JDialog editorDialog = new JDialog ( NodeBoxDocument . this , activeNode . getName ( ) + " Metadata " ) ; editorDialog . getContentPane ( ) . add ( editor ) ; editorDialog . setSize ( 580 , 751 ) ; editorDialog . setResizable ( false ) ; editorDialog . setModal ( true ) ; editorDialog . setModalityType ( Dialog . ModalityType . DOCUMENT_MODAL ) ; editorDialog . setLocationRelativeTo ( NodeBoxDocument . this ) ; editorDialog . setVisible ( true ) ; } 
public void activeNodeChanged ( Node node ) { setActiveNode ( node ) ; } 
public void onPartClicked ( Node ) { setActiveNetwork ( ) ; } 
public void createNode ( Node prototype , Point pt ) { startEdits ( " Create Node " ) ; Node = getActiveNetwork ( ) . create ( prototype ) ; setNodePosition ( , new nodebox . graphics . Point ( pt ) ) ; setRenderedNode ( ) ; setActiveNode ( ) ; stopEdits ( ) ; networkView . updateNodes ( ) ; networkView . setActiveNode ( activeNode ) ; updateEditorPaneSource ( ) ; parameterView . setActiveNode ( activeNode ) ; } 
public void removeNode ( Node node ) { addEdit ( " Remove Node " ) ; removeNodeImpl ( node ) ; networkView . updateAll ( ) ; render ( ) ; } 
public void removeNodes ( Iterable < Node > nodes ) { addEdit ( " Delete Nodes " ) ; for ( Node node : nodes ) { removeNodeImpl ( node ) ; } networkView . updateAll ( ) ; render ( ) ; } 
private void removeNodeImpl ( Node node ) { checkNotNull ( node , " Node to remove cannot be null. " ) ; checkArgument ( node . getParent ( ) = = activeNetwork , " Node to remove is not in active network. " ) ; getActiveNetwork ( ) . remove ( node ) ; If the removed node was the active one, reset the parameter view. if (node == activeNode) { setActiveNode(null); 
public void reorderConnection ( Connection connection , int deltaIndex , boolean multi ) { connection . getInput ( ) . getParentNode ( ) . reorderConnection ( connection , deltaIndex , multi ) ; parameterView . updateConnectionPanel ( ) ; networkView . updateConnections ( ) ; render ( ) ; } 
public void clearParameterExpression ( Parameter parameter ) { addEdit ( " Clear Parameter Expression " ) ; parameter . clearExpression ( ) ; parameterView . updateParameter ( parameter ) ; render ( ) ; } 
public void revertParameterToDefault ( Parameter parameter ) { addEdit ( " Revert Parameter to Default " ) ; parameter . revertToDefault ( ) ; parameterView . updateParameter ( parameter ) ; render ( ) ; } 
private void updateEditorPaneSource ( ) { if ( activeNode ! = null ) { if ( workingCodeMap . containsKey ( activeNode ) ) { 
public void startRendering ( ProcessingContext context ) { addressBar . setProgressVisible ( true ) ; } 
public void finishedRendering ( ProcessingContext context ) { addressBar . setProgressVisible ( false ) ; editorPane . updateMessages ( activeNode , context ) ; viewer . setOutputValue ( activeNetwork . getOutputValue ( ) ) ; networkView . checkErrorAndRepaint ( ) ; TODO: Why? if (activeNode != null) { viewer.setHandleEnabled(activeNode.hasEnabledHandle()); 
private void render ( ) { if ( ! loaded ) return ; if ( ! activeNetwork . isDirty ( ) ) return ; final ProcessingContext context = new ProcessingContext ( activeNetwork ) ; startRendering ( context ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { If meanwhile the node has been marked clean, ignore the event. This avoids double renders. if (!activeNetwork.isDirty()) return; try { activeNetwork.update(context); 
public void run ( ) { finishedRendering ( context ) ; } 
public void fireCodeChanged ( Node node , boolean changed ) { networkView . codeChanged ( node , changed ) ; } 
public boolean close ( ) { stopAnimation ( ) ; if ( shouldClose ( ) ) { renderThread.shutdown(); 
private boolean shouldClose ( ) { if ( isChanged ( ) ) { SaveDialog sd = new SaveDialog ( ) ; int retVal = sd . show ( this ) ; if ( retVal = = JOptionPane . YES_OPTION ) { return save ( ) ; } else if ( retVal = = JOptionPane . NO_OPTION ) { return true ; } else if ( retVal = = JOptionPane . CANCEL_OPTION ) { return false ; } } return true ; } 
private boolean saveToFile ( File file ) { try { nodeLibrary . store ( file ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , " An error occurred while saving the file. " , " NodeBox " , JOptionPane . ERROR_MESSAGE ) ; logger . log ( Level . SEVERE , " An error occurred while saving the file. " , e ) ; return false ; } documentChanged = false ; updateTitle ( ) ; return true ; 
private boolean exportToFile ( File file , ImageFormat format ) { return exportToFile ( file , activeNetwork , format ) ; } 
private boolean exportToFile ( File file , Node exportNetwork , ImageFormat format ) { file = format . ensureFileExtension ( file ) ; if ( exportNetwork = = null ) return false ; Object outputValue = exportNetwork . getOutputValue ( ) ; if ( outputValue instanceof nodebox . graphics . Canvas ) { nodebox . graphics . Canvas c = ( nodebox . graphics . Canvas ) outputValue ; 
private void markChanged ( ) { if ( ! documentChanged & & loaded ) { documentChanged = true ; 
public void paste ( ) { addEdit ( " Paste node " ) ; networkView . pasteSelected ( ) ; } 
public void deleteSelected ( ) { networkView . deleteSelected ( ) ; } 
private void updateTitle ( ) { String postfix = " " ; if ( ! PlatformUtils . onMac ( ) ) { postfix = ( documentChanged ? " * " : " " ) ; } else { getRootPane ( ) . putClientProperty ( " Window.documentModified " , documentChanged ) ; } if ( documentFile = = null ) { setTitle ( " Untitled " + postfix ) ; 
public void createNewNode ( ) { TODO Move this from the NetworkView to here. networkView.showNodeSelectionDialog(); } 
public void reload ( ) { setActiveNodeCode ( editorPane . getSource ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { document . createNewNode ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . reload ( ) ; } 
private void doRename ( ) { String s = JOptionPane . showInputDialog ( networkView , " New name: " , node . getName ( ) ) ; if ( s = = null | | s . length ( ) = = 0 ) return ; try { getDocument ( ) . setNodeName ( node , s ) ; 
public void mouseDragged ( PInputEvent e ) { if ( isPanningEvent ( e ) ) return ; if ( isDragging ) { checkNotNull ( dragPoint , " dragPoint cannot be null. " ) ; Point2D pt = e . getPosition ( ) ; double dx = pt . getX ( ) - dragPoint . getX ( ) ; double dy = pt . getY ( ) - dragPoint . getY ( ) ; getNetworkView ( ) . dragSelection ( dx , dy ) ; dragPoint = pt ; } else if ( networkView . isConnecting ( ) ) { Point2D p = e . getPosition ( ) ; networkView . dragConnectionPoint ( p ) ; } e . setHandled ( true ) ; } 
public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; final Pane newPane ; try { Constructor c = paneType . getConstructor ( NodeBoxDocument . class ) ; newPane = ( Pane ) c . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " Could not instantiate new " + paneType , e ) ; } Container parent = getParent ( ) ; if ( parent instanceof PaneSplitter ) { PaneSplitter parentSplit = ( PaneSplitter ) parent ; boolean first = parentSplit . getFirstComponent ( ) = = this ; if ( first ) { parentSplit . setFirstComponent ( newPane ) ; } else { parentSplit . setSecondComponent ( newPane ) ; } } else { Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; } parent . validate ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void actionPerformed ( ActionEvent e ) { ( ( EditorPane ) getPane ( ) ) . onCodeParameterChanged ( codeType ) ; } 
public Pane duplicate ( ) { return new ParameterPane ( ) ; } 
public void editMetadata ( ) { editMetadataListener . onEditMetadata ( ) ; } 
public void updateParameter ( Parameter parameter ) { TODO More granular rebuild. rebuildInterface(); } 
public void updateParameterValue ( Parameter parameter , Object value ) { Nodes that have expressions set don't display the actual value but the expression. Since the expression doesn't change, we can return immediately. if (parameter.hasExpression()) return; ParameterControl control = getControlForParameter(parameter); if (control != null && control.isVisible()) { control.setValueForControl(value); 
public void updateConnectionPanel ( ) { if ( multiConnectionPanel ! = null ) { multiConnectionPanel . update ( ) ; 
public void onValueChange ( ParameterControl control , Object newValue ) { document . setParameterValue ( control . getParameter ( ) , newValue ) ; } 
protected void paintComponent ( Graphics g ) { if ( activeNode = = null ) { Rectangle clip = g . getClipBounds ( ) ; 
public boolean isHandleEnabled ( ) { return handleEnabled ; } 
public void mouseClicked ( MouseEvent e ) { We register the mouse click as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void mousePressed ( MouseEvent e ) { We register the mouse press as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void mouseReleased ( MouseEvent e ) { We register the mouse release as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void mouseDragged ( MouseEvent e ) { We register the mouse drag as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void actionPerformed ( ActionEvent e ) { JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( this ) ; final JDialog d = new JDialog ( frame , " Choose Color " , true ) ; d . getContentPane ( ) . setLayout ( new BorderLayout ( 10 , 10 ) ) ; final ColorSwatch colorSwatch = new ColorSwatch(parameter.asColor()); Install a listener that listens for active node changed events, so we can dispose of the color dialog. TODO: Find a better way to do this. Maybe add color dialogs to the document itself? Component component = getParent(); while (!(component instanceof NodeBoxDocument)) { component = component.getParent(); } if (colorDialog == null) { colorDialog = new ColorDialog((Frame) SwingUtilities.getWindowAncestor(this)); 
public Parameter getParameter ( ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( ParameterControl control , Object newValue ) ; } } 
public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( ParameterControl control , Object newValue ) ; } } 
public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( ParameterControl control , Object newValue ) ; } } 
public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( ParameterControl control , Object newValue ) ; } } 
public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( ParameterControl control , Object newValue ) ; } } 
public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( ParameterControl control , Object newValue ) ; } } 
public void onValueChange ( ParameterControl control , Object newValue ) ; } } 
public Object cook ( Node node , ProcessingContext context ) throws ProcessingError { if ( ! node . hasChildren ( ) ) return null ; Node renderedChild = node . getRenderedChild ( ) ; if ( renderedChild ! = null ) { renderedChild . update ( context ) ; 
public boolean hasEnabledHandle ( ) { Parameter handleParameter = getParameter ( " _handle " ) ; return handleParameter ! = null & & handleParameter . isEnabled ( ) ; } 
public void testRemove ( ) { First add a node Node net = testNetworkNode.newInstance(testLibrary, "net1"); Node number1 = net.create(numberNode); We add a second node to check for the processing error. If there are no nodes in the parent, the root will just return null. net.create(numberNode); number1.setValue("value", 42); number1.setRendered(); net.update(); assertEquals(42, net.getOutputValue()); Now remove and update again net.remove(number1); assertNull(net.getRenderedChild()); net.update(); The output value should revert to null. assertEquals(null, net.getOutputValue()); } 
public void testBasicProcessing ( ) { Node net = testNetworkNode . newInstance ( testLibrary , " net " ) ; Node v1 = net . create ( numberNode ) ; v1 . setValue ( " value " , 42 ) ; assertEquals ( null , net . getOutputValue ( ) ) ; v1 . setRendered ( ) ; net . update ( ) ; assertEquals ( 42 , net . getOutputValue ( ) ) ; } 
protected void paintComponent ( Graphics g ) { java . util . List < Node > nodes = getNetworkParts ( ) ; positions = new int [ nodes . size ( ) ] ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; g2 . drawImage ( addressGradient , 0 , 0 , getWidth ( ) , 25 , null ) ; int x = 10 ; for ( int i = 0 ; i < nodes . size ( ) ; i + + ) { Node part = nodes . get ( i ) ; 
private void applyPreferences ( ) { Preferences preferences = Preferences . userNodeForPackage ( this . getClass ( ) ) ; There are no more preferences. Leaving this in for when there are. 
protected void paintComponent ( Graphics g ) { g . drawImage ( paneHeaderBackground , 0 , 0 , getWidth ( ) , 25 , null ) ; } 
protected void paintComponent ( Graphics g ) { g . setFont ( Theme . SMALL_BOLD_FONT ) ; g . setColor ( Theme . TEXT_NORMAL_COLOR ) ; SwingUtils . drawShadowText ( ( Graphics2D ) g , getText ( ) , 5 , 14 ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { doSave ( ) ; } 
private void readPreferences ( ) { this . preferences = Preferences . userNodeForPackage ( Application . class ) ; } 
public void doSave ( ) { TODO Re-enable this when there are actual preferences. JOptionPane.showMessageDialog(this, "Please restart NodeBox for the changes to take effect."); try { preferences.flush(); } catch (BackingStoreException e) { throw new RuntimeException(e); } dispose(); } 
public void silentSet ( Node node , String parameterName , Object value ) { try { Parameter parameter = node . getParameter ( parameterName ) ; 
public void stopEditing ( Node node ) { stopCombiningEdits ( ) ; } 
public void finishedRendering ( ProcessingContext context ) { addressBar . setProgressVisible ( false ) ; editorPane . updateMessages ( activeNode , context ) ; viewer . setOutputValue ( activeNetwork . getOutputValue ( ) ) ; networkView . checkErrorAndRepaint ( ) ; TODO I don't know if this is the best way to do this. if (viewer.getHandle() != null) viewer.getHandle().update(); 
public Pane duplicate ( ) { return new ViewerPane ( document ) ; } 
public void silentSet ( String parameterName , Object value ) { if ( delegate ! = null ) delegate . silentSet ( node , parameterName , value ) ; 
public void stopCombiningEdits ( ) { if ( delegate ! = null ) delegate . stopEditing ( node ) ; 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float x = pt . getX ( ) ; float y = pt . getY ( ) ; float dx = x - px ; float dy = y - py ; The delta value is multiplied by 2 to create the float effect of moving the top left corner down and the bottom left corner up (in the case of the top left handle). if (dx == 0 && dy == 0) return false; switch (dragState) { case TOP_LEFT: silentSet(widthName, owidth - dx * 2); silentSet(heightName, oheight - dy * 2); break; case TOP_RIGHT: silentSet(heightName, oheight - dy * 2); silentSet(widthName, owidth + dx * 2); break; case BOTTOM_LEFT: silentSet(widthName, owidth - dx * 2); silentSet(heightName, oheight + dy * 2); break; case BOTTOM_RIGHT: silentSet(widthName, owidth + dx * 2); silentSet(heightName, oheight + dy * 2); break; case CENTER: silentSet(xName, ocx + dx); silentSet(yName, ocy + dy); } return true; } 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public Node getNode ( ) ; public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseClicked ( Point pt ) ; public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void stopCombiningEdits(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setValue ( String parameterName , Object value ) ; public void stopCombiningEdits ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void silentSet ( String parameterName , Object value ) ; public void stopCombiningEdits ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void stopCombiningEdits ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public HandleDelegate getHandleDelegate ( ) ; public void setHandleDelegate ( HandleDelegate delegate ) ; } 
public void setValue ( Node node , String parameterName , Object value ) ; public void stopEditing ( Node node ) ; } 
public void silentSet ( Node node , String parameterName , Object value ) ; public void stopEditing ( Node node ) ; } 
public boolean mouseDragged ( Point e ) { if ( ! dragging ) return false ; double x = e . getX ( ) ; double y = e . getY ( ) ; double dx = x - px ; double dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; TODO: Temporary float fix to get a working compile. Doubles will be removed. silentSet(xName, (float) (ox + dx)); silentSet(yName, (float) (oy + dy)); return true; } 
public void silentSet ( String parameterName , Object value ) { HACK this method now refers to the current document because otherwise the set will not trigger a network update. NodeBoxDocument.getCurrentDocument().silentSet(this, parameterName, value); } 
public boolean mouseDragged ( Point pt ) { if ( ! dragging ) return false ; float newSize = ( float ) Geometry . distance ( getCenterX ( ) , getCenterY ( ) , pt . x , pt . y ) ; if ( mode = = Mode . DIAMETER ) newSize * = 2 ; if ( newSize = = getRadius ( ) ) return false ; silentSet ( radiusName , newSize ) ; this . pt = pt ; return true ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float cx = getCenterX ( ) ; float cy = getCenterY ( ) ; float a = ( float ) Geometry . angle ( cx , cy , pt . x , pt . y ) ; ca = a ; current angle handleLength = (float) Geometry.distance(cx, cy, pt.x, pt.y); if (dragState == DragState.HANDLE) silentSet(angleName, a); else if (dragState == DragState.CIRCLE) silentSet(angleName, oa + a - pa); return true; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float x = pt . getX ( ) ; float y = pt . getY ( ) ; float dx = x - px ; float dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; if ( dragState = = DragState . TOP_LEFT ) { handleWidth = HANDLE_WIDTH - dx * 2 ; handleHeight = HANDLE_HEIGHT - dy * 2 ; } else if ( dragState = = DragState . TOP_RIGHT ) { handleWidth = HANDLE_WIDTH + dx * 2 ; handleHeight = HANDLE_HEIGHT - dy * 2 ; } else if ( dragState = = DragState . BOTTOM_LEFT ) { handleWidth = HANDLE_WIDTH - dx * 2 ; handleHeight = HANDLE_HEIGHT + dy * 2 ; } else if ( dragState = = DragState . BOTTOM_RIGHT ) { handleWidth = HANDLE_WIDTH + dx * 2 ; handleHeight = HANDLE_HEIGHT + dy * 2 ; } float pctX = handleWidth / HANDLE_WIDTH ; float pctY = handleHeight / HANDLE_HEIGHT ; if ( scaleHorizontal ) silentSet ( sxName , ox * pctX ) ; else handleWidth = HANDLE_WIDTH ; if ( scaleVertical ) silentSet ( syName , oy * pctY ) ; else handleHeight = HANDLE_HEIGHT ; return true ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float dx = pt . x - px ; float dy = pt . y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; if ( dragState = = DragState . CENTER ) { silentSet ( txName , ox + dx ) ; silentSet ( tyName , oy + dy ) ; } else if ( dragState = = DragState . HORIZONTAL ) silentSet ( txName , ox + dx ) ; else if ( dragState = = DragState . VERTICAL ) silentSet ( tyName , oy + dy ) ; return true ; } 
protected BasicSplitPaneUI createUI ( ) { return new CustomSplitPaneUI ( ) ; } 
public BasicSplitPaneDivider createDefaultDivider ( ) { return new BasicSplitPaneDivider ( CustomSplitPaneUI . this ) { @Override 
public void paintBorder ( Component component , Graphics g , int x , int y , int width , int height ) { g . setColor ( Theme . DEFAULT_SPLIT_COLOR ) ; g . drawLine ( x , y , x + width , y ) ; } 
public boolean isShowMessages ( ) { return showMessages ; } 
protected BasicSplitPaneUI createUI ( ) { return new EditorSplitPaneUI ( ) ; } 
public BasicSplitPaneDivider createDefaultDivider ( ) { return new BasicSplitPaneDivider ( EditorSplitPaneUI . this ) { @Override 
public void paint ( Graphics g ) { int width = getWidth ( ) ; int height = getHeight(); Rectangle r = g.getClipBounds(); if (getOrientation() == JSplitPane.HORIZONTAL_SPLIT) throw new AssertionError("Horizontal split is not implemented."); g.drawImage(editorSplitterBackground, 0, 0, width, DIVIDER_SIZE, null); if (isShowMessages()) { g.drawImage(editorSplitterHandle, width - 3 - editorSplitterHandleWidth, 1, null); } g.setFont(Theme.SMALL_BOLD_FONT); g.setColor(Theme.TEXT_NORMAL_COLOR); SwingUtils.drawShadowText((Graphics2D) g, positionString, 5, 13); } 
private void split ( int orientation ) { Container parent = getParent ( ) ; if ( parent instanceof JSplitPane ) { JSplitPane parentSplit = ( JSplitPane ) parent ; 
public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; final Pane newPane ; try { Constructor c = paneType . getConstructor ( NodeBoxDocument . class ) ; newPane = ( Pane ) c . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " Could not instantiate new " + paneType , e ) ; } Container parent = getParent ( ) ; if ( parent instanceof JSplitPane ) { JSplitPane parentSplit = ( JSplitPane ) parent ; boolean first = parentSplit . getTopComponent ( ) = = this ; if ( first ) { parentSplit . setTopComponent ( newPane ) ; } else { parentSplit . setBottomComponent ( newPane ) ; } } else { Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; } parent . validate ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
protected BasicSplitPaneUI createUI ( ) { return new SingleLineSplitPaneUI ( ) ; } 
public BasicSplitPaneDivider createDefaultDivider ( ) { return new BasicSplitPaneDivider ( SingleLineSplitPaneUI . this ) { @Override 
public boolean isOpaque ( ) { return false ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; pressed = true ; armed = true ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; pressed = false ; if ( armed ) { armed = false ; if ( mode = = Mode . CHECK ) checked = ! checked ; try { actionMethod . invoke ( actionObject ) ; } catch ( Exception e1 ) { throw new RuntimeException ( " Could not invoke method " + actionMethod + " on object " + actionObject , e1 ) ; } repaint ( ) ; } } public void mouseEntered ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; if ( pressed ) { armed = true ; repaint ( ) ; } } public void mouseExited ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; armed = false ; repaint ( ) ; } } 
public void repaintHandle ( Node node ) { TODO Make viewer repaint more fine-grained. viewer.repaint(); } 
public void repaintHandle ( ) { if ( delegate ! = null ) delegate . repaintHandle ( node ) ; 
public void draw ( GraphicsContext ctx ) { if ( currentPoint = = null ) return ; ctx . nofill ( ) ; ctx . stroke ( 0.5f ) ; ctx . ellipse ( currentPoint . x - 5 , currentPoint . y - 5 , 10 , 10 ) ; } 
public boolean mousePressed ( Point pt ) { newPath = true ; return true ; } 
public boolean mouseMoved ( Point pt ) { currentPoint = pt ; repaintHandle ( ) ; return true ; } 
public boolean mouseDragged ( Point pt ) { Note that the freehand handle is not concerned with parsing the actual path. All it does is append new points to the string. The actual path parsing is done by the freehand node code. currentPoint = pt; String pathString = parameter.asString(); if (newPath) { if (pathString.isEmpty()) { pathString = " "; } pathString += "M "; newPath = false; } pathString += String.format("%.2f %.2f ", pt.getX(), pt.getY()); silentSet(pathParameterName, pathString); repaintHandle(); return true; } 
public boolean mouseReleased ( Point pt ) { stopCombiningEdits ( ) ; return true ; } 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public Node getNode ( ) ; public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseClicked ( Point pt ) ; public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void repaintHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setValue ( String parameterName , Object value ) ; public void repaintHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void silentSet ( String parameterName , Object value ) ; public void repaintHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void stopCombiningEdits ( ) ; public void repaintHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void repaintHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setValue ( Node node , String parameterName , Object value ) ; public void repaintHandle ( Node node ) ; } 
public void silentSet ( Node node , String parameterName , Object value ) ; public void repaintHandle ( Node node ) ; } 
public void stopEditing ( Node node ) ; public void repaintHandle ( Node node ) ; } 
public void updateHandle ( Node node ) { if ( viewer . getHandle ( ) ! = null ) viewer . getHandle ( ) . update ( ) ; TODO Make viewer repaint more fine-grained. viewer.repaint(); } 
public void updateHandle ( ) { if ( delegate ! = null ) delegate . updateHandle ( node ) ; 
public boolean mouseMoved ( Point pt ) { currentPoint = pt ; updateHandle ( ) ; return true ; } 
public boolean mouseDragged ( Point pt ) { Note that the freehand handle is not concerned with parsing the actual path. All it does is append new points to the string. The actual path parsing is done by the freehand node code. currentPoint = pt; String pathString = parameter.asString(); if (newPath) { if (pathString.isEmpty()) { pathString = " "; } pathString += "M "; newPath = false; } pathString += String.format("%.2f %.2f ", pt.getX(), pt.getY()); silentSet(pathParameterName, pathString); updateHandle(); return true; } 
public void setViewer ( Viewer viewer ) ; public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public Viewer getViewer ( ) ; public List<Parameter> getParameters(); public Node getNode(); public void update(); public void draw(GraphicsContext ctx); public void setVisible(boolean visible); public boolean isVisible(); Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public Node getNode ( ) ; public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseClicked ( Point pt ) ; public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setValue ( String parameterName , Object value ) ; public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void silentSet ( String parameterName , Object value ) ; public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void stopCombiningEdits ( ) ; public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setValue ( Node node , String parameterName , Object value ) ; public void updateHandle ( Node node ) ; } 
public void silentSet ( Node node , String parameterName , Object value ) ; public void updateHandle ( Node node ) ; } 
public void stopEditing ( Node node ) ; public void updateHandle ( Node node ) ; } 
private void init ( ) { this . setMargin ( new Insets ( 0 , 5 , 0 , 5 ) ) ; setFont ( Theme . EDITOR_FONT ) ; setEditorKit ( new PythonEditorKit ( ) ) ; getDocument ( ) . addUndoableEditListener ( undoManager ) ; rootElement = getDocument ( ) . getDefaultRootElement ( ) ; todo:this code should be in the kit for (KeyStroke ks : defaultInputMap.allKeys()) { getInputMap().put(ks, defaultInputMap.get(ks)); } defaultInputMap.put(PlatformUtils.getKeyStroke(KeyEvent.VK_Z), new UndoAction()); defaultInputMap.put(PlatformUtils.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK), new RedoAction()); addMouseListener(new DragDetector()); } 
public void discardAllEdits ( ) { undoManager . discardAllEdits ( ) ; } 
public void actionPerformed ( ActionEvent e ) { undo ( ) ; } 
public void actionPerformed ( ActionEvent e ) { redo ( ) ; } 
private void updateHSB ( ) { float h = 0 ; float s = 0 ; float v = Math . max ( Math . max ( red , green ) , blue ) ; float d = v - Math . min ( Math . min ( red , green ) , blue ) ; if ( v ! = 0 ) s = d / v ; if ( s ! = 0 ) { if ( red = = v ) h = 0 + ( green - blue ) / d ; else if ( green = = v ) h = 2 + ( blue - red ) / d ; else h = 4 + ( red - green ) / d ; } h = h * ( float ) ( 60.0 / 360 ) ; if ( h < 0 ) h = h + 1 ; hue = h ; saturation = s ; brightness = v ; } 
public Pane duplicate ( ) { return new EditorPane ( document ) ; } 
private void updateSource ( ) { if ( activeParameter ! = null ) { if ( hasInProgressCode ( activeParameter ) ) { 
public void reload ( ) { This method can be called from the menu bar, so we need to check if the code has really changed. if (!hasInProgressCode(activeParameter)) return; document.setActiveNodeCode(activeParameter, getSource()); removeInProgressCode(activeParameter); The code has been set so there is nothing to reload. setReloadButtonEnabled(false); } 
public boolean isIgnoringChanges ( ) { return ignoringChanges ; } 
public void toggleMessages ( ) { setShowMessages ( messagesCheck . isChecked ( ) ) ; } 
public void stateChanged ( ChangeEvent changeEvent ) { The editor also triggers state changes when using setSource(). We ignore those changes. if (isIgnoringChanges()) return; setInProgressCode(activeParameter, getSource()); setReloadButtonEnabled(true); document.codeEdited(getSource()); } 
private void removeInProgressCode ( Parameter p ) { inProgressCode . remove ( p ) ; } 
private boolean hasInProgressCode ( Parameter p ) { return inProgressCode . containsKey ( p ) ; } 
public void actionPerformed ( ActionEvent e ) { We know the event will always come from the pane code type menu. setCodeType(e.getActionCommand()); } 
public void createNode ( Node prototype , Point pt ) { startEdits ( " Create Node " ) ; Node = getActiveNetwork ( ) . create ( prototype ) ; setNodePosition ( , new nodebox . graphics . Point ( pt ) ) ; setRenderedNode ( ) ; setActiveNode ( ) ; stopEdits ( ) ; networkView . updateNodes ( ) ; networkView . setActiveNode ( activeNode ) ; parameterView . setActiveNode ( activeNode ) ; editorPane . setActiveNode ( activeNode ) ; } 
public void codeEdited ( String source ) { networkView . codeChanged ( activeNode , true ) ; } 
private void createHandleForActiveNode ( ) { if ( activeNode ! = null ) { Handle handle = null ; 
public void actionPerformed ( ActionEvent e ) { Component c = getDocument ( ) . getFocusOwner ( ) ; if ( c instanceof CodeArea ) { ( ( CodeArea ) c ) . undo ( ) ; } else { getDocument ( ) . undo ( ) ; } updateUndoRedoState ( ) ; } 
public void update ( ) { Component c = getDocument ( ) . getFocusOwner ( ) ; if ( c instanceof CodeArea ) { setEnabled ( true ) ; 
public void actionPerformed ( ActionEvent e ) { Component c = getDocument ( ) . getFocusOwner ( ) ; if ( c instanceof CodeArea ) { ( ( CodeArea ) c ) . redo ( ) ; } else { getDocument ( ) . redo ( ) ; } updateUndoRedoState ( ) ; } 
public void mousePressed ( MouseEvent e ) { Rectangle bounds = getBounds ( ) ; paneCodePopup . show ( this , 5 , bounds . y + bounds . height - 4 ) ; } 
public void actionPerformed ( ActionEvent e ) { setMenuName ( codeName ) ; fireActionEvent ( codeType ) ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } protected void fireActionEvent ( String menuKey ) { ActionEvent actionEvent = new ActionEvent ( this , 0 , menuKey ) ; Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i > = 0 ; i - = 2 ) { if ( listeners [ i ] = = ActionListener . class ) { ( ( ActionListener ) listeners [ i + 1 ] ) . actionPerformed ( actionEvent ) ; } } } } 
public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } protected void fireActionEvent ( String menuKey ) { ActionEvent actionEvent = new ActionEvent ( this , 0 , menuKey ) ; Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i > = 0 ; i - = 2 ) { if ( listeners [ i ] = = ActionListener . class ) { ( ( ActionListener ) listeners [ i + 1 ] ) . actionPerformed ( actionEvent ) ; } } } } 
public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } protected void fireActionEvent ( String menuKey ) { ActionEvent actionEvent = new ActionEvent ( this , 0 , menuKey ) ; Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i > = 0 ; i - = 2 ) { if ( listeners [ i ] = = ActionListener . class ) { ( ( ActionListener ) listeners [ i + 1 ] ) . actionPerformed ( actionEvent ) ; } } } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } protected void fireActionEvent ( String menuKey ) { ActionEvent actionEvent = new ActionEvent ( this , 0 , menuKey ) ; Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i > = 0 ; i - = 2 ) { if ( listeners [ i ] = = ActionListener . class ) { ( ( ActionListener ) listeners [ i + 1 ] ) . actionPerformed ( actionEvent ) ; } } } } 
public void mouseExited ( MouseEvent e ) { } protected void fireActionEvent ( String menuKey ) { ActionEvent actionEvent = new ActionEvent ( this , 0 , menuKey ) ; Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i > = 0 ; i - = 2 ) { if ( listeners [ i ] = = ActionListener . class ) { ( ( ActionListener ) listeners [ i + 1 ] ) . actionPerformed ( actionEvent ) ; } } } } 
public void addActionListener ( ActionListener l ) { listenerList . add ( ActionListener . class , l ) ; } 
public void removeActionListener ( ActionListener l ) { listenerList . remove ( ActionListener . class , l ) ; } 
protected void fireActionEvent ( String menuKey ) { ActionEvent actionEvent = new ActionEvent ( this , 0 , menuKey ) ; Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i > = 0 ; i - = 2 ) { if ( listeners [ i ] = = ActionListener . class ) { 
public void keyReleased ( KeyEvent e ) { panEnabled = false ; if ( ! getCursor ( ) . equals ( defaultCursor ) ) setCursor ( defaultCursor ) ; if ( hasVisibleHandle ( ) ) handle . keyReleased ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public Pane duplicate ( ) { return new NetworkPane ( document ) ; } 
public void select ( Iterable < Node > nodes ) { Set < NodeView > nodeViews = nodesToNodeViews ( nodes ) ; select ( nodeViews ) ; } 
private Set < NodeView > nodesToNodeViews ( Iterable < Node > nodes ) { Set < NodeView > nodeViews = new HashSet < NodeView > ( ) ; for ( Node node : nodes ) { nodeViews . add ( getNodeView ( node ) ) ; } return nodeViews ; } 
public void cut ( ) { copy ( ) ; deleteSelection ( ) ; } 
public void copy ( ) { When copying, create copies of all the nodes and store them under a new parent. The parent is used to preserve the connections, and also to save the state of the copied nodes. This parent is the root of a new library. NodeLibrary clipboardLibrary = new NodeLibrary("clipboard"); Node clipboardRoot = clipboardLibrary.getRootNode(); copyChildren(networkView.getSelectedNodes(), getActiveNetwork(), clipboardRoot); setNodeClipboard(clipboardLibrary); } 
public void paste ( ) { addEdit ( " Paste node " ) ; NodeLibrary clipboardLibrary = getNodeClipboard ( ) ; if ( clipboardLibrary = = null ) return ; Node clipboardRoot = clipboardLibrary . getRootNode ( ) ; if ( clipboardRoot . size ( ) = = 0 ) return ; Collection < Node > newNodes = copyChildren ( clipboardRoot . getChildren ( ) , clipboardRoot , getActiveNetwork ( ) ) ; for ( Node newNode : newNodes ) { nodebox . graphics . Point pt = newNode . getPosition ( ) ; pt . x + = 20 ; pt . y + = 80 ; newNode . setPosition ( pt ) ; } networkView . updateAll ( ) ; networkView . select ( newNodes ) ; } 
public void deleteSelection ( ) { removeNodes ( networkView . getSelectedNodes ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . deleteSelection ( ) ; } 
public void updateEnabledState ( ) { for ( Component c : controlPanel . getComponents ( ) ) if ( c instanceof ParameterRow ) { 
public void windowOpened ( WindowEvent e ) { viewEditorSplit . setDividerLocation ( 0.5 ) ; parameterNetworkSplit . setDividerLocation ( 0.5 ) ; topSplit . setDividerLocation ( 0.5 ) ; } 
public boolean mouseDragged ( Point pt ) { Note that the freehand handle is not concerned with parsing the actual path. All it does is append new points to the string. The actual path parsing is done by the freehand node code. currentPoint = pt; String pathString = parameter.asString(); if (newPath) { if (pathString.isEmpty()) { pathString = " "; } pathString += "M "; newPath = false; } Use US locale, otherwise the code might generate a "," instead of a "." as the floating point. pathString += String.format(Locale.US, "%.2f %.2f ", pt.getX(), pt.getY()); silentSet(pathParameterName, pathString); updateHandle(); return true; } 
public void actionPerformed ( ActionEvent e ) { todo: implement NodeAttributesDialog.this.dispose(); } 
public void onEditMetadata ( ) { if ( activeNode = = null ) return ; addEdit ( " Node Metadata " ) ; JDialog editorDialog = new NodeAttributesDialog ( NodeBoxDocument . this ) ; editorDialog . setSize ( 580 , 751 ) ; editorDialog . setLocationRelativeTo ( NodeBoxDocument . this ) ; editorDialog . setVisible ( true ) ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Name nameField = new JFormattedTextField(20); nameField.setEditable(false); addRow("Name", nameField); Label labelField = new JTextField(20); labelField.addActionListener(this); labelField.addFocusListener(this); addRow("Label", labelField); Help Text helpTextField = new JTextField(20); helpTextField.addActionListener(this); helpTextField.addFocusListener(this); addRow("Help Text", helpTextField); Widget widgetBox = new JComboBox(humanizedWidgets); widgetBox.addActionListener(this); addRow("Type", widgetBox); Value valueField = new JTextField(20); valueField.addActionListener(this); valueField.addFocusListener(this); addRow("Value", valueField); Enable If enableIfField = new JTextField(20); enableIfField.addActionListener(this); enableIfField.addFocusListener(this); addRow("Enable If", enableIfField); Bounding Method boundingMethodBox = new JComboBox(new String[]{"none", "soft", "hard"}); boundingMethodBox.addActionListener(this); addRow("Bounding", boundingMethodBox); Minimum Value minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); minimumValueField.addFocusListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); addRow("Minimum", minimumValuePanel); Maximum Value maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); maximumValueField.addFocusListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); addRow("Maximum", maximumValuePanel); Display Level displayLevelBox = new JComboBox(new String[]{"hud", "detail", "hidden"}); displayLevelBox.addActionListener(this); addRow("Display Level", displayLevelBox); Menu Items menuItemsTable = new JTable(new MenuItemsModel()); menuItemsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); JPanel tablePanel = new JPanel(new BorderLayout(5, 5)); JScrollPane tableScroll = new JScrollPane(menuItemsTable, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); tableScroll.setSize(200, 170); tableScroll.setPreferredSize(new Dimension(200, 170)); tableScroll.setMaximumSize(new Dimension(200, 170)); tableScroll.setMinimumSize(new Dimension(200, 170)); tablePanel.add(tableScroll, BorderLayout.CENTER); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 5)); addButton = new JButton(new Icons.PlusIcon()); addButton.addActionListener(this); removeButton = new JButton(new Icons.MinusIcon()); removeButton.addActionListener(this); upButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.NORTH)); upButton.addActionListener(this); downButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.SOUTH)); downButton.addActionListener(this); buttonPanel.add(addButton); buttonPanel.add(removeButton); buttonPanel.add(upButton); buttonPanel.add(downButton); tablePanel.add(buttonPanel, BorderLayout.SOUTH); addRow("Menu Items", tablePanel); } 
public void addParameter ( Node node , String parameterName ) { onChanged ( ) ; document . addParameter ( node , parameterName ) ; } 
public void removeParameter ( Node node , String parameterName ) { onChanged ( ) ; document . removeParameter ( node , parameterName ) ; } 
public void addParameterMenuItem ( Parameter parameter , String key , String label ) { onChanged ( ) ; document . addParameterMenuItem ( parameter , key , label ) ; } 
public void removeParameterMenuItem ( Parameter parameter , Parameter . MenuItem menuItem ) { onChanged ( ) ; document . removeParameterMenuItem ( parameter , menuItem ) ; } 
public void moveParameterItemDown ( Parameter parameter , int index ) { onChanged ( ) ; document . moveParameterItemDown ( parameter , index ) ; } 
public void moveParameterItemUp ( Parameter parameter , int index ) { onChanged ( ) ; document . moveParameterItemUp ( parameter , index ) ; } 
private void onChanged ( ) { if ( ! changed ) { document . startEdits ( " Node Metadata " ) ; 
public void actionPerformed ( ActionEvent e ) { if ( changed ) { document . stopEdits ( ) ; } NodeAttributesDialog . this . dispose ( ) ; } 
public void actionPerformed ( ActionEvent e ) { if ( changed ) { document . stopEdits ( ) ; document . undo ( ) ; } NodeAttributesDialog . this . dispose ( ) ; } 
private void settingsSelected ( ) { editorPanel . removeAll ( ) ; NodeSettingsEditor editor = new NodeSettingsEditor ( dialog ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; selectedPort = null ; selectedParameter = null ; } 
private void portSelected ( Port port ) { editorPanel . removeAll ( ) ; PortAttributesEditor editor = new PortAttributesEditor ( dialog , port ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; selectedPort = port ; selectedParameter = null ; } 
private void parameterSelected ( Parameter parameter ) { editorPanel . removeAll ( ) ; ParameterAttributesEditor editor = new ParameterAttributesEditor ( dialog , parameter ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; selectedParameter = parameter ; selectedPort = null ; } 
private void addParameter ( ) { String parameterName = JOptionPane . showInputDialog ( " Enter parameter name " ) ; if ( parameterName ! = null ) { dialog . addParameter ( node , parameterName ) ; 
private void removeSelectedPort ( ) { JOptionPane . showMessageDialog ( this , " Sorry, removing ports is not implemented yet. " ) ; } 
public void onEditMetadata ( ) { if ( activeNode = = null ) return ; JDialog editorDialog = new NodeAttributesDialog ( NodeBoxDocument . this ) ; editorDialog . setSize ( 580 , 751 ) ; editorDialog . setLocationRelativeTo ( NodeBoxDocument . this ) ; editorDialog . setVisible ( true ) ; } 
public void addParameter ( Node node , String parameterName ) { addEdit ( " Add Parameter " ) ; Parameter parameter = node . addParameter ( parameterName , Parameter . Type . FLOAT ) ; if ( node = = activeNode ) { parameterView . updateAll ( ) ; 
public void removeParameter ( Node node , String parameterName ) { addEdit ( " Remove Parameter " ) ; node . removeParameter ( parameterName ) ; if ( node = = activeNode ) { parameterView . updateAll ( ) ; 
public void addParameterMenuItem ( Parameter parameter , String key , String label ) { addEdit ( " Add Parameter Menu Item " ) ; parameter . addMenuItem ( key , label ) ; parameterView . updateParameter ( parameter ) ; render ( ) ; } 
public void removeParameterMenuItem ( Parameter parameter , Parameter . MenuItem item ) { addEdit ( " Remove Parameter Menu Item " ) ; parameter . removeMenuItem ( item ) ; parameterView . updateParameter ( parameter ) ; render ( ) ; } 
public void moveParameterItemDown ( Parameter parameter , int itemIndex ) { addEdit ( " Move Parameter Item Down " ) ; java . util . List < Parameter . MenuItem > items = parameter . getMenuItems ( ) ; Parameter . MenuItem item = items . get ( itemIndex ) ; items . remove ( item ) ; items . add ( itemIndex + 1 , item ) ; parameter . fireAttributeChanged ( ) ; parameterView . updateParameter ( parameter ) ; } 
public void moveParameterItemUp ( Parameter parameter , int itemIndex ) { addEdit ( " Move Parameter Item Up " ) ; java . util . List < Parameter . MenuItem > items = parameter . getMenuItems ( ) ; Parameter . MenuItem item = items . get ( itemIndex ) ; items . remove ( item ) ; items . add ( itemIndex - 1 , item ) ; parameter . fireAttributeChanged ( ) ; parameterView . updateParameter ( parameter ) ; } 
public void updateValues ( ) { exportBox . setSelected ( dialog . getNode ( ) . isExported ( ) ) ; revalidate ( ) ; } 
private void moveItemDown ( ) { int index = menuItemsTable . getSelectedRow ( ) ; Return if nothing was selected. if (index == -1) return; java.util.List<Parameter.MenuItem> items = parameter.getMenuItems(); Return if the last item is selected. if (index >= items.size() - 1) return; nodeAttributesDialog.moveParameterItemDown(parameter, index); TODO: Changing the selection doesn't have any effect on Mac. menuItemsTable.changeSelection(index + 1, 1, false, false); } 
private void moveItemUp ( ) { int index = menuItemsTable . getSelectedRow ( ) ; Return if nothing was selected. if (index == -1) return; Return if the first item is selected. if (index == 0) return; nodeAttributesDialog.moveParameterItemUp(parameter, index); TODO: Changing the selection doesn't have any effect on Mac. menuItemsTable.changeSelection(index - 1, 1, false, false); } 
public void actionPerformed ( ActionEvent e ) { if ( changed ) { NodeAttributesDialog . this . document . stopEdits ( ) ; NodeAttributesDialog . this . document . undo ( ) ; } dispose ( ) ; } 
public void stopEditing ( Node node ) { stopEdits ( ) ; stopCombiningEdits ( ) ; } 
public void startCombiningEdits ( String command ) { if ( delegate ! = null & & ! combinesEdits ) { delegate . startEdits ( command ) ; 
public void stopCombiningEdits ( ) { if ( delegate ! = null ) { combinesEdits = false ; 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float x = pt . getX ( ) ; float y = pt . getY ( ) ; float dx = x - px ; float dy = y - py ; The delta value is multiplied by 2 to create the float effect of moving the top left corner down and the bottom left corner up (in the case of the top left handle). if (dx == 0 && dy == 0) return false; startCombiningEdits("Set Value"); switch (dragState) { case TOP_LEFT: silentSet(widthName, owidth - dx * 2); silentSet(heightName, oheight - dy * 2); break; case TOP_RIGHT: silentSet(heightName, oheight - dy * 2); silentSet(widthName, owidth + dx * 2); break; case BOTTOM_LEFT: silentSet(widthName, owidth - dx * 2); silentSet(heightName, oheight + dy * 2); break; case BOTTOM_RIGHT: silentSet(widthName, owidth + dx * 2); silentSet(heightName, oheight + dy * 2); break; case CENTER: silentSet(xName, ocx + dx); silentSet(yName, ocy + dy); } return true; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; dragState = DragState . NONE ; stopCombiningEdits ( ) ; return true ; } 
public void setValue ( Node node , String parameterName , Object value ) ; public void updateHandle ( Node node ) ; } 
public void silentSet ( Node node , String parameterName , Object value ) ; public void updateHandle ( Node node ) ; } 
public void startEdits ( String command ) ; public void updateHandle ( Node node ) ; } 
public boolean mouseDragged ( Point e ) { if ( ! dragging ) return false ; double x = e . getX ( ) ; double y = e . getY ( ) ; double dx = x - px ; double dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; startCombiningEdits ( " Set Value " ) ; TODO: Temporary float fix to get a working compile. Doubles will be removed. silentSet(xName, (float) (ox + dx)); silentSet(yName, (float) (oy + dy)); return true; } 
public boolean mouseReleased ( Point pt ) { if ( ! dragging ) return false ; dragging = false ; stopCombiningEdits ( ) ; return true ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float x = pt . getX ( ) ; float y = pt . getY ( ) ; float dx = x - px ; float dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; startCombiningEdits ( " Set Value " ) ; if ( dragState = = DragState . TOP_LEFT ) { handleWidth = HANDLE_WIDTH - dx * 2 ; handleHeight = HANDLE_HEIGHT - dy * 2 ; } else if ( dragState = = DragState . TOP_RIGHT ) { handleWidth = HANDLE_WIDTH + dx * 2 ; handleHeight = HANDLE_HEIGHT - dy * 2 ; } else if ( dragState = = DragState . BOTTOM_LEFT ) { handleWidth = HANDLE_WIDTH - dx * 2 ; handleHeight = HANDLE_HEIGHT + dy * 2 ; } else if ( dragState = = DragState . BOTTOM_RIGHT ) { handleWidth = HANDLE_WIDTH + dx * 2 ; handleHeight = HANDLE_HEIGHT + dy * 2 ; } float pctX = handleWidth / HANDLE_WIDTH ; float pctY = handleHeight / HANDLE_HEIGHT ; if ( scaleHorizontal ) silentSet ( sxName , ox * pctX ) ; else handleWidth = HANDLE_WIDTH ; if ( scaleVertical ) silentSet ( syName , oy * pctY ) ; else handleHeight = HANDLE_HEIGHT ; return true ; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; handleWidth = HANDLE_WIDTH ; handleHeight = HANDLE_HEIGHT ; dragState = DragState . NONE ; stopCombiningEdits ( ) ; viewer . repaint ( ) ; return true ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; float dx = pt . x - px ; float dy = pt . y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; startCombiningEdits ( " Set Value " ) ; if ( dragState = = DragState . CENTER ) { silentSet ( txName , ox + dx ) ; silentSet ( tyName , oy + dy ) ; } else if ( dragState = = DragState . HORIZONTAL ) silentSet ( txName , ox + dx ) ; else if ( dragState = = DragState . VERTICAL ) silentSet ( tyName , oy + dy ) ; return true ; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; dragState = DragState . NONE ; stopCombiningEdits ( ) ; viewer . repaint ( ) ; return true ; } 
public static double hold ( double startFrame , double functionValue , double . . . values ) { double frame = currentContext . getFrame ( ) ; switch ( values . length ) { case 1 : 
public static double hold ( double startFrame , double functionValue ) { return hold ( startFrame , functionValue , 0 , currentContext . getFrame ( ) ) ; } 
public static double hold ( double startFrame , double functionValue , double defaultValue ) { return hold ( startFrame , functionValue , defaultValue , currentContext . getFrame ( ) ) ; } 
public static double hold ( double startFrame , double functionValue , double defaultValue , double frame ) { return frame < startFrame ? defaultValue : functionValue ; } 
public static double schedule ( double startFrame , double endFrame , double functionValue , double . . . values ) { double frame = currentContext . getFrame ( ) ; switch ( values . length ) { case 1 : 
public static double schedule ( double startFrame , double endFrame , double functionValue ) { return schedule ( startFrame , endFrame , functionValue , 0 , currentContext . getFrame ( ) ) ; } 
public static double schedule ( double startFrame , double endFrame , double functionValue , double defaultValue ) { return schedule ( startFrame , endFrame , functionValue , defaultValue , currentContext . getFrame ( ) ) ; } 
public static double schedule ( double startFrame , double endFrame , double functionValue , double defaultValue , double frame ) { return startFrame < = frame & & frame < endFrame ? functionValue : defaultValue ; } 
private void removeSelectedParameter ( ) { if ( selectedParameter = = null ) return ; dialog . removeParameter ( node , selectedParameter . getName ( ) ) ; reloadParameterList ( ) ; editorPanel . removeAll ( ) ; editorPanel . revalidate ( ) ; editorPanel . repaint ( ) ; selectedParameter = null ; } 
public static double hold ( double startFrame , double functionValue , double defaultValue , double frame ) { return frame < startFrame ? defaultValue : functionValue - startFrame ; } 
public static double timeloop ( double speed , List < Number > values , double frame ) { if ( values . size ( ) = = 0 ) return 0 ; int index = ( int ) Math . floor ( frame / speed ) ; index = index % values . size ( ) ; if ( index < 0 ) { index = values . size ( ) + index ; } try { return values . get ( index ) . doubleValue ( ) ; 
private void addPort ( ) { NewPortDialog d = new NewPortDialog ( ) ; d . setVisible ( true ) ; String portName = d . portName ; if ( portName ! = null ) { node . addPort ( portName , d . portCardinality ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { dispose ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { portName = nameField . getText ( ) ; portCardinality = ( Port . Cardinality ) box . getSelectedItem ( ) ; dispose ( ) ; } 
public void actionPerformed ( ActionEvent e ) { dispose ( ) ; } 
public void addPort ( Node node , String portName , Port . Cardinality cardinality ) { onChanged ( ) ; document . addPort ( node , portName , cardinality ) ; } 
private void addPort ( ) { NewPortDialog d = new NewPortDialog ( ) ; d . setVisible ( true ) ; String portName = d . portName ; if ( portName ! = null ) { dialog . addPort ( node , portName , d . portCardinality ) ; 
public boolean hasSelectedConnection ( ) { return connectionLayer . hasSelection ( ) ; } 
public void deleteSelectedConnection ( ) { if ( hasSelectedConnection ( ) ) connectionLayer . deleteSelected ( ) ; 
public void deleteSelection ( ) { java . util . List < Node > selectedNodes = networkView . getSelectedNodes ( ) ; if ( ! selectedNodes . isEmpty ( ) ) removeNodes ( networkView . getSelectedNodes ( ) ) ; 
protected abstract float adjustedTime ( float ) ; protected abstract float computeValue ( float phase ) ; } 
protected float computeValue ( float phase ) { return ( ( phase / TWO_PI ) * 2 - 1 ) * - amplitude ; } 
protected float adjustedTime ( float ) { return + getPeriod ( ) / 2 ; } 
protected float adjustedTime ( float ) { return + getPeriod ( ) / 4 ; } 
public void showConsole ( ) { java . awt . Dimension d = new java . awt . Dimension ( 400 , 400 ) ; if ( console = = null ) { console = new Console ( ) ; console . setPreferredSize ( d ) ; console . setSize ( d ) ; console . setLocationRelativeTo ( getCurrentDocument ( ) ) ; console . setVisible ( true ) ; } console . setLocationRelativeTo ( getCurrentDocument ( ) ) ; console . setVisible ( true ) ; for ( NodeBoxDocument document : documents ) { document . onConsoleVisibleEvent ( true ) ; 
public void hideConsole ( ) { console . setVisible ( false ) ; onHideConsole ( ) ; } 
public void onHideConsole ( ) { for ( NodeBoxDocument document : documents ) { document . onConsoleVisibleEvent ( false ) ; 
public boolean isConsoleOpened ( ) { if ( console = = null ) return false ; return console . isVisible ( ) ; } 
public void windowClosing ( WindowEvent e ) { Application . getInstance ( ) . onHideConsole ( ) ; } 
public void onConsoleVisibleEvent ( boolean visible ) { menuBar . setShowConsoleChecked ( visible ) ; } 
public void actionPerformed ( ActionEvent e ) { Application instance = Application . getInstance ( ) ; if ( instance . isConsoleOpened ( ) ) instance . hideConsole ( ) ; 
public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); Rectangle r = getBounds(); int centerWidth = r.width - draggerLeftWidth - draggerRightWidth; g2.drawImage(draggerLeft, 0, 0, null); g2.drawImage(draggerRight, r.width - draggerRightWidth, 0, null); g2.drawImage(draggerBackground, draggerLeftWidth, 0, centerWidth, draggerHeight, null); g2.setFont(Theme.SMALL_BOLD_FONT); if (isEnabled()) { g2.setColor(Theme.TEXT_NORMAL_COLOR); } else { g2.setColor(Theme.TEXT_DISABLED_COLOR); } SwingUtils.drawCenteredShadowText(g2, valueAsString(), r.width / 2, 14, Theme.DRAGGABLE_NUMBER_HIGHLIGHT_COLOR); } 
public void testSineWave ( ) { SineWave w = new SineWave ( 120 , 20 ) ; assertEquals ( 0f , w . getValueAt ( 0 ) , 0.0001 ) ; assertEquals ( - 20 f , w . getValueAt ( 30 ) , 0.0001 ) ; assertEquals ( 0f , w . getValueAt ( 60 ) , 0.0001 ) ; assertEquals ( 20 f , w . getValueAt ( 90 ) , 0.0001 ) ; assertEquals ( 0f , w . getValueAt ( 120 ) , 0.0001 ) ; } 
public void setName ( String name ) throws InvalidNameException { if ( this . name . equals ( name ) ) return ; if ( this . parent . children . containsKey ( name ) ) throw new InvalidNameException ( null , name , " The network already contains a node named " + name ) ; validateName ( name ) ; this . parent . children . remove ( this . name ) ; this . name = name ; this . parent . children . put ( this . name , this ) ; getLibrary ( ) . fireNodeAttributeChanged ( this , Attribute . NAME ) ; } 
public void updateParameterMenuItem ( Parameter parameter , int index , String key , String label ) { onChanged ( ) ; document . updateParameterMenuItem ( parameter , index , key , label ) ; } 
public void updateParameterMenuItem ( Parameter parameter , int index , String key , String label ) { addEdit ( " Update Parameter Menu Item " ) ; parameter . updateMenuItem ( index , key , label ) ; parameterView . updateParameter ( parameter ) ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Name nameField = new JFormattedTextField(20); nameField.setEditable(false); addRow("Name", nameField); Label labelField = new JTextField(20); labelField.addActionListener(this); labelField.addFocusListener(this); addRow("Label", labelField); Help Text helpTextField = new JTextField(20); helpTextField.addActionListener(this); helpTextField.addFocusListener(this); addRow("Help Text", helpTextField); Widget widgetBox = new JComboBox(humanizedWidgets); widgetBox.addActionListener(this); addRow("Type", widgetBox); Value valueField = new JTextField(20); valueField.addActionListener(this); valueField.addFocusListener(this); addRow("Value", valueField); Enable If enableIfField = new JTextField(20); enableIfField.addActionListener(this); enableIfField.addFocusListener(this); addRow("Enable If", enableIfField); Bounding Method boundingMethodBox = new JComboBox(new String[]{"none", "soft", "hard"}); boundingMethodBox.addActionListener(this); addRow("Bounding", boundingMethodBox); Minimum Value minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); minimumValueField.addFocusListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); addRow("Minimum", minimumValuePanel); Maximum Value maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); maximumValueField.addFocusListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); addRow("Maximum", maximumValuePanel); Display Level displayLevelBox = new JComboBox(new String[]{"hud", "detail", "hidden"}); displayLevelBox.addActionListener(this); addRow("Display Level", displayLevelBox); Menu Items menuItemsTable = new JTable(new MenuItemsModel()); menuItemsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); menuItemsTable.addMouseListener(new MouseAdapter() { public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) updateMenuItem(); } }); JPanel tablePanel = new JPanel(new BorderLayout(5, 5)); JScrollPane tableScroll = new JScrollPane(menuItemsTable, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); tableScroll.setSize(200, 170); tableScroll.setPreferredSize(new Dimension(200, 170)); tableScroll.setMaximumSize(new Dimension(200, 170)); tableScroll.setMinimumSize(new Dimension(200, 170)); tablePanel.add(tableScroll, BorderLayout.CENTER); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 5)); addButton = new JButton(new Icons.PlusIcon()); addButton.addActionListener(this); removeButton = new JButton(new Icons.MinusIcon()); removeButton.addActionListener(this); upButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.NORTH)); upButton.addActionListener(this); downButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.SOUTH)); downButton.addActionListener(this); buttonPanel.add(addButton); buttonPanel.add(removeButton); buttonPanel.add(upButton); buttonPanel.add(downButton); tablePanel.add(buttonPanel, BorderLayout.SOUTH); addRow("Menu Items", tablePanel); } 
public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) = = 2 ) updateMenuItem ( ) ; 
private void updateMenuItem ( ) { int index = menuItemsTable . getSelectedRow ( ) ; if ( index = = - 1 ) return ; Parameter . MenuItem item = parameter . getMenuItems ( ) . get ( index ) ; MenuItemDialog dialog = new MenuItemDialog ( ( Dialog ) SwingUtilities . getRoot ( this ) , item ) ; dialog . setVisible ( true ) ; if ( dialog . isSuccessful ( ) ) { nodeAttributesDialog . updateParameterMenuItem ( parameter , index , dialog . getKey ( ) , dialog . getLabel ( ) ) ; 
public void updateMenuItem ( int index , String key , String label ) { if ( index < 0 | | index > = menuItems . size ( ) ) return ; menuItems . set ( index , new Parameter . MenuItem ( key , label ) ) ; fireAttributeChanged ( ) ; } 
public void moveParameterMenuItemDown ( Parameter parameter , int itemIndex ) { onChanged ( ) ; document . moveParameterMenuItemDown ( parameter , itemIndex ) ; } 
public void moveParameterMenuItemUp ( Parameter parameter , int itemIndex ) { onChanged ( ) ; document . moveParameterMenuItemUp ( parameter , itemIndex ) ; } 
public void updateParameterMenuItem ( Parameter parameter , int itemIndex , String key , String label ) { onChanged ( ) ; document . updateParameterMenuItem ( parameter , itemIndex , key , label ) ; } 
public void moveParameterMenuItemDown ( Parameter parameter , int itemIndex ) { addEdit ( " Move Parameter Item Down " ) ; parameter . moveMenuItemDown ( itemIndex ) ; parameterView . updateParameter ( parameter ) ; } 
public void moveParameterMenuItemUp ( Parameter parameter , int itemIndex ) { addEdit ( " Move Parameter Item Up " ) ; parameter . moveMenuItemUp ( itemIndex ) ; parameterView . updateParameter ( parameter ) ; } 
public void updateParameterMenuItem ( Parameter parameter , int itemIndex , String key , String label ) { addEdit ( " Update Parameter Menu Item " ) ; parameter . updateMenuItem ( itemIndex , key , label ) ; parameterView . updateParameter ( parameter ) ; } 
private void moveMenuItemDown ( ) { int index = menuItemsTable . getSelectedRow ( ) ; Return if nothing was selected. if (index == -1) return; java.util.List<Parameter.MenuItem> items = parameter.getMenuItems(); Return if the last item is selected. if (index >= items.size() - 1) return; nodeAttributesDialog.moveParameterMenuItemDown(parameter, index); TODO: Changing the selection doesn't have any effect on Mac. menuItemsTable.changeSelection(index + 1, 1, false, false); } 
private void moveMenuItemUp ( ) { int index = menuItemsTable . getSelectedRow ( ) ; Return if nothing was selected. if (index == -1) return; Return if the first item is selected. if (index == 0) return; nodeAttributesDialog.moveParameterMenuItemUp(parameter, index); TODO: Changing the selection doesn't have any effect on Mac. menuItemsTable.changeSelection(index - 1, 1, false, false); } 
public void moveMenuItemDown ( int index ) { Parameter . MenuItem item = menuItems . get ( index ) ; menuItems . remove ( item ) ; menuItems . add ( index + 1 , item ) ; fireAttributeChanged ( ) ; } 
public void moveMenuItemUp ( int index ) { Parameter . MenuItem item = menuItems . get ( index ) ; menuItems . remove ( item ) ; menuItems . add ( index - 1 , item ) ; fireAttributeChanged ( ) ; } 
public boolean save ( ) { textArea . requestFocus ( ) ; try { NodeBoxDocument doc = NodeBoxDocument . getCurrentDocument ( ) ; 
public void addEdit ( String command , String type , Object object ) { spotlightPanel . hideSpotlightPanel ( ) ; if ( ! holdEdits ) { markChanged ( ) ; 
public void deleteSelection ( ) { java . util . List < Node > selectedNodes = networkView . getSelectedNodes ( ) ; if ( ! selectedNodes . isEmpty ( ) ) removeNodes ( networkView . getSelectedNodes ( ) ) ; 
private void hideSpotlightPanel ( ) { if ( isVisible ( ) ) { setVisible ( false ) ; 
public static void initializePython ( ) { Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = PlatformUtils.getUserDataDirectory() + PlatformUtils.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. String workingDirectory = System.getProperty("user.dir"); File pythonLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "python.zip"); File nodeBoxLibraries = new File(workingDirectory, "lib" + PlatformUtils.SEP + "nodeboxlibs.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Py.getSystemState().path.add(new PyString(nodeBoxLibraries.getAbsolutePath())); This folder contains unarchived NodeBox libraries. Only used in development. File developmentLibraries = new File("src/python"); Py.getSystemState().path.add(new PyString(developmentLibraries.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(PlatformUtils.getUserPythonDirectory().getAbsolutePath())); } 
public boolean hasDocument ( ) { return document ! = null ; } 
public boolean isEnabled ( ) { return NodeBoxMenuBar . this . hasDocument ( ) & & super . isEnabled ( ) ; } 
public void copy ( ) { When copying, create copies of all the nodes and store them under a new parent. The parent is used to preserve the connections, and also to save the state of the copied nodes. This parent is the root of a new library. Collection<Node> selectedNodes = networkView.getSelectedNodes(); if (! selectedNodes.isEmpty()) { NodeLibrary clipboardLibrary = new NodeLibrary("clipboard"); 
public void paste ( ) { addEdit ( " Paste node " ) ; NodeLibrary clipboardLibrary = getNodeClipboard ( ) ; if ( clipboardLibrary = = null ) return ; Node clipboardRoot = clipboardLibrary . getRootNode ( ) ; if ( clipboardRoot . size ( ) = = 0 ) return ; NodeBoxDocument . pasteCount + = 1 ; Collection < Node > newNodes = copyChildren ( clipboardRoot . getChildren ( ) , clipboardRoot , getActiveNetwork ( ) ) ; for ( Node newNode : newNodes ) { nodebox . graphics . Point pt = newNode . getPosition ( ) ; pt . x + = NodeBoxDocument . pasteCount * 20 ; pt . y + = NodeBoxDocument . pasteCount * 80 ; newNode . setPosition ( pt ) ; } networkView . updateAll ( ) ; networkView . select ( newNodes ) ; } 
public void paste ( ) { addEdit ( " Paste node " ) ; NodeLibrary clipboardLibrary = getNodeClipboard ( ) ; if ( clipboardLibrary = = null ) return ; Node clipboardRoot = clipboardLibrary . getRootNode ( ) ; if ( clipboardRoot . size ( ) = = 0 ) return ; int pasteCount = NodeBoxDocument . pasteCount + = 1 ; Collection < Node > newNodes = copyChildren ( clipboardRoot . getChildren ( ) , clipboardRoot , getActiveNetwork ( ) ) ; for ( Node newNode : newNodes ) { nodebox . graphics . Point pt = newNode . getPosition ( ) ; pt . x + = pasteCount * 20 ; pt . y + = pasteCount * 80 ; newNode . setPosition ( pt ) ; } networkView . updateAll ( ) ; networkView . select ( newNodes ) ; } 
public void paste ( ) { addEdit ( " Paste node " ) ; NodeLibrary clipboardLibrary = getNodeClipboard ( ) ; if ( clipboardLibrary = = null ) return ; Node clipboardRoot = clipboardLibrary . getRootNode ( ) ; if ( clipboardRoot . size ( ) = = 0 ) return ; pasteCount + = 1 ; Collection < Node > newNodes = copyChildren ( clipboardRoot . getChildren ( ) , clipboardRoot , getActiveNetwork ( ) ) ; for ( Node newNode : newNodes ) { nodebox . graphics . Point pt = newNode . getPosition ( ) ; pt . x + = pasteCount * 20 ; pt . y + = pasteCount * 80 ; newNode . setPosition ( pt ) ; } networkView . updateAll ( ) ; networkView . select ( newNodes ) ; } 
public void focusLost ( FocusEvent e ) { if ( numberField . isVisible ( ) ) commitNumberField ( ) ; setFocusable ( true ) ; } 
private void showNumberField ( ) { numberField . setText ( valueAsString ( ) ) ; numberField . setVisible ( true ) ; numberField . requestFocus ( ) ; numberField . selectAll ( ) ; componentResized ( null ) ; repaint ( ) ; } 
public void focusGained ( FocusEvent e ) { showNumberField ( ) ; setFocusable ( false ) ; } 
public void actionPerformed ( ActionEvent e ) { breakFocusCycle ( ) ; commitNumberField ( ) ; } 
private void breakFocusCycle ( ) { Container o = getParent ( ) ; while ( o ! = null ) { if ( o ! = null & & o . isFocusable ( ) ) break ; o = o . getParent ( ) ; } if ( o ! = null ) o . requestFocus ( ) ; 
private void init ( Mode mode , String text , Image normalImage , Image checkedImage ) { this . mode = mode ; this . text = text ; this . normalImage = normalImage ; this . checkedImage = checkedImage ; int width = measureWidth ( ) ; Dimension d = new Dimension ( width , BUTTON_HEIGHT ) ; setSize ( d ) ; setPreferredSize ( d ) ; setMinimumSize ( d ) ; setMaximumSize ( d ) ; addMouseListener ( this ) ; setFocusable ( true ) ; this . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( " SPACE " ) , " pressed " ) ; this . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( " released SPACE " ) , " released " ) ; this . getActionMap ( ) . put ( " pressed " , new PressedAction ( ) ) ; this . getActionMap ( ) . put ( " released " , new ReleasedAction ( ) ) ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { onPressed ( ) ; } private void onPressed ( ) { if ( ! isEnabled ( ) ) return ; requestFocus ( ) ; pressed = true ; armed = true ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { onReleased ( ) ; } private void onReleased ( ) { if ( ! isEnabled ( ) ) return ; pressed = false ; if ( armed ) { armed = false ; if ( mode = = Mode . CHECK ) checked = ! checked ; try { actionMethod . invoke ( actionObject ) ; } catch ( Exception e1 ) { throw new RuntimeException ( " Could not invoke method " + actionMethod + " on object " + actionObject , e1 ) ; } repaint ( ) ; } } public void mouseEntered ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; if ( pressed ) { armed = true ; repaint ( ) ; } } public void mouseExited ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; armed = false ; repaint ( ) ; } private class PressedAction extends AbstractAction { private PressedAction ( ) { super ( " Pressed " ) ; } public void actionPerformed ( ActionEvent e ) { onPressed ( ) ; } } private class ReleasedAction extends AbstractAction { private ReleasedAction ( ) { super ( " Released " ) ; } public void actionPerformed ( ActionEvent e ) { onReleased ( ) ; } } } 
public void mousePressed ( MouseEvent e ) { onPressed ( ) ; } 
private void onPressed ( ) { if ( ! isEnabled ( ) ) return ; requestFocus ( ) ; pressed = true ; armed = true ; repaint ( ) ; } 
public void mouseReleased ( MouseEvent e ) { onReleased ( ) ; } 
private void onReleased ( ) { if ( ! isEnabled ( ) ) return ; pressed = false ; if ( armed ) { armed = false ; 
public void actionPerformed ( ActionEvent e ) { onPressed ( ) ; } 
public void actionPerformed ( ActionEvent e ) { onReleased ( ) ; } 
public void stateChanged ( ChangeEvent changeEvent ) { frame = frameNumber . getValue ( ) ; document . setFrame ( frame ) ; } 
public void playAnimation ( ) { if ( ! playButton . isChecked ( ) ) playButton . setChecked ( true ) ; document . playAnimation ( ) ; playButton . setText ( " Stop " ) ; playButton . setToolTipText ( " Stop Animation " ) ; playButton . setActionMethod ( this , " stopAnimation " ) ; forcePlayButtonWidth ( 45 ) ; } 
private void initLookAndFeel ( ) { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception ignored ) { } System . setProperty ( " apple.laf.useScreenMenuBar " , " true " ) ; UIManager . put ( " Table.alternateRowColor " , new Color ( 243 , 246 , 250 ) ) ; } 
private void createNodeBoxDataDirectories ( ) throws RuntimeException { Platform . getUserDataDirectory ( ) . mkdir ( ) ; Platform . getUserScriptsDirectory ( ) . mkdir ( ) ; Platform . getUserPythonDirectory ( ) . mkdir ( ) ; } 
private void applyPreferences ( ) { Preferences preferences = Preferences . userNodeForPackage ( Application . class ) ; } 
private void registerForMacOSXEvents ( ) throws RuntimeException { if ( ! Platform . onMac ( ) ) return ; try { Generate and register the OSXAdapter, passing it a hash of all the methods we wish to use as delegates for various com.apple.eawt.ApplicationListener methods OSXAdapter.setQuitHandler(this, getClass().getDeclaredMethod("quit", (Class[]) null)); OSXAdapter.setAboutHandler(this, getClass().getDeclaredMethod("showAbout", (Class[]) null)); OSXAdapter.setPreferencesHandler(this, getClass().getDeclaredMethod("showPreferences", (Class[]) null)); OSXAdapter.setFileHandler(this, getClass().getDeclaredMethod("readFromFile", String.class)); } catch (Exception e) { throw new RuntimeException("Error while loading the OS X Adapter.", e); } On the Mac, if all windows are closed the menu bar will be empty. To solve this, we create an off-screen window with the same menu bar as visible windows. hiddenFrame = new JFrame(); hiddenFrame.setJMenuBar(new NodeBoxMenuBar()); hiddenFrame.setUndecorated(true); hiddenFrame.setSize(0, 0); hiddenFrame.setLocation(-100, -100); hiddenFrame.pack(); hiddenFrame.setVisible(true); } 
private void initPython ( ) { PythonUtils . initializePython ( ) ; lookForLibraries ( ) ; } 
private void lookForLibraries ( ) { NodeLibrary coreLibrary = NodeLibrary . load ( new File ( " libraries/core/core.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary lSystemLibrary = NodeLibrary . load ( new File ( " libraries/l_system/l_system.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary packingLibrary = NodeLibrary . load ( new File ( " libraries/packing/packing.ndbx " ) , NodeRepository . of ( ) ) ; systemRepository = NodeRepository . of ( coreLibrary , mathLibrary , stringLibrary , listLibrary , dataLibrary , colorLibrary , 
public void showPreferences ( ) { PreferencePanel preferencePanel = new PreferencePanel ( this , getCurrentDocument ( ) ) ; preferencePanel . setLocationRelativeTo ( getCurrentDocument ( ) ) ; preferencePanel . setVisible ( true ) ; } 
public void showConsole ( ) { java . awt . Dimension d = new java . awt . Dimension ( 400 , 400 ) ; if ( console = = null ) { console = new Console ( ) ; console . setPreferredSize ( d ) ; console . setSize ( d ) ; console . setLocationRelativeTo ( getCurrentDocument ( ) ) ; console . setVisible ( true ) ; } console . setLocationRelativeTo ( getCurrentDocument ( ) ) ; console . setVisible ( true ) ; for ( NodeBoxDocument document : documents ) { document.onConsoleVisibleEvent(true); 
public void onHideConsole ( ) { for ( NodeBoxDocument document : documents ) { document.onConsoleVisibleEvent(false); 
public NodeBoxDocument createNewDocument ( ) { NodeBoxDocument doc = new NodeBoxDocument ( ) ; addDocument ( doc ) ; return doc ; } 
private void addDocument ( NodeBoxDocument doc ) { doc . setVisible ( true ) ; doc . requestFocus ( ) ; doc . focusNetworkView ( ) ; doc . setActiveNetwork ( " / " ) ; documents . add ( doc ) ; currentDocument = doc ; } 
public static void paintConnection ( Graphics2D g , Node outputNode , Node inputNode , Port inputPort ) { GeneralPath p = connectionPath ( outputNode , inputNode , inputPort ) ; paintConnectionPath ( g , p ) ; } 
public static void paintConnectionPath ( Graphics2D g , GeneralPath p ) { g . setStroke ( new BasicStroke ( 1.5f ) ) ; g . draw ( p ) ; } 
public static GeneralPath connectionPath ( Node outputNode , Node inputNode , Port inputPort ) { float x1 = ( float ) ( inputNode . getPosition ( ) . x + 2 ) ; Compensate for selection border float y1 = (float) (inputNode.getPosition().y + NodeView.getVerticalOffsetForPort(inputNode, inputPort) + NodeView.NODE_PORT_HEIGHT / 2); return connectionPath(outputNode, x1, y1); } 
public static GeneralPath connectionPath ( Node outputNode , float x1 , float y1 ) { GeneralPath p = new GeneralPath ( ) ; Start position is at the middle right of the node. nodebox.graphics.Point pt = outputNode.getPosition(); double x0 = pt.x + NodeView.NODE_FULL_SIZE - 3; Compensate for selection border double y0 = pt.y + NodeView.NODE_FULL_SIZE / 2; End position is at the middle left of the node. double dx = Math.abs(y1 - y0) / 2; p.moveTo(x0, y0); p.curveTo(x0 + dx, y0, x1 - dx, y1, x1, y1); return p; } 
public void doEnter ( ) { String command = getCommand ( ) ; addCommandToHistory ( command ) ; setCommand ( " " ) ; addCommandMessage ( command + " " ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; ByteArrayOutputStream errorStream = new ByteArrayOutputStream ( ) ; interpreter . setOut ( outputStream ) ; interpreter . setErr ( errorStream ) ; HACK Indirect way to access the current document. NodeBoxDocument document = Application.getInstance().getCurrentDocument(); interpreter.set("document", document); interpreter.set("root", document.getNodeLibrary().getRoot()); interpreter.set("parent", document.getActiveNetwork()); interpreter.set("node", document.getActiveNode()); interpreter.exec("from nodebox.node import *"); Exception pythonException = null; try { Object result = interpreter.eval(command); if (result != null) { addMessage(result.toString() + ""); } } catch (Exception e) { pythonException = e; } String os = outputStream.toString(); if (os.length() > 0) { addMessage(os); if (!os.endsWith("")) addMessage(""); } if (pythonException != null) addErrorMessage(pythonException.toString()); 
public void paint ( Graphics g ) { ui . update ( g , this ) ; } 
public boolean isOpaque ( ) { return getBackground ( ) ! = null ; } 
private Map inspect ( Object o ) { if ( o instanceof Map ) { return ( Map ) o ; 
public void updateFunctionLibraries ( ) { functionLibraries = new ArrayList < FunctionLibrary > ( ) ; functionLibraries . addAll ( functionRepository . getLibraries ( ) ) ; functionLibraries . remove ( CoreFunctions . LIBRARY ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { removeSelectedLibrary ( ) ; } 
public void mousePressed ( MouseEvent e ) { languagePopup . show ( plusLibraryButton , - 20 , 21 ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { DocumentPropertiesDialog . this . setVisible ( false ) ; } 
private void addLibrary ( String prefix , File libraryFile ) { String relativePath = FileUtils . getRelativePath ( libraryFile , document . getDocumentFile ( ) . getParentFile ( ) ) ; FunctionLibrary library = FunctionLibrary . load ( document . getDocumentFile ( ) , prefix + " : " + relativePath ) ; functionRepository = functionRepository . withLibraryAdded ( library ) ; reloadListModel ( ) ; repositoryChanged = true ; 
private File chooseFileWithExtension ( String extension , String extensionDescription ) { return nodebox . util . FileUtils . showOpenDialog ( NodeBoxDocument . getCurrentDocument ( ) , NodeBoxDocument . lastFilePath , extension , extensionDescription ) ; } 
private void removeSelectedLibrary ( ) { int index = functionLibraryList . getSelectedIndex ( ) ; if ( index > = 0 ) { FunctionLibrary library = ( FunctionLibrary ) functionLibraryListModel . getElementAt ( index ) ; 
private void reloadListModel ( ) { functionLibraryListModel . updateFunctionLibraries ( ) ; functionLibraryList . setModel ( functionLibraryListModel ) ; functionLibraryList . setSelectedIndex ( 0 ) ; functionLibraryList . ensureIndexIsVisible ( 0 ) ; functionLibraryList . setCellRenderer ( new FunctionLibraryRenderer ( ) ) ; repaint ( ) ; } 
public void actionPerformed ( ActionEvent e ) { if ( Platform . onMac ( ) ) { On Mac, we can use the native FileDialog to choose a directory using a special property. 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . translate ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; if ( outputValue instanceof Grob ) { if ( outputValue instanceof nodebox . graphics . Canvas ) 
public void mouseClicked ( MouseEvent e ) { ExceptionDialog ed = new ExceptionDialog ( null , nodeRenderException , " " , false ) ; ed . setVisible ( true ) ; } 
public void showNodeSelectionDialog ( ) { document . showNodeSelectionDialog ( ) ; } 
public void clearError ( ) { errorLabel . setText ( " " ) ; errorLabel . setVisible ( false ) ; } 
public void updatePosition ( Node node ) { updateConnections ( ) ; } 
public void singleSelect ( NodeView nodeView ) { connectionLayer . deselect ( ) ; if ( nodeView = = null ) return ; if ( selection . size ( ) = = 1 & & selection . contains ( nodeView ) ) return ; for ( NodeView nv : selection ) { nv . setSelected ( false ) ; } selection . clear ( ) ; selection . add ( nodeView ) ; nodeView . setSelected ( true ) ; firePropertyChange ( SELECT_PROPERTY , null , selection ) ; document . setActiveNode ( nodeView . getNode ( ) ) ; } 
private Set < NodeView > nodesToNodeViews ( Iterable < Node > nodes ) { Set < NodeView > nodeViews = new HashSet < NodeView > ( ) ; for ( Node node : nodes ) { nodeViews . add ( getNodeView ( node ) ) ; } return nodeViews ; } 
public void connect ( Node outputNode , Node inputNode , Port inputPort ) { getDocument ( ) . connect ( outputNode , inputNode , inputPort ) ; } 
private void goUp ( ) { JOptionPane . showMessageDialog ( this , " Child nodes are not supported yet. " ) ; getDocument().goUp(); 
private void goDown ( ) { JOptionPane . showMessageDialog ( this , " Child nodes are not supported yet. " ) ; if (selection.size() != 1) { 
public void keyPressed ( KeyEvent e ) { panEnabled = e . getKeyCode ( ) = = KeyEvent . VK_SPACE ; if ( panEnabled & & ! getCursor ( ) . equals ( panCursor ) ) setCursor ( panCursor ) ; 
public void keyReleased ( KeyEvent e ) { panEnabled = false ; if ( ! getCursor ( ) . equals ( defaultCursor ) ) setCursor ( defaultCursor ) ; 
public void mouseClicked ( PInputEvent e ) { if ( e . getButton ( ) ! = MouseEvent . BUTTON1 ) return ; deselectAll ( ) ; getDocument ( ) . setActiveNode ( ( Node ) null ) ; connectionLayer . mouseClickedEvent ( e ) ; } 
public void processEvent ( PInputEvent e , int i ) { if ( e . getClickCount ( ) ! = 2 ) return ; NodeView view = getNodeViewAt ( e . getPosition ( ) ) ; if ( view ! = null | | e . isHandled ( ) ) return ; e . setHandled ( true ) ; document . showNodeSelectionDialog ( ) ; } 
public void actionPerformed ( ActionEvent e ) { document . showNodeSelectionDialog ( ) ; } 
private static NodeLibrary createNewLibrary ( ) { NodeRepository nodeRepository = Application . getInstance ( ) . getSystemRepository ( ) ; Node root = Node . ROOT . withName ( " root " ) ; Node rectPrototype = nodeRepository . getNode ( " corevector.rect " ) ; String name = root . uniqueName ( rectPrototype . getName ( ) ) ; Node rect1 = rectPrototype . extend ( ) . withName ( name ) . withPosition ( new nodebox . graphics . Point ( 20 , 20 ) ) ; root = root . withChildAdded ( rect1 ) . withRenderedChild ( rect1 ) ; return NodeLibrary . create ( " untitled " , root , nodeRepository , FunctionRepository . of ( ) ) ; } 
public Thread newThread ( Runnable r ) { Thread = new Thread ( r , " node-renderer " ) ; . setPriority ( Thread . MIN_PRIORITY ) ; return ; } 
public void onSegmentClicked ( String fullPath ) { setActiveNetwork ( fullPath ) ; } 
public void restoreState ( NodeLibrary nodeLibrary , String networkPath , String nodeName ) { controller . setNodeLibrary ( nodeLibrary ) ; invalidateFunctionRepository = true ; restoring = true ; setActiveNetwork ( networkPath ) ; setActiveNode ( nodeName ) ; restoring = false ; } 
public void createNode ( Node prototype , nodebox . graphics . Point pt ) { startEdits ( " Create Node " ) ; Node newNode = controller . createNode ( activeNetworkPath , prototype ) ; String newNodePath = Node . path ( activeNetworkPath , newNode ) ; controller . setNodePosition ( newNodePath , pt ) ; controller . setRenderedChild ( activeNetworkPath , newNode . getName ( ) ) ; setActiveNode ( newNode ) ; stopEdits ( ) ; Node activeNode = getActiveNode ( ) ; networkView . updateNodes ( ) ; networkView . singleSelect ( activeNode ) ; portView . setActiveNode ( activeNode ) ; requestRender ( ) ; } 
public void removeNode ( Node node ) { addEdit ( " Remove Node " ) ; removeNodeImpl ( node ) ; networkView . updateAll ( ) ; requestRender ( ) ; } 
public void removeNodes ( Iterable < Node > nodes ) { addEdit ( " Delete Nodes " ) ; for ( Node node : nodes ) { removeNodeImpl ( node ) ; } networkView . updateAll ( ) ; portView . setActiveNode ( getActiveNode ( ) ) ; requestRender ( ) ; } 
public void connect ( Node outputNode , Node inputNode , Port inputPort ) { addEdit ( " Connect " ) ; controller . connect ( activeNetworkPath , outputNode , inputNode , inputPort ) ; portView . updateAll ( ) ; viewerPane . updateHandle ( ) ; requestRender ( ) ; } 
public void disconnect ( Connection connection ) { addEdit ( " Disconnect " ) ; controller . disconnect ( activeNetworkPath , connection ) ; portView . updateAll ( ) ; networkView . updateConnections ( ) ; viewerPane . updateHandle ( ) ; requestRender ( ) ; } 
public void addPort ( Node node , String parameterName ) { addEdit ( " Add Port " ) ; throw new UnsupportedOperationException ( " Not implemented yet. " ) ; TODO Port port = Port.portForType(); 
public void revertPortToDefault ( Port port ) { addEdit ( " Revert Port to Default " ) ; throw new UnsupportedOperationException ( " Not implemented yet. " ) ; 
public void editMetadata ( ) { if ( getActiveNode ( ) = = null ) return ; JDialog editorDialog = new NodeAttributesDialog(NodeBoxDocument.this); 
public void silentSet ( String portName , Object value ) { try { Port port = getActiveNode ( ) . getInput ( portName ) ; 
public void updateHandle ( ) { if ( viewerPane . getHandle ( ) ! = null ) viewerPane . getHandle ( ) . update ( ) ; TODO Make viewer repaint more fine-grained. viewerPane.repaint(); } 
public void goUp ( ) { throw new UnsupportedOperationException ( " Not implemented yet. " ) ; } 
private void createHandleForActiveNode ( ) { Node activeNode = getActiveNode ( ) ; if ( activeNode ! = null ) { Handle handle = null ; 
public boolean hasInput ( String portName ) { Node node = getActiveNode ( ) ; return node . hasInput ( portName ) ; } 
public boolean isConnected ( Port p ) { return isConnected ( p . getName ( ) ) ; } 
public synchronized void requestRender ( ) { If we're already rendering, request the next renderNetwork. if (isRendering.get()) { shouldRender.set(true); 
public synchronized void startRendering ( final NodeContext context ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { progressPanel . setInProgress ( true ) ; } 
public synchronized void stopRendering ( ) { if ( currentRender ! = null ) { currentRender . cancel ( true ) ; 
public synchronized void finishedRendering ( final NodeContext context , final Node renderedNetwork ) { finishCurrentRender ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { Node renderedChild = renderedNetwork . getRenderedChild ( ) ; Iterable < ? > results = context . getResults ( renderedChild ) ; lastRenderResult = results ; viewerPane . setOutputValues ( results ) ; networkPane . clearError ( ) ; networkView . checkErrorAndRepaint ( ) ; } 
private synchronized void finishedRenderingWithError ( NodeContext context , Node network , final Exception e ) { finishCurrentRender ( ) ; lastRenderResult = null ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { networkPane . setError ( e ) ; } 
private synchronized void finishCurrentRender ( ) { currentRender = null ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { progressPanel . setInProgress ( false ) ; } 
private Object firstOutputValue ( final Map < String , Object > outputValues ) { if ( outputValues . isEmpty ( ) ) return null ; return outputValues . values ( ) . iterator ( ) . next ( ) ; } 
private synchronized void render ( ) { If we're already rendering, return. if (isRendering.get()) return; Before starting the renderNetwork, turn the "should render" flag off and the "is rendering" flag on. synchronized (shouldRender) { synchronized (isRendering) { shouldRender.set(false); isRendering.set(true); } } final NodeLibrary renderLibrary = getNodeLibrary(); final Node renderNetwork = getActiveNetwork(); checkState(currentRender == null, "Another render is still in progress."); currentRender = renderService.submit(new Runnable() { public void run() { 
public void run ( ) { final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame ) ; Exception renderException = null ; startRendering ( context ) ; try { context . renderNetwork ( renderNetwork ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); if (renderException == null) { finishedRendering(context, renderNetwork); 
public void run ( ) { render ( ) ; } 
public void addEdit ( String command , String type , String objectId ) { if ( ! holdEdits ) { markChanged ( ) ; 
public void stopCombiningEdits ( ) { We just reset the last edit type and object so that addEdit will be forced to create a new edit. lastEditType = null; lastEditObjectId = null; stopEdits(); } 
public boolean close ( ) { stopAnimation ( ) ; if ( shouldClose ( ) ) { Application . getInstance ( ) . removeDocument ( this ) ; 
private boolean saveToFile ( File file ) { try { getNodeLibrary ( ) . store ( file ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , " An error occurred while saving the file. " , " NodeBox " , JOptionPane . ERROR_MESSAGE ) ; LOG . log ( Level . SEVERE , " An error occurred while saving the file. " , e ) ; return false ; } documentChanged = false ; updateTitle ( ) ; return true ; } 
private void updateTitle ( ) { String postfix = " " ; if ( ! Platform . onMac ( ) ) { postfix = ( documentChanged ? " * " : " " ) ; } else { getRootPane ( ) . putClientProperty ( " Window.documentModified " , documentChanged ) ; } if ( documentFile = = null ) { setTitle ( " Untitled " + postfix ) ; 
public void focusNetworkView ( ) { networkView . requestFocus ( ) ; } 
private void exportToFile ( File file , ImageFormat format ) { get data from last export. if (lastRenderResult == null) { JOptionPane.showMessageDialog(this, "There is no last render result."); 
private void exportToFile ( File file , Iterable < ? > objects , ImageFormat format ) { file = format . ensureFileExtension ( file ) ; ObjectsRenderer . render ( objects , file ) ; } 
public boolean exportRange ( ) { File exportDirectory = lastExportPath = = null ? null : new File ( lastExportPath ) ; if ( exportDirectory ! = null & & ! exportDirectory . exists ( ) ) exportDirectory = null ; ExportRangeDialog d = new ExportRangeDialog ( this , exportDirectory ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; String exportPrefix = d . getExportPrefix ( ) ; File directory = d . getExportDirectory ( ) ; int fromValue = d . getFromValue ( ) ; int toValue = d . getToValue ( ) ; nodebox . ui . ImageFormat format = d . getFormat ( ) ; if ( directory = = null ) return false ; lastExportPath = directory . getAbsolutePath ( ) ; exportRange ( exportPrefix , directory , fromValue , toValue , format ) ; return true ; } 
public void frameDone ( double frame , Iterable < ? > results ) { File exportFile = new File ( directory , exportPrefix + " - " + frame ) ; exportToFile ( exportFile , results , format ) ; } 
public boolean exportMovie ( ) { ExportMovieDialog d = new ExportMovieDialog ( this , lastExportPath = = null ? null : new File ( lastExportPath ) ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; File chosenFile = d . getExportPath ( ) ; if ( chosenFile ! = null ) { lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; exportToMovieFile ( chosenFile , d . getVideoFormat ( ) , d . getFromValue ( ) , d . getToValue ( ) ) ; return true ; } return false ; } 
public void frameDone ( double frame , Iterable < ? > results ) { movie . addFrame ( ObjectsRenderer . createImage ( results ) ) ; } 
void exportDone ( ) { progressDialog . setTitle ( " Converting frames to movie... " ) ; progressDialog . reset ( ) ; FramesWriter w = new FramesWriter ( progressDialog ) ; movie . save ( w ) ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final ExportViewer viewer = new ExportViewer ( ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame ) ; context . renderNetwork ( exportNetwork ) ; Node renderedChild = exportNetwork . getRenderedChild ( ) ; Iterable < ? > results = context . getResults ( renderedChild ) ; viewer . setOutputValue ( results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; viewer . setVisible ( true ) ; } 
public void copy ( ) { When copying, save a reference to the nodes and the parent network. Since the model is immutable, we don't need to make defensive copies. nodeClipboard = new NodeClipboard(getActiveNetwork(), networkView.getSelectedNodes()); } 
public void paste ( ) { addEdit ( " Paste node " ) ; if ( nodeClipboard = = null ) return ; List < Node > newNodes = controller . pasteNodes ( activeNetworkPath , nodeClipboard . nodes ) ; networkView . updateAll ( ) ; networkView . select ( newNodes ) ; setActiveNode ( newNodes . get ( 0 ) ) ; } 
public void deleteSelection ( ) { java . util . List < Node > selectedNodes = networkView . getSelectedNodes ( ) ; if ( ! selectedNodes . isEmpty ( ) ) { Node node = getActiveNode ( ) ; 
public void showDocumentProperties ( ) { DocumentPropertiesDialog dialog = new DocumentPropertiesDialog ( this , getNodeLibrary ( ) . getFunctionRepository ( ) ) ; dialog . setVisible ( true ) ; FunctionRepository functionRepository = dialog . getFunctionRepository ( ) ; if ( functionRepository ! = null ) { addEdit ( " Change function repository " ) ; 
public void reload ( ) { controller . reloadFunctionRepository ( ) ; invalidateFunctionRepository = true ; requestRender ( ) ; editorPane.reload(); 
public void windowOpened ( WindowEvent e ) { viewEditorSplit.setDividerLocation(0.5); parameterNetworkSplit.setDividerLocation(0.5); topSplit.setDividerLocation(0.5); } 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowDeactivated ( WindowEvent e ) { } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . showDocumentProperties ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . doExport ( ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " http:beta.nodebox.net/ " ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " http:beta.nodebox.net/documentation/getting-started/ " ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " http:beta.nodebox.net/documentation/ " ) ; } 
public UndoState saveState ( ) { return new UndoState ( document . getNodeLibrary ( ) , document . getActiveNetworkPath ( ) , document . getActiveNodeName ( ) ) ; } 
public void restoreState ( UndoState state ) { document . restoreState ( state . nodeLibrary , state . activeNetworkPath , state . activeNodeName ) ; } 
public static BufferedImage findNodeImage ( NodeLibrary library , Node node ) { if ( node = = null | | node . getImage ( ) = = null | | node . getImage ( ) . isEmpty ( ) ) return null ; if ( ! library . getRoot ( ) . hasChild ( node ) ) return null ; File libraryFile = library . getFile ( ) ; if ( libraryFile ! = null ) { File libraryDirectory = libraryFile . getParentFile ( ) ; if ( libraryDirectory ! = null ) { File nodeImageFile = new File ( libraryDirectory , node . getImage ( ) ) ; if ( nodeImageFile . exists ( ) ) { try { return ImageIO . read ( nodeImageFile ) ; } catch ( IOException ignored ) { Pass through } } } } return null; } 
public void updateIcon ( ) { fullIcon = getFullImageForNode ( getNode ( ) , getDocument ( ) . getNodeRepository ( ) , true ) ; } 
protected void paint ( PPaintContext ctx ) { Graphics2D g = ctx . getGraphics ( ) ; Shape clip = g . getClip ( ) ; g . clip ( getBounds ( ) ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; Draw the selection/connection border if (selected && networkView.getConnectionTarget() != this) g.drawImage(nodeGlow, 0, 0, null); if (networkView.getConnectionTarget() == this) g.drawImage(nodeConnectionGlow, 0, 0, null); g.drawImage(fullIcon, 0, 0, null); if (codeChanged) g.drawImage(nodeCodeChanged, 0, 0, null); TODO Add support for node errors. if (node.hasError()) g.drawImage(nodeError, 0, 0, null); if (networkView.getActiveNetwork().getRenderedChildName().equals(getNodeName())) g.drawImage(nodeRendered, 0, 0, null); g.drawImage(nodeRim, 0, 0, null); Draw the node name. g.setFont(Theme.SMALL_BOLD_FONT); g.setColor(Theme.NETWORK_NODE_NAME_COLOR); int textWidth = g.getFontMetrics().stringWidth(getNodeName()); int x = (int) ((NODE_FULL_SIZE - textWidth) / 2f); SwingUtils.drawShadowText(g, getNodeName(), x, NODE_FULL_SIZE + 5, Theme.NETWORK_NODE_NAME_SHADOW_COLOR, -1); Reset the clipping. g.setClip(clip); } 
private void doRename ( ) { String s = JOptionPane . showInputDialog ( networkView , " New name: " , getNodeName ( ) ) ; if ( s = = null | | s . length ( ) = = 0 ) return ; try { getDocument ( ) . setNodeName ( getNode ( ) , s ) ; 
private boolean isPanningEvent ( PInputEvent event ) { return networkView . isPanning ( ) ; } 
public void actionPerformed ( ActionEvent e ) { try { getDocument ( ) . connect ( outputNode , inputNode , inputPort ) ; 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . setRenderedNode ( getNode ( ) ) ; networkView . repaint ( ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . removeNode ( getNode ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { String childPath = Node . path ( getDocument ( ) . getActiveNetworkPath ( ) , getNodeName ( ) ) ; getDocument ( ) . setActiveNetwork ( childPath ) ; } 
protected void paintComponent ( Graphics g ) { g . drawImage ( notesBackgroundImage , PortView . LABEL_WIDTH , 0 , getWidth ( ) , 20 , null ) ; } 
public Pane duplicate ( ) { return new PortPane ( document ) ; } 
public void editMetadata ( ) { document . editMetadata ( ) ; } 
public void actionPerformed ( ActionEvent e ) { NodeBoxDocument doc = NodeBoxDocument.getCurrentDocument(); if (doc == null) throw new RuntimeException("No current active document."); ExpressionWindow window = new ExpressionWindow(port); window.setLocationRelativeTo(this); window.setVisible(true); doc.addPortEditor(window); } Action classes private class RevertToDefaultAction extends AbstractAction { private RevertToDefaultAction() { putValue(Action.NAME, "Revert to Default"); } public void actionPerformed(ActionEvent e) { document.revertPortToDefault(port); Reverting to default could cause an expression to be set/cleared. This triggers an valueChanged event, where we check if our expression field is still up-to-date. } }} 
public void actionPerformed ( ActionEvent e ) { document . revertPortToDefault ( port ) ; Reverting to default could cause an expression to be set/cleared. 
public void updatePort ( Port port ) { TODO More granular rebuild. rebuildInterface(); } 
public void updatePortValue ( Port port , Object value ) { Nodes that have expressions set don't display the actual value but the expression. Since the expression doesn't change, we can return immediately. if (port.hasExpression()) return; PortControl control = getControlForPort(port); if (control != null && control.isVisible()) { control.setValueForControl(value); 
public void updateEnabledState ( ) { for ( Component c : controlPanel . getComponents ( ) ) if ( c instanceof PortRow ) { 
private PortControl constructControl ( Class controlClass , Port p ) { try { Constructor constructor = controlClass . getConstructor ( Port . class ) ; 
public void onValueChange ( PortControl control , Object newValue ) { document . setValue ( control . getPort ( ) . getName ( ) , newValue ) ; } 
public void actionPerformed ( ActionEvent e ) { document . stopRendering ( ) ; } 
protected void paintComponent ( Graphics g ) { g . drawImage ( backgroundImage , 0 , 0 , getWidth ( ) , PROGRESS_PANEL_HEIGHT , null ) ; } 
public static void initializePython ( ) { Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = Platform.getUserDataDirectory() + Platform.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. String workingDirectory = System.getProperty("user.dir"); File pythonLibraries = new File(workingDirectory, "lib" + Platform.SEP + "python.zip"); File nodeBoxLibraries = new File(workingDirectory, "lib" + Platform.SEP + "nodeboxlibs.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Py.getSystemState().path.add(new PyString(nodeBoxLibraries.getAbsolutePath())); This folder contains unarchived NodeBox libraries. Only used in development. File developmentLibraries = new File("src/python"); Py.getSystemState().path.add(new PyString(developmentLibraries.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(Platform.getUserPythonDirectory().getAbsolutePath())); } 
public void setSelected ( boolean s ) ; public boolean isSelected ( ) ; } 
public void updateHandle ( ) { if ( handle = = null ) return ; handle . update ( ) ; } 
public boolean hasVisibleHandle ( ) { if ( handle = = null ) return false ; if ( ! showHandle ) return false ; if ( ! handleEnabled ) return false ; Don't show handles when the window offset of LastResortVisualizer and ColorVisualizer doesn't match the visualizer for Grob, Canvas or Point, resulting in the handle showing up at a weird location. Todo: Find a better solution, because this feels a bit hacky. if (currentVisualizer instanceof LastResortVisualizer) return false; if (currentVisualizer instanceof ColorVisualizer) return false; return handle.isVisible(); } 
protected void paint ( PPaintContext paintContext ) { Graphics2D g = paintContext . getGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; drawObjects ( g ) ; drawHandle ( g ) ; drawPoints ( g ) ; drawPointNumbers ( g ) ; } 
public void drawObjects ( Graphics2D g ) { if ( currentVisualizer ! = null ) currentVisualizer . draw ( g , outputValues ) ; 
public void drawHandle ( Graphics2D g ) { if ( hasVisibleHandle ( ) ) { Create a canvas with a transparent background. 
private void drawPoints ( Graphics2D g ) { if ( showPoints & & IGeometry . class . isAssignableFrom ( valuesClass ) ) { TODO Create a dynamic iterator that combines all output values into one flat sequence. 
private void drawPointNumbers ( Graphics2D g ) { if ( showPointNumbers & & IGeometry . class . isAssignableFrom ( valuesClass ) ) { g . setFont ( Theme . SMALL_MONO_FONT ) ; 
public void actionPerformed ( ActionEvent e ) { CardLayout layout = ( CardLayout ) contentPanel . getLayout ( ) ; layout . show ( contentPanel , viewName ) ; viewerToggle . setSelected ( view = = viewer ) ; dataSheetToggle . setSelected ( view = = dataSheet ) ; currentView = view ; currentView . setOutputValues ( ImmutableList . copyOf ( outputValues ) ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g . setFont ( Theme . SMALL_BOLD_FONT ) ; if ( isSelected ( ) ) { g . setColor ( Theme . SELECTED_TAB_BACKGROUND_COLOR ) ; g2 . fill ( g . getClip ( ) ) ; g . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } else { g . setColor ( Theme . TAB_BACKGROUND_COLOR ) ; g2 . fill ( g . getClip ( ) ) ; g . setColor ( Theme . TEXT_DISABLED_COLOR ) ; } SwingUtils . drawShadowText ( ( Graphics2D ) g , getText ( ) , 5 , 14 ) ; } 
public String getDisplayName ( ) ; public String getExtension ( ) ; public int getWidth ( ) ; public int getHeight ( ) ; public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public String getExtension ( ) ; public int getWidth ( ) ; public int getHeight ( ) ; public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public int getWidth ( ) ; public int getHeight ( ) ; public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public int getHeight ( ) ; public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public ArrayList < String > getArgumentList ( ) ; public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public ArrayList < String > getArgumentList ( Movie movie ) ; public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public File ensureFileExtension ( File file ) ; public String ensureFileExtension ( String file ) ; } 
public void actionPerformed ( ActionEvent e ) { JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( this ) ; final JDialog d = new JDialog ( frame , " Choose Color " , true ) ; d . getContentPane ( ) . setLayout ( new BorderLayout ( 10 , 10 ) ) ; final ColorSwatch colorSwatch = new ColorSwatch(port.asColor()); Install a listener that listens for active node changed events, so we can dispose of the color dialog. TODO: Find a better way to do this. Maybe add color dialogs to the document itself? Component component = getParent(); while (!(component instanceof NodeBoxDocument)) { component = component.getParent(); } if (colorDialog == null) { colorDialog = new ColorDialog((Frame) SwingUtilities.getWindowAncestor(this)); 
protected void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; if ( ColorControl . this . isEnabled ( ) ) { g . setColor ( Color . darkGray ) ; } else { g . setColor ( Theme . PORT_LABEL_BACKGROUND ) ; } g . fillRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; if ( ColorControl . this . isEnabled ( ) ) { r . grow ( 1 , 1 ) ; } else { r . grow ( - 5 , - 5 ) ; } g . setColor ( port . colorValue ( ) . getAwtColor ( ) ) ; g . fillRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; } 
public void actionPerformed ( ActionEvent e ) { JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( this ) ; File f = FileUtils . showOpenDialog ( frame , port . stringValue ( ) , acceptedExtensions ( ) , acceptedDescription ( ) ) ; if ( f ! = null ) { File libraryFile = NodeBoxDocument . getCurrentDocument ( ) . getDocumentFile ( ) ; 
public void actionPerformed ( ActionEvent e ) { Font font = ( Font ) fontChooser . getSelectedItem ( ) ; if ( font = = null ) return ; String fontName = font . getFontName ( ) ; setPortValue ( font . getFontName ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { MenuItem item = ( MenuItem ) menuBox . getSelectedItem ( ) ; if ( item ! = null ) { setPortValue ( item . getKey ( ) ) ; 
public Port getPort ( ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
public void onValueChange ( PortControl control , Object newValue ) ; } } 
public void actionPerformed ( ActionEvent e ) { setPortValue ( textField . getText ( ) ) ; } 
public void toggle ( ) { setPortValue ( checkBox . isChecked ( ) ) ; } 
public static int paintSyntaxLine ( Segment line , Token tokens , SyntaxStyle [ ] styles , TabExpander expander , Graphics gfx , int x , int y ) { Font defaultFont = gfx . getFont ( ) ; Color defaultColor = gfx . getColor ( ) ; int offset = 0 ; for ( ; ; ) { byte id = tokens . id ; if ( id = = Token . END ) break ; int length = tokens . length ; if ( id = = Token . NULL ) { if ( ! defaultColor . equals ( gfx . getColor ( ) ) ) gfx . setColor ( defaultColor ) ; if ( ! defaultFont . equals ( gfx . getFont ( ) ) ) gfx . setFont ( defaultFont ) ; } else styles [ id ] . setGraphicsFlags ( gfx , defaultFont ) ; line . count = length ; x = Utilities . drawTabbedText ( line , x , y , gfx , expander , 0 ) ; line . offset + = length ; offset + = length ; tokens = tokens . next ; } return x ; } 
public boolean accepts ( Iterable < ? > objects , Class listClass ) { return nodebox . graphics . Canvas . class . isAssignableFrom ( listClass ) ; } 
public void draw ( Graphics2D g , Iterable < ? > objects ) { firstCanvas = getFirstCanvas ( objects ) ; drawCanvasBounds ( g , firstCanvas ) ; GrobVisualizer . drawGrobs ( g , ( Iterable < Grob > ) objects ) ; } 
private void drawCanvasBounds ( Graphics2D g , Canvas canvas ) { Rectangle2D canvasBounds = canvas . getBounds ( ) . getRectangle2D ( ) ; g . setColor ( Color . DARK_GRAY ) ; g . setStroke ( new BasicStroke ( 1f ) ) ; g . draw ( canvasBounds ) ; } 
public boolean accepts ( Iterable < ? > objects , Class listClass ) { return Color . class . isAssignableFrom ( listClass ) ; } 
public void draw ( Graphics2D g , Iterable < ? > objects ) { AffineTransform = g . getTransform ( ) ; int x = 0 ; int y = 0 ; for ( Object o : objects ) { Color c = ( Color ) o ; 
private void drawColor ( Graphics2D g , Color c , int x , int y ) { g . setColor ( java . awt . Color . WHITE ) ; g . fillRoundRect ( x , y , COLOR_SIZE + 6 , COLOR_SIZE + 6 , 3 , 3 ) ; g . setColor ( java . awt . Color . LIGHT_GRAY ) ; g . drawRoundRect ( x , y , COLOR_SIZE + 6 , COLOR_SIZE + 6 , 3 , 3 ) ; g . setColor ( c . getAwtColor ( ) ) ; g . fillRect ( x + 3 , y + 3 , COLOR_SIZE , COLOR_SIZE ) ; } 
public boolean accepts ( Iterable < ? > objects , Class listClass ) { return Grob . class . isAssignableFrom ( listClass ) ; } 
public void draw ( Graphics2D g , Iterable < ? > objects ) { Object firstObject = Iterables . getFirst ( objects , null ) ; if ( firstObject instanceof Grob ) drawGrobs ( g , ( Iterable < Grob > ) objects ) ; 
public static void drawGrobs ( Graphics2D g , Iterable < Grob > objects ) { for ( Grob grob : objects ) { Shape oldClip = g . getClip ( ) ; 
public boolean accepts ( Iterable < ? > objects , Class listClass ) { return true ; } 
public void draw ( Graphics2D g , Iterable < ? > objects ) { if ( objects = = null ) return ; g . setColor ( Theme . TEXT_NORMAL_COLOR ) ; g . setFont ( Theme . EDITOR_FONT ) ; AffineTransform = g . getTransform ( ) ; for ( Object o : objects ) { String s = o . toString ( ) ; for ( String line : s . split ( " " ) ) { g . drawString ( line , 5 , 20 ) ; g . translate ( 0 , 14 ) ; } g . drawLine ( - 100 , 10 , 1000 , 10 ) ; g . translate ( 0 , 14 ) ; } g . setTransform ( ) ; } 
public boolean accepts ( Iterable < ? > objects , Class listClass ) { return listClass = = Point . class ; } 
public void draw ( Graphics2D g , Iterable < ? > objects ) { Object firstObject = Iterables . getFirst ( objects , null ) ; if ( firstObject instanceof Point ) drawPoints ( g , ( Iterable < Point > ) objects ) ; 
public static void drawPoints ( Graphics2D g , Iterable < Point > points ) { Path onCurves = new Path ( ) ; Path offCurves = new Path ( ) ; onCurves . setFill ( new nodebox . graphics . Color ( 0 , 0 , 1 ) ) ; offCurves . setFill ( new nodebox . graphics . Color ( 1 , 0 , 0 ) ) ; for ( Point point : points ) { if ( point . isOnCurve ( ) ) { onCurves . ellipse ( point . x , point . y , POINT_SIZE , POINT_SIZE ) ; } else { offCurves . ellipse ( point . x , point . y , POINT_SIZE , POINT_SIZE ) ; } } onCurves . draw ( g ) ; offCurves . draw ( g ) ; } 
public boolean accepts ( Iterable < ? > objects , Class listClass ) ; public Rectangle2D getBounds ( Iterable < ? > objects ) ; public Point2D getOffset ( Iterable < ? > objects , Dimension2D viewerSize ) ; public void draw ( Graphics2D g , Iterable < ? > objects ) ; } 
public Rectangle2D getBounds ( Iterable < ? > objects ) ; public Point2D getOffset ( Iterable < ? > objects , Dimension2D viewerSize ) ; public void draw ( Graphics2D g , Iterable < ? > objects ) ; } 
public Point2D getOffset ( Iterable < ? > objects , Dimension2D viewerSize ) ; public void draw ( Graphics2D g , Iterable < ? > objects ) ; } 
public static ClojureLibrary loadScript ( String fileName ) throws LoadException { return loadScript ( null , fileName ) ; } 
public static ClojureLibrary loadScript ( File baseFile , String fileName ) throws LoadException { File file = null ; try { if ( baseFile ! = null ) { file = new File ( baseFile . getCanonicalPath ( ) + File . separator + fileName ) ; } else { file = new File ( fileName ) ; } } catch ( IOException e ) { throw new LoadException ( fileName , e ) ; } Object returnValue ; try { returnValue = Compiler . loadFile ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { throw new LoadException ( fileName , e ) ; } We need a Var as the last statement, because we need to retrieve the current namespace. if (!(returnValue instanceof Var)) { throw new LoadException(fileName, String.format("The last statement does not define a var, but %s." + "Make sure the last line of your script looks like this:" + "(def nodes [{:name \"foo\" :fn inc}])", returnValue)); } Var nodesVar = (Var) returnValue; Namespace ns = nodesVar.ns; String namespace = ns.name.getName(); Object functionMap = nodesVar.deref(); checkStructure(functionMap); ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder(); for (Object item : (Iterable) functionMap) { Map m = (Map) item; String name = (String) m.get(NAME); IFn fn = (IFn) m.get(FN); Function f = new ClojureFunction(name, fn); builder.put(name, f); } return new ClojureLibrary(namespace, file, builder.build()); } 
public boolean hasFunction ( String name ) { return functionMap . containsKey ( name ) ; } 
private static void checkStructure ( Object v ) { checkArgument ( v instanceof Iterable , " The function map is not a list of maps but a %s " , v ) ; Iterable iterable = ( Iterable ) v ; for ( Object item : iterable ) { checkArgument ( item instanceof Map , " The function map is not a list of maps but a %s " , v ) ; 
public Object invoke ( Object . . . args ) throws Exception { return fn . applyTo ( RT . arrayToList ( args ) ) ; } 
private static ImmutableList < Argument > introspect ( IFn fn ) { Each function is a separate class. Class functionClass = fn.getClass(); Method m = Functions.findMethod(functionClass, "invoke"); return Functions.introspect(m); } 
public static Color color ( Color color ) { return color ; } 
public static Color gray ( double gray , double alpha , double range ) { range = Math . max ( range , 1 ) ; return new Color ( gray / range , gray / range , gray / range , alpha / range ) ; } 
public static Color rgb ( double red , double green , double blue , double alpha , double range ) { range = Math . max ( range , 1 ) ; return new Color ( red / range , green / range , blue / range , alpha / range ) ; } 
public static Color hsb ( double hue , double saturation , double brightness , double alpha , double range ) { range = Math . max ( range , 1 ) ; return new Color ( hue / range , saturation / range , brightness / range , alpha / range , Color . Mode . HSB ) ; } 
public static double frame ( NodeContext context ) { return context . getFrame ( ) ; } 
public static Geometry rect ( Point position , double width , double height ) { Path p = new Path ( ) ; p . rect ( position . getX ( ) , position . getY ( ) , width , height ) ; return p . asGeometry ( ) ; } 
public static Point valuesToPoint ( double x , double y ) { return new Point ( x , y ) ; } 
public static Object lookup ( Object o , String key ) { if ( o = = null | | key = = null ) return null ; if ( o instanceof Map ) { Map m = ( Map ) o ; 
public static List < Map < String , Object > > importCSV ( String fileName ) { if ( fileName = = null | | fileName . trim ( ) . isEmpty ( ) ) return ImmutableList . of ( ) ; try { InputStreamReader in = new InputStreamReader ( new FileInputStream ( fileName ) , " UTF-8 " ) ; 
public static FunctionLibrary load ( String href ) { return load ( null , href ) ; } 
public static FunctionLibrary load ( File file , String href ) { Matcher hrefMatcher = HREF_PATTERN . matcher ( href ) ; checkArgument ( hrefMatcher . matches ( ) , " Library identifier should be in the form language:filename.ext " ) ; checkState ( hrefMatcher . groupCount ( ) = = 2 ) ; String language = hrefMatcher . group ( 1 ) ; String identifier = hrefMatcher . group ( 2 ) ; if ( file ! = null ) file = file . getParentFile ( ) ; if ( language . equals ( " java " ) ) { return JavaLibrary . loadStaticClass ( identifier ) ; 
public static FunctionLibrary ofClass ( String namespace , Class c , String . . . methodNames ) { return JavaLibrary . ofClass ( namespace , c , methodNames ) ; } 
public abstract String getLink ( File baseFile ) ; public abstract Function getFunction ( String name ) ; public abstract boolean hasFunction ( String name ) ; public FunctionLibrary reload ( ) { throw new UnsupportedOperationException ( " The reload() method is unsupported. " ) ; } Object overrides @Override public int hashCode() { return Objects.hashCode(getNamespace()); } @Override public boolean equals(Object o) { if (!(o instanceof FunctionLibrary)) return false; final FunctionLibrary other = (FunctionLibrary) o; return Objects.equal(getNamespace(), other.getNamespace()); } @Override public String toString() { return String.format("<FunctionLibrary %s>", getNamespace()); }} 
public abstract Function getFunction ( String name ) ; public abstract boolean hasFunction ( String name ) ; public FunctionLibrary reload ( ) { throw new UnsupportedOperationException ( " The reload() method is unsupported. " ) ; } Object overrides @Override public int hashCode() { return Objects.hashCode(getNamespace()); } @Override public boolean equals(Object o) { if (!(o instanceof FunctionLibrary)) return false; final FunctionLibrary other = (FunctionLibrary) o; return Objects.equal(getNamespace(), other.getNamespace()); } @Override public String toString() { return String.format("<FunctionLibrary %s>", getNamespace()); }} 
public abstract boolean hasFunction ( String name ) ; public FunctionLibrary reload ( ) { throw new UnsupportedOperationException ( " The reload() method is unsupported. " ) ; } Object overrides @Override public int hashCode() { return Objects.hashCode(getNamespace()); } @Override public boolean equals(Object o) { if (!(o instanceof FunctionLibrary)) return false; final FunctionLibrary other = (FunctionLibrary) o; return Objects.equal(getNamespace(), other.getNamespace()); } @Override public String toString() { return String.format("<FunctionLibrary %s>", getNamespace()); }} 
public FunctionLibrary reload ( ) { throw new UnsupportedOperationException ( " The reload() method is unsupported. " ) ; } 
public int hashCode ( ) { return Objects . hashCode ( getNamespace ( ) ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof FunctionLibrary ) ) return false ; final FunctionLibrary other = ( FunctionLibrary ) o ; return Objects . equal ( getNamespace ( ) , other . getNamespace ( ) ) ; } 
public String toString ( ) { return String . format ( " <FunctionLibrary %s> " , getNamespace ( ) ) ; } 
public static FunctionRepository of ( FunctionLibrary . . . libraries ) { ImmutableSet . Builder < FunctionLibrary > librarySet = ImmutableSet . builder ( ) ; librarySet . addAll ( ImmutableSet . copyOf ( libraries ) ) ; The core library is always included. librarySet.add(CoreFunctions.LIBRARY); ImmutableMap.Builder<String, FunctionLibrary> builder = ImmutableMap.builder(); for (FunctionLibrary library : librarySet.build()) { builder.put(library.getNamespace(), library); } return new FunctionRepository(builder.build()); } 
public static FunctionRepository combine ( FunctionRepository . . . repositories ) { ImmutableSet . Builder < FunctionLibrary > librarySet = ImmutableSet . builder ( ) ; The core library is always included. librarySet.add(CoreFunctions.LIBRARY); for (FunctionRepository repository : repositories) { librarySet.addAll(repository.getLibraries()); } ImmutableMap.Builder<String, FunctionLibrary> builder = ImmutableMap.builder(); for (FunctionLibrary library : librarySet.build()) { builder.put(library.getNamespace(), library); } return new FunctionRepository(builder.build()); } 
public boolean hasFunction ( String identifier ) { try { return getFunction ( identifier ) ! = null ; 
public boolean hasLibrary ( String namespace ) { return libraryMap . containsKey ( namespace ) ; } 
public FunctionRepository withLibraryAdded ( FunctionLibrary newLibrary ) { List < FunctionLibrary > newLibraries = new ArrayList < FunctionLibrary > ( ) ; Collection < FunctionLibrary > libraries = getLibraries ( ) ; if ( libraries . contains ( newLibrary ) ) { for ( FunctionLibrary library : libraries ) { if ( library . equals ( newLibrary ) ) newLibraries . add ( newLibrary ) ; else newLibraries . add ( library ) ; } } else { newLibraries . addAll ( libraries ) ; newLibraries . add ( newLibrary ) ; } FunctionLibrary [ ] fl = newLibraries . toArray ( new FunctionLibrary [ newLibraries . size ( ) ] ) ; return FunctionRepository . of ( fl ) ; } 
public FunctionRepository withLibraryRemoved ( FunctionLibrary library ) { checkNotNull ( library ) ; checkArgument ( hasLibrary ( library . getNamespace ( ) ) , " Could not find library %s: unknown namespace. " , library . getNamespace ( ) ) ; List < FunctionLibrary > newLibraries = new ArrayList < FunctionLibrary > ( ) ; newLibraries . addAll ( getLibraries ( ) ) ; newLibraries . remove ( library ) ; FunctionLibrary [ ] fl = newLibraries . toArray ( new FunctionLibrary [ newLibraries . size ( ) ] ) ; return FunctionRepository . of ( fl ) ; } 
public int hashCode ( ) { return Objects . hashCode ( libraryMap ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof FunctionRepository ) ) return false ; final FunctionRepository other = ( FunctionRepository ) o ; return Objects . equal ( libraryMap , other . libraryMap ) ; } 
public String toString ( ) { return String . format ( " <FunctionRepository %s> " , Joiner . on ( " , " ) . join ( libraryMap . values ( ) ) ) ; } 
public synchronized String nextWithPrefix ( String prefix ) { int number = Objects . firstNonNull ( prefixMap . get ( prefix ) , 0 ) ; number + + ; prefixMap . put ( prefix , number ) ; return prefix + number ; } 
public static JavaLibrary loadStaticClass ( String identifier ) { try { Class c = Class . forName ( identifier ) ; 
public static JavaLibrary ofClass ( String namespace , Class c , String . . . methodNames ) { ArrayList < Function > functions = new ArrayList < Function > ( ) ; for ( String methodName : methodNames ) { Function function = StaticMethodFunction . find ( c , methodName ) ; functions . add ( function ) ; } return new JavaLibrary ( namespace , c , functions ) ; } 
public static StaticMethodFunction find ( Class c , String methodName ) { Method m = Functions . findMethod ( c , methodName ) ; return new StaticMethodFunction ( m ) ; } 
public Object invoke ( Object . . . args ) throws Exception { return method . invoke ( null , args ) ; } 
public static long count ( Iterable < ? > iterable ) { if ( iterable = = null ) return 0 ; return Iterables . size ( iterable ) ; } 
public static List < ? > first ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; Iterator iterator = iterable . iterator ( ) ; if ( iterator . hasNext ( ) ) { return ImmutableList . of ( iterator . next ( ) ) ; } return ImmutableList . of ( ) ; } 
public static List < ? > second ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; Iterator iterator = iterable . iterator ( ) ; if ( iterator . hasNext ( ) ) { iterator . next ( ) ; if ( iterator . hasNext ( ) ) { return ImmutableList . of ( iterator . next ( ) ) ; } } return ImmutableList . of ( ) ; } 
public static Iterable < ? > rest ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; return Iterables . skip ( iterable , 1 ) ; } 
public static List < ? > last ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; try { return ImmutableList . of ( Iterables . getLast ( iterable ) ) ; 
public static Iterable < ? > combine ( Iterable list1 , Iterable list2 , Iterable list3 ) { Iterable < Iterable < ? > > nonNullLists = Iterables . filter ( Lists . < Iterable < ? > > newArrayList ( list1 , list2 , list3 ) , Predicates . notNull ( ) ) ; return Iterables . concat ( nonNullLists ) ; } 
public static Iterable < ? > combine ( Iterable < ? > . . . iterables ) { return Iterables . concat ( iterables ) ; } 
public static Iterable < ? > slice ( Iterable < ? > iterable , long startIndex , long size ) { if ( iterable = = null ) return ImmutableList . of ( ) ; Iterable < ? > skipped = Iterables . skip ( iterable , ( int ) startIndex ) ; return Iterables . limit ( skipped , ( int ) size ) ; } 
public static Iterable < ? > shift ( Iterable < ? > iterable , long amount ) { if ( iterable = = null ) return ImmutableList . of ( ) ; int listSize = Iterables . size ( iterable ) ; if ( listSize = = 0 ) return ImmutableList . of ( ) ; int a = ( int ) amount % listSize ; if ( a = = 0 ) return iterable ; Iterable < ? > tail = Iterables . skip ( iterable , a ) ; Iterable < ? > head = Iterables . limit ( iterable , a ) ; return Iterables . concat ( tail , head ) ; } 
public static Iterable < ? > repeat ( Iterable < ? > iterable , long amount ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( amount < 1 ) return ImmutableList . of ( ) ; Iterable < ? > [ ] iterables = new Iterable < ? > [ ( int ) amount ] ; for ( int i = 0 ; i < amount ; i + + ) { iterables [ i ] = iterable ; } return Iterables . concat ( iterables ) ; } 
public static List < ? > reverse ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; return Lists . reverse ( ImmutableList . copyOf ( iterable ) ) ; } 
public static List < ? > sort ( Iterable < ? > iterable , final String key ) { if ( iterable = = null ) return ImmutableList . of ( ) ; try { if ( key = = null | | key . length ( ) = = 0 ) 
public int compare ( Object o1 , Object o2 ) { Comparable c1 = ( Comparable ) DataFunctions . lookup ( o1 , key ) ; Comparable c2 = ( Comparable ) DataFunctions . lookup ( o2 , key ) ; return Ordering . natural ( ) . compare ( c1 , c2 ) ; } 
public static List < ? > shuffle ( Iterable < ? > iterable , long seed ) { if ( iterable = = null ) return ImmutableList . of ( ) ; List < ? > l = Lists . newArrayList ( iterable ) ; Collections . shuffle ( l , new Random ( seed ) ) ; return ImmutableList . copyOf ( l ) ; } 
public static List < ? > pick ( Iterable < ? > iterable , long amount , long seed ) { if ( iterable = = null | | amount < = 0 ) return ImmutableList . of ( ) ; List < ? > l = Lists . newArrayList ( iterable ) ; Collections . shuffle ( l , new Random ( seed ) ) ; if ( amount > = l . size ( ) ) return ImmutableList . copyOf ( l ) ; return ImmutableList . copyOf ( l . subList ( 0 , ( int ) amount ) ) ; } 
public static Iterable < ? > cycle ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; return Iterables . cycle ( iterable ) ; } 
public static List < ? > filter ( Iterable < ? > iterable , Iterable < Boolean > booleans ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( booleans = = null ) return ImmutableList . copyOf ( iterable ) ; if ( Iterables . size ( booleans ) = = 1 ) { if ( Iterables . getFirst ( booleans , false ) ) return ImmutableList . copyOf ( iterable ) ; else return ImmutableList . of ( ) ; } List < ? > l = Lists . newArrayList ( iterable ) ; List < Boolean > b = Lists . newArrayList ( booleans ) ; List < Object > newList = new ArrayList < Object > ( ) ; int min = Math . min ( l . size ( ) , b . size ( ) ) ; for ( int i = 0 ; i < min ; i + + ) { boolean keep = b . get ( i ) ; if ( keep ) newList . add ( l . get ( i ) ) ; } if ( b . size ( ) < l . size ( ) ) newList . addAll ( l . subList ( b . size ( ) , l . size ( ) ) ) ; return ImmutableList . copyOf ( newList ) ; } 
public static List < ? > cull ( Iterable < ? > iterable , Iterable < Boolean > booleans ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( booleans = = null ) return ImmutableList . copyOf ( iterable ) ; if ( Iterables . size ( booleans ) = = 1 ) { if ( Iterables . getFirst ( booleans , false ) ) return ImmutableList . copyOf ( iterable ) ; else return ImmutableList . of ( ) ; } Iterator < ? > it = iterable . iterator ( ) ; ImmutableList . Builder < Object > builder = ImmutableList . builder ( ) ; Iterator < ? > booleanIterator = ( ( Iterable < ? > ) cycle ( booleans ) ) . iterator ( ) ; if ( ! booleanIterator . hasNext ( ) ) return ImmutableList . copyOf ( iterable ) ; while ( it . hasNext ( ) ) { Object object = it . next ( ) ; boolean keep = ( Boolean ) booleanIterator . next ( ) ; if ( keep ) builder . add ( object ) ; } return builder . build ( ) ; } 
public static List < ? > distinct ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; List < Object > newList = new ArrayList < Object > ( ) ; Iterator < ? > iterator = iterable . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object object = iterator . next ( ) ; if ( newList . contains ( object ) ) continue ; newList . add ( object ) ; } return ImmutableList . copyOf ( newList ) ; } 
public static Iterable < ? > takeEvery ( Iterable < ? > iterable , long ) { if ( iterable = = null ) return ImmutableList . of ( ) ; ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; Iterator < ? > iterator = iterable . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( i % = = 0 ) { b . add ( o ) ; } i + + ; } return b . build ( ) ; } 
public static double add ( double n1 , double n2 ) { return n1 + n2 ; } 
public static double subtract ( double n1 , double n2 ) { return n1 - n2 ; } 
public static double multiply ( double n1 , double n2 ) { return n1 * n2 ; } 
public static double divide ( double n1 , double n2 ) { checkArgument ( n2 ! = 0 , " Divider cannot be zero. " ) ; return n1 / n2 ; } 
public static double mod ( double n1 , double n2 ) { checkArgument ( n2 ! = 0 , " Divider cannot be zero. " ) ; return n1 % n2 ; } 
public static double sqrt ( double ) { return Math . sqrt ( ) ; } 
public static double log ( double ) { checkArgument ( ! = 0 , " Value cannot be zero. " ) ; return Math . log ( ) ; } 
public static boolean even ( double ) { return % 2 = = 0 ; } 
public static boolean odd ( double ) { return % 2 ! = 0 ; } 
public static double abs ( double ) { return Math . abs ( ) ; } 
public static double sum ( Iterable < Double > numbers ) { if ( numbers = = null ) return 0.0 ; double sum = 0 ; for ( Double d : numbers ) { sum + = d ; } return sum ; } 
public static double average ( Iterable < Double > numbers ) { if ( numbers = = null ) return 0.0 ; double sum = 0 ; double counter = 0 ; for ( Double d : numbers ) { sum + = d ; counter + + ; } return sum / counter ; } 
public static double max ( Iterable < Double > numbers ) { if ( numbers = = null ) return 0.0 ; double max = Iterables . getFirst ( numbers , 0.0 ) ; for ( Double d : numbers ) { max = Math . max ( max , d ) ; } return max ; } 
public static double min ( Iterable < Double > numbers ) { if ( numbers = = null ) return 0.0 ; double min = Iterables . getFirst ( numbers , 0.0 ) ; for ( Double d : numbers ) { min = Math . min ( min , d ) ; } return min ; } 
public static boolean compare ( String comparator , double n1 , double n2 ) { if ( comparator . equals ( " < " ) ) { return n1 < n2 ; 
public static Iterable < Double > makeNumbers ( String s , String separator ) { if ( s = = null | | s . length ( ) = = 0 ) { return ImmutableList . of ( ) ; } Iterable < String > parts ; if ( separator = = null | | separator . isEmpty ( ) ) parts = Splitter . fixedLength ( 1 ) . split ( s ) ; else parts = Splitter . on ( separator ) . split ( s ) ; ArrayList < Double > numbers = new ArrayList < Double > ( ) ; for ( String part : parts ) { numbers . add ( Double . parseDouble ( part ) ) ; } return ImmutableList . copyOf ( numbers ) ; } 
public static List < Double > randomNumbers ( long amount , double start , double end , long seed ) { Random r = new Random ( seed ) ; ImmutableList . Builder < Double > numbers = ImmutableList . builder ( ) ; for ( int i = 0 ; i < amount ; i + + ) { double v = start + ( r . nextDouble ( ) * ( end - start ) ) ; numbers . add ( v ) ; } return numbers . build ( ) ; } 
public static long toInteger ( double a ) { return ( long ) a ; } 
public static List < Double > sample ( final long amount , final double start , final double end ) { if ( amount = = 0 ) return ImmutableList . of ( ) ; if ( amount = = 1 ) return ImmutableList . of ( start + ( end - start ) / 2 ) ; The step is the range divided by amount - 1, because we also want the end value. If I wouldn't use amount - 1, we fall one value short of the end. E.g. if amount = 3 between 0-100, I want 0.0, 50.0, 100.0. final double step = (end - start) / (amount - 1); ImmutableList.Builder<Double> b = ImmutableList.builder(); for (long i = 0; i < amount; i++) { b.add(start + step * i); } return b.build(); } 
public static Iterable < Double > range ( final double start , final double end , final double step ) { if ( step = = 0 | | start = = end | | ( start < end & & step < 0 ) | | ( start > end & & step > 0 ) ) return ImmutableList . of ( ) ; 
public Iterator < Double > iterator ( ) { return new RangeIterator ( start , end , step ) ; } 
public boolean hasNext ( ) { if ( step > 0 ) return next < end ; 
public Double next ( ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) throw new RuntimeException ( " interrupt " ) ; if (Thread.interrupted()) throw new RuntimeException("interrupt"); if (!hasNext()) throw new NoSuchElementException(); double result = next; next += step; return result; } 
public void remove ( ) { throw new UnsupportedOperationException ( ) ; } 
public static double radians ( double degrees ) { return Geometry . radians ( degrees ) ; } 
public static double degrees ( double radians ) { return Geometry . degrees ( radians ) ; } 
public static double angle ( Point p1 , Point p2 ) { return Geometry . angle ( p1 . x , p1 . y , p2 . x , p2 . y ) ; } 
public static double distance ( Point p1 , Point p2 ) { return Geometry . distance ( p1 . x , p1 . y , p2 . x , p2 . y ) ; } 
public static Point coordinates ( Point p , double angle , double distance ) { double x = p . x + Math . cos ( radians ( angle ) ) * distance ; double y = p . y + Math . sin ( radians ( angle ) ) * distance ; return new Point ( x , y ) ; } 
public static Point reflect ( Point p1 , Point p2 , double distance , double angle ) { distance * = distance ( p1 , p2 ) ; angle + = angle ( p1 , p2 ) ; return coordinates ( p1 , distance , angle ) ; } 
public static double sin ( double ) { return Math . sin ( ) ; } 
public static double cos ( double ) { return Math . cos ( ) ; } 
public static double slowNumber ( double ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ignored ) { return - 999 ; } return ; } 
public static double convertRange ( double value , double srcMin , double srcMax , double targetMin , double targetMax , String overflowMethod ) { if ( overflowMethod . equals ( OVERFLOW_WRAP ) ) { value = srcMin + value % ( srcMax - srcMin ) ; } else if ( overflowMethod . equals ( OVERFLOW_MIRROR ) ) { double rest = value % ( srcMax - srcMin ) ; if ( ( int ) ( value / ( srcMax - srcMin ) ) % 2 = = 1 ) value = srcMax - rest ; else value = srcMin + rest ; } else if ( overflowMethod . equals ( OVERFLOW_CLAMP ) ) { value = clamp ( value , srcMin , srcMax ) ; } Convert value to 0.0-1.0 range. try { value = (value - srcMin) / (srcMax - srcMin); } catch (ArithmeticException e) { value = srcMin; } Convert value to target range. return targetMin + value * (targetMax - targetMin); } 
public static String namespaceForFile ( String fileName ) { checkArgument ( fileName . endsWith ( " .py " ) , " The file name of a Python library needs to end in .py (not %s) " , fileName ) ; checkArgument ( fileName . trim ( ) . length ( ) > = 4 , " The file name can not be empty (was %s). " , fileName ) ; File f = new File ( fileName ) ; String baseName = f . getName ( ) ; checkArgument ( FILE_NAME_PATTERN . matcher ( baseName ) . matches ( ) , " The file name can only contain lowercase letters, numbers and underscore (was %s). " , fileName ) ; return baseName . substring ( 0 , baseName . length ( ) - 3 ) ; } 
public static PythonLibrary loadScript ( File baseFile , String fileName ) throws LoadException { return loadScript ( namespaceForFile ( fileName ) , baseFile , fileName ) ; } 
public static PythonLibrary loadScript ( String namespace , String fileName ) throws LoadException { return loadScript ( namespace , null , fileName ) ; } 
public static PythonLibrary loadScript ( String namespace , File baseFile , String fileName ) throws LoadException { PythonInterpreter interpreter = new PythonInterpreter ( ) ; File file ; try { if ( baseFile ! = null ) { String path = baseFile . getCanonicalPath ( ) ; Py . getSystemState ( ) . path . append ( new PyString ( path ) ) ; interpreter . execfile ( path + File . separator + fileName ) ; file = new File ( path + File . separator + fileName ) ; } else { String path = new File ( fileName ) . getParentFile ( ) . getCanonicalPath ( ) ; Py . getSystemState ( ) . path . append ( new PyString ( path ) ) ; interpreter . execfile ( fileName ) ; file = new File ( fileName ) ; } } catch ( IOException e ) { throw new LoadException ( fileName , e ) ; } catch ( PyException e ) { throw new LoadException ( fileName , e ) ; } PyStringMap map = ( PyStringMap ) interpreter . getLocals ( ) ; ImmutableMap . Builder < String , Function > builder = ImmutableMap . builder ( ) ; for ( Object key : map . keys ( ) ) { Object o = map . get ( Py . java2py ( key ) ) ; if ( o instanceof PyFunction ) { String name = ( String ) key ; Function f = new PythonFunction ( name , ( PyFunction ) o ) ; builder . put ( name , f ) ; } } return new PythonLibrary ( namespace , file , builder . build ( ) ) ; } 
public FunctionLibrary reload ( ) { PythonInterpreter interpreter = new PythonInterpreter ( ) ; try { interpreter . execfile ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { throw new LoadException ( file . getName ( ) , e ) ; } catch ( PyException e ) { throw new LoadException ( file . getName ( ) , e ) ; } PyStringMap map = ( PyStringMap ) interpreter . getLocals ( ) ; ImmutableMap . Builder < String , Function > builder = ImmutableMap . builder ( ) ; for ( Object key : map . keys ( ) ) { Object o = map . get ( Py . java2py ( key ) ) ; if ( o instanceof PyFunction ) { String name = ( String ) key ; Function f = new PythonFunction ( name , ( PyFunction ) o ) ; builder . put ( name , f ) ; } } return new PythonLibrary ( namespace , file , builder . build ( ) ) ; } 
public Object invoke ( Object . . . args ) throws Exception { PyObject [ ] pyArgs = new PyObject [ args . length ] ; for ( int i = 0 ; i < args . length ; i + + ) pyArgs [ i ] = Py . java2py ( args [ i ] ) ; PyObject pyResult = fn . __call__ ( pyArgs ) ; if ( pyResult = = null ) return null ; todo: number conversions should be handled higher up in the code, and not at the Jython level. if (pyResult instanceof PyLong || pyResult instanceof PyInteger) return pyResult.__tojava__(Long.class); Object result = pyResult.__tojava__(Object.class); if (result == Py.NoConversion) throw new RuntimeException("Cannot convert Python object " + pyResult + " to java."); return result; } 
public static List < String > makeStrings ( String s , String separator ) { if ( s = = null ) { return ImmutableList . of ( ) ; } if ( separator = = null | | separator . isEmpty ( ) ) { return ImmutableList . copyOf ( Splitter . fixedLength ( 1 ) . split ( s ) ) ; } return ImmutableList . copyOf ( Splitter . on ( separator ) . split ( s ) ) ; } 
public static int length ( String s ) { if ( s = = null ) return 0 ; return s . length ( ) ; } 
public static int wordCount ( String s ) { if ( s = = null ) return 0 ; Iterable < String > split = Splitter . onPattern ( " \\ w+ " ) . split ( s ) ; return Iterables . size ( split ) - 1 ; } 
public static String concatenate ( String s1 , String s2 , String s3 , String s4 ) { s1 = s1 ! = null ? s1 : " " ; s2 = s2 ! = null ? s2 : " " ; s3 = s3 ! = null ? s3 : " " ; s4 = s4 ! = null ? s4 : " " ; return s1 + s2 + s3 + s4 ; } 
public void extend ( Point [ ] points ) { for ( Point point : points ) { addPoint ( point ) ; 
protected double pointDelta ( int amount , boolean closed ) { double delta = 1 ; if ( closed ) { if ( amount > 0 ) { delta = 1.0 / amount ; } } else { The delta value is divided by amount - 1, because we also want the last point (t=1.0) If I wouldn't use amount - 1, I fall one point short of the end. E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0, if amount = 2, I want point at t 0.0 and t 1.0 if (amount > 2) { delta = 1.0 / (amount - 1.0); } } return delta; } 
public void resetContext ( ) { colorMode = Color . Mode . RGB ; colorRange = 1 ; fillColor = new Color ( ) ; strokeColor = null ; strokeWidth = 1 ; path = null ; autoClosePath = true ; transformMode = Transform . Mode . CENTER ; transform = new Transform ( ) ; transformStack = new ArrayList < Transform > ( ) ; fontName = " Helvetica " ; fontSize = 24 ; lineHeight = 1.2 ; align = Text . Align . LEFT ; } 
public Path rect ( double x , double y , double width , double height ) { return rect ( x , y , width , height , true ) ; } 
public Path rect ( double x , double y , double width , double height , boolean draw ) { Path p = createPath ( ) ; switch ( rectMode ) { case CENTER : p . rect ( x , y , width , height ) ; break ; case CORNER : p . cornerRect ( x , y , width , height ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path rect ( Rect r , double roundness ) { return rect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , roundness , roundness , true ) ; } 
public Path rect ( Rect r , double roundness , boolean draw ) { return rect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) , roundness , roundness , draw ) ; } 
public Path rect ( double x , double y , double width , double height , double roundness ) { return rect ( x , y , width , height , roundness , roundness , true ) ; } 
public Path rect ( double x , double y , double width , double height , double roundness , boolean draw ) { return rect ( x , y , width , height , roundness , roundness , draw ) ; } 
public Path rect ( double x , double y , double width , double height , double rx , double ry ) { return rect ( x , y , width , height , rx , ry , true ) ; } 
public Path rect ( double x , double y , double width , double height , double rx , double ry , boolean draw ) { Path p = createPath ( ) ; switch ( rectMode ) { case CENTER : p . rect ( x , y , width , height , rx , ry ) ; break ; case CORNER : p . cornerRect ( x , y , width , height , rx , ry ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path oval ( double x , double y , double width , double height ) { TODO: Deprecation warning return ellipse(x, y, width, height, true); } 
public Path oval ( double x , double y , double width , double height , boolean draw ) { TODO: Deprecation warning return ellipse(x, y, width, height, draw); } 
public Path ellipse ( double x , double y , double width , double height ) { return ellipse ( x , y , width , height , true ) ; } 
public Path ellipse ( double x , double y , double width , double height , boolean draw ) { Path p = createPath ( ) ; switch ( ellipseMode ) { case CENTER : p . ellipse ( x , y , width , height ) ; break ; case CORNER : p . cornerEllipse ( x , y , width , height ) ; break ; } inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path line ( double x1 , double y1 , double x2 , double y2 ) { return line ( x1 , y1 , x2 , y2 , true ) ; } 
public Path line ( double x1 , double y1 , double x2 , double y2 , boolean draw ) { Path p = createPath ( ) ; p . line ( x1 , y1 , x2 , y2 ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path star ( double cx , double cy ) { return star ( cx , cy , 20 , 100 , 50 , true ) ; } 
public Path star ( double cx , double cy , int points ) { return star ( cx , cy , points , 100 , 50 , true ) ; } 
public Path star ( double cx , double cy , int points , double outer ) { return star ( cx , cy , points , outer , 50 , true ) ; } 
public Path star ( double cx , double cy , int points , double outer , double inner ) { return star ( cx , cy , points , outer , inner , true ) ; } 
public Path star ( double cx , double cy , int points , double outer , double inner , boolean draw ) { double PI = ( double ) Math . PI ; Path p = createPath ( ) ; p . moveto ( cx , cy + outer ) ; for ( int i = 1 ; i < points * 2 ; i + + ) { double angle = i * PI / points ; double x = ( double ) Math . sin ( angle ) ; double y = ( double ) Math . cos ( angle ) ; double radius = i % 2 = = 0 ? outer : inner ; x + = cx + radius * x ; y + = cy + radius * y ; p . lineto ( x , y ) ; } p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public Path arrow ( double x , double y ) { return arrow ( x , y , 100 , ArrowType . NORMAL , true ) ; } 
public Path arrow ( double x , double y , ArrowType type ) { return arrow ( x , y , 100 , type , true ) ; } 
public Path arrow ( double x , double y , String type ) { return arrow ( x , y , 100 , type , true ) ; } 
public Path arrow ( double x , double y , int type ) { return arrow ( x , y , 100 , type , true ) ; } 
public Path arrow ( double x , double y , double width ) { return arrow ( x , y , width , NORMAL , true ) ; } 
public Path arrow ( double x , double y , double width , boolean draw ) { return arrow ( x , y , width , NORMAL , draw ) ; } 
public Path arrow ( double x , double y , double width , ArrowType type ) { return arrow ( x , y , width , type , true ) ; } 
public Path arrow ( double x , double y , double width , String type ) { return arrow ( x , y , width , type , true ) ; } 
public Path arrow ( double x , double y , double width , int type ) { return arrow ( x , y , width , type , true ) ; } 
public Path arrow ( double x , double y , double width , String type , boolean draw ) { try { ArrowType arrowType = ArrowType . valueOf ( type . toUpperCase ( Locale . US ) ) ; 
public Path arrow ( double x , double y , double width , int type , boolean draw ) { try { ArrowType arrowType = ArrowType . values ( ) [ type ] ; 
public Path arrow ( double x , double y , double width , ArrowType type , boolean draw ) { if ( type = = ArrowType . NORMAL ) return arrowNormal ( x , y , width , draw ) ; 
private Path arrowNormal ( double x , double y , double width , boolean draw ) { double head = width * .4 ; double tail = width * .2 ; Path p = createPath ( ) ; p . moveto ( x , y ) ; p . lineto ( x - head , y + head ) ; p . lineto ( x - head , y + tail ) ; p . lineto ( x - width , y + tail ) ; p . lineto ( x - width , y - tail ) ; p . lineto ( x - head , y - tail ) ; p . lineto ( x - head , y - head ) ; p . lineto ( x , y ) ; p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
private Path arrowFortyFive ( double x , double y , double width , boolean draw ) { double head = .3 ; double tail = 1 + head ; Path p = createPath ( ) ; p . moveto ( x , y ) ; p . lineto ( x , y + width * ( 1 - head ) ) ; p . lineto ( x - width * head , y + width ) ; p . lineto ( x - width * head , y + width * tail * .4 ) ; p . lineto ( x - width * tail * .6 , y + width ) ; p . lineto ( x - width , y + width * tail * .6 ) ; p . lineto ( x - width * tail * .4 , y + width * head ) ; p . lineto ( x - width , y + width * head ) ; p . lineto ( x - width * ( 1 - head ) , y ) ; p . lineto ( x , y ) ; p . close ( ) ; inheritFromContext ( p ) ; if ( draw ) addPath ( p ) ; return p ; } 
public void beginpath ( double x , double y ) { beginpath ( ) ; moveto ( x , y ) ; } 
public void moveto ( double x , double y ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginpath() first. " ) ; path . moveto ( x , y ) ; } 
public void lineto ( double x , double y ) { if ( path = = null ) throw new NodeBoxError ( " No current path. Use beginpath() first. " ) ; path . lineto ( x , y ) ; } 
public Path findpath ( List < Point > points , double curvature ) { Path path = Path . findPath ( points , curvature ) ; inheritFromContext ( path ) ; addPath ( path ) ; return path ; } 
public Color . Mode colormode ( Color . Mode mode ) { return colorMode = mode ; } 
public Color . Mode colormode ( Color . Mode mode , double range ) { colorRange = range ; return colorMode = mode ; } 
public Color . Mode colormode ( String mode ) { return colormode ( mode , colorRange ) ; } 
public Color . Mode colormode ( String mode , double range ) { try { Color . Mode newMode = Color . Mode . valueOf ( mode . toUpperCase ( Locale . US ) ) ; 
public Color . Mode colormode ( int mode ) { return colormode ( mode , colorRange ) ; } 
public Color . Mode colormode ( int mode , double range ) { try { Color . Mode newMode = Color . Mode . values ( ) [ mode ] ; 
public double colorrange ( double range ) { return colorRange = range ; } 
public Color color ( double x ) { double nx = normalize ( x ) ; return new Color ( nx , nx , nx ) ; } 
public Color color ( double x , double y ) { double nx = normalize ( x ) ; return new Color ( nx , nx , nx , normalize ( y ) ) ; } 
public Color color ( double x , double y , double z ) { return new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , colormode ( ) ) ; } 
public Color color ( double x , double y , double z , double a ) { return new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , normalize ( a ) , colormode ( ) ) ; } 
public Color fill ( double x ) { double nx = normalize ( x ) ; return fillColor = new Color ( nx , nx , nx ) ; } 
public Color fill ( double x , double y ) { double nx = normalize ( x ) ; return fillColor = new Color ( nx , nx , nx , normalize ( y ) ) ; } 
public Color fill ( double x , double y , double z ) { return fillColor = new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , colormode ( ) ) ; } 
public Color fill ( double x , double y , double z , double a ) { return fillColor = new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , normalize ( a ) , colormode ( ) ) ; } 
public Color stroke ( double x ) { double nx = normalize ( x ) ; return strokeColor = new Color ( nx , nx , nx ) ; } 
public Color stroke ( double x , double y ) { double nx = normalize ( x ) ; return strokeColor = new Color ( nx , nx , nx , normalize ( y ) ) ; } 
public Color stroke ( double x , double y , double z ) { return strokeColor = new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , colormode ( ) ) ; } 
public Color stroke ( double x , double y , double z , double a ) { return strokeColor = new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , normalize ( a ) , colormode ( ) ) ; } 
public double strokewidth ( double w ) { return strokeWidth = w ; } 
public Image image ( String path , double x , double y ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , double x , double y , double width ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , double x , double y , double width , double height ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , double x , double y , double width , double height , double alpha ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , double x , double y , double width , double height , boolean draw ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) { throw new RuntimeException ( " 'image' is not applicable to this type of GraphicsContext. " ) ; } 
public Size imagesize ( String path ) { throw new RuntimeException ( " 'imagesize' is not applicable to this type of GraphicsContext. " ) ; } 
public Size imagesize ( Image img ) { throw new RuntimeException ( " 'imagesize' is not applicable to this type of GraphicsContext. " ) ; } 
public Size imagesize ( BufferedImage img ) { throw new RuntimeException ( " 'imagesize' is not applicable to this type of GraphicsContext. " ) ; } 
public String font ( String fontName , double fontSize ) { font ( fontName ) ; fontsize ( fontSize ) ; return fontName ; } 
public double fontsize ( double s ) { return fontSize = s ; } 
public double lineheight ( double lineHeight ) { return this . lineHeight = lineHeight ; } 
public Text text ( String text , double x , double y ) { return text ( text , x , y , 0 , 0 , true ) ; } 
public Text text ( String text , double x , double y , double width ) { return text ( text , x , y , width , 0 , true ) ; } 
public Text text ( String text , double x , double y , double width , double height ) { return text ( text , x , y , width , height , true ) ; } 
public Text text ( String text , double x , double y , double width , double height , boolean draw ) { Text = new Text ( text , x , y , width , height ) ; . setTransformDelegate ( new ContextTransformDelegate ( this ) ) ; inheritFromContext ( ) ; if ( draw ) addText ( ) ; return ; } 
public Path textpath ( String text , double x , double y ) { return textpath ( text , x , y , 0 , 0 ) ; } 
public Path textpath ( String text , double x , double y , double width ) { return textpath ( text , x , y , width , 0 ) ; } 
public Path textpath ( String text , double x , double y , double width , double height ) { Text = new Text ( text , x , y , width , height ) ; inheritFontAttributesFromContext ( ) ; Path path = . getPath ( ) ; path . setTransformDelegate ( new ContextTransformDelegate ( this ) ) ; inheritFromContext ( path ) ; return path ; } 
public Rect textmetrics ( String text , double width ) { return textmetrics ( text , width , 0 ) ; } 
public Rect textmetrics ( String text , double width , double height ) { Text = new Text ( text , 0 , 0 , width , height ) ; inheritFromContext ( ) ; return . getMetrics ( ) ; } 
public double textwidth ( String text ) { return textmetrics ( text , 0 , 0 ) . getWidth ( ) ; } 
public double textwidth ( String text , double width ) { return textmetrics ( text , width ) . getWidth ( ) ; } 
public double textheight ( String text ) { return textmetrics ( text , 0 , 0 ) . getHeight ( ) ; } 
public double textheight ( String text , double width ) { return textmetrics ( text , width ) . getHeight ( ) ; } 
public void var ( String name , VarType type ) { var ( name , type , null , 0 , 1000 ) ; } 
public void var ( String name , String type ) { var ( name , type , null , 0 , 1000 ) ; } 
public void var ( String name , int type ) { var ( name , type , 0 , 0 , 1000 ) ; } 
public void var ( String name , VarType type , Object value ) { var ( name , type , value , 0 , 1000 ) ; } 
public void var ( String name , String type , Object value ) { var ( name , type , value , 0 , 1000 ) ; } 
public void var ( String name , int type , Object value ) { var ( name , type , value , 0 , 1000 ) ; } 
public void var ( String name , String type , Object value , double min , double max ) { try { var ( name , VarType . valueOf ( type . toUpperCase ( Locale . US ) ) , value , min , max ) ; 
public void var ( String name , int type , Object value , double min , double max ) { try { var ( name , VarType . values ( ) [ type ] , value , min , max ) ; 
public Port findVar ( String name ) { Node node = ProcessingContext.getCurrentContext().getNode(); if (node == null) return null; return node.getInput(name); return null; } 
protected double normalize ( double v ) { Bring the color into the 0-1 scale for the current colorrange if (colorRange == 1) return v; return v / colorRange; 
public Iterator < Point > grid ( double columns , double rows ) { return grid ( Math . round ( columns ) , Math . round ( rows ) , 1 , 1 ) ; } 
public Iterator < Point > grid ( double columns , double rows , double columnSize , double rowSize ) { return grid ( Math . round ( columns ) , Math . round ( rows ) , columnSize , rowSize ) ; } 
public Point next ( ) { Point pt = new Point ( ( double ) ( x * columnSize ) , ( double ) ( y * rowSize ) ) ; x + + ; if ( x > = columns ) { x = 0 ; y + + ; } return pt ; } 
protected abstract void addPath ( Path p ) ; protected abstract void addText ( Text ) ; protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; TransformDelegate d = p . getTransformDelegate ( ) ; d . transform ( p , transform , true ) ; } protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; inheritFontAttributesFromContext ( ) ; todo: check if this is sufficient. TransformDelegate d = t.getTransformDelegate(); d.transform(t, transform, true); } private void inheritFontAttributesFromContext(Text t) { t.setFontName(fontName); t.setFontSize(fontSize); t.setLineHeight(lineHeight); t.setAlign(align); }} 
protected abstract void addText ( Text ) ; protected void inheritFromContext ( Path p ) { p . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; p . setStrokeColor ( strokeColor = = null ? null : strokeColor . clone ( ) ) ; p . setStrokeWidth ( strokeWidth ) ; TransformDelegate d = p . getTransformDelegate ( ) ; d . transform ( p , transform , true ) ; } protected void inheritFromContext ( Text ) { . setFillColor ( fillColor = = null ? null : fillColor . clone ( ) ) ; inheritFontAttributesFromContext ( ) ; todo: check if this is sufficient. TransformDelegate d = t.getTransformDelegate(); d.transform(t, transform, true); } private void inheritFontAttributesFromContext(Text t) { t.setFontName(fontName); t.setFontSize(fontSize); t.setLineHeight(lineHeight); t.setAlign(align); }} 
public void translate ( double tx , double ty ) { Transform = Transform . translated ( tx , ty ) ; transformDelegate . transform ( this , ) ; } 
public void rotate ( double degrees ) { Transform = Transform . rotated ( degrees ) ; transformDelegate . transform ( this , ) ; } 
public void rotateRadians ( double radians ) { Transform = Transform . rotatedRadians ( radians ) ; transformDelegate . transform ( this , ) ; } 
public void scale ( double scale ) { Transform = Transform . scaled ( scale ) ; transformDelegate . transform ( this , ) ; } 
public void scale ( double sx , double sy ) { Transform = Transform . scaled ( sx , sy ) ; transformDelegate . transform ( this , ) ; } 
public void skew ( double skew ) { Transform = Transform . skewed ( skew ) ; transformDelegate . transform ( this , ) ; } 
public void skew ( double kx , double ky ) { Transform = Transform . skewed ( kx , ky ) ; transformDelegate . transform ( this , ) ; } 
public boolean containsKey ( Object key ) { return fields . contains ( key ) ; } 
public boolean containsValue ( Object value ) { for ( String field : fields ) { Object fieldValue = get ( field ) ; if ( Objects . equal ( fieldValue , value ) ) return true ; } return false ; } 
private void ensureGetterMap ( ) { if ( getterMap ! = null ) return ; ImmutableMap . Builder < String , Method > b = ImmutableMap . builder ( ) ; for ( String field : fields ) { Method m = getGetterMethod ( getClass ( ) , field ) ; if ( m = = null ) { throw new RuntimeException ( " The field " + field + " could not be found in " + this ) ; } b . put ( field , m ) ; } getterMap = b . build ( ) ; } 
public Object get ( Object key ) { ensureGetterMap ( ) ; checkArgument ( getterMap . containsKey ( key ) , " Key %s not found in object %s " , key , this ) ; Method getterMethod = getterMap . get ( key ) ; try { return getterMethod . invoke ( this ) ; 
public Object put ( String key , Object value ) { throw new UnsupportedOperationException ( " Records are immutable. " ) ; } 
public Object remove ( Object key ) { throw new UnsupportedOperationException ( " Records are immutable. " ) ; } 
public void putAll ( Map < ? extends String , ? > m ) { throw new UnsupportedOperationException ( " Records are immutable. " ) ; } 
public void clear ( ) { throw new UnsupportedOperationException ( " Records are immutable. " ) ; } 
public Set < String > keySet ( ) { return Sets . newHashSet ( fields ) ; } 
public Collection < Object > values ( ) { throw new UnsupportedOperationException ( " The values() method is unsupported. " ) ; } 
public Set < Entry < String , Object > > entrySet ( ) { throw new UnsupportedOperationException ( " The entrySet() method is unsupported. " ) ; } 
public BufferedImage asImage ( ) { Rect bounds = getBounds ( ) ; BufferedImage img = new BufferedImage ( ( int ) Math . round ( bounds . getWidth ( ) ) , ( int ) Math . round ( bounds . getHeight ( ) ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = img . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . translate ( - bounds . getX ( ) , - bounds . getY ( ) ) ; draw ( g ) ; img . flush ( ) ; return img ; } 
public Color background ( double x ) { double nx = normalize ( x ) ; return canvas . setBackground ( new Color ( nx , nx , nx ) ) ; } 
public Color background ( double x , double y ) { double nx = normalize ( x ) ; return canvas . setBackground ( new Color ( nx , nx , nx , normalize ( y ) ) ) ; } 
public Color background ( double x , double y , double z ) { return canvas . setBackground ( new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , colormode ( ) ) ) ; } 
public Color background ( double x , double y , double z , double a ) { return canvas . setBackground ( new Color ( normalize ( x ) , normalize ( y ) , normalize ( z ) , normalize ( a ) , colormode ( ) ) ) ; } 
public Image image ( String path , double x , double y ) { return image ( path , x , y , 0 , 0 , 1 , true ) ; } 
public Image image ( String path , double x , double y , double width ) { return image ( path , x , y , width , 0 , 1 , true ) ; } 
public Image image ( String path , double x , double y , double width , double height ) { return image ( path , x , y , width , height , 1 , true ) ; } 
public Image image ( String path , double x , double y , double width , double height , double alpha ) { return image ( path , x , y , width , height , alpha , true ) ; } 
public Image image ( String path , double x , double y , double width , double height , boolean draw ) { return image ( path , x , y , width , height , 1.0 , draw ) ; } 
public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) { return loadImage ( new Image ( path ) , x , y , width , height , alpha , draw ) ; } 
public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) { return loadImage ( img . clone ( ) , x , y , width , height , alpha , draw ) ; } 
public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) { return loadImage ( new Image ( img ) , x , y , width , height , alpha , draw ) ; } 
private Image loadImage ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) { if ( width ! = 0 ) img . setWidth ( width ) ; if ( height ! = 0 ) img . setHeight ( height ) ; switch ( imageMode ) { case CORNER : double w = img . getWidth ( ) ; double h = img . getHeight ( ) ; img . setX ( x + w / 2 ) ; img . setY ( y + h / 2 ) ; break ; case CENTER : img . setX ( x ) ; img . setY ( y ) ; } todo: differentiate between newly constructed objects and copies. img.setTransformDelegate(new ContextTransformDelegate(this)); inheritFromContext(img); if (alpha != 1.0) img.setAlpha(alpha); if (draw) canvas.add(img); return img; } 
protected void inheritFromContext ( Image i ) { TransformDelegate d = i . getTransformDelegate ( ) ; d . transform ( i , transform , true ) ; } 
public static Color valueOf ( String hex ) { return new Color ( hex ) ; } 
private double [ ] updateRGB ( ) { if ( s = = 0 ) return new double [ ] { this . v , this . v , this . v } ; 
private double [ ] updateHSB ( ) { double h = 0 ; double s = 0 ; double v = Math . max ( Math . max ( r , g ) , b ) ; double d = v - Math . min ( Math . min ( r , g ) , b ) ; if ( v ! = 0 ) s = d / v ; if ( s ! = 0 ) { if ( r = = v ) h = 0 + ( g - b ) / d ; else if ( g = = v ) h = 2 + ( b - r ) / d ; else h = 4 + ( r - g ) / d ; } h = h * ( 60.0 / 360 ) ; if ( h < 0 ) h = h + 1 ; return new double [ ] { h , s , v } ; } 
void setFillColor ( Color fillColor ) ; void setFill ( Color c ) ; void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( double strokeWidth ) ; } 
void setFill ( Color c ) ; void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( double strokeWidth ) ; } 
void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( double strokeWidth ) ; } 
void setStroke ( Color c ) ; void setStrokeWidth ( double strokeWidth ) ; } 
public void addPoint ( Point pt ) { points . add ( pt ) ; invalidate ( ) ; } 
public void addPoint ( double x , double y ) { points . add ( new Point ( x , y ) ) ; invalidate ( ) ; } 
public double updateSegmentLengths ( ) { java . util . List < Point > points = getPoints ( ) ; segmentLengths = new ArrayList < Double > ( ) ; double totalLength = 0 ; We cannot form a line or curve with the first point. Since the algorithm looks back at previous points, we start looking from the first useful point, which is the second (index of 1). for (int pi = 1; pi < points.size(); pi++) { Point pt = points.get(pi); if (pt.isLineTo()) { Point pt0 = points.get(pi - 1); double length = Path.lineLength(pt0.x, pt0.y, pt.x, pt.y); segmentLengths.add(length); totalLength += length; } else if (pt.isCurveTo()) { Point pt0 = points.get(pi - 3); Point c1 = points.get(pi - 2); Point c2 = points.get(pi - 1); double length = Path.curveLength(pt0.x, pt0.y, c1.x, c1.y, c2.x, c2.y, pt.x, pt.y, SEGMENT_ACCURACY); segmentLengths.add(length); totalLength += length; } } If the path is closed, add the closing segment. if (closed && !points.isEmpty()) { Point pt0 = points.get(points.size() - 1); Point pt1 = points.get(0); double length = Path.lineLength(pt0.x, pt0.y, pt1.x, pt1.y); segmentLengths.add(length); totalLength += length; } this.length = totalLength; return totalLength; } 
public Point pointAt ( double ) { if ( segmentLengths = = null ) updateSegmentLengths ( ) ; Check if there is a path. if (points.isEmpty()) throw new NodeBoxError("The path is empty."); If the path has no length, return the position of the first point. if (length == 0) return points.get(0); Since t is relative, convert it to the absolute length. double absT = t * length; The resT is what remains of t after we traversed all segments. double resT = t; Find the segment that contains t. int segnum = -1; for (Double seglength : segmentLengths) { segnum++; if (absT <= seglength || segnum == segmentLengths.size() - 1) break; absT -= seglength; resT -= seglength / length; } resT /= (segmentLengths.get(segnum) / length); Find the point index for the segment. int pi = pointIndexForSegment(segnum + 1); Point pt1 = points.get(pi); If the path is closed, the point index is set to zero. Set the index to the last point to get the one-but-last point for pt0. if (pi == 0) { pi = points.size(); } if (pt1.isLineTo()) { Point pt0 = points.get(pi - 1); 
public Point [ ] makePoints ( int amount ) { If the contour is empty, pointAt will fail. Return an empty array. if (points.isEmpty()) return new Point[0]; Point[] points = new Point[amount]; double delta = 1; if (closed) { if (amount > 0) { delta = 1.0 / amount; } } else { The delta value is divided by amount - 1, because we also want the last point (t=1.0) If I wouldn't use amount - 1, I fall one point short of the end. E.g. if amount = 4, I want point at t 0.0, 0.33, 0.66 and 1.0, if amount = 2, I want point at t 0.0 and t 1.0 if (amount > 2) { delta = 1.0 / (amount - 1.0); } } for (int i = 0; i < amount; i++) { points[i] = pointAt(delta * i); } return points; } 
public Contour resampleByLength ( double segmentLength ) { if ( segmentLength < = 0.0000001 ) { throw new IllegalArgumentException ( " Segment length must be greater than zero. " ) ; } double contourLength = getLength ( ) ; int amount = ( int ) Math . ceil ( contourLength / segmentLength ) ; if ( closed ) { return resampleByAmount ( amount ) ; 
public void transform ( Transform ) { this . points = . map ( getPoints ( ) ) ; invalidate ( ) ; } 
public void add ( Geometry geometry ) { extend ( geometry ) ; } 
public void addPoint ( double x , double y ) { ensureCurrentPath ( ) ; currentPath . addPoint ( x , y ) ; invalidate ( false ) ; } 
private void updatePathLengths ( ) { pathLengths = new ArrayList < Double > ( paths . size ( ) ) ; groupLength = 0 ; double length ; for ( Path p : paths ) { length = p . getLength ( ) ; pathLengths . add ( length ) ; groupLength + = length ; } lengthDirty = false ; } 
public Point pointAt ( double ) { double length = getLength ( ) ; Since t is relative, convert it to the absolute length. double absT = t * length; The resT is what remains of t after we traversed all segments. double resT = t; Find the contour that contains t. double cLength; Path currentPath = null; for (Path p : paths) { currentPath = p; cLength = p.getLength(); if (absT <= cLength) break; absT -= cLength; resT -= cLength / length; } if (currentPath == null) return Point.ZERO; resT /= (currentPath.getLength() / length); return currentPath.pointAt(resT); } 
public boolean contains ( double x , double y ) { for ( Path p : paths ) { if ( p . contains ( x , y ) ) { return true ; } } return false ; } 
public Geometry resampleByLength ( double segmentLength ) { Geometry g = new Geometry ( ) ; for ( Path p : paths ) { g . add ( p . resampleByLength ( segmentLength ) ) ; } return g ; } 
public double colorrange ( ) ; public double colorrange ( double range ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double colorrange ( double range ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( double x ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( double x , double y ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( double x , double y , double z ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( double x , double y , double z , double a ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( Color c ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( double x ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( double x , double y ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( double x , double y , double z ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( double x , double y , double z , double a ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( Color c ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nofill ( ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( double x ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( double x , double y ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( double x , double y , double z ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( double x , double y , double z , double a ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( Color c ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type , Object value , double min , double max ) ; public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Port findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void draw ( Graphics2D g ) ; Geometric queries public boolean isEmpty(); public Rect getBounds(); Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(double tx, double ty); void rotate(double degrees); void rotateRadians(double radians); void scale(double scale); void scale(double sx, double sy); void skew(double skew); void skew(double kx, double ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public boolean isEmpty ( ) ; public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(double tx, double ty); void rotate(double degrees); void rotateRadians(double radians); void scale(double scale); void scale(double sx, double sy); void skew(double skew); void skew(double kx, double ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(double tx, double ty); void rotate(double degrees); void rotateRadians(double radians); void scale(double scale); void scale(double sx, double sy); void skew(double skew); void skew(double kx, double ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public void transform ( Transform ) ; Cloning public Grob clone(); void translate(double tx, double ty); void rotate(double degrees); void rotateRadians(double radians); void scale(double scale); void scale(double sx, double sy); void skew(double skew); void skew(double kx, double ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public Grob clone ( ) ; void translate ( double tx , double ty ) ; void rotate ( double degrees ) ; void rotateRadians ( double radians ) ; void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void translate ( double tx , double ty ) ; void rotate ( double degrees ) ; void rotateRadians ( double radians ) ; void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void rotate ( double degrees ) ; void rotateRadians ( double radians ) ; void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void rotateRadians ( double radians ) ; void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public int getPointCount ( ) ; public IGeometry clone();} 
public List < Point > getPoints ( ) ; public IGeometry clone();} 
public void addPoint ( Point pt ) ; public IGeometry clone();} 
public void addPoint ( double x , double y ) ; public IGeometry clone();} 
public void extend ( Iterator < Point > points ) ; public IGeometry clone();} 
public void extend ( Point [ ] points ) ; Geometric operations public IGeometry clone();} 
public Point [ ] makePoints ( ) ; public IGeometry clone ( ) ; } 
public Point [ ] makePoints ( int amount ) ; public IGeometry clone ( ) ; } 
public Point [ ] makePoints ( int amount , boolean perContour ) ; public IGeometry clone ( ) ; } 
public IGeometry resampleByAmount ( int amount , boolean perContour ) ; public IGeometry clone ( ) ; } 
public IGeometry resampleByLength ( double segmentLength ) ; public IGeometry clone ( ) ; } 
public static BufferedImage createImage ( Iterable < ? > objects ) { Visualizer v = Viewer . getVisualizer ( objects , ListUtils . listClass ( objects ) ) ; return createImage ( v , objects ) ; } 
private static BufferedImage createImage ( Visualizer visualizer , Iterable < ? > objects ) { Rectangle2D bounds = visualizer . getBounds ( objects ) ; BufferedImage img = new BufferedImage ( ( int ) Math . round ( bounds . getWidth ( ) ) , ( int ) Math . round ( bounds . getHeight ( ) ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = img . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . translate ( - bounds . getX ( ) , - bounds . getY ( ) ) ; visualizer . draw ( g , objects ) ; img . flush ( ) ; return img ; } 
protected Void doInBackground ( ) throws Exception { fontMapper = new com . itextpdf . text . pdf . DefaultFontMapper ( ) ; String osName = System . getProperty ( " os.name " ) ; if ( osName . startsWith ( " Windows " ) ) { TODO: Windows is not installed under C:\Windows all the time. fontMapper.insertDirectory("C:\\windows\\fonts"); } else if (osName.startsWith("Mac OS X")) { fontMapper.insertDirectory("/Library/Fonts"); String userHome = System.getProperty("user.home"); fontMapper.insertDirectory(userHome + "/Fonts"); } else { Where are the fonts in a UNIX install? } return null; } 
protected void done ( ) { pd . setVisible ( false ) ; } 
public static void render ( File file , Visualizer v , Iterable < ? > objects ) { I'm using fully qualified class names here so as not to pollute the class' namespace. Rectangle2D bounds = v.getBounds(objects); com.itextpdf.text.Rectangle size = new com.itextpdf.text.Rectangle((float) bounds.getWidth(), (float) bounds.getHeight()); com.itextpdf.text.Document document = new com.itextpdf.text.Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } com.itextpdf.text.pdf.PdfWriter writer; try { writer = com.itextpdf.text.pdf.PdfWriter.getInstance(document, fos); } catch (com.itextpdf.text.DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); com.itextpdf.text.pdf.PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = contentByte.createGraphics((float) bounds.getWidth(), (float) bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); v.draw(graphics, objects); graphics.dispose(); document.close(); } 
public static void render ( Grob g , File file ) { I'm using fully qualified class names here so as not to pollute the class' namespace. Rect bounds = g.getBounds(); com.itextpdf.text.Rectangle size = new com.itextpdf.text.Rectangle((float) bounds.getWidth(), (float) bounds.getHeight()); com.itextpdf.text.Document document = new com.itextpdf.text.Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } com.itextpdf.text.pdf.PdfWriter writer; try { writer = com.itextpdf.text.pdf.PdfWriter.getInstance(document, fos); } catch (com.itextpdf.text.DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); com.itextpdf.text.pdf.PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = contentByte.createGraphics((float) bounds.getWidth(), (float) bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); g.draw(graphics); graphics.dispose(); document.close(); } 
public void moveto ( double x , double y ) { Stop using the current contour. addPoint will automatically create a new contour. currentContour = null; addPoint(x, y); } 
public void lineto ( double x , double y ) { if ( currentContour = = null ) throw new RuntimeException ( " Lineto without moveto first. " ) ; addPoint ( x , y ) ; } 
public void curveto ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { if ( currentContour = = null ) throw new RuntimeException ( " Curveto without moveto first. " ) ; addPoint ( new Point ( x1 , y1 , Point . CURVE_DATA ) ) ; addPoint ( new Point ( x2 , y2 , Point . CURVE_DATA ) ) ; addPoint ( new Point ( x3 , y3 , Point . CURVE_TO ) ) ; } 
public void addPoint ( double x , double y ) { ensureCurrentContour ( ) ; currentContour . addPoint ( x , y ) ; invalidate ( false ) ; } 
public void rect ( double cx , double cy , double width , double height ) { double w2 = width / 2 ; double h2 = height / 2 ; addPoint ( cx - w2 , cy - h2 ) ; addPoint ( cx + w2 , cy - h2 ) ; addPoint ( cx + w2 , cy + h2 ) ; addPoint ( cx - w2 , cy + h2 ) ; close ( ) ; } 
public void cornerRect ( double x , double y , double width , double height ) { addPoint ( x , y ) ; addPoint ( x + width , y ) ; addPoint ( x + width , y + height ) ; addPoint ( x , y + height ) ; close ( ) ; } 
public void cornerRect ( Rect r ) { cornerRect ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) ) ; } 
public void cornerRect ( Rect r , double roundness ) { roundedRect ( Rect . corneredRect ( r ) , roundness ) ; } 
public void cornerRect ( Rect r , double rx , double ry ) { roundedRect ( Rect . corneredRect ( r ) , rx , ry ) ; } 
public void cornerRect ( double cx , double cy , double width , double height , double r ) { roundedRect ( Rect . corneredRect ( cx , cy , width , height ) , r ) ; } 
public void cornerRect ( double cx , double cy , double width , double height , double rx , double ry ) { roundedRect ( Rect . corneredRect ( cx , cy , width , height ) , rx , ry ) ; } 
public void roundedRect ( double cx , double cy , double width , double height , double rx , double ry ) { double halfWidth = width / 2 ; double halfHeight = height / 2 ; double dx = rx ; double dy = ry ; double left = cx - halfWidth ; double right = cx + halfWidth ; double top = cy - halfHeight ; double bottom = cy + halfHeight ; rx/ry cannot be greater than half of the width of the rectangle (required by SVG spec) dx = Math.min(dx, width * 0.5); dy = Math.min(dy, height * 0.5); moveto(left + dx, top); if (dx < width * 0.5) lineto(right - rx, top); curveto(right - dx * ONE_MINUS_QUARTER, top, right, top + dy * ONE_MINUS_QUARTER, right, top + dy); if (dy < height * 0.5) lineto(right, bottom - dy); curveto(right, bottom - dy * ONE_MINUS_QUARTER, right - dx * ONE_MINUS_QUARTER, bottom, right - dx, bottom); if (dx < width * 0.5) lineto(left + dx, bottom); curveto(left + dx * ONE_MINUS_QUARTER, bottom, left, bottom - dy * ONE_MINUS_QUARTER, left, bottom - dy); if (dy < height * 0.5) lineto(left, top + dy); curveto(left, top + dy * ONE_MINUS_QUARTER, left + dx * ONE_MINUS_QUARTER, top, left + dx, top); close(); } 
public void cornerEllipse ( double x , double y , double width , double height ) { Ellipse2D . Double e = new Ellipse2D . Double ( x , y , width , height ) ; extend ( e ) ; } 
public void extend ( Shape s ) { PathIterator pi = s . getPathIterator ( new AffineTransform ( ) ) ; double px = 0 ; double py = 0 ; while ( ! pi . isDone ( ) ) { double [ ] points = new double [ 6 ] ; int cmd = pi . currentSegment ( points ) ; if ( cmd = = PathIterator . SEG_MOVETO ) { px = points [ 0 ] ; py = points [ 1 ] ; moveto ( px , py ) ; } else if ( cmd = = PathIterator . SEG_LINETO ) { px = points [ 0 ] ; py = points [ 1 ] ; lineto ( px , py ) ; } else if ( cmd = = PathIterator . SEG_QUADTO ) { Convert the quadratic bezier to a cubic bezier. double c1x = px + (points[0] - px) * 2 / 3; double c1y = py + (points[1] - py) * 2 / 3; double c2x = points[0] + (points[2] - points[0]) / 3; double c2y = points[1] + (points[3] - points[1]) / 3; curveto(c1x, c1y, c2x, c2y, points[2], points[3]); px = points[2]; py = points[3]; } else if (cmd == PathIterator.SEG_CUBICTO) { px = points[4]; py = points[5]; curveto(points[0], points[1], points[2], points[3], px, py); } else if (cmd == PathIterator.SEG_CLOSE) { px = py = 0; close(); } else { throw new AssertionError("Unknown path command " + cmd); } pi.next(); } invalidate(false); } 
private void updateContourLengths ( ) { contourLengths = new ArrayList < Double > ( contours . size ( ) ) ; pathLength = 0 ; double length ; for ( Contour c : contours ) { length = c . getLength ( ) ; contourLengths . add ( length ) ; pathLength + = length ; } lengthDirty = false ; } 
public Contour contourAt ( double ) { Since t is relative, convert it to the absolute length. double absT = t * getLength(); Find the contour that contains t. double cLength; for (Contour c : contours) { cLength = c.getLength(); if (absT <= cLength) return c; absT -= cLength; } return null; } 
public Point pointAt ( double ) { double length = getLength ( ) ; Since t is relative, convert it to the absolute length. double absT = t * length; The resT is what remains of t after we traversed all segments. double resT = t; Find the contour that contains t. double cLength; Contour currentContour = null; for (Contour c : contours) { currentContour = c; cLength = c.getLength(); if (absT <= cLength) break; absT -= cLength; resT -= cLength / length; } if (currentContour == null) return new Point(); resT /= (currentContour.getLength() / length); return currentContour.pointAt(resT); } 
public Path resampleByLength ( double segmentLength ) { Path p = cloneAndClear ( ) ; for ( Contour c : contours ) { p . add ( c . resampleByLength ( segmentLength ) ) ; } return p ; } 
public static Path findPath ( java . util . List < Point > points , double curvature ) { Point [ ] pts = new Point [ points . size ( ) ] ; points . toArray ( pts ) ; return findPath ( pts , curvature ) ; } 
public static Path findPath ( Point [ ] points , double curvature ) { if ( points . length = = 0 ) return null ; if ( points . length = = 1 ) { Path path = new Path ( ) ; path . moveto ( points [ 0 ] . x , points [ 0 ] . y ) ; return path ; } if ( points . length = = 2 ) { Path path = new Path ( ) ; path . moveto ( points [ 0 ] . x , points [ 0 ] . y ) ; path . lineto ( points [ 1 ] . x , points [ 1 ] . y ) ; return path ; } Zero curvature means straight lines. curvature = Math.max(0, Math.min(1, curvature)); if (curvature == 0) { Path path = new Path(); path.moveto(points[0].x, points[0].y); for (Point point : points) path.lineto(point.x, point.y); return path; } curvature = 4 + (1.0 - curvature) * 40; HashMap<Integer, Double> dx, dy, bi, ax, ay; dx = new HashMap<Integer, Double>(); dy = new HashMap<Integer, Double>(); bi = new HashMap<Integer, Double>(); ax = new HashMap<Integer, Double>(); ay = new HashMap<Integer, Double>(); dx.put(0, 0.0); dx.put(points.length - 1, 0.0); dy.put(0, 0.0); dy.put(points.length - 1, 0.0); bi.put(1, -0.25); ax.put(1, (points[2].x - points[0].x - dx.get(0)) / 4); ay.put(1, (points[2].y - points[0].y - dy.get(0)) / 4); for (int i = 2; i < points.length - 1; i++) { bi.put(i, -1 / (curvature + bi.get(i - 1))); ax.put(i, -(points[i + 1].x - points[i - 1].x - ax.get(i - 1)) * bi.get(i)); ay.put(i, -(points[i + 1].y - points[i - 1].y - ay.get(i - 1)) * bi.get(i)); } for (int i = points.length - 2; i >= 1; i--) { dx.put(i, ax.get(i) + dx.get(i + 1) * bi.get(i)); dy.put(i, ay.get(i) + dy.get(i + 1) * bi.get(i)); } Path path = new Path(); path.moveto(points[0].x, points[0].y); for (int i = 0; i < points.length - 1; i++) { path.curveto(points[i].x + dx.get(i), points[i].y + dy.get(i), points[i + 1].x - dx.get(i + 1), points[i + 1].y - dy.get(i + 1), points[i + 1].x, points[i + 1].y); } return path; } 
public boolean contains ( Point p ) { return getGeneralPath ( ) . contains ( p . toPoint2D ( ) ) ; } 
public void transform ( Transform ) { for ( Contour c : contours ) { c . setPoints ( . map ( c . getPoints ( ) ) ) ; } invalidate ( true ) ; } 
private boolean fuzzyCompare ( double p1 , double p2 ) { return Math . abs ( p1 - p2 ) < = ( 0.000000000001 * Math . min ( Math . abs ( p1 ) , Math . abs ( p2 ) ) ) ; } 
public Point pointAt ( double ) { double coeff [ ] , a , b , c , d ; coeff = coefficients ( ) ; a = coeff [ 0 ] ; b = coeff [ 1 ] ; c = coeff [ 2 ] ; d = coeff [ 3 ] ; return new Point ( a * x1 + b * x2 + c * x3 + d * x4 , a * y1 + b * y2 + c * y3 + d * y4 ) ; } 
private double [ ] coefficients ( double ) { double m_t , a , b , c , d ; m_t = 1 - ; b = m_t * m_t ; c = * ; d = c * ; a = b * m_t ; b * = ( 3. * ) ; c * = ( 3. * m_t ) ; return new double [ ] { a , b , c , d } ; } 
private void bezierCheck ( double ) { if ( > = 0 & & < = 1 ) { Point p = pointAt ( ) ; 
public Rect extrema ( ) { double ax , bx , cx , ay , by , cy ; if ( x1 < x4 ) { minx = x1 ; maxx = x4 ; } else { minx = x4 ; maxx = x1 ; } if ( y1 < y4 ) { miny = y1 ; maxy = y4 ; } else { miny = y4 ; maxy = y1 ; } ax = 3 * ( - x1 + 3 * x2 - 3 * x3 + x4 ) ; bx = 6 * ( x1 - 2 * x2 + x3 ) ; cx = 3 * ( - x1 + x2 ) ; if ( fuzzyCompare ( ax + 1 , 1 ) ) { if ( ! fuzzyCompare ( bx + 1 , 1 ) ) { double = - cx / bx ; bezierCheck ( ) ; } } else { double tx = bx * bx - 4 * ax * cx ; if ( tx > = 0 ) { double temp , rcp , t1 , t2 ; temp = ( double ) Math . sqrt ( tx ) ; rcp = 1 / ( 2 * ax ) ; t1 = ( - bx + temp ) * rcp ; bezierCheck ( t1 ) ; t2 = ( - bx - temp ) * rcp ; bezierCheck ( t2 ) ; } } ay = 3 * ( - y1 + 3 * y2 - 3 * y3 + y4 ) ; by = 6 * ( y1 - 2 * y2 + y3 ) ; cy = 3 * ( - y1 + y2 ) ; if ( fuzzyCompare ( ay + 1 , 1 ) ) { if ( ! fuzzyCompare ( by + 1 , 1 ) ) { double = - cy / by ; bezierCheck ( ) ; } } else { double ty = by * by - 4 * ay * cy ; if ( ty > 0 ) { double temp , rcp , t1 , t2 ; temp = ( double ) Math . sqrt ( ty ) ; rcp = 1 / ( 2 * ay ) ; t1 = ( - by + temp ) * rcp ; bezierCheck ( t1 ) ; t2 = ( - by - temp ) * rcp ; bezierCheck ( t2 ) ; } } return new Rect ( minx , miny , maxx - minx , maxy - miny ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof PathElement ) ) return false ; final PathElement other = ( PathElement ) o ; return Objects . equal ( command , other . command ) & & Objects . equal ( point , other . point ) 
public int hashCode ( ) { return Objects . hashCode ( command , point , control1 , control2 ) ; } 
public static Point valueOf ( String s ) { String [ ] args = s . split ( " , " ) ; checkArgument ( args . length = = 2 , " String ' " + s + " ' needs two components, i.e. 12.3,45.6 " ) ; return new Point ( Float . valueOf ( args [ 0 ] ) , Float . valueOf ( args [ 1 ] ) ) ; } 
public boolean isCurveData ( ) { return type = = CURVE_DATA ; } 
public Point moved ( double dx , double dy ) { return new Point ( x + dx , y + dy ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof Point ) ) return false ; final Point other = ( Point ) o ; return Objects . equal ( x , other . x ) & & Objects . equal ( y , other . y ) & & Objects . equal ( type , other . type ) ; } 
public int hashCode ( ) { return Objects . hashCode ( x , y , type ) ; } 
public String toString ( ) { return String . format ( Locale . US , " %.2f,%.2f " , x , y ) ; } 
public Point2D toPoint2D ( ) { return new Point2D . Double ( x , y ) ; } 
public static Rect corneredRect ( double cx , double cy , double width , double height ) { return new Rect ( cx + width / 2 , cy + height / 2 , width , height ) ; } 
public Rect normalized ( ) { double x = this . x ; double y = this . y ; double width = this . width ; double height = this . height ; if ( width < 0 ) { x + = width ; width = - width ; } if ( height < 0 ) { y + = height ; height = - height ; } return new Rect ( x , y , width , height ) ; } 
public Rect united ( Rect r ) { Rect r1 = normalized ( ) ; Rect r2 = r . normalized ( ) ; double x , y , width , height ; x = Math . min ( r1 . x , r2 . x ) ; y = Math . min ( r1 . y , r2 . y ) ; width = Math . max ( r1 . x + r1 . width , r2 . x + r2 . width ) - x ; height = Math . max ( r1 . y + r1 . height , r2 . y + r2 . height ) - y ; return new Rect ( x , y , width , height ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof Rect ) ) return false ; final Rect other = ( Rect ) o ; return Objects . equal ( x , other . x ) & & Objects . equal ( y , other . y ) 
public int hashCode ( ) { return Objects . hashCode ( x , y , width , height ) ; } 
public Iterator < Double > iterator ( ) { return ImmutableList . < Double > of ( x , y , width , height ) . iterator ( ) ; } 
public void draw ( Graphics2D g ) { if ( fillColor = = null ) return ; setupTransform ( g ) ; if ( text = = null | | text . length ( ) = = 0 ) return ; TextLayoutIterator iterator = new TextLayoutIterator ( ) ; while ( iterator . hasNext ( ) ) { TextLayout layout = iterator . next ( ) ; layout . draw ( g , ( float ) ( baseLineX + iterator . getX ( ) ) , ( float ) ( baseLineY + iterator . getY ( ) ) ) ; } restoreTransform ( g ) ; } 
public static Transform translated ( double tx , double ty ) { Transform = new Transform ( ) ; . translate ( tx , ty ) ; return ; } 
public static Transform translated ( Point ) { return translated ( . x , . y ) ; } 
public static Transform rotated ( double degrees ) { Transform = new Transform ( ) ; . rotate ( degrees ) ; return ; } 
public static Transform rotatedRadians ( double radians ) { Transform = new Transform ( ) ; . rotateRadians ( radians ) ; return ; } 
public static Transform scaled ( double scale ) { Transform = new Transform ( ) ; . scale ( scale ) ; return ; } 
public static Transform scaled ( double sx , double sy ) { Transform = new Transform ( ) ; . scale ( sx , sy ) ; return ; } 
public static Transform scaled ( Point s ) { return scaled ( s . x , s . y ) ; } 
public static Transform skewed ( double skew ) { Transform = new Transform ( ) ; . skew ( skew ) ; return ; } 
public static Transform skewed ( double kx , double ky ) { Transform = new Transform ( ) ; . skew ( kx , ky ) ; return ; } 
public void translate ( Point point ) { affineTransform . translate ( point . x , point . y ) ; } 
public Point map ( Point p ) { Point2D . Double p2 = new Point2D . Double ( ) ; affineTransform . transform ( p . toPoint2D ( ) , p2 ) ; return new Point ( p2 ) ; } 
public List < Point > map ( List < Point > points ) { Prepare the points for the AffineTransform transformation. double[] coords = new double[points.size() * 2]; int i = 0; for (Point pt : points) { coords[i++] = pt.x; coords[i++] = pt.y; } affineTransform.transform(coords, 0, coords, 0, points.size()); Convert the transformed points into a new List. List<Point> transformed = new ArrayList<Point>(points.size()); int pointIndex = 0; for (i = 0; i < coords.length; i += 2) { transformed.add(new Point(coords[i], coords[i + 1], points.get(pointIndex).type)); pointIndex++; } return transformed; } 
public boolean hasInput ( String portName ) { if ( delegate ! = null ) return delegate . hasInput ( portName ) ; return false ; } 
public boolean isConnected ( String portName ) { if ( delegate ! = null ) return delegate . isConnected ( portName ) ; return false ; } 
public void silentSet ( String portName , Object value ) { if ( delegate ! = null & & ! isConnected ( portName ) ) delegate . silentSet ( portName , value ) ; 
public void startCombiningEdits ( String command ) { if ( delegate ! = null & & ! combinesEdits ) { delegate . startEdits ( command ) ; 
public void updateHandle ( ) { if ( delegate ! = null ) delegate . updateHandle ( ) ; 
protected void drawDot ( GraphicsContext ctx , double x , double y ) { ctx . rectmode ( GraphicsContext . RectMode . CENTER ) ; ctx . fill ( HANDLE_COLOR ) ; ctx . rect ( x , y , HANDLE_SIZE , HANDLE_SIZE ) ; } 
protected void drawDot ( Path p , double x , double y ) { p . rect ( x , y , HANDLE_SIZE , HANDLE_SIZE ) ; } 
public void draw ( GraphicsContext ctx ) { Point center = getCenter ( ) ; double x = center . x ; double y = center . y ; double radius = getRadius ( ) ; ctx . nofill ( ) ; ctx . ellipsemode ( GraphicsContext . EllipseMode . CENTER ) ; ctx . stroke ( HANDLE_COLOR ) ; ctx . ellipse ( x , y , radius * 2 , radius * 2 ) ; if ( pt ! = null ) drawDot ( ctx , pt . x , pt . y ) ; 
public boolean mousePressed ( Point pt ) { this . pt = null ; double radius = getRadius ( ) ; Point center = getCenter ( ) ; float d = ( float ) Geometry . distance ( center . x , center . y , pt . x , pt . y ) ; dragging = ( radius - 4 < = d & & d < = radius + 4 ) ; return dragging ; } 
public boolean mouseDragged ( Point pt ) { if ( ! dragging ) return false ; Point center = getCenter ( ) ; float newSize = ( float ) Geometry . distance ( center . x , center . y , pt . x , pt . y ) ; if ( mode = = Mode . DIAMETER ) newSize * = 2 ; if ( newSize = = getRadius ( ) ) return false ; silentSet ( radiusName , newSize ) ; this . pt = pt ; return true ; } 
public boolean mouseReleased ( Point pt ) { if ( ! dragging ) return false ; dragging = false ; this . pt = null ; updateHandle ( ) ; return true ; } 
public boolean mouseMoved ( Point pt ) { Point center = getCenter ( ) ; double x = center . x ; double y = center . y ; double radius = getRadius ( ) ; float d = ( float ) Geometry . distance ( x , y , pt . x , pt . y ) ; if ( radius - 4 < = d & & d < = radius + 4 ) { float a = ( float ) Geometry . angle ( x , y , pt . x , pt . y ) ; double [ ] xy ; xy = Geometry . coordinates ( x , y , radius , a ) ; this . pt = new Point ( ( float ) xy [ 0 ] , ( float ) xy [ 1 ] ) ; } else { this . pt = null ; } updateHandle ( ) ; return true ; } 
public void update ( ) { if ( hasInput ( " shape " ) ) setVisible ( isConnected ( " shape " ) ) ; 
public void draw ( GraphicsContext ctx ) { Point cp = ( Point ) getValue ( positionName ) ; double cx = cp . x ; double cy = cp . y ; double width = ( Double ) getValue ( widthName ) ; double height = ( Double ) getValue ( heightName ) ; double left = cx - width / 2 ; double right = cx + width / 2 ; double top = cy - height / 2 ; double bottom = cy + height / 2 ; Path cornerPath = new Path ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0 ) ; drawDot ( cornerPath , left , top ) ; drawDot ( cornerPath , right , top ) ; drawDot ( cornerPath , right , bottom ) ; drawDot ( cornerPath , left , bottom ) ; drawDot ( cornerPath , cx , cy ) ; ctx . draw ( cornerPath ) ; Path strokePath = new Path ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . rect ( cx , cy , width , height ) ; ctx . draw ( strokePath ) ; } 
public boolean mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; Point op = ( Point ) getValue ( positionName ) ; ocx = op . x ; ocy = op . y ; owidth = ( Double ) getValue ( widthName ) ; oheight = ( Double ) getValue ( heightName ) ; double left = ocx - owidth / 2 ; double right = ocx + owidth / 2 ; double top = ocy - oheight / 2 ; double bottom = ocy + oheight / 2 ; Rect topLeft = createHitRectangle ( left , top ) ; Rect topRight = createHitRectangle ( right , top ) ; Rect bottomLeft = createHitRectangle ( left , bottom ) ; Rect bottomRight = createHitRectangle ( right , bottom ) ; Rect center = new Rect ( left , top , owidth , oheight ) ; if ( topLeft . contains ( pt ) ) { dragState = DragState . TOP_LEFT ; } else if ( topRight . contains ( pt ) ) { dragState = DragState . TOP_RIGHT ; } else if ( bottomLeft . contains ( pt ) ) { dragState = DragState . BOTTOM_LEFT ; } else if ( bottomRight . contains ( pt ) ) { dragState = DragState . BOTTOM_RIGHT ; } else if ( center . contains ( pt ) ) { dragState = DragState . CENTER ; } else { dragState = DragState . NONE ; return false ; } return true ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; double x = pt . getX ( ) ; double y = pt . getY ( ) ; double dx = x - px ; double dy = y - py ; The delta value is multiplied by 2 to create the float effect of moving the top left corner down and the bottom left corner up (in the case of the top left handle). if (dx == 0 && dy == 0) return false; startCombiningEdits("Set Value"); switch (dragState) { case TOP_LEFT: silentSet(widthName, owidth - dx * 2); silentSet(heightName, oheight - dy * 2); break; case TOP_RIGHT: silentSet(heightName, oheight - dy * 2); silentSet(widthName, owidth + dx * 2); break; case BOTTOM_LEFT: silentSet(widthName, owidth - dx * 2); silentSet(heightName, oheight + dy * 2); break; case BOTTOM_RIGHT: silentSet(widthName, owidth + dx * 2); silentSet(heightName, oheight + dy * 2); break; case CENTER: silentSet(positionName, new Point(ocx + dx, ocy + dy)); } return true; } 
public boolean mouseDragged ( Point pt ) { Note that the freehand handle is not concerned with parsing the actual path. All it does is append new points to the string. The actual path parsing is done by the freehand node code. currentPoint = pt; String pathString = (String) getValue(pathPortName); if (newPath) { if (pathString.isEmpty()) { pathString = " "; } pathString += "M "; newPath = false; } Use US locale, otherwise the code might generate a "," instead of a "." as the floating point. pathString += String.format(Locale.US, "%.2f %.2f ", pt.getX(), pt.getY()); silentSet(pathPortName, pathString); updateHandle(); return true; } 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseClicked ( Point pt ) ; public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean hasInput ( String portName ) ; public boolean isConnected ( String portName ) ; public Object getValue ( String portName ) ; public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean isConnected ( String portName ) ; public Object getValue ( String portName ) ; public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public Object getValue ( String portName ) ; public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setValue ( String portName , Object value ) ; public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void silentSet ( String portName , Object value ) ; public void updateHandle ( ) ; Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean hasInput ( String portName ) ; public boolean isConnected ( String portName ) ; public void updateHandle ( ) ; } 
public boolean isConnected ( String portName ) ; public void updateHandle ( ) ; } 
public Object getValue ( String portName ) ; public void updateHandle ( ) ; } 
public void setValue ( String portName , Object value ) ; public void updateHandle ( ) ; } 
public void silentSet ( String portName , Object value ) ; public void updateHandle ( ) ; } 
public void startEdits ( String command ) ; public void updateHandle ( ) ; } 
public void stopEditing ( ) ; public void updateHandle ( ) ; } 
public void draw ( GraphicsContext ctx ) { Point pt = ( Point ) getValue ( positionName ) ; drawDot ( ctx , ( float ) pt . x , ( float ) pt . y ) ; } 
public boolean mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; Point op = ( Point ) getValue ( positionName ) ; ox = op . x ; oy = op . y ; Rect hitRect = createHitRectangle ( ox , oy ) ; dragging = hitRect . contains ( pt ) ; return dragging ; } 
public boolean mouseDragged ( Point e ) { if ( ! dragging ) return false ; double x = e . getX ( ) ; double y = e . getY ( ) ; double dx = x - px ; double dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; startCombiningEdits ( " Set Value " ) ; TODO: Temporary float fix to get a working compile. Doubles will be removed. silentSet(positionName, new Point((float) (ox + dx), (float) (oy + dy))); return true; } 
public void update ( ) { setVisible ( isConnected ( " shape " ) ) ; } 
public void draw ( GraphicsContext ctx ) { Point c = getCenter ( ) ; double cx = c . x ; double cy = c . y ; ctx . ellipsemode ( GraphicsContext . EllipseMode . CENTER ) ; ctx . nofill ( ) ; ctx . stroke ( HANDLE_COLOR ) ; ctx . ellipse ( cx , cy , handleLength * 2 , handleLength * 2 ) ; double [ ] xy ; if ( dragState = = DragState . NONE | | dragState = = DragState . HANDLE ) xy = Geometry . coordinates ( cx , cy , handleLength , ( Double ) getValue ( angleName ) ) ; else { xy = Geometry . coordinates ( cx , cy , handleLength , pa ) ; ctx . line ( cx , cy , ( float ) xy [ 0 ] , ( float ) xy [ 1 ] ) ; xy = Geometry . coordinates ( cx , cy , handleLength , ca ) ; } float x = ( float ) xy [ 0 ] ; float y = ( float ) xy [ 1 ] ; ctx . line ( cx , cy , x , y ) ; ctx . fill ( 1 ) ; ctx . ellipse ( x , y , 6 , 6 ) ; if ( dragState = = DragState . HANDLE ) { xy = Geometry . coordinates ( cx , cy , handleLength , oa ) ; 
public boolean mousePressed ( Point pt ) { Point c = getCenter ( ) ; double cx = c . x ; double cy = c . y ; original angle oa = (Double) getValue(angleName); double[] xy = Geometry.coordinates(cx, cy, handleLength, oa); float x = (float) xy[0]; float y = (float) xy[1]; Path p = new Path(); p.ellipse(cx, cy, handleLength * 2, handleLength * 2); Rect handleRect = createHitRectangle(x, y); float a = (float) Geometry.angle(cx, cy, pt.x, pt.y); xy = Geometry.coordinates(cx, cy, handleLength, a); float x1 = (float) xy[0]; float y1 = (float) xy[1]; Rect circleRect = createHitRectangle(x1, y1); if (handleRect.contains(pt)) dragState = DragState.HANDLE; else if (circleRect.contains(pt)) { pa = a; pressed angle dragState = DragState.CIRCLE; } else dragState = DragState.NONE; return (dragState != DragState.NONE); } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; Point c = getCenter ( ) ; double cx = c . x ; double cy = c . y ; float a = ( float ) Geometry . angle ( cx , cy , pt . x , pt . y ) ; ca = a ; current angle handleLength = (float) Geometry.distance(cx, cy, pt.x, pt.y); if (dragState == DragState.HANDLE) silentSet(angleName, a); else if (dragState == DragState.CIRCLE) silentSet(angleName, oa + a - pa); return true; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; dragState = DragState . NONE ; handleLength = HANDLE_LENGTH ; updateHandle ( ) ; return true ; } 
public void draw ( GraphicsContext ctx ) { ctx . nofill ( ) ; ctx . stroke ( HANDLE_COLOR ) ; double halfWidth = handleWidth / 2 ; double halfHeight = handleHeight / 2 ; ctx . rectmode ( GraphicsContext . RectMode . CENTER ) ; ctx . rect ( 0 , 0 , handleWidth , handleHeight ) ; drawDot ( ctx , - halfWidth , - halfHeight ) ; drawDot ( ctx , halfWidth , - halfHeight ) ; drawDot ( ctx , - halfWidth , halfHeight ) ; drawDot ( ctx , halfWidth , halfHeight ) ; } 
public boolean mousePressed ( Point pt ) { double left = - handleWidth / 2 ; double right = handleWidth / 2 ; double top = - handleHeight / 2 ; double bottom = handleHeight / 2 ; Rect topLeft = createHitRectangle ( left , top ) ; Rect topRight = createHitRectangle ( right , top ) ; Rect bottomLeft = createHitRectangle ( left , bottom ) ; Rect bottomRight = createHitRectangle ( right , bottom ) ; px = pt . getX ( ) ; py = pt . getY ( ) ; Point op = ( Point ) getValue ( scaleName ) ; ox = op . x ; oy = op . y ; if ( topLeft . contains ( pt ) ) dragState = DragState . TOP_LEFT ; else if ( topRight . contains ( pt ) ) dragState = DragState . TOP_RIGHT ; else if ( bottomLeft . contains ( pt ) ) dragState = DragState . BOTTOM_LEFT ; else if ( bottomRight . contains ( pt ) ) dragState = DragState . BOTTOM_RIGHT ; else dragState = DragState . NONE ; return ( dragState ! = DragState . NONE ) ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; double x = pt . getX ( ) ; double y = pt . getY ( ) ; double dx = x - px ; double dy = y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; startCombiningEdits ( " Set Value " ) ; if ( dragState = = DragState . TOP_LEFT ) { handleWidth = HANDLE_WIDTH - dx * 2 ; handleHeight = HANDLE_HEIGHT - dy * 2 ; } else if ( dragState = = DragState . TOP_RIGHT ) { handleWidth = HANDLE_WIDTH + dx * 2 ; handleHeight = HANDLE_HEIGHT - dy * 2 ; } else if ( dragState = = DragState . BOTTOM_LEFT ) { handleWidth = HANDLE_WIDTH - dx * 2 ; handleHeight = HANDLE_HEIGHT + dy * 2 ; } else if ( dragState = = DragState . BOTTOM_RIGHT ) { handleWidth = HANDLE_WIDTH + dx * 2 ; handleHeight = HANDLE_HEIGHT + dy * 2 ; } double pctX = handleWidth / HANDLE_WIDTH ; double pctY = handleHeight / HANDLE_HEIGHT ; Point op = ( Point ) getValue ( scaleName ) ; if ( scaleHorizontal ) op = new Point ( ox * pctX , op . y ) ; else handleWidth = HANDLE_WIDTH ; if ( scaleVertical ) op = new Point ( op . x , oy * pctY ) ; else handleHeight = HANDLE_HEIGHT ; silentSet ( scaleName , op ) ; return true ; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; handleWidth = HANDLE_WIDTH ; handleHeight = HANDLE_HEIGHT ; dragState = DragState . NONE ; stopCombiningEdits ( ) ; updateHandle ( ) ; return true ; } 
public void draw ( GraphicsContext ctx ) { Point cp = ( Point ) getValue ( translateName ) ; double x = cp . x ; double y = cp . y ; ctx . rectmode ( GraphicsContext . RectMode . CENTER ) ; Path p = new Path ( ) ; p . setFillColor ( HANDLE_COLOR ) ; ctx . stroke ( HANDLE_COLOR ) ; p . setStrokeColor ( null ) ; ctx . nofill ( ) ; drawDot ( ctx , x , y ) ; if ( dragState = = DragState . NONE ) { Horizontal and vertical direction lines. ctx.line(x, y, x + handleLength, y); ctx.line(x, y, x, y + handleLength); Vertical arrow p.moveto(x, y + handleLength + 3); p.lineto(x - 5, y + handleLength - 3); p.lineto(x + 5, y + handleLength - 3); Horizontal arrow p.moveto(x + handleLength + 3, y); p.lineto(x + handleLength - 3, y - 5); p.lineto(x + handleLength - 3, y + 5); } else if (dragState == DragState.CENTER) { ctx.line(px, py, x, y); drawDot(ctx, x, y); } else if (dragState == DragState.HORIZONTAL) { double x0, x1; ctx.line(px - handleLength, y, x + handleLength, y); if (x + handleLength > px - handleLength) { arrow points right x0 = x + handleLength + 3; x1 = x + handleLength - 3; } else { arrow points left x0 = x + handleLength - 3; x1 = x + handleLength + 3; } p.moveto(x0, y); p.lineto(x1, y - 5); p.lineto(x1, y + 5); } else if (dragState == DragState.VERTICAL) { double y0, y1; ctx.line(x, py - handleLength, x, y + handleLength); if (y + handleLength > py - handleLength) { arrow points down y0 = y + handleLength + 3; y1 = y + handleLength - 3; } else { arrow points up y0 = y + handleLength - 3; y1 = y + handleLength + 3; } p.moveto(x, y0); p.lineto(x - 5, y1); p.lineto(x + 5, y1); } ctx.nostroke(); ctx.draw(p); } 
public boolean mousePressed ( Point pt ) { px = pt . getX ( ) ; py = pt . getY ( ) ; Point cp = ( Point ) getValue ( translateName ) ; double x = ox = cp . x ; double y = oy = cp . y ; Rect centerRect = createHitRectangle ( x , y ) ; Rect horRect = createHitRectangle ( x + handleLength , y ) ; Rect vertRect = createHitRectangle ( x , y + handleLength ) ; if ( centerRect . contains ( pt ) ) dragState = DragState . CENTER ; else if ( horRect . contains ( pt ) ) dragState = DragState . HORIZONTAL ; else if ( vertRect . contains ( pt ) ) dragState = DragState . VERTICAL ; return ( dragState ! = DragState . NONE ) ; } 
public boolean mouseDragged ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; Point cp = ( Point ) getValue ( translateName ) ; double dx = pt . x - px ; double dy = pt . y - py ; if ( dx = = 0 & & dy = = 0 ) return false ; startCombiningEdits ( " Set Value " ) ; if ( dragState = = DragState . CENTER ) { silentSet ( translateName , new Point ( ox + dx , oy + dy ) ) ; } else if ( dragState = = DragState . HORIZONTAL ) silentSet ( translateName , new Point ( ox + dx , cp . y ) ) ; else if ( dragState = = DragState . VERTICAL ) silentSet ( translateName , new Point ( cp . x , oy + dy ) ) ; return true ; } 
public boolean mouseReleased ( Point pt ) { if ( dragState = = DragState . NONE ) return false ; dragState = DragState . NONE ; stopCombiningEdits ( ) ; updateHandle ( ) ; return true ; } 
public int hashCode ( ) { return Objects . hashCode ( outputNode , inputNode , inputPort ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof Connection ) ) return false ; final Connection other = ( Connection ) o ; return Objects . equal ( outputNode , other . outputNode ) & & Objects . equal ( inputNode , other . inputNode ) 
public String toString ( ) { return String . format ( " %s <= %s.%s " , getOutputNode ( ) , getInputNode ( ) , getInputPort ( ) ) ; } 
public String toString ( ) { return connection + " : " + getMessage ( ) ; } 
public String toString ( ) { return String . format ( Locale . US , " InvalidNameException on %s name %s: %s " , source , name , getMessage ( ) ) ; } 
public final boolean isListAware ( ) { return this = = LIST_AWARE ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof MenuItem ) ) return false ; final MenuItem other = ( MenuItem ) o ; return Objects . equal ( key , other . key ) & & Objects . equal ( label , other . label ) ; 
public int hashCode ( ) { return Objects . hashCode ( key , label ) ; } 
public String toString ( ) { return String . format ( " <MenuItem %s (%s)> " , label , key ) ; } 
public static void write ( NodeLibrary library , File file ) { StreamResult streamResult = new StreamResult ( file ) ; write ( library , streamResult , file ) ; 
public static void write ( NodeLibrary library , Writer writer ) { StreamResult streamResult = new StreamResult ( writer ) ; write ( library , streamResult , null ) ; } 
public static void write ( NodeLibrary library , StreamResult streamResult , File file ) { try { DocumentBuilder builder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; 
private static String findNodeId ( Node node , NodeRepository nodeRepository ) { NodeLibrary library = nodeRepository . nodeLibraryForNode ( node ) ; if ( library = = null ) { return node . getName ( ) ; 
private static boolean shouldWriteAttribute ( Node node , Node . Attribute attribute ) { checkArgument ( node ! = Node . ROOT , " You cannot write out the _root node. " ) ; Object prototypeValue = node . getPrototype ( ) . getAttributeValue ( attribute ) ; Object nodeValue = node . getAttributeValue ( attribute ) ; if ( attribute ! = Node . Attribute . PROTOTYPE ) { checkNotNull ( prototypeValue , " Attribute %s of node %s is empty. " , attribute , node . getPrototype ( ) ) ; 
private static void writeOrderedChild ( Document doc , Element parent , List < Node > children , Node child , NodeRepository nodeRepository ) { Node prototype = child . getPrototype ( ) ; if ( children . contains ( prototype ) ) writeOrderedChild ( doc , parent , children , prototype , nodeRepository ) ; writeNode ( doc , parent , child , nodeRepository ) ; children . remove ( child ) ; } 
private static boolean shouldWriteAttribute ( Node node , Port port , Port . Attribute attribute ) { checkArgument ( node ! = Node . ROOT , " You cannot write out the _root node. " ) ; Port prototypePort = node . getPrototype ( ) . getInput ( port . getName ( ) ) ; If there is no prototype port, we should always write the attribute. if (prototypePort == null) return true; Object prototypeValue = prototypePort.getAttributeValue(attribute); Object value = port.getAttributeValue(attribute); Objects.equal does the correct null-comparison for min / max values. return !Objects.equal(prototypeValue, value); } 
private static void writePort ( Document doc , Element parent , Node node , Port port , Port . Direction direction ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = node.getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getInput(port.getName()); If the port and its prototype are equal, don't write anything. if (port.equals(protoPort)) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); el.setAttribute("type", port.getType()); if (shouldWriteAttribute(node, port, Port.Attribute.WIDGET)) el.setAttribute("widget", port.getWidget().toString().toLowerCase()); if (shouldWriteAttribute(node, port, Port.Attribute.RANGE)) el.setAttribute("range", port.getRange().toString().toLowerCase()); if (port.isStandardType()) el.setAttribute("value", port.stringValue()); if (shouldWriteAttribute(node, port, Port.Attribute.MINIMUM_VALUE)) if (port.getMinimumValue() != null) el.setAttribute("min", String.format(Locale.US, "%s", port.getMinimumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MAXIMUM_VALUE)) if (port.getMaximumValue() != null) el.setAttribute("max", String.format(Locale.US, "%s", port.getMaximumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MENU_ITEMS)) writeMenuItems(doc, el, port.getMenuItems()); parent.appendChild(el); } 
private static void writeMenuItems ( Document doc , Element parent , List < MenuItem > menuItems ) { for ( MenuItem item : menuItems ) { Element el = doc . createElement ( " menu " ) ; 
private static void writeConnection ( Document doc , Element parent , Connection conn ) { Element connElement = doc . createElement ( " conn " ) ; connElement . setAttribute ( " output " , String . format ( " %s " , conn . getOutputNode ( ) ) ) ; connElement . setAttribute ( " input " , String . format ( " %s.%s " , conn . getInputNode ( ) , conn . getInputPort ( ) ) ) ; parent . appendChild ( connElement ) ; } 
public static String path ( String parentPath , Node node ) { checkNotNull ( node ) ; return path ( parentPath , node . getName ( ) ) ; } 
public static String path ( String parentPath , String nodeName ) { checkNotNull ( parentPath ) ; checkNotNull ( nodeName ) ; checkArgument ( parentPath . startsWith ( " / " ) , " Only absolute paths are supported. " ) ; if ( parentPath . equals ( " / " ) ) { return " / " + nodeName ; 
private void checkAllNotNull ( Object . . . args ) { for ( Object o : args ) { checkNotNull ( o ) ; 
public boolean hasChild ( String name ) { checkNotNull ( name , " Name cannot be null. " ) ; return getChild ( name ) ! = null ; } 
public boolean hasChild ( Node node ) { checkNotNull ( node , " Node cannot be null. " ) ; return children . contains ( node ) ; } 
public boolean hasInput ( String name ) { return getInput ( name ) ! = null ; } 
public boolean hasValueOutputRange ( ) { return outputRange . equals ( Port . Range . VALUE ) ; } 
public boolean hasListOutputRange ( ) { return outputRange . equals ( Port . Range . LIST ) ; } 
public boolean hasRenderedChild ( ) { return hasChild ( getRenderedChildName ( ) ) ; } 
public Node extend ( ) { return newNodeWithAttribute ( Attribute . PROTOTYPE , this ) ; } 
public static void validateName ( String name ) throws InvalidNameException { Matcher m1 = NODE_NAME_PATTERN . matcher ( name ) ; Matcher m2 = DOUBLE_UNDERSCORE_PATTERN . matcher ( name ) ; Matcher m3 = RESERVED_WORD_PATTERN.matcher(name); if (!m1.matches()) { throw new InvalidNameException(null, name, "Names can only contain lowercase letters, numbers, and the underscore. Names cannot be longer than 29 characters."); } if (m2.matches()) { throw new InvalidNameException(null, name, "Names starting with double underscore are reserved for internal use."); 
public Node withName ( String name ) { validateName ( name ) ; return newNodeWithAttribute ( Attribute . NAME , name ) ; } 
public Node withDescription ( String description ) { return newNodeWithAttribute ( Attribute . DESCRIPTION , description ) ; } 
public Node withImage ( String image ) { return newNodeWithAttribute ( Attribute . IMAGE , image ) ; } 
public Node withFunction ( String function ) { return newNodeWithAttribute ( Attribute . FUNCTION , function ) ; } 
public Node withPosition ( Point position ) { return newNodeWithAttribute ( Attribute . POSITION , position ) ; } 
public Node withInputAdded ( Port port ) { checkNotNull ( port , " Port cannot be null. " ) ; checkArgument ( ! hasInput ( port . getName ( ) ) , " An input port named %s already exists on node %s. " , port . getName ( ) , this ) ; ImmutableList . Builder < Port > b = ImmutableList . builder ( ) ; b . addAll ( getInputs ( ) ) ; b . add ( port ) ; return newNodeWithAttribute ( Attribute . INPUTS , b . build ( ) ) ; } 
public Node withInputValue ( String portName , Object value ) { Port p = getInput ( portName ) ; checkNotNull ( p , " Input port %s does not exist on node %s. " , portName , this ) ; p = p . withValue ( value ) ; return withInputChanged ( portName , p ) ; } 
public Node withInputRange ( String portName , Port . Range range ) { Port p = getInput ( portName ) ; checkNotNull ( p , " Input port %s does not exist on node %s. " , portName , this ) ; p = p . withRange ( range ) ; return withInputChanged ( portName , p ) ; } 
public Node withOutputType ( String outputType ) { return newNodeWithAttribute ( Attribute . OUTPUT_TYPE , outputType ) ; } 
public Node withOutputRange ( Port . Range outputRange ) { return newNodeWithAttribute ( Attribute . OUTPUT_RANGE , outputRange ) ; } 
public Node withChildAdded ( Node node ) { checkNotNull ( node , " Node cannot be null. " ) ; checkArgument ( ! hasChild ( node . getName ( ) ) , " A node named %s is already a child of node %s. " , node . getName ( ) , this ) ; ImmutableList . Builder < Node > b = ImmutableList . builder ( ) ; b . addAll ( getChildren ( ) ) ; b . add ( node ) ; return newNodeWithAttribute ( Attribute . CHILDREN , b . build ( ) ) ; } 
public Node withRenderedChildName ( String name ) { checkNotNull ( name , " Rendered child name cannot be null. " ) ; checkArgument ( name . isEmpty ( ) | | hasChild ( name ) , " Node does not have a child named %s. " , name ) ; return newNodeWithAttribute ( Attribute . RENDERED_CHILD_NAME , name ) ; } 
public Node withRenderedChild ( Node renderedChild ) { return withRenderedChildName ( renderedChild = = null ? " " : renderedChild . getName ( ) ) ; } 
public Node withConnectionAdded ( Connection connection ) { return connect ( connection . getOutputNode ( ) , connection . getInputNode ( ) , connection . getInputPort ( ) ) ; } 
public Node withHandle ( String handle ) { return newNodeWithAttribute ( Attribute . HANDLE , handle ) ; } 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT, make the ROOT the prototype. if (prototype == null) { prototype = ROOT; } The name of a node can never be "_root". if (name.equals("_root")) { name = "node"; } return new Node(prototype, name, description, image, function, position, inputs, outputType, outputRange, children, renderedChildName, connections, handle); 
public int hashCode ( ) { return Objects . hashCode ( prototype , name , description , image , function , position , inputs , outputType , outputRange , children , renderedChildName , connections , handle ) ; 
public boolean equals ( Object o ) { if ( ! ( o instanceof Node ) ) return false ; final Node other = ( Node ) o ; return Objects . equal ( prototype , other . prototype ) & & Objects . equal ( name , other . name ) 
public String toString ( ) { return String . format ( " <Node %s:%s> " , getName ( ) , getFunction ( ) ) ; } 
private Iterable < ? > convert ( Iterable < ? > outputValues , String inputType ) { Class outputType = ListUtils . listClass ( outputValues ) ; Convert IGeometry type to points if (inputType.equals(Port.TYPE_POINT) && IGeometry.class.isAssignableFrom(outputType)) { ImmutableList.Builder<Object> b = new ImmutableList.Builder<Object>(); for (Object o : outputValues) { b.addAll((Iterable<?>) ((IGeometry) o).getPoints()); } return b.build(); } return outputValues; } 
private int level ( Iterable it ) { Iterator < Object > iterator = it . iterator ( ) ; if ( ! iterator . hasNext ( ) ) return 0 ; Object first = iterator . next ( ) ; We check if the structure implements List rather than Iterable, because we might be interested in certain kind of iterables (for example a Path object). Deconstructing those kind of iterables may not be what we want. if (first instanceof List) { return 1 + level((Iterable) first); } return 0; } 
private int level ( ValueOrList v ) { if ( ! v . isList ( ) ) return 0 ; return level ( v . getList ( ) ) ; } 
private int outputLevel ( List < ValueOrList > values ) { int sum = 0 ; for ( ValueOrList v : values ) { sum + = level ( v ) ; } return sum ; } 
public void call ( List < Object > arguments , List < Object > results ) { Object returnValue = invokeFunction ( node , function , arguments ) ; if ( returnValue ! = null ) { results . add ( returnValue ) ; 
private Object invokeFunction ( Node node , Function function , List < ? > arguments ) throws NodeRenderException { try { return function . invoke ( arguments . toArray ( ) ) ; 
private static boolean hasElements ( List < ValueOrList > ll ) { checkNotNull ( ll ) ; if ( ll . isEmpty ( ) ) return false ; for ( ValueOrList v : ll ) { if ( v . isList ( ) ) { if ( ! v . getList ( ) . iterator ( ) . hasNext ( ) ) return false ; } } return true ; } 
private static ValueOrList ofValue ( Object value ) { return new ValueOrList ( false , value ) ; } 
private static ValueOrList ofList ( Iterable list ) { return new ValueOrList ( true , list ) ; } 
private boolean isList ( ) { return isList ; } 
public static NodePort of ( Node node , Port port ) { return new NodePort ( node , port ) ; } 
public static NodePort of ( Node node , String portName ) { return new NodePort ( node , node . getInput ( portName ) ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof NodePort ) ) return false ; final NodePort other = ( NodePort ) o ; return Objects . equal ( node , other . node ) & & Objects . equal ( port , other . port ) ; 
public int hashCode ( ) { return Objects . hashCode ( node , port ) ; } 
public void call ( List < Object > arguments , List < Object > results ) ; } } 
public static NodeLibrary create ( String libraryName , Node root ) { return create ( libraryName , root , NodeRepository . of ( ) , FunctionRepository . of ( ) , UUID . randomUUID ( ) ) ; } 
public static NodeLibrary create ( String libraryName , Node root , FunctionRepository functionRepository ) { return create ( libraryName , root , NodeRepository . of ( ) , functionRepository ) ; } 
public static NodeLibrary create ( String libraryName , Node root , NodeRepository nodeRepository , FunctionRepository functionRepository ) { return create ( libraryName , root , nodeRepository , functionRepository , UUID . randomUUID ( ) ) ; } 
private static NodeLibrary create ( String libraryName , Node root , NodeRepository nodeRepository , FunctionRepository functionRepository , UUID uuid ) { return new NodeLibrary ( libraryName , null , root , nodeRepository , functionRepository , uuid ) ; } 
public static NodeLibrary load ( String libraryName , String xml , NodeRepository nodeRepository ) throws LoadException { checkNotNull ( libraryName , " Library name cannot be null. " ) ; checkNotNull ( xml , " XML string cannot be null. " ) ; try { return load ( libraryName , null , new StringReader ( xml ) , nodeRepository ) ; 
public static NodeLibrary load ( File f , NodeRepository nodeRepository ) throws LoadException { checkNotNull ( f , " File cannot be null. " ) ; String libraryName = FileUtils . stripExtension ( f ) ; try { return load ( libraryName , f , new FileReader ( f ) , nodeRepository ) ; 
private static NodeLibrary load ( String libraryName , File file , Reader r , NodeRepository nodeRepository ) throws XMLStreamException { XMLInputFactory xmlInputFactory = XMLInputFactory . newInstance ( ) ; XMLStreamReader reader = xmlInputFactory . createXMLStreamReader ( r ) ; NodeLibrary nodeLibrary = null ; while ( reader . hasNext ( ) ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) { String uuidString = reader . getAttributeValue ( null , " uuid " ) ; UUID uuid = ( uuidString = = null ) ? UUID . randomUUID ( ) : UUID . fromString ( uuidString ) ; nodeLibrary = parseNDBX ( libraryName , file , reader , nodeRepository , uuid ) ; } else { throw new XMLStreamException ( " Only tag ndbx allowed, not " + tagName , reader . getLocation ( ) ) ; } } } return nodeLibrary ; } 
private static NodeLibrary parseNDBX ( String libraryName , File file , XMLStreamReader reader , NodeRepository nodeRepository , UUID uuid ) throws XMLStreamException { List < FunctionLibrary > functionLibraries = new LinkedList < FunctionLibrary > ( ) ; Node rootNode = Node . ROOT ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " link " ) ) { FunctionLibrary functionLibrary = parseLink ( file , reader ) ; functionLibraries . add ( functionLibrary ) ; } else if ( tagName . equals ( " node " ) ) { rootNode = parseNode ( reader , rootNode , nodeRepository ) ; } else { throw new XMLStreamException ( " Unknown tag " + tagName , reader . getLocation ( ) ) ; } } else if ( eventType = = XMLStreamConstants . END_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) break ; } } FunctionLibrary [ ] fl = functionLibraries . toArray ( new FunctionLibrary [ functionLibraries . size ( ) ] ) ; return new NodeLibrary ( libraryName , file , rootNode , nodeRepository , FunctionRepository . of ( fl ) , uuid ) ; } 
private static FunctionLibrary parseLink ( File file , XMLStreamReader reader ) throws XMLStreamException { String linkRelation = reader . getAttributeValue ( null , " rel " ) ; checkState ( linkRelation . equals ( " functions " ) ) ; String ref = reader . getAttributeValue ( null , " href " ) ; loading should happen lazily? return FunctionLibrary.load(file, ref); } 
private static Node parseNode ( XMLStreamReader reader , Node parent , NodeRepository nodeRepository ) throws XMLStreamException { String prototypeId = reader . getAttributeValue ( null , " prototype " ) ; String name = reader . getAttributeValue ( null , " name " ) ; String description = reader . getAttributeValue ( null , " description " ) ; String image = reader . getAttributeValue ( null , " image " ) ; String function = reader . getAttributeValue ( null , " function " ) ; String outputRange = reader . getAttributeValue ( null , " outputRange " ) ; String position = reader . getAttributeValue ( null , " position " ) ; String renderedChildName = reader . getAttributeValue ( null , " renderedChild " ) ; String handle = reader . getAttributeValue ( null , " handle " ) ; Node prototype = prototypeId = = null ? Node . ROOT : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) { throw new XMLStreamException ( " Prototype " + prototypeId + " could not be found. " , reader . getLocation ( ) ) ; } Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " port " ) ) { String portName = reader . getAttributeValue ( null , " name " ) ; Remove the port if it is already on the prototype. if (node.hasInput(portName)) { node = node.withInputChanged(portName, parsePort(reader, node.getInput(portName))); } else { node = node.withInputAdded(parsePort(reader, null)); } } else if (tagName.equals("node")) { node = node.withChildAdded(parseNode(reader, node, nodeRepository)); } else if (tagName.equals("conn")) { node = node.withConnectionAdded(parseConnection(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("node")) break; } } This has to come at the end, since the child first needs to exist. if (renderedChildName != null) node = node.withRenderedChildName(renderedChildName); return node; } 
private static Node lookupNode ( String nodeId , Node parent , NodeRepository nodeRepository ) { if ( nodeId . contains ( " . " ) ) { return nodeRepository . getNode ( nodeId ) ; 
private static Port parsePort ( XMLStreamReader reader , Port prototype ) throws XMLStreamException { Name and type are always required. String name = reader.getAttributeValue(null, "name"); String type = reader.getAttributeValue(null, "type"); String widget = reader.getAttributeValue(null, "widget"); String range = reader.getAttributeValue(null, "range"); String value = reader.getAttributeValue(null, "value"); String min = reader.getAttributeValue(null, "min"); String max = reader.getAttributeValue(null, "max"); Port port; if (prototype == null) { port = Port.portForType(name, type); } else { port = prototype; } Widget, value, min, max are optional and could come from the prototype. if (widget != null) port = port.withParsedAttribute(Port.Attribute.WIDGET, widget); if (range != null) port = port.withParsedAttribute(Port.Attribute.RANGE, range); if (value != null) port = port.withParsedAttribute(Port.Attribute.VALUE, value); if (min != null) port = port.withParsedAttribute(Port.Attribute.MINIMUM_VALUE, min); if (max != null) port = port.withParsedAttribute(Port.Attribute.MAXIMUM_VALUE, max); ImmutableList.Builder<MenuItem> b = ImmutableList.builder(); while (true) { int eventType = reader.next(); if (eventType == XMLStreamConstants.START_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("menu")) { b.add(parseMenuItem(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("port")) break; } } ImmutableList<MenuItem> items = b.build(); if (!items.isEmpty()) port = port.withMenuItems(items); return port; } 
private static MenuItem parseMenuItem ( XMLStreamReader reader ) throws XMLStreamException { String key = reader . getAttributeValue ( null , " key " ) ; String label = reader . getAttributeValue ( null , " label " ) ; if ( key = = null ) throw new XMLStreamException ( " Menu item key cannot be null. " , reader . getLocation ( ) ) ; return new MenuItem ( key , label ! = null ? label : key ) ; } 
private static Connection parseConnection ( XMLStreamReader reader ) throws XMLStreamException { String outputNode = reader . getAttributeValue ( null , " output " ) ; String input = reader . getAttributeValue ( null , " input " ) ; Iterator < String > inputIterator = PORT_NAME_SPLITTER . split ( input ) . iterator ( ) ; String inputNode = inputIterator . next ( ) ; String inputPort = inputIterator . next ( ) ; return new Connection ( outputNode , inputNode , inputPort ) ; } 
public NodeLibrary withRoot ( Node newRoot ) { return new NodeLibrary ( this . name , this . file , newRoot , this . nodeRepository , this . functionRepository , this . uuid ) ; } 
public NodeLibrary withFunctionRepository ( FunctionRepository newRepository ) { return new NodeLibrary ( this . name , this . file , this . root , this . nodeRepository , newRepository , this . uuid ) ; } 
public void store ( File file ) throws IOException { NDBXWriter . write ( this , file ) ; } 
public int hashCode ( ) { return Objects . hashCode ( name , root , functionRepository ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof NodeLibrary ) ) return false ; final NodeLibrary other = ( NodeLibrary ) o ; return Objects . equal ( name , other . name ) & & Objects . equal ( root , other . root ) 
public String toString ( ) { return String . format ( " <NodeLibrary %s> " , name ) ; } 
public static NodeLibraryController create ( ) { return new NodeLibraryController ( NodeLibrary . create ( " untitled " , Node . ROOT , NodeRepository . of ( ) , FunctionRepository . of ( ) ) ) ; } 
public static NodeLibraryController create ( String libraryName , NodeRepository nodeRepository , FunctionRepository functionRepository ) { return new NodeLibraryController ( NodeLibrary . create ( libraryName , Node . ROOT , nodeRepository , functionRepository ) ) ; } 
public static NodeLibraryController withLibrary ( NodeLibrary nodeLibrary ) { return new NodeLibraryController ( nodeLibrary ) ; } 
public Node createNode ( String parentPath , Node prototype ) { Node parent = getNode ( parentPath ) ; String name = parent . uniqueName ( prototype . getName ( ) ) ; Node newNode = prototype . extend ( ) . withName ( name ) ; addNode ( parentPath , newNode ) ; return newNode ; } 
public void removeNode ( String parentPath , String nodeName ) { String renderedChild = getNode ( parentPath ) . getRenderedChildName ( ) ; Node newParent = getNode ( parentPath ) . disconnect ( nodeName ) . withChildRemoved ( nodeName ) ; if ( renderedChild . equals ( nodeName ) ) newParent = newParent . withRenderedChild ( null ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
public void removePort ( String nodePath , String portName ) { Node newNode = getNode ( nodePath ) . withInputRemoved ( portName ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public void connect ( String parentPath , Node outputNode , Node inputNode , Port inputPort ) { Node newParent = getNode ( parentPath ) . connect ( outputNode . getName ( ) , inputNode . getName ( ) , inputPort . getName ( ) ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
public void disconnect ( String parentPath , Connection connection ) { Node newParent = getNode ( parentPath ) . disconnect ( connection ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
public void replaceNodeInPath ( String nodePath , Node node ) { checkArgument ( nodePath . startsWith ( " / " ) , " Node path needs to be an absolute path, starting with '/'. " ) ; nodePath = nodePath . substring ( 1 ) ; Node newRoot ; if ( nodePath . isEmpty ( ) ) { newRoot = node ; } else { TODO Recursively replace nodes at higher levels. checkArgument(!nodePath.contains("/"), "Subpaths are not supported yet."); newRoot = nodeLibrary.getRoot().withChildReplaced(nodePath, node); } nodeLibrary = nodeLibrary.withRoot(newRoot); } 
public static NodeRepository of ( ) { return new NodeRepository ( ImmutableMap . < String , NodeLibrary > of ( ) ) ; } 
public static NodeRepository of ( NodeLibrary . . . libraries ) { ImmutableMap . Builder < String , NodeLibrary > builder = ImmutableMap . builder ( ) ; for ( NodeLibrary library : libraries ) { builder . put ( library . getName ( ) , library ) ; } TODO The core library is always included. return new NodeRepository(builder.build()); } 
public static Port intPort ( String name , long value ) { return intPort ( name , value , null , null ) ; } 
public static Port intPort ( String name , long value , Integer minimumValue , Integer maximumValue ) { checkNotNull ( value , " Value cannot be null. " ) ; return new Port ( name , TYPE_INT , value , minimumValue ! = null ? minimumValue . doubleValue ( ) : null , maximumValue ! = null ? maximumValue . doubleValue ( ) : null ) ; } 
public static Port floatPort ( String name , double value ) { return floatPort ( name , value , null , null ) ; } 
public static Port floatPort ( String name , double value , Double minimumValue , Double maximumValue ) { checkNotNull ( value , " Value cannot be null. " ) ; return new Port ( name , TYPE_FLOAT , value , minimumValue , maximumValue ) ; } 
public static Port booleanPort ( String name , boolean value ) { checkNotNull ( value , " Value cannot be null. " ) ; return new Port ( name , TYPE_BOOLEAN , value ) ; } 
public static Port stringPort ( String name , String value ) { checkNotNull ( value , " Value cannot be null. " ) ; return new Port ( name , TYPE_STRING , value ) ; } 
public static Port stringPort ( String name , String value , Iterable < MenuItem > menuItems ) { checkNotNull ( value , " Value cannot be null. " ) ; return new Port ( name , TYPE_STRING , value , menuItems ) ; } 
public static Port pointPort ( String name , Point value ) { checkNotNull ( value , " Value cannot be null. " ) ; return new Port ( name , TYPE_POINT , value ) ; } 
public static Port colorPort ( String name , Color value ) { checkNotNull ( value , " Value cannot be null. " ) ; return new Port ( name , TYPE_COLOR , value ) ; } 
public static Port customPort ( String name , String type ) { checkNotNull ( type , " Type cannot be null. " ) ; return new Port ( name , type , null ) ; } 
public static Port portForType ( String name , String type ) { checkNotNull ( type , " Type cannot be null. " ) ; If the type is not found in the default values, get() returns null, which is what we need for custom types. return new Port(name, type, defaultWidgetForType(type), DEFAULT_RANGE, DEFAULT_VALUES.get(type), null, null, ImmutableList.<MenuItem>of()); } 
public static Port parsedPort ( String name , String type , String stringValue ) { return parsedPort ( name , type , " " , DEFAULT_RANGE . toString ( ) . toLowerCase ( ) , stringValue , null , null , ImmutableList . < MenuItem > of ( ) ) ; } 
public static Port parsedPort ( String name , String type , String widgetString , String rangeString , String valueString , String minString , String maxString , ImmutableList < MenuItem > menuItems ) { checkNotNull ( name , " Name cannot be null. " ) ; checkNotNull ( type , " Type cannot be null. " ) ; if ( STANDARD_TYPES . contains ( type ) ) { Object value ; 
public static Widget defaultWidgetForType ( String type ) { checkNotNull ( type , " Type cannot be null. " ) ; if ( type . equals ( TYPE_INT ) ) { return Widget . INT ; 
public boolean hasValueRange ( ) { return range . equals ( Range . VALUE ) ; } 
public boolean hasListRange ( ) { return range . equals ( Range . LIST ) ; } 
public boolean hasMenu ( ) { return ! menuItems . isEmpty ( ) ; } 
public boolean isStandardType ( ) { return STANDARD_TYPES . contains ( type ) ; } 
public boolean isCustomType ( ) { return ! isStandardType ( ) ; } 
public long intValue ( ) { checkValueType ( ) ; if ( type . equals ( TYPE_INT ) ) { return ( Long ) value ; 
public double floatValue ( ) { checkValueType ( ) ; if ( type . equals ( TYPE_INT ) ) { return ( ( Long ) value ) . doubleValue ( ) ; 
public String stringValue ( ) { checkValueType ( ) ; return String . valueOf ( value ) ; } 
public boolean booleanValue ( ) { checkValueType ( ) ; if ( type . equals ( TYPE_BOOLEAN ) ) { return ( Boolean ) value ; 
public Point pointValue ( ) { checkValueType ( ) ; if ( type . equals ( TYPE_POINT ) ) { return ( Point ) value ; 
public Color colorValue ( ) { checkValueType ( ) ; if ( type . equals ( TYPE_COLOR ) ) { return ( Color ) value ; 
public boolean isFileWidget ( ) { return widget = = Widget . FILE | | widget = = Widget . IMAGE ; } 
public Port withValue ( Object value ) { checkState ( isStandardType ( ) , " You can only change the value of a standard type. " ) ; checkArgument ( correctValueForType ( value ) , " Value '%s' is not correct for %s port. " , value , getType ( ) ) ; return new Port ( getName ( ) , getType ( ) , getWidget ( ) , getRange ( ) , clampValue ( convertValue ( getType ( ) , value ) ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withWidget ( Widget widget ) { return new Port ( getName ( ) , getType ( ) , widget , getRange ( ) , getValue ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withRange ( Range range ) { return new Port ( getName ( ) , getType ( ) , getWidget ( ) , range , getValue ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
private Object convertValue ( String type , Object value ) { if ( value instanceof Integer ) { checkArgument ( type . equals ( TYPE_INT ) ) ; 
private double clamp ( double v ) { if ( minimumValue ! = null & & v < minimumValue ) { return minimumValue ; 
private void checkValueType ( ) { checkState ( correctValueForType ( this . value ) , " The internal value %s is not a %s. " , value , type ) ; } 
private boolean correctValueForType ( Object value ) { if ( type . equals ( TYPE_INT ) ) { return value instanceof Long | | value instanceof Integer ; 
private static Object parseValue ( String type , String valueString ) { if ( type . equals ( " int " ) ) { return Long . valueOf ( valueString ) ; 
private static Widget parseWidget ( String valueString ) { return Widget . valueOf ( valueString . toUpperCase ( ) ) ; } 
private static Range parseRange ( String valueString ) { if ( valueString . equals ( " value " ) ) return Range . VALUE ; 
public Port withMenuItems ( Iterable < MenuItem > items ) { checkNotNull ( items ) ; checkArgument ( type . equals ( Port . TYPE_STRING ) , " You can only use menu items on string ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getMinimumValue ( ) , getMaximumValue ( ) , items ) ; } 
public Port withParsedAttribute ( Attribute attribute , String valueString ) { checkNotNull ( valueString ) ; String name = this . name ; String type = this . type ; Widget widget = this . widget ; Range range = this . range ; Object value = this . value ; Double minimumValue = this . minimumValue ; Double maximumValue = this . maximumValue ; switch ( attribute ) { case VALUE : checkArgument ( STANDARD_TYPES . contains ( type ) , " Port %s: you can only set the value for one of the standard types, not %s (value=%s) " , name , type , valueString ) ; value = parseValue ( type , valueString ) ; break ; case WIDGET : widget = parseWidget ( valueString ) ; break ; case RANGE : range = parseRange ( valueString ) ; break ; case MINIMUM_VALUE : minimumValue = Double . valueOf ( valueString ) ; break ; case MAXIMUM_VALUE : maximumValue = Double . valueOf ( valueString ) ; break ; default : throw new AssertionError ( " You cannot use withParsedAttribute with attribute " + attribute ) ; } return new Port ( name , type , widget , range , value , minimumValue , maximumValue , getMenuItems ( ) ) ; } 
public int hashCode ( ) { return Objects . hashCode ( name , type , value ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof Port ) ) return false ; final Port other = ( Port ) o ; return Objects . equal ( name , other . name ) & & Objects . equal ( type , other . type ) 
public String toString ( ) { return String . format ( " <Port %s (%s): %s> " , name , type , value ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; g2 . drawImage ( backgroundImage , 0 , 0 , getWidth ( ) , 25 , null ) ; } 
protected void paintComponent ( Graphics g ) { g . drawImage ( dividerImage , 0 , 0 , null ) ; } 
protected void paintComponent ( Graphics g ) { positions = new int [ segments . size ( ) ] ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; g2 . drawImage ( addressGradient , 0 , 0 , getWidth ( ) , 25 , null ) ; int x = 10 ; int i = 0 ; for ( String segment : segments ) { if ( i = = armed ) { 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { int mx = e . getX ( ) ; armed = partIndex ( mx ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; String selectedPart = segments . get ( partIndex ) ; if ( selectedPart ! = null & & onSegmentClickListener ! = null ) onSegmentClickListener . onSegmentClicked ( pathForIndex ( partIndex ) ) ; repaint ( ) ; } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } private String pathForIndex ( int endIndex ) { return " / " + Joiner . on ( " / " ) . join ( segments . subList ( 0 , endIndex ) ) ; } public void onSegmentClicked ( String fullPath ) ; } } 
public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; String selectedPart = segments . get ( partIndex ) ; if ( selectedPart ! = null & & onSegmentClickListener ! = null ) onSegmentClickListener . onSegmentClicked ( pathForIndex ( partIndex ) ) ; repaint ( ) ; } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } private String pathForIndex ( int endIndex ) { return " / " + Joiner . on ( " / " ) . join ( segments . subList ( 0 , endIndex ) ) ; } public void onSegmentClicked ( String fullPath ) ; } } 
private String pathForIndex ( int endIndex ) { return " / " + Joiner . on ( " / " ) . join ( segments . subList ( 0 , endIndex ) ) ; } 
public static Border topBottom ( int topSize , Color topColor , int bottomSize , Color bottomColor ) { return new CssBorder ( topSize , topColor , 0 , null , bottomSize , bottomColor , 0 , null ) ; } 
public static Border bottom ( int size , Color color ) { return new CssBorder ( 0 , null , 0 , null , size , color , 0 , null ) ; } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { if ( topSize > 0 ) { g . setColor ( topColor ) ; g . fillRect ( x , y , width , topSize ) ; } if ( leftSize > 0 ) { g . setColor ( leftColor ) ; g . fillRect ( x + width - leftSize , y , leftSize , height ) ; } if ( bottomSize > 0 ) { g . setColor ( bottomColor ) ; g . fillRect ( x , y + height - bottomSize , width , bottomSize ) ; } if ( rightSize > 0 ) { g . setColor ( rightColor ) ; 
private void init ( ) { this . setMargin ( new Insets ( 0 , 5 , 0 , 5 ) ) ; setFont ( Theme . EDITOR_FONT ) ; setEditorKit ( new PythonEditorKit ( ) ) ; getDocument ( ) . addUndoableEditListener ( undoManager ) ; rootElement = getDocument ( ) . getDefaultRootElement ( ) ; todo:this code should be in the kit for (KeyStroke ks : defaultInputMap.allKeys()) { getInputMap().put(ks, defaultInputMap.get(ks)); } defaultInputMap.put(Platform.getKeyStroke(KeyEvent.VK_Z), new UndoAction()); defaultInputMap.put(Platform.getKeyStroke(KeyEvent.VK_Z, Event.SHIFT_MASK), new RedoAction()); addMouseListener(new DragDetector()); } 
public void mousePressed ( MouseEvent e ) { if ( ( e . getModifiersEx ( ) & BTN1_CTRL_MASK ) ! = BTN1_CTRL_MASK ) return ; LOG . info ( " mouse pressed at " + e . getPoint ( ) ) ; int index = viewToModel ( e . getPoint ( ) ) ; Returns the correct coordinate. String text = getText(); int[] range = numberRange(text, index); if (range == null) return; int left = range[0]; int right = range[1]; String number = numberForRange(text, range); LOG.info("The number is " + number); try { value = Float.parseFloat(number); } catch (NumberFormatException ex) { LOG.log(Level.WARNING, "parsing gave error: " + number, ex); } try { Get position of rightmost character of the number. 
public void paint ( Graphics g ) { g . setColor ( color ) ; Rectangle r = g . getClipBounds ( ) ; g . fillRect ( r . x , r . y , r . width , r . height ) ; } 
private Color colorFromPoint ( int x , int y ) { float h = x / 255.0F ; float s = 1.0F ; float b = 1.0F - ( y / 100.0F ) ; return java . awt . Color . getHSBColor ( h , s , b ) ; } 
public void actionPerformed ( ActionEvent e ) { System . exit ( - 1 ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( getFont ( ) ) ; g2 . setColor ( getForeground ( ) ) ; SwingUtils . drawShadowText ( g2 , getText ( ) , 0 , 14 ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( isEnabled ( ) ) { if ( checked ) { g2 . drawImage ( checkedImage , 0 , 0 , null ) ; } else { g2 . drawImage ( normalImage , 0 , 0 , null ) ; } } else { if ( mode = = Mode . CHECK & & checked ) { g2 . drawImage ( checkDisabledOn , 0 , 0 , null ) ; } else if ( mode = = Mode . CHECK & & ! checked ) { g2 . drawImage ( checkDisabledOff , 0 , 0 , null ) ; } else { Composite oldComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 0.5f ) ) ; g2 . drawImage ( normalImage , 0 , 0 , null ) ; g2 . setComposite ( oldComposite ) ; } } int w = normalImage . getWidth ( null ) ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; if ( warn ) { g2 . setColor ( Theme . TEXT_WARNING_COLOR ) ; } else if ( armed ) { g2 . setColor ( Theme . TEXT_ARMED_COLOR ) ; } else if ( ! isEnabled ( ) ) { g2 . setColor ( Theme . TEXT_DISABLED_COLOR ) ; } else { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } SwingUtils . drawShadowText ( g2 , text , w + IMAGE_TEXT_MARGIN , TEXT_BASELINE ) ; } 
public void changePaneType ( Class paneType ) { if ( ! Pane . class . isAssignableFrom ( paneType ) ) return ; final Pane newPane ; try { Constructor c = paneType . getConstructors ( ) [ 0 ] ; newPane = ( Pane ) c . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( " Could not instantiate new " + paneType , e ) ; } Container parent = getParent ( ) ; if ( parent instanceof JSplitPane ) { JSplitPane parentSplit = ( JSplitPane ) parent ; boolean first = parentSplit . getTopComponent ( ) = = this ; if ( first ) { parentSplit . setTopComponent ( newPane ) ; } else { parentSplit . setBottomComponent ( newPane ) ; } } else { Dimension d = getSize ( ) ; parent . remove ( this ) ; parent . add ( newPane ) ; newPane . setSize ( d ) ; } parent . validate ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public static PaneHeader withName ( Pane pane ) { return new PaneHeader ( pane , true ) ; } 
public static PaneHeader withoutName ( Pane pane ) { return new PaneHeader ( pane , false ) ; } 
public static File getUserDataDirectory ( ) throws RuntimeException { if ( userDataDirectory ! = null ) return userDataDirectory ; if ( onMac ( ) ) { userDataDirectory = new File ( getHomeDirectory ( ) , " Library/ " + APPLICATION_NAME ) ; } else if ( onWindows ( ) ) { String localAppData ; HWND hwndOwner = null ; int nFolder = Shell32 . CSIDL_LOCAL_APPDATA ; HANDLE hToken = null ; int dwFlags = Shell32 . SHGFP_TYPE_CURRENT ; char [ ] pszPath = new char [ Shell32 . MAX_PATH ] ; int hResult = Shell32 . INSTANCE . SHGetFolderPath ( hwndOwner , nFolder , hToken , dwFlags , pszPath ) ; if ( Shell32 . S_OK = = hResult ) { String path = new String ( pszPath ) ; int len = path . indexOf ( '\0' ) ; localAppData = path . substring ( 0 , len ) ; } else { If the native call fails, use the home directory. localAppData = getHomeDirectory().getPath(); } userDataDirectory = new File(localAppData, APPLICATION_NAME); } else { userDataDirectory = new File(getHomeDirectory(), APPLICATION_NAME.toLowerCase(Locale.US)); } return userDataDirectory; } 
public static void openURL ( String url ) { try { Desktop . getDesktop ( ) . browse ( URI . create ( url ) ) ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( isEnabled ( ) ) { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } else { g2 . setColor ( Theme . TEXT_DISABLED_COLOR ) ; } g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; int textX = Theme . LABEL_WIDTH - g2 . getFontMetrics ( ) . stringWidth ( getText ( ) ) - 10 ; Add some padding to align it to 30px high components. int textY = (getHeight() - g2.getFont().getSize()) / 2 + 10; SwingUtils.drawShadowText(g2, getText(), textX, textY, Theme.DEFAULT_SHADOW_COLOR, 1); } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { Draw border on the side of the label g.setColor(LABEL_UP_COLOR); g.fillRect(x, y + height - 2, LABEL_WIDTH - 2, 1); g.setColor(LABEL_DOWN_COLOR); g.fillRect(x, y + height - 1, LABEL_WIDTH - 2, 1); Draw border on port side g.setColor(PARAMETER_UP_COLOR); g.fillRect(x + LABEL_WIDTH + 1, y + height - 2, width - LABEL_WIDTH - 1, 1); g.setColor(PARAMETER_DOWN_COLOR); g.fillRect(x + LABEL_WIDTH + 1, y + height - 1, width - LABEL_WIDTH - 1, 1); } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { Draw border on the side of the label g.setColor(LABEL_UP_COLOR); g.fillRect(x, y + height - 2, LABEL_WIDTH - 2, 1); g.setColor(LABEL_DOWN_COLOR); g.fillRect(x, y + height - 1, LABEL_WIDTH - 2, 1); Draw border on port side g.setColor(PARAMETER_UP_COLOR); g.fillRect(x + LABEL_WIDTH, y + height - 2, width - LABEL_WIDTH, 1); g.setColor(PARAMETER_DOWN_COLOR); g.fillRect(x + LABEL_WIDTH + 1, y + height - 1, width - LABEL_WIDTH - 1, 1); } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . setColor ( EDGE_COLOR ) ; g . drawRect ( x + 1 , y + 1 , width - 3 , height - 3 ) ; g . setColor ( SHADOW_COLOR ) ; g . drawLine ( x , y , x + width - 1 , y ) ; g . drawLine ( x , y , x , y + height - 1 ) ; g . setColor ( HIGHLIGHT_COLOR ) ; g . drawLine ( x , y + height - 1 , x + width - 1 , y + height - 1 ) ; g . drawLine ( x + width - 1 , y , x + width - 1 , y + height - 1 ) ; } 
public static double angle ( double x0 , double y0 , double x1 , double y1 ) { return degrees ( Math . atan2 ( y1 - y0 , x1 - x0 ) ) ; } 
public static double distance ( double x0 , double y0 , double x1 , double y1 ) { return Math . sqrt ( Math . pow ( x1 - x0 , 2 ) + Math . pow ( y1 - y0 , 2 ) ) ; } 
public static < E > InfiniteList < E > of ( E object ) { return new InfiniteList < E > ( object ) ; } 
public boolean contains ( Object o ) { return theObject . equals ( o ) ; } 
public Iterator < E > iterator ( ) { return new Iterator < E > ( ) { public boolean hasNext ( ) { 
public boolean hasNext ( ) { return true ; } 
public E next ( ) { return theObject ; } 
public void remove ( ) { throw new UnsupportedOperationException ( " Remove is not supported. " ) ; } 
public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( ) ; } 
public < E > E [ ] toArray ( E [ ] a ) { throw new UnsupportedOperationException ( ) ; 
public boolean add ( Object o ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public boolean remove ( Object o ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public boolean containsAll ( Collection < ? > objects ) { throw new UnsupportedOperationException ( ) ; } 
public boolean addAll ( Collection collection ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public boolean addAll ( int i , Collection collection ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public boolean removeAll ( Collection < ? > objects ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public boolean retainAll ( Collection < ? > objects ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public void clear ( ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public E set ( int i , Object o ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public void add ( int i , Object o ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public E remove ( int i ) { throw new UnsupportedOperationException ( " Infinite list is read-only. " ) ; } 
public int indexOf ( Object o ) { throw new UnsupportedOperationException ( ) ; } 
public int lastIndexOf ( Object o ) { throw new UnsupportedOperationException ( ) ; } 
public ListIterator < E > listIterator ( ) { throw new UnsupportedOperationException ( ) ; } 
public ListIterator < E > listIterator ( int i ) { throw new UnsupportedOperationException ( ) ; } 
public List < E > subList ( int i , int i1 ) { throw new UnsupportedOperationException ( ) ; } 
public static Class listClass ( Iterable < ? > objects ) { if ( objects = = null ) return Object . class ; Class < ? > c = classOfFirst ( objects ) ; return nestedListClass ( objects , c ) ; } 
private static Class nestedListClass ( Iterable < ? > objects , Class klass ) { Class c = klass ; for ( Object o : objects ) { if ( o = = null ) return Object . class ; if ( o instanceof List ) { c = nestedListClass ( ( Iterable ) o , c ) ; break ; } while ( c ! = Object . class ) { if ( ! c . isAssignableFrom ( o . getClass ( ) ) ) c = c . getSuperclass ( ) ; else break ; } } return c ; } 
private static Class classOfFirst ( Iterable < ? > objects ) { Object firstObject = Iterables . getFirst ( objects , null ) ; if ( firstObject = = null ) return Object . class ; if ( firstObject instanceof List ) return classOfFirst ( ( Iterable ) firstObject ) ; return firstObject . getClass ( ) ; } 
public static String capitalize ( String s ) { if ( s = = null | | s . length ( ) = = 0 ) { return s ; } return s . substring ( 0 , 1 ) . toUpperCase ( ENGLISH ) + s . substring ( 1 ) ; } 
public static String getterMethod ( String field ) { return " get " + capitalize ( field ) ; } 
public static Object get ( Object o , String field , Object defaultValue ) { checkNotNull ( o , " The given object cannot be null. " ) ; checkNotNull ( field , " The field cannot be null. " ) ; try { Method m = getGetterMethod ( o . getClass ( ) , field ) ; 
public static String humanizeName ( String name ) { StringBuilder sb = new StringBuilder ( ) ; String [ ] tokens = name . split ( " _ " ) ; for ( String : tokens ) { if ( . length ( ) = = 0 ) continue ; sb . append ( . substring ( 0 , 1 ) . toUpperCase ( Locale . US ) ) ; sb . append ( . substring ( 1 ) ) ; sb . append ( " " ) ; } return sb . toString ( ) . trim ( ) ; } 
protected abstract float adjustedTime ( float ) ; protected abstract float computeValue ( float phase ) ; } 
private void downloadClicked ( ) { setVisible ( false ) ; dispose ( ) ; Open download link URL. Platform.openURL(appcast.getDownloadLink()); } 
public void checkForUpdates ( boolean showProgressWindow ) { if ( updateChecker ! = null & & updateChecker . isAlive ( ) ) return ; if ( showProgressWindow ) { updateCheckDialog = new UpdateCheckDialog ( null , this ) ; updateCheckDialog . setLocationRelativeTo ( null ) ; updateCheckDialog . setVisible ( true ) ; } updateChecker = new UpdateChecker ( this , false ) ; updateChecker . start ( ) ; } 
public void checkerFoundValidUpdate ( UpdateChecker checker , Appcast appcast ) { Delegate method. if (delegate != null) if (delegate.checkerFoundValidUpdate(checker, appcast)) return; UpdateAlert alert = new UpdateAlert(this, appcast); alert.setLocationRelativeTo(null); alert.setVisible(true); } 
public void testAdd ( ) { Node addNode = Node . ROOT . withName ( " add " ) . withOutputType ( " int " ) . withFunction ( " clojure-math/add " ) ; Iterable < ? > results = context . renderNode ( addNode ) ; assertResultsEqual ( results , 0 L ) ; } 
public void testAddWithArguments ( ) { Node addNode = Node . ROOT . withName ( " add " ) . withFunction ( " clojure-math/add " ) . withOutputType ( " int " ) . withInputAdded ( Port . intPort ( " v1 " , 1 ) ) . withInputAdded ( Port . intPort ( " v2 " , 2 ) ) . withInputAdded ( Port . intPort ( " v3 " , 3 ) ) ; Iterable < ? > results = context . renderNode ( addNode ) ; assertResultsEqual ( results , 6L ) ; } 
public void testNoVarAtEnd ( ) { ClojureLibrary . loadScript ( " test/clojure/no-var-at-end.clj " ) ; } 
public void testLookupNull ( ) { assertNull ( lookup ( null , " xxx " ) ) ; assertNull ( lookup ( new Point ( 11 , 22 ) , null ) ) ; } 
public void testLookupInMap ( ) { Map < String , Integer > greek = ImmutableMap . of ( " alpha " , 1 , " beta " , 2 , " gamma " , 3 ) ; assertEquals ( 1 , lookup ( greek , " alpha " ) ) ; assertEquals ( 2 , lookup ( greek , " beta " ) ) ; assertNull ( lookup ( greek , " xxx " ) ) ; } 
public void testLookupInObject ( ) { Point awtPoint = new Point ( 11 , 22 ) ; assertEquals ( 11.0 , lookup ( awtPoint , " x " ) ) ; assertEquals ( 22.0 , lookup ( awtPoint , " y " ) ) ; assertNull ( lookup ( awtPoint , " xxx " ) ) ; } 
public void testImportCSV ( ) { List < Map < String , Object > > l = importCSV ( " test/files/colors.csv " ) ; assertEquals ( 5 , l . size ( ) ) ; Map < String , Object > black = l . get ( 0 ) ; assertResultsEqual ( black . keySet ( ) , " Name " , " Red " , " Green " , " Blue " ) ; assertEquals ( " Black " , black . get ( " Name " ) ) ; Numerical data is automatically converted to doubles. assertEquals(0.0, black.get("Red")); } 
public void testImportCSVUnicode ( ) { List < Map < String , Object > > l = importCSV ( " test/files/unicode.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > frederik = l . get ( 0 ) ; assertResultsEqual ( frederik . keySet ( ) , " Name " , " Age " ) ; assertEquals ( " Fr u00e9d u00ebr u00eck " , frederik . get ( " Name " ) ) ; Map < String , Object > bob = l . get ( 1 ) ; assertEquals ( " B u00f8b " , bob . get ( " Name " ) ) ; } 
public void testImportEmptyCSV ( ) { List l = importCSV ( null ) ; assertTrue ( l . isEmpty ( ) ) ; } 
public void testImportNonexistentCSV ( ) { importCSV ( " blah/blah.csv " ) ; } 
public void testImportCSVWithWhitespace ( ) { List < Map < String , Object > > l = importCSV ( " test/files/whitespace.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > alice = l . get ( 0 ) ; assertResultsEqual ( alice . keySet ( ) , " Name " , " Age " ) ; assertEquals ( " Alice " , alice . get ( " Name " ) ) ; Numerical data is automatically converted to doubles. assertEquals(41.0, alice.get("Age")); } 
public void testImportCSVWithBadHeaders ( ) { List < Map < String , Object > > l = importCSV ( " test/files/bad-headers.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > row1 = l . get ( 0 ) ; assertResultsEqual ( row1 . keySet ( ) , " Alpha " , " Column 2 " , " Column 3 " ) ; assertResultsEqual ( row1 . values ( ) , 1.0 , 2.0 , 3.0 ) ; } 
public void testLoadClojure ( ) { String href = " clojure:test/clojure/math.clj " ; FunctionLibrary clojureLibrary = FunctionLibrary . load ( " clojure:test/clojure/math.clj " ) ; assertEquals ( " clojure-math " , clojureLibrary . getNamespace ( ) ) ; assertTrue ( clojureLibrary . hasFunction ( " add " ) ) ; assertEquals ( href , clojureLibrary . getLink ( new File ( userDir , " test.ndbx " ) ) ) ; } 
public void testLoadPython ( ) { String href = " python:test/python/functions.py " ; FunctionLibrary pythonLibrary = FunctionLibrary . load ( href ) ; assertEquals ( " functions " , pythonLibrary . getNamespace ( ) ) ; assertTrue ( pythonLibrary . hasFunction ( " add " ) ) ; assertEquals ( href , pythonLibrary . getLink ( new File ( userDir , " test.ndbx " ) ) ) ; } 
public void testLoadJava ( ) { String href = " java:nodebox.function.MathFunctions " ; FunctionLibrary javaLibrary = FunctionLibrary . load ( href ) ; assertEquals ( " math " , javaLibrary . getNamespace ( ) ) ; assertTrue ( javaLibrary . hasFunction ( " add " ) ) ; assertEquals ( href , javaLibrary . getLink ( ) ) ; } 
public void testGetFunctionRepository ( ) { NodeRepository nodeRepository = NodeRepository . of ( mathLibrary , stringLibrary ) ; FunctionRepository functionRepository = nodeRepository . getFunctionRepository ( ) ; assertTrue ( functionRepository . hasLibrary ( " math " ) ) ; assertTrue ( functionRepository . hasLibrary ( " string " ) ) ; } 
public void testCount ( ) { assertEquals ( 0 , ListFunctions . count ( null ) ) ; assertEquals ( 0 , ListFunctions . count ( ImmutableList . of ( ) ) ) ; assertEquals ( 3 , ListFunctions . count ( ImmutableList . of ( 1 , 2 , 3 ) ) ) ; } 
public void testFirst ( ) { assertElements ( ListFunctions . first ( ImmutableList . of ( ) ) ) ; assertElements ( ListFunctions . first ( ImmutableList . of ( 1 ) ) , 1 ) ; assertElements ( ListFunctions . first ( ImmutableList . of ( 1 , 2 ) ) , 1 ) ; assertElements ( ListFunctions . first ( ImmutableList . of ( 1 , 2 , 3 ) ) , 1 ) ; } 
public void testSecond ( ) { assertElements ( ListFunctions . second ( ImmutableList . of ( ) ) ) ; assertElements ( ListFunctions . second ( ImmutableList . of ( 1 ) ) ) ; assertElements ( ListFunctions . second ( ImmutableList . of ( 1 , 2 ) ) , 2 ) ; assertElements ( ListFunctions . second ( ImmutableList . of ( 1 , 2 , 3 ) ) , 2 ) ; } 
public void testRest ( ) { assertElements ( ListFunctions . rest ( ImmutableList . of ( ) ) ) ; assertElements ( ListFunctions . rest ( ImmutableList . of ( 1 ) ) ) ; assertElements ( ListFunctions . rest ( ImmutableList . of ( 1 , 2 ) ) , 2 ) ; assertElements ( ListFunctions . rest ( ImmutableList . of ( 1 , 2 , 3 ) ) , 2 , 3 ) ; } 
public void testLast ( ) { assertElements ( ListFunctions . last ( ImmutableList . of ( ) ) ) ; assertElements ( ListFunctions . last ( ImmutableList . of ( 1 ) ) , 1 ) ; assertElements ( ListFunctions . last ( ImmutableList . of ( 1 , 2 ) ) , 2 ) ; assertElements ( ListFunctions . last ( ImmutableList . of ( 1 , 2 , 3 ) ) , 3 ) ; } 
public void testCombine ( ) { assertElements ( ListFunctions . combine ( ImmutableList . of ( ) , ImmutableList . of ( ) ) ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( ) ) , 1 ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( 2 ) ) , 1 , 2 ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( 2 ) , ImmutableList . of ( 3 ) ) , 1 , 2 , 3 ) ; } 
public void testSubList ( ) { assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 0 , 100 ) , 1 , 2 , 3 , 4 ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( ) , 100 , 100 ) ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 1 , 2 ) , 2 , 3 ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 100 , 2 ) ) ; } 
public void testShift ( ) { assertElements ( ListFunctions . shift ( ImmutableList . of ( ) , 0 ) ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( ) , 10 ) ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 ) , 10 ) , 1 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , 1 ) , 2 , 3 , 1 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , 2 ) , 3 , 1 , 2 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , 3 ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , 4 ) , 2 , 3 , 1 ) ; } 
public void testReverse ( ) { assertElements ( ListFunctions . reverse ( ImmutableList . of ( ) ) ) ; assertElements ( ListFunctions . reverse ( ImmutableList . of ( 1 ) ) , 1 ) ; assertElements ( ListFunctions . reverse ( ImmutableList . of ( 1 , 2 ) ) , 2 , 1 ) ; assertElements ( ListFunctions . reverse ( ImmutableList . of ( 1 , 2 , 3 ) ) , 3 , 2 , 1 ) ; } 
public void testSort ( ) { assertElements ( ListFunctions . sort ( ImmutableList . of ( " c " , " b " , " a " ) , null ) , " a " , " b " , " c " ) ; assertElements ( ListFunctions . sort ( ImmutableList . of ( 9 , 3 , 5 ) , null ) , 3 , 5 , 9 ) ; } 
public void testSortByKey ( ) { Point p1 = new Point ( 1 , 9 ) ; Point p2 = new Point ( 10 , 4 ) ; Point p3 = new Point ( 4 , 7 ) ; Point p4 = new Point ( 8 , 6 ) ; assertElements ( ListFunctions . sort ( ImmutableList . of ( p1 , p2 , p3 , p4 ) , " x " ) , p1 , p3 , p4 , p2 ) ; assertElements ( ListFunctions . sort ( ImmutableList . of ( p1 , p2 , p3 , p4 ) , " y " ) , p2 , p4 , p3 , p1 ) ; } 
public void testShuffle ( ) { Shuffling is stable: the same seed always returns the same sort order. assertElements(ListFunctions.shuffle(ImmutableList.of(), 42)); assertElements(ListFunctions.shuffle(ImmutableList.of(1), 42), 1); assertElements(ListFunctions.shuffle(ImmutableList.of(1, 2, 3, 4, 5), 42), 2, 3, 4, 5, 1); assertElements(ListFunctions.shuffle(ImmutableList.of(1, 2, 3, 4, 5), 33), 2, 1, 5, 3, 4); } 
public void testFilter ( ) { assertElements ( ListFunctions . filter ( ImmutableList . of ( ) , ImmutableList . < Boolean > of ( ) ) ) ; assertElements ( ListFunctions . filter ( ImmutableList . of ( 1 , 2 , 3 , 4 , 5 ) , ImmutableList . of ( true , false , false , true , true ) ) , 1 , 4 , 5 ) ; assertElements ( ListFunctions . filter ( ImmutableList . of ( 1 , 2 , 3 , 4 , 5 ) , ImmutableList . of ( true , false , true , false , true , false , true ) ) , 1 , 3 , 5 ) ; assertElements ( ListFunctions . filter ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . < Boolean > of ( ) ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . filter ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . of ( true ) ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . filter ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . of ( false ) ) ) ; } 
public void testCull ( ) { assertElements ( ListFunctions . cull ( ImmutableList . of ( ) , ImmutableList . < Boolean > of ( ) ) ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . < Boolean > of ( ) ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . < Boolean > of ( true ) ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . < Boolean > of ( false ) ) ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , ImmutableList . < Boolean > of ( false , true ) ) , 2 , 4 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , ImmutableList . < Boolean > of ( true , false ) ) , 1 , 3 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , ImmutableList . < Boolean > of ( true , true , false ) ) , 1 , 2 , 4 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , ImmutableList . < Boolean > of ( true , false , true , true , true ) ) , 1 , 3 , 4 ) ; } 
public void testDistinct ( ) { Distinct is stable: the same seed always returns the same sort order. assertElements(ListFunctions.distinct(ImmutableList.of())); assertElements(ListFunctions.distinct(ImmutableList.of(1, 2, 3, 4)), 1, 2, 3, 4); assertElements(ListFunctions.distinct(ImmutableList.of(4, 3, 2, 1)), 4, 3, 2, 1); assertElements(ListFunctions.distinct(ImmutableList.of(3, 4, 3, 1, 2, 1)), 3, 4, 1, 2); assertElements(ListFunctions.distinct(ImmutableList.of(3, 4, 3, 2, 1)), 3, 4, 2, 1); } 
public void testRepeat ( ) { assertElements ( ListFunctions . repeat ( ImmutableList . of ( ) , 0 ) ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( ) , 10 ) ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , - 1 ) ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , 0 ) ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , 1 ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , 2 ) , 1 , 2 , 3 , 1 , 2 , 3 ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 ) , 5 ) , 1 , 1 , 1 , 1 , 1 ) ; } 
public void testSortDisparateElements ( ) { You can't sort elements of different types. This error is caught and wrapped in an illegal argument exception. ListFunctions.sort(ImmutableList.of("hello", 42, 15.0), null); } 
public void testCycle ( ) { assertFirstElements ( ListFunctions . cycle ( ImmutableList . of ( ) ) ) ; assertFirstElements ( ListFunctions . cycle ( ImmutableList . of ( 1 ) ) , 1 , 1 , 1 , 1 , 1 ) ; assertFirstElements ( ListFunctions . cycle ( ImmutableList . of ( 1 , 2 ) ) , 1 , 2 , 1 , 2 , 1 ) ; assertFirstElements ( ListFunctions . cycle ( ImmutableList . of ( 1 , 2 , 3 ) ) , 1 , 2 , 3 , 1 , 2 ) ; } 
public void testTakeEvery ( ) { assertElements ( ListFunctions . takeEvery ( ImmutableList . of ( ) , 1 ) ) ; assertElements ( ListFunctions . takeEvery ( ImmutableList . of ( 1 , 2 , 3 , 4 , 5 ) , 1 ) , 1 , 2 , 3 , 4 , 5 ) ; assertElements ( ListFunctions . takeEvery ( ImmutableList . of ( 1 , 2 , 3 , 4 , 5 ) , 2 ) , 1 , 3 , 5 ) ; assertElements ( ListFunctions . takeEvery ( ImmutableList . of ( 1 , 2 , 3 , 4 , 5 ) , 3 ) , 1 , 4 ) ; } 
private void assertElements ( Iterable < ? > iterable , Object . . . items ) { assertEquals ( ImmutableList . copyOf ( iterable ) , ImmutableList . copyOf ( items ) ) ; } 
private void assertFirstElements ( Iterable < ? > iterable , Object . . . items ) { assertElements ( Iterables . limit ( iterable , items . length ) , items ) ; } 
public void testInvertExists ( ) { assertTrue ( functions . hasFunction ( " math/negate " ) ) ; assertTrue ( mathLibrary . hasFunction ( " negate " ) ) ; Function function = functions . getFunction ( " math/negate " ) ; assertEquals ( " negate " , function . getName ( ) ) ; } 
public void testCallInvertWithNoArguments ( ) { Node invertNode = Node . ROOT . withFunction ( " math/negate " ) ; context . renderNode ( invertNode ) ; } 
public void testCallInvert ( ) { Node invertNode = Node . ROOT . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 5 ) ) ; assertEquals ( ImmutableList . of ( - 5.0 ) , context . renderNode ( invertNode ) ) ; } 
public void testPortOrder ( ) { Node subtract1 = Node . ROOT . withFunction ( " math/subtract " ) . withInputAdded ( Port . floatPort ( " a " , 10 ) ) . withInputAdded ( Port . floatPort ( " b " , 3 ) ) ; assertEquals ( ImmutableList . of ( 7.0 ) , context . renderNode ( subtract1 ) ) ; Node subtract2 = Node . ROOT . withFunction ( " math/subtract " ) . withInputAdded ( Port . floatPort ( " b " , 3 ) ) . withInputAdded ( Port . floatPort ( " a " , 10 ) ) ; assertEquals ( ImmutableList . of ( - 7.0 ) , context . renderNode ( subtract2 ) ) ; } 
public void testAbs ( ) { assertEquals ( 0.0 , MathFunctions . abs ( 0.0 ) , 0.0 ) ; assertEquals ( 42.0 , MathFunctions . abs ( 42.0 ) , 0.0 ) ; assertEquals ( 42.0 , MathFunctions . abs ( - 42.0 ) , 0.0 ) ; } 
public void testMod ( ) { assertEquals ( 0.0 , MathFunctions . mod ( 10 , 2 ) , 0.0 ) ; assertEquals ( 3.0 , MathFunctions . mod ( 10 , 7 ) , 0.0 ) ; } 
public void testModByZero ( ) { MathFunctions . mod ( 10 , 0 ) ; } 
public void testSum ( ) { assertEquals ( 0.0 , MathFunctions . sum ( null ) , 0.001 ) ; assertEquals ( 0.0 , MathFunctions . sum ( ImmutableList . < Double > of ( ) ) , 0.001 ) ; assertEquals ( 6.0 , MathFunctions . sum ( ImmutableList . of ( 1.0 , 2.0 , 3.0 ) ) , 0.001 ) ; assertEquals ( - 6.0 , MathFunctions . sum ( ImmutableList . of ( - 1.0 , - 2.0 , - 3.0 ) ) , 0.001 ) ; } 
public void testMax ( ) { assertEquals ( 0.0 , MathFunctions . max ( ImmutableList . < Double > of ( ) ) , 0.001 ) ; assertEquals ( 3.0 , MathFunctions . max ( ImmutableList . of ( 1.0 , 2.0 , 3.0 ) ) , 0.001 ) ; assertEquals ( - 1.0 , MathFunctions . max ( ImmutableList . of ( - 1.0 , - 2.0 , - 3.0 ) ) , 0.001 ) ; } 
public void testMin ( ) { assertEquals ( 0.0 , MathFunctions . min ( ImmutableList . < Double > of ( ) ) , 0.001 ) ; assertEquals ( 1.0 , MathFunctions . min ( ImmutableList . of ( 1.0 , 2.0 , 3.0 ) ) , 0.001 ) ; assertEquals ( - 3.0 , MathFunctions . min ( ImmutableList . of ( - 1.0 , - 2.0 , - 3.0 ) ) , 0.001 ) ; } 
public void testRandomNumbers ( ) { List < Double > numbers = MathFunctions . randomNumbers ( 3 , - 10.0 , 10.0 , 42 ) ; assertEquals ( 4.55127 , numbers . get ( 0 ) , 0.001 ) ; assertEquals ( 3.66447 , numbers . get ( 1 ) , 0.001 ) ; assertEquals ( - 3.82561 , numbers . get ( 2 ) , 0.001 ) ; } 
public void testSample ( ) { Assertions . assertResultsEqual ( sample ( 0 , 1 , 2 ) ) ; Assertions . assertResultsEqual ( sample ( 1 , 100 , 200 ) , 150.0 ) ; Assertions . assertResultsEqual ( sample ( 2 , 100 , 200 ) , 100.0 , 200.0 ) ; Assertions . assertResultsEqual ( sample ( 3 , 100 , 200 ) , 100.0 , 150.0 , 200.0 ) ; Assertions . assertResultsEqual ( sample ( 4 , 100 , 250 ) , 100.0 , 150.0 , 200.0 , 250.0 ) ; Assertions . assertResultsEqual ( sample ( 3 , 200 , 100 ) , 200.0 , 150.0 , 100.0 ) ; Assertions . assertResultsEqual ( sample ( 3 , 1 , 1 ) , 1.0 , 1.0 , 1.0 ) ; List < Double > values = sample ( 1000 , 0 , 100 ) ; double lastValue = values . get ( values . size ( ) - 1 ) ; assertEquals ( " The last value needs to be exactly 100. " , 100.0 , lastValue , 0.0 ) ; assertTrue ( " The last value needs to be exactly 100. " , lastValue < = 100.0 ) ; } 
public void testConvertRange ( ) { assertEquals ( 0.5 , convertRange ( 50 , 0 , 100 , 0 , 1 , OVERFLOW_IGNORE ) , 0.001 ) ; assertEquals ( 0.25 , convertRange ( 75 , 0 , 100 , 1 , 0 , OVERFLOW_IGNORE ) , 0.001 ) ; } 
public void testNamespaceForFile ( ) { assertEquals ( " math " , PythonLibrary . namespaceForFile ( " math.py " ) ) ; assertNamespaceForFileFails ( " blob " , " needs to end in .py " ) ; assertNamespaceForFileFails ( " .py " , " can not be empty " ) ; assertNamespaceForFileFails ( " MyFileName.py " , " can only contain " ) ; assertNamespaceForFileFails ( " my-file-name.py " , " can only contain " ) ; assertNamespaceForFileFails ( " my file name.py " , " can only contain " ) ; } 
private void assertNamespaceForFileFails ( String fileName , String message ) { try { PythonLibrary . namespaceForFile ( fileName ) ; 
public void testAdd ( ) { Node addNode = Node . ROOT . withName ( " add " ) . withFunction ( " py-functions/add " ) ; Iterable < ? > results = context . renderNode ( addNode ) ; assertResultsEqual ( results , 0 L ) ; } 
public void testAddWithArguments ( ) { Node addNode = Node . ROOT . withName ( " add " ) . withFunction ( " py-functions/add " ) . withInputAdded ( Port . intPort ( " v1 " , 1 ) ) . withInputAdded ( Port . intPort ( " v2 " , 2 ) ) . withInputAdded ( Port . intPort ( " v3 " , 3 ) ) ; Iterable < ? > results = context . renderNode ( addNode ) ; assertResultsEqual ( results , 6L ) ; } 
public void testMultiplyFloat ( ) { Node multiplyNode = Node . ROOT . withName ( " multiply " ) . withFunction ( " py-functions/multiply " ) . withInputAdded ( Port . floatPort ( " v1 " , 10 ) ) . withInputAdded ( Port . floatPort ( " v2 " , 2 ) ) ; Iterable < ? > results = context . renderNode ( multiplyNode ) ; assertResultsEqual ( results , 20.0 ) ; } 
public void testMultiplyString ( ) { Node multiplyNode = Node . ROOT . withName ( " multiply " ) . withFunction ( " py-functions/multiply " ) . withInputAdded ( Port . stringPort ( " v1 " , " spam " ) ) . withInputAdded ( Port . intPort ( " v2 " , 3 ) ) ; Iterable < ? > results = context . renderNode ( multiplyNode ) ; assertResultsEqual ( results , " spamspamspam " ) ; } 
public void testLoadError ( ) { PythonLibrary . loadScript ( " py-error " , " test/python/nonexisting.py " ) ; } 
public void testMakeStrings ( ) { assertResultsEqual ( makeStrings ( " a;b " , " ; " ) , " a " , " b " ) ; assertResultsEqual ( makeStrings ( " a;b " , " " ) , " a " , " ; " , " b " ) ; assertResultsEqual ( makeStrings ( " hello " , " " ) , " h " , " e " , " l " , " l " , " o " ) ; assertResultsEqual ( makeStrings ( " a b c " , " " ) , " a " , " b " , " c " ) ; assertResultsEqual ( makeStrings ( " a; b; c " , " ; " ) , " a " , " b " , " c " ) ; assertResultsEqual ( makeStrings ( null , " ; " ) ) ; assertResultsEqual ( makeStrings ( null , null ) ) ; } 
public void testLength ( ) { assertEquals ( 0 , StringFunctions . length ( null ) ) ; assertEquals ( 0 , StringFunctions . length ( " " ) ) ; assertEquals ( 5 , StringFunctions . length ( " bingo " ) ) ; } 
public void testWordCount ( ) { assertEquals ( 0 , StringFunctions . wordCount ( null ) ) ; assertEquals ( 0 , StringFunctions . wordCount ( " " ) ) ; assertEquals ( 1 , StringFunctions . wordCount ( " a " ) ) ; assertEquals ( 1 , StringFunctions . wordCount ( " a_b " ) ) ; assertEquals ( 2 , StringFunctions . wordCount ( " a b " ) ) ; assertEquals ( 2 , StringFunctions . wordCount ( " a-b " ) ) ; assertEquals ( 2 , StringFunctions . wordCount ( " a,b " ) ) ; assertEquals ( 2 , StringFunctions . wordCount ( " a.b " ) ) ; } 
public void testConcatenate ( ) { assertEquals ( " a " , StringFunctions . concatenate ( " a " , null , null , null ) ) ; assertEquals ( " ab " , StringFunctions . concatenate ( " a " , " b " , null , null ) ) ; assertEquals ( " ad " , StringFunctions . concatenate ( " a " , null , null , " d " ) ) ; assertEquals ( " cd " , StringFunctions . concatenate ( null , null , " c " , " d " ) ) ; assertEquals ( " " , StringFunctions . concatenate ( null , null , null , null ) ) ; } 
public static String allTypes ( int i , float f , String s , Point pt ) { StringBuilder b = new StringBuilder ( ) . append ( i ) . append ( " , " ) . append ( f ) . append ( " , " ) . append ( s ) . append ( " , " ) . append ( pt ) ; return b . toString ( ) ; } 
public static Double makeNull ( Double ignored ) { return null ; } 
public static boolean fileExists ( String fileName ) { return new File ( fileName ) . exists ( ) ; } 
public static double calculateMultipleArgs ( double a , double b , double c , double d ) { return a + b * c + d ; } 
public void testCloning ( ) { Color backgroundColor = new Color ( 0.1 , 0.2 , 0.3 ) ; Canvas c = new Canvas ( 200 , 300 ) ; c . setBackground ( backgroundColor ) ; Canvas c2 = c . clone ( ) ; assertEquals ( 200.0 , c2 . getWidth ( ) ) ; assertEquals ( 300.0 , c2 . getHeight ( ) ) ; assertEquals ( backgroundColor , c . getBackground ( ) ) ; } 
public void testPointAt ( ) { Contour c1 = new Contour ( ) ; c1 . addPoint ( 0 , 0 ) ; c1 . addPoint ( 100 , 0 ) ; assertPointEquals ( 0 , 0 , c1 . pointAt ( 0 ) ) ; assertPointEquals ( 50 , 0 , c1 . pointAt ( 0.5 ) ) ; assertPointEquals ( 100 , 0 , c1 . pointAt ( 1 ) ) ; assertPointEquals ( - 50 , 0 , c1 . pointAt ( - 0.5 ) ) ; assertPointEquals ( 150 , 0 , c1 . pointAt ( 1.5 ) ) ; Contour c2 = new Contour ( ) ; c2 . addPoint ( new Point ( 0 , 0 , Point . LINE_TO ) ) ; c2 . addPoint ( new Point ( 0 , 0 , Point . CURVE_DATA ) ) ; c2 . addPoint ( new Point ( 100 , 0 , Point . CURVE_DATA ) ) ; c2 . addPoint ( new Point ( 100 , 0 , Point . CURVE_TO ) ) ; assertPointEquals ( 0 , 0 , c2 . pointAt ( 0 ) ) ; assertPointEquals ( 50 , 0 , c2 . pointAt ( 0.5 ) ) ; assertPointEquals ( 100 , 0 , c2 . pointAt ( 1 ) ) ; assertEquals(new Point(-50, 0), c2.pointAt(-0.5)); 
public void testPointAtEmptyPath ( ) { Contour c = new Contour ( ) ; try { c . pointAt ( 0.1 ) ; fail ( " Should have thrown an error. " ) ; } catch ( NodeBoxError e ) { } c . addPoint ( 33 , 44 ) ; assertPointEquals ( 33 , 44 , c . pointAt ( 0.1 ) ) ; assertPointEquals ( 33 , 44 , c . pointAt ( 100 ) ) ; assertPointEquals ( 33 , 44 , c . pointAt ( - 12 ) ) ; } 
public void testPointAtClosed ( ) { Contour c = new Contour ( ) ; c . addPoint ( 0 , 0 ) ; c . addPoint ( SIDE , 0 ) ; c . addPoint ( SIDE , SIDE ) ; c . addPoint ( 0 , SIDE ) ; assertEquals ( SIDE * 3 , c . getLength ( ) ) ; assertPointEquals ( 0 , 0 , c . pointAt ( 0 ) ) ; assertPointEquals ( SIDE , SIDE / 2 , c . pointAt ( 0.5 ) ) ; assertPointEquals ( 0 , SIDE , c . pointAt ( 1 ) ) ; c . close ( ) ; assertEquals ( SIDE * 4 , c . getLength ( ) ) ; assertPointEquals ( 0 , 0 , c . pointAt ( 0 ) ) ; assertPointEquals ( SIDE , SIDE , c . pointAt ( 0.5 ) ) ; assertPointEquals ( 0 , 0 , c . pointAt ( 1 ) ) ; } 
public void testPointAtMultiple ( ) { Contour c1 = new Contour ( ) ; c1 . addPoint ( 0 , 0 ) ; c1 . addPoint ( 50 , 0 ) ; c1 . addPoint ( 100 , 0 ) ; assertPointEquals ( - 50 , 0 , c1 . pointAt ( - 0.5 ) ) ; assertPointEquals ( 0 , 0 , c1 . pointAt ( 0 ) ) ; assertPointEquals ( 25 , 0 , c1 . pointAt ( 0.25 ) ) ; assertPointEquals ( 50 , 0 , c1 . pointAt ( 0.5 ) ) ; assertPointEquals ( 60 , 0 , c1 . pointAt ( 0.6 ) ) ; assertPointEquals ( 100 , 0 , c1 . pointAt ( 1 ) ) ; assertPointEquals ( 150 , 0 , c1 . pointAt ( 1.5 ) ) ; } 
public void testLength ( ) { assertLength ( 0 , 0 ) ; assertLength ( 100 , 200 ) ; } 
private void assertLength ( double x , double y ) { Contour c = new Contour ( ) ; c . addPoint ( x , y ) ; c . addPoint ( x + SIDE , y ) ; c . addPoint ( x + SIDE , y + SIDE ) ; c . addPoint ( x , y + SIDE ) ; assertEquals ( SIDE * 3 , c . getLength ( ) ) ; c . close ( ) ; assertEquals ( SIDE * 4 , c . getLength ( ) ) ; } 
public void testCacheInvalidation ( ) { Contour c = new Contour ( ) ; c . addPoint ( 0 , 0 ) ; c . addPoint ( 50 , 0 ) ; assertEquals ( 50.0 , c . getLength ( ) ) ; Add a point c.addPoint(100, 0); Check the length again. assertEquals(100.0, c.getLength()); } 
private void assertRectPoints ( IGeometry g , double x , double y , double width , double height ) { assertEquals ( 4 , g . getPointCount ( ) ) ; List < Point > points = g . getPoints ( ) ; assertPointEquals ( x , y , points . get ( 0 ) ) ; assertPointEquals ( x + width , y , points . get ( 1 ) ) ; assertPointEquals ( x + width , y + height , points . get ( 2 ) ) ; assertPointEquals ( x , y + height , points . get ( 3 ) ) ; } 
public void testTranslatePointsOfGroup ( ) { Path p1 = new Path ( ) ; Path p2 = new Path ( ) ; p1 . rect ( 10 , 20 , 30 , 40 ) ; p2 . rect ( 40 , 20 , 30 , 40 ) ; Geometry g = new Geometry ( ) ; g . add ( p1 ) ; g . add ( p2 ) ; assertEquals ( Rect . centeredRect ( ( 40 - 10 ) / 2 + 10 , 20 , 60 , 40 ) , g . getBounds ( ) ) ; Transform = Transform . translated ( 5 , 7 ) ; Geometry g2 = . map ( g ) ; assertEquals ( Rect . centeredRect ( 30 , 27 , 60 , 40 ) , g2 . getBounds ( ) ) ; } 
public void testMakePoints ( ) { Create a continuous line from 0,0 to 100,0. The line is composed of one path from 0-50 and another path with two contours, from 50-75 and 75-100. Path p1 = new Path(); p1.line(0, 0, 50, 0); Path p2 = new Path(); p2.line(50, 0, 75, 0); p2.line(75, 0, 100, 0); Geometry g = new Geometry(); g.add(p1); g.add(p2); assertEquals(100.0, g.getLength()); Point[] points = g.makePoints(5); assertPointEquals(0, 0, points[0]); assertPointEquals(25, 0, points[1]); assertPointEquals(50, 0, points[2]); assertPointEquals(75, 0, points[3]); assertPointEquals(100, 0, points[4]); Achieve the same result using resampleByAmount. Geometry resampledGeometry = g.resampleByAmount(5, false); List<Point> resampledPoints = resampledGeometry.getPoints(); assertPointEquals(0, 0, resampledPoints.get(0)); assertPointEquals(25, 0, resampledPoints.get(1)); assertPointEquals(50, 0, resampledPoints.get(2)); assertPointEquals(75, 0, resampledPoints.get(3)); assertPointEquals(100, 0, resampledPoints.get(4)); } 
public void testCacheInvalidation ( ) { Geometry g = new Geometry ( ) ; assertEquals ( 0.0 , g . getLength ( ) ) ; Path p1 = new Path ( ) ; p1 . line ( 0 , 0 , 50 , 0 ) ; g . add ( p1 ) ; assertEquals ( 50.0 , g . getLength ( ) ) ; Change the Path after it was added to the Geometry. p1.line(50, 0, 75, 0); This change is not detected by the Geometry, and thus the length is not updated. assertEquals(50.0, g.getLength()); Manually invalidate the group. g.invalidate(); This time, the length is correct. assertEquals(75.0, g.getLength()); } 
public void testLength ( ) { Geometry g = new Geometry ( ) ; Path p1 = new Path ( ) ; p1 . line ( 0 , 0 , 100 , 0 ) ; Path p2 = new Path ( ) ; p2 . line ( 0 , 100 , 100 , 100 ) ; g . add ( p1 ) ; g . add ( p2 ) ; assertEquals ( 200.0 , g . getLength ( ) ) ; } 
public void testSize ( ) { CanvasContext ctx = new CanvasContext ( ) ; ctx . size ( 200 , 300 ) ; assertEquals ( 200.0 , ctx . getWIDTH ( ) ) ; assertEquals ( 300.0 , ctx . getHeight ( ) ) ; assertEquals ( 200.0 , ctx . getCanvas ( ) . getWidth ( ) ) ; assertEquals ( 300.0 , ctx . getCanvas ( ) . getHeight ( ) ) ; } 
private void assertNextPoint ( Iterator < Point > points , double x , double y ) { assertTrue ( points . hasNext ( ) ) ; assertEquals ( new Point ( x , y ) , points . next ( ) ) ; } 
protected void addRect ( IGeometry g , float x , float y , float width , float height ) { g . addPoint ( x , y ) ; g . addPoint ( x + width , y ) ; g . addPoint ( x + width , y + height ) ; g . addPoint ( x , y + height ) ; } 
public static void assertPointEquals ( double x , double y , Point actual ) { assertEquals ( x , actual . x , 0.001 ) ; assertEquals ( y , actual . y , 0.001 ) ; } 
public static void addRect ( IGeometry g , double x , double y , double width , double height ) { g . addPoint ( x , y ) ; g . addPoint ( x + width , y ) ; g . addPoint ( x + width , y + height ) ; g . addPoint ( x , y + height ) ; } 
public void testLength ( ) { testLength ( 0 , 0 ) ; testLength ( 200 , 300 ) ; Path p = new Path ( ) ; p . line ( 0 , 0 , 50 , 0 ) ; p . line ( 50 , 0 , 100 , 0 ) ; assertEquals ( 100.0 , p . getLength ( ) ) ; } 
public void testLengthMultipleContours ( ) { Path p = new Path ( ) ; p . line ( 0 , 0 , 100 , 0 ) ; assertEquals ( 100.0 , p . getLength ( ) ) ; p . line ( 0 , 100 , 100 , 100 ) ; assertEquals ( 200.0 , p . getLength ( ) ) ; p . close ( ) ; assertEquals ( 300.0 , p . getLength ( ) ) ; } 
public void testPointAt ( ) { Path p = new Path ( ) ; p . line ( 0 , 0 , 50 , 0 ) ; p . line ( 50 , 0 , 100 , 0 ) ; assertPointEquals ( 0 , 0 , p . pointAt ( 0 ) ) ; assertPointEquals ( 10 , 0 , p . pointAt ( 0.1 ) ) ; assertPointEquals ( 25 , 0 , p . pointAt ( 0.25 ) ) ; assertPointEquals ( 40 , 0 , p . pointAt ( 0.4 ) ) ; assertPointEquals ( 50 , 0 , p . pointAt ( 0.5 ) ) ; assertPointEquals ( 75 , 0 , p . pointAt ( 0.75 ) ) ; assertPointEquals ( 80 , 0 , p . pointAt ( 0.8 ) ) ; assertPointEquals ( 100 , 0 , p . pointAt ( 1 ) ) ; } 
public void testPointAtMultipleContours ( ) { Create two contours that look like a single line. Path p = new Path(); p.addPoint(0, 0); p.addPoint(50, 0); p.newContour(); p.addPoint(50, 0); p.addPoint(100, 0); assertEquals(2, p.getContours().size()); assertEquals(4, p.getPointCount()); assertEquals(100.0, p.getLength()); assertPointEquals(0, 0, p.pointAt(0)); assertPointEquals(25, 0, p.pointAt(0.25)); assertPointEquals(50, 0, p.pointAt(0.5)); assertPointEquals(100, 0, p.pointAt(1.0)); } 
public void testContour ( ) { final double SIDE = 50 ; Point [ ] points ; Path p = new Path ( ) ; addRect ( p , 0 , 0 , SIDE , SIDE ) ; assertEquals ( SIDE * 3 , p . getLength ( ) ) ; points = p . makePoints ( 7 ) ; assertPointEquals ( 0 , 0 , points [ 0 ] ) ; assertPointEquals ( SIDE / 2 , 0 , points [ 1 ] ) ; assertPointEquals ( SIDE , 0 , points [ 2 ] ) ; assertPointEquals ( 0 , SIDE , points [ 6 ] ) ; Closing the contour will increase the length of the path and thus will also have an effect on point positions. p.close(); assertEquals(SIDE * 4, p.getLength()); points = p.makePoints(8); assertEquals(new Point(0, 0), points[0]); assertPointEquals(SIDE / 2, 0, points[1]); assertPointEquals(SIDE, 0, points[2]); assertPointEquals(0, SIDE, points[6]); assertPointEquals(0, SIDE / 2, points[7]); } 
public void testCacheInvalidation ( ) { Path p = new Path ( ) ; assertEquals ( 0.0 , p . getLength ( ) ) ; p . line ( 0 , 0 , 50 , 0 ) ; assertEquals ( 50.0 , p . getLength ( ) ) ; Contour c = new Contour ( ) ; c . addPoint ( 50 , 0 ) ; c . addPoint ( 75 , 0 ) ; p . add ( c ) ; assertEquals ( 75.0 , p . getLength ( ) ) ; Add a point to the contour. c.addPoint(100, 0); This change is not detected by the Path, and thus the length is not updated. assertEquals(75.0, p.getLength()); Manually invalidate the path. p.invalidate(); This time, the length is correct. assertEquals(100.0, p.getLength()); } 
public void testMap ( ) { Point pt = new Point ( 22 , 33 ) ; assertEquals ( 22.0 , pt . get ( " x " ) ) ; assertEquals ( 33.0 , pt . get ( " y " ) ) ; assertEquals ( 1 , pt . get ( " type " ) ) ; } 
public void setUp ( ) throws Exception { Create a temporary folder tempDirectory = File.createTempFile("localhistory", ""); assertTrue(tempDirectory.delete()); assertTrue(tempDirectory.mkdir()); localHistoryDirectory = new File(tempDirectory, "_history"); manager = new LocalHistoryManager(localHistoryDirectory); testDirectory = new File(tempDirectory, "testproject"); assertTrue(testDirectory.mkdir()); } 
public void tearDown ( ) throws Exception { FileUtils . deleteDirectory ( tempDirectory ) ; } 
public void testHashObject ( ) { Repository r = manager . createRepository ( testDirectory ) ; String fileName = " greeting " ; String contents = " Hello, world! " ; createProjectFile ( fileName , contents ) ; assertEquals ( " 943a702d06f34599aee1f8da8ef9f7296031d699 " , r . hashObject ( " greeting " ) ) ; } 
public void testAddFile ( ) { Repository r = manager . createRepository ( testDirectory ) ; Assert this repository is empty: no objects, and the head commit returns None. assertEquals(0, r.getObjectCount()); assertEquals(null, r.getHead()); String fileName = "greeting"; String contents = "Hello, world!"; createProjectFile(fileName, contents); String id = r.hashObject(fileName); String commitId1 = r.commit("Adding files to the project."); Assert that the contents are stored in the repository. assertEquals(contents, new String(r.readObject(id))); Assert the head commit now refers to the newly created commit. assertEquals(commitId1, r.getHead().getId()); Since this is the first commit, it will not have a parent. assertEquals(null, r.getHead().getParentId()); Once committed, there will be three objects in the database: the file, the tree, and the commit. assertEquals(3, r.getObjectCount()); String commitId2 = r.commit("My second commit with the same files."); assertNotSame(commitId1, commitId2); Since no files/folders were changed, only one new object is created in the database: the second commit. assertEquals(4, r.getObjectCount()); Assert the head commit now refers to the newly created commit. assertEquals(commitId2, r.getHead().getId()); Assert the parent commit refers to our previous commit. assertEquals(commitId1, r.getHead().getParentId()); } 
private void createProjectFile ( String fileName , String contents ) { File projectFile = new File ( testDirectory , fileName ) ; FileUtils . writeFile ( projectFile , contents ) ; } 
public void setUp ( ) throws Exception { context = new NodeContext ( testLibrary ) ; } 
public void testBasicConnection ( ) { Node = net ; assertFalse ( . isConnected ( " number42 " ) ) ; assertFalse ( . isConnected ( " add " ) ) ; = . connect ( " number42 " , " add " , " v1 " ) ; assertTrue ( . isConnected ( " number42 " ) ) ; assertTrue ( . isConnected ( " add " ) ) ; = . connect ( " number5 " , " add " , " v2 " ) ; assertTrue ( . isConnected ( " number5 " ) ) ; } 
public void testReplaceConnection ( ) { Node = net ; = . connect ( " number42 " , " add " , " v1 " ) ; assertTrue ( . isConnected ( " number42 " ) ) ; = . connect ( " number5 " , " add " , " v1 " ) ; assertFalse ( . isConnected ( " number42 " ) ) ; } 
public void testExecute ( ) { Node = net . connect ( " number42 " , " add " , " v1 " ) . connect ( " number5 " , " add " , " v2 " ) ; context . renderNetwork ( ) ; assertResultsEqual ( context . getResults ( addNode ) , 47.0 ) ; } 
public void testCycles ( ) { Create an infinite loop. Node n = net .connect("number42", "add", "v1") .connect("add", "number42", "number"); Infinite loops are allowed: each node is only executed once. context.renderNetwork(n); assertResultsEqual(context.getResults(addNode), 42.0); } 
public void setUp ( ) throws Exception { context = new NodeContext ( testLibrary ) ; SideEffects . reset ( ) ; } 
public void testSingleOutput ( ) { context . renderNode ( valuesToPointNode ) ; Map < Node , Iterable < ? > > resultsMap = context . getResultsMap ( ) ; assertEquals ( 1 , resultsMap . size ( ) ) ; Iterable < ? > results = context . getResults ( valuesToPointNode ) ; List resultsList = ImmutableList . copyOf ( results ) ; assertEquals ( 1 , resultsList . size ( ) ) ; assertResultsEqual ( resultsList , Point . ZERO ) ; } 
public void testSameOutputPort ( ) { Node invert1 = invertNode . extend ( ) . withName ( " invert1 " ) . withInputValue ( " value " , 1.0 ) ; Node invert2 = invertNode . extend ( ) . withName ( " invert2 " ) . withInputValue ( " value " , 10.0 ) ; assertResultsEqual ( context . renderNode ( invert1 ) , - 1.0 ) ; assertResultsEqual ( context . renderNode ( invert2 ) , - 10.0 ) ; } 
public void testListAwareProcessing ( ) { Node makeNumbers1 = makeNumbersNode . extend ( ) . withInputValue ( " string " , " 1 2 3 4 " ) ; assertResultsEqual ( context . renderNode ( makeNumbers1 ) , 1.0 , 2.0 , 3.0 , 4.0 ) ; } 
public void testListUnawareProcessing ( ) { Node invert1 = invertNode . extend ( ) . withName ( " invert1 " ) . withInputValue ( " value " , 42.0 ) ; assertResultsEqual ( context . renderNode ( invert1 ) , - 42.0 ) ; } 
public void testConnectedListProcessing ( ) { Node makeNumbers1 = makeNumbersNode . extend ( ) . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 4 " ) ; Node invert1 = invertNode . extend ( ) . withName ( " invert1 " ) ; Node net = Node . ROOT . withChildAdded ( makeNumbers1 ) . withChildAdded ( invert1 ) . connect ( " makeNumbers1 " , " invert1 " , " value " ) . withRenderedChildName ( " invert1 " ) ; assertResultsEqual ( context . renderChild ( net , invert1 ) , - 1.0 , - 2.0 , - 3.0 , - 4.0 ) ; } 
public void testEmptyListProcessing ( ) { Node noNumbers = makeNumbersNode . extend ( ) . withName ( " noNumbers " ) . withInputValue ( " string " , " " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node net = Node . ROOT . withChildAdded ( noNumbers ) . withChildAdded ( add1 ) . connect ( " noNumbers " , " add1 " , " v1 " ) ; context . renderChild ( net , add1 ) ; assertResultsEqual ( context . renderChild ( net , add1 ) ) ; } 
public void testInputSideEffect ( ) { Node getNumberNode = Node . ROOT . withFunction ( " side-effects/getNumber " ) ; SideEffects . theInput = 42 ; assertResultsEqual ( context . renderNode ( getNumberNode ) , 42L ) ; } 
public void testOutputSideEffect ( ) { Node setNumberNode = Node . ROOT . withFunction ( " side-effects/setNumber " ) . withInputAdded ( Port . intPort ( " number " , 42 ) ) ; context . renderNode ( setNumberNode ) ; assertEquals ( SideEffects . theOutput , 42L ) ; } 
public void testSamePrototypeTwice ( ) { Node invert1Node = invertNode . withName ( " invert1 " ) . withInputValue ( " value " , 42.0 ) ; Node invert2Node = invertNode . withName ( " invert2 " ) ; Node net = Node . ROOT . withChildAdded ( invert1Node ) . withChildAdded ( invert2Node ) . connect ( " invert1 " , " invert2 " , " value " ) ; assertResultsEqual ( context . renderChild ( net , invert2Node ) , 42.0 ) ; } 
public void testExecuteAmount ( ) { Node makeNumbers1 = makeNumbersNode . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 " ) ; Node incNode = Node . ROOT . withName ( " inc " ) . withFunction ( " side-effects/increaseAndCount " ) . withInputAdded ( Port . floatPort ( " number " , 0 ) ) ; Node net = Node . ROOT . withChildAdded ( makeNumbers1 ) . withChildAdded ( incNode ) . connect ( " makeNumbers1 " , " inc " , " number " ) ; context . renderChild ( net , incNode ) ; assertEquals ( 3 , SideEffects . theCounter ) ; Iterable < ? > results = context . getResults ( incNode ) ; assertResultsEqual ( results , 2.0 , 3.0 , 4.0 ) ; } 
public void testListWithValue ( ) { Node makeNumbers1 = makeNumbersNode . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) . withInputValue ( " v2 " , 100.0 ) ; Node net = Node . ROOT . withChildAdded ( makeNumbers1 ) . withChildAdded ( add1 ) . connect ( " makeNumbers1 " , " add1 " , " v1 " ) ; assertResultsEqual ( context . renderChild ( net , add1 ) , 101.0 , 102.0 , 103.0 ) ; } 
public void testLongestList ( ) { Node net = Node . ROOT . withChildAdded ( threeNumbers ) . withChildAdded ( fiveNumbers ) . withChildAdded ( addNode ) . connect ( " threeNumbers " , addNode . getName ( ) , " v1 " ) . connect ( " fiveNumbers " , addNode . getName ( ) , " v2 " ) ; assertResultsEqual ( context . renderChild ( net , addNode ) , 101.0 , 202.0 , 303.0 , 401.0 , 502.0 ) ; } 
public void testPortRangeMatching ( ) { Node sum = Node . ROOT . withName ( " sum " ) . withFunction ( " math/sum " ) . withInputAdded ( Port . floatPort ( " numbers " , 0 ) ) . withInputRange ( " numbers " , Port . Range . LIST ) ; Node net = Node . ROOT . withChildAdded ( sum ) . withChildAdded ( threeNumbers ) . connect ( " threeNumbers " , sum . getName ( ) , " numbers " ) ; assertResultsEqual ( context . renderChild ( net , sum ) , 6.0 ) ; } 
public void testListWithNulls ( ) { Node makeNull = Node . ROOT . withName ( " makeNull " ) . withFunction ( " test/makeNull " ) . withInputAdded ( Port . floatPort ( " value " , 0.0 ) ) ; Node net = Node . ROOT . withChildAdded ( threeNumbers ) . withChildAdded ( makeNull ) . connect ( " threeNumbers " , " makeNull " , " value " ) ; assertResultsEqual ( net , makeNull ) ; } 
public void testNestedLists ( ) { Node makeStrings = makeStringsNode . extend ( ) . withInputValue ( " string " , " 1,2;3,4;5,6 " ) ; Node makeNumbers = makeNumbersNode . extend ( ) . withName ( " makeNumbers " ) . withInputValue ( " separator " , " , " ) ; Node net = Node . ROOT . withChildAdded ( makeStrings ) . withChildAdded ( makeNumbers ) . withRenderedChildName ( " makeNumbers " ) . connect ( " makeStrings " , " makeNumbers " , " string " ) ; assertResultsEqual ( context . renderNode ( net ) , ImmutableList . of ( 1.0 , 2.0 ) , ImmutableList . of ( 3.0 , 4.0 ) , ImmutableList . of ( 5.0 , 6.0 ) ) ; } 
public void testNestedListsLevel0 ( ) { Node net = createNestedNetwork ( " 3,4 " , " 2,3,4 " ) ; assertResultsEqual ( context . renderNode ( net ) , 22.0 , 29.0 , 34.0 ) ; } 
public void testNestedListsLevel1 ( ) { Node net = createNestedNetwork ( " 3,4;1,8 " , " 2,3,4 " ) ; assertResultsEqual ( context . renderNode ( net ) , ImmutableList . of ( 22.0 , 29.0 , 34.0 ) , ImmutableList . of ( 20.0 , 33.0 , 32.0 ) ) ; } 
public void testNestedListsLevel2 ( ) { Node net = createNestedNetwork ( " 3,4;1,8 " , " 1,2;2,3,4 " ) ; assertResultsEqual ( context . renderNode ( net ) , ImmutableList . of ( 
public void testFrame ( ) { Node frame = Node . ROOT . withName ( " frame " ) . withFunction ( " core/frame " ) . withInputAdded ( Port . customPort ( " context " , " context " ) ) ; assertResultsEqual ( frame , 1.0 ) ; } 
private Node createNestedNetwork ( String makeStrings1Value , String makeStrings2Value ) { Node makeStrings1 = makeStringsNode . extend ( ) . withName ( " makeStrings1 " ) . withInputValue ( " string " , makeStrings1Value ) ; Node makeStrings2 = makeStringsNode . extend ( ) . withName ( " makeStrings2 " ) . withInputValue ( " string " , makeStrings2Value ) ; Node makeNumbers1 = makeNumbersNode . extend ( ) . withName ( " makeNumbers1 " ) . withInputValue ( " separator " , " , " ) ; Node makeNumbers2 = makeNumbersNode . extend ( ) . withName ( " makeNumbers2 " ) . withInputValue ( " separator " , " , " ) ; Node calculate = calculateMultipleNode . extend ( ) . withInputValue ( " v2 " , 6.0 ) . withInputValue ( " v4 " , 7.0 ) ; Node net = Node . ROOT . withChildAdded ( makeStrings1 ) . withChildAdded ( makeStrings2 ) . withChildAdded ( makeNumbers1 ) . withChildAdded ( makeNumbers2 ) . withChildAdded ( calculate ) . withRenderedChildName ( " calculateMultiple " ) . connect ( " makeStrings1 " , " makeNumbers1 " , " string " ) . connect ( " makeStrings2 " , " makeNumbers2 " , " string " ) . connect ( " makeNumbers1 " , " calculateMultiple " , " v1 " ) . connect ( " makeNumbers2 " , " calculateMultiple " , " v3 " ) ; return net ; } 
public void setUp ( ) throws Exception { controller = NodeLibraryController . create ( ) ; 
public void testChangeRenderedNode ( ) throws Exception { Node alpha = Node . ROOT . withName ( " alpha " ) ; Node beta = Node . ROOT . withName ( " beta " ) ; controller . addNode ( " / " , alpha ) ; controller . addNode ( " / " , beta ) ; assertNull ( controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChild ( ) ) ; controller . setRenderedChild ( " / " , " alpha " ) ; assertEquals ( alpha , controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChild ( ) ) ; controller . setRenderedChild ( " / " , " beta " ) ; assertEquals ( beta , controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChild ( ) ) ; controller . setRenderedChild ( " / " , " " ) ; assertNull ( controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChild ( ) ) ; } 
public void testAddNode ( ) { NodeLibrary library ; Node parent = Node . ROOT . withName ( " parent " ) ; controller . addNode ( " / " , parent ) ; library = controller . getNodeLibrary ( ) ; assertTrue ( library . getRoot ( ) . hasChild ( " parent " ) ) ; assertSame ( parent , library . getRoot ( ) . getChild ( " parent " ) ) ; assertSame ( parent , library . getNodeForPath ( " /parent " ) ) ; Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " /parent " , child ) ; library = controller . getNodeLibrary ( ) ; assertTrue ( library . getRoot ( ) . getChild ( " parent " ) . hasChild ( " child " ) ) ; assertSame ( child , library . getNodeForPath ( " /parent/child " ) ) ; assertNotSame ( " No longer the same since the new parent has an extra child. " , parent , library . getNodeForPath ( " /parent " ) ) ; } 
public void testAddNodeUniqueName ( ) { Node gamma = Node . ROOT . withName ( " gamma " ) ; controller . addNode ( " / " , gamma ) ; assertTrue ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " gamma " ) ) ; controller . addNode ( " / " , gamma ) ; assertTrue ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " gamma1 " ) ) ; } 
public void testPasteNodes ( ) { createTestNetwork ( ) ; Now paste them controller.pasteNodes("/", ImmutableList.of(controller.getNode("/alpha"), controller.getNode("/beta"))); Node root = controller.getNodeLibrary().getRoot(); assertTrue(root.hasChild("alpha1")); assertTrue(root.hasChild("beta1")); assertTrue(root.isConnected("alpha1")); assertTrue(root.isConnected("beta1")); } 
public void testPasteOutputNode ( ) { createTestNetwork ( ) ; Now paste them controller.pasteNodes("/", ImmutableList.of(controller.getNode("/alpha"))); Node root = controller.getNodeLibrary().getRoot(); assertTrue(root.hasChild("alpha1")); assertTrue(root.isConnected("alpha")); assertTrue(root.isConnected("beta")); assertFalse(root.isConnected("alpha1")); } 
public void testPasteInputNode ( ) { createTestNetwork ( ) ; Now paste them controller.pasteNodes("/", ImmutableList.of(controller.getNode("/beta"))); Node root = controller.getNodeLibrary().getRoot(); assertTrue(root.hasChild("beta1")); assertTrue(root.isConnected("alpha")); assertTrue(root.isConnected("beta")); assertTrue(root.isConnected("beta1")); } 
private void createTestNetwork ( ) { Node alpha = Node . ROOT . withName ( " alpha " ) ; Node beta = Node . ROOT . withName ( " beta " ) . withInputAdded ( Port . floatPort ( " number " , 0.0 ) ) ; controller . addNode ( " / " , alpha ) ; controller . addNode ( " / " , beta ) ; controller . connect ( " / " , alpha , beta , beta . getInput ( " number " ) ) ; Node root = controller . getNodeLibrary ( ) . getRoot ( ) ; assertTrue ( root . isConnected ( " alpha " ) ) ; assertTrue ( root . isConnected ( " beta " ) ) ; } 
public void testCreateNode ( ) { Node proto = Node . ROOT . withName ( " protoNode " ) ; controller . createNode ( " / " , proto ) ; assertTrue ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " protoNode1 " ) ) ; assertSame ( proto , controller . getNodeLibrary ( ) . getNodeForPath ( " /protoNode1 " ) . getPrototype ( ) ) ; } 
public void testRemoveNode ( ) { Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " / " , child ) ; assertTrue ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " child " ) ) ; controller . removeNode ( " / " , " child " ) ; assertFalse ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " child " ) ) ; assertNull ( controller . getNodeLibrary ( ) . getNodeForPath ( " /child " ) ) ; } 
public void testSetPortValue ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withInputAdded ( Port . intPort ( " value " , 10 ) ) ; controller . addNode ( " / " , numberNode ) ; assertEquals ( 10 , controller . getNode ( " /number " ) . getInput ( " value " ) . intValue ( ) ) ; controller . setPortValue ( " /number " , " value " , 42 ) ; assertEquals ( 42 , controller . getNode ( " /number " ) . getInput ( " value " ) . intValue ( ) ) ; } 
public void testUniqueNodeName ( ) { Node proto = Node . ROOT . withName ( " protoNode " ) ; controller . createNode ( " / " , proto ) ; controller . createNode ( " / " , proto ) ; controller . createNode ( " / " , proto ) ; Node rootNode = controller . getNodeLibrary ( ) . getRoot ( ) ; assertFalse ( rootNode . hasChild ( " protoNode " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode1 " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode2 " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode3 " ) ) ; controller . removeNode ( " / " , " protoNode2 " ) ; rootNode = controller . getNodeLibrary ( ) . getRoot ( ) ; assertFalse ( rootNode . hasChild ( " protoNode2 " ) ) ; controller . createNode ( " / " , proto ) ; rootNode = controller . getNodeLibrary ( ) . getRoot ( ) ; assertTrue ( rootNode . hasChild ( " protoNode2 " ) ) ; assertFalse ( rootNode . hasChild ( " protoNode4 " ) ) ; } 
public void testSimpleRename ( ) { Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " / " , child ) ; controller . renameNode ( " / " , " /child " , " " ) ; assertFalse ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " child " ) ) ; assertTrue ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " " ) ) ; } 
public void testSimpleConnection ( ) { assertEquals ( 0 , controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . size ( ) ) ; createSimpleConnection ( ) ; assertEquals ( 1 , controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . size ( ) ) ; Connection c = controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . get ( 0 ) ; assertEquals ( " negate " , c . getInputNode ( ) ) ; assertEquals ( " value " , c . getInputPort ( ) ) ; assertEquals ( " number " , c . getOutputNode ( ) ) ; assertResultsEqual ( controller . getNodeLibrary ( ) . getRoot ( ) , controller . getNode ( " /negate " ) , - 20.0 ) ; } 
public void testSimpleDisconnect ( ) { createSimpleConnection ( ) ; Connection c = controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . get ( 0 ) ; controller . disconnect ( " / " , c ) ; assertEquals ( 0 , controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . size ( ) ) ; } 
public void testRemoveNodeWithConnections ( ) { createSimpleConnection ( ) ; Node invert2Node = Node . ROOT . withName ( " invert2 " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , invert2Node ) ; controller . connect ( " / " , controller . getNode ( " /number " ) , invert2Node , invert2Node . getInput ( " value " ) ) ; assertEquals ( 2 , controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . size ( ) ) ; controller . removeNode ( " / " , " number " ) ; assertEquals ( 0 , controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . size ( ) ) ; } 
public void testRemoveNodeWithRendered ( ) { Node alpha = Node . ROOT . withName ( " alpha " ) ; controller . addNode ( " / " , alpha ) ; controller . setRenderedChild ( " / " , " alpha " ) ; Node beta = Node . ROOT . withName ( " beta " ) ; controller . addNode ( " / " , beta ) ; assertEquals ( " alpha " , controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChildName ( ) ) ; controller . removeNode ( " / " , " beta " ) ; assertEquals ( " alpha " , controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChildName ( ) ) ; controller . removeNode ( " / " , " alpha " ) ; assertEquals ( " " , controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChildName ( ) ) ; assertNull ( controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChild ( ) ) ; } 
private void createSimpleConnection ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 20 ) ) ; Node invertNode = Node . ROOT . withName ( " negate " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , numberNode ) ; controller . addNode ( " / " , invertNode ) ; controller . connect ( " / " , numberNode , invertNode , invertNode . getInput ( " value " ) ) ; } 
public void testNodeForPath ( ) { assertEquals ( root , library . getNodeForPath ( " / " ) ) ; assertEquals ( parent , library . getNodeForPath ( " /parent " ) ) ; assertEquals ( child1 , library . getNodeForPath ( " /parent/child1 " ) ) ; assertEquals ( child2 , library . getNodeForPath ( " /parent/child2 " ) ) ; assertNull ( " Invalid names return null. " , library . getNodeForPath ( " /foo " ) ) ; assertNull ( " Invalid nested names return null. " , library . getNodeForPath ( " /parent/foo " ) ) ; } 
public void testRelativePath ( ) { library . getNodeForPath ( " parent " ) ; } 
public void testSimpleReadWrite ( ) { NodeLibrary simple = NodeLibrary . create ( " test " , Node . ROOT . extend ( ) , FunctionRepository . of ( ) ) ; assertReadWriteEquals ( simple , NodeRepository . of ( ) ) ; } 
public void testNestedReadWrite ( ) { assertReadWriteEquals ( library , NodeRepository . of ( ) ) ; } 
public void testDoNotWriteRootPrototype ( ) { Node myNode = Node . ROOT . withName ( " myNode " ) ; NodeLibrary library = libraryWithChildren ( " test " , myNode ) ; Because myNode uses the _root prototype, it shouldn't write the prototype attribute. assertFalse(library.toXml().contains("prototype")); } 
public void testPrototypeInSameLibrary ( ) { You can refer to a prototype in the same library as the current node. Node invert = Node.ROOT .withName("negate") .withFunction("math/negate") .withInputAdded(Port.floatPort("number", 0)); Node invert1 = invert.extend().withName("invert1").withInputValue("number", 42.0); Node root = Node.ROOT .withName("root") .withChildAdded(invert) .withChildAdded(invert1) .withRenderedChild(invert1); NodeLibrary originalLibrary = NodeLibrary.create("test", root, FunctionRepository.of(MathFunctions.LIBRARY)); Assert the original library returns the correct result. NodeContext context = new NodeContext(originalLibrary); assertResultsEqual(context.renderNode(root), -42.0); Persist / load the library and assert it still returns the correct result. NodeLibrary restoredLibrary = NodeLibrary.load("test", originalLibrary.toXml(), NodeRepository.of()); assertResultsEqual(context.renderNode(restoredLibrary.getRoot()), -42.0); } 
public void testRenderedNode ( ) { Node child1 = Node . ROOT . withName ( " child1 " ) ; Node originalRoot = Node . ROOT . withChildAdded ( child1 ) . withRenderedChild ( child1 ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , originalRoot , FunctionRepository . of ( ) ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; assertEquals ( " child1 " , library . getRoot ( ) . getRenderedChildName ( ) ) ; assertNotNull ( library . getRoot ( ) . getRenderedChild ( ) ) ; } 
public void testPortSerialization ( ) { assertPortSerialization ( Port . intPort ( " int " , 42 ) ) ; assertPortSerialization ( Port . floatPort ( " float " , 33.3 ) ) ; assertPortSerialization ( Port . stringPort ( " string " , " hello " ) ) ; assertPortSerialization ( Port . colorPort ( " color " , Color . BLACK ) ) ; assertPortSerialization ( Port . pointPort ( " point " , new Point ( 11 , 22 ) ) ) ; assertPortSerialization ( Port . customPort ( " geometry " , " nodebox.graphics.Geometry " ) ) ; } 
public void testLink ( ) { Node originalAdd = Node . ROOT . withName ( " add " ) . withFunction ( " math/add " ) . withInputAdded ( Port . floatPort ( " v1 " , 11 ) ) . withInputAdded ( Port . floatPort ( " v2 " , 22 ) ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , originalAdd , FunctionRepository . of ( MathFunctions . LIBRARY ) ) ; assertSingleResult ( 33.0 , originalAdd , originalLibrary . getFunctionRepository ( ) ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; assertTrue ( library . getFunctionRepository ( ) . hasLibrary ( " math " ) ) ; Node add = library . getRoot ( ) ; assertEquals ( " add " , add . getName ( ) ) ; assertEquals ( " math/add " , add . getFunction ( ) ) ; assertSingleResult ( 33.0 , add , library . getFunctionRepository ( ) ) ; } 
public void testRelativeImport ( ) { File relativeImportFile = new File ( " test/files/relative-import.ndbx " ) ; NodeLibrary originalLibrary = NodeLibrary . load ( relativeImportFile , NodeRepository . of ( ) ) ; FunctionRepository repository = originalLibrary . getFunctionRepository ( ) ; assertTrue ( repository . hasLibrary ( " relative " ) ) ; assertTrue ( repository . hasFunction ( " relative/concat " ) ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; FunctionLibrary relativeLibrary = library . getFunctionRepository ( ) . getLibrary ( " relative " ) ; assertEquals ( " python:test/files/relative.py " , relativeLibrary . getLink ( new File ( userDir , " test.ndbx " ) ) ) ; assertEquals ( " python:relative.py " , relativeLibrary . getLink ( relativeImportFile ) ) ; } 
public void testPortRangePersistence ( ) { Default check. Node makeNumbers = Node.ROOT .withName("makeNumbers") .withFunction("math/makeNumbers") .withOutputRange(Port.Range.LIST) .withInputAdded(Port.stringPort("s", "1 2 3 4 5")) .withInputAdded(Port.stringPort("sep", " ")); Node reverse = Node.ROOT .withName("reverse") .withFunction("list/reverse") .withInputAdded(Port.customPort("list", "list")) .withInputRange("list", Port.Range.LIST) .withOutputRange(Port.Range.LIST); Node net = Node.ROOT .withChildAdded(makeNumbers) .withChildAdded(reverse) .withRenderedChild(reverse) .connect("makeNumbers", "reverse", "list"); NodeLibrary originalLibrary = NodeLibrary.create("test", net, functions); assertResultsEqual(originalLibrary.getRoot(), 5.0, 4.0, 3.0, 2.0, 1.0); Now save / load the library and check the output. NodeLibrary library = NodeLibrary.load("test", originalLibrary.toXml(), NodeRepository.of()); assertResultsEqual(library.getRoot(), 5.0, 4.0, 3.0, 2.0, 1.0); } 
public void testPrototypeOverridePersistence ( ) { NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; Node rangePrototype = mathLibrary . getRoot ( ) . getChild ( " range " ) ; Node range1 = rangePrototype . extend ( ) . withName ( " range1 " ) . withInputValue ( " end " , 5.0 ) ; assertResultsEqual ( range1 , 0.0 , 1.0 , 2.0 , 3.0 , 4.0 ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , range1 , NodeRepository . of ( mathLibrary ) , functions ) ; Now save / load the library and check the output. NodeLibrary library = NodeLibrary.load("test", originalLibrary.toXml(), NodeRepository.of(mathLibrary)); assertResultsEqual(library.getRoot(), 0.0, 1.0, 2.0, 3.0, 4.0); } 
public void testMinMaxPersistence ( ) { Node originalRoot = Node . ROOT . withName ( " root " ) . withInputAdded ( Port . floatPort ( " v " , 5.0 , 0.0 , 10.0 ) ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , originalRoot ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Port v = library . getRoot ( ) . getInput ( " v " ) ; assertEquals ( 0.0 , v . getMinimumValue ( ) ) ; assertEquals ( 10.0 , v . getMaximumValue ( ) ) ; } 
public void testLocale ( ) { Locale savedLocale = Locale . getDefault ( ) ; The german locale uses a comma to separate the decimals, which could make points fail. Locale.setDefault(Locale.GERMAN); try { We use points for the position and for the input port. 
public void testReadMenus ( ) { NodeLibrary menuLibrary = NodeLibrary . load ( new File ( " test/files/menus.ndbx " ) , NodeRepository . of ( ) ) ; Port thePort = menuLibrary . getRoot ( ) . getInput ( " thePort " ) ; assertTrue ( thePort . hasMenu ( ) ) ; assertEquals ( 2 , thePort . getMenuItems ( ) . size ( ) ) ; assertEquals ( new MenuItem ( " a " , " Alpha " ) , thePort . getMenuItems ( ) . get ( 0 ) ) ; assertEquals ( new MenuItem ( " b " , " Beta " ) , thePort . getMenuItems ( ) . get ( 1 ) ) ; } 
public void testMenuSerialization ( ) { Node originalRoot = makeLetterMenuNode ( ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , originalRoot ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Port letterPort = library . getRoot ( ) . getInput ( " letter " ) ; assertTrue ( letterPort . hasMenu ( ) ) ; assertEquals ( 2 , letterPort . getMenuItems ( ) . size ( ) ) ; assertEquals ( new MenuItem ( " a " , " Alpha " ) , letterPort . getMenuItems ( ) . get ( 0 ) ) ; assertEquals ( new MenuItem ( " b " , " Beta " ) , letterPort . getMenuItems ( ) . get ( 1 ) ) ; } 
public void testMenuPrototypeSerialization ( ) { Node letterPrototype = makeLetterMenuNode ( ) ; Node letterNode = letterPrototype . extend ( ) . withName ( " my_letter " ) . withInputValue ( " letter " , " b " ) ; Node originalRoot = Node . ROOT . withChildAdded ( letterPrototype ) . withChildAdded ( letterNode ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , originalRoot ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Port letterPort = library . getRoot ( ) . getChild ( " my_letter " ) . getInput ( " letter " ) ; assertTrue ( letterPort . hasMenu ( ) ) ; assertEquals ( 2 , letterPort . getMenuItems ( ) . size ( ) ) ; assertEquals ( " b " , letterPort . getValue ( ) ) ; } 
public void testWidgetSerialization ( ) { Node originalNode = Node . ROOT . withInputAdded ( Port . stringPort ( " file " , " " ) . withWidget ( Port . Widget . FILE ) ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , originalNode ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Port filePort = library . getRoot ( ) . getInput ( " file " ) ; assertEquals ( Port . Widget . FILE , filePort . getWidget ( ) ) ; } 
public void testRelativePathsInWidgets ( ) { NodeLibrary library = NodeLibrary . load ( new File ( " test/files/relative-file.ndbx " ) , NodeRepository . of ( ) ) ; NodeContext context = new NodeContext ( library ) ; Iterable < ? > results = context . renderNode ( library . getRoot ( ) ) ; Object firstResult = results . iterator ( ) . next ( ) ; assertEquals ( true , firstResult ) ; } 
public Node makeLetterMenuNode ( ) { MenuItem alpha = new MenuItem ( " a " , " Alpha " ) ; MenuItem beta = new MenuItem ( " b " , " Beta " ) ; return Node . ROOT . withName ( " letter " ) . withInputAdded ( Port . stringPort ( " letter " , " a " , ImmutableList . of ( alpha , beta ) ) ) ; 
private void assertPointEquals ( Point point , double x , double y ) { assertEquals ( x , point . getX ( ) ) ; assertEquals ( y , point . getY ( ) ) ; } 
private void assertSingleResult ( Double expected , Node node , FunctionRepository functionRepository ) { NodeLibrary testLibrary = NodeLibrary . create ( " test " , Node . ROOT , functionRepository ) ; NodeContext context = new NodeContext ( testLibrary ) ; List < Object > values = ImmutableList . copyOf ( context . renderNode ( node ) ) ; assertEquals ( 1 , values . size ( ) ) ; assertEquals ( expected , values . get ( 0 ) ) ; } 
private void assertPortSerialization ( Port originalPort ) { Node originalNode ; originalNode = Node . ROOT . withInputAdded ( originalPort ) ; NodeLibrary originalLibrary = libraryWithChildren ( " test " , originalNode ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Node node = library . getRoot ( ) . getChild ( " node " ) ; assertNotNull ( node ) ; Port port ; port = node . getInput ( originalPort . getName ( ) ) ; assertEquals ( originalPort . getName ( ) , port . getName ( ) ) ; assertEquals ( originalPort . getType ( ) , port . getType ( ) ) ; assertEquals ( originalPort . getValue ( ) , port . getValue ( ) ) ; } 
private NodeLibrary libraryWithChildren ( String libraryName , Node . . . children ) { Node root = Node . ROOT . withName ( " root " ) ; for ( Node child : children ) { root = root . withChildAdded ( child ) ; } return NodeLibrary . create ( libraryName , root , FunctionRepository . of ( ) ) ; } 
private void assertReadWriteEquals ( NodeLibrary library , NodeRepository nodeRepository ) { String xml = library . toXml ( ) ; assertEquals ( library , NodeLibrary . load ( library . getName ( ) , xml , nodeRepository ) ) ; } 
public void testPath ( ) { assertEquals ( " /child " , Node . path ( " / " , Node . ROOT . withName ( " child " ) ) ) ; assertEquals ( " /parent/child " , Node . path ( " /parent " , Node . ROOT . withName ( " child " ) ) ) ; } 
public void testRelativePath ( ) { Node . path ( " " , Node . ROOT . withName ( " child " ) ) ; } 
public void testRootName ( ) { assertEquals ( " _root " , Node . ROOT . getName ( ) ) ; The moment we extend from root, the name changes. assertEquals("node", Node.ROOT.withFunction("test").getName()); Trying to change the name back to _root fails. assertEquals("node", Node.ROOT.withName("_root").getName()); } 
public void testChangeFunction ( ) { Node test = Node . ROOT . extend ( ) . withFunction ( " test/test " ) ; assertEquals ( " test/test " , test . getFunction ( ) ) ; } 
public void testPrototype ( ) { Node alpha = Node . ROOT . withName ( " alpha " ) ; assertSame ( " Using withXXX on the root sets the root automatically on the prototype. " , alpha . getPrototype ( ) , Node . ROOT ) ; Node beta = alpha . withName ( " beta " ) ; assertSame ( " Using withXXX methods doesn't automatically change the prototype. " , beta . getPrototype ( ) , Node . ROOT ) ; Node gamma = alpha . extend ( ) . withName ( " gamma " ) ; assertSame ( " Use extend() to change the prototype. " , gamma . getPrototype ( ) , alpha ) ; 
public void testNodeNaming ( ) { Node = Node . ROOT ; assertInvalidName ( , " 1234 " , " names cannot start with a digit. " ) ; assertInvalidName ( , " __reserved " , " names cannot start with double underscores " ) ; assertInvalidName ( , " what! " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " $-#34 " , " Only lowercase, numbers and underscore are allowed " ) ; assertInvalidName ( , " " , " names cannot be empty " ) ; assertInvalidName ( , " very_very_very_very_very_very_long_name " , " names cannot be longer than 30 characters " ) ; assertValidName ( , " radius " ) ; assertValidName ( , " _test " ) ; assertValidName ( , " _ " ) ; assertValidName ( , " _1234 " ) ; assertValidName ( , " a1234 " ) ; assertValidName ( , " node1 " ) ; assertValidName ( , " UPPERCASE " ) ; assertValidName ( , " uPpercase " ) ; } 
public void testPortOrder ( ) { Port pAlpha = Port . intPort ( " alpha " , 1 ) ; Port pBeta = Port . intPort ( " beta " , 2 ) ; Node original = Node . ROOT . withInputAdded ( pAlpha ) . withInputAdded ( pBeta ) ; ImmutableList < String > orderedPortNames = ImmutableList . of ( " alpha " , " beta " ) ; assertEquals ( orderedPortNames , portNames ( original ) ) ; Node alphaChanged = original . withInputValue ( " alpha " , 11L ) ; assertEquals ( orderedPortNames , portNames ( alphaChanged ) ) ; } 
public void testPorts ( ) { Port pX = Port . floatPort ( " x " , 0 ) ; Port pY = Port . floatPort ( " y " , 0 ) ; Node rectNode1 = Node . ROOT . withName ( " rect1 " ) . withInputAdded ( pX ) ; assertNull ( getNodePort ( Node . ROOT , " x " ) ) ; assertSame ( pX , getNodePort ( rectNode1 , " x " ) ) ; Node rectNode2 = newNodeWithPortAdded ( rectNode1 . withName ( " rect2 " ) , pY ) ; assertSame ( pX , getNodePort ( rectNode2 , " x " ) ) ; assertSame ( pY , getNodePort ( rectNode2 , " y " ) ) ; assertNull ( getNodePort ( rectNode1 , " y " ) ) ; assertNodePortsSizeEquals ( 0 , Node . ROOT ) ; assertNodePortsSizeEquals ( 1 , rectNode1 ) ; assertNodePortsSizeEquals ( 2 , rectNode2 ) ; Node rectNode3 = newNodeWithPortRemoved ( rectNode2 . withName ( " rect3 " ) , " x " ) ; assertNodePortsSizeEquals ( 2 , rectNode2 ) ; assertNodePortsSizeEquals ( 1 , rectNode3 ) ; assertNull ( getNodePort ( rectNode3 , " x " ) ) ; assertSame ( pY , getNodePort ( rectNode3 , " y " ) ) ; } 
private Node newNodeWithPortAdded ( Node node , Port port ) { return node . withInputAdded ( port ) ; } 
private Node newNodeWithPortRemoved ( Node node , String portName ) { return node . withInputRemoved ( portName ) ; } 
private void assertNodePortsSizeEquals ( int expected , Node node ) { assertEquals ( expected , node . getInputs ( ) . size ( ) ) ; } 
private void assertInvalidName ( Node , String newName , String reason ) { try { . withName ( newName ) ; 
private void assertValidName ( Node , String newName ) { try { Node newNode = . withName ( newName ) ; 
public void testParsedPort ( ) { assertEquals ( 42 , Port . parsedPort ( " myInt " , " int " , " 42 " ) . intValue ( ) ) ; assertEquals ( 33.3 , Port . parsedPort ( " myInt " , " float " , " 33.3 " ) . floatValue ( ) ) ; assertEquals ( " hello " , Port . parsedPort ( " myInt " , " string " , " hello " ) . stringValue ( ) ) ; assertEquals ( true , Port . parsedPort ( " myBoolean " , " boolean " , " true " ) . booleanValue ( ) ) ; } 
public void testParseBooleanPort ( ) { assertEquals ( true , Port . parsedPort ( " myBoolean " , " boolean " , " true " ) . booleanValue ( ) ) ; assertEquals ( false , Port . parsedPort ( " myBoolean " , " boolean " , " false " ) . booleanValue ( ) ) ; assertEquals ( false , Port . parsedPort ( " myBoolean " , " boolean " , " xxx " ) . booleanValue ( ) ) ; } 
public void testParsedPortNullValue ( ) { assertEquals ( 0 , Port . parsedPort ( " myInt " , " int " , null ) . intValue ( ) ) ; assertEquals ( 0.0 , Port . parsedPort ( " myInt " , " float " , null ) . floatValue ( ) ) ; assertEquals ( " " , Port . parsedPort ( " myInt " , " string " , null ) . stringValue ( ) ) ; } 
public void testFloatBounding ( ) { Port p1 = Port . floatPort ( " p " , 5.0 , 0.0 , 10.0 ) ; Port p2 = p1 . withValue ( - 10.0 ) ; assertEquals ( 0.0 , p2 . getValue ( ) ) ; } 
public void testFloatMin ( ) { Port p1 = Port . floatPort ( " p " , 5.0 , 0.0 , null ) ; Port p2 = p1 . withValue ( 9999.0 ) ; assertEquals ( 9999.0 , p2 . getValue ( ) ) ; Port p3 = p1 . withValue ( - 10.0 ) ; assertEquals ( 0.0 , p3 . getValue ( ) ) ; } 
public void testIntBounding ( ) { Port p1 = Port . intPort ( " p " , 5 , 0 , 10 ) ; Port p2 = p1 . withValue ( - 10 ) ; assertEquals ( 0 L , p2 . getValue ( ) ) ; } 
public static void assertResultsEqual ( Iterable < ? > result , Object . . . args ) { assertEquals ( ImmutableList . copyOf ( args ) , ImmutableList . copyOf ( result ) ) ; } 
public static void assertResultsEqual ( Node network , Node child , Object . . . args ) { NodeContext context = new NodeContext ( testLibrary ) ; Iterable < ? > values = context . renderChild ( network , child ) ; assertResultsEqual ( values , args ) ; } 
public static void assertResultsEqual ( Node node , Object . . . args ) { NodeContext context = new NodeContext ( testLibrary ) ; Iterable < ? > values = context . renderNode ( node ) ; assertResultsEqual ( values , args ) ; } 
public void testGetRelativePaths ( ) { String sep = " / " ; assertEquals ( " stuff " + sep + " xyz.dat " , FileUtils . getRelativePath ( new File ( " /var/data/stuff/xyz.dat " ) , new File ( " /var/data/ " ) ) ) ; assertEquals ( " .. " + sep + " .. " + sep + " b " + sep + " c " , FileUtils . getRelativePath ( new File ( " /a/b/c " ) , new File ( " /a/x/y/ " ) ) ) ; assertEquals ( " .. " + sep + " .. " + sep + " b " + sep + " c " , FileUtils . getRelativePath ( new File ( " /m/n/o/a/b/c " ) , new File ( " /m/n/o/a/x/y/ " ) ) ) ; 
public void testBasic ( ) { final String hello = " HELLO " ; InfiniteList < String > list = InfiniteList . of ( hello ) ; assertEquals ( list . get ( 0 ) , hello ) ; assertEquals ( list . get ( 2 ) , hello ) ; assertEquals ( list . get ( 8888 ) , hello ) ; } 
public void testListClass ( ) { assertSame ( Integer . class , listClass ( Lists . newArrayList ( 1 , 2 ) ) ) ; assertSame ( String . class , listClass ( ImmutableList . of ( " a " , " b " ) ) ) ; assertSame ( Number . class , listClass ( Lists . newArrayList ( 1 , 2.0 ) ) ) ; assertSame ( Object . class , listClass ( ImmutableList . of ( ) ) ) ; assertSame ( Object . class , listClass ( Lists . newArrayList ( 1 , null , 2 ) ) ) ; assertSame ( Object . class , listClass ( Lists . newArrayList ( null , null , 1 ) ) ) ; assertSame ( nodebox . graphics . Path . class , listClass ( Lists . newArrayList ( new nodebox . graphics . Path ( ) , new nodebox . graphics . Path ( ) ) ) ) ; assertSame ( nodebox . graphics . Geometry . class , listClass ( Lists . newArrayList ( new nodebox . graphics . Geometry ( ) , new nodebox . graphics . Geometry ( ) ) ) ) ; assertSame ( nodebox . graphics . AbstractGeometry . class , listClass ( Lists . newArrayList ( new nodebox . graphics . Path ( ) , new nodebox . graphics . Geometry ( ) ) ) ) ; assertSame ( Object . class , listClass ( Lists . newArrayList ( new nodebox . graphics . Geometry ( ) , null , new nodebox . graphics . Path ( ) ) ) ) ; } 
public static void reset ( ) { theInput = 0 ; theOutput = 0 ; theCounter = 0 ; } 
public static double increaseAndCount ( double ) { theCounter + + ; return + 1 ; } 
private static String readFileAsString ( File f ) throws java . io . IOException { StringBuilder fileData = new StringBuilder ( 1000 ) ; BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; char [ ] buf = new char [ 1024 ] ; int numRead ; while ( ( numRead = reader . read ( buf ) ) ! = - 1 ) { String readData = String . valueOf ( buf , 0 , numRead ) ; fileData . append ( readData ) ; buf = new char [ 1024 ] ; } reader . close ( ) ; return fileData . toString ( ) ; } 
public void setUp ( ) throws Exception { server = new MockAppcastServer ( MockHost . APPCAST_SERVER_PORT ) ; serverThread = new Thread ( server ) ; serverThread . start ( ) ; } 
public void tearDown ( ) throws Exception { server . stop ( ) ; serverThread . join ( ) ; } 
public abstract String getLink ( File baseFile ) ; public abstract Function getFunction ( String name ) ; public abstract boolean hasFunction ( String name ) ; public void reload ( ) { } Object overrides @Override public int hashCode() { return Objects.hashCode(getNamespace()); } @Override public boolean equals(Object o) { if (!(o instanceof FunctionLibrary)) return false; final FunctionLibrary other = (FunctionLibrary) o; return Objects.equal(getNamespace(), other.getNamespace()); } @Override public String toString() { return String.format("<FunctionLibrary %s>", getNamespace()); }} 
public abstract Function getFunction ( String name ) ; public abstract boolean hasFunction ( String name ) ; public void reload ( ) { } Object overrides @Override public int hashCode() { return Objects.hashCode(getNamespace()); } @Override public boolean equals(Object o) { if (!(o instanceof FunctionLibrary)) return false; final FunctionLibrary other = (FunctionLibrary) o; return Objects.equal(getNamespace(), other.getNamespace()); } @Override public String toString() { return String.format("<FunctionLibrary %s>", getNamespace()); }} 
public abstract boolean hasFunction ( String name ) ; public void reload ( ) { } Object overrides @Override public int hashCode() { return Objects.hashCode(getNamespace()); } @Override public boolean equals(Object o) { if (!(o instanceof FunctionLibrary)) return false; final FunctionLibrary other = (FunctionLibrary) o; return Objects.equal(getNamespace(), other.getNamespace()); } @Override public String toString() { return String.format("<FunctionLibrary %s>", getNamespace()); }} 
public void reload ( ) { } Object overrides @Override public int hashCode() { return Objects.hashCode(getNamespace()); } @Override public boolean equals(Object o) { if (!(o instanceof FunctionLibrary)) return false; final FunctionLibrary other = (FunctionLibrary) o; return Objects.equal(getNamespace(), other.getNamespace()); } @Override public String toString() { return String.format("<FunctionLibrary %s>", getNamespace()); }} 
public void reload ( ) { controller . reloadFunctionRepository ( ) ; requestRender ( ) ; editorPane.reload(); 
public void reload ( ) { PythonInterpreter interpreter = new PythonInterpreter ( ) ; try { interpreter . execfile ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { throw new LoadException ( file . getName ( ) , e ) ; } catch ( PyException e ) { throw new LoadException ( file . getName ( ) , e ) ; } PyStringMap map = ( PyStringMap ) interpreter . getLocals ( ) ; ImmutableMap . Builder < String , Function > builder = ImmutableMap . builder ( ) ; for ( Object key : map . keys ( ) ) { Object o = map . get ( Py . java2py ( key ) ) ; if ( o instanceof PyFunction ) { String name = ( String ) key ; Function f = new PythonFunction ( name , ( PyFunction ) o ) ; builder . put ( name , f ) ; } } this . functionMap = builder . build ( ) ; } 
public void reload ( ) { Object returnValue ; try { returnValue = Compiler . loadFile ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { throw new LoadException ( file . getName ( ) , e ) ; } We need a Var as the last statement, because we need to retrieve the current namespace. if (!(returnValue instanceof Var)) { throw new LoadException(file.getName(), String.format("The last statement does not define a var, but %s." + "Make sure the last line of your script looks like this:" + "(def nodes [{:name \"foo\" :fn inc}])", returnValue)); } Var nodesVar = (Var) returnValue; Object functionMap = nodesVar.deref(); checkStructure(functionMap); ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder(); for (Object item : (Iterable) functionMap) { Map m = (Map) item; String name = (String) m.get(NAME); IFn fn = (IFn) m.get(FN); Function f = new ClojureFunction(name, fn); builder.put(name, f); } this.functionMap = builder.build(); } 
public static ClojureLibrary loadScript ( File baseFile , String fileName ) throws LoadException { File file = null ; try { if ( baseFile ! = null ) { file = new File ( baseFile . getCanonicalPath ( ) + File . separator + fileName ) ; } else { file = new File ( fileName ) ; } } catch ( IOException e ) { throw new LoadException ( fileName , e ) ; } return loadScript ( file ) ; } 
private static ClojureLibrary loadScript ( File file ) { Object returnValue ; try { returnValue = Compiler . loadFile ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { throw new LoadException ( file . getName ( ) , e ) ; } We need a Var as the last statement, because we need to retrieve the current namespace. if (!(returnValue instanceof Var)) { throw new LoadException(file.getName(), String.format("The last statement does not define a var, but %s." + "Make sure the last line of your script looks like this:" + "(def nodes [{:name \"foo\" :fn inc}])", returnValue)); } Var nodesVar = (Var) returnValue; Namespace ns = nodesVar.ns; String namespace = ns.name.getName(); Object functionMap = nodesVar.deref(); checkStructure(functionMap); ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder(); for (Object item : (Iterable) functionMap) { Map m = (Map) item; String name = (String) m.get(NAME); IFn fn = (IFn) m.get(FN); Function f = new ClojureFunction(name, fn); builder.put(name, f); } return new ClojureLibrary(namespace, file, builder.build()); } 
public void reload ( ) { ClojureLibrary reloadedLibrary = loadScript ( file ) ; if ( ! reloadedLibrary . namespace . equals ( namespace ) ) throw new RuntimeException ( " The namespace of a function library should not be changed. " ) ; this . functionMap = reloadedLibrary . functionMap ; } 
public static PythonLibrary loadScript ( String namespace , File baseFile , String fileName ) throws LoadException { try { File file ; 
private static ImmutableMap < String , Function > loadScript ( File file ) { PythonInterpreter interpreter = new PythonInterpreter ( ) ; try { interpreter . execfile ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { throw new LoadException ( file . getName ( ) , e ) ; } catch ( PyException e ) { throw new LoadException ( file . getName ( ) , e ) ; } PyStringMap map = ( PyStringMap ) interpreter . getLocals ( ) ; ImmutableMap . Builder < String , Function > builder = ImmutableMap . builder ( ) ; for ( Object key : map . keys ( ) ) { Object o = map . get ( Py . java2py ( key ) ) ; if ( o instanceof PyFunction ) { String name = ( String ) key ; Function f = new PythonFunction ( name , ( PyFunction ) o ) ; builder . put ( name , f ) ; } } return builder . build ( ) ; } 
public void reload ( ) { this . functionMap = loadScript ( this . file ) ; } 
public void testCombine ( ) { assertElements ( ListFunctions . combine ( ImmutableList . of ( ) , ImmutableList . of ( ) , null ) ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( ) , null ) , 1 ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( 2 ) , null ) , 1 , 2 ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( 2 ) , ImmutableList . of ( 3 ) ) , 1 , 2 , 3 ) ; } 
public static Method findMethod ( Class c , String methodName ) { return findMethod ( c , methodName , true ) ; } 
public static StaticMethodFunction find ( Class c , String methodName ) { Method m = Functions . findMethod ( c , methodName , false ) ; return new StaticMethodFunction ( m ) ; } 
public void testMethodsWithSameName ( ) { String href = " java:nodebox.function.NonUniqueFunctions " ; FunctionLibrary javaLibrary = FunctionLibrary . load ( href ) ; } 
public static int myFunction ( int ignored ) { return 0 ; } 
public static int myFunction ( int ignored1 , int ignored2 ) { return 0 ; } 
private Iterable < ? > convert ( Iterable < ? > outputValues , String inputType ) { if ( level ( outputValues ) = = 0 ) { Class outputType = ListUtils . listClass ( outputValues ) ; 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setColor ( Theme . NETWORK_BACKGROUND_COLOR ) ; g2 . fill ( g . getClipBounds ( ) ) ; paintGrid ( g2 ) ; paintConnections ( g2 ) ; paintNodes ( g2 ) ; } 
private void paintGridCross ( Graphics2D g , int x , int y ) { g . drawLine ( x - 2 , y , x + 2 , y ) ; g . drawLine ( x , y - 2 , x , y + 2 ) ; } 
private void paintConnection ( Graphics2D g , Connection connection ) { Node outputNode = findNodeWithName ( connection . getOutputNode ( ) ) ; Node inputNode = findNodeWithName ( connection . getInputNode ( ) ) ; Rectangle outputRect = nodeRect ( outputNode ) ; Rectangle inputRect = nodeRect ( inputNode ) ; g . drawLine ( outputRect . x + 4 , outputRect . y + outputRect . height , inputRect . x + 4 , inputRect . y ) ; } 
private Node findNodeWithName ( String name ) { return getActiveNetwork ( ) . getChild ( name ) ; } 
private void paintNode ( Graphics2D g , Node node , boolean selected , boolean rendered ) { Rectangle r = nodeRect ( node ) ; if ( selected ) { g . setColor ( Color . WHITE ) ; g . fillRect ( r . x , r . y , NODE_WIDTH , NODE_HEIGHT ) ; g . fillRect ( r . x , r . y + NODE_HEIGHT , 10 , 3 ) ; g . setColor ( NODE_BACKGROUND_COLOR ) ; g . fillRect ( r . x + 2 , r . y + 2 , NODE_WIDTH - 4 , NODE_HEIGHT - 4 ) ; } else { g . setColor ( NODE_BACKGROUND_COLOR ) ; g . fillRect ( r . x , r . y , NODE_WIDTH , NODE_HEIGHT ) ; g . fillRect ( r . x , r . y + NODE_HEIGHT , 10 , 3 ) ; } if ( rendered ) { g . setColor ( Color . WHITE ) ; GeneralPath gp = new GeneralPath ( ) ; gp . moveTo ( r . x + NODE_WIDTH - 2 , r . y + NODE_HEIGHT - 20 ) ; gp . lineTo ( r . x + NODE_WIDTH - 2 , r . y + NODE_HEIGHT - 2 ) ; gp . lineTo ( r . x + NODE_WIDTH - 20 , r . y + NODE_HEIGHT - 2 ) ; g . fill ( gp ) ; } g . setColor ( Color . WHITE ) ; g . fillRect ( r . x + 5 , r . y + 5 , NODE_HEIGHT - 10 , NODE_HEIGHT - 10 ) ; g . setColor ( Theme . NETWORK_NODE_NAME_COLOR ) ; g . drawString ( node . getName ( ) , r . x + 40 , r . y + 25 ) ; } 
private Rectangle nodeRect ( Node node ) { return new Rectangle ( nodePoint ( node ) , NODE_DIMENSION ) ; } 
private Point nodePoint ( Node node ) { int nodeX = ( ( int ) node . getPosition ( ) . getX ( ) ) * GRID_CELL_SIZE ; int nodeY = ( ( int ) node . getPosition ( ) . getY ( ) ) * GRID_CELL_SIZE ; return new Point ( nodeX , nodeY ) ; } 
private void resetViewTransform ( ) { viewTransform = new AffineTransform ( ) ; repaint ( ) ; } 
private ImmutableMap < String , nodebox . graphics . Point > selectedNodePositions ( ) { ImmutableMap . Builder < String , nodebox . graphics . Point > b = ImmutableMap . builder ( ) ; for ( String nodeName : selectedNodes ) { b . put ( nodeName , findNodeWithName ( nodeName ) . getPosition ( ) ) ; } return b . build ( ) ; } 
public boolean isRendered ( Node node ) { return getActiveNetwork ( ) . getRenderedChild ( ) = = node ; } 
public boolean isSelected ( Node node ) { return ( selectedNodes . contains ( node . getName ( ) ) ) ; } 
public void select ( Node node ) { selectedNodes . add ( node . getName ( ) ) ; } 
public void singleSelect ( Node node ) { selectedNodes . clear ( ) ; if ( node ! = null ) { selectedNodes . add ( node . getName ( ) ) ; 
public void toggleSelection ( Node node ) { checkNotNull ( node ) ; if ( selectedNodes . isEmpty ( ) ) { singleSelect ( node ) ; 
public void deselectAll ( ) { if ( selectedNodes . isEmpty ( ) ) return ; selectedNodes . clear ( ) ; firePropertyChange ( SELECT_PROPERTY , null , selectedNodes ) ; document . setActiveNode ( ( Node ) null ) ; } 
public void codeChanged ( Node node , boolean changed ) { repaint ( ) ; } 
private void goDown ( ) { JOptionPane . showMessageDialog ( this , " Child nodes are not supported yet. " ) ; if (selectedNodes.size() != 1) { 
public void actionPerformed ( ActionEvent e ) { resetViewTransform ( ) ; } 
private static NodeLibrary createNewLibrary ( ) { NodeRepository nodeRepository = Application . getInstance ( ) . getSystemRepository ( ) ; Node root = Node . ROOT . withName ( " root " ) ; Node rectPrototype = nodeRepository . getNode ( " corevector.rect " ) ; String name = root . uniqueName ( rectPrototype . getName ( ) ) ; Node rect1 = rectPrototype . extend ( ) . withName ( name ) . withPosition ( new nodebox . graphics . Point ( 1 , 1 ) ) ; Node translatePrototype = nodeRepository . getNode ( " corevector.translate " ) ; String translateName = root . uniqueName ( translatePrototype . getName ( ) ) ; Node translate1 = translatePrototype . extend ( ) . withName ( translateName ) . withPosition ( new nodebox . graphics . Point ( 1 , 2 ) ) ; root = root . withChildAdded ( rect1 ) . withChildAdded ( translate1 ) . connect ( " rect1 " , " translate1 " , " shape " ) . withRenderedChild ( translate1 ) ; return NodeLibrary . create ( " untitled " , root , nodeRepository , FunctionRepository . of ( ) ) ; } 
public void deleteSelection ( ) { networkView . deleteSelection ( ) ; } 
protected void paint ( PPaintContext ctx ) { Graphics2D g = ctx . getGraphics ( ) ; Shape clip = g . getClip ( ) ; g . clip ( getBounds ( ) ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_ALPHA_INTERPOLATION , RenderingHints . VALUE_ALPHA_INTERPOLATION_QUALITY ) ; Draw the selection/connection border if (selected && networkView.getConnectionTarget() != this) g.drawImage(nodeGlow, 0, 0, null); if (networkView.getConnectionTarget() == this) g.drawImage(nodeConnectionGlow, 0, 0, null); g.drawImage(fullIcon, 0, 0, null); if (codeChanged) g.drawImage(nodeCodeChanged, 0, 0, null); TODO Add support for node errors. if (node.hasError()) g.drawImage(nodeError, 0, 0, null); if (networkView.getActiveNetwork().getRenderedChildName().equals(getNodeName())) g.drawImage(nodeRendered, 0, 0, null); g.drawImage(nodeRim, 0, 0, null); Draw the node name. g.setFont(Theme.SMALL_BOLD_FONT); g.setColor(Theme.NETWORK_NODE_NAME_COLOR); int textWidth = g.getFontMetrics().stringWidth(getNodeName()); int x = (int) ((NODE_FULL_SIZE - textWidth) / 2f); SwingUtils.drawShadowText(g, getNodeName(), x, NODE_FULL_SIZE + 5, Theme.NETWORK_NODE_NAME_SHADOW_COLOR, -1); Reset the clipping. g.setClip(clip); } 
public void mouseDragged ( PInputEvent e ) { if ( isPanningEvent ( e ) ) return ; if ( isDragging ) { checkNotNull ( dragPoint , " dragPoint cannot be null. " ) ; Point2D pt = e . getPosition ( ) ; double dx = pt . getX ( ) - dragPoint . getX ( ) ; double dy = pt . getY ( ) - dragPoint . getY ( ) ; getNetworkView().dragSelection(dx, dy); dragPoint = pt; } else if (networkView.isConnecting()) { Point2D p = e.getPosition(); networkView.dragConnectionPoint(p); } e.setHandled(true); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(viewTransform); Paint all components paintGrid(g2); paintConnections(g2); paintNodes(g2); Restore original transform g2.setTransform(originalTransform); } 
private Point2D inverseViewTransformPoint ( Point p ) { Point2D pt = new Point2D . Double ( p . getX ( ) , p . getY ( ) ) ; try { return viewTransform . inverseTransform ( pt , null ) ; 
private Point2D minPoint ( Point2D a , Point2D b ) { return new Point2D . Double ( a . getX ( ) - b . getX ( ) , a . getY ( ) - b . getY ( ) ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Paint the grid (The grid is not really affected by the view transform) paintGrid(g2); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(viewTransform); paintConnections(g2); paintNodes(g2); Restore original transform g2.setTransform(originalTransform); } 
private void paintNode ( Graphics2D g , Node node , boolean selected , boolean rendered ) { Rectangle r = nodeRect ( node ) ; if ( selected ) { g . setColor ( Color . WHITE ) ; g . fillRect ( r . x , r . y , NODE_WIDTH , NODE_HEIGHT ) ; g . fillRect ( r . x , r . y + NODE_HEIGHT , 10 , 3 ) ; g . setColor ( NODE_BACKGROUND_COLOR ) ; g . fillRect ( r . x + 2 , r . y + 2 , NODE_WIDTH - 4 , NODE_HEIGHT - 4 ) ; } else { g . setColor ( NODE_BACKGROUND_COLOR ) ; g . fillRect ( r . x , r . y , NODE_WIDTH , NODE_HEIGHT ) ; g . fillRect ( r . x , r . y + NODE_HEIGHT , 10 , 3 ) ; } if ( rendered ) { g . setColor ( Color . WHITE ) ; GeneralPath gp = new GeneralPath ( ) ; gp . moveTo ( r . x + NODE_WIDTH - 2 , r . y + NODE_HEIGHT - 20 ) ; gp . lineTo ( r . x + NODE_WIDTH - 2 , r . y + NODE_HEIGHT - 2 ) ; gp . lineTo ( r . x + NODE_WIDTH - 20 , r . y + NODE_HEIGHT - 2 ) ; g . fill ( gp ) ; } g . setColor ( Color . WHITE ) ; g . fillRect ( r . x + 5 , r . y + 5 , NODE_HEIGHT - 10 , NODE_HEIGHT - 10 ) ; g . setColor ( Color . WHITE ) ; g . drawString ( node . getName ( ) , r . x + 30 , r . y + 20 ) ; } 
private Color portTypeColor ( String type ) { Color portColor = PORT_COLORS . get ( type ) ; return portColor = = null ? DEFAULT_PORT_COLOR : portColor ; } 
private int level ( Iterable it ) { if ( it = = null ) return 0 ; Iterator < Object > iterator = it . iterator ( ) ; if ( ! iterator . hasNext ( ) ) return 0 ; Object first = iterator . next ( ) ; We check if the structure implements List rather than Iterable, because we might be interested in certain kind of iterables (for example a Path object). Deconstructing those kind of iterables may not be what we want. if (first instanceof List) { return 1 + level((Iterable) first); } return 0; } 
private static Node parseNode ( XMLStreamReader reader , Node parent , NodeRepository nodeRepository ) throws XMLStreamException { String prototypeId = reader . getAttributeValue ( null , " prototype " ) ; String name = reader . getAttributeValue ( null , " name " ) ; String description = reader . getAttributeValue ( null , " description " ) ; String image = reader . getAttributeValue ( null , " image " ) ; String function = reader . getAttributeValue ( null , " function " ) ; String outputType = reader . getAttributeValue ( null , " outputType " ) ; String outputRange = reader . getAttributeValue ( null , " outputRange " ) ; String position = reader . getAttributeValue ( null , " position " ) ; String renderedChildName = reader . getAttributeValue ( null , " renderedChild " ) ; String handle = reader . getAttributeValue ( null , " handle " ) ; Node prototype = prototypeId = = null ? Node . ROOT : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) { throw new XMLStreamException ( " Prototype " + prototypeId + " could not be found. " , reader . getLocation ( ) ) ; } Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputType ! = null ) node = node . withOutputType ( outputType ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " port " ) ) { String portName = reader . getAttributeValue ( null , " name " ) ; Remove the port if it is already on the prototype. if (node.hasInput(portName)) { node = node.withInputChanged(portName, parsePort(reader, node.getInput(portName))); } else { node = node.withInputAdded(parsePort(reader, null)); } } else if (tagName.equals("node")) { node = node.withChildAdded(parseNode(reader, node, nodeRepository)); } else if (tagName.equals("conn")) { node = node.withConnectionAdded(parseConnection(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("node")) break; } } This has to come at the end, since the child first needs to exist. if (renderedChildName != null) node = node.withRenderedChildName(renderedChildName); return node; } 
public void testOutputTypeSerialization ( ) { Node myRect = Node . ROOT . withName ( " rect " ) . withOutputType ( " geometry " ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , myRect ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; assertEquals ( " geometry " , library . getRoot ( ) . getOutputType ( ) ) ; } 
public static Object parseValue ( String type , String valueString ) { if ( type . equals ( " int " ) ) { return Long . valueOf ( valueString ) ; 
public Port withMinimumValue ( Double minimumValue ) { checkArgument ( type . equals ( Port . TYPE_INT ) | | type . equals ( Port . TYPE_FLOAT ) , " You can only set a minimum value on int or float ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , minimumValue , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withMaximumValue ( Double maximumValue ) { checkArgument ( type . equals ( Port . TYPE_INT ) | | type . equals ( Port . TYPE_FLOAT ) , " You can only set a maximum value on int or float ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getMinimumValue ( ) , maximumValue , getMenuItems ( ) ) ; } 
public void addPort ( Node node , String portName , String portType ) { onChanged ( ) ; document . addPort ( node , portName , portType ) ; } 
public void removePort ( Node node , String portName ) { onChanged ( ) ; document . removePort ( node , portName ) ; } 
public void addPortMenuItem ( String port , String key , String label ) { onChanged ( ) ; document . addPortMenuItem ( port , key , label ) ; } 
public void removePortMenuItem ( String port , MenuItem menuItem ) { onChanged ( ) ; document . removePortMenuItem ( port , menuItem ) ; } 
public void movePortMenuItemDown ( String port , int itemIndex ) { onChanged ( ) ; document . movePortMenuItemDown ( port , itemIndex ) ; } 
public void movePortMenuItemUp ( String port , int itemIndex ) { onChanged ( ) ; document . movePortMenuItemUp ( port , itemIndex ) ; } 
public void updatePortMenuItem ( String port , int itemIndex , String key , String label ) { onChanged ( ) ; document . updatePortMenuItem ( port , itemIndex , key , label ) ; } 
public void actionPerformed ( ActionEvent e ) { removeSelectedPort ( ) ; } 
private void settingsSelected ( ) { editorPanel . removeAll ( ) ; NodeSettingsEditor editor = new NodeSettingsEditor(dialog); editorPanel.add(editor, BorderLayout.CENTER); editorPanel.revalidate(); selectedPort = null; } 
private void portSelected ( Port port ) { editorPanel . removeAll ( ) ; PortAttributesEditor editor = new PortAttributesEditor ( dialog , port . getName ( ) ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; selectedPort = port ; } 
private void addPort ( ) { NewPortDialog d = new NewPortDialog ( ) ; d . setVisible ( true ) ; String portName = d . portName ; if ( portName ! = null ) { dialog . addPort ( getNode ( ) , portName , d . portType ) ; 
private void removeSelectedPort ( ) { if ( selectedPort = = null ) return ; dialog . removePort ( getNode ( ) , selectedPort . getName ( ) ) ; reloadPortList ( ) ; editorPanel . removeAll ( ) ; editorPanel . revalidate ( ) ; editorPanel . repaint ( ) ; selectedPort = null ; } 
public void valueChanged ( ListSelectionEvent e ) { if ( selectedPort = = portList . getSelectedValue ( ) ) return ; selectedPort = ( Port ) portList . getSelectedValue ( ) ; if ( selectedPort = = null ) { removeButton . setEnabled ( false ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { portName = nameField . getText ( ) ; portType = ( String ) box . getSelectedItem ( ) ; dispose ( ) ; } 
public void addPort ( Node node , String portName , String portType ) { checkArgument ( getActiveNetwork ( ) . hasChild ( node ) ) ; addEdit ( " Add Port " ) ; controller . addPort ( Node . path ( activeNetworkPath , node ) , portName , portType ) ; portView . updateAll ( ) ; networkView . updateAll ( ) ; } 
public void addPortMenuItem ( String portName , String key , String label ) { addEdit ( " Add Port Menu Item " ) ; controller . addPortMenuItem ( getActiveNodePath ( ) , portName , key , label ) ; portView . updateAll ( ) ; requestRender ( ) ; } 
public void removePortMenuItem ( String portName , MenuItem item ) { addEdit ( " Remove Parameter Menu Item " ) ; controller . removePortMenuItem ( getActiveNodePath ( ) , portName , item ) ; Node = getActiveNode ( ) ; portView . setActiveNode ( = = null ? getActiveNetwork ( ) : ) ; requestRender ( ) ; } 
public void movePortMenuItemDown ( String portName , int itemIndex ) { addEdit ( " Move Port Item Down " ) ; controller . movePortMenuItem ( getActiveNodePath ( ) , portName , itemIndex , false ) ; portView . updateAll ( ) ; } 
public void movePortMenuItemUp ( String portName , int itemIndex ) { addEdit ( " Move Port Item Up " ) ; controller . movePortMenuItem ( getActiveNodePath ( ) , portName , itemIndex , true ) ; portView . updateAll ( ) ; } 
public void updatePortMenuItem ( String portName , int itemIndex , String key , String label ) { addEdit ( " Update Port Menu Item " ) ; controller . updatePortMenuItem ( getActiveNodePath ( ) , portName , itemIndex , key , label ) ; portView . updateAll ( ) ; } 
public void editMetadata ( ) { if ( getActiveNode ( ) = = null ) return ; JDialog editorDialog = new NodeAttributesDialog ( NodeBoxDocument . this ) ; editorDialog . setSize ( 580 , 751 ) ; editorDialog . setLocationRelativeTo ( NodeBoxDocument . this ) ; editorDialog . setVisible ( true ) ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Name nameField = new JFormattedTextField(20); nameField.setEditable(false); addRow("Name", nameField); Label labelField = new JTextField(20); labelField.addActionListener(this); labelField.addFocusListener(this); labelField.setEditable(false); addRow("Label", labelField); Widget widgetBox = new JComboBox(humanizedWidgets); widgetBox.addActionListener(this); addRow("Widget", widgetBox); Value valueField = new JTextField(20); valueField.addActionListener(this); valueField.addFocusListener(this); addRow("Value", valueField); Minimum Value minimumValueCheck = new JCheckBox(); minimumValueCheck.addActionListener(this); minimumValueField = new JTextField(10); minimumValueField.addActionListener(this); minimumValueField.addFocusListener(this); JPanel minimumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); minimumValuePanel.add(minimumValueCheck); minimumValuePanel.add(minimumValueField); addRow("Minimum", minimumValuePanel); Maximum Value maximumValueCheck = new JCheckBox(); maximumValueCheck.addActionListener(this); maximumValueField = new JTextField(10); maximumValueField.addActionListener(this); maximumValueField.addFocusListener(this); JPanel maximumValuePanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 0)); maximumValuePanel.add(maximumValueCheck); maximumValuePanel.add(maximumValueField); addRow("Maximum", maximumValuePanel); Menu Items menuItemsTable = new JTable(new MenuItemsModel()); menuItemsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); menuItemsTable.addMouseListener(new MouseAdapter() { public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) updateMenuItem(); } }); JPanel tablePanel = new JPanel(new BorderLayout(5, 5)); JScrollPane tableScroll = new JScrollPane(menuItemsTable, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); tableScroll.setSize(200, 170); tableScroll.setPreferredSize(new Dimension(200, 170)); tableScroll.setMaximumSize(new Dimension(200, 170)); tableScroll.setMinimumSize(new Dimension(200, 170)); tablePanel.add(tableScroll, BorderLayout.CENTER); JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 5, 5)); addButton = new JButton(new Icons.PlusIcon()); addButton.addActionListener(this); removeButton = new JButton(new Icons.MinusIcon()); removeButton.addActionListener(this); upButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.NORTH)); upButton.addActionListener(this); downButton = new JButton(new Icons.ArrowIcon(Icons.ArrowIcon.SOUTH)); downButton.addActionListener(this); buttonPanel.add(addButton); buttonPanel.add(removeButton); buttonPanel.add(upButton); buttonPanel.add(downButton); tablePanel.add(buttonPanel, BorderLayout.SOUTH); addRow("Menu Items", tablePanel); } 
public void updateValues ( ) { Port port = getPort ( ) ; nameField . setText ( port . getName ( ) ) ; labelField . setText ( port . getLabel ( ) ) ; widgetBox . setSelectedItem ( getHumanizedWidget ( port . getWidget ( ) ) ) ; if ( port . isStandardType ( ) ) valueField . setText ( port . getValue ( ) . toString ( ) ) ; else valueField . setEnabled ( false ) ; Object minimumValue = port . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = port . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
private void moveMenuItemDown ( ) { int index = menuItemsTable . getSelectedRow ( ) ; Return if nothing was selected. if (index == -1) return; java.util.List<MenuItem> items = getPort().getMenuItems(); Return if the last item is selected. if (index >= items.size() - 1) return; nodeAttributesDialog.movePortMenuItemDown(portName, index); TODO: Changing the selection doesn't have any effect on Mac. menuItemsTable.changeSelection(index + 1, 1, false, false); } 
private void moveMenuItemUp ( ) { int index = menuItemsTable . getSelectedRow ( ) ; Return if nothing was selected. if (index == -1) return; Return if the first item is selected. if (index == 0) return; nodeAttributesDialog.movePortMenuItemUp(portName, index); TODO: Changing the selection doesn't have any effect on Mac. menuItemsTable.changeSelection(index - 1, 1, false, false); } 
private void updateMenuItem ( ) { int index = menuItemsTable . getSelectedRow ( ) ; if ( index = = - 1 ) return ; MenuItem item = getPort ( ) . getMenuItems ( ) . get ( index ) ; MenuItemDialog dialog = new MenuItemDialog ( ( Dialog ) SwingUtilities . getRoot ( this ) , item ) ; dialog . setVisible ( true ) ; if ( dialog . isSuccessful ( ) ) { nodeAttributesDialog . updatePortMenuItem ( portName , index , dialog . getKey ( ) , dialog . getLabel ( ) ) ; 
public void addPort ( String nodePath , String portName , String portType ) { Node newNode = getNode ( nodePath ) . withInputAdded ( Port . portForType ( portName , portType ) ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public void addPortMenuItem ( String nodePath , String portName , String key , String label ) { Node node = getNode ( nodePath ) ; Port port = node . getInput ( portName ) ; ImmutableList . Builder < MenuItem > b = ImmutableList . builder ( ) ; b . addAll ( port . getMenuItems ( ) ) ; b . add ( new MenuItem ( key , label ) ) ; Port newPort = port . withMenuItems ( b . build ( ) ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public void movePortMenuItem ( String nodePath , String portName , int index , boolean up ) { Node node = getNode ( nodePath ) ; Port port = node . getInput ( portName ) ; List < MenuItem > menuItems = new ArrayList < MenuItem > ( 0 ) ; menuItems . addAll ( port . getMenuItems ( ) ) ; MenuItem item = menuItems . get ( index ) ; menuItems . remove ( item ) ; if ( up ) menuItems . add ( index - 1 , item ) ; else menuItems . add ( index + 1 , item ) ; Port newPort = port . withMenuItems ( ImmutableList . copyOf ( menuItems ) ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public void updatePortMenuItem ( String nodePath , String portName , int index , String key , String label ) { Node node = getNode ( nodePath ) ; Port port = node . getInput ( portName ) ; List < MenuItem > menuItems = new ArrayList < MenuItem > ( 0 ) ; menuItems . addAll ( port . getMenuItems ( ) ) ; if ( index < 0 | | index > = menuItems . size ( ) ) return ; menuItems . set ( index , new MenuItem ( key , label ) ) ; Port newPort = port . withMenuItems ( ImmutableList . copyOf ( menuItems ) ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public boolean isPanningView ( ) { return isPanningView ; } 
public void mousePressed ( MouseEvent e ) { Point2D pt = inverseViewTransformPoint ( e . getPoint ( ) ) ; Node pressedNode = getNodeAt ( pt ) ; if ( pressedNode ! = null ) { Don't immediately set "isDragging." We wait until we actually drag the first time to do the work. startDragging = true; } if (isPanningView) { When panning the view use the original mouse point, not the one affected by the view transform. 
public void mouseReleased ( MouseEvent e ) { isDraggingNodes = false ; } 
private boolean isPanningEvent ( PInputEvent event ) { return networkView . isPanningView ( ) ; } 
private void initEventHandlers ( ) { setFocusable ( true ) ; This is disabled so we can detect the tab key. setFocusTraversalKeysEnabled(false); addKeyListener(this); addMouseListener(this); addMouseMotionListener(this); } 
private Point pointToGridPoint ( Point e ) { Point2D pt ; try { pt = viewTransform . inverseTransform ( e , null ) ; } catch ( NoninvertibleTransformException e1 ) { pt = e ; } return new Point ( ( int ) Math . floor ( pt . getX ( ) / GRID_CELL_SIZE ) , 
public void deselectAll ( ) { if ( selectedNodes . isEmpty ( ) ) return ; selectedNodes . clear ( ) ; firePropertyChange ( SELECT_PROPERTY , null , selectedNodes ) ; document . setActiveNode ( ( Node ) null ) ; repaint ( ) ; } 
public void deleteSelection ( ) { document . removeNodes ( getSelectedNodes ( ) ) ; else if (networkView.hasSelectedConnection()) 
public void showNodeSelectionDialog ( ) { Point pt = new Point ( ( int ) ( Math . random ( ) * 10 ) , ( int ) ( Math . random ( ) * 10 ) ) ; showNodeSelectionDialog ( pt ) ; } 
public void updateValues ( ) { Port port = getPort ( ) ; nameField . setText ( port . getName ( ) ) ; labelField . setText ( port . getLabel ( ) ) ; typeField . setText ( StringUtils . humanizeConstant ( port . getType ( ) ) ) ; if ( port . isStandardType ( ) ) { widgetBox . setSelectedItem ( getHumanizedWidget ( port . getWidget ( ) ) ) ; valueField . setText ( port . getValue ( ) . toString ( ) ) ; } else valueField . setEnabled ( false ) ; Object minimumValue = port . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = port . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
public String toString ( ) { return StringUtils . humanizeConstant ( range . toString ( ) ) ; } 
public void updateValues ( ) { Port port = getPort ( ) ; nameField . setText ( port . getName ( ) ) ; labelField . setText ( port . getLabel ( ) ) ; typeField . setText ( StringUtils . humanizeConstant ( port . getType ( ) ) ) ; rangeBox . setSelectedItem ( getHumanizedRange ( port . getRange ( ) ) ) ; if ( port . isStandardType ( ) ) { widgetBox . setSelectedItem ( getHumanizedWidget ( port . getWidget ( ) ) ) ; valueField . setText ( port . getValue ( ) . toString ( ) ) ; } else valueField . setEnabled ( false ) ; Object minimumValue = port . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = port . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
public String toString ( ) { return StringUtils . humanizeConstant ( object . toString ( ) ) ; } 
public void addPortMenuItem ( String portName , String key , String label ) { checkValidPort ( portName ) ; addEdit ( " Add Port Menu Item " ) ; controller . addPortMenuItem ( getActiveNodePath ( ) , portName , key , label ) ; portView . updateAll ( ) ; requestRender ( ) ; } 
public void removePortMenuItem ( String portName , MenuItem item ) { checkValidPort ( portName ) ; addEdit ( " Remove Parameter Menu Item " ) ; controller . removePortMenuItem ( getActiveNodePath ( ) , portName , item ) ; Node = getActiveNode ( ) ; portView . setActiveNode ( = = null ? getActiveNetwork ( ) : ) ; requestRender ( ) ; } 
public void movePortMenuItemDown ( String portName , int itemIndex ) { checkValidPort ( portName ) ; addEdit ( " Move Port Item Down " ) ; controller . movePortMenuItem ( getActiveNodePath ( ) , portName , itemIndex , false ) ; portView . updateAll ( ) ; } 
public void movePortMenuItemUp ( String portName , int itemIndex ) { checkValidPort ( portName ) ; addEdit ( " Move Port Item Up " ) ; controller . movePortMenuItem ( getActiveNodePath ( ) , portName , itemIndex , true ) ; portView . updateAll ( ) ; } 
public void updatePortMenuItem ( String portName , int itemIndex , String key , String label ) { checkValidPort ( portName ) ; addEdit ( " Update Port Menu Item " ) ; controller . updatePortMenuItem ( getActiveNodePath ( ) , portName , itemIndex , key , label ) ; portView . updateAll ( ) ; } 
private Port checkValidPort ( String portName ) { checkNotNull ( portName , " Port cannot be null. " ) ; Port port = getActiveNode ( ) . getInput ( portName ) ; checkArgument ( port ! = null , " Port %s does not exist on node %s " , portName , getActiveNode ( ) ) ; return port ; } 
public String toString ( ) { return StringUtils . humanizeConstant ( object . toString ( ) ) ; } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; } 
private Rectangle inputPortRect ( Node node , Port port ) { int portIndex = node . getInputs ( ) . indexOf ( port ) ; Point pt = nodePoint ( node ) ; int portOffset = ( PORT_WIDTH + PORT_SPACING ) * portIndex ; Rectangle portRect = new Rectangle ( pt . x + portOffset , pt . y - PORT_HEIGHT , PORT_WIDTH , PORT_HEIGHT ) ; growHitRectangle ( portRect ) ; return portRect ; } 
private Rectangle outputPortRect ( Node node ) { Point pt = nodePoint ( node ) ; Rectangle portRect = new Rectangle ( pt . x , pt . y + NODE_HEIGHT , PORT_WIDTH , PORT_HEIGHT ) ; growHitRectangle ( portRect ) ; return portRect ; } 
private void growHitRectangle ( Rectangle r ) { r . grow ( 2 , 2 ) ; } 
private boolean isHovering ( Node node ) { return node . getName ( ) . equals ( hoverNodeName ) ; } 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { networkMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; 
public void mouseReleased ( MouseEvent e ) { isDraggingNodes = false ; if ( e . isPopupTrigger ( ) ) { networkMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; 
public void mouseMoved ( MouseEvent e ) { Point2D pt = inverseViewTransformPoint ( e . getPoint ( ) ) ; overOutput = getNodeWithOutputPortAt ( pt ) ; overInput = getInputPortAt ( pt ) ; It is probably very inefficient to repaint the view every time the mouse moves. repaint(); } 
public static NodePort of ( Node node , Port port ) { return new NodePort ( node , port ) ; } 
public static NodePort of ( Node node , String portName ) { return new NodePort ( node , node . getInput ( portName ) ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof NodePort ) ) return false ; final NodePort other = ( NodePort ) o ; return Objects . equal ( node , other . node ) & & Objects . equal ( port , other . port ) ; 
public int hashCode ( ) { return Objects . hashCode ( node , port ) ; } 
private void settingsSelected ( ) { editorPanel . removeAll ( ) ; NodeSettingsEditor editor = new NodeSettingsEditor ( dialog ) ; editorPanel . add ( editor , BorderLayout . CENTER ) ; editorPanel . revalidate ( ) ; selectedPort = null ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Description descriptionField = new JTextField(20); descriptionField.addActionListener(this); descriptionField.addFocusListener(this); addRow("Description", descriptionField); Image imageField = new JTextField(20); imageField.addActionListener(this); imageField.addFocusListener(this); addRow("Image", imageField); Output Type outputTypeField = new JTextField(20); outputTypeField.addActionListener(this); outputTypeField.addFocusListener(this); addRow("Output Type", outputTypeField); Output Range outputRangeBox = new JComboBox(humanizedRanges); outputRangeBox.addActionListener(this); addRow("Output Range", outputRangeBox); } 
public void updateValues ( ) { Node node = getNode ( ) ; descriptionField . setText ( node . getDescription ( ) ) ; imageField . setText ( node . getImage ( ) ) ; outputTypeField . setText ( node . getOutputType ( ) ) ; outputRangeBox . setSelectedItem ( getHumanizedRange ( node . getOutputRange ( ) ) ) ; } 
public void focusGained ( FocusEvent e ) { } public void focusLost ( FocusEvent e ) { } } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Paint the grid (The grid is not really affected by the view transform) paintGrid(g2); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(viewTransform); paintConnections(g2); paintNodes(g2); paintCurrentConnection(g2); Restore original transform g2.setTransform(originalTransform); } 
private void paintConnection ( Graphics2D g , Connection connection ) { Node outputNode = findNodeWithName ( connection . getOutputNode ( ) ) ; Node inputNode = findNodeWithName ( connection . getInputNode ( ) ) ; Port inputPort = inputNode . getInput ( connection . getInputPort ( ) ) ; Rectangle outputRect = nodeRect ( outputNode ) ; Rectangle inputRect = nodeRect ( inputNode ) ; g . drawLine ( outputRect . x + 4 , outputRect . y + outputRect . height , inputRect . x + portOffset ( inputNode , inputPort ) + 4 , inputRect . y ) ; } 
private void paintConnection ( Graphics2D g , Node outputNode , Point2D inputPoint ) { Rectangle outputRect = nodeRect ( outputNode ) ; g . drawLine ( outputRect . x + 4 , outputRect . y + outputRect . height , ( int ) inputPoint . getX ( ) , ( int ) inputPoint . getY ( ) ) ; } 
private void paintCurrentConnection ( Graphics2D g ) { g . setColor ( Theme . CONNECTION_DEFAULT_COLOR ) ; if ( connectionOutput ! = null ) { paintConnection ( g , connectionOutput , connectionPoint ) ; 
private Rectangle inputPortRect ( Node node , Port port ) { Point pt = nodePoint ( node ) ; Rectangle portRect = new Rectangle ( pt . x + portOffset ( node , port ) , pt . y - PORT_HEIGHT , PORT_WIDTH , PORT_HEIGHT ) ; growHitRectangle ( portRect ) ; return portRect ; } 
private int portOffset ( Node node , Port port ) { int portIndex = node . getInputs ( ) . indexOf ( port ) ; return ( PORT_WIDTH + PORT_SPACING ) * portIndex ; } 
public void mouseReleased ( MouseEvent e ) { isDraggingNodes = false ; if ( connectionOutput ! = null & & connectionInput ! = null ) { getDocument ( ) . connect ( connectionOutput , connectionInput . node , connectionInput . port ) ; } connectionOutput = null ; if ( e . isPopupTrigger ( ) ) { networkMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } repaint ( ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Paint the grid (The grid is not really affected by the view transform) paintGrid(g2); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(viewTransform); paintNodes(g2); paintConnections(g2); paintCurrentConnection(g2); Restore original transform g2.setTransform(originalTransform); } 
private void paintConnection ( Graphics2D g , Connection connection ) { Node outputNode = findNodeWithName ( connection . getOutputNode ( ) ) ; Node inputNode = findNodeWithName ( connection . getInputNode ( ) ) ; Port inputPort = inputNode . getInput ( connection . getInputPort ( ) ) ; Rectangle outputRect = nodeRect ( outputNode ) ; Rectangle inputRect = nodeRect ( inputNode ) ; paintConnectionLine ( g , outputRect . x + 4 , outputRect . y + outputRect . height + 4 , inputRect . x + portOffset ( inputNode , inputPort ) + 4 , inputRect . y - 5 ) ; 
private void paintCurrentConnection ( Graphics2D g ) { g . setColor ( Theme . CONNECTION_DEFAULT_COLOR ) ; if ( connectionOutput ! = null ) { Rectangle outputRect = nodeRect ( connectionOutput ) ; 
private void paintConnectionLine ( Graphics2D g , int x0 , int y0 , int x1 , int y1 ) { double dy = Math . abs ( y1 - y0 ) ; if ( dy < GRID_CELL_SIZE ) { g . drawLine ( x0 , y0 , x1 , y1 ) ; 
private static void paintConnectionLine ( Graphics2D g , int x0 , int y0 , int x1 , int y1 ) { double dy = Math . abs ( y1 - y0 ) ; if ( dy < GRID_CELL_SIZE ) { g . drawLine ( x0 , y0 , x1 , y1 ) ; 
private static Color portTypeColor ( String type ) { Color portColor = PORT_COLORS . get ( type ) ; return portColor = = null ? DEFAULT_PORT_COLOR : portColor ; } 
private static Rectangle nodeRect ( Node node ) { return new Rectangle ( nodePoint ( node ) , NODE_DIMENSION ) ; } 
private static Rectangle inputPortRect ( Node node , Port port ) { Point pt = nodePoint ( node ) ; Rectangle portRect = new Rectangle ( pt . x + portOffset ( node , port ) , pt . y - PORT_HEIGHT , PORT_WIDTH , PORT_HEIGHT ) ; growHitRectangle ( portRect ) ; return portRect ; } 
private static Rectangle outputPortRect ( Node node ) { Point pt = nodePoint ( node ) ; Rectangle portRect = new Rectangle ( pt . x , pt . y + NODE_HEIGHT , PORT_WIDTH , PORT_HEIGHT ) ; growHitRectangle ( portRect ) ; return portRect ; } 
private static void growHitRectangle ( Rectangle r ) { r . grow ( 2 , 2 ) ; } 
private static Point nodePoint ( Node node ) { int nodeX = ( ( int ) node . getPosition ( ) . getX ( ) ) * GRID_CELL_SIZE ; int nodeY = ( ( int ) node . getPosition ( ) . getY ( ) ) * GRID_CELL_SIZE ; return new Point ( nodeX , nodeY ) ; } 
private static int portOffset ( Node node , Port port ) { int portIndex = node . getInputs ( ) . indexOf ( port ) ; return ( PORT_WIDTH + PORT_SPACING ) * portIndex ; } 
public void select ( Iterable < Node > nodes ) { selectedNodes . clear ( ) ; for ( Node node : nodes ) { selectedNodes . add ( node . getName ( ) ) ; 
public void deleteSelection ( ) { document . removeNodes ( getSelectedNodes ( ) ) ; } 
public void paste ( ) { addEdit ( " Paste node " ) ; if ( nodeClipboard = = null ) return ; List < Node > newNodes = controller . pasteNodes ( activeNetworkPath , nodeClipboard . nodes ) ; networkView . updateAll ( ) ; setActiveNode ( newNodes . get ( 0 ) ) ; networkView . select ( newNodes ) ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Description descriptionField = new JTextField(20); descriptionField.addActionListener(this); descriptionField.addFocusListener(this); addRow("Description", descriptionField); Image imageField = new JTextField(20); imageField.addActionListener(this); imageField.addFocusListener(this); addRow("Image", imageField); Output Type outputTypeField = new JTextField(20); outputTypeField.addActionListener(this); outputTypeField.addFocusListener(this); addRow("Output Type", outputTypeField); Output Range outputRangeBox = new JComboBox(humanizedRanges); outputRangeBox.addActionListener(this); addRow("Output Range", outputRangeBox); Function functionField = new JTextField(20); functionField.addActionListener(this); functionField.addFocusListener(this); addRow("Function", functionField); Handle Function handleField = new JTextField(20); handleField.addActionListener(this); handleField.addFocusListener(this); addRow("Handle Function", handleField); } 
public void updateValues ( ) { Node node = getNode ( ) ; descriptionField . setText ( node . getDescription ( ) ) ; imageField . setText ( node . getImage ( ) ) ; outputTypeField . setText ( node . getOutputType ( ) ) ; outputRangeBox . setSelectedItem ( getHumanizedRange ( node . getOutputRange ( ) ) ) ; functionField . setText ( node . getFunction ( ) ) ; handleField . setText ( node . getHandle ( ) ) ; } 
public void createNode ( Node prototype , nodebox . graphics . Point pt ) { startEdits ( " Create Node " ) ; Node newNode = controller . createNode ( activeNetworkPath , prototype ) ; String newNodePath = Node . path ( activeNetworkPath , newNode ) ; controller . setNodePosition ( newNodePath , pt ) ; controller . setRenderedChild ( activeNetworkPath , newNode . getName ( ) ) ; setActiveNode ( newNode ) ; stopEdits ( ) ; Node activeNode = getActiveNode ( ) ; networkView . updateNodes ( ) ; networkView . singleSelect ( activeNode ) ; portView . updateAll ( ) ; requestRender ( ) ; } 
public void removeNodes ( Iterable < Node > nodes ) { addEdit ( " Delete Nodes " ) ; for ( Node node : nodes ) { removeNodeImpl ( node ) ; } networkView . updateAll ( ) ; portView . updateAll ( ) ; requestRender ( ) ; } 
public void removePortMenuItem ( String portName , MenuItem item ) { checkValidPort ( portName ) ; addEdit ( " Remove Parameter Menu Item " ) ; controller . removePortMenuItem ( getActiveNodePath ( ) , portName , item ) ; Node = getActiveNode ( ) ; portView . updateAll ( ) ; requestRender ( ) ; } 
public void updateAll ( ) { rebuildInterface ( ) ; validate ( ) ; repaint ( ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Paint the grid (The grid is not really affected by the view transform) paintGrid(g2); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(viewTransform); paintNodes(g2); paintConnections(g2); paintCurrentConnection(g2); paintPortTooltip(g2); Restore original transform g2.setTransform(originalTransform); } 
private void paintPortTooltip ( Graphics2D g ) { if ( overInput ! = null ) { Rectangle r = inputPortRect ( overInput . node , overInput . port ) ; 
private static void paintTooltip ( Graphics2D g , Point2D point , String text ) { FontMetrics fontMetrics = g . getFontMetrics ( ) ; int textWidth = fontMetrics . stringWidth ( text ) ; Rectangle r = new Rectangle ( ( int ) point . getX ( ) , ( int ) point . getY ( ) , textWidth , fontMetrics . getHeight ( ) ) ; r . grow ( 4 , 3 ) ; g . setColor ( TOOLTIP_STROKE_COLOR ) ; g . drawRoundRect ( r . x , r . y , r . width , r . height , 8 , 8 ) ; g . setColor ( TOOLTIP_BACKGROUND_COLOR ) ; g . fillRoundRect ( r . x , r . y , r . width , r . height , 8 , 8 ) ; g . setColor ( TOOLTIP_TEXT_COLOR ) ; g . drawString ( text , ( float ) point . getX ( ) , ( float ) point . getY ( ) + fontMetrics . getAscent ( ) ) ; } 
public void keyPressed ( KeyEvent e ) { int keyCode = e . getKeyCode ( ) ; if ( keyCode = = KeyEvent . VK_SHIFT ) { isShiftPressed = true ; 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Paint the grid (The grid is not really affected by the view transform) paintGrid(g2); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(viewTransform); paintNodes(g2); paintConnections(g2); paintCurrentConnection(g2); paintPortTooltip(g2); paintDragSelection(g2); Restore original transform g2.setTransform(originalTransform); } 
private void paintDragSelection ( Graphics2D g ) { if ( isDragSelecting ) { Rectangle r = dragSelectRect ( ) ; 
private Rectangle dragSelectRect ( ) { int x = ( int ) dragStartPoint . getX ( ) ; int y = ( int ) dragStartPoint . getY ( ) ; int w = ( int ) ( dragCurrentPoint . getX ( ) - dragStartPoint . getX ( ) ) ; int h = ( int ) ( dragCurrentPoint . getY ( ) - dragStartPoint . getY ( ) ) ; return new Rectangle ( x , y , w , h ) ; } 
public void keyPressed ( KeyEvent e ) { int keyCode = e . getKeyCode ( ) ; if ( keyCode = = KeyEvent . VK_SHIFT ) { isShiftPressed = true ; 
public boolean isSpacePressed ( ) { return isSpacePressed ; } 
public void mouseReleased ( MouseEvent e ) { isDraggingNodes = false ; isDragSelecting = false ; if ( connectionOutput ! = null & & connectionInput ! = null ) { getDocument ( ) . connect ( connectionOutput , connectionInput . node , connectionInput . port ) ; } connectionOutput = null ; if ( e . isPopupTrigger ( ) ) { networkMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } repaint ( ) ; } 
private boolean isPanningEvent ( PInputEvent event ) { return networkView . isSpacePressed ( ) ; } 
private static void paintTooltip ( Graphics2D g , Point2D point , String text ) { FontMetrics fontMetrics = g . getFontMetrics ( ) ; int textWidth = fontMetrics . stringWidth ( text ) ; int verticalOffset = 10 ; Rectangle r = new Rectangle ( ( int ) point . getX ( ) , ( int ) point . getY ( ) + verticalOffset , textWidth , fontMetrics . getHeight ( ) ) ; r . grow ( 4 , 3 ) ; g . setColor ( TOOLTIP_STROKE_COLOR ) ; g . drawRoundRect ( r . x , r . y , r . width , r . height , 8 , 8 ) ; g . setColor ( TOOLTIP_BACKGROUND_COLOR ) ; g . fillRoundRect ( r . x , r . y , r . width , r . height , 8 , 8 ) ; g . setColor ( TOOLTIP_TEXT_COLOR ) ; g . drawString ( text , ( float ) point . getX ( ) , ( float ) point . getY ( ) + fontMetrics . getAscent ( ) + verticalOffset ) ; } 
private static void paintTooltip ( Graphics2D g , Point2D point , String text ) { FontMetrics fontMetrics = g . getFontMetrics ( ) ; int textWidth = fontMetrics . stringWidth ( text ) ; int verticalOffset = 10 ; Rectangle r = new Rectangle ( ( int ) point . getX ( ) , ( int ) point . getY ( ) + verticalOffset , textWidth , fontMetrics . getHeight ( ) ) ; r . grow ( 4 , 3 ) ; g . setColor ( TOOLTIP_STROKE_COLOR ) ; g . drawRoundRect ( r . x , r . y , r . width , r . height , 8 , 8 ) ; g . setColor ( TOOLTIP_BACKGROUND_COLOR ) ; g . fillRoundRect ( r . x , r . y , r . width , r . height , 8 , 8 ) ; g . setColor ( TOOLTIP_TEXT_COLOR ) ; g . drawString ( text , ( float ) point . getX ( ) , ( float ) point . getY ( ) + fontMetrics . getAscent ( ) + verticalOffset ) ; } 
private void goUp ( ) { JOptionPane . showMessageDialog ( this , " Child nodes are not supported yet. " ) ; } 
private void goDown ( ) { JOptionPane . showMessageDialog ( this , " Child nodes are not supported yet. " ) ; } 
private int outputLevel ( List < ValueOrList > values ) { int sum = 0 ; int counter = 0 ; for ( ValueOrList v : values ) { sum + = level ( v ) ; counter + = 1 ; } return sum ; } 
public void mouseEntered ( MouseEvent e ) { grabFocus ( ) ; } 
public void testNestedListAsSingleValue ( ) { Node sample1 = createSampleNode ( " sample1 " , 4 , 3.0 , 9.0 ) ; Node sample2 = createSampleNode ( " sample2 " , 4 , 9.0 , 24.0 ) ; Node sample3 = sampleNode . extend ( ) . withName ( " sample3 " ) . withInputValue ( " amount " , 4 ) ; Node net = Node . ROOT . withChildAdded ( sample1 ) . withChildAdded ( sample2 ) . withChildAdded ( sample3 ) . withRenderedChildName ( " sample3 " ) . connect ( " sample1 " , " sample3 " , " start " ) . connect ( " sample2 " , " sample3 " , " end " ) ; assertResultsEqual ( context . renderNode ( net ) , ImmutableList . of ( 3.0 , 5.0 , 7.0 , 9.0 ) , ImmutableList . of ( 5.0 , 8.0 , 11.0 , 14.0 ) , ImmutableList . of ( 7.0 , 11.0 , 15.0 , 19.0 ) , ImmutableList . of ( 9.0 , 14.0 , 19.0 , 24.0 ) ) ; Node sample4 = createSampleNode ( " sample4 " , 2 , 2.0 , 3.0 ) ; Node slice = Node . ROOT . withName ( " slice " ) . withFunction ( " list/slice " ) . withOutputRange ( Port . Range . LIST ) . withInputAdded ( Port . floatPort ( " list " , 0 ) ) . withInputRange ( " list " , Port . Range . LIST ) . withInputAdded ( Port . intPort ( " start_index " , 1 ) ) . withInputAdded ( Port . intPort ( " size " , 2 ) ) ; net = net . withChildAdded ( slice ) . withChildAdded ( sample4 ) . withRenderedChildName ( " slice " ) . connect ( " sample3 " , " slice " , " list " ) . connect ( " sample4 " , " slice " , " size " ) ; Iterable results = context . renderNode ( net ) ; assertEquals ( 4 , Iterables . size ( results ) ) ; assertResultsEqual ( ( Iterable ) Iterables . get ( results , 0 ) , 5.0 , 7.0 ) ; assertResultsEqual ( ( Iterable ) Iterables . get ( results , 1 ) , 8.0 , 11.0 , 14.0 ) ; assertResultsEqual ( ( Iterable ) Iterables . get ( results , 2 ) , 11.0 , 15.0 ) ; assertResultsEqual ( ( Iterable ) Iterables . get ( results , 3 ) , 14.0 , 19.0 , 24.0 ) ; } 
private Node createSampleNode ( String name , int amount , double start , double end ) { return sampleNode . extend ( ) . withName ( name ) 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Paint the grid (The grid is not really affected by the view transform) paintGrid(g2); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(viewTransform); paintNodes(g2); paintConnections(g2); paintCurrentConnection(g2); paintPortTooltip(g2); paintDragSelection(g2); Restore original transform g2.setTransform(originalTransform); } 
public void revertPortToDefault ( String portName ) { Port port = checkValidPort ( portName ) ; addEdit ( " Revert Port to Default " ) ; controller . revertToDefaultPortValue ( getActiveNodePath ( ) , portName ) ; portView . updateAll ( ) ; portView . updateEnabledState ( ) ; requestRender ( ) ; } 
public void actionPerformed ( ActionEvent e ) { NodeBoxDocument doc = NodeBoxDocument.getCurrentDocument(); if (doc == null) throw new RuntimeException("No current active document."); ExpressionWindow window = new ExpressionWindow(port); window.setLocationRelativeTo(this); window.setVisible(true); doc.addPortEditor(window); } Action classes private class RevertToDefaultAction extends AbstractAction { private RevertToDefaultAction() { putValue(Action.NAME, "Revert to Default"); } public void actionPerformed(ActionEvent e) { document.revertPortToDefault(port.getName()); Reverting to default could cause an expression to be set/cleared. This triggers an valueChanged event, where we check if our expression field is still up-to-date. } }} 
public void actionPerformed ( ActionEvent e ) { document . revertPortToDefault ( port . getName ( ) ) ; Reverting to default could cause an expression to be set/cleared. 
public void revertToDefaultPortValue ( String nodePath , String portName ) { Node node = getNode ( nodePath ) ; Port port = node . getPrototype ( ) . getInput ( portName ) ; if ( port ! = null ) { Node newNode = node . withInputValue ( portName , port . getValue ( ) ) ; 
public void actionPerformed ( ActionEvent e ) { NodeBoxDocument doc = NodeBoxDocument.getCurrentDocument(); if (doc == null) throw new RuntimeException("No current active document."); ExpressionWindow window = new ExpressionWindow(port); window.setLocationRelativeTo(this); window.setVisible(true); doc.addPortEditor(window); } Action classes private class RevertToDefaultAction extends AbstractAction { private RevertToDefaultAction() { putValue(Action.NAME, "Revert to Default"); } public void actionPerformed(ActionEvent e) { document.revertPortToDefault(portName); Reverting to default could cause an expression to be set/cleared. This triggers an valueChanged event, where we check if our expression field is still up-to-date. } }} 
public void actionPerformed ( ActionEvent e ) { document . revertPortToDefault ( portName ) ; Reverting to default could cause an expression to be set/cleared. 
public static List < ? > sort ( Iterable < ? > iterable , final String key ) { if ( iterable = = null ) return ImmutableList . of ( ) ; try { if ( key = = null | | key . length ( ) = = 0 ) { 
public void updateValues ( ) { Port port = getPort ( ) ; nameField . setText ( port . getName ( ) ) ; labelField . setText ( port . getLabel ( ) ) ; typeField . setText ( port . getType ( ) ) ; rangeBox . setSelectedItem ( getHumanizedRange ( port . getRange ( ) ) ) ; if ( port . isStandardType ( ) ) { widgetBox . setSelectedItem ( getHumanizedWidget ( port . getWidget ( ) ) ) ; valueField . setText ( port . getValue ( ) . toString ( ) ) ; } else valueField . setEnabled ( false ) ; Object minimumValue = port . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = port . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
public void actionPerformed ( ActionEvent e ) { customTypeField . setEnabled ( box . getSelectedItem ( ) . equals ( " custom " ) ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { portName = nameField . getText ( ) ; String selectedType = ( String ) box . getSelectedItem ( ) ; portType = selectedType . equals ( " custom " ) ? customTypeField . getText ( ) . toLowerCase ( Locale . US ) : selectedType ; dispose ( ) ; } 
public static List < ? > rest ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; return ImmutableList . copyOf ( Iterables . skip ( iterable , 1 ) ) ; } 
public static List < ? > combine ( Iterable list1 , Iterable list2 , Iterable list3 ) { Iterable < Iterable < ? > > nonNullLists = Iterables . filter ( Lists . < Iterable < ? > > newArrayList ( list1 , list2 , list3 ) , Predicates . notNull ( ) ) ; return ImmutableList . copyOf ( Iterables . concat ( nonNullLists ) ) ; } 
public static List < ? > slice ( Iterable < ? > iterable , long startIndex , long size ) { if ( iterable = = null ) return ImmutableList . of ( ) ; Iterable < ? > skipped = Iterables . skip ( iterable , ( int ) startIndex ) ; return ImmutableList . copyOf ( Iterables . limit ( skipped , ( int ) size ) ) ; } 
public static List < ? > shift ( Iterable < ? > iterable , long amount ) { if ( iterable = = null ) return ImmutableList . of ( ) ; int listSize = Iterables . size ( iterable ) ; if ( listSize = = 0 ) return ImmutableList . of ( ) ; int a = ( int ) amount % listSize ; if ( a = = 0 ) return ImmutableList . copyOf ( iterable ) ; Iterable < ? > tail = Iterables . skip ( iterable , a ) ; Iterable < ? > head = Iterables . limit ( iterable , a ) ; return ImmutableList . copyOf ( Iterables . concat ( tail , head ) ) ; } 
public static List < ? > repeat ( Iterable < ? > iterable , long amount ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( amount < 1 ) return ImmutableList . of ( ) ; Iterable < ? > [ ] iterables = new Iterable < ? > [ ( int ) amount ] ; for ( int i = 0 ; i < amount ; i + + ) { iterables [ i ] = iterable ; } return ImmutableList . copyOf ( Iterables . concat ( iterables ) ) ; } 
public static List < ? > takeEvery ( Iterable < ? > iterable , long ) { if ( iterable = = null ) return ImmutableList . of ( ) ; ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; Iterator < ? > iterator = iterable . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { Object o = iterator . next ( ) ; if ( i % = = 0 ) { b . add ( o ) ; } i + + ; } return b . build ( ) ; } 
public static List < Double > makeNumbers ( String s , String separator ) { if ( s = = null | | s . length ( ) = = 0 ) { return ImmutableList . of ( ) ; } Iterable < String > parts ; if ( separator = = null | | separator . isEmpty ( ) ) parts = Splitter . fixedLength ( 1 ) . split ( s ) ; else parts = Splitter . on ( separator ) . split ( s ) ; ArrayList < Double > numbers = new ArrayList < Double > ( ) ; for ( String part : parts ) { numbers . add ( Double . parseDouble ( part ) ) ; } return ImmutableList . copyOf ( numbers ) ; } 
public static List < Double > range ( final double start , final double end , final double step ) { if ( step = = 0 | | start = = end | | ( start < end & & step < 0 ) | | ( start > end & & step > 0 ) ) return ImmutableList . of ( ) ; 
private Rectangle dragSelectRect ( ) { int x0 = ( int ) dragStartPoint . getX ( ) ; int y0 = ( int ) dragStartPoint . getY ( ) ; int x1 = ( int ) dragCurrentPoint . getX ( ) ; int y1 = ( int ) dragCurrentPoint . getY ( ) ; int x = Math . min ( x0 , x1 ) ; int y = Math . min ( y0 , y1 ) ; int w = ( int ) Math . abs ( dragCurrentPoint . getX ( ) - dragStartPoint . getX ( ) ) ; int h = ( int ) Math . abs ( dragCurrentPoint . getY ( ) - dragStartPoint . getY ( ) ) ; return new Rectangle ( x , y , w , h ) ; } 
private void paintConnection ( Graphics2D g , Connection connection ) { Node outputNode = findNodeWithName ( connection . getOutputNode ( ) ) ; Node inputNode = findNodeWithName ( connection . getInputNode ( ) ) ; Port inputPort = inputNode . getInput ( connection . getInputPort ( ) ) ; Rectangle outputRect = nodeRect ( outputNode ) ; Rectangle inputRect = nodeRect ( inputNode ) ; paintConnectionLine ( g , outputRect . x + 4 , outputRect . y + outputRect . height + 1 , inputRect . x + portOffset ( inputNode , inputPort ) + 4 , inputRect . y - 4 ) ; 
private void paintConnection ( Graphics2D g , Connection connection ) { Node outputNode = findNodeWithName ( connection . getOutputNode ( ) ) ; Node inputNode = findNodeWithName ( connection . getInputNode ( ) ) ; Port inputPort = inputNode . getInput ( connection . getInputPort ( ) ) ; g . setColor ( portTypeColor ( outputNode . getOutputType ( ) ) ) ; Rectangle outputRect = nodeRect ( outputNode ) ; Rectangle inputRect = nodeRect ( inputNode ) ; paintConnectionLine ( g , outputRect . x + 4 , outputRect . y + outputRect . height + 1 , inputRect . x + portOffset ( inputNode , inputPort ) + 4 , inputRect . y - 4 ) ; 
public static boolean isCompatible ( Node outputNode , Port inputPort ) { checkNotNull ( outputNode ) ; checkNotNull ( inputPort ) ; return isCompatible ( outputNode . getOutputType ( ) , inputPort . getType ( ) ) ; } 
public static boolean isCompatible ( String outputType , String inputType ) { checkNotNull ( outputType ) ; checkNotNull ( inputType ) ; If the output and input type are the same, they are compatible. if (outputType.equals(inputType)) return true; Everything can be converted to a string. if (inputType.equals(Port.TYPE_STRING)) return true; Integers can be converted to floating-point numbers without loss of information. if (outputType.equals(Port.TYPE_INT) && inputType.equals(Port.TYPE_FLOAT)) return true; Floating-point numbers can be converted to integers: they are rounded. if (outputType.equals(Port.TYPE_FLOAT) && inputType.equals(Port.TYPE_INT)) return true; A number can be converted to a point: both X and Y then get the same value. if (outputType.equals(Port.TYPE_INT) && inputType.equals(Port.TYPE_POINT)) return true; if (outputType.equals(Port.TYPE_FLOAT) && inputType.equals(Port.TYPE_POINT)) return true; If none of these tests pass, the types are not compatible. return false; } 
public void testIsCompatible ( ) { assertTrue ( " Nodes with the same type are always compatible. " , Node . isCompatible ( " foo " , " foo " ) ) ; assertTrue ( " Everything can be converted to a string. " , Node . isCompatible ( " foo " , Port . TYPE_STRING ) ) ; assertFalse ( " But not every type can take in a string. " , Node . isCompatible ( Port . TYPE_STRING , " foo " ) ) ; assertTrue ( " Floating-point numbers will be rounded to integers. " , Node . isCompatible ( Port . TYPE_FLOAT , Port . TYPE_INT ) ) ; assertTrue ( " Integers will be converted to floating-point numbers. " , Node . isCompatible ( Port . TYPE_INT , Port . TYPE_FLOAT ) ) ; assertTrue ( " Floating-point numbers can be converted to points. " , Node . isCompatible ( Port . TYPE_FLOAT , Port . TYPE_POINT ) ) ; assertTrue ( " Integers can be converted to points. " , Node . isCompatible ( Port . TYPE_INT , Port . TYPE_POINT ) ) ; assertFalse ( " Points can not be converted to numbers. " , Node . isCompatible ( Port . TYPE_POINT , Port . TYPE_FLOAT ) ) ; } 
private void initEventHandlers ( ) { setFocusable ( true ) ; This is disabled so we can detect the tab key. setFocusTraversalKeysEnabled(false); addKeyListener(this); addMouseListener(this); addMouseMotionListener(this); addMouseWheelListener(this); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Paint the grid (The grid is not really affected by the view transform) paintGrid(g2); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(getViewTransform()); paintNodes(g2); paintConnections(g2); paintCurrentConnection(g2); paintPortTooltip(g2); paintDragSelection(g2); Restore original transform g2.setTransform(originalTransform); } 
private Point pointToGridPoint ( Point e ) { Point2D pt = getInverseViewTransform ( ) . transform ( e , null ) ; return new Point ( ( int ) Math . floor ( pt . getX ( ) / GRID_CELL_SIZE ) , 
private void resetViewTransform ( ) { setViewTransform ( 0 , 0 , 1 ) ; repaint ( ) ; } 
public void mouseWheelMoved ( MouseWheelEvent e ) { double scaleDelta = 1F - e . getWheelRotation ( ) / 10 F ; double newViewScale = viewScale * scaleDelta ; if ( newViewScale < MIN_ZOOM ) { scaleDelta = MIN_ZOOM / viewScale ; } else if ( newViewScale > MAX_ZOOM ) { scaleDelta = MAX_ZOOM / viewScale ; } double vx = viewX - ( e . getX ( ) - viewX ) * ( scaleDelta - 1 ) ; double vy = viewY - ( e . getY ( ) - viewY ) * ( scaleDelta - 1 ) ; setViewTransform ( vx , vy , viewScale * scaleDelta ) ; repaint ( ) ; } 
private Point2D inverseViewTransformPoint ( Point p ) { Point2D pt = new Point2D . Double ( p . getX ( ) , p . getY ( ) ) ; return getInverseViewTransform ( ) . transform ( pt , null ) ; } 
public void testRenderSubnetwork ( ) { Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 1.0 ) ; Node number2 = numberNode . extend ( ) . withName ( " number2 " ) . withInputValue ( " number " , 2.0 ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node subnet = Node . ROOT . withName ( " subnet1 " ) . withChildAdded ( number1 ) . withChildAdded ( number2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " number1 " , " add1 " , " v1 " ) . connect ( " number2 " , " add1 " , " v2 " ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withRenderedChildName ( " subnet1 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 3.0 ) ; } 
public static BufferedImage findNodeImage ( NodeLibrary library , Node node ) { if ( node = = null | | node . getImage ( ) = = null | | node . getImage ( ) . isEmpty ( ) ) return null ; if ( ! library . getRoot ( ) . hasChild ( node ) ) return null ; File libraryFile = library . getFile ( ) ; if ( libraryFile ! = null ) { File libraryDirectory = libraryFile . getParentFile ( ) ; if ( libraryDirectory ! = null ) { File nodeImageFile = new File ( libraryDirectory , node . getImage ( ) ) ; if ( nodeImageFile . exists ( ) ) { return readNodeImage ( nodeImageFile ) ; } } } return null ; } 
public static BufferedImage readNodeImage ( File nodeImageFile ) { String imagePath = nodeImageFile . getAbsolutePath ( ) ; if ( nodeImageCache . containsKey ( imagePath ) ) { return nodeImageCache . get ( imagePath ) ; 
public void testRenderSubnetwork ( ) { Node subnet = createSubnetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withRenderedChildName ( " subnet1 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 3.0 ) ; } 
public void testValidSubnetworkResults ( ) { Node subnet1 = createSubnetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node subnet2 = createSubnetwork ( " subnet2 " , 3.0 , 4.0 ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node net = Node . ROOT . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( add1 ) , 10.0 ) ; } 
private Node createSubnetwork ( String name , double v1 , double v2 ) { Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , v1 ) ; Node number2 = numberNode . extend ( ) . withName ( " number2 " ) . withInputValue ( " number " , v2 ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node subnet = Node . ROOT . withName ( name ) . withChildAdded ( number1 ) . withChildAdded ( number2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " number1 " , " add1 " , " v1 " ) . connect ( " number2 " , " add1 " , " v2 " ) ; return subnet ; } 
public void replaceNodeInPath ( String nodePath , Node node ) { checkArgument ( nodePath . startsWith ( " / " ) , " Node path needs to be an absolute path, starting with '/'. " ) ; nodePath = nodePath . substring ( 1 ) ; Node newRoot ; if ( nodePath . isEmpty ( ) ) { newRoot = node ; } else { newRoot = replacedInPath ( nodePath , node ) ; } nodeLibrary = nodeLibrary . withRoot ( newRoot ) ; } 
private Node replacedInPath ( String nodePath , Node node ) { if ( ! nodePath . contains ( " / " ) ) return nodeLibrary . getRoot ( ) . withChildReplaced ( nodePath , node ) ; List < String > parts = ImmutableList . copyOf ( Splitter . on ( " / " ) . split ( nodePath ) ) ; List < String > parentParts = parts . subList ( 0 , parts . size ( ) - 1 ) ; String childName = parts . get ( parts . size ( ) - 1 ) ; String parentPath = Joiner . on ( " / " ) . join ( parentParts ) ; Node parent = nodeLibrary . getNodeForPath ( " / " + parentPath ) ; Node newParent = parent . withChildReplaced ( childName , node ) ; return replacedInPath ( parentPath , newParent ) ; } 
public static void drawPoints ( Graphics2D g , Iterable < Point > points ) { GeneralPath onCurves = new GeneralPath ( ) ; GeneralPath offCurves = new GeneralPath ( ) ; for ( Point point : points ) { Shape s = new Ellipse2D . Double ( point . x - HALF_POINT_SIZE , point . y - HALF_POINT_SIZE , POINT_SIZE , POINT_SIZE ) ; if ( point . isOnCurve ( ) ) { onCurves . append ( s , false ) ; } else { offCurves . append ( s , false ) ; } } g . setColor ( Color . BLUE ) ; g . fill ( onCurves ) ; g . setColor ( Color . RED ) ; g . fill ( offCurves ) ; } 
public static Path generator ( ) { Path p = new Path ( ) ; p . rect ( 0 , 0 , 100 , 100 ) ; return p ; } 
public static Geometry filter ( Geometry geometry ) { if ( geometry = = null ) return null ; Transform = new Transform ( ) ; . rotate ( 45 ) ; return . map ( geometry ) ; } 
public static Path arc ( Point position , double width , double height , double startAngle , double degrees , String arcType ) { int awtType ; if ( arcType . equals ( " chord " ) ) { awtType = Arc2D . CHORD ; } else if ( arcType . equals ( " pie " ) ) { awtType = Arc2D . PIE ; } else { awtType = Arc2D . OPEN ; } return new Path ( new Arc2D . Double ( position . x - width / 2 , position . y - height / 2 , width , height , - startAngle , - degrees , awtType ) ) ; 
public static Path ellipse ( Point position , double width , double height ) { Path p = new Path ( ) ; p . ellipse ( position . x , position . y , width , height ) ; return p ; } 
public static Path freehand ( String pathString ) { if ( pathString = = null ) return new Path ( ) ; Path p = parsePath ( pathString ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; return p ; } 
public static Path parsePath ( String s ) { checkNotNull ( s ) ; Path p = new Path ( ) ; s = s . trim ( ) ; for ( String pointString : CONTOUR_SPLITTER . split ( s ) ) { pointString = pointString . trim ( ) ; if ( ! pointString . isEmpty ( ) ) { p . add ( parseContour ( pointString ) ) ; } } return p ; } 
public static Contour parseContour ( String s ) { Contour contour = new Contour ( ) ; Double x = null ; for ( String numberString : POINT_SPLITTER . split ( s ) ) { if ( x = = null ) { x = Double . parseDouble ( numberString ) ; } else { double y = Double . parseDouble ( numberString ) ; contour . addPoint ( x , y ) ; x = null ; } } return contour ; } 
public static List < Point > grid ( long rows , long columns , double width , double height , Point position ) { double columnSize , left , rowSize , top ; if ( columns > 1 ) { columnSize = width / ( columns - 1 ) ; left = position . x - width / 2 ; } else { columnSize = left = position . x ; } if ( rows > 1 ) { rowSize = height / ( rows - 1 ) ; top = position . y - height / 2 ; } else { rowSize = top = position . y ; } ImmutableList . Builder < Point > builder = new ImmutableList . Builder < Point > ( ) ; for ( long rowIndex = 0 ; rowIndex < rows ; rowIndex + + ) { for ( long colIndex = 0 ; colIndex < columns ; colIndex + + ) { double x = left + colIndex * columnSize ; double y = top + rowIndex * rowSize ; builder . add ( new Point ( x , y ) ) ; } } return builder . build ( ) ; } 
public static Path line ( Point p1 , Point p2 ) { Path p = new Path ( ) ; p . line ( p1 . x , p1 . y , p2 . x , p2 . y ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; return p ; } 
public static Path rect ( Point position , double width , double height , Point roundness ) { Path p = new Path ( ) ; if ( roundness = = Point . ZERO ) { p . rect ( position . x , position . y , width , height ) ; } else { p . roundedRect ( position . x , position . y , width , height , roundness . x , roundness . y ) ; } return p ; } 
public static Handle fourPointHandle ( ) { return new FourPointHandle ( ) ; } 
public static Handle freehandHandle ( ) { return new FreehandHandle ( ) ; } 
public static Handle lineHandle ( ) { return new LineHandle ( ) ; } 
public void testSetPortValueInSubnet ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 10.0 ) ) ; Node subnet = Node . ROOT . withName ( " subnet " ) . withChildAdded ( numberNode ) . withRenderedChildName ( " number " ) ; controller . addNode ( " / " , subnet ) ; assertResultsEqual ( controller . getNodeLibrary ( ) . getRoot ( ) , controller . getNode ( " /subnet " ) , 10.0 ) ; controller . setPortValue ( " /subnet/number " , " value " , 42.0 ) ; assertResultsEqual ( controller . getNodeLibrary ( ) . getRoot ( ) , controller . getNode ( " /subnet " ) , 42.0 ) ; } 
public static AbstractGeometry align ( AbstractGeometry geometry , Point position , String hAlign , String vAlign ) { if ( geometry = = null ) return null ; double x = position . x ; double y = position . y ; Rect bounds = geometry . getBounds ( ) ; double dx , dy ; if ( hAlign . equals ( " left " ) ) { dx = x - bounds . x ; } else if ( hAlign . equals ( " right " ) ) { dx = x - bounds . x - bounds . width ; } else if ( hAlign . equals ( " center " ) ) { dx = x - bounds . x - bounds . width / 2 ; } else { dx = 0 ; } if ( vAlign . equals ( " top " ) ) { dy = y - bounds . y ; } else if ( vAlign . equals ( " bottom " ) ) { dy = y - bounds . y - bounds . height ; } else if ( vAlign . equals ( " middle " ) ) { dy = y - bounds . y - bounds . height / 2 ; } else { dy = 0 ; } Transform = Transform . translated ( dx , dy ) ; if ( geometry instanceof Path ) { return . map ( ( Path ) geometry ) ; 
public static Handle pointHandle ( ) { return new PointHandle ( ) ; } 
public static Point centroid ( Grob grob ) { if ( grob = = null ) return Point . ZERO ; return grob . getBounds ( ) . getCentroid ( ) ; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { int mx = e . getX ( ) ; armed = partIndex ( mx ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { armed = - 1 ; int mx = e . getX ( ) ; int partIndex = partIndex ( mx ) ; if ( partIndex = = - 1 ) return ; String selectedPart = segments . get ( partIndex ) ; if ( selectedPart ! = null & & onSegmentClickListener ! = null ) onSegmentClickListener . onSegmentClicked ( pathForIndex ( partIndex ) ) ; repaint ( ) ; } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } private String pathForIndex ( int endIndex ) { return " / " + Joiner . on ( " / " ) . join ( segments . subList ( 1 , endIndex + 1 ) ) ; } public void onSegmentClicked ( String fullPath ) ; } } 
public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { armed = - 1 ; repaint ( ) ; } private int partIndex ( int x ) { if ( positions = = null ) return - 1 ; for ( int i = 0 ; i < positions . length ; i + + ) { if ( x < positions [ i ] ) return i ; } return - 1 ; } private String pathForIndex ( int endIndex ) { return " / " + Joiner . on ( " / " ) . join ( segments . subList ( 1 , endIndex + 1 ) ) ; } public void onSegmentClicked ( String fullPath ) ; } } 
private String pathForIndex ( int endIndex ) { return " / " + Joiner . on ( " / " ) . join ( segments . subList ( 1 , endIndex + 1 ) ) ; } 
public static Path rect ( Point position , double width , double height , Point roundness ) { Path p = new Path ( ) ; if ( roundness . equals ( Point . ZERO ) ) { p . rect ( position . x , position . y , width , height ) ; } else { p . roundedRect ( position . x , position . y , width , height , roundness . x , roundness . y ) ; } return p ; } 
private void lookForLibraries ( ) { NodeLibrary coreLibrary = NodeLibrary . load ( new File ( " libraries/core/core.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary lSystemLibrary = NodeLibrary.load(new File("libraries/l_system/l_system.ndbx"), NodeRepository.of()); NodeLibrary packingLibrary = NodeLibrary.load(new File("libraries/packing/packing.ndbx"), NodeRepository.of()); systemRepository = NodeRepository.of(coreLibrary, mathLibrary, stringLibrary, listLibrary, dataLibrary, colorLibrary, 
public static Colorizable colorize ( Colorizable shape , Color fill , Color stroke , double strokeWidth ) { if ( shape = = null ) return null ; Colorizable newShape = shape . clone ( ) ; newShape . setFill ( fill ) ; if ( strokeWidth > 0 ) { newShape . setStrokeColor ( stroke ) ; newShape . setStrokeWidth ( strokeWidth ) ; } else { newShape . setStrokeColor ( null ) ; } return newShape ; } 
void setFillColor ( Color fillColor ) ; void setFill ( Color c ) ; void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( double strokeWidth ) ; public Colorizable clone ( ) ; } 
void setFill ( Color c ) ; void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( double strokeWidth ) ; public Colorizable clone ( ) ; } 
void setStrokeColor ( Color strokeColor ) ; void setStroke ( Color c ) ; void setStrokeWidth ( double strokeWidth ) ; public Colorizable clone ( ) ; } 
void setStroke ( Color c ) ; void setStrokeWidth ( double strokeWidth ) ; public Colorizable clone ( ) ; } 
void setStrokeWidth ( double strokeWidth ) ; public Colorizable clone ( ) ; } 
public static Path connect ( List < Point > points , boolean closed ) { if ( points = = null ) return null ; Path p = new Path ( ) ; for ( Point pt : points ) { p . addPoint ( pt ) ; } if ( closed ) p . close ( ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; return p ; } 
public static List < Point > toPoints ( IGeometry shape ) { if ( shape = = null ) return null ; return shape . getPoints ( ) ; } 
public static Path parsePath ( String s ) { checkNotNull ( s ) ; Path p = new Path ( ) ; s = s . trim ( ) ; for ( String pointString : PATH_SPLITTER . split ( s ) ) { pointString = pointString . trim ( ) ; if ( ! pointString . isEmpty ( ) ) { p . add ( parseContour ( pointString ) ) ; } } return p ; } 
public static Contour parseContour ( String s ) { Contour contour = new Contour ( ) ; for ( String pointString : CONTOUR_SPLITTER . split ( s ) ) { contour . addPoint ( parsePoint ( pointString ) ) ; } return contour ; } 
public static Point parsePoint ( String s ) { Double x = null , y = null ; for ( String numberString : POINT_SPLITTER . split ( s ) ) { if ( x = = null ) { x = Double . parseDouble ( numberString ) ; } else if ( y = = null ) { y = Double . parseDouble ( numberString ) ; } else { throw new IllegalArgumentException ( " Too many coordinates in point " + s ) ; } } if ( x ! = null & & y ! = null ) { return new Point ( x , y ) ; 
public boolean mouseDragged ( Point pt ) { Note that the freehand handle is not concerned with parsing the actual path. All it does is append new points to the string. The actual path parsing is done by the freehand node code. currentPoint = pt; String pathString = (String) getValue(pathPortName); if (newPath) { pathString += "M"; newPath = false; } else { pathString += " "; } Use US locale, otherwise the code might generate a "," instead of a "." as the floating point. pathString += String.format(Locale.US, "%.2f,%.2f ", pt.getX(), pt.getY()); silentSet(pathPortName, pathString); updateHandle(); return true; } 
public static Path lineAngle ( Point point , double angle , double distance ) { Point p2 = coordinates ( point , angle , distance ) ; Path p = new Path ( ) ; p . line ( point . x , point . y , p2 . x , p2 . y ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; return p ; } 
public static Handle lineAngleHandle ( ) { CombinedHandle handle = new CombinedHandle ( ) ; handle . addHandle ( new PointHandle ( ) ) ; handle . addHandle ( new RotateHandle ( " angle " , " position " ) ) ; return handle ; } 
public static Point makePoint ( double x , double y ) { return new Point ( x , y ) ; } 
public static Object doNothing ( Object object ) { return object ; } 
public void testPrototypeInSameLibrary ( ) { You can refer to a prototype in the same library as the current node. Node invert = Node.ROOT .withName("negate") .withFunction("math/negate") .withInputAdded(Port.floatPort("number", 0)); Node invert1 = invert.extend().withName("invert1").withInputValue("number", 42.0); Node root = Node.ROOT .withName("root") .withChildAdded(invert) .withChildAdded(invert1) .withRenderedChild(invert1); NodeLibrary originalLibrary = NodeLibrary.create("test", root, FunctionRepository.of(MathFunctions.LIBRARY)); Assert the original library returns the correct result. NodeContext context = new NodeContext(originalLibrary); assertResultsEqual(context.renderNode(root), -42.0); Persist / load the library and assert it still returns the correct result. NodeLibrary restoredLibrary = NodeLibrary.load("test", originalLibrary.toXml(), NodeRepository.of()); context = new NodeContext(restoredLibrary); assertResultsEqual(context.renderNode(restoredLibrary.getRoot()), -42.0); } 
private int level ( Iterable it ) { if ( it = = null ) return 0 ; Iterator < ? > iterator = it . iterator ( ) ; if ( ! iterator . hasNext ( ) ) return 0 ; Object first = iterator . next ( ) ; We check if the structure implements List rather than Iterable, because we might be interested in certain kind of iterables (for example a Path object). Deconstructing those kind of iterables may not be what we want. if (first instanceof List) { return 1 + level((Iterable) first); } return 0; } 
private static Class nestedListClass ( Iterable < ? > objects , Class klass ) { Class < ? > c = klass ; for ( Object o : objects ) { if ( o = = null ) return Object . class ; if ( o instanceof List ) { c = nestedListClass ( ( Iterable ) o , c ) ; break ; } while ( c ! = Object . class ) { if ( ! c . isAssignableFrom ( o . getClass ( ) ) ) c = c . getSuperclass ( ) ; else break ; } } return c ; } 
public void testNestedListAsSingleValue ( ) { Node sample1 = createSampleNode ( " sample1 " , 4 , 3.0 , 9.0 ) ; Node sample2 = createSampleNode ( " sample2 " , 4 , 9.0 , 24.0 ) ; Node sample3 = sampleNode . extend ( ) . withName ( " sample3 " ) . withInputValue ( " amount " , 4 ) ; Node net = Node . ROOT . withChildAdded ( sample1 ) . withChildAdded ( sample2 ) . withChildAdded ( sample3 ) . withRenderedChildName ( " sample3 " ) . connect ( " sample1 " , " sample3 " , " start " ) . connect ( " sample2 " , " sample3 " , " end " ) ; assertResultsEqual ( context . renderNode ( net ) , ImmutableList . of ( 3.0 , 5.0 , 7.0 , 9.0 ) , ImmutableList . of ( 5.0 , 8.0 , 11.0 , 14.0 ) , ImmutableList . of ( 7.0 , 11.0 , 15.0 , 19.0 ) , ImmutableList . of ( 9.0 , 14.0 , 19.0 , 24.0 ) ) ; Node sample4 = createSampleNode ( " sample4 " , 2 , 2.0 , 3.0 ) ; Node slice = Node . ROOT . withName ( " slice " ) . withFunction ( " list/slice " ) . withOutputRange ( Port . Range . LIST ) . withInputAdded ( Port . floatPort ( " list " , 0 ) ) . withInputRange ( " list " , Port . Range . LIST ) . withInputAdded ( Port . intPort ( " start_index " , 1 ) ) . withInputAdded ( Port . intPort ( " size " , 2 ) ) ; net = net . withChildAdded ( slice ) . withChildAdded ( sample4 ) . withRenderedChildName ( " slice " ) . connect ( " sample3 " , " slice " , " list " ) . connect ( " sample4 " , " slice " , " size " ) ; Iterable < ? > results = context . renderNode ( net ) ; assertEquals ( 4 , Iterables . size ( results ) ) ; assertResultsEqual ( ( Iterable < ? > ) Iterables . get ( results , 0 ) , 5.0 , 7.0 ) ; assertResultsEqual ( ( Iterable < ? > ) Iterables . get ( results , 1 ) , 8.0 , 11.0 , 14.0 ) ; assertResultsEqual ( ( Iterable < ? > ) Iterables . get ( results , 2 ) , 11.0 , 15.0 ) ; assertResultsEqual ( ( Iterable < ? > ) Iterables . get ( results , 3 ) , 14.0 , 19.0 , 24.0 ) ; } 
public static Geometry copy ( IGeometry shape , long copies , String order , Point translate , double rotate , Point scale ) { Geometry geo = new Geometry ( ) ; double tx = 0 ; double ty = 0 ; double r = 0 ; double sx = 1.0 ; double sy = 1.0 ; char [ ] cOrder = order . toCharArray ( ) ; for ( long i = 0 ; i < copies ; i + + ) { Transform = new Transform ( ) ; Each letter of the order describes an operation. for (char op : cOrder) { if (op == 't') { t.translate(tx, ty); } else if (op == 'r') { t.rotate(r); } else if (op == 's') { t.scale(sx, sy); } } if (shape instanceof Path) { Path newPath = t.map((Path)shape); geo.add(newPath); } else if (shape instanceof Geometry) { Geometry newGeo = t.map((Geometry) shape); geo.extend(newGeo); } tx += translate.x; ty += translate.y; r += rotate; sx += scale.x; sy += scale.y; } return geo; } 
public static Handle translateHandle ( ) { return new TranslateHandle ( ) ; } 
public static Geometry copy ( IGeometry shape , long copies , String order , Point translate , double rotate , Point scale ) { Geometry geo = new Geometry ( ) ; double tx = 0 ; double ty = 0 ; double r = 0 ; double sx = 1.0 ; double sy = 1.0 ; char [ ] cOrder = order . toCharArray ( ) ; for ( long i = 0 ; i < copies ; i + + ) { Transform = new Transform ( ) ; Each letter of the order describes an operation. for (char op : cOrder) { if (op == 't') { t.translate(tx, ty); } else if (op == 'r') { t.rotate(r); } else if (op == 's') { t.scale(sx, sy); } } if (shape instanceof Path) { Path newPath = t.map((Path) shape); geo.add(newPath); } else if (shape instanceof Geometry) { Geometry newGeo = t.map((Geometry) shape); geo.extend(newGeo); } tx += translate.x; ty += translate.y; r += rotate; sx += scale.x; sy += scale.y; } return geo; } 
public static IGeometry fit ( IGeometry shape , Point position , double width , double height , boolean keepProportions ) { if ( shape = = null ) return null ; Rect bounds = shape . getBounds ( ) ; Make sure bw and bh aren't infinitely small numbers. This will lead to incorrect transformations with for examples lines. double bw = bounds.width > 0.000000000001 ? bounds.width : 0; double bh = bounds.height > 0.000000000001 ? bounds.height : 0; Transform t = new Transform(); t.translate(position.x, position.y); double sx, sy; if (keepProportions) { don't scale widths or heights that are equal to zero. sx = bw > 0 ? width / bw : Float.MAX_VALUE; sy = bh > 0 ? height / bh : Float.MAX_VALUE; sx = sy = Math.min(sx, sy); } else { sx = bw > 0 ? width / bw : 1; sy = bh > 0 ? height / bh : 1; } t.scale(sx, sy); t.translate(-bw / 2 - bounds.x, -bh / 2 - bounds.y); return t.map(shape); } 
public IGeometry map ( IGeometry shape ) { if ( shape instanceof Path ) { return map ( ( Path ) shape ) ; 
public static IGeometry fitTo ( IGeometry shape , IGeometry bounding , boolean keepProportions ) { if ( shape = = null ) return null ; if ( bounding = = null ) return shape ; Rect bounds = bounding . getBounds ( ) ; return fit ( shape , bounds . getCentroid ( ) , bounds . width , bounds . height , keepProportions ) ; } 
public static Geometry group ( List < IGeometry > shapes ) { if ( shapes = = null ) return null ; Geometry geo = new Geometry ( ) ; for ( IGeometry shape : shapes ) { if ( shape instanceof Path ) { geo . add ( ( Path ) shape ) ; } else if ( shape instanceof Geometry ) { geo . extend ( ( Geometry ) shape ) ; } else { throw new RuntimeException ( " Unable to group " + shape + " : I can only group paths or geometry objects. " ) ; } } return geo ; } 
public static List < Path > ungroup ( IGeometry shape ) { if ( shape = = null ) return null ; if ( shape instanceof Geometry ) { return ( ( Geometry ) shape ) . getPaths ( ) ; 
public static Path link ( Grob shape1 , Grob shape2 , String orientation ) { if ( shape1 = = null | | shape2 = = null ) return null ; Path p = new Path ( ) ; Rect a = shape1 . getBounds ( ) ; Rect b = shape2 . getBounds ( ) ; if ( orientation . equals ( " horizontal " ) ) { double hw = ( b . x - ( a . x + a . width ) ) / 2 ; p . moveto ( a . x + a . width , a . y ) ; p . curveto ( a . x + a . width + hw , a . y , b . x - hw , b . y , b . x , b . y ) ; p . lineto ( b . x , b . y + b . height ) ; p . curveto ( b . x - hw , b . y + b . height , a . x + a . width + hw , a . y + a . height , a . x + a . width , a . y + a . height ) ; } else { double hh = ( b . y - ( a . y + a . height ) ) / 2 ; p . moveto ( a . x , a . y + a . height ) ; p . curveto ( a . x , a . y + a . height + hh , b . x , b . y - hh , b . x , b . y ) ; p . lineto ( b . x + b . width , b . y ) ; p . curveto ( b . x + b . width , b . y - hh , a . x + a . width , a . y + a . height + hh , a . x + a . width , a . y + a . height ) ; } return p ; } 
public static Point pointOnPath ( AbstractGeometry shape , double , double range ) { if ( shape = = null ) return null ; = Math . abs ( % range ) ; return shape . pointAt ( / range ) ; } 
public abstract Point pointAt ( double ) ; public abstract IGeometry clone ( ) ; } 
public static AbstractGeometry snap ( AbstractGeometry shape , final double distance , final double strength , final Point position ) { if ( shape = = null ) return null ; final double dStrength = strength / 100.0 ; return shape . mapPoints ( new Function < Point , Point > ( ) { public Point apply ( @Nullable Point point ) { 
public Point apply ( @Nullable Point point ) { if ( point = = null ) return Point . ZERO ; double x = MathUtils . snap ( point . x + position . x , distance , dStrength ) - position . x ; double y = MathUtils . snap ( point . y + position . y , distance , dStrength ) - position . y ; return new Point ( x , y ) ; } 
public static Handle snapHandle ( ) { return new SnapHandle ( ) ; } 
public abstract Point pointAt ( double ) ; public abstract IGeometry clone ( ) ; public abstract AbstractGeometry mapPoints ( Function < Point , Point > pointFunction ) ; } 
public abstract IGeometry clone ( ) ; public abstract AbstractGeometry mapPoints ( Function < Point , Point > pointFunction ) ; } 
public abstract AbstractGeometry mapPoints ( Function < Point , Point > pointFunction ) ; } 
protected Rect createHitRectangle ( double x , double y ) { return new Rect ( - 1000 , - 1000 , 2000 , 2000 ) ; } 
public void draw ( GraphicsContext ctx ) { Point pos = ( Point ) getValue ( " position " ) ; double snapX = pos . x ; double snapY = pos . y ; double distance = ( Double ) getValue ( " distance " ) ; ctx . stroke ( 0.4 , 0.4 , 0.4 , 0.5 ) ; ctx . strokewidth ( 1.0 ) ; Path p = new Path ( ) ; for ( int i = - 100 ; i < 100 ; i + + ) { double x = - snapX + ( i * distance ) ; double y = - snapY + ( i * distance ) ; p . line ( x , - 1000 , x , 1000 ) ; p . line ( - 1000 , y , 1000 , y ) ; } ctx . drawpath ( p ) ; } 
public static double snap ( double v , double distance , double strength ) { return ( v * ( 1.0 - strength ) ) + ( strength * Math . round ( v / distance ) * distance ) ; } 
public void testAddPort ( ) { Node gamma = Node . ROOT . withName ( " gamma " ) ; controller . addNode ( " / " , gamma ) ; assertFalse ( controller . getNodeLibrary ( ) . getNodeForPath ( " /gamma " ) . hasInput ( " p " ) ) ; controller . addPort ( " /gamma " , " p " , Port . TYPE_INT ) ; assertTrue ( controller . getNodeLibrary ( ) . getNodeForPath ( " /gamma " ) . hasInput ( " p " ) ) ; } 
public void testRemovePort ( ) { Node gamma = Node . ROOT . withName ( " gamma " ) . withInputAdded ( Port . intPort ( " p " , 0 ) ) ; controller . addNode ( " / " , gamma ) ; assertTrue ( controller . getNodeLibrary ( ) . getNodeForPath ( " /gamma " ) . hasInput ( " p " ) ) ; controller . removePort ( " / " , " gamma " , " p " ) ; assertFalse ( controller . getNodeLibrary ( ) . getNodeForPath ( " /gamma " ) . hasInput ( " p " ) ) ; } 
public void testRemoveConnectedPort ( ) { Node gamma = Node . ROOT . withName ( " gamma " ) . withInputAdded ( Port . intPort ( " p " , 0 ) ) ; Node delta = Node . ROOT . withName ( " delta " ) . withInputAdded ( Port . intPort ( " q " , 0 ) ) ; controller . addNode ( " / " , gamma ) ; controller . addNode ( " / " , delta ) ; controller . connect ( " / " , gamma , delta , delta . getInput ( " q " ) ) ; assertTrue ( controller . getNodeLibrary ( ) . getNodeForPath ( " /delta " ) . hasInput ( " q " ) ) ; assertEquals ( 1 , controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . size ( ) ) ; controller . removePort ( " / " , " delta " , " q " ) ; assertFalse ( controller . getNodeLibrary ( ) . getNodeForPath ( " /delta " ) . hasInput ( " q " ) ) ; assertEquals ( 0 , controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . size ( ) ) ; } 
public void testSimpleRename ( ) { Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " / " , child ) ; controller . renameNode ( " / " , " child " , " " ) ; assertFalse ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " child " ) ) ; assertTrue ( controller . getNodeLibrary ( ) . getRoot ( ) . hasChild ( " " ) ) ; } 
public void testRenderedNodeRenaming ( ) { Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " / " , child ) ; controller . setRenderedChild ( " / " , " child " ) ; assertTrue ( controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChildName ( ) . equals ( " child " ) ) ; controller . renameNode ( " / " , " child " , " " ) ; assertTrue ( controller . getNodeLibrary ( ) . getRoot ( ) . getRenderedChildName ( ) . equals ( " " ) ) ; } 
public void testConnectedNodeRenaming ( ) { createSimpleConnection ( ) ; controller . renameNode ( " / " , " negate " , " invert " ) ; assertEquals ( 1 , controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . size ( ) ) ; Connection c = controller . getNodeLibrary ( ) . getRoot ( ) . getConnections ( ) . get ( 0 ) ; assertEquals ( " invert " , c . getInputNode ( ) ) ; assertEquals ( " value " , c . getInputPort ( ) ) ; assertEquals ( " number " , c . getOutputNode ( ) ) ; } 
public Node addNode ( String parentPath , Node node ) { Node newParent = getNode ( parentPath ) . withChildAdded ( node ) ; replaceNodeInPath ( parentPath , newParent ) ; We can't return the given node argument itself because withChildAdded might have chosen a new name, Instead return the child at the end of the parent's children list. return Iterables.getLast(newParent.getChildren()); } 
public void removeNode ( String parentPath , String nodeName ) { Node newParent = getNode ( parentPath ) . withChildRemoved ( nodeName ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
private Node replacedInPath ( String nodePath , Node node ) { if ( ! nodePath . contains ( " / " ) ) return getRootNode ( ) . withChildReplaced ( nodePath , node ) ; List < String > parts = ImmutableList . copyOf ( Splitter . on ( " / " ) . split ( nodePath ) ) ; List < String > parentParts = parts . subList ( 0 , parts . size ( ) - 1 ) ; String childName = parts . get ( parts . size ( ) - 1 ) ; String parentPath = Joiner . on ( " / " ) . join ( parentParts ) ; Node parent = nodeLibrary . getNodeForPath ( " / " + parentPath ) ; Node newParent = parent . withChildReplaced ( childName , node ) ; return replacedInPath ( parentPath , newParent ) ; } 
public void setUp ( ) throws Exception { controller = NodeLibraryController . create ( ) ; } 
public void testChangeRenderedNode ( ) throws Exception { Node alpha = Node . ROOT . withName ( " alpha " ) ; Node beta = Node . ROOT . withName ( " beta " ) ; controller . addNode ( " / " , alpha ) ; controller . addNode ( " / " , beta ) ; assertNull ( controller . getRootNode ( ) . getRenderedChild ( ) ) ; controller . setRenderedChild ( " / " , " alpha " ) ; assertEquals ( alpha , controller . getRootNode ( ) . getRenderedChild ( ) ) ; controller . setRenderedChild ( " / " , " beta " ) ; assertEquals ( beta , controller . getRootNode ( ) . getRenderedChild ( ) ) ; controller . setRenderedChild ( " / " , " " ) ; assertNull ( controller . getRootNode ( ) . getRenderedChild ( ) ) ; } 
public void testRemoveConnectedPort ( ) { Node gamma = Node . ROOT . withName ( " gamma " ) . withInputAdded ( Port . intPort ( " p " , 0 ) ) ; Node delta = Node . ROOT . withName ( " delta " ) . withInputAdded ( Port . intPort ( " q " , 0 ) ) ; controller . addNode ( " / " , gamma ) ; controller . addNode ( " / " , delta ) ; controller . connect ( " / " , gamma , delta , delta . getInput ( " q " ) ) ; assertTrue ( controller . getNodeLibrary ( ) . getNodeForPath ( " /delta " ) . hasInput ( " q " ) ) ; assertEquals ( 1 , controller . getRootNode ( ) . getConnections ( ) . size ( ) ) ; controller . removePort ( " / " , " delta " , " q " ) ; assertFalse ( controller . getNodeLibrary ( ) . getNodeForPath ( " /delta " ) . hasInput ( " q " ) ) ; assertEquals ( 0 , controller . getRootNode ( ) . getConnections ( ) . size ( ) ) ; } 
public void testAddNodeUniqueName ( ) { Node gamma = Node . ROOT . withName ( " gamma " ) ; controller . addNode ( " / " , gamma ) ; assertTrue ( controller . getRootNode ( ) . hasChild ( " gamma " ) ) ; controller . addNode ( " / " , gamma ) ; assertTrue ( controller . getRootNode ( ) . hasChild ( " gamma1 " ) ) ; } 
private void createTestNetwork ( ) { Node alpha = Node . ROOT . withName ( " alpha " ) ; Node beta = Node . ROOT . withName ( " beta " ) . withInputAdded ( Port . floatPort ( " number " , 0.0 ) ) ; controller . addNode ( " / " , alpha ) ; controller . addNode ( " / " , beta ) ; controller . connect ( " / " , alpha , beta , beta . getInput ( " number " ) ) ; Node root = controller . getRootNode ( ) ; assertTrue ( root . isConnected ( " alpha " ) ) ; assertTrue ( root . isConnected ( " beta " ) ) ; } 
public void testCreateNode ( ) { Node proto = Node . ROOT . withName ( " protoNode " ) ; controller . createNode ( " / " , proto ) ; assertTrue ( controller . getRootNode ( ) . hasChild ( " protoNode1 " ) ) ; assertSame ( proto , controller . getNodeLibrary ( ) . getNodeForPath ( " /protoNode1 " ) . getPrototype ( ) ) ; } 
public void testRemoveNode ( ) { Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " / " , child ) ; assertTrue ( controller . getRootNode ( ) . hasChild ( " child " ) ) ; controller . removeNode ( " / " , " child " ) ; assertFalse ( controller . getRootNode ( ) . hasChild ( " child " ) ) ; assertNull ( controller . getNodeLibrary ( ) . getNodeForPath ( " /child " ) ) ; } 
public void testSetPortValueInSubnet ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 10.0 ) ) ; Node subnet = Node . ROOT . withName ( " subnet " ) . withChildAdded ( numberNode ) . withRenderedChildName ( " number " ) ; controller . addNode ( " / " , subnet ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet " ) , 10.0 ) ; controller . setPortValue ( " /subnet/number " , " value " , 42.0 ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet " ) , 42.0 ) ; } 
public void testUniqueNodeName ( ) { Node proto = Node . ROOT . withName ( " protoNode " ) ; controller . createNode ( " / " , proto ) ; controller . createNode ( " / " , proto ) ; controller . createNode ( " / " , proto ) ; Node rootNode = controller . getRootNode ( ) ; assertFalse ( rootNode . hasChild ( " protoNode " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode1 " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode2 " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode3 " ) ) ; controller . removeNode ( " / " , " protoNode2 " ) ; rootNode = controller . getRootNode ( ) ; assertFalse ( rootNode . hasChild ( " protoNode2 " ) ) ; controller . createNode ( " / " , proto ) ; rootNode = controller . getRootNode ( ) ; assertTrue ( rootNode . hasChild ( " protoNode2 " ) ) ; assertFalse ( rootNode . hasChild ( " protoNode4 " ) ) ; } 
public void testSimpleRename ( ) { Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " / " , child ) ; controller . renameNode ( " / " , " child " , " " ) ; assertFalse ( controller . getRootNode ( ) . hasChild ( " child " ) ) ; assertTrue ( controller . getRootNode ( ) . hasChild ( " " ) ) ; } 
public void testRenderedNodeRenaming ( ) { Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " / " , child ) ; controller . setRenderedChild ( " / " , " child " ) ; assertTrue ( controller . getRootNode ( ) . getRenderedChildName ( ) . equals ( " child " ) ) ; controller . renameNode ( " / " , " child " , " " ) ; assertTrue ( controller . getRootNode ( ) . getRenderedChildName ( ) . equals ( " " ) ) ; } 
public void testSimpleConnection ( ) { assertEquals ( 0 , controller . getRootNode ( ) . getConnections ( ) . size ( ) ) ; createSimpleConnection ( ) ; assertEquals ( 1 , controller . getRootNode ( ) . getConnections ( ) . size ( ) ) ; Connection c = controller . getRootNode ( ) . getConnections ( ) . get ( 0 ) ; assertEquals ( " negate " , c . getInputNode ( ) ) ; assertEquals ( " value " , c . getInputPort ( ) ) ; assertEquals ( " number " , c . getOutputNode ( ) ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /negate " ) , - 20.0 ) ; } 
public void testSimpleDisconnect ( ) { createSimpleConnection ( ) ; Connection c = controller . getRootNode ( ) . getConnections ( ) . get ( 0 ) ; controller . disconnect ( " / " , c ) ; assertEquals ( 0 , controller . getRootNode ( ) . getConnections ( ) . size ( ) ) ; } 
public void testRemoveNodeWithConnections ( ) { createSimpleConnection ( ) ; Node invert2Node = Node . ROOT . withName ( " invert2 " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , invert2Node ) ; controller . connect ( " / " , controller . getNode ( " /number " ) , invert2Node , invert2Node . getInput ( " value " ) ) ; assertEquals ( 2 , controller . getRootNode ( ) . getConnections ( ) . size ( ) ) ; controller . removeNode ( " / " , " number " ) ; assertEquals ( 0 , controller . getRootNode ( ) . getConnections ( ) . size ( ) ) ; } 
public void testConnectedNodeRenaming ( ) { createSimpleConnection ( ) ; controller . renameNode ( " / " , " negate " , " invert " ) ; assertEquals ( 1 , controller . getRootNode ( ) . getConnections ( ) . size ( ) ) ; Connection c = controller . getRootNode ( ) . getConnections ( ) . get ( 0 ) ; assertEquals ( " invert " , c . getInputNode ( ) ) ; assertEquals ( " value " , c . getInputPort ( ) ) ; assertEquals ( " number " , c . getOutputNode ( ) ) ; } 
public void testRemoveNodeWithRendered ( ) { Node alpha = Node . ROOT . withName ( " alpha " ) ; controller . addNode ( " / " , alpha ) ; controller . setRenderedChild ( " / " , " alpha " ) ; Node beta = Node . ROOT . withName ( " beta " ) ; controller . addNode ( " / " , beta ) ; assertEquals ( " alpha " , controller . getRootNode ( ) . getRenderedChildName ( ) ) ; controller . removeNode ( " / " , " beta " ) ; assertEquals ( " alpha " , controller . getRootNode ( ) . getRenderedChildName ( ) ) ; controller . removeNode ( " / " , " alpha " ) ; assertEquals ( " " , controller . getRootNode ( ) . getRenderedChildName ( ) ) ; assertNull ( controller . getRootNode ( ) . getRenderedChild ( ) ) ; } 
public void paste ( ) { addEdit ( " Paste node " ) ; if ( nodeClipboard = = null ) return ; List < Node > newNodes = controller . pasteNodes ( activeNetworkPath , nodeClipboard . network , nodeClipboard . nodes ) ; networkView . updateAll ( ) ; networkView . select ( newNodes ) ; setActiveNode ( newNodes . get ( 0 ) ) ; } 
public void testPasteNodes ( ) { createTestNetwork ( ) ; Now paste them controller.pasteNodes("/", controller.getRootNode(), ImmutableList.of(controller.getNode("/alpha"), controller.getNode("/beta"))); Node root = controller.getRootNode(); assertTrue(root.hasChild("alpha1")); assertTrue(root.hasChild("beta1")); assertTrue(root.isConnected("alpha1")); assertTrue(root.isConnected("beta1")); } 
public void testPasteOutputNode ( ) { createTestNetwork ( ) ; Now paste them controller.pasteNodes("/", controller.getRootNode(), ImmutableList.of(controller.getNode("/alpha"))); Node root = controller.getRootNode(); assertTrue(root.hasChild("alpha1")); assertTrue(root.isConnected("alpha")); assertTrue(root.isConnected("beta")); assertFalse(root.isConnected("alpha1")); } 
public void testPasteInputNode ( ) { createTestNetwork ( ) ; Now paste them controller.pasteNodes("/", controller.getRootNode(), ImmutableList.of(controller.getNode("/beta"))); Node root = controller.getRootNode(); assertTrue(root.hasChild("beta1")); assertTrue(root.isConnected("alpha")); assertTrue(root.isConnected("beta")); assertTrue(root.isConnected("beta1")); } 
public void testCopyPasteNodes ( ) { createTestNetwork ( ) ; Now paste them controller.pasteNodes("/", controller.getRootNode(), ImmutableList.of(controller.getNode("/alpha"), controller.getNode("/beta"))); Node root = controller.getRootNode(); assertTrue(root.hasChild("alpha1")); assertTrue(root.hasChild("beta1")); assertTrue(root.isConnected("alpha1")); assertTrue(root.isConnected("beta1")); } 
public void testCutPasteNodes ( ) { createTestNetwork ( ) ; Node root = controller . getRootNode ( ) ; Node alpha = controller . getNode ( " /alpha " ) ; Node beta = controller . getNode ( " /beta " ) ; controller . removeNode ( " / " , " alpha " ) ; controller . removeNode ( " / " , " beta " ) ; controller . pasteNodes ( " / " , root , ImmutableList . of ( alpha , beta ) ) ; assertTrue ( root . hasChild ( " alpha " ) ) ; assertTrue ( root . hasChild ( " beta " ) ) ; assertTrue ( root . isConnected ( " alpha " ) ) ; assertTrue ( root . isConnected ( " beta " ) ) ; } 
public void testPasteIntoSubnetwork ( ) { createTestNetwork ( ) ; controller . addNode ( " / " , Node . ROOT . withName ( " subnet " ) ) ; controller . pasteNodes ( " /subnet " , controller . getRootNode ( ) , ImmutableList . of ( controller . getNode ( " /alpha " ) , controller . getNode ( " /beta " ) ) ) ; Node subnet = controller . getNode ( " /subnet " ) ; assertTrue ( subnet . hasChild ( " alpha " ) ) ; assertTrue ( subnet . hasChild ( " beta " ) ) ; assertTrue ( subnet . isConnected ( " alpha " ) ) ; assertTrue ( subnet . isConnected ( " beta " ) ) ; } 
public void testPasteInputNodePartial ( ) { createTestNetwork ( ) ; Node root = controller . getRootNode ( ) ; controller . removeNode ( " / " , " alpha " ) ; Now paste them controller.pasteNodes("/", root, ImmutableList.of(controller.getNode("/beta"))); root = controller.getRootNode(); assertTrue(root.hasChild("beta1")); assertFalse(root.hasChild("alpha")); assertFalse(root.isConnected("beta")); assertFalse(root.isConnected("beta1")); } 
private void run ( ) { showProgressDialog ( ) ; startupWorker = new SwingWorker < Throwable , String > ( ) { @Override protected Throwable doInBackground ( ) throws Exception { try { publish ( " Starting NodeBox " ) ; setNodeBoxVersion ( ) ; createNodeBoxDataDirectories ( ) ; applyPreferences ( ) ; registerForMacOSXEvents ( ) ; updater = new Updater ( Application . this ) ; updater . checkForUpdatesInBackground ( ) ; initPython ( ) ; } catch ( RuntimeException ex ) { return ex ; } return null ; } @Override protected void process ( List < String > strings ) { final String firstString = strings . get ( 0 ) ; startupDialog . setMessage ( firstString ) ; } @Override protected void done ( ) { startingUp . set ( false ) ; startupDialog . setVisible ( false ) ; See if application startup has generated an exception. Throwable t; try { t = get(); } catch (Exception e) { t = e; } if (t != null) { ExceptionDialog ed = new ExceptionDialog(null, t); ed.setVisible(true); System.exit(-1); } if (documents.isEmpty() && filesToLoad.isEmpty()) { instance.createNewDocument(); } else { for (File f : filesToLoad) { openDocument(f); } } } }; startupWorker.execute(); } 
protected Throwable doInBackground ( ) throws Exception { try { publish ( " Starting NodeBox " ) ; setNodeBoxVersion ( ) ; createNodeBoxDataDirectories ( ) ; applyPreferences ( ) ; registerForMacOSXEvents ( ) ; updater = new Updater ( Application . this ) ; updater . checkForUpdatesInBackground ( ) ; initPython ( ) ; } catch ( RuntimeException ex ) { return ex ; } return null ; } 
private void initPython ( ) { Actually initializing Python happens in the library. lookForLibraries(); } 
public synchronized static void initializePython ( ) { if ( isInitialized . get ( ) ) return ; Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = Platform.getUserDataDirectory() + Platform.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. String workingDirectory = System.getProperty("user.dir"); File pythonLibraries = new File(workingDirectory, "lib" + Platform.SEP + "python.zip"); File nodeBoxLibraries = new File(workingDirectory, "lib" + Platform.SEP + "nodeboxlibs.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Py.getSystemState().path.add(new PyString(nodeBoxLibraries.getAbsolutePath())); This folder contains unarchived NodeBox libraries. Only used in development. File developmentLibraries = new File("src/python"); Py.getSystemState().path.add(new PyString(developmentLibraries.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(Platform.getUserPythonDirectory().getAbsolutePath())); isInitialized.set(true); } 
private static Future < ImmutableMap < String , Function > > loadScript ( final File file ) { FutureTask < ImmutableMap < String , Function > > task = new FutureTask < ImmutableMap < String , Function > > ( new Callable < ImmutableMap < String , Function > > ( ) { public ImmutableMap < String , Function > call ( ) throws Exception { This creates a dependency between function and the client. However, we need to know the load paths before we can do anything, so this is necessary. PythonUtils.initializePython(); Py.getSystemState().path.append(new PyString(file.getParentFile().getCanonicalPath())); PythonInterpreter interpreter = new PythonInterpreter(); try { interpreter.execfile(file.getCanonicalPath()); } catch (IOException e) { throw new LoadException(file.getName(), e); } catch (PyException e) { throw new LoadException(file.getName(), e); } PyStringMap map = (PyStringMap) interpreter.getLocals(); ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder(); for (Object key : map.keys()) { Object o = map.get(Py.java2py(key)); if (o instanceof PyFunction) { String name = (String) key; Function f = new PythonFunction(name, (PyFunction) o); builder.put(name, f); } } return builder.build(); } }); Thread t = new Thread(task); t.start(); return task; } 
public ImmutableMap < String , Function > call ( ) throws Exception { This creates a dependency between function and the client. However, we need to know the load paths before we can do anything, so this is necessary. PythonUtils.initializePython(); Py.getSystemState().path.append(new PyString(file.getParentFile().getCanonicalPath())); PythonInterpreter interpreter = new PythonInterpreter(); try { interpreter.execfile(file.getCanonicalPath()); } catch (IOException e) { throw new LoadException(file.getName(), e); } catch (PyException e) { throw new LoadException(file.getName(), e); } PyStringMap map = (PyStringMap) interpreter.getLocals(); ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder(); for (Object key : map.keys()) { Object o = map.get(Py.java2py(key)); if (o instanceof PyFunction) { String name = (String) key; Function f = new PythonFunction(name, (PyFunction) o); builder.put(name, f); } } return builder.build(); } 
public boolean hasFunction ( String name ) { return getFunctionMap ( ) . containsKey ( name ) ; } 
public int hashCode ( ) { return Objects . hashCode ( inputNode , inputPort , publishedName ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof PublishedPort ) ) return false ; final PublishedPort other = ( PublishedPort ) o ; return Objects . equal ( inputNode , other . inputNode ) & & Objects . equal ( inputPort , other . inputPort ) 
public String toString ( ) { return String . format ( " <PublishedPort %s : %s.%s> " , getPublishedName ( ) , getInputNode ( ) , getInputPort ( ) ) ; } 
public boolean isPublished ( String inputNode , String inputPort ) { for ( PublishedPort p : publishedInputs ) { if ( p . getInputNode ( ) . equals ( inputNode ) & & p . getInputPort ( ) . equals ( inputPort ) ) return true ; } return false ; } 
public Node publish ( String inputNode , String inputPort , String publishedName ) { checkNotNull ( publishedName , " Published name cannot be null. " ) ; checkArgument ( hasChild ( inputNode ) , " Node %s does not have a child named %s. " , this , inputNode ) ; Node input = getChild ( inputNode ) ; checkArgument ( input . hasInput ( inputPort ) , " Node %s does not have an input port %s. " , inputNode , inputPort ) ; checkArgument ( ! isPublished ( inputNode , inputPort ) , " The port %s on node %s has already been published. " , inputPort , inputNode ) ; PublishedPort newPublishedInput = new PublishedPort ( inputNode , inputPort , publishedName ) ; ImmutableList . Builder < PublishedPort > b = ImmutableList . builder ( ) ; for ( PublishedPort pp : getPublishedInputs ( ) ) b . add ( pp ) ; b . add ( newPublishedInput ) ; return newNodeWithAttribute ( Attribute . PUBLISHED_INPUTS , b . build ( ) ) ; } 
public Node withPublishedPortAdded ( PublishedPort p ) { return publish ( p . getInputNode ( ) , p . getInputPort ( ) , p . getPublishedName ( ) ) ; } 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; ImmutableList < PublishedPort > publishedInputs = this . publishedInputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case PUBLISHED_INPUTS : publishedInputs = ( ImmutableList < PublishedPort > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT, make the ROOT the prototype. if (prototype == null) { prototype = ROOT; } The name of a node can never be "_root". if (name.equals("_root")) { name = "node"; } return new Node(prototype, name, description, image, function, position, inputs, publishedInputs, outputType, outputRange, children, renderedChildName, connections, handle); 
public int hashCode ( ) { return Objects . hashCode ( prototype , name , description , image , function , position , inputs , publishedInputs , outputType , outputRange , children , renderedChildName , connections , handle ) ; 
public void testPublishInput ( ) { Node = net ; assertEquals ( 0 , . getPublishedInputs ( ) . size ( ) ) ; = . publish ( " number42 " , " number " , " pNumber " ) ; assertEquals ( 1 , . getPublishedInputs ( ) . size ( ) ) ; assertTrue ( . isPublished ( " number42 " , " number " ) ) ; } 
public void testPublishSameInputTwice ( ) { Node = net ; = . publish ( " number42 " , " number " , " pNumber " ) ; . publish ( " number42 " , " number " , " pNumber " ) ; } 
public void testUnpublishInput ( ) { Node = net ; = . publish ( " number42 " , " number " , " pNumber " ) ; assertEquals ( 1 , . getPublishedInputs ( ) . size ( ) ) ; = . unpublish ( " number42 " , " number " ) ; assertEquals ( 0 , . getPublishedInputs ( ) . size ( ) ) ; assertFalse ( . isPublished ( " number42 " , " number " ) ) ; } 
public void testPublishFromUnexistingChild ( ) { net . publish ( " number3 " , " number " , " pNumber " ) ; } 
public void testPublishFromUnexistingChildInput ( ) { net . publish ( " number42 " , " myNumber " , " pNumber " ) ; } 
public boolean hasPublishedInput ( String publishedName ) { for ( PublishedPort p : publishedInputs ) { if ( p . getPublishedName ( ) . equals ( publishedName ) ) return true ; } return false ; } 
public Node publish ( String inputNode , String inputPort , String publishedName ) { checkNotNull ( publishedName , " Published name cannot be null. " ) ; checkArgument ( hasChild ( inputNode ) , " Node %s does not have a child named %s. " , this , inputNode ) ; Node input = getChild ( inputNode ) ; checkArgument ( input . hasInput ( inputPort ) , " Node %s does not have an input port %s. " , inputNode , inputPort ) ; checkArgument ( ! isPublished ( inputNode , inputPort ) , " The port %s on node %s has already been published. " , inputPort , inputNode ) ; checkArgument ( ! hasPublishedInput ( publishedName ) , " Node %s already has a published input named %s. " , this , publishedName ) ; PublishedPort newPublishedInput = new PublishedPort ( inputNode , inputPort , publishedName ) ; ImmutableList . Builder < PublishedPort > b = ImmutableList . builder ( ) ; for ( PublishedPort pp : getPublishedInputs ( ) ) b . add ( pp ) ; b . add ( newPublishedInput ) ; return newNodeWithAttribute ( Attribute . PUBLISHED_INPUTS , b . build ( ) ) ; } 
public void testPublishSameInputTwice ( ) { net . publish ( " number42 " , " number " , " pNumber " ) . publish ( " number42 " , " number " , " pNumber " ) ; 
public void testAlreadyUsedPublishedName ( ) { net . withChildAdded ( number23Node ) . publish ( " number42 " , " number " , " pNumber " ) 
public void testUnpublishInput ( ) { Node = net ; = . publish ( " number42 " , " number " , " pNumber " ) ; assertEquals ( 1 , . getPublishedInputs ( ) . size ( ) ) ; = . unpublish ( " number42 " , " number " ) ; assertEquals ( 0 , . getPublishedInputs ( ) . size ( ) ) ; assertFalse ( . isPublished ( " number42 " , " number " ) ) ; = . publish ( " number42 " , " number " , " aNumber " ) ; assertEquals ( 1 , . getPublishedInputs ( ) . size ( ) ) ; assertTrue ( . hasPublishedInput ( " aNumber " ) ) ; = . unpublish ( " aNumber " ) ; assertEquals ( 0 , . getPublishedInputs ( ) . size ( ) ) ; assertFalse ( . hasPublishedInput ( " aNumber " ) ) ; } 
public Node withInputAdded ( Port port ) { checkNotNull ( port , " Port cannot be null. " ) ; checkArgument ( ! hasInput ( port . getName ( ) ) , " An input port named %s already exists on node %s. " , port . getName ( ) , this ) ; ImmutableList . Builder < Port > b = ImmutableList . builder ( ) ; b . addAll ( inputs ) ; b . add ( port ) ; return newNodeWithAttribute ( Attribute . INPUTS , b . build ( ) ) ; } 
public Node withInputRemoved ( String portName ) { Port portToRemove = getInput ( portName ) ; checkArgument ( portToRemove ! = null , " Input port %s does not exist on node %s. " , portName , this ) ; if ( hasPublishedInput ( portName ) ) return unpublish ( portName ) ; ImmutableList . Builder < Port > b = ImmutableList . builder ( ) ; for ( Port port : inputs ) { if ( portToRemove ! = port ) b . add ( port ) ; } return newNodeWithAttribute ( Attribute . INPUTS , b . build ( ) ) ; } 
public boolean hasPublishedChildInput ( String inputNode , String inputPort ) { for ( PublishedPort p : publishedInputs ) { if ( p . getInputNode ( ) . equals ( inputNode ) & & p . getInputPort ( ) . equals ( inputPort ) ) return true ; } return false ; } 
public boolean hasPublishedChildInputs ( String inputNode ) { for ( PublishedPort p : publishedInputs ) { if ( p . getInputNode ( ) . equals ( inputNode ) ) return true ; } return false ; } 
public void testPublishInput ( ) { Node = net ; assertEquals ( 0 , . getPublishedInputs ( ) . size ( ) ) ; = . publish ( " number42 " , " number " , " pNumber " ) ; assertEquals ( 1 , . getPublishedInputs ( ) . size ( ) ) ; assertTrue ( . hasPublishedChildInput ( " number42 " , " number " ) ) ; } 
public void testUnpublishInput ( ) { Node = net ; = . publish ( " number42 " , " number " , " pNumber " ) ; assertEquals ( 1 , . getPublishedInputs ( ) . size ( ) ) ; = . unpublish ( " number42 " , " number " ) ; assertEquals ( 0 , . getPublishedInputs ( ) . size ( ) ) ; assertFalse ( . hasPublishedChildInput ( " number42 " , " number " ) ) ; = . publish ( " number42 " , " number " , " aNumber " ) ; assertEquals ( 1 , . getPublishedInputs ( ) . size ( ) ) ; assertTrue ( . hasPublishedInput ( " aNumber " ) ) ; = . unpublish ( " aNumber " ) ; assertEquals ( 0 , . getPublishedInputs ( ) . size ( ) ) ; assertFalse ( . hasPublishedInput ( " aNumber " ) ) ; } 
private Node withChildInputChanged ( String childName , String portName , Port newPort ) { todo: checks return withChildReplaced(childName, getChild(childName).withInputChanged(portName, newPort)); } 
public boolean hasPublishedInput ( String publishedName ) { return getPublishedInput ( publishedName ) ! = null ; } 
public void testRenderNetworkWithPublishedPort ( ) { Node subnet = createSubnetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " value1 " ) . publish ( " number2 " , " number " , " value2 " ) . withInputValue ( " value1 " , 2.0 ) . withInputValue ( " value2 " , 3.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withRenderedChildName ( " subnet1 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 5.0 ) ; } 
public void testRenderNetworkWithConnectedPublishedPort ( ) { Node subnet = createSubnetwork ( " subnet1 " , 0.0 , 1.0 ) . publish ( " number1 " , " number " , " value1 " ) . withInputValue ( " value1 " , 2.0 ) ; Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 10.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withChildAdded ( number1 ) . withRenderedChildName ( " subnet1 " ) . connect ( " number1 " , " subnet1 " , " value1 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 11.0 ) ; } 
public static NodePort of ( String nodeName , String portName ) { return new NodePort ( nodeName , portName ) ; } 
public static NodePort of ( String node , String port ) { return new NodePort ( node , port ) ; } 
public void testRenderNetworkWithPublishedPorts ( ) { Node subnet = createSubnetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " value1 " ) . publish ( " number2 " , " number " , " value2 " ) . withInputValue ( " value1 " , 2.0 ) . withInputValue ( " value2 " , 3.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withRenderedChildName ( " subnet1 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 5.0 ) ; } 
public void testRenderNetworkWithConnectedPublishedPorts ( ) { Node subnet = createSubnetwork ( " subnet1 " , 0.0 , 1.0 ) . publish ( " number1 " , " number " , " value1 " ) . withInputValue ( " value1 " , 2.0 ) ; Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 10.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withChildAdded ( number1 ) . withRenderedChildName ( " subnet1 " ) . connect ( " number1 " , " subnet1 " , " value1 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 11.0 ) ; } 
public void testRenderNestedNetworkWithConnectedPublishedPorts ( ) { Node subnet1 = createSubnetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node subnet2 = createSubnetwork ( " subnet2 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node subnet = Node . ROOT . withName ( " subnet " ) . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) . publish ( " subnet1 " , " n1 " , " value1 " ) . publish ( " subnet1 " , " n2 " , " value2 " ) . publish ( " subnet2 " , " n1 " , " value3 " ) . publish ( " subnet2 " , " n2 " , " value4 " ) ; Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 11.0 ) ; Node number2 = numberNode . extend ( ) . withName ( " number2 " ) . withInputValue ( " number " , 22.0 ) ; Node number3 = numberNode . extend ( ) . withName ( " number3 " ) . withInputValue ( " number " , 33.0 ) ; Node number4 = numberNode . extend ( ) . withName ( " number4 " ) . withInputValue ( " number " , 44.0 ) ; Node net = Node . ROOT . withChildAdded ( number1 ) . withChildAdded ( number2 ) . withChildAdded ( number3 ) . withChildAdded ( number4 ) . withChildAdded ( subnet ) . withRenderedChildName ( " subnet " ) . connect ( " number1 " , " subnet " , " value1 " ) . connect ( " number2 " , " subnet " , " value2 " ) . connect ( " number3 " , " subnet " , " value3 " ) . connect ( " number4 " , " subnet " , " value4 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 110.0 ) ; } 
public void connect ( String parentPath , String outputNode , String inputNode , String inputPort ) { Node newParent = getNode ( parentPath ) . connect ( outputNode , inputNode , inputPort ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
public void publish ( String parentPath , String childNode , String childPort , String publishedName ) { Node newParent = getNode ( parentPath ) . publish ( childNode , childPort , publishedName ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
public void unpublish ( String parentPath , String publishedName ) { Node newParent = getNode ( parentPath ) . unpublish ( publishedName ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
public void testPublish ( ) { Node invertNode = Node . ROOT . withName ( " negate " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , Node . ROOT . withName ( " subnet " ) ) ; controller . addNode ( " /subnet " , invertNode ) ; controller . setRenderedChild ( " /subnet " , " negate " ) ; controller . publish ( " /subnet " , " negate " , " value " , " " ) ; assertTrue ( controller . getNode ( " /subnet " ) . hasPublishedInput ( " " ) ) ; controller . setPortValue ( " /subnet " , " " , 42.0 ) ; assertEquals ( 42 , controller . getNode ( " /subnet/negate " ) . getInput ( " value " ) . intValue ( ) ) ; Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 20 ) ) ; controller . addNode ( " / " , numberNode ) ; controller . connect ( " / " , " number " , " subnet " , " " ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet " ) , - 20.0 ) ; controller . setPortValue ( " /number " , " value " , 55.0 ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet " ) , - 55.0 ) ; } 
public void testSimpleUnpublish ( ) { Node invertNode = Node . ROOT . withName ( " negate " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , Node . ROOT . withName ( " subnet " ) ) ; controller . addNode ( " /subnet " , invertNode ) ; controller . publish ( " /subnet " , " negate " , " value " , " " ) ; controller . unpublish ( " /subnet " , " " ) ; assertFalse ( controller . getNode ( " /subnet " ) . hasPublishedInput ( " " ) ) ; } 
private static void writePublishedInput ( Document doc , Element parent , PublishedPort publishedInput ) { Element publishedPortElement = doc . createElement ( " publishedPort " ) ; publishedPortElement . setAttribute ( " childPort " , String . format ( " %s.%s " , publishedInput . getInputNode ( ) , publishedInput . getInputPort ( ) ) ) ; publishedPortElement . setAttribute ( " name " , String . format ( " %s " , publishedInput . getPublishedName ( ) ) ) ; parent . appendChild ( publishedPortElement ) ; } 
private static Node parseNode ( XMLStreamReader reader , Node parent , NodeRepository nodeRepository ) throws XMLStreamException { String prototypeId = reader . getAttributeValue ( null , " prototype " ) ; String name = reader . getAttributeValue ( null , " name " ) ; String description = reader . getAttributeValue ( null , " description " ) ; String image = reader . getAttributeValue ( null , " image " ) ; String function = reader . getAttributeValue ( null , " function " ) ; String outputType = reader . getAttributeValue ( null , " outputType " ) ; String outputRange = reader . getAttributeValue ( null , " outputRange " ) ; String position = reader . getAttributeValue ( null , " position " ) ; String renderedChildName = reader . getAttributeValue ( null , " renderedChild " ) ; String handle = reader . getAttributeValue ( null , " handle " ) ; Node prototype = prototypeId = = null ? Node . ROOT : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) { throw new XMLStreamException ( " Prototype " + prototypeId + " could not be found. " , reader . getLocation ( ) ) ; } Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputType ! = null ) node = node . withOutputType ( outputType ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " node " ) ) { node = node . withChildAdded ( parseNode ( reader , node , nodeRepository ) ) ; } else if ( tagName . equals ( " publishedPort " ) ) { node = node . withPublishedPortAdded ( parsePublishedPort ( reader ) ) ; } else if ( tagName . equals ( " port " ) ) { String portName = reader . getAttributeValue ( null , " name " ) ; Remove the port if it is already on the prototype. if (node.hasInput(portName)) { node = node.withInputChanged(portName, parsePort(reader, node.getInput(portName))); } else { node = node.withInputAdded(parsePort(reader, null)); } } else if (tagName.equals("conn")) { node = node.withConnectionAdded(parseConnection(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("node")) break; } } This has to come at the end, since the child first needs to exist. if (renderedChildName != null) node = node.withRenderedChildName(renderedChildName); return node; } 
private static PublishedPort parsePublishedPort ( XMLStreamReader reader ) throws XMLStreamException { String child = reader . getAttributeValue ( null , " childPort " ) ; Iterator < String > inputIterator = PORT_NAME_SPLITTER . split ( child ) . iterator ( ) ; String childNode = inputIterator . next ( ) ; String childPort = inputIterator . next ( ) ; String publishedName = reader . getAttributeValue ( null , " name " ) ; return new PublishedPort ( childNode , childPort , publishedName ) ; } 
public void testPublishedPortSerialization ( ) { Node inner = Node . ROOT . withName ( " inner " ) . withInputAdded ( Port . floatPort ( " value " , 0.0 ) ) . withFunction ( " math/number " ) ; Node outer = Node . ROOT . withName ( " outer " ) . withChildAdded ( inner ) . publish ( " inner " , " value " , " v " ) . withInputValue ( " v " , 11.0 ) ; assertEquals ( 11 , outer . getChild ( " inner " ) . getInput ( " value " ) . intValue ( ) ) ; NodeLibrary originalLibrary = libraryWithChildren ( " test " , outer ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; assertTrue ( library . getNodeForPath ( " /outer " ) . hasPublishedInput ( " v " ) ) ; assertEquals ( 11 , library . getNodeForPath ( " /outer/inner " ) . getInput ( " value " ) . intValue ( ) ) ; } 
private static void writePublishedInput ( Document doc , Element parent , PublishedPort publishedInput ) { Element publishedPortElement = doc . createElement ( " publishedPort " ) ; publishedPortElement . setAttribute ( " ref " , String . format ( " %s.%s " , publishedInput . getChildNode ( ) , publishedInput . getChildPort ( ) ) ) ; publishedPortElement . setAttribute ( " name " , String . format ( " %s " , publishedInput . getPublishedName ( ) ) ) ; parent . appendChild ( publishedPortElement ) ; } 
private static PublishedPort parsePublishedPort ( XMLStreamReader reader ) throws XMLStreamException { String child = reader . getAttributeValue ( null , " ref " ) ; Iterator < String > inputIterator = PORT_NAME_SPLITTER . split ( child ) . iterator ( ) ; String childNode = inputIterator . next ( ) ; String childPort = inputIterator . next ( ) ; String publishedName = reader . getAttributeValue ( null , " name " ) ; return new PublishedPort ( childNode , childPort , publishedName ) ; } 
public boolean hasPublishedChildInput ( String inputNode , String inputPort ) { for ( PublishedPort p : publishedInputs ) { if ( p . getChildNode ( ) . equals ( inputNode ) & & p . getChildPort ( ) . equals ( inputPort ) ) return true ; } return false ; } 
public boolean hasPublishedChildInputs ( String inputNode ) { for ( PublishedPort p : publishedInputs ) { if ( p . getChildNode ( ) . equals ( inputNode ) ) return true ; } return false ; } 
public Node withPublishedPortAdded ( PublishedPort p ) { return publish ( p . getChildNode ( ) , p . getChildPort ( ) , p . getPublishedName ( ) ) ; } 
public int hashCode ( ) { return Objects . hashCode ( childNode , childPort , publishedName ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof PublishedPort ) ) return false ; final PublishedPort other = ( PublishedPort ) o ; return Objects . equal ( childNode , other . childNode ) & & Objects . equal ( childPort , other . childPort ) 
public String toString ( ) { return String . format ( " <PublishedPort %s : %s.%s> " , getPublishedName ( ) , getChildNode ( ) , getChildPort ( ) ) ; } 
public Node withChildInputRemoved ( String childName , String portName ) { checkArgument ( hasChild ( childName ) , " Node %s does not have a child named %s. " , this , childName ) ; Node child = getChild ( childName ) ; checkArgument ( child . hasInput ( portName ) , " Node %s does not have an input port %s. " , childName , portName ) ; if ( hasPublishedChildInput ( childName , portName ) ) return unpublish ( childName , portName ) . withChildInputRemoved ( childName , portName ) ; if ( isConnected ( childName , portName ) ) return disconnect ( childName , portName ) . withChildInputRemoved ( childName , portName ) ; return withChildReplaced ( childName , child . withInputRemoved ( portName ) ) ; } 
public void removePort ( String parentPath , String nodeName , String portName ) { Node newParent = getNode ( parentPath ) . withChildInputRemoved ( nodeName , portName ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
public void addPortMenuItem ( String nodePath , String portName , String key , String label ) { Node node = getNode ( nodePath ) ; Port newPort = node . getInput ( portName ) . withMenuItemAdded ( key , label ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public void removePortMenuItem ( String nodePath , String portName , MenuItem menuItem ) { Node node = getNode ( nodePath ) ; Port newPort = node . getInput ( portName ) . withMenuItemRemoved ( menuItem ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public void movePortMenuItem ( String nodePath , String portName , int index , boolean up ) { Node node = getNode ( nodePath ) ; Port newPort = node . getInput ( portName ) . withMenuItemMoved ( index , up ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public void updatePortMenuItem ( String nodePath , String portName , int index , String key , String label ) { Node node = getNode ( nodePath ) ; Port newPort = node . getInput ( portName ) . withMenuItemChanged ( index , key , label ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public Port withMenuItemAdded ( String key , String label ) { ImmutableList . Builder < MenuItem > b = ImmutableList . builder ( ) ; b . addAll ( menuItems ) ; b . add ( new MenuItem ( key , label ) ) ; return withMenuItems ( b . build ( ) ) ; } 
public Port withMenuItemRemoved ( MenuItem menuItem ) { ImmutableList . Builder < MenuItem > b = ImmutableList . builder ( ) ; for ( MenuItem item : menuItems ) { if ( item . equals ( menuItem ) ) { Do nothing } else { b.add(item); } } return withMenuItems(b.build()); } 
public Port withMenuItemMoved ( int index , boolean up ) { checkArgument ( index < 0 | | index > = menuItems . size ( ) ) ; List < MenuItem > items = new ArrayList < MenuItem > ( 0 ) ; items . addAll ( menuItems ) ; MenuItem item = items . get ( index ) ; items . remove ( item ) ; if ( up ) items . add ( index - 1 , item ) ; else items . add ( index + 1 , item ) ; return withMenuItems ( ImmutableList . copyOf ( items ) ) ; } 
public Port withMenuItemChanged ( int index , String key , String label ) { checkArgument ( index < 0 | | index > = menuItems . size ( ) ) ; List < MenuItem > items = new ArrayList < MenuItem > ( 0 ) ; items . addAll ( menuItems ) ; items . set ( index , new MenuItem ( key , label ) ) ; return withMenuItems ( ImmutableList . copyOf ( items ) ) ; } 
public void renameNode ( String parentPath , String oldName , String newName ) { Node newParent = getNode ( parentPath ) . withChildRenamed ( oldName , newName ) ; replaceNodeInPath ( parentPath , newParent ) ; } 
public List < Node > pasteNodes ( String parentPath , Node nodesParent , Iterable < Node > nodes ) { Node parent = getNode ( parentPath ) ; Node newParent = parent . withChildrenAdded ( nodesParent , nodes ) ; replaceNodeInPath ( parentPath , newParent ) ; return ImmutableList . copyOf ( Iterables . skip ( newParent . getChildren ( ) , parent . getChildren ( ) . size ( ) ) ) ; } 
public static ClojureLibrary loadScript ( File baseFile , String fileName ) throws LoadException { File file ; if ( baseFile ! = null ) { file = new File ( baseFile . getAbsoluteFile ( ) , fileName ) ; } else { file = new File ( fileName ) ; } return loadScript ( file ) ; } 
private static ClojureLibrary loadScript ( File file ) { Object returnValue ; try { returnValue = Compiler . loadFile ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { throw new LoadException ( file , e ) ; } We need a Var as the last statement, because we need to retrieve the current namespace. if (!(returnValue instanceof Var)) { throw new LoadException(file, String.format("The last statement does not define a var, but %s." + "Make sure the last line of your script looks like this:" + "(def nodes [{:name \"foo\" :fn inc}])", returnValue)); } Var nodesVar = (Var) returnValue; Namespace ns = nodesVar.ns; String namespace = ns.name.getName(); Object functionMap = nodesVar.deref(); checkStructure(functionMap); ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder(); for (Object item : (Iterable) functionMap) { Map m = (Map) item; String name = (String) m.get(NAME); IFn fn = (IFn) m.get(FN); Function f = new ClojureFunction(name, fn); builder.put(name, f); } return new ClojureLibrary(namespace, file, builder.build()); } 
public void reload ( ) { ClojureLibrary reloadedLibrary = loadScript ( file ) ; if ( ! reloadedLibrary . namespace . equals ( namespace ) ) throw new RuntimeException ( " The namespace of a function library should not be changed. " ) ; this . functionMap = reloadedLibrary . functionMap ; } 
public static PythonLibrary loadScript ( String namespace , File baseFile , String fileName ) throws LoadException { File file ; if ( baseFile ! = null ) { file = new File ( baseFile , fileName ) ; } else { file = new File ( fileName ) ; } if ( ! file . exists ( ) ) { throw new LoadException ( file , " Library does not exist. " ) ; } return new PythonLibrary ( namespace , file , loadScript ( file ) ) ; } 
private static Future < ImmutableMap < String , Function > > loadScript ( final File file ) { FutureTask < ImmutableMap < String , Function > > task = new FutureTask < ImmutableMap < String , Function > > ( new Callable < ImmutableMap < String , Function > > ( ) { public ImmutableMap < String , Function > call ( ) throws Exception { This creates a dependency between function and the client. However, we need to know the load paths before we can do anything, so this is necessary. PythonUtils.initializePython(); Py.getSystemState().path.append(new PyString(file.getParentFile().getCanonicalPath())); PythonInterpreter interpreter = new PythonInterpreter(); try { interpreter.execfile(file.getCanonicalPath()); } catch (IOException e) { throw new LoadException(file, e); } catch (PyException e) { throw new LoadException(file, e); } PyStringMap map = (PyStringMap) interpreter.getLocals(); ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder(); for (Object key : map.keys()) { Object o = map.get(Py.java2py(key)); if (o instanceof PyFunction) { String name = (String) key; Function f = new PythonFunction(name, (PyFunction) o); builder.put(name, f); } } return builder.build(); } }); Thread t = new Thread(task); t.start(); return task; } 
public ImmutableMap < String , Function > call ( ) throws Exception { This creates a dependency between function and the client. However, we need to know the load paths before we can do anything, so this is necessary. PythonUtils.initializePython(); Py.getSystemState().path.append(new PyString(file.getParentFile().getCanonicalPath())); PythonInterpreter interpreter = new PythonInterpreter(); try { interpreter.execfile(file.getCanonicalPath()); } catch (IOException e) { throw new LoadException(file, e); } catch (PyException e) { throw new LoadException(file, e); } PyStringMap map = (PyStringMap) interpreter.getLocals(); ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder(); for (Object key : map.keys()) { Object o = map.get(Py.java2py(key)); if (o instanceof PyFunction) { String name = (String) key; Function f = new PythonFunction(name, (PyFunction) o); builder.put(name, f); } } return builder.build(); } 
private static Method upgradeMethod ( String methodName ) { try { return NodeLibrary . class . getMethod ( methodName , String . class ) ; 
public static String parseFormatVersion ( String xml ) { Matcher m = formatVersionPattern . matcher ( xml ) ; if ( ! m . find ( ) ) throw new RuntimeException ( " Invalid NodeBox file: " + xml ) ; return m . group ( 1 ) ; } 
private static String readFile ( File file ) { try { return Files . toString ( file , Charsets . UTF_8 ) ; 
public static UpgradeResult upgrade ( File file ) throws LoadException { return upgradeTo ( file , CURRENT_FORMAT_VERSION ) ; } 
public static UpgradeResult upgradeTo ( File file , String targetVersion ) throws LoadException { String currentXml = readFile ( file ) ; String currentVersion = parseFormatVersion ( currentXml ) ; ArrayList < String > warnings = new ArrayList < String > ( ) ; Avoid upgrades getting stuck in an infinite loop. int tries = 0; while (!currentVersion.equals(targetVersion) && tries < 100) { Method upgradeMethod = upgradeMap.get(currentVersion); if (upgradeMethod == null) { throw new LoadException(file, "Unsupported version " + currentVersion + ": this file is too old or too new."); } try { UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, readFile(file)); warnings.addAll(result.warnings); currentXml = result.xml; } catch (Exception e) { throw new LoadException(file, "Upgrading to " + currentVersion + " failed.", e); } currentVersion = parseFormatVersion(currentXml); tries++; } if (tries >= 100) { throw new LoadException(file, "Got stuck in an infinite loop when trying to upgrade from " + currentVersion); } return new UpgradeResult(file, currentXml, warnings); } 
public static UpgradeStringResult upgrade1to2 ( String inputXml ) throws LoadException { Version 2: Vertical node networks 1. Rotate all nodes 90 degrees by reversing X and Y positions. 2. Convert from pixel units to grid units by dividing by GRID_CELL_SIZE. final int GRID_CELL_SIZE = 48; return transformXml(inputXml, "2", new Function<Element, String>() { @Override 
public String apply ( Element node ) { Attribute position = node . getAttribute ( " position " ) ; if ( position ! = null ) { Point pt = Point . valueOf ( position . getValue ( ) ) ; Point reversedPoint = new Point ( pt . y , pt . x ) ; Point gridPoint = new Point ( Math . round ( reversedPoint . x / GRID_CELL_SIZE ) , Math . round ( reversedPoint . y / GRID_CELL_SIZE ) ) ; node . addAttribute ( new Attribute ( " position " , String . valueOf ( gridPoint ) ) ) ; } return null ; } 
private static UpgradeStringResult transformXml ( String xml , String newFormatVersion , Function < Element , String > function ) { try { Document document = new Builder ( ) . build ( xml , null ) ; 
private static UpgradeStringResult transformDocument ( Document document , String newFormatVersion , Function < Element , String > function ) { Check that this is a NodeBox document and set the new formatVersion. Element root = document.getRootElement(); checkArgument(root.getLocalName().equals("ndbx"), "This is not a valid NodeBox document."); root.addAttribute(new Attribute("formatVersion", newFormatVersion)); Recursively transform all nodes. ArrayList<String> warnings = new ArrayList<String>(); transformNodesRecursive(root, function, warnings); return new UpgradeStringResult(document.toXML(), ImmutableList.copyOf(warnings)); } 
private static void transformNodesRecursive ( Element parent , Function < Element , String > function , List < String > warnings ) { Elements nodes = parent . getChildElements ( " node " ) ; for ( int i = 0 ; i < nodes . size ( ) ; i + + ) { Element node = nodes . get ( i ) ; 
private static NodeLibrary load ( String libraryName , File file , Reader r , NodeRepository nodeRepository ) throws XMLStreamException { XMLInputFactory xmlInputFactory = XMLInputFactory . newInstance ( ) ; XMLStreamReader reader = xmlInputFactory . createXMLStreamReader ( r ) ; NodeLibrary nodeLibrary = null ; while ( reader . hasNext ( ) ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) { String formatVersion = reader . getAttributeValue ( null , " formatVersion " ) ; if ( ! CURRENT_FORMAT_VERSION . equals ( formatVersion ) ) { throw new OutdatedLibraryException ( file , " File uses version " + formatVersion + " , current version is " + CURRENT_FORMAT_VERSION + " . " ) ; } String uuidString = reader . getAttributeValue ( null , " uuid " ) ; UUID uuid = ( uuidString = = null ) ? UUID . randomUUID ( ) : UUID . fromString ( uuidString ) ; nodeLibrary = parseNDBX ( libraryName , file , reader , nodeRepository , uuid ) ; } else { throw new XMLStreamException ( " Only tag ndbx allowed, not " + tagName , reader . getLocation ( ) ) ; } } } return nodeLibrary ; } 
private static String errorMessage ( File file , Object message ) { return " Error while loading " + ( file = = null ? " unknown " : file . getName ( ) ) 
public void testParseFormatVersion ( ) { assertEquals ( " 1.0 " , NodeLibrary . parseFormatVersion ( " <ndbx formatVersion='1.0'> " ) ) ; assertEquals ( " 2 " , NodeLibrary . parseFormatVersion ( " <ndbx type= \" file \" formatVersion= \" 2 \" > " ) ) ; } 
public void testUpgrade1to2 ( ) { File version1File = new File ( " test/files/upgrade-v1.ndbx " ) ; UpgradeResult result = NodeLibrary . upgradeTo ( version1File , " 2 " ) ; assertTrue ( " Result should contain updated position: " + result . getXml ( ) , result . getXml ( ) . contains ( " position= \" 4.00,2.00 \" " ) ) ; TODO We can't use these checks yet since the current version is still 1.0. 
public void testTooOldToUpgrade ( ) { File version09File = new File ( " test/files/upgrade-v0.9.ndbx " ) ; try { NodeLibrary . upgrade ( version09File ) ; 
public void testTooNewToUpgrade ( ) { File version999Files = new File ( " test/files/upgrade-v999.ndbx " ) ; try { NodeLibrary . upgrade ( version999Files ) ; 
public void testAddMenuItem ( ) { Port p = menuItemsPort . withMenuItemAdded ( " keyD " , " labelD " ) ; assertEquals ( 4 , p . getMenuItems ( ) . size ( ) ) ; assertEquals ( new MenuItem ( " keyD " , " labelD " ) , p . getMenuItems ( ) . get ( 3 ) ) ; } 
public void testRemoveMenuItem ( ) { Port p = menuItemsPort . withMenuItemRemoved ( new MenuItem ( " keyC " , " labelC " ) ) ; assertEquals ( 2 , p . getMenuItems ( ) . size ( ) ) ; } 
public void movePortMenuItemDown ( String portName , int itemIndex ) { checkValidPort ( portName ) ; addEdit ( " Move Port Item Down " ) ; controller . movePortMenuItemDown ( getActiveNodePath ( ) , portName , itemIndex ) ; portView . updateAll ( ) ; } 
public void movePortMenuItemUp ( String portName , int itemIndex ) { checkValidPort ( portName ) ; addEdit ( " Move Port Item Up " ) ; controller . movePortMenuItemUp ( getActiveNodePath ( ) , portName , itemIndex ) ; portView . updateAll ( ) ; } 
public void movePortMenuItemUp ( String nodePath , String portName , int index ) { Node node = getNode ( nodePath ) ; Port newPort = node . getInput ( portName ) . withMenuItemMovedUp ( index ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public void movePortMenuItemDown ( String nodePath , String portName , int index ) { Node node = getNode ( nodePath ) ; Port newPort = node . getInput ( portName ) . withMenuItemMovedDown ( index ) ; Node newNode = node . withInputChanged ( portName , newPort ) ; replaceNodeInPath ( nodePath , newNode ) ; } 
public Port withMenuItemMovedUp ( int index ) { checkArgument ( 0 < index & & index < menuItems . size ( ) ) ; return withMenuItemMoved ( index , index - 1 ) ; } 
public Port withMenuItemMovedDown ( int index ) { checkArgument ( 0 < = index & & index < menuItems . size ( ) - 1 ) ; return withMenuItemMoved ( index , index + 1 ) ; } 
private Port withMenuItemMoved ( int fromIndex , int toIndex ) { List < MenuItem > items = new ArrayList < MenuItem > ( 0 ) ; items . addAll ( menuItems ) ; MenuItem item = items . get ( fromIndex ) ; items . remove ( item ) ; items . add ( toIndex , item ) ; return withMenuItems ( ImmutableList . copyOf ( items ) ) ; } 
public Port withMenuItemChanged ( int index , String key , String label ) { checkArgument ( 0 < = index & & index < menuItems . size ( ) ) ; List < MenuItem > items = new ArrayList < MenuItem > ( 0 ) ; items . addAll ( menuItems ) ; items . set ( index , new MenuItem ( key , label ) ) ; return withMenuItems ( ImmutableList . copyOf ( items ) ) ; } 
public void testMoveMenuItem ( ) { Port p = menuItemsPort . withMenuItemMovedUp ( 2 ) ; assertEquals ( new MenuItem ( " keyC " , " labelC " ) , p . getMenuItems ( ) . get ( 1 ) ) ; p = p . withMenuItemMovedDown ( 0 ) ; assertEquals ( new MenuItem ( " keyA " , " labelA " ) , p . getMenuItems ( ) . get ( 1 ) ) ; } 
public void testMoveMenuItemMinIndex ( ) { menuItemsPort . withMenuItemMovedUp ( 0 ) ; } 
public void testMoveMenuItemMaxIndex ( ) { menuItemsPort . withMenuItemMovedDown ( menuItemsPort . getMenuItems ( ) . size ( ) - 1 ) ; } 
public void testChangeMenuItem ( ) { Port p = menuItemsPort . withMenuItemChanged ( 0 , " keyF " , " labelF " ) ; assertEquals ( new MenuItem ( " keyF " , " labelF " ) , p . getMenuItems ( ) . get ( 0 ) ) ; } 
private void lookForLibraries ( ) { NodeLibrary coreLibrary = NodeLibrary . load ( new File ( " libraries/core/core.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; systemRepository = NodeRepository . of ( coreLibrary , mathLibrary , stringLibrary , colorLibrary , listLibrary , dataLibrary , corevectorLibrary ) ; 
public static NodeBoxDocument load ( File file ) { NodeLibrary library ; NodeBoxDocument document ; try { library = NodeLibrary . load ( file , Application . getInstance ( ) . getSystemRepository ( ) ) ; document = new NodeBoxDocument ( library ) ; document . setDocumentFile ( file ) ; } catch ( OutdatedLibraryException e ) { UpgradeResult result = NodeLibrary . upgrade ( file ) ; The file is used here as the base name for finding relative libraries. library = result.getLibrary(file, Application.getInstance().getSystemRepository()); document = new NodeBoxDocument(library); document.showUpgradeResult(result); } catch (LoadException e) { throw new RuntimeException("Could not load " + file, e); } lastFilePath = file.getParentFile().getAbsolutePath(); return document; } 
private void showUpgradeResult ( UpgradeResult result ) { checkNotNull ( result ) ; if ( result . getWarnings ( ) . isEmpty ( ) ) return ; final UpgradeWarningsDialog dialog = new UpgradeWarningsDialog ( result ) ; dialog . setLocationRelativeTo ( this ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @Override 
public void run ( ) { dialog . setVisible ( true ) ; } 
private static NodeLibrary createNewLibrary ( ) { NodeRepository nodeRepository = Application . getInstance ( ) . getSystemRepository ( ) ; Node root = Node . ROOT . withName ( " root " ) ; Node rectPrototype = nodeRepository . getNode ( " corevector.rect " ) ; String name = root . uniqueName ( rectPrototype . getName ( ) ) ; Node rect1 = rectPrototype . extend ( ) . withName ( name ) . withPosition ( new nodebox . graphics . Point ( 1 , 1 ) ) ; root = root . withChildAdded ( rect1 ) . withRenderedChild ( rect1 ) ; return NodeLibrary . create ( " untitled " , root , nodeRepository , FunctionRepository . of ( ) ) ; } 
public void paste ( ) { addEdit ( " Paste node " ) ; if ( nodeClipboard = = null ) return ; List < Node > newNodes = controller . pasteNodes ( activeNetworkPath , nodeClipboard . network , nodeClipboard . nodes ) ; networkView . updateAll ( ) ; setActiveNode ( newNodes . get ( 0 ) ) ; networkView . select ( newNodes ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { dispose ( ) ; } 
public static NodeLibrary load ( String libraryName , String xml , File baseFile , NodeRepository nodeRepository ) throws LoadException { checkNotNull ( libraryName , " Library name cannot be null. " ) ; checkNotNull ( xml , " XML string cannot be null. " ) ; try { return load ( libraryName , baseFile , new StringReader ( xml ) , nodeRepository ) ; 
public static UpgradeStringResult upgrade1to2 ( String inputXml ) throws LoadException { Version 2: Vertical node networks 1. Rotate all nodes 90 degrees by reversing X and Y positions. 2. Convert from pixel units to grid units by dividing by GRID_CELL_SIZE. final int GRID_CELL_SIZE = 48; UpgradeStringResult result = transformXml(inputXml, "2", new Function<Element, String>() { @Override public String apply(Element node) { Attribute position = node.getAttribute("position"); if (position != null) { Point pt = Point.valueOf(position.getValue()); Point reversedPoint = new Point(pt.y, pt.x); Point gridPoint = new Point(Math.round(reversedPoint.x / GRID_CELL_SIZE) * 3, Math.round(reversedPoint.y / GRID_CELL_SIZE)); node.addAttribute(new Attribute("position", String.valueOf(gridPoint))); } return null; } }); result.warnings.add("Nodes have been rotated. Your network will look different."); return result; } 
public String apply ( Element node ) { Attribute position = node . getAttribute ( " position " ) ; if ( position ! = null ) { Point pt = Point . valueOf ( position . getValue ( ) ) ; Point reversedPoint = new Point ( pt . y , pt . x ) ; Point gridPoint = new Point ( Math . round ( reversedPoint . x / GRID_CELL_SIZE ) * 3 , Math . round ( reversedPoint . y / GRID_CELL_SIZE ) ) ; node . addAttribute ( new Attribute ( " position " , String . valueOf ( gridPoint ) ) ) ; } return null ; } 
private static UpgradeStringResult transformDocument ( Document document , String newFormatVersion , Function < Element , String > function ) { Check that this is a NodeBox document and set the new formatVersion. Element root = document.getRootElement(); checkArgument(root.getLocalName().equals("ndbx"), "This is not a valid NodeBox document."); root.addAttribute(new Attribute("formatVersion", newFormatVersion)); Recursively transform all nodes. ArrayList<String> warnings = new ArrayList<String>(); transformNodesRecursive(root, function, warnings); return new UpgradeStringResult(document.toXML(), warnings); } 
public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . setColor ( topColor ) ; g . drawLine ( x , y , x + width , y ) ; } 
public void testWritePrototypeFirst ( ) { We execute the test multiple times with the names switched to avoid that the order is accidentally correct. This can happen because of the hashing algorithm. assertPrototypeBeforeInstance("alpha", "beta", "gamma"); assertPrototypeBeforeInstance("beta", "alpha", "gamma"); assertPrototypeBeforeInstance("gamma", "alpha", "beta"); } 
private void assertPrototypeBeforeInstance ( String prototypeName , String . . . instanceNames ) { Node originalPrototype = Node . ROOT . withName ( prototypeName ) ; Node network = Node . ROOT . withChildAdded ( originalPrototype ) ; for ( String instanceName : instanceNames ) { Node originalInstance = originalPrototype . extend ( ) . withName ( instanceName ) ; network = network . withChildAdded ( originalInstance ) ; } NodeLibrary originalLibrary = NodeLibrary . create ( " test " , network ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Node prototype = library . getRoot ( ) . getChild ( prototypeName ) ; for ( String instanceName : instanceNames ) { Node instance = library . getRoot ( ) . getChild ( instanceName ) ; 
public void testUpgrade1to2 ( ) { File version1File = new File ( " test/files/upgrade-v1.ndbx " ) ; UpgradeResult result = NodeLibrary . upgradeTo ( version1File , " 2 " ) ; assertTrue ( " Result should contain updated position: " + result . getXml ( ) , result . getXml ( ) . contains ( " position= \" 12.00,2.00 \" " ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version1File , NodeRepository . of ( ) ) ; Node root = upgradedLibrary . getRoot ( ) ; Node alpha = root . getChild ( " alpha " ) ; assertEquals ( new Point ( 12 , 2 ) , alpha . getPosition ( ) ) ; } 
public void call ( List < Object > arguments , List < Object > results ) ; } private static final class Conversions { private static Iterable < ? > geometryToPoints ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . addAll ( ( Iterable < ? > ) ( ( IGeometry ) o ) . getPoints ( ) ) ; return b . build ( ) ; } private static Iterable < ? > doubleToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Long ) ( Math . round ( ( Double ) o ) ) ) . intValue ( ) ) ; return b . build ( ) ; } private static Iterable < ? > toString ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( o . toString ( ) ) ; return b . build ( ) ; } } ; } 
private static Iterable < ? > geometryToPoints ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . addAll ( ( Iterable < ? > ) ( ( IGeometry ) o ) . getPoints ( ) ) ; return b . build ( ) ; } 
private static Iterable < ? > doubleToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Long ) ( Math . round ( ( Double ) o ) ) ) . intValue ( ) ) ; return b . build ( ) ; } 
private static Iterable < ? > toString ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( o . toString ( ) ) ; return b . build ( ) ; } 
private int level ( Iterable it ) { if ( it = = null ) return 0 ; Iterator < ? > iterator = it . iterator ( ) ; if ( ! iterator . hasNext ( ) ) return 0 ; Object first = iterator . next ( ) ; We check if the structure implements List rather than Iterable, because we might be interested in certain kind of iterables (for example a Path object). Deconstructing those kind of iterables may not be what we want. if (first instanceof List) { return 1 + level((Iterable) first); } return 0; } 
public static ConversionPair of ( String type , Class klass ) { return new ConversionPair ( type , klass ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof ConversionPair ) ) return false ; final ConversionPair other = ( ConversionPair ) o ; return Objects . equal ( type , other . type ) & & Objects . equal ( klass , other . klass ) ; 
public int hashCode ( ) { return Objects . hashCode ( type , klass ) ; } 
public void call ( List < Object > arguments , List < Object > results ) ; } private static final class Conversions { public static Iterable < ? > geometryToPoints ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . addAll ( ( Iterable < ? > ) ( ( IGeometry ) o ) . getPoints ( ) ) ; return b . build ( ) ; } public static Iterable < ? > doubleToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Long ) ( Math . round ( ( Double ) o ) ) ) . intValue ( ) ) ; return b . build ( ) ; } public static Iterable < ? > toString ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( o . toString ( ) ) ; return b . build ( ) ; } public static Iterable < ? > stringToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Integer . parseInt ( ( String ) o ) ) ; return b . build ( ) ; } public static Iterable < ? > stringToDouble ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Double . parseDouble ( ( String ) o ) ) ; return b . build ( ) ; } public static Iterable < ? > stringToBoolean ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Boolean . parseBoolean ( ( ( String ) o ) . toLowerCase ( ) ) ) ; return b . build ( ) ; } public static Iterable < ? > booleanToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? 1 : 0 ) ; return b . build ( ) ; } public static Iterable < ? > booleanToDouble ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? 1.0 : 0.0 ) ; return b . build ( ) ; } public static Iterable < ? > numberToBoolean ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Integer ) o ) = = 1 ) ; return b . build ( ) ; } public static Iterable < ? > stringToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Color . parseColor ( ( String ) o ) ) ; return b . build ( ) ; } public static Iterable < ? > intToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( new Color ( ( ( Long ) o ) / 255.0 ) ) ; return b . build ( ) ; } public static Iterable < ? > doubleToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( new Color ( ( Double ) o ) ) ; return b . build ( ) ; } public static Iterable < ? > booleanToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? Color . WHITE : Color . BLACK ) ; return b . build ( ) ; } public static Iterable < ? > numberToPoint ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) { double d = ( ( Number ) o ) . doubleValue ( ) ; b . add ( new Point ( d , d ) ) ; } return b . build ( ) ; } public static Iterable < ? > stringToPoint ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) { b . add ( Point . valueOf ( ( String ) o ) ) ; } return b . build ( ) ; } } } 
public static Iterable < ? > geometryToPoints ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . addAll ( ( Iterable < ? > ) ( ( IGeometry ) o ) . getPoints ( ) ) ; return b . build ( ) ; } 
public static Iterable < ? > doubleToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Long ) ( Math . round ( ( Double ) o ) ) ) . intValue ( ) ) ; return b . build ( ) ; } 
public static Iterable < ? > toString ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( o . toString ( ) ) ; return b . build ( ) ; } 
public static Iterable < ? > stringToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Integer . parseInt ( ( String ) o ) ) ; return b . build ( ) ; } 
public static Iterable < ? > stringToDouble ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Double . parseDouble ( ( String ) o ) ) ; return b . build ( ) ; } 
public static Iterable < ? > stringToBoolean ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Boolean . parseBoolean ( ( ( String ) o ) . toLowerCase ( ) ) ) ; return b . build ( ) ; } 
public static Iterable < ? > booleanToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? 1 : 0 ) ; return b . build ( ) ; } 
public static Iterable < ? > booleanToDouble ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? 1.0 : 0.0 ) ; return b . build ( ) ; } 
public static Iterable < ? > numberToBoolean ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Integer ) o ) = = 1 ) ; return b . build ( ) ; } 
public static Iterable < ? > stringToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Color . parseColor ( ( String ) o ) ) ; return b . build ( ) ; } 
public static Iterable < ? > intToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( new Color ( ( ( Long ) o ) / 255.0 ) ) ; return b . build ( ) ; } 
public static Iterable < ? > doubleToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( new Color ( ( Double ) o ) ) ; return b . build ( ) ; } 
public static Iterable < ? > booleanToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? Color . WHITE : Color . BLACK ) ; return b . build ( ) ; } 
public static Iterable < ? > numberToPoint ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) { double d = ( ( Number ) o ) . doubleValue ( ) ; b . add ( new Point ( d , d ) ) ; } return b . build ( ) ; } 
public static Iterable < ? > stringToPoint ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) { b . add ( Point . valueOf ( ( String ) o ) ) ; } return b . build ( ) ; } 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { networkMenuLocation = e . getPoint ( ) ; 
public void actionPerformed ( ActionEvent e ) { Point gridPoint = pointToGridPoint ( networkMenuLocation ) ; getDocument ( ) . showNodeSelectionDialog ( gridPoint ) ; } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; nodeMenu = new JPopupMenu ( ) ; nodeMenu . add ( new SetRenderedAction ( ) ) ; nodeMenu . add ( new RenameAction ( ) ) ; nodeMenu . add ( new DeleteAction ( ) ) ; nodeMenu . add ( new GoInAction ( ) ) ; } 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { Point pt = e . getPoint ( ) ; 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; document . setRenderedNode ( node ) ; } 
public void actionPerformed ( ActionEvent e ) { } } private class DeleteAction extends AbstractAction { private DeleteAction ( ) { super ( " Delete " ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_BACK_SPACE , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { deleteSelection ( ) ; } } private class GoInAction extends AbstractAction { private GoInAction ( ) { super ( " Edit Children " ) ; putValue ( Action . ACCELERATOR_KEY , KeyStroke . getKeyStroke ( KeyEvent . VK_ENTER , 0 ) ) ; } public void actionPerformed ( ActionEvent e ) { } } } 
public void actionPerformed ( ActionEvent e ) { deleteSelection ( ) ; } 
public void actionPerformed ( ActionEvent e ) { } } } 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; String s = JOptionPane . showInputDialog ( NetworkView . this , " New name: " , node . getName ( ) ) ; if ( s = = null | | s . length ( ) = = 0 ) return ; try { getDocument ( ) . setNodeName ( node , s ) ; 
private void goUp ( ) { if ( getDocument ( ) . getActiveNetworkPath ( ) . equals ( " / " ) ) return ; Iterable it = Splitter . on ( " / " ) . split ( getDocument ( ) . getActiveNetworkPath ( ) ) ; int parts = Iterables . size ( it ) ; String path = parts - 1 > 1 ? Joiner . on ( " / " ) . join ( Iterables . limit ( it , parts - 1 ) ) : " / " ; getDocument ( ) . setActiveNetwork ( path ) ; } 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; String childPath = Node . path ( getDocument ( ) . getActiveNetworkPath ( ) , node . getName ( ) ) ; getDocument ( ) . setActiveNetwork ( childPath ) ; } 
private void paintPortTooltip ( Graphics2D g ) { if ( overInput ! = null ) { Node overInputNode = findNodeWithName ( overInput . node ) ; 
public void mouseReleased ( MouseEvent e ) { isDraggingNodes = false ; isDragSelecting = false ; if ( connectionOutput ! = null & & connectionInput ! = null ) { Node inputNode = findNodeWithName ( connectionInput . node ) ; Port inputPort = inputNode . getInput ( connectionInput . port ) ; getDocument ( ) . connect ( connectionOutput , inputNode , inputPort ) ; } connectionOutput = null ; if ( e . isPopupTrigger ( ) ) { networkMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } repaint ( ) ; } 
public static NodePort of ( String node , String port ) { return new NodePort ( node , port ) ; } 
private static int portOffset ( Node node , Port port ) { int portIndex = node . getAllInputs ( ) . indexOf ( port ) ; return ( PORT_WIDTH + PORT_SPACING ) * portIndex ; } 
public void mouseReleased ( MouseEvent e ) { isDraggingNodes = false ; isDragSelecting = false ; if ( connectionOutput ! = null & & connectionInput ! = null ) { getDocument ( ) . connect ( connectionOutput . getName ( ) , connectionInput . node , connectionInput . port ) ; } connectionOutput = null ; if ( e . isPopupTrigger ( ) ) { networkMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } repaint ( ) ; } 
public void connect ( String outputNode , String inputNode , String inputPort ) { addEdit ( " Connect " ) ; controller . connect ( activeNetworkPath , outputNode , inputNode , inputPort ) ; portView . updateAll ( ) ; viewerPane . updateHandle ( ) ; requestRender ( ) ; } 
private void publish ( ) { String s = JOptionPane . showInputDialog ( NetworkView . this , " Publish as: " , nodePort . getPort ( ) ) ; if ( s = = null | | s . length ( ) = = 0 ) return ; getDocument ( ) . publish ( nodePort . getNode ( ) , nodePort . getPort ( ) , s ) ; } 
public void publish ( String inputNode , String inputPort , String publishedName ) { addEdit ( " Publish " ) ; controller . publish ( activeNetworkPath , inputNode , inputPort , publishedName ) ; } 
public void unpublish ( String publishedName ) { addEdit ( " Unpublish " ) ; controller . unpublish ( activeNetworkPath , publishedName ) ; } 
public void testRenderUnpublishAndDisconnect ( ) { Node subnet = createSubnetwork ( " subnet " , 2.0 , 3.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node number = numberNode . extend ( ) . withName ( " number " ) . withInputValue ( " number " , 11.0 ) ; Node net = Node . ROOT . withChildAdded ( number ) . withChildAdded ( subnet ) . withRenderedChildName ( " subnet " ) . connect ( " number " , " subnet " , " n1 " ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 14.0 ) ; subnet = subnet . unpublish ( " n1 " ) ; net = net . withChildReplaced ( " subnet " , subnet ) ; context . renderNetwork ( net ) ; assertResultsEqual ( context . getResults ( subnet ) , 5.0 ) ; } 
public void updatePortValue ( String portName , Object value ) { PortControl control = getControlForPort ( portName ) ; if ( control ! = null & & control . isVisible ( ) ) { control . setValueForControl ( value ) ; 
public void onValueChange ( PortControl control , Object newValue ) { document . setValue ( control . getDisplayName ( ) , newValue ) ; } 
public Port getPort ( ) ; public String getDisplayName ( ) ; public void setDisplayName ( String displayName ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
public String getDisplayName ( ) ; public void setDisplayName ( String displayName ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
public void setDisplayName ( String displayName ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( PortControl control , Object newValue ) ; } } 
private void goUp ( ) { if ( getDocument ( ) . getActiveNetworkPath ( ) . equals ( " / " ) ) return ; Iterable < String > it = Splitter . on ( " / " ) . split ( getDocument ( ) . getActiveNetworkPath ( ) ) ; int parts = Iterables . size ( it ) ; String path = parts - 1 > 1 ? Joiner . on ( " / " ) . join ( Iterables . limit ( it , parts - 1 ) ) : " / " ; getDocument ( ) . setActiveNetwork ( path ) ; } 
public static Color portTypeColor ( String type ) { Color portColor = PORT_COLORS . get ( type ) ; return portColor = = null ? DEFAULT_PORT_COLOR : portColor ; } 
public void moveForwardInHistory ( ) { if ( historyOffset = = 0 ) return ; historyOffset - - ; if ( historyOffset = = 0 ) { checkNotNull ( temporarySavedCommand , " temporarySavedCommand is null. " ) ; 
public static double convertRange ( double value , double srcMin , double srcMax , double targetMin , double targetMax , String overflowMethod ) { if ( overflowMethod . equals ( OVERFLOW_WRAP ) ) { value = srcMin + value % ( srcMax - srcMin ) ; } else if ( overflowMethod . equals ( OVERFLOW_MIRROR ) ) { double rest = value % ( srcMax - srcMin ) ; if ( ( int ) ( value / ( srcMax - srcMin ) ) % 2 = = 1 ) value = srcMax - rest ; else value = srcMin + rest ; } else if ( overflowMethod . equals ( OVERFLOW_CLAMP ) ) { value = clamp ( value , srcMin , srcMax ) ; } Convert value to 0.0-1.0 range. try { value = (value - srcMin) / (srcMax - srcMin); } catch (ArithmeticException e) { value = srcMin; } Convert value to target range. return targetMin + value * (targetMax - targetMin); } 
public static double wave ( double min , double max , double speed , double frame , String waveType ) { float fmin = ( float ) min ; float fmax = ( float ) max ; float fspeed = ( float ) speed ; AbstractWave wave ; if ( waveType . equals ( WAVE_TRIANGLE ) ) wave = TriangleWave . from ( fmin , fmax , fspeed ) ; else if ( waveType . equals ( WAVE_SQUARE ) ) wave = SquareWave . from ( fmin , fmax , fspeed ) ; else if ( waveType . equals ( WAVE_SAWTOOTH ) ) wave = SawtoothWave . from ( fmin , fmax , fspeed ) ; else wave = SineWave . from ( fmin , fmax , fspeed ) ; return wave . getValueAt ( ( float ) frame ) ; } 
public void reloadCategories ( ) { categoryList . removeAll ( ) ; categoryList . addCategory ( ALL_CATEGORIES ) ; categoryList.addCategory("Geometry"); categoryList.addCategory("Math"); categoryList.addCategory("String"); categoryList.setSelectedCategory(ALL_CATEGORIES); } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( selected ) { Rectangle clip = g2 . getClipBounds ( ) ; g2 . setColor ( new java . awt . Color ( 224 , 224 , 224 ) ) ; g2 . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; } g2 . setFont ( Theme . SMALL_FONT ) ; g2 . setColor ( Color . BLACK ) ; g2 . drawString ( category , 15 , 18 ) ; } 
public void addCategory ( final String category ) { final CategoryLabel label = new CategoryLabel ( category ) ; label . addMouseListener ( new MouseInputAdapter ( ) { public void mouseClicked ( MouseEvent e ) { setSelectedCategory ( label ) ; } } ) ; labelMap . put ( category , label ) ; add ( label ) ; } 
public void mouseClicked ( MouseEvent e ) { setSelectedCategory ( label ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( selected ) { Rectangle clip = g2 . getClipBounds ( ) ; g2 . setColor ( new java . awt . Color ( 224 , 224 , 224 ) ) ; g2 . fillRect ( clip . x , clip . y , clip . width , clip . height ) ; } g2 . setFont ( Theme . SMALL_FONT ) ; g2 . setColor ( Color . BLACK ) ; g2 . drawString ( text , 15 , 18 ) ; } 
public void addCategory ( final String categoryLabel , final Object source ) { final CategoryLabel label = new CategoryLabel ( categoryLabel , source ) ; label . addMouseListener ( new MouseInputAdapter ( ) { public void mouseClicked ( MouseEvent e ) { setSelectedCategory ( label ) ; } } ) ; labelMap . put ( categoryLabel , label ) ; add ( label ) ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Category categoryField = new JTextField(20); categoryField.addActionListener(this); categoryField.addFocusListener(this); addRow("Category", categoryField); Description descriptionField = new JTextField(20); descriptionField.addActionListener(this); descriptionField.addFocusListener(this); addRow("Description", descriptionField); Image imageField = new JTextField(20); imageField.addActionListener(this); imageField.addFocusListener(this); addRow("Image", imageField); Output Type outputTypeField = new JTextField(20); outputTypeField.addActionListener(this); outputTypeField.addFocusListener(this); addRow("Output Type", outputTypeField); Output Range outputRangeBox = new JComboBox(humanizedRanges); outputRangeBox.addActionListener(this); addRow("Output Range", outputRangeBox); Function functionField = new JTextField(20); functionField.addActionListener(this); functionField.addFocusListener(this); addRow("Function", functionField); Handle Function handleField = new JTextField(20); handleField.addActionListener(this); handleField.addFocusListener(this); addRow("Handle Function", handleField); } 
public void updateValues ( ) { Node node = getNode ( ) ; categoryField . setText ( node . getCategory ( ) ) ; descriptionField . setText ( node . getDescription ( ) ) ; imageField . setText ( node . getImage ( ) ) ; outputTypeField . setText ( node . getOutputType ( ) ) ; outputRangeBox . setSelectedItem ( getHumanizedRange ( node . getOutputRange ( ) ) ) ; functionField . setText ( node . getFunction ( ) ) ; handleField . setText ( node . getHandle ( ) ) ; } 
public Node withCategory ( String category ) { return newNodeWithAttribute ( Attribute . CATEGORY , category ) ; } 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String category = this . category ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; ImmutableList < PublishedPort > publishedInputs = this . publishedInputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case CATEGORY : category = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case PUBLISHED_INPUTS : publishedInputs = ( ImmutableList < PublishedPort > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT, make the ROOT the prototype. if (prototype == null) { prototype = ROOT; } The name of a node can never be "_root". if (name.equals("_root")) { name = "node"; } return new Node(prototype, name, category, description, image, function, position, inputs, publishedInputs, outputType, outputRange, children, renderedChildName, connections, handle); 
public int hashCode ( ) { return Objects . hashCode ( prototype , name , category , description , image , function , position , inputs , publishedInputs , outputType , outputRange , children , renderedChildName , connections , handle ) ; 
private static Node parseNode ( XMLStreamReader reader , Node parent , NodeRepository nodeRepository ) throws XMLStreamException { String prototypeId = reader . getAttributeValue ( null , " prototype " ) ; String name = reader . getAttributeValue ( null , " name " ) ; String category = reader . getAttributeValue ( null , " category " ) ; String description = reader . getAttributeValue ( null , " description " ) ; String image = reader . getAttributeValue ( null , " image " ) ; String function = reader . getAttributeValue ( null , " function " ) ; String outputType = reader . getAttributeValue ( null , " outputType " ) ; String outputRange = reader . getAttributeValue ( null , " outputRange " ) ; String position = reader . getAttributeValue ( null , " position " ) ; String renderedChildName = reader . getAttributeValue ( null , " renderedChild " ) ; String handle = reader . getAttributeValue ( null , " handle " ) ; Node prototype = prototypeId = = null ? Node . ROOT : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) { throw new XMLStreamException ( " Prototype " + prototypeId + " could not be found. " , reader . getLocation ( ) ) ; } Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( category ! = null ) node = node . withCategory ( category ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputType ! = null ) node = node . withOutputType ( outputType ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " node " ) ) { node = node . withChildAdded ( parseNode ( reader , node , nodeRepository ) ) ; } else if ( tagName . equals ( " publishedPort " ) ) { node = node . withPublishedPortAdded ( parsePublishedPort ( reader ) ) ; } else if ( tagName . equals ( " port " ) ) { String portName = reader . getAttributeValue ( null , " name " ) ; Remove the port if it is already on the prototype. if (node.hasInput(portName)) { node = node.withInputChanged(portName, parsePort(reader, node.getInput(portName))); } else { node = node.withInputAdded(parsePort(reader, null)); } } else if (tagName.equals("conn")) { node = node.withConnectionAdded(parseConnection(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("node")) break; } } This has to come at the end, since the child first needs to exist. if (renderedChildName != null) node = node.withRenderedChildName(renderedChildName); return node; } 
private void moveUp ( ) { int index = nodeList . getSelectedIndex ( ) ; index - - ; if ( index < 0 ) { index = nodeList . getModel ( ) . getSize ( ) - 1 ; } nodeList . setSelectedIndex ( index ) ; nodeList . ensureIndexIsVisible ( index ) ; } 
public synchronized static void initializePython ( ) { if ( isInitialized . get ( ) ) return ; Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = Platform.getUserDataDirectory() + Platform.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. String workingDirectory = System.getProperty("user.dir"); File pythonLibraries = new File(workingDirectory, "lib" + Platform.SEP + "python.zip"); File nodeBoxLibraries = new File(workingDirectory, "lib" + Platform.SEP + "nodeboxlibs.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Py.getSystemState().path.add(new PyString(nodeBoxLibraries.getAbsolutePath())); This folder contains unarchived NodeBox libraries. Only used in development. File developmentLibraries = new File("src/main/python"); Py.getSystemState().path.add(new PyString(developmentLibraries.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(Platform.getUserPythonDirectory().getAbsolutePath())); isInitialized.set(true); } 
public void testNoVarAtEnd ( ) { ClojureLibrary . loadScript ( " src/test/clojure/no-var-at-end.clj " ) ; } 
public void testImportCSV ( ) { List < Map < String , Object > > l = importCSV ( " src/test/files/colors.csv " ) ; assertEquals ( 5 , l . size ( ) ) ; Map < String , Object > black = l . get ( 0 ) ; assertResultsEqual ( black . keySet ( ) , " Name " , " Red " , " Green " , " Blue " ) ; assertEquals ( " Black " , black . get ( " Name " ) ) ; Numerical data is automatically converted to doubles. assertEquals(0.0, black.get("Red")); } 
public void testImportCSVUnicode ( ) { List < Map < String , Object > > l = importCSV ( " src/test/files/unicode.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > frederik = l . get ( 0 ) ; assertResultsEqual ( frederik . keySet ( ) , " Name " , " Age " ) ; assertEquals ( " Fr u00e9d u00ebr u00eck " , frederik . get ( " Name " ) ) ; Map < String , Object > bob = l . get ( 1 ) ; assertEquals ( " B u00f8b " , bob . get ( " Name " ) ) ; } 
public void testImportCSVWithWhitespace ( ) { List < Map < String , Object > > l = importCSV ( " src/test/files/whitespace.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > alice = l . get ( 0 ) ; assertResultsEqual ( alice . keySet ( ) , " Name " , " Age " ) ; assertEquals ( " Alice " , alice . get ( " Name " ) ) ; Numerical data is automatically converted to doubles. assertEquals(41.0, alice.get("Age")); } 
public void testImportCSVWithBadHeaders ( ) { List < Map < String , Object > > l = importCSV ( " src/test/files/bad-headers.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > row1 = l . get ( 0 ) ; assertResultsEqual ( row1 . keySet ( ) , " Alpha " , " Column 2 " , " Column 3 " ) ; assertResultsEqual ( row1 . values ( ) , 1.0 , 2.0 , 3.0 ) ; } 
public void testLoadClojure ( ) { String href = " clojure:src/test/clojure/math.clj " ; FunctionLibrary clojureLibrary = FunctionLibrary . load ( href ) ; assertEquals ( " clojure-math " , clojureLibrary . getNamespace ( ) ) ; assertTrue ( clojureLibrary . hasFunction ( " add " ) ) ; assertEquals ( href , clojureLibrary . getLink ( new File ( userDir , " test.ndbx " ) ) ) ; } 
public void testLoadPython ( ) { String href = " python:src/test/python/functions.py " ; FunctionLibrary pythonLibrary = FunctionLibrary . load ( href ) ; assertEquals ( " functions " , pythonLibrary . getNamespace ( ) ) ; assertTrue ( pythonLibrary . hasFunction ( " add " ) ) ; assertEquals ( href , pythonLibrary . getLink ( new File ( userDir , " test.ndbx " ) ) ) ; } 
public void testLoadError ( ) { PythonLibrary . loadScript ( " py-error " , " src/test/python/nonexisting.py " ) ; } 
public void testRelativeImport ( ) { File relativeImportFile = new File ( " src/test/files/relative-import.ndbx " ) ; NodeLibrary originalLibrary = NodeLibrary . load ( relativeImportFile , NodeRepository . of ( ) ) ; FunctionRepository repository = originalLibrary . getFunctionRepository ( ) ; assertTrue ( repository . hasLibrary ( " relative " ) ) ; assertTrue ( repository . hasFunction ( " relative/concat " ) ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; FunctionLibrary relativeLibrary = library . getFunctionRepository ( ) . getLibrary ( " relative " ) ; assertEquals ( " python:src/test/files/relative.py " , relativeLibrary . getLink ( new File ( userDir , " test.ndbx " ) ) ) ; assertEquals ( " python:relative.py " , relativeLibrary . getLink ( relativeImportFile ) ) ; } 
public void testReadMenus ( ) { NodeLibrary menuLibrary = NodeLibrary . load ( new File ( " src/test/files/menus.ndbx " ) , NodeRepository . of ( ) ) ; Port thePort = menuLibrary . getRoot ( ) . getInput ( " thePort " ) ; assertTrue ( thePort . hasMenu ( ) ) ; assertEquals ( 2 , thePort . getMenuItems ( ) . size ( ) ) ; assertEquals ( new MenuItem ( " a " , " Alpha " ) , thePort . getMenuItems ( ) . get ( 0 ) ) ; assertEquals ( new MenuItem ( " b " , " Beta " ) , thePort . getMenuItems ( ) . get ( 1 ) ) ; } 
public void testRelativePathsInWidgets ( ) { NodeLibrary library = NodeLibrary . load ( new File ( " src/test/files/relative-file.ndbx " ) , NodeRepository . of ( ) ) ; NodeContext context = new NodeContext ( library ) ; Iterable < ? > results = context . renderNode ( library . getRoot ( ) ) ; Object firstResult = results . iterator ( ) . next ( ) ; assertEquals ( true , firstResult ) ; } 
public void testUpgrade1to2 ( ) { File version1File = new File ( " src/test/files/upgrade-v1.ndbx " ) ; UpgradeResult result = NodeLibrary . upgradeTo ( version1File , " 2 " ) ; assertTrue ( " Result should contain updated position: " + result . getXml ( ) , result . getXml ( ) . contains ( " position= \" 12.00,2.00 \" " ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version1File , NodeRepository . of ( ) ) ; Node root = upgradedLibrary . getRoot ( ) ; Node alpha = root . getChild ( " alpha " ) ; assertEquals ( new Point ( 12 , 2 ) , alpha . getPosition ( ) ) ; } 
public void testTooOldToUpgrade ( ) { File version09File = new File ( " src/test/files/upgrade-v0.9.ndbx " ) ; try { NodeLibrary . upgrade ( version09File ) ; 
public void testTooNewToUpgrade ( ) { File version999Files = new File ( " src/test/files/upgrade-v999.ndbx " ) ; try { NodeLibrary . upgrade ( version999Files ) ; 
private nodebox . graphics . Point pointForEvent ( MouseEvent e ) { Point2D originalPoint = new Point2D . Float ( e . getX ( ) , e . getY ( ) ) ; PAffineTransform transform = getCamera ( ) . getViewTransform ( ) ; Point2D transformedPoint ; transformedPoint = transform . inverseTransform ( originalPoint , null ) ; Point2D offset = viewerLayer . getOffset ( ) ; double cx = - offset . getX ( ) + transformedPoint . getX ( ) ; double cy = - offset . getY ( ) + transformedPoint . getY ( ) ; double cx = -getWidth() / 2.0 + transformedPoint.getX(); double cy = -getHeight() / 2.0 + transformedPoint.getY(); return new nodebox.graphics.Point((float) cx, (float) cy); } 
public static AbstractGeometry snap ( AbstractGeometry shape , final double distance , final double strength , final Point position ) { if ( shape = = null ) return null ; final double dStrength = strength / 100.0 ; return shape . mapPoints ( new Function < Point , Point > ( ) { public Point apply ( Point point ) { 
public Point apply ( Point point ) { if ( point = = null ) return Point . ZERO ; double x = MathUtils . snap ( point . x + position . x , distance , dStrength ) - position . x ; double y = MathUtils . snap ( point . y + position . y , distance , dStrength ) - position . y ; return new Point ( x , y ) ; } 
protected Void doInBackground ( ) throws Exception { fontMapper = new DefaultFontMapper ( ) ; String osName = System . getProperty ( " os.name " ) ; if ( osName . startsWith ( " Windows " ) ) { TODO: Windows is not installed under C:\Windows all the time. fontMapper.insertDirectory("C:\\windows\\fonts"); } else if (osName.startsWith("Mac OS X")) { fontMapper.insertDirectory("/Library/Fonts"); String userHome = System.getProperty("user.home"); fontMapper.insertDirectory(userHome + "/Fonts"); } else { Where are the fonts in a UNIX install? } return null; } 
public static void render ( File file , Visualizer v , Iterable < ? > objects ) { I'm using fully qualified class names here so as not to pollute the class' namespace. Rectangle2D bounds = v.getBounds(objects); Rectangle size = new Rectangle((float) bounds.getWidth(), (float) bounds.getHeight()); Document document = new Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } PdfWriter writer; try { writer = PdfWriter.getInstance(document, fos); } catch (DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = new PdfGraphics2D(contentByte, (float) bounds.getWidth(), (float) bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); v.draw(graphics, objects); graphics.dispose(); document.close(); } 
public static void render ( Grob g , File file ) { I'm using fully qualified class names here so as not to pollute the class' namespace. Rect bounds = g.getBounds(); Rectangle size = new Rectangle((float) bounds.getWidth(), (float) bounds.getHeight()); Document document = new Document(size); FileOutputStream fos; try { fos = new FileOutputStream(file); } catch (FileNotFoundException e) { throw new RuntimeException("The file " + file + "could not be created", e); } PdfWriter writer; try { writer = PdfWriter.getInstance(document, fos); } catch (DocumentException e) { throw new RuntimeException("An error occurred while creating a PdfWriter object.", e); } document.open(); PdfContentByte contentByte = writer.getDirectContent(); Graphics2D graphics = new PdfGraphics2D(contentByte, (float) bounds.getWidth(), (float) bounds.getHeight(), fontMapper); graphics.translate(-bounds.getX(), -bounds.getY()); g.draw(graphics); graphics.dispose(); document.close(); } 
private void showUpgradeResult ( UpgradeResult result ) { checkNotNull ( result ) ; if ( result . getWarnings ( ) . isEmpty ( ) ) return ; final UpgradeWarningsDialog dialog = new UpgradeWarningsDialog ( result ) ; dialog . setLocationRelativeTo ( this ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void call ( List < Object > arguments , List < Object > results ) { Object returnValue = invokeFunction ( node , function , arguments ) ; if ( returnValue ! = null ) { results . add ( returnValue ) ; 
public static List < List < String > > makeNestedWords ( ) { List < String > aWords = ImmutableList . of ( " apple " , " abstraction " , " albatross " ) ; List < String > bWords = ImmutableList . of ( " banana " , " bird " , " boat " ) ; List < String > cWords = ImmutableList . of ( " clock " , " creature " , " coffee " ) ; return ImmutableList . of ( aWords , bWords , cWords ) ; } 
public void testNestedNetworks ( ) { Node makeNestedWords = Node . ROOT . withName ( " makeNestedWords " ) . withFunction ( " test/makeNestedWords " ) . withOutputType ( " string " ) . withOutputRange ( Port . Range . LIST ) ; Node countNet = createLengthCountNetwork ( ) ; Node mainNetwork = Node . ROOT . withChildAdded ( makeNestedWords ) . withChildAdded ( countNet ) . connect ( " makeNestedWords " , " countNetwork " , " text " ) . withRenderedChild ( countNet ) ; List < Integer > aCounts = ImmutableList . of ( 5 , 11 , 9 ) ; List < Integer > bCounts = ImmutableList . of ( 6 , 4 , 4 ) ; List < Integer > cCounts = ImmutableList . of ( 5 , 8 , 6 ) ; List < List < Integer > > expectedCounts = ImmutableList . of ( aCounts , bCounts , cCounts ) ; ImmutableList < ? > results = ImmutableList . copyOf ( context . renderNode ( mainNetwork ) ) ; assertEquals ( expectedCounts , results ) ; } 
private Node createLengthCountNetwork ( ) { Node countLetters = Node . ROOT . withName ( " countLetters " ) . withFunction ( " string/length " ) . withOutputType ( " string " ) . withInputAdded ( Port . stringPort ( " text " , " " ) ) ; return Node . ROOT . withName ( " countNetwork " ) 
public static double pow ( double n1 , double n2 ) { return Math . pow ( n1 , n2 ) ; } 
public static double ceil ( double ) { return Math . ceil ( ) ; } 
public static double floor ( double ) { return Math . floor ( ) ; } 
public synchronized void finishedRendering ( final Node renderedNetwork , final List < ? > results ) { finishCurrentRender ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { Node renderedChild = renderedNetwork . getRenderedChild ( ) ; lastRenderResult = results ; viewerPane . setOutputValues ( results ) ; networkPane . clearError ( ) ; networkView . checkErrorAndRepaint ( ) ; } 
public void run ( ) { final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame ) ; Exception renderException = null ; startRendering ( context ) ; List < ? > results = null ; try { results = context . renderNode ( renderNetwork ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); if (renderException == null) { finishedRendering(renderNetwork, results); 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final ExportViewer viewer = new ExportViewer ( ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame ) ; List < ? > results = context . renderNode ( exportNetwork ) ; Node renderedChild = exportNetwork . getRenderedChild ( ) ; viewer . setOutputValue ( results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; viewer . setVisible ( true ) ; } 
public List < ? > renderNode ( Node node ) throws NodeRenderException { checkNotNull ( node ) ; checkNotNull ( functionRepository ) ; If the node has children, forgo the operation of the current node and evaluate the child. if (node.hasRenderedChild()) { return renderChild(node, node.getRenderedChild()); 
private List < ? > postProcessResult ( Node node , Object result ) { if ( node . hasListOutputRange ( ) ) { return ( List < ? > ) result ; 
private Object invokeNode ( Node node , List < ? > arguments ) { String functionName = node . getFunction ( ) ; Function function = functionRepository . getFunction ( functionName ) ; return invokeFunction ( node , function , arguments ) ; } 
private List < ? > evaluatePort ( Node network , Node child , Port childPort ) { Node outputNode = findOutputNode ( network , child , childPort ) ; if ( outputNode ! = null ) { return renderChild ( network , outputNode ) ; 
private static int biggestList ( List < List < ? > > listOfLists ) { int maxSize = 0 ; for ( List < ? > list : listOfLists ) { maxSize = Math . max ( maxSize , list . size ( ) ) ; } return maxSize ; } 
private static Object wrappingGet ( List < ? > list , int index ) { return list . get ( index % list . size ( ) ) ; } 
private static List < List < ? > > buildArgumentLists ( List < List < ? > > perPortLists ) { List < List < ? > > argumentLists = new ArrayList < List < ? > > ( ) ; int maxSize = biggestList ( perPortLists ) ; for ( int i = 0 ; i < maxSize ; i + + ) { ArrayList < Object > argumentList = new ArrayList < Object > ( perPortLists . size ( ) ) ; for ( List < ? > portList : perPortLists ) { argumentList . add ( wrappingGet ( portList , i ) ) ; } argumentLists . add ( argumentList ) ; } return argumentLists ; } 
public void testExecute ( ) { Node = net . connect ( " number42 " , " add " , " v1 " ) . connect ( " number5 " , " add " , " v2 " ) ; assertResultsEqual ( , 47.0 ) ; } 
public void testCycles ( ) { TODO Infinite loops are not supported anymore! Create an infinite loop. Node n = net .connect("number42", "add", "v1") .connect("add", "number42", "number"); assertResultsEqual(n, 42.0); } 
public void testSingleOutput ( ) { List < ? > results = context . renderNode ( valuesToPointNode ) ; assertEquals ( 1 , results . size ( ) ) ; assertResultsEqual ( results , Point . ZERO ) ; } 
public void testExecuteAmount ( ) { Node makeNumbers1 = makeNumbersNode . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 " ) ; Node incNode = Node . ROOT . withName ( " inc " ) . withFunction ( " side-effects/increaseAndCount " ) . withInputAdded ( Port . floatPort ( " number " , 0 ) ) ; Node net = Node . ROOT . withChildAdded ( makeNumbers1 ) . withChildAdded ( incNode ) . connect ( " makeNumbers1 " , " inc " , " number " ) ; assertResultsEqual ( net , incNode , 2.0 , 3.0 , 4.0 ) ; assertEquals ( 3 , SideEffects . theCounter ) ; } 
public void testRenderSubnetwork ( ) { Node subnet = createSubnetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withRenderedChildName ( " subnet1 " ) ; assertResultsEqual ( net , subnet , 3.0 ) ; } 
public void testValidSubnetworkResults ( ) { Node subnet1 = createSubnetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node subnet2 = createSubnetwork ( " subnet2 " , 3.0 , 4.0 ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node net = Node . ROOT . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) ; assertResultsEqual ( net , add1 , 10.0 ) ; } 
public void testRenderNetworkWithPublishedPorts ( ) { Node subnet = createSubnetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " value1 " ) . publish ( " number2 " , " number " , " value2 " ) . withInputValue ( " value1 " , 2.0 ) . withInputValue ( " value2 " , 3.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withRenderedChildName ( " subnet1 " ) ; assertResultsEqual ( net , subnet , 5.0 ) ; } 
public void testRenderNetworkWithConnectedPublishedPorts ( ) { Node subnet = createSubnetwork ( " subnet1 " , 0.0 , 1.0 ) . publish ( " number1 " , " number " , " value1 " ) . withInputValue ( " value1 " , 2.0 ) ; Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 10.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withChildAdded ( number1 ) . withRenderedChildName ( " subnet1 " ) . connect ( " number1 " , " subnet1 " , " value1 " ) ; assertResultsEqual ( net , subnet , 11.0 ) ; } 
public void testRenderNestedNetworkWithConnectedPublishedPorts ( ) { Node subnet1 = createSubnetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node subnet2 = createSubnetwork ( " subnet2 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node subnet = Node . ROOT . withName ( " subnet " ) . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) . publish ( " subnet1 " , " n1 " , " value1 " ) . publish ( " subnet1 " , " n2 " , " value2 " ) . publish ( " subnet2 " , " n1 " , " value3 " ) . publish ( " subnet2 " , " n2 " , " value4 " ) ; Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 11.0 ) ; Node number2 = numberNode . extend ( ) . withName ( " number2 " ) . withInputValue ( " number " , 22.0 ) ; Node number3 = numberNode . extend ( ) . withName ( " number3 " ) . withInputValue ( " number " , 33.0 ) ; Node number4 = numberNode . extend ( ) . withName ( " number4 " ) . withInputValue ( " number " , 44.0 ) ; Node net = Node . ROOT . withChildAdded ( number1 ) . withChildAdded ( number2 ) . withChildAdded ( number3 ) . withChildAdded ( number4 ) . withChildAdded ( subnet ) . withRenderedChildName ( " subnet " ) . connect ( " number1 " , " subnet " , " value1 " ) . connect ( " number2 " , " subnet " , " value2 " ) . connect ( " number3 " , " subnet " , " value3 " ) . connect ( " number4 " , " subnet " , " value4 " ) ; assertResultsEqual ( net , subnet , 110.0 ) ; } 
public void testRenderUnpublishAndDisconnect ( ) { Node subnet = createSubnetwork ( " subnet " , 2.0 , 3.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node number = numberNode . extend ( ) . withName ( " number " ) . withInputValue ( " number " , 11.0 ) ; Node net = Node . ROOT . withChildAdded ( number ) . withChildAdded ( subnet ) . withRenderedChildName ( " subnet " ) . connect ( " number " , " subnet " , " n1 " ) ; assertResultsEqual ( net , subnet , 14.0 ) ; subnet = subnet . unpublish ( " n1 " ) ; net = net . withChildReplaced ( " subnet " , subnet ) ; assertResultsEqual ( net , subnet , 5.0 ) ; } 
public void testNestedNetworks ( ) { Node makeNestedWords = Node . ROOT . withName ( " makeNestedWords " ) . withFunction ( " test/makeNestedWords " ) . withOutputType ( " string " ) . withOutputRange ( Port . Range . LIST ) ; Node countNet = createLengthCountNetwork ( ) ; Node mainNetwork = Node . ROOT . withChildAdded ( makeNestedWords ) . withChildAdded ( countNet ) . connect ( " makeNestedWords " , " countNetwork " , " text " ) . withRenderedChild ( countNet ) ; List < Integer > aCounts = ImmutableList . of ( 5 , 11 , 9 ) ; List < Integer > bCounts = ImmutableList . of ( 6 , 4 , 4 ) ; List < Integer > cCounts = ImmutableList . of ( 5 , 8 , 6 ) ; assertResultsEqual ( mainNetwork , aCounts , bCounts , cCounts ) ; } 
private static int biggestArgumentList ( Map < Port , List < ? > > argumentsPerPort ) { int maxSize = 0 ; for ( Map . Entry < Port , List < ? > > entry : argumentsPerPort . entrySet ( ) ) { maxSize = Math . max ( maxSize , argumentListSize ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return maxSize ; } 
private static int argumentListSize ( Port port , List < ? > arguments ) { If the port takes in a list, he will always take the entire argument list as an argument. Therefore, the size of arguments is 1. if (port.hasListRange()) { return 1; 
private Object invokeNode ( Node node , List < ? > arguments ) { Function function = functionRepository . getFunction ( node . getFunction ( ) ) ; return invokeFunction ( node , function , arguments ) ; } 
public static List < ? > doSwitch ( Iterable list1 , Iterable list2 , Iterable list3 , long index ) { Iterable returnList ; switch ( ( int ) index % 3 ) { case 0 : returnList = list1 ; break ; case 1 : returnList = list2 ; break ; default : returnList = list3 ; break ; } if ( returnList = = null ) return ImmutableList . of ( ) ; return ImmutableList . copyOf ( returnList ) ; } 
public List < ? > renderNode ( Node node ) throws NodeRenderException { return renderNode ( node , Collections . < Port , Object > emptyMap ( ) ) ; } 
public List < ? > renderChild ( Node network , Node child ) throws NodeRenderException { return renderChild ( network , child , Collections . < Port , Object > emptyMap ( ) ) ; } 
private static int smallestArgumentList ( Map < Port , List < ? > > argumentsPerPort ) { int minSize = Integer . MAX_VALUE ; for ( Map . Entry < Port , List < ? > > entry : argumentsPerPort . entrySet ( ) ) { minSize = Math . min ( minSize , argumentListSize ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return minSize ; } 
public static List < ? > geometryToPoints ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . addAll ( ( Iterable < ? > ) ( ( IGeometry ) o ) . getPoints ( ) ) ; return b . build ( ) ; } 
public static List < ? > doubleToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Long ) ( Math . round ( ( Double ) o ) ) ) . intValue ( ) ) ; return b . build ( ) ; } 
public static List < ? > toString ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( o . toString ( ) ) ; return b . build ( ) ; } 
public static List < ? > stringToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Integer . parseInt ( ( String ) o ) ) ; return b . build ( ) ; } 
public static List < ? > stringToDouble ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Double . parseDouble ( ( String ) o ) ) ; return b . build ( ) ; } 
public static List < ? > stringToBoolean ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Boolean . parseBoolean ( ( ( String ) o ) . toLowerCase ( ) ) ) ; return b . build ( ) ; } 
public static List < ? > booleanToInt ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? 1 : 0 ) ; return b . build ( ) ; } 
public static List < ? > booleanToDouble ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? 1.0 : 0.0 ) ; return b . build ( ) ; } 
public static List < ? > numberToBoolean ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Integer ) o ) = = 1 ) ; return b . build ( ) ; } 
public static List < ? > stringToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( Color . parseColor ( ( String ) o ) ) ; return b . build ( ) ; } 
public static List < ? > intToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( new Color ( ( ( Long ) o ) / 255.0 ) ) ; return b . build ( ) ; } 
public static List < ? > doubleToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( new Color ( ( Double ) o ) ) ; return b . build ( ) ; } 
public static List < ? > booleanToColor ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) b . add ( ( ( Boolean ) o ) ? Color . WHITE : Color . BLACK ) ; return b . build ( ) ; } 
public static List < ? > numberToPoint ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) { double d = ( ( Number ) o ) . doubleValue ( ) ; b . add ( new Point ( d , d ) ) ; } return b . build ( ) ; } 
public static List < ? > stringToPoint ( Iterable < ? > values ) { ImmutableList . Builder < Object > b = new ImmutableList . Builder < Object > ( ) ; for ( Object o : values ) { b . add ( Point . valueOf ( ( String ) o ) ) ; } return b . build ( ) ; } 
public static NodeLibraryController create ( ) { return new NodeLibraryController ( NodeLibrary . create ( " untitled " , Node . NETWORK , NodeRepository . of ( ) , FunctionRepository . of ( ) ) ) ; } 
public static NodeLibraryController create ( String libraryName , NodeRepository nodeRepository , FunctionRepository functionRepository ) { return new NodeLibraryController ( NodeLibrary . create ( libraryName , Node . NETWORK , nodeRepository , functionRepository ) ) ; } 
public void testConnectedListProcessing ( ) { Node makeNumbers1 = makeNumbersNode . extend ( ) . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 4 " ) ; Node invert1 = invertNode . extend ( ) . withName ( " invert1 " ) ; Node net = Node . NETWORK . withChildAdded ( makeNumbers1 ) . withChildAdded ( invert1 ) . connect ( " makeNumbers1 " , " invert1 " , " value " ) . withRenderedChildName ( " invert1 " ) ; assertResultsEqual ( context . renderChild ( net , invert1 ) , - 1.0 , - 2.0 , - 3.0 , - 4.0 ) ; } 
public void testEmptyListProcessing ( ) { Node noNumbers = makeNumbersNode . extend ( ) . withName ( " noNumbers " ) . withInputValue ( " string " , " " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node net = Node . NETWORK . withChildAdded ( noNumbers ) . withChildAdded ( add1 ) . connect ( " noNumbers " , " add1 " , " v1 " ) ; assertNoResults ( net , add1 ) ; } 
public void testSamePrototypeTwice ( ) { Node invert1Node = invertNode . withName ( " invert1 " ) . withInputValue ( " value " , 42.0 ) ; Node invert2Node = invertNode . withName ( " invert2 " ) ; Node net = Node . NETWORK . withChildAdded ( invert1Node ) . withChildAdded ( invert2Node ) . connect ( " invert1 " , " invert2 " , " value " ) ; assertResultsEqual ( context . renderChild ( net , invert2Node ) , 42.0 ) ; } 
public void testExecuteAmount ( ) { Node makeNumbers1 = makeNumbersNode . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 " ) ; Node incNode = Node . ROOT . withName ( " inc " ) . withFunction ( " side-effects/increaseAndCount " ) . withInputAdded ( Port . floatPort ( " number " , 0 ) ) ; Node net = Node . NETWORK . withChildAdded ( makeNumbers1 ) . withChildAdded ( incNode ) . connect ( " makeNumbers1 " , " inc " , " number " ) ; assertResultsEqual ( net , incNode , 2.0 , 3.0 , 4.0 ) ; assertEquals ( 3 , SideEffects . theCounter ) ; } 
public void testListWithValue ( ) { Node makeNumbers1 = makeNumbersNode . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) . withInputValue ( " v2 " , 100.0 ) ; Node net = Node . NETWORK . withChildAdded ( makeNumbers1 ) . withChildAdded ( add1 ) . connect ( " makeNumbers1 " , " add1 " , " v1 " ) ; assertResultsEqual ( context . renderChild ( net , add1 ) , 101.0 , 102.0 , 103.0 ) ; } 
public void testLongestList ( ) { Node net = Node . NETWORK . withChildAdded ( threeNumbers ) . withChildAdded ( fiveNumbers ) . withChildAdded ( addNode ) . connect ( " threeNumbers " , addNode . getName ( ) , " v1 " ) . connect ( " fiveNumbers " , addNode . getName ( ) , " v2 " ) ; assertResultsEqual ( context . renderChild ( net , addNode ) , 101.0 , 202.0 , 303.0 , 401.0 , 502.0 ) ; } 
public void testPortRangeMatching ( ) { Node sum = Node . ROOT . withName ( " sum " ) . withFunction ( " math/sum " ) . withInputAdded ( Port . floatPort ( " numbers " , 0 ) ) . withInputRange ( " numbers " , Port . Range . LIST ) ; Node net = Node . NETWORK . withChildAdded ( sum ) . withChildAdded ( threeNumbers ) . connect ( " threeNumbers " , sum . getName ( ) , " numbers " ) ; assertResultsEqual ( context . renderChild ( net , sum ) , 6.0 ) ; } 
public void testListWithNulls ( ) { Node makeNull = Node . ROOT . withName ( " makeNull " ) . withFunction ( " test/makeNull " ) . withInputAdded ( Port . floatPort ( " value " , 0.0 ) ) ; Node net = Node . NETWORK . withChildAdded ( threeNumbers ) . withChildAdded ( makeNull ) . connect ( " threeNumbers " , " makeNull " , " value " ) ; assertResultsEqual ( net , makeNull ) ; } 
public void testNestedLists ( ) { Node makeStrings = makeStringsNode . extend ( ) . withInputValue ( " string " , " 1,2;3,4;5,6 " ) ; Node makeNumbers = makeNumbersNode . extend ( ) . withName ( " makeNumbers " ) . withInputValue ( " separator " , " , " ) ; Node net = Node . NETWORK . withChildAdded ( makeStrings ) . withChildAdded ( makeNumbers ) . withRenderedChildName ( " makeNumbers " ) . connect ( " makeStrings " , " makeNumbers " , " string " ) ; assertResultsEqual ( net , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 ) ; } 
public void testNestedListAsSingleValue ( ) { Node sample1 = createSampleNode ( " sample1 " , 4 , 3.0 , 9.0 ) ; Node sample2 = createSampleNode ( " sample2 " , 4 , 9.0 , 24.0 ) ; Node sample3 = sampleNode . extend ( ) . withName ( " sample3 " ) . withInputValue ( " amount " , 4 ) ; Node net = Node . NETWORK . withChildAdded ( sample1 ) . withChildAdded ( sample2 ) . withChildAdded ( sample3 ) . withRenderedChildName ( " sample3 " ) . connect ( " sample1 " , " sample3 " , " start " ) . connect ( " sample2 " , " sample3 " , " end " ) ; assertResultsEqual ( context . renderNode ( net ) , ImmutableList . of ( 3.0 , 5.0 , 7.0 , 9.0 ) , ImmutableList . of ( 5.0 , 8.0 , 11.0 , 14.0 ) , ImmutableList . of ( 7.0 , 11.0 , 15.0 , 19.0 ) , ImmutableList . of ( 9.0 , 14.0 , 19.0 , 24.0 ) ) ; Node sample4 = createSampleNode ( " sample4 " , 2 , 2.0 , 3.0 ) ; Node slice = Node . ROOT . withName ( " slice " ) . withFunction ( " list/slice " ) . withOutputRange ( Port . Range . LIST ) . withInputAdded ( Port . floatPort ( " list " , 0 ) ) . withInputRange ( " list " , Port . Range . LIST ) . withInputAdded ( Port . intPort ( " start_index " , 1 ) ) . withInputAdded ( Port . intPort ( " size " , 2 ) ) ; net = net . withChildAdded ( slice ) . withChildAdded ( sample4 ) . withRenderedChildName ( " slice " ) . connect ( " sample3 " , " slice " , " list " ) . connect ( " sample4 " , " slice " , " size " ) ; Iterable < ? > results = context . renderNode ( net ) ; assertEquals ( 4 , Iterables . size ( results ) ) ; assertResultsEqual ( ( Iterable < ? > ) Iterables . get ( results , 0 ) , 5.0 , 7.0 ) ; assertResultsEqual ( ( Iterable < ? > ) Iterables . get ( results , 1 ) , 8.0 , 11.0 , 14.0 ) ; assertResultsEqual ( ( Iterable < ? > ) Iterables . get ( results , 2 ) , 11.0 , 15.0 ) ; assertResultsEqual ( ( Iterable < ? > ) Iterables . get ( results , 3 ) , 14.0 , 19.0 , 24.0 ) ; } 
public void testRenderSubnetwork ( ) { Node subnet = createSubNetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node net = Node . NETWORK . withChildAdded ( subnet ) . withRenderedChildName ( " subnet1 " ) ; assertResultsEqual ( net , subnet , 3.0 ) ; } 
public void testValidSubnetworkResults ( ) { Node subnet1 = createSubNetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node subnet2 = createSubNetwork ( " subnet2 " , 3.0 , 4.0 ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node net = Node . ROOT . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) ; assertResultsEqual ( net , add1 , 10.0 ) ; } 
public void testRenderNetworkWithPublishedPorts ( ) { Node subNet = createSubNetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " value1 " ) . publish ( " number2 " , " number " , " value2 " ) . withInputValue ( " value1 " , 2.0 ) . withInputValue ( " value2 " , 3.0 ) ; Node net = Node . NETWORK . withChildAdded ( subNet ) . withRenderedChildName ( " subnet1 " ) ; assertResultsEqual ( net , subNet , 5.0 ) ; } 
public void testRenderNetworkWithConnectedPublishedPorts ( ) { Node subnet = createSubNetwork ( " subnet1 " , 0.0 , 1.0 ) . publish ( " number1 " , " number " , " value1 " ) . withInputValue ( " value1 " , 2.0 ) ; Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 10.0 ) ; Node net = Node . ROOT . withChildAdded ( subnet ) . withChildAdded ( number1 ) . withRenderedChildName ( " subnet1 " ) . connect ( " number1 " , " subnet1 " , " value1 " ) ; assertResultsEqual ( net , subnet , 11.0 ) ; } 
public void testRenderNestedNetworkWithConnectedPublishedPorts ( ) { Node subnet1 = createSubNetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node subnet2 = createSubNetwork ( " subnet2 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node subnet = Node . NETWORK . withName ( " subnet " ) . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) . publish ( " subnet1 " , " n1 " , " value1 " ) . publish ( " subnet1 " , " n2 " , " value2 " ) . publish ( " subnet2 " , " n1 " , " value3 " ) . publish ( " subnet2 " , " n2 " , " value4 " ) ; Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 11.0 ) ; Node number2 = numberNode . extend ( ) . withName ( " number2 " ) . withInputValue ( " number " , 22.0 ) ; Node number3 = numberNode . extend ( ) . withName ( " number3 " ) . withInputValue ( " number " , 33.0 ) ; Node number4 = numberNode . extend ( ) . withName ( " number4 " ) . withInputValue ( " number " , 44.0 ) ; Node net = Node . NETWORK . withChildAdded ( number1 ) . withChildAdded ( number2 ) . withChildAdded ( number3 ) . withChildAdded ( number4 ) . withChildAdded ( subnet ) . withRenderedChildName ( " subnet " ) . connect ( " number1 " , " subnet " , " value1 " ) . connect ( " number2 " , " subnet " , " value2 " ) . connect ( " number3 " , " subnet " , " value3 " ) . connect ( " number4 " , " subnet " , " value4 " ) ; assertResultsEqual ( net , subnet , 110.0 ) ; } 
public void testRenderUnpublishAndDisconnect ( ) { Node subNet = createSubNetwork ( " subNet " , 2.0 , 3.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node number = numberNode . extend ( ) . withName ( " number " ) . withInputValue ( " number " , 11.0 ) ; Node net = Node . NETWORK . withChildAdded ( number ) . withChildAdded ( subNet ) . withRenderedChildName ( " subNet " ) . connect ( " number " , " subNet " , " n1 " ) ; assertResultsEqual ( net , subNet , 14.0 ) ; subNet = subNet . unpublish ( " n1 " ) ; net = net . withChildReplaced ( " subNet " , subNet ) ; assertResultsEqual ( net , subNet , 5.0 ) ; } 
private Node createSubNetwork ( String name , double v1 , double v2 ) { Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , v1 ) ; Node number2 = numberNode . extend ( ) . withName ( " number2 " ) . withInputValue ( " number " , v2 ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node subNet = Node . NETWORK . withName ( name ) . withChildAdded ( number1 ) . withChildAdded ( number2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " number1 " , " add1 " , " v1 " ) . connect ( " number2 " , " add1 " , " v2 " ) ; return subNet ; } 
private Node createNestedNetwork ( String makeStrings1Value , String makeStrings2Value ) { Node makeStrings1 = makeStringsNode . extend ( ) . withName ( " makeStrings1 " ) . withInputValue ( " string " , makeStrings1Value ) ; Node makeStrings2 = makeStringsNode . extend ( ) . withName ( " makeStrings2 " ) . withInputValue ( " string " , makeStrings2Value ) ; Node makeNumbers1 = makeNumbersNode . extend ( ) . withName ( " makeNumbers1 " ) . withInputValue ( " separator " , " , " ) ; Node makeNumbers2 = makeNumbersNode . extend ( ) . withName ( " makeNumbers2 " ) . withInputValue ( " separator " , " , " ) ; Node calculate = calculateMultipleNode . extend ( ) . withInputValue ( " v2 " , 6.0 ) . withInputValue ( " v4 " , 7.0 ) ; return Node . NETWORK . withChildAdded ( makeStrings1 ) 
public void testListOutputRange ( ) { Node slice = Node . ROOT . withName ( " slice " ) . withFunction ( " list/slice " ) . withInputAdded ( Port . stringPort ( " list " , " " ) . withRange ( Port . Range . LIST ) ) . withInputAdded ( Port . intPort ( " start " , 0 ) ) . withInputAdded ( Port . intPort ( " size " , 1000 ) ) . withOutputRange ( Port . Range . LIST ) ; Node makeStrings = Node . ROOT . withName ( " makeStrings " ) . withFunction ( " string/makeStrings " ) . withInputAdded ( Port . stringPort ( " text " , " A;B;C " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node makeNumbers = Node . ROOT . withName ( " makeNumbers " ) . withFunction ( " math/makeNumbers " ) . withInputAdded ( Port . stringPort ( " text " , " 0;1;2 " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node net = Node . NETWORK . withChildAdded ( makeStrings ) . withChildAdded ( makeNumbers ) . withChildAdded ( slice ) . connect ( " makeStrings " , " slice " , " list " ) . connect ( " makeNumbers " , " slice " , " start " ) ; assertResultsEqual ( net , slice , " A " , " B " , " C " , " B " , " C " , " C " ) ; } 
public void testNestedGenerator ( ) { Node repeat = Node . ROOT . withName ( " repeat " ) . withFunction ( " list/repeat " ) . withInputAdded ( Port . customPort ( " value " , " list " ) . withRange ( Port . Range . LIST ) ) . withInputAdded ( Port . intPort ( " amount " , 3 ) ) . withOutputRange ( Port . Range . LIST ) ; Node string = Node . ROOT . withName ( " string " ) . withFunction ( " string/string " ) . withInputAdded ( Port . stringPort ( " value " , " A " ) ) . withOutputType ( " string " ) ; Node repeatNet = Node . NETWORK . withName ( " repeatNet " ) . withChildAdded ( string ) . withChildAdded ( repeat ) . withRenderedChild ( repeat ) . publish ( " string " , " value " , " strings " ) . connect ( " string " , " repeat " , " value " ) ; assertResultsEqual ( repeatNet , " A " , " A " , " A " ) ; Node makeStrings = Node . ROOT . withName ( " makeStrings " ) . withFunction ( " string/makeStrings " ) . withInputAdded ( Port . stringPort ( " value " , " A;B;C " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node net = Node . NETWORK . withChildAdded ( makeStrings ) . withChildAdded ( repeatNet ) . withRenderedChild ( repeatNet ) . connect ( " makeStrings " , " repeatNet " , " strings " ) ; assertResultsEqual ( net , ImmutableList . of ( " A " , " A " , " A " ) , ImmutableList . of ( " B " , " B " , " B " ) , ImmutableList . of ( " C " , " C " , " C " ) ) ; } 
public void testNestedFilter ( ) { Node makeNestedWords = Node . NETWORK . withName ( " makeNestedWords " ) . withFunction ( " test/makeNestedWords " ) . withOutputType ( " string " ) ; Node countNet = createLengthCountNetwork ( ) ; Node mainNetwork = Node . NETWORK . withChildAdded ( makeNestedWords ) . withChildAdded ( countNet ) . connect ( " makeNestedWords " , " countNetwork " , " text " ) . withRenderedChild ( countNet ) ; List < Integer > aCounts = ImmutableList . of ( 5 , 11 , 9 ) ; List < Integer > bCounts = ImmutableList . of ( 6 , 4 , 4 ) ; List < Integer > cCounts = ImmutableList . of ( 5 , 8 , 6 ) ; assertResultsEqual ( mainNetwork , aCounts , bCounts , cCounts ) ; } 
private Node createLengthCountNetwork ( ) { Node countLetters = Node . ROOT . withName ( " countLetters " ) . withFunction ( " string/length " ) . withOutputType ( " string " ) . withInputAdded ( Port . stringPort ( " text " , " " ) ) ; return Node . NETWORK . withName ( " countNetwork " ) 
public void testSetPortValueInSubNet ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 10.0 ) ) ; Node subNet = Node . NETWORK . withName ( " subNet " ) . withChildAdded ( numberNode ) . withRenderedChildName ( " number " ) ; controller . addNode ( " / " , subNet ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subNet " ) , 10.0 ) ; controller . setPortValue ( " /subNet/number " , " value " , 42.0 ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subNet " ) , 42.0 ) ; } 
public void testPublish ( ) { Node invertNode = Node . ROOT . withName ( " negate " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , Node . NETWORK . withName ( " subnet " ) ) ; controller . addNode ( " /subnet " , invertNode ) ; controller . setRenderedChild ( " /subnet " , " negate " ) ; controller . publish ( " /subnet " , " negate " , " value " , " " ) ; assertTrue ( controller . getNode ( " /subnet " ) . hasPublishedInput ( " " ) ) ; controller . setPortValue ( " /subnet " , " " , 42.0 ) ; assertEquals ( 42 , controller . getNode ( " /subnet/negate " ) . getInput ( " value " ) . intValue ( ) ) ; Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 20 ) ) ; controller . addNode ( " / " , numberNode ) ; controller . connect ( " / " , " number " , " subnet " , " " ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet " ) , - 20.0 ) ; controller . setPortValue ( " /number " , " value " , 55.0 ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet " ) , - 55.0 ) ; } 
public void testPrototypeInSameLibrary ( ) { You can refer to a prototype in the same library as the current node. Node invert = Node.ROOT .withName("negate") .withFunction("math/negate") .withInputAdded(Port.floatPort("number", 0)); Node invert1 = invert.extend().withName("invert1").withInputValue("number", 42.0); Node net = Node.NETWORK .withName("root") .withChildAdded(invert) .withChildAdded(invert1) .withRenderedChild(invert1); NodeLibrary originalLibrary = NodeLibrary.create("test", net, FunctionRepository.of(MathFunctions.LIBRARY)); Assert the original library returns the correct result. NodeContext context = new NodeContext(originalLibrary); assertResultsEqual(context.renderNode(net), -42.0); Persist / load the library and assert it still returns the correct result. NodeLibrary restoredLibrary = NodeLibrary.load("test", originalLibrary.toXml(), NodeRepository.of()); context = new NodeContext(restoredLibrary); assertResultsEqual(context.renderNode(restoredLibrary.getRoot()), -42.0); } 
public void testPortRangePersistence ( ) { Default check. Node makeNumbers = Node.ROOT .withName("makeNumbers") .withFunction("math/makeNumbers") .withOutputRange(Port.Range.LIST) .withInputAdded(Port.stringPort("s", "1 2 3 4 5")) .withInputAdded(Port.stringPort("sep", " ")); Node reverse = Node.ROOT .withName("reverse") .withFunction("list/reverse") .withInputAdded(Port.customPort("list", "list")) .withInputRange("list", Port.Range.LIST) .withOutputRange(Port.Range.LIST); Node net = Node.NETWORK .withChildAdded(makeNumbers) .withChildAdded(reverse) .withRenderedChild(reverse) .connect("makeNumbers", "reverse", "list"); NodeLibrary originalLibrary = NodeLibrary.create("test", net, functions); assertResultsEqual(originalLibrary.getRoot(), 5.0, 4.0, 3.0, 2.0, 1.0); Now save / load the library and check the output. NodeLibrary library = NodeLibrary.load("test", originalLibrary.toXml(), NodeRepository.of()); assertResultsEqual(library.getRoot(), 5.0, 4.0, 3.0, 2.0, 1.0); } 
public static void assertNoResults ( Node network , Node child ) { assertResultsEqual ( network , child ) ; } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; nodeMenu = new JPopupMenu ( ) ; nodeMenu . add ( new SetRenderedAction ( ) ) ; nodeMenu . add ( new RenameAction ( ) ) ; nodeMenu . add ( new DeleteAction ( ) ) ; nodeMenu . add ( new GroupIntoNetworkAction ( null ) ) ; nodeMenu . add ( new GoInAction ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { nodebox . graphics . Point position ; if ( gridPoint = = null ) position = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) . getPosition ( ) ; else position = new nodebox . graphics . Point ( gridPoint ) ; getDocument ( ) . groupIntoNetwork ( position ) ; } 
public static Point point ( Point value ) { return value ; } 
public static long integer ( long value ) { return value ; } 
public static boolean makeBoolean ( boolean value ) { return value ; } 
public static String string ( String value ) { return value ; } 
private synchronized void finishedRenderingWithError ( NodeContext context , Node network , final Throwable ) { finishCurrentRender ( ) ; lastRenderResult = null ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { networkPane . setError ( ) ; } 
public void run ( ) { final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame ) ; Throwable renderException = null ; startRendering ( context ) ; try { context . renderNetwork ( renderNetwork ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); if (renderException == null) { finishedRendering(context, renderNetwork); 
public static Path textpath ( String text , String fontName , double fontSize , String alignment , Point position , double width , double height ) { Text . Align align ; try { align = Text . Align . valueOf ( alignment ) ; } catch ( IllegalArgumentException ignore ) { align = Text . Align . CENTER ; } if ( align = = Text . Align . LEFT ) { position = position . moved ( 0 , 0 ) ; } else if ( align = = Text . Align . CENTER ) { position = position . moved ( - width / 2 , 0 ) ; } else if ( align = = Text . Align . RIGHT ) { position = position . moved ( - width , 0 ) ; } Text = new Text ( text , position . x , position . y , width , height ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setAlign ( align ) ; return . getPath ( ) ; } 
public void testListRange ( ) { Node node = Node . ROOT . withFunction ( " math/average " ) . withInputAdded ( Port . floatPort ( " values " , 42 ) . withRange ( Port . Range . LIST ) ) ; assertResultsEqual ( node ) ; } 
private void run ( ) { showProgressDialog ( ) ; startupWorker = new SwingWorker < Throwable , String > ( ) { @Override protected Throwable doInBackground ( ) throws Exception { try { publish ( " Starting NodeBox " ) ; initApplication ( ) ; checkForUpdates ( ) ; } catch ( RuntimeException ex ) { return ex ; } return null ; } @Override protected void process ( List < String > strings ) { final String firstString = strings . get ( 0 ) ; startupDialog . setMessage ( firstString ) ; } @Override protected void done ( ) { startingUp . set ( false ) ; startupDialog . setVisible ( false ) ; See if application startup has generated an exception. Throwable t; try { t = get(); } catch (Exception e) { t = e; } if (t != null) { ExceptionDialog ed = new ExceptionDialog(null, t); ed.setVisible(true); System.exit(-1); } if (documents.isEmpty() && filesToLoad.isEmpty()) { instance.createNewDocument(); } else { for (File f : filesToLoad) { openDocument(f); } } } }; startupWorker.execute(); } 
protected Throwable doInBackground ( ) throws Exception { try { publish ( " Starting NodeBox " ) ; initApplication ( ) ; checkForUpdates ( ) ; } catch ( RuntimeException ex ) { return ex ; } return null ; } 
private void initApplication ( ) { setNodeBoxVersion ( ) ; createNodeBoxDataDirectories ( ) ; applyPreferences ( ) ; registerForMacOSXEvents ( ) ; initPython ( ) ; } 
private void checkForUpdates ( ) { updater = new Updater ( Application . this ) ; updater . checkForUpdatesInBackground ( ) ; } 
public void takeScreenshotOfDocument ( String documentFileName ) { File documentFile = new File ( documentFileName ) ; File documentDirectory = documentFile . getParentFile ( ) ; String imageName = FileUtils . getBaseName ( documentFile . getName ( ) ) + " .png " ; File screenshotFile = new File ( documentDirectory , imageName ) ; NodeBoxDocument doc = NodeBoxDocument . load ( documentFile ) ; addDocument ( doc ) ; doc . setVisible ( true ) ; doc . takeScreenshot ( screenshotFile ) ; doc . close ( ) ; } 
public static void main ( String [ ] args ) { final Application app = new Application ( ) ; if ( args . length = = 2 & & args [ 0 ] . equals ( " --screenshot " ) ) { String fileName = args [ 1 ] ; 
public void run ( ) { app . run ( ) ; } 
public void takeScreenshot ( File outputFile ) { Container c = getContentPane ( ) ; BufferedImage img = new BufferedImage ( c . getWidth ( ) , c . getHeight ( ) , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g2 = img . createGraphics ( ) ; c . paint ( g2 ) ; try { ImageIO . write ( img , " png " , outputFile ) ; 
public void testGetBaseName ( ) { assertEquals ( " helloworld " , getBaseName ( " helloworld.png " ) ) ; assertEquals ( " a.lot.of.dots " , getBaseName ( " a.lot.of.dots.dot " ) ) ; assertEquals ( " noextension " , getBaseName ( " noextension " ) ) ; } 
private static NodeLibrary create ( String libraryName , Node root , NodeRepository nodeRepository , FunctionRepository functionRepository , UUID uuid ) { return new NodeLibrary ( libraryName , null , root , nodeRepository , functionRepository , ImmutableMap . < String , String > of ( ) , uuid ) ; } 
public boolean hasProperty ( String name ) { return properties . containsKey ( name ) ; } 
public boolean isValidPropertyName ( String name ) { checkNotNull ( name ) ; no whitespace, only lowercase, numbers + period. return true; } 
public NodeLibrary withProperty ( String name , String value ) { ImmutableMap . Builder < String , String > b = ImmutableMap . builder ( ) ; checkArgument ( isValidPropertyName ( name ) , " Property name '%s' is not valid. " , name ) ; b . putAll ( properties ) ; b . put ( name , value ) ; return withProperties ( b . build ( ) ) ; } 
private NodeLibrary withProperties ( ImmutableMap < String , String > properties ) { return new NodeLibrary ( this . name , this . file , this . root , this . nodeRepository , this . functionRepository , properties , this . uuid ) ; 
private static NodeLibrary parseNDBX ( String libraryName , File file , XMLStreamReader reader , NodeRepository nodeRepository , UUID uuid ) throws XMLStreamException { List < FunctionLibrary > functionLibraries = new LinkedList < FunctionLibrary > ( ) ; Map < String , String > propertyMap = new HashMap < String , String > ( ) ; Node rootNode = Node . ROOT ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " property " ) ) { parseProperty ( reader , propertyMap ) ; } else if ( tagName . equals ( " link " ) ) { FunctionLibrary functionLibrary = parseLink ( file , reader ) ; functionLibraries . add ( functionLibrary ) ; } else if ( tagName . equals ( " node " ) ) { rootNode = parseNode ( reader , rootNode , nodeRepository ) ; } else { throw new XMLStreamException ( " Unknown tag " + tagName , reader . getLocation ( ) ) ; } } else if ( eventType = = XMLStreamConstants . END_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) break ; } } FunctionLibrary [ ] fl = functionLibraries . toArray ( new FunctionLibrary [ functionLibraries . size ( ) ] ) ; return new NodeLibrary ( libraryName , file , rootNode , nodeRepository , FunctionRepository . of ( fl ) , propertyMap , uuid ) ; } 
private static void parseProperty ( XMLStreamReader reader , Map < String , String > propertyMap ) throws XMLStreamException { String name = reader . getAttributeValue ( null , " name " ) ; String value = reader . getAttributeValue ( null , " value " ) ; if ( name = = null | | value = = null ) return ; propertyMap . put ( name , value ) ; } 
public NodeLibrary withRoot ( Node newRoot ) { return new NodeLibrary ( this . name , this . file , newRoot , this . nodeRepository , this . functionRepository , this . properties , this . uuid ) ; } 
public NodeLibrary withFunctionRepository ( FunctionRepository newRepository ) { return new NodeLibrary ( this . name , this . file , this . root , this . nodeRepository , newRepository , this . properties , this . uuid ) ; } 
private void assertPrototypeBeforeInstance ( String prototypeName , String . . . instanceNames ) { Node originalPrototype = Node . ROOT . withName ( prototypeName ) ; Node network = Node . ROOT . withChildAdded ( originalPrototype ) ; for ( String instanceName : instanceNames ) { Node originalInstance = originalPrototype . extend ( ) . withName ( instanceName ) ; network = network . withChildAdded ( originalInstance ) ; } NodeLibrary originalLibrary = NodeLibrary . create ( " test " , network ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Node prototype = library . getRoot ( ) . getChild ( prototypeName ) ; for ( String instanceName : instanceNames ) { Node instance = library . getRoot ( ) . getChild ( instanceName ) ; 
public void testDocumentProperties ( ) { NodeLibrary library = NodeLibrary . create ( " test " , Node . ROOT ) ; assertFalse ( library . hasProperty ( " alpha " ) ) ; library = library . withProperty ( " alpha " , " 42 " ) ; assertTrue ( library . hasProperty ( " alpha " ) ) ; assertEquals ( " 42 " , library . getProperty ( " alpha " ) ) ; library = library . withPropertyRemoved ( " alpha " ) ; assertFalse ( library . hasProperty ( " alpha " ) ) ; assertEquals ( " notFound " , library . getProperty ( " alpha " , " notFound " ) ) ; } 
public void testDocumentPropertiesSerialization ( ) { NodeLibrary library = NodeLibrary . create ( " test " , Node . ROOT . extend ( ) ) ; library = library . withProperty ( " alpha " , " 42 " ) ; String xml = library . toXml ( ) ; NodeLibrary newLibrary = NodeLibrary . load ( " test " , xml , NodeRepository . of ( ) ) ; assertTrue ( newLibrary . hasProperty ( " alpha " ) ) ; assertEquals ( " 42 " , newLibrary . getProperty ( " alpha " ) ) ; } 
public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) = = categoryField ) setCategory ( ) ; 
private void applyChanges ( ) { setCategory ( ) ; setDescription ( ) ; setImage ( ) ; setOutputType ( ) ; setOutputRange ( ) ; setFunction ( ) ; setHandle ( ) ; } 
public void focusGained ( FocusEvent e ) { } public void focusLost ( FocusEvent e ) { applyChanges ( ) ; } } 
public void focusLost ( FocusEvent e ) { applyChanges ( ) ; } 
public void groupIntoNetwork ( nodebox . graphics . Point pt ) { startEdits ( " Group Into Network Node " ) ; Node subnet = controller . groupIntoNetwork ( activeNetworkPath , networkView . getSelectedNodes ( ) ) ; controller . setNodePosition ( Node . path ( activeNetworkPath , subnet . getName ( ) ) , pt ) ; controller . setRenderedChild ( activeNetworkPath , subnet . getName ( ) ) ; stopEdits ( ) ; setActiveNode ( subnet ) ; networkView . updateAll ( ) ; networkView . select ( subnet ) ; requestRender ( ) ; } 
private void unpublish ( ) { getDocument ( ) . unpublish ( nodePort . getPort ( ) ) ; } 
public static String changeCase ( String value , String caseMethod ) { caseMethod = caseMethod . toLowerCase ( ) ; if ( caseMethod . equals ( " lowercase " ) ) { return value . toLowerCase ( ) ; 
private static void writePort ( Document doc , Element parent , Node node , Port port , Port . Direction direction ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = node.getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getInput(port.getName()); If the port and its prototype are equal, don't write anything. if (port.equals(protoPort)) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); el.setAttribute("type", port.getType()); if (shouldWriteAttribute(node, port, Port.Attribute.CHILD_REFERENCE)) el.setAttribute("childReference", port.getChildReference()); if (shouldWriteAttribute(node, port, Port.Attribute.WIDGET)) el.setAttribute("widget", port.getWidget().toString().toLowerCase()); if (shouldWriteAttribute(node, port, Port.Attribute.RANGE)) el.setAttribute("range", port.getRange().toString().toLowerCase()); if (port.isStandardType()) el.setAttribute("value", port.stringValue()); if (shouldWriteAttribute(node, port, Port.Attribute.MINIMUM_VALUE)) if (port.getMinimumValue() != null) el.setAttribute("min", String.format(Locale.US, "%s", port.getMinimumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MAXIMUM_VALUE)) if (port.getMaximumValue() != null) el.setAttribute("max", String.format(Locale.US, "%s", port.getMaximumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MENU_ITEMS)) writeMenuItems(doc, el, port.getMenuItems()); parent.appendChild(el); } 
public Node withChildInputRemoved ( String childName , String portName ) { checkArgument ( hasChild ( childName ) , " Node %s does not have a child named %s. " , this , childName ) ; Node child = getChild ( childName ) ; checkArgument ( child . hasInput ( portName ) , " Node %s does not have an input port %s. " , childName , portName ) ; if ( hasPublishedInput ( childName , portName ) ) return unpublish ( childName , portName ) . withChildInputRemoved ( childName , portName ) ; if ( isConnected ( childName , portName ) ) return disconnect ( childName , portName ) . withChildInputRemoved ( childName , portName ) ; return withChildReplaced ( childName , child . withInputRemoved ( portName ) ) ; } 
public Node withInputValue ( String portName , Object value ) { Port p = getInput ( portName ) ; checkNotNull ( p , " Input port %s does not exist on node %s. " , portName , this ) ; p = p . withValue ( value ) ; Node = this ; if ( p . isPublishedPort ( ) ) { String childNodeName = p . getChildNodeName ( ) ; Node newChildNode = p . getChildNode ( this ) . withInputValue ( p . getChildPortName ( ) , value ) ; = . withChildReplaced ( childNodeName , newChildNode ) ; } return . withInputChanged ( portName , p ) ; } 
public boolean hasPublishedInput ( String publishedName ) { return hasInput ( publishedName ) & & getInput ( publishedName ) . isPublishedPort ( ) ; } 
public Node unpublish ( String childNodeName , String childPortName ) { checkArgument ( hasChild ( childNodeName ) , " Node %s does not have a child named %s. " , this , childNodeName ) ; Node childNode = getChild ( childNodeName ) ; checkArgument ( childNode . hasInput ( childPortName ) , " Child node %s does not have a port named %s. " , childNodeName , childPortName ) ; Port childPort = childNode . getInput ( childPortName ) ; Port p = getPortByChildReference ( childNode , childPort ) ; return withInputRemoved ( p . getName ( ) ) ; } 
public Node unpublish ( String publishedName ) { return withInputRemoved ( publishedName ) ; } 
private boolean isConsistentWithPublishedInputs ( String childName , Node newChild ) { TODO Implement return true; for (PublishedPort pp : publishedInputs) { 
private Node withConsistentPublishedInputs ( String childName , Node newChild ) { TODO Implement return this; ImmutableList.Builder<PublishedPort> b = ImmutableList.builder(); 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String category = this . category ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case CATEGORY : category = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT, make the ROOT the prototype. if (prototype == null) { prototype = ROOT; } The name of a node can never be "_root". if (name.equals("_root")) { name = "node"; } return new Node(prototype, name, category, description, image, function, position, inputs, outputType, outputRange, children, renderedChildName, connections, handle); 
public int hashCode ( ) { return Objects . hashCode ( prototype , name , category , description , image , function , position , inputs , outputType , outputRange , children , renderedChildName , connections , handle ) ; 
public List < ? > renderNode ( Node node , Map < Port , ? > argumentMap ) { checkNotNull ( node ) ; checkNotNull ( functionRepository ) ; If the node has children, forgo the operation of the current node and evaluate the child. Object result; if (node.hasRenderedChild()) { result = renderChild(node, node.getRenderedChild(), argumentMap); } else { result = invokeNode(node, argumentMap); } return postProcessResult(node, result); } 
private List < ? > preprocessInput ( Port networkPort , Port childPort , Object value ) { if ( networkPort . hasListRange ( ) ) { if ( childPort . hasListRange ( ) ) { 
private List < ? > evaluatePort ( Node network , Node child , Port childPort , Map < Port , ? > networkArgumentMap ) { Node outputNode = findOutputNode ( network , child , childPort ) ; if ( outputNode ! = null ) { return renderChild ( network , outputNode , networkArgumentMap ) ; 
private static Node parseNode ( XMLStreamReader reader , Node parent , NodeRepository nodeRepository ) throws XMLStreamException { String prototypeId = reader . getAttributeValue ( null , " prototype " ) ; String name = reader . getAttributeValue ( null , " name " ) ; String category = reader . getAttributeValue ( null , " category " ) ; String description = reader . getAttributeValue ( null , " description " ) ; String image = reader . getAttributeValue ( null , " image " ) ; String function = reader . getAttributeValue ( null , " function " ) ; String outputType = reader . getAttributeValue ( null , " outputType " ) ; String outputRange = reader . getAttributeValue ( null , " outputRange " ) ; String position = reader . getAttributeValue ( null , " position " ) ; String renderedChildName = reader . getAttributeValue ( null , " renderedChild " ) ; String handle = reader . getAttributeValue ( null , " handle " ) ; Node prototype = prototypeId = = null ? Node . ROOT : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) { throw new XMLStreamException ( " Prototype " + prototypeId + " could not be found. " , reader . getLocation ( ) ) ; } Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( category ! = null ) node = node . withCategory ( category ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputType ! = null ) node = node . withOutputType ( outputType ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " node " ) ) { node = node . withChildAdded ( parseNode ( reader , node , nodeRepository ) ) ; } else if ( tagName . equals ( " port " ) ) { String portName = reader . getAttributeValue ( null , " name " ) ; Remove the port if it is already on the prototype. if (node.hasInput(portName)) { node = node.withInputChanged(portName, parsePort(reader, node.getInput(portName))); } else { node = node.withInputAdded(parsePort(reader, null)); } } else if (tagName.equals("conn")) { node = node.withConnectionAdded(parseConnection(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("node")) break; } } This has to come at the end, since the child first needs to exist. if (renderedChildName != null) node = node.withRenderedChildName(renderedChildName); return node; } 
private static Port parsePort ( XMLStreamReader reader , Port prototype ) throws XMLStreamException { Name and type are always required. String name = reader.getAttributeValue(null, "name"); String type = reader.getAttributeValue(null, "type"); String childReference = reader.getAttributeValue(null, "childReference"); String widget = reader.getAttributeValue(null, "widget"); String range = reader.getAttributeValue(null, "range"); String value = reader.getAttributeValue(null, "value"); String min = reader.getAttributeValue(null, "min"); String max = reader.getAttributeValue(null, "max"); Port port; if (prototype == null) { port = Port.portForType(name, type); } else { port = prototype; } Widget, value, min, max are optional and could come from the prototype. if (childReference != null) port = port.withParsedAttribute(Port.Attribute.CHILD_REFERENCE, childReference); if (widget != null) port = port.withParsedAttribute(Port.Attribute.WIDGET, widget); if (range != null) port = port.withParsedAttribute(Port.Attribute.RANGE, range); if (value != null) port = port.withParsedAttribute(Port.Attribute.VALUE, value); if (min != null) port = port.withParsedAttribute(Port.Attribute.MINIMUM_VALUE, min); if (max != null) port = port.withParsedAttribute(Port.Attribute.MAXIMUM_VALUE, max); ImmutableList.Builder<MenuItem> b = ImmutableList.builder(); while (true) { int eventType = reader.next(); if (eventType == XMLStreamConstants.START_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("menu")) { b.add(parseMenuItem(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("port")) break; } } ImmutableList<MenuItem> items = b.build(); if (!items.isEmpty()) port = port.withMenuItems(items); return port; } 
public static Port publishedPort ( Node childNode , Port childPort , String publishedName ) { checkNotNull ( childNode ) ; checkNotNull ( childPort ) ; String childReference = buildChildReference ( childNode , childPort ) ; return new Port ( publishedName , childPort . getType ( ) , childReference , childPort . getWidget ( ) , Range . LIST , childPort . getValue ( ) , childPort . getMinimumValue ( ) , childPort . getMaximumValue ( ) , childPort . getMenuItems ( ) ) ; } 
public static Port portForType ( String name , String type ) { checkNotNull ( type , " Type cannot be null. " ) ; If the type is not found in the default values, get() returns null, which is what we need for custom types. return new Port(name, type, null, defaultWidgetForType(type), DEFAULT_RANGE, DEFAULT_VALUES.get(type), null, null, ImmutableList.<MenuItem>of()); } 
public boolean isPublishedPort ( ) { return childReference ! = null ; } 
public Port withChildReference ( Node childNode , Port childPort ) { checkNotNull ( childNode ) ; checkNotNull ( childPort ) ; String childReference = buildChildReference ( childNode , childPort ) ; return new Port ( getName ( ) , getType ( ) , childReference , getWidget ( ) , getRange ( ) , getValue ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
private static String buildChildReference ( Node childNode , Port childPort ) { checkNotNull ( childNode ) ; checkNotNull ( childPort ) ; return String . format ( " %s.%s " , childNode . getName ( ) , childPort . getName ( ) ) ; } 
public Port withValue ( Object value ) { checkState ( isStandardType ( ) , " You can only change the value of a standard type. " ) ; checkArgument ( correctValueForType ( value ) , " Value '%s' is not correct for %s port. " , value , getType ( ) ) ; return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , clampValue ( convertValue ( getType ( ) , value ) ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withWidget ( Widget widget ) { return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , widget , getRange ( ) , getValue ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withRange ( Range range ) { return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , range , getValue ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withMinimumValue ( Double minimumValue ) { checkArgument ( type . equals ( Port . TYPE_INT ) | | type . equals ( Port . TYPE_FLOAT ) , " You can only set a minimum value on int or float ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , minimumValue , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withMaximumValue ( Double maximumValue ) { checkArgument ( type . equals ( Port . TYPE_INT ) | | type . equals ( Port . TYPE_FLOAT ) , " You can only set a maximum value on int or float ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getMinimumValue ( ) , maximumValue , getMenuItems ( ) ) ; } 
public Port withMenuItems ( Iterable < MenuItem > items ) { checkNotNull ( items ) ; checkArgument ( type . equals ( Port . TYPE_STRING ) , " You can only use menu items on string ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getMinimumValue ( ) , getMaximumValue ( ) , items ) ; } 
public Port withParsedAttribute ( Attribute attribute , String valueString ) { checkNotNull ( valueString ) ; String name = this . name ; String type = this . type ; String childReference = this . childReference ; Widget widget = this . widget ; Range range = this . range ; Object value = this . value ; Double minimumValue = this . minimumValue ; Double maximumValue = this . maximumValue ; switch ( attribute ) { case CHILD_REFERENCE : childReference = valueString ; break ; case VALUE : checkArgument ( STANDARD_TYPES . contains ( type ) , " Port %s: you can only set the value for one of the standard types, not %s (value=%s) " , name , type , valueString ) ; value = parseValue ( type , valueString ) ; break ; case WIDGET : widget = parseWidget ( valueString ) ; break ; case RANGE : range = parseRange ( valueString ) ; break ; case MINIMUM_VALUE : minimumValue = Double . valueOf ( valueString ) ; break ; case MAXIMUM_VALUE : maximumValue = Double . valueOf ( valueString ) ; break ; default : throw new AssertionError ( " You cannot use withParsedAttribute with attribute " + attribute ) ; } return new Port ( name , type , childReference , widget , range , value , minimumValue , maximumValue , getMenuItems ( ) ) ; } 
public static String toTitleCase ( String value ) { StringBuilder titleCase = new StringBuilder ( ) ; boolean nextTitleCase = true ; for ( char c : value . toCharArray ( ) ) { if ( Character . isSpaceChar ( c ) ) { nextTitleCase = true ; } else if ( nextTitleCase ) { c = Character . toTitleCase ( c ) ; nextTitleCase = false ; } titleCase . append ( c ) ; } return titleCase . toString ( ) ; } 
public void testRenderSubnetwork ( ) { Node subnet = createAddNetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node net = Node . NETWORK . withChildAdded ( subnet ) . withRenderedChildName ( " subnet1 " ) ; assertResultsEqual ( net , subnet , 3.0 ) ; } 
public void testValidSubnetworkResults ( ) { Node subnet1 = createAddNetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node subnet2 = createAddNetwork ( " subnet2 " , 3.0 , 4.0 ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node net = Node . ROOT . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) ; assertResultsEqual ( net , add1 , 10.0 ) ; } 
public void testRenderNetworkWithPublishedPorts ( ) { Node subNet = createAddNetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " value1 " ) . publish ( " number2 " , " number " , " value2 " ) . withInputValue ( " value1 " , 2.0 ) . withInputValue ( " value2 " , 3.0 ) ; Node net = Node . NETWORK . withChildAdded ( subNet ) . withRenderedChildName ( " subnet1 " ) ; assertResultsEqual ( net , subNet , 5.0 ) ; } 
public void testRenderNetworkWithConnectedPublishedPorts ( ) { Node addNet = createAddNetwork ( " addNet " , 0 , 0 ) . publish ( " number1 " , " number " , " value1 " ) . publish ( " number2 " , " number " , " value2 " ) ; Node number1 = numberNode . withName ( " number1 " ) . withInputValue ( " number " , 5.0 ) ; Node number2 = numberNode . withName ( " number2 " ) . withInputValue ( " number " , 3.0 ) ; Node net = Node . NETWORK . withChildAdded ( number1 ) . withChildAdded ( number2 ) . withChildAdded ( addNet ) . withRenderedChild ( addNet ) . connect ( " number1 " , " addNet " , " value1 " ) . connect ( " number2 " , " addNet " , " value2 " ) ; assertResultsEqual ( net , addNet , 8.0 ) ; } 
public void testRenderNestedNetworkWithConnectedPublishedPorts ( ) { Node subnet1 = createAddNetwork ( " subnet1 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node subnet2 = createAddNetwork ( " subnet2 " , 0.0 , 0.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node subnet = Node . NETWORK . withName ( " subnet " ) . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) . publish ( " subnet1 " , " n1 " , " value1 " ) . publish ( " subnet1 " , " n2 " , " value2 " ) . publish ( " subnet2 " , " n1 " , " value3 " ) . publish ( " subnet2 " , " n2 " , " value4 " ) ; Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , 11.0 ) ; Node number2 = numberNode . extend ( ) . withName ( " number2 " ) . withInputValue ( " number " , 22.0 ) ; Node number3 = numberNode . extend ( ) . withName ( " number3 " ) . withInputValue ( " number " , 33.0 ) ; Node number4 = numberNode . extend ( ) . withName ( " number4 " ) . withInputValue ( " number " , 44.0 ) ; Node net = Node . NETWORK . withChildAdded ( number1 ) . withChildAdded ( number2 ) . withChildAdded ( number3 ) . withChildAdded ( number4 ) . withChildAdded ( subnet ) . withRenderedChildName ( " subnet " ) . connect ( " number1 " , " subnet " , " value1 " ) . connect ( " number2 " , " subnet " , " value2 " ) . connect ( " number3 " , " subnet " , " value3 " ) . connect ( " number4 " , " subnet " , " value4 " ) ; assertResultsEqual ( net , subnet , 110.0 ) ; } 
public void testRenderUnpublishAndDisconnect ( ) { Node subNet = createAddNetwork ( " subNet " , 2.0 , 3.0 ) . publish ( " number1 " , " number " , " n1 " ) . publish ( " number2 " , " number " , " n2 " ) ; Node number = numberNode . extend ( ) . withName ( " number " ) . withInputValue ( " number " , 11.0 ) ; Node net = Node . NETWORK . withChildAdded ( number ) . withChildAdded ( subNet ) . withRenderedChildName ( " subNet " ) . connect ( " number " , " subNet " , " n1 " ) ; assertResultsEqual ( net , subNet , 14.0 ) ; subNet = subNet . unpublish ( " n1 " ) ; net = net . withChildReplaced ( " subNet " , subNet ) ; assertResultsEqual ( net , subNet , 5.0 ) ; } 
private Node createAddNetwork ( String name , double v1 , double v2 ) { Node number1 = numberNode . extend ( ) . withName ( " number1 " ) . withInputValue ( " number " , v1 ) ; Node number2 = numberNode . extend ( ) . withName ( " number2 " ) . withInputValue ( " number " , v2 ) ; return Node . NETWORK . withName ( name ) 
public void testNestedGenerator ( ) { Node repeat = Node . ROOT . withName ( " repeat " ) . withFunction ( " list/repeat " ) . withInputAdded ( Port . customPort ( " value " , " list " ) . withRange ( Port . Range . LIST ) ) . withInputAdded ( Port . intPort ( " amount " , 3 ) ) . withOutputRange ( Port . Range . LIST ) ; Node repeatNet = Node . NETWORK . withName ( " repeatNet " ) . withChildAdded ( repeat ) . withRenderedChild ( repeat ) . publish ( " repeat " , " value " , " strings " ) . withOutputRange ( Port . Range . VALUE ) ; Port publishedPort = repeatNet . getInput ( " strings " ) . withRange ( Port . Range . VALUE ) ; repeatNet = repeatNet . withInputChanged ( " strings " , publishedPort ) ; assertResultsEqual ( repeatNet ) ; Node makeStrings = Node . ROOT . withName ( " makeStrings " ) . withFunction ( " string/makeStrings " ) . withInputAdded ( Port . stringPort ( " value " , " A;B;C " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node net = Node . NETWORK . withChildAdded ( makeStrings ) . withChildAdded ( repeatNet ) . withRenderedChild ( repeatNet ) . connect ( " makeStrings " , " repeatNet " , " strings " ) ; assertResultsEqual ( net , ImmutableList . of ( " A " , " A " , " A " ) , ImmutableList . of ( " B " , " B " , " B " ) , ImmutableList . of ( " C " , " C " , " C " ) ) ; } 
public void testSimpleNestedFilter ( ) { Node makeStrings = Node . ROOT . withName ( " makeStrings " ) . withFunction ( " string/makeStrings " ) . withInputAdded ( Port . stringPort ( " value " , " alpha;beta;gamma " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node caseNode = Node . ROOT . withName ( " changeCase " ) . withFunction ( " string/changeCase " ) . withInputAdded ( Port . stringPort ( " value " , " " ) ) . withInputAdded ( Port . stringPort ( " method " , " uppercase " ) ) ; Node caseNet = Node . NETWORK . withName ( " caseNet " ) . withChildAdded ( caseNode ) . withRenderedChild ( caseNode ) . publish ( " changeCase " , " value " , " value " ) ; Node net = Node . NETWORK . withChildAdded ( makeStrings ) . withChildAdded ( caseNet ) . connect ( " makeStrings " , " caseNet " , " value " ) . withRenderedChild ( caseNet ) ; assertResultsEqual ( net , " ALPHA " , " BETA " , " GAMMA " ) ; } 
public void testNestedFilter ( ) { Node makeNestedWords = Node . NETWORK . withName ( " makeNestedWords " ) . withFunction ( " test/makeNestedWords " ) . withOutputType ( " string " ) . withOutputRange ( Port . Range . LIST ) ; Node length = Node . ROOT . withName ( " length " ) . withFunction ( " string/length " ) . withOutputType ( " string " ) . withInputAdded ( Port . stringPort ( " text " , " " ) ) ; Node lengthNet = Node . NETWORK . withName ( " lengthNet " ) . withChildAdded ( length ) . publish ( " length " , " text " , " text " ) . withRenderedChild ( length ) . withOutputRange ( Port . Range . VALUE ) ; Port publishedPort = lengthNet . getInput ( " text " ) . withRange ( Port . Range . VALUE ) ; lengthNet = lengthNet . withInputChanged ( " text " , publishedPort ) ; Node mainNetwork = Node . NETWORK . withChildAdded ( makeNestedWords ) . withChildAdded ( lengthNet ) . connect ( " makeNestedWords " , " lengthNet " , " text " ) . withRenderedChild ( lengthNet ) ; List < Integer > aCounts = ImmutableList . of ( 5 , 11 , 9 ) ; List < Integer > bCounts = ImmutableList . of ( 6 , 4 , 4 ) ; List < Integer > cCounts = ImmutableList . of ( 5 , 8 , 6 ) ; assertResultsEqual ( mainNetwork , aCounts , bCounts , cCounts ) ; } 
public void testPublish ( ) { Node invertNode = Node . ROOT . withName ( " negate " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , Node . NETWORK . withName ( " subnet " ) ) ; controller . addNode ( " /subnet " , invertNode ) ; controller . setRenderedChild ( " /subnet " , " negate " ) ; controller . publish ( " /subnet " , " negate " , " value " , " " ) ; assertTrue ( controller . getNode ( " /subnet " ) . hasPublishedInput ( " " ) ) ; controller . setPortValue ( " /subnet " , " " , 42.0 ) ; assertEquals ( 42 , controller . getNode ( " /subnet " ) . getPublishedPort ( " " ) . intValue ( ) ) ; assertEquals ( 42 , controller . getNode ( " /subnet/negate " ) . getInput ( " value " ) . intValue ( ) ) ; Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 20 ) ) ; controller . addNode ( " / " , numberNode ) ; controller . connect ( " / " , " number " , " subnet " , " " ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet " ) , - 20.0 ) ; controller . setPortValue ( " /number " , " value " , 55.0 ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet " ) , - 55.0 ) ; } 
public void testPublishInput ( ) { Node = net ; assertEquals ( 0 , . getPublishedPorts ( ) . size ( ) ) ; = . publish ( " number42 " , " number " , " pNumber " ) ; assertEquals ( 1 , . getPublishedPorts ( ) . size ( ) ) ; assertTrue ( . hasPublishedInput ( " number42 " , " number " ) ) ; } 
public void testPublishFromNonexistentChild ( ) { net . publish ( " number3 " , " number " , " pNumber " ) ; } 
public void testPublishFromNonexistentChildInput ( ) { net . publish ( " number42 " , " myNumber " , " pNumber " ) ; } 
public void testUnpublishInput ( ) { Node = net ; = . publish ( " number42 " , " number " , " pNumber " ) ; assertEquals ( 1 , . getPublishedPorts ( ) . size ( ) ) ; = . unpublish ( " number42 " , " number " ) ; assertEquals ( 0 , . getPublishedPorts ( ) . size ( ) ) ; assertFalse ( . hasPublishedInput ( " number42 " , " number " ) ) ; = . publish ( " number42 " , " number " , " aNumber " ) ; assertEquals ( 1 , . getPublishedPorts ( ) . size ( ) ) ; assertTrue ( . hasPublishedInput ( " aNumber " ) ) ; = . unpublish ( " aNumber " ) ; assertEquals ( 0 , . getPublishedPorts ( ) . size ( ) ) ; assertFalse ( . hasPublishedInput ( " aNumber " ) ) ; } 
private boolean isConsistentWithPublishedInputs ( String childName , Node newChild ) { TODO Implement return true; } 
private Node withConsistentPublishedInputs ( String childName , Node newChild ) { TODO Implement return this; } 
private static boolean noValues ( Iterable < ? > values ) { return values = = null | | Iterables . isEmpty ( values ) ; } 
public static double sum ( Iterable < Double > numbers ) { if ( noValues ( numbers ) ) return 0.0 ; double sum = 0 ; for ( Double d : numbers ) { sum + = d ; } return sum ; } 
public static double average ( Iterable < Double > numbers ) { if ( noValues ( numbers ) ) return 0.0 ; double sum = 0 ; double counter = 0 ; for ( Double d : numbers ) { sum + = d ; counter + + ; } return sum / counter ; } 
public static double max ( Iterable < Double > numbers ) { if ( noValues ( numbers ) ) return 0.0 ; double max = Iterables . getFirst ( numbers , 0.0 ) ; for ( Double d : numbers ) { max = Math . max ( max , d ) ; } return max ; } 
public static double min ( Iterable < Double > numbers ) { if ( noValues ( numbers ) ) return 0.0 ; double min = Iterables . getFirst ( numbers , 0.0 ) ; for ( Double d : numbers ) { min = Math . min ( min , d ) ; } return min ; } 
public void testListRange ( ) { Node node = Node . ROOT . withFunction ( " math/average " ) . withInputAdded ( Port . floatPort ( " values " , 42 ) . withRange ( Port . Range . LIST ) ) ; assertResultsEqual ( node , 0.0 ) ; } 
public void disabledTestCycles ( ) { TODO Infinite loops are not supported anymore! Create an infinite loop. Node n = net .connect("number42", "add", "v1") .connect("add", "number42", "number"); assertResultsEqual(n, 42.0); } 
private List < ? > postProcessResult ( Node node , Object result ) { if ( node . hasListOutputRange ( ) ) { TODO This is a temporary fix for networks that have no rendered nodes. 
public void testRenderEmptyNetwork ( ) { Node network = Node . NETWORK ; assertResultsEqual ( network , 0.0 ) ; } 
public void run ( ) { final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame ) ; Throwable renderException = null ; startRendering ( context ) ; List < ? > results = null ; try { results = context . renderNode ( renderNetwork ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); if (renderException == null) { finishedRendering(renderNetwork, results); 
public void groupIntoNetwork ( nodebox . graphics . Point pt ) { startEdits ( " Group Into Network Node " ) ; String renderedChild = getActiveNetwork ( ) . getRenderedChildName ( ) ; Node subnet = controller . groupIntoNetwork ( activeNetworkPath , networkView . getSelectedNodes ( ) ) ; controller . setNodePosition ( Node . path ( activeNetworkPath , subnet . getName ( ) ) , pt ) ; if ( renderedChild . equals ( subnet . getRenderedChildName ( ) ) ) controller . setRenderedChild ( activeNetworkPath , subnet . getName ( ) ) ; stopEdits ( ) ; setActiveNode ( subnet ) ; networkView . updateAll ( ) ; networkView . select ( subnet ) ; requestRender ( ) ; } 
public static boolean isPublished ( Node network , Node childNode , Port childPort ) { return network . hasPublishedInput ( childNode . getName ( ) , childPort . getName ( ) ) ; } 
public void groupIntoNetwork ( nodebox . graphics . Point pt ) { startEdits ( " Group into Network " ) ; String renderedChild = getActiveNetwork ( ) . getRenderedChildName ( ) ; Node subnet = controller . groupIntoNetwork ( activeNetworkPath , networkView . getSelectedNodes ( ) ) ; controller . setNodePosition ( Node . path ( activeNetworkPath , subnet . getName ( ) ) , pt ) ; if ( renderedChild . equals ( subnet . getRenderedChildName ( ) ) ) controller . setRenderedChild ( activeNetworkPath , subnet . getName ( ) ) ; stopEdits ( ) ; setActiveNode ( subnet ) ; networkView . updateAll ( ) ; networkView . select ( subnet ) ; requestRender ( ) ; } 
private static NodeLibrary createNewLibrary ( ) { NodeRepository nodeRepository = Application . getInstance ( ) . getSystemRepository ( ) ; Node root = Node . NETWORK . withName ( " root " ) ; Node rectPrototype = nodeRepository . getNode ( " corevector.rect " ) ; String name = root . uniqueName ( rectPrototype . getName ( ) ) ; Node rect1 = rectPrototype . extend ( ) . withName ( name ) . withPosition ( new nodebox . graphics . Point ( 1 , 1 ) ) ; root = root . withChildAdded ( rect1 ) . withRenderedChild ( rect1 ) ; return NodeLibrary . create ( " untitled " , root , nodeRepository , FunctionRepository . of ( ) ) ; } 
public static Port publishedPort ( Node childNode , Port childPort , String publishedName ) { checkNotNull ( childNode ) ; checkNotNull ( childPort ) ; String childReference = buildChildReference ( childNode , childPort ) ; return new Port ( publishedName , childPort . getType ( ) , childReference , childPort . getWidget ( ) , childPort . getRange ( ) , childPort . getValue ( ) , childPort . getMinimumValue ( ) , childPort . getMaximumValue ( ) , childPort . getMenuItems ( ) ) ; } 
public void testNestedGenerator ( ) { Node makeStrings = Node . ROOT . withName ( " makeStrings " ) . withFunction ( " string/makeStrings " ) . withInputAdded ( Port . stringPort ( " value " , " A;B;C " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node repeat = Node . ROOT . withName ( " repeat " ) . withFunction ( " list/repeat " ) . withInputAdded ( Port . customPort ( " value " , " list " ) . withRange ( Port . Range . LIST ) ) . withInputAdded ( Port . intPort ( " amount " , 3 ) ) . withOutputRange ( Port . Range . LIST ) ; Node repeatNet = Node . NETWORK . withName ( " repeatNet " ) . withChildAdded ( repeat ) . withRenderedChild ( repeat ) . publish ( " repeat " , " value " , " strings " ) . withOutputRange ( Port . Range . VALUE ) ; Port publishedPort = repeatNet . getInput ( " strings " ) . withRange ( Port . Range . VALUE ) ; repeatNet = repeatNet . withInputChanged ( " strings " , publishedPort ) ; assertResultsEqual ( repeatNet ) ; Node net = Node . NETWORK . withChildAdded ( makeStrings ) . withChildAdded ( repeatNet ) . withRenderedChild ( repeatNet ) . connect ( " makeStrings " , " repeatNet " , " strings " ) ; assertResultsEqual ( net , ImmutableList . of ( " A " , " A " , " A " ) , ImmutableList . of ( " B " , " B " , " B " ) , ImmutableList . of ( " C " , " C " , " C " ) ) ; } 
public void testNestedFilter ( ) { Node makeNestedWords = Node . NETWORK . withName ( " makeNestedWords " ) . withFunction ( " test/makeNestedWords " ) . withOutputType ( " string " ) . withOutputRange ( Port . Range . LIST ) ; Node length = Node . ROOT . withName ( " length " ) . withFunction ( " string/length " ) . withOutputType ( " string " ) . withInputAdded ( Port . stringPort ( " text " , " " ) ) ; Node lengthNet = Node . NETWORK . withName ( " lengthNet " ) . withChildAdded ( length ) . publish ( " length " , " text " , " text " ) . withRenderedChild ( length ) . withOutputRange ( Port . Range . VALUE ) ; Port textPort = lengthNet . getInput ( " text " ) . withRange ( Port . Range . LIST ) ; lengthNet = lengthNet . withInputChanged ( " text " , textPort ) ; Node mainNetwork = Node . NETWORK . withChildAdded ( makeNestedWords ) . withChildAdded ( lengthNet ) . connect ( " makeNestedWords " , " lengthNet " , " text " ) . withRenderedChild ( lengthNet ) ; List < Integer > aCounts = ImmutableList . of ( 5 , 11 , 9 ) ; List < Integer > bCounts = ImmutableList . of ( 6 , 4 , 4 ) ; List < Integer > cCounts = ImmutableList . of ( 5 , 8 , 6 ) ; assertResultsEqual ( mainNetwork , aCounts , bCounts , cCounts ) ; } 
public static Point coordinates ( Point p , double distance , double angle ) { double x = p . x + Math . cos ( radians ( angle ) ) * distance ; double y = p . y + Math . sin ( radians ( angle ) ) * distance ; return new Point ( x , y ) ; } 
public void testFrame ( ) { Node frame = Node . ROOT . withName ( " frame " ) . withFunction ( " core/frame " ) . withInputAdded ( Port . customPort ( " context " , " context " ) ) ; Node frameNet = Node . NETWORK . withChildAdded ( frame ) . withRenderedChild ( frame ) ; NodeContext c = new NodeContext ( testLibrary , 42.0 ) ; List < ? > results = c . renderNode ( frameNet ) ; assertResultsEqual ( results , 42.0 ) ; } 
public void testNestedFilter ( ) { Node makeNestedWords = Node . NETWORK . withName ( " makeNestedWords " ) . withFunction ( " test/makeNestedWords " ) . withOutputType ( " string " ) . withOutputRange ( Port . Range . LIST ) ; Node length = Node . ROOT . withName ( " length " ) . withFunction ( " string/length " ) . withOutputType ( " string " ) . withInputAdded ( Port . stringPort ( " text " , " " ) ) ; Node lengthNet = Node . NETWORK . withName ( " lengthNet " ) . withChildAdded ( length ) . publish ( " length " , " text " , " text " ) . withRenderedChild ( length ) . withOutputRange ( Port . Range . VALUE ) ; Port textPort = lengthNet . getInput ( " text " ) . withRange ( Port . Range . VALUE ) ; lengthNet = lengthNet . withInputChanged ( " text " , textPort ) ; Node mainNetwork = Node . NETWORK . withChildAdded ( makeNestedWords ) . withChildAdded ( lengthNet ) . connect ( " makeNestedWords " , " lengthNet " , " text " ) . withRenderedChild ( lengthNet ) ; List < Integer > aCounts = ImmutableList . of ( 5 , 11 , 9 ) ; List < Integer > bCounts = ImmutableList . of ( 6 , 4 , 4 ) ; List < Integer > cCounts = ImmutableList . of ( 5 , 8 , 6 ) ; assertResultsEqual ( mainNetwork , aCounts , bCounts , cCounts ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . setActiveNetwork ( Node . path ( getDocument ( ) . getActiveNetworkPath ( ) , nodePort . getNode ( ) ) ) ; 
private void drawPointNumbers ( Graphics2D g ) { if ( ! showPointNumbers ) return ; g . setFont ( Theme . SMALL_MONO_FONT ) ; g . setColor ( Color . BLUE ) ; int index = 0 ; if ( IGeometry . class . isAssignableFrom ( valuesClass ) ) { for ( Object o : outputValues ) { 
private void drawPointNumber ( Graphics2D g , nodebox . graphics . Point pt , int number ) { if ( pt . isOnCurve ( ) ) { g . setColor ( Color . BLUE ) ; } else { g . setColor ( Color . RED ) ; } g . drawString ( number + " " , ( int ) ( pt . x + 3 ) , ( int ) ( pt . y - 2 ) ) ; } 
public void testChildRenaming ( ) { Node = net ; = . publish ( " number42 " , " number " , " pNumber " ) ; = . withChildRenamed ( " number42 " , " myNumber42 " ) ; assertTrue ( . hasInput ( " pNumber " ) ) ; assertEquals ( " myNumber42 " , . getInput ( " pNumber " ) . getChildNodeName ( ) ) ; assertEquals ( " number " , . getInput ( " pNumber " ) . getChildPortName ( ) ) ; } 
public static Point parsePoint ( String s ) { return valueOf ( s ) ; } 
private List < ? > convertResultsForPort ( Port port , List < ? > values ) { Class outputType = ListUtils . listClass ( values ) ; ListConverter converter = conversionTable . get ( outputType , port . getType ( ) ) ; if ( converter ! = null ) { return converter . convert ( values ) ; 
public List < ? > convert ( List < ? > values ) ; } private abstract static class ValueConverter implements ListConverter { public List < ? > convert ( List < ? > values ) { ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; for ( Object v : values ) { b . add ( convertValue ( v ) ) ; } return b . build ( ) ; } public abstract Object convertValue ( Object value ) ; } private static class IntToFloatConverter extends ValueConverter { public Object convertValue ( Object value ) { return ( ( Long ) value ) . doubleValue ( ) ; } } private static class ObjectToStringConverter extends ValueConverter { public Object convertValue ( Object value ) { return value . toString ( ) ; } } private static class IntToBooleanConverter extends ValueConverter { public Object convertValue ( Object value ) { TODO Which values are true vs false? return ((Long) value) > 0; } } private static class IntToColorConverter extends ValueConverter { public Object convertValue(Object value) { long v = (Long) value; return new Color(v / 255.0, v / 255.0, v / 255.0); } } private static class IntToPointConverter extends ValueConverter { public Object convertValue(Object value) { long v = (Long) value; return new Point(v, v); } } private static class FloatToIntConverter extends ValueConverter { public Object convertValue(Object value) { return Math.round((Double) value); } } private static class FloatToBooleanConverter extends ValueConverter { public Object convertValue(Object value) { return ((Double) value) > 0; } } private static class FloatToColorConverter extends ValueConverter { public Object convertValue(Object value) { double v = (Double) value; return new Color(v / 255.0, v / 255.0, v / 255.0); } } private static class FloatToPointConverter extends ValueConverter { public Object convertValue(Object value) { double v = (Double) value; return new Point(v, v); } } private static class StringToIntConverter extends ValueConverter { public Object convertValue(Object value) { return Long.parseLong((String) value); } } private static class StringToFloatConverter extends ValueConverter { public Object convertValue(Object value) { return Double.parseDouble((String) value); } } private static class StringToBooleanConverter extends ValueConverter { public Object convertValue(Object value) { return Boolean.parseBoolean((String) value); } } private static class StringToColorConverter extends ValueConverter { public Object convertValue(Object value) { return Color.parseColor((String) value); } } private static class StringToPointConverter extends ValueConverter { public Object convertValue(Object value) { return Point.parsePoint((String) value); } } private static class BooleanToIntConverter extends ValueConverter { public Object convertValue(Object value) { return ((Boolean) value) ? 1 : 0; } } private static class BooleanToFloatConverter extends ValueConverter { public Object convertValue(Object value) { return ((Boolean) value) ? 1.0 : 0.0; } } private static class BooleanToColorConverter extends ValueConverter { public Object convertValue(Object value) { return ((Boolean) value) ? Color.WHITE : Color.BLACK; } } private static class GeometryToPointsConverter implements ListConverter { public List<?> convert(List<?> values) { ImmutableList.Builder<Object> b = ImmutableList.builder(); for (Object v : values) { b.addAll(((IGeometry) v).getPoints()); } return b.build(); } }} 
public List < ? > convert ( List < ? > values ) { ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; for ( Object v : values ) { b . add ( convertValue ( v ) ) ; } return b . build ( ) ; } 
public abstract Object convertValue ( Object value ) ; } private static class IntToFloatConverter extends ValueConverter { public Object convertValue ( Object value ) { return ( ( Long ) value ) . doubleValue ( ) ; } } private static class ObjectToStringConverter extends ValueConverter { public Object convertValue ( Object value ) { return value . toString ( ) ; } } private static class IntToBooleanConverter extends ValueConverter { public Object convertValue ( Object value ) { TODO Which values are true vs false? return ((Long) value) > 0; } } private static class IntToColorConverter extends ValueConverter { public Object convertValue(Object value) { long v = (Long) value; return new Color(v / 255.0, v / 255.0, v / 255.0); } } private static class IntToPointConverter extends ValueConverter { public Object convertValue(Object value) { long v = (Long) value; return new Point(v, v); } } private static class FloatToIntConverter extends ValueConverter { public Object convertValue(Object value) { return Math.round((Double) value); } } private static class FloatToBooleanConverter extends ValueConverter { public Object convertValue(Object value) { return ((Double) value) > 0; } } private static class FloatToColorConverter extends ValueConverter { public Object convertValue(Object value) { double v = (Double) value; return new Color(v / 255.0, v / 255.0, v / 255.0); } } private static class FloatToPointConverter extends ValueConverter { public Object convertValue(Object value) { double v = (Double) value; return new Point(v, v); } } private static class StringToIntConverter extends ValueConverter { public Object convertValue(Object value) { return Long.parseLong((String) value); } } private static class StringToFloatConverter extends ValueConverter { public Object convertValue(Object value) { return Double.parseDouble((String) value); } } private static class StringToBooleanConverter extends ValueConverter { public Object convertValue(Object value) { return Boolean.parseBoolean((String) value); } } private static class StringToColorConverter extends ValueConverter { public Object convertValue(Object value) { return Color.parseColor((String) value); } } private static class StringToPointConverter extends ValueConverter { public Object convertValue(Object value) { return Point.parsePoint((String) value); } } private static class BooleanToIntConverter extends ValueConverter { public Object convertValue(Object value) { return ((Boolean) value) ? 1 : 0; } } private static class BooleanToFloatConverter extends ValueConverter { public Object convertValue(Object value) { return ((Boolean) value) ? 1.0 : 0.0; } } private static class BooleanToColorConverter extends ValueConverter { public Object convertValue(Object value) { return ((Boolean) value) ? Color.WHITE : Color.BLACK; } } private static class GeometryToPointsConverter implements ListConverter { public List<?> convert(List<?> values) { ImmutableList.Builder<Object> b = ImmutableList.builder(); for (Object v : values) { b.addAll(((IGeometry) v).getPoints()); } return b.build(); } }} 
public Object convertValue ( Object value ) { return ( ( Long ) value ) . doubleValue ( ) ; } 
public Object convertValue ( Object value ) { return value . toString ( ) ; } 
public Object convertValue ( Object value ) { TODO Which values are true vs false? return ((Long) value) > 0; } 
public Object convertValue ( Object value ) { long v = ( Long ) value ; return new Color ( v / 255.0 , v / 255.0 , v / 255.0 ) ; } 
public Object convertValue ( Object value ) { long v = ( Long ) value ; return new Point ( v , v ) ; } 
public Object convertValue ( Object value ) { return Math . round ( ( Double ) value ) ; } 
public Object convertValue ( Object value ) { return ( ( Double ) value ) > 0 ; } 
public Object convertValue ( Object value ) { double v = ( Double ) value ; return new Color ( v / 255.0 , v / 255.0 , v / 255.0 ) ; } 
public Object convertValue ( Object value ) { double v = ( Double ) value ; return new Point ( v , v ) ; } 
public Object convertValue ( Object value ) { return Long . parseLong ( ( String ) value ) ; } 
public Object convertValue ( Object value ) { return Double . parseDouble ( ( String ) value ) ; } 
public Object convertValue ( Object value ) { return Boolean . parseBoolean ( ( String ) value ) ; } 
public Object convertValue ( Object value ) { return Color . parseColor ( ( String ) value ) ; } 
public Object convertValue ( Object value ) { return Point . parsePoint ( ( String ) value ) ; } 
public Object convertValue ( Object value ) { return ( ( Boolean ) value ) ? 1 : 0 ; } 
public Object convertValue ( Object value ) { return ( ( Boolean ) value ) ? 1.0 : 0.0 ; } 
public Object convertValue ( Object value ) { return ( ( Boolean ) value ) ? Color . WHITE : Color . BLACK ; } 
public List < ? > convert ( List < ? > values ) { ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; for ( Object v : values ) { b . addAll ( ( ( IGeometry ) v ) . getPoints ( ) ) ; } return b . build ( ) ; } 
public void testTypeConversion ( ) { assertConversion ( Port . TYPE_INT , Port . TYPE_INT , 42L , 42L ) ; assertConversion ( Port . TYPE_INT , Port . TYPE_FLOAT , 42L , 42.0 ) ; assertConversion ( Port . TYPE_INT , Port . TYPE_STRING , 42L , " 42 " ) ; assertConversion ( Port . TYPE_INT , Port . TYPE_BOOLEAN , 42L , true ) ; assertConversion ( Port . TYPE_INT , Port . TYPE_COLOR , 255L , Color . WHITE ) ; assertConversion ( Port . TYPE_INT , Port . TYPE_POINT , 42L , new Point ( 42 , 42 ) ) ; assertConversion ( Port . TYPE_FLOAT , Port . TYPE_INT , 42.0 , 42L ) ; assertConversion ( Port . TYPE_FLOAT , Port . TYPE_FLOAT , 42.0 , 42.0 ) ; assertConversion ( Port . TYPE_FLOAT , Port . TYPE_STRING , 42.0 , " 42.0 " ) ; assertConversion ( Port . TYPE_FLOAT , Port . TYPE_BOOLEAN , 0.0 , false ) ; assertConversion ( Port . TYPE_FLOAT , Port . TYPE_COLOR , 0.0 , Color . BLACK ) ; assertConversion ( Port . TYPE_FLOAT , Port . TYPE_POINT , 42.0 , new Point ( 42 , 42 ) ) ; assertConversion ( Port . TYPE_STRING , Port . TYPE_INT , " 42 " , 42L ) ; assertConversion ( Port . TYPE_STRING , Port . TYPE_FLOAT , " 42 " , 42.0 ) ; assertConversion ( Port . TYPE_STRING , Port . TYPE_STRING , " hello " , " hello " ) ; assertConversion ( Port . TYPE_STRING , Port . TYPE_BOOLEAN , " true " , true ) ; assertConversion ( Port . TYPE_STRING , Port . TYPE_BOOLEAN , " not-a-boolean " , false ) ; assertConversion ( Port . TYPE_STRING , Port . TYPE_COLOR , " #ff0000ff " , new Color ( 1 , 0 , 0 ) ) ; assertConversion ( Port . TYPE_STRING , Port . TYPE_POINT , " 4,2 " , new Point ( 4 , 2 ) ) ; assertConversion ( Port . TYPE_BOOLEAN , Port . TYPE_INT , true , 1L ) ; assertConversion ( Port . TYPE_BOOLEAN , Port . TYPE_INT , false , 0 L ) ; assertConversion ( Port . TYPE_BOOLEAN , Port . TYPE_FLOAT , true , 1.0 ) ; assertConversion ( Port . TYPE_BOOLEAN , Port . TYPE_STRING , true , " true " ) ; assertConversion ( Port . TYPE_BOOLEAN , Port . TYPE_STRING , false , " false " ) ; assertConversion ( Port . TYPE_BOOLEAN , Port . TYPE_BOOLEAN , false , false ) ; assertConversion ( Port . TYPE_BOOLEAN , Port . TYPE_COLOR , true , Color . WHITE ) ; assertConversion ( Port . TYPE_BOOLEAN , Port . TYPE_COLOR , false , Color . BLACK ) ; assertConversion ( Port . TYPE_COLOR , Port . TYPE_STRING , new Color ( 0 , 1 , 0 ) , " #00ff00ff " ) ; assertConversion ( Port . TYPE_COLOR , Port . TYPE_COLOR , Color . WHITE , Color . WHITE ) ; assertConversion ( Port . TYPE_POINT , Port . TYPE_STRING , new Point ( 4 , 2 ) , " 4.00,2.00 " ) ; assertConversion ( Port . TYPE_POINT , Port . TYPE_POINT , new Point ( 4 , 2 ) , new Point ( 4 , 2 ) ) ; } 
public void testGeometryToPointsConversion ( ) { Node line = Node . ROOT . withName ( " line " ) . withFunction ( " corevector/line " ) . withInputAdded ( Port . pointPort ( " point1 " , new Point ( 10 , 20 ) ) ) . withInputAdded ( Port . pointPort ( " point2 " , new Point ( 30 , 40 ) ) ) ; Node point = Node . ROOT . withName ( " point " ) . withFunction ( " corevector/point " ) . withInputAdded ( Port . pointPort ( " value " , Point . ZERO ) ) ; Node net = Node . NETWORK . withChildAdded ( line ) . withChildAdded ( point ) . withRenderedChild ( point ) . connect ( " line " , " point " , " value " ) ; assertResultsEqual ( net , new Point ( 10 , 20 ) , new Point ( 30 , 40 ) ) ; } 
private void assertConversion ( String sourceType , String targetType , Object sourceValue , Object targetValue ) { String generateFunction = identityFunction ( sourceType ) ; Port generatePort = Port . parsedPort ( " value " , sourceType , sourceValue . toString ( ) ) ; String convertFunction = identityFunction ( targetType ) ; Port convertPort = Port . portForType ( " value " , targetType ) ; Node net = buildTypeConversionNetwork ( generateFunction , generatePort , convertFunction , convertPort ) ; assertResultsEqual ( net , targetValue ) ; } 
private String identityFunction ( String portType ) { ImmutableMap . Builder < String , String > b = ImmutableMap . builder ( ) ; b . put ( Port . TYPE_INT , " math/integer " ) ; b . put ( Port . TYPE_FLOAT , " math/number " ) ; b . put ( Port . TYPE_STRING , " string/string " ) ; b . put ( Port . TYPE_BOOLEAN , " math/makeBoolean " ) ; b . put ( Port . TYPE_COLOR , " color/color " ) ; b . put ( Port . TYPE_POINT , " corevector/point " ) ; ImmutableMap < String , String > functions = b . build ( ) ; return functions . get ( portType ) ; } 
private Node buildTypeConversionNetwork ( String generateFunction , Port generatePort , String convertFunction , Port convertPort ) { Node generator = Node . ROOT . withName ( " generate " ) . withFunction ( generateFunction ) . withInputAdded ( generatePort ) ; Node converter = Node . ROOT . withName ( " convert " ) . withFunction ( convertFunction ) . withInputAdded ( convertPort ) ; return Node . NETWORK . withChildAdded ( generator ) 
public void testNestedFilter ( ) { Node makeNestedWords = Node . NETWORK . withName ( " makeNestedWords " ) . withFunction ( " test/makeNestedWords " ) . withOutputType ( " string " ) . withOutputRange ( Port . Range . LIST ) ; Node length = Node . ROOT . withName ( " length " ) . withFunction ( " string/length " ) . withOutputType ( " string " ) . withInputAdded ( Port . stringPort ( " text " , " " ) ) ; Node lengthNet = Node . NETWORK . withName ( " lengthNet " ) . withChildAdded ( length ) . publish ( " length " , " text " , " text " ) . withRenderedChild ( length ) . withOutputRange ( Port . Range . VALUE ) ; Port textPort = lengthNet . getInput ( " text " ) . withRange ( Port . Range . VALUE ) ; lengthNet = lengthNet . withInputChanged ( " text " , textPort ) ; Node mainNetwork = Node . NETWORK . withChildAdded ( makeNestedWords ) . withChildAdded ( lengthNet ) . connect ( " makeNestedWords " , " lengthNet " , " text " ) . withRenderedChild ( lengthNet ) ; List < Integer > aCounts = ImmutableList . of ( 5 , 11 , 9 ) ; List < Integer > bCounts = ImmutableList . of ( 6 , 4 , 4 ) ; List < Integer > cCounts = ImmutableList . of ( 5 , 8 , 6 ) ; assertResultsEqual ( mainNetwork , aCounts , bCounts , cCounts ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { CodeLibrariesDialog . this . setVisible ( false ) ; } 
public void showCodeLibraries ( ) { CodeLibrariesDialog dialog = new CodeLibrariesDialog ( this , getNodeLibrary ( ) . getFunctionRepository ( ) ) ; dialog . setVisible ( true ) ; FunctionRepository functionRepository = dialog . getFunctionRepository ( ) ; if ( functionRepository ! = null ) { addEdit ( " Change function repository " ) ; 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . showCodeLibraries ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { String key = " property " + propertyCounter ; properties . put ( key , " value " ) ; propertyKeys . add ( key ) ; propertyCounter + + ; table . tableChanged ( new TableModelEvent ( propertiesModel ) ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { int rowIndex = table . getSelectedRow ( ) ; if ( rowIndex > = 0 ) { String key = propertyKeys . get ( rowIndex ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { committed = false ; setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { committed = true ; setVisible ( false ) ; } 
public boolean isCellEditable ( int rowIndex , int columnIndex ) { return true ; } 
public static void main ( String [ ] args ) { NodeLibrary library = NodeLibrary . create ( " test " , Node . ROOT ) ; library = library . withProperty ( " screenshot.region " , " network " ) ; library = library . withProperty ( " screenshot.path " , " /root/invader " ) ; DocumentPropertiesDialog editor = new DocumentPropertiesDialog ( new NodeBoxDocument ( library ) ) ; editor . setVisible ( true ) ; } 
public void showDocumentProperties ( ) { DocumentPropertiesDialog dialog = new DocumentPropertiesDialog ( this ) ; dialog . setVisible ( true ) ; if ( dialog . isCommitted ( ) ) { addEdit ( " Change document properties " ) ; 
public NodeLibrary withProperties ( Map < String , String > properties ) { return new NodeLibrary ( this . name , this . file , this . root , this . nodeRepository , this . functionRepository , ImmutableMap . copyOf ( properties ) , this . uuid ) ; 
public static Point reflect ( Point p1 , Point p2 , double angle , double distance ) { distance * = distance ( p1 , p2 ) ; angle + = angle ( p1 , p2 ) ; return coordinates ( p1 , angle , distance ) ; } 
public String uniqueInputName ( String prefix ) { Matcher m = UNDERSCORE_NUMBER_AT_THE_END . matcher ( prefix ) ; m . find ( ) ; String namePrefix = m . group ( 1 ) ; String number = m . group ( 3 ) ; int counter ; if ( number . length ( ) > 0 ) { counter = Integer . parseInt ( number ) ; } else { counter = 1 ; } while ( true ) { String suggestedName = namePrefix + " _ " + counter ; 
public String uniqueInputName ( String prefix ) { Matcher m = UNDERSCORE_NUMBER_AT_THE_END . matcher ( prefix ) ; m . find ( ) ; String namePrefix = m . group ( 1 ) ; String number = m . group ( 4 ) ; int counter ; if ( number ! = null & & number . length ( ) > 0 ) { counter = Integer . parseInt ( number ) ; } else { counter = 1 ; } while ( true ) { String suggestedName = namePrefix + " _ " + counter ; 
public void testGroupIntoNetwork ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 15 ) ) ; controller . addNode ( " / " , numberNode ) ; Node invertNode = Node . ROOT . withName ( " negate " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , invertNode ) ; controller . setRenderedChild ( " / " , " negate " ) ; controller . connect ( " / " , controller . getNode ( " /number " ) , invertNode , invertNode . getInput ( " value " ) ) ; Node subnet = controller . groupIntoNetwork ( " / " , ImmutableList . of ( numberNode , invertNode ) ) ; assertTrue ( subnet . hasChild ( " number " ) ) ; assertTrue ( subnet . hasChild ( " negate " ) ) ; assertEquals ( 1 , subnet . getConnections ( ) . size ( ) ) ; assertEquals ( 1 , controller . getRootNode ( ) . getChildren ( ) . size ( ) ) ; assertSame ( subnet , controller . getRootNode ( ) . getChild ( " subnet1 " ) ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet1 " ) , - 15.0 ) ; } 
public void testGroupAndPublish ( ) { Node piNode = Node . ROOT . withName ( " pi " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 3.1415 ) ) ; controller . addNode ( " / " , piNode ) ; Node multiply1Node = Node . ROOT . withName ( " multiply1 " ) . withFunction ( " math/multiply " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 2 ) ) ; controller . addNode ( " / " , multiply1Node ) ; Node multiply2Node = Node . ROOT . withName ( " multiply2 " ) . withFunction ( " math/multiply " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 0 ) ) ; controller . addNode ( " / " , multiply2Node ) ; Node radiusNode = Node . ROOT . withName ( " radius " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 2 ) ) ; controller . addNode ( " / " , radiusNode ) ; controller . connect ( " / " , " pi " , " multiply1 " , " value1 " ) ; controller . connect ( " / " , " radius " , " multiply2 " , " value1 " ) ; controller . connect ( " / " , " multiply1 " , " multiply2 " , " value2 " ) ; controller . setRenderedChild ( " / " , " multiply2 " ) ; Node subnet1 = controller . groupIntoNetwork ( " / " , ImmutableList . of ( piNode , multiply1Node , multiply2Node ) ) ; Node root = controller . getRootNode ( ) ; assertEquals ( 2 , root . getChildren ( ) . size ( ) ) ; assertTrue ( root . hasChild ( radiusNode ) ) ; assertTrue ( root . hasChild ( subnet1 ) ) ; assertEquals ( 1 , subnet1 . getInputs ( ) . size ( ) ) ; assertEquals ( " value1 " , subnet1 . getInputs ( ) . get ( 0 ) . getName ( ) ) ; assertEquals ( 1 , root . getConnections ( ) . size ( ) ) ; assertEquals ( " radius " , root . getConnection ( " subnet1 " , " value1 " ) . getOutputNode ( ) ) ; } 
public void testGroupingAndPortNaming ( ) { Node number1Node = Node . ROOT . withName ( " number1 " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 2 ) ) ; controller . addNode ( " / " , number1Node ) ; Node multiply1Node = Node . ROOT . withName ( " multiply1 " ) . withFunction ( " math/multiply " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 3 ) ) ; controller . addNode ( " / " , multiply1Node ) ; Node add1Node = Node . ROOT . withName ( " add1 " ) . withFunction ( " math/add " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 3 ) ) ; controller . addNode ( " / " , add1Node ) ; Node divide1Node = Node . ROOT . withName ( " divide1 " ) . withFunction ( " math/divide " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 1 ) ) ; controller . addNode ( " / " , divide1Node ) ; controller . connect ( " / " , " number1 " , " multiply1 " , " value1 " ) ; controller . connect ( " / " , " number1 " , " add1 " , " value1 " ) ; controller . connect ( " / " , " multiply1 " , " divide1 " , " value1 " ) ; controller . connect ( " / " , " add1 " , " divide1 " , " value2 " ) ; controller . setRenderedChild ( " / " , " divide1 " ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /divide1 " ) , 1.2 ) ; Node subnet1 = controller . groupIntoNetwork ( " / " , ImmutableList . of ( multiply1Node , add1Node , divide1Node ) ) ; Node root = controller . getRootNode ( ) ; assertEquals ( 2 , root . getChildren ( ) . size ( ) ) ; assertTrue ( root . hasChild ( number1Node ) ) ; assertTrue ( root . hasChild ( subnet1 ) ) ; assertEquals ( 2 , subnet1 . getInputs ( ) . size ( ) ) ; List < Port > inputs = subnet1 . getInputs ( ) ; assertEquals ( " value1_1 " , inputs . get ( 0 ) . getName ( ) ) ; assertEquals ( " value1_2 " , inputs . get ( 1 ) . getName ( ) ) ; assertEquals ( 2 , root . getConnections ( ) . size ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " subnet1 " , " value1_1 " ) . getOutputNode ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " subnet1 " , " value1_2 " ) . getOutputNode ( ) ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet1 " ) , 1.2 ) ; } 
public static void main ( String [ ] args ) { int width = 640 ; int height = 480 ; Create a new movie. Movie movie = new Movie("test.mov", MP4VideoFormat.MP4Format, width, height); movie.setVerbose(true); / Initialize an image to draw on. BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); Graphics2D g = (Graphics2D) img.getGraphics(); g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); for (int frame = 0; frame < 20; frame++) { System.out.println("frame = " + frame); Clear the canvas and draw some simple circles. g.setColor(Color.WHITE); g.fillRect(0, 0, width, height); Random r = MathUtils.randomFromSeed(0); for (int j = 0; j < 100; j++) { g.setColor(new Color(r.nextInt(255), 255, r.nextInt(255))); g.fillOval(r.nextInt(width) + frame, r.nextInt(height) + frame, 30, 30); } Add the image to the movie. movie.addFrame(img); } Export the movie. movie.save(); } 
public static List < ? > shuffle ( Iterable < ? > iterable , long seed ) { if ( iterable = = null ) return ImmutableList . of ( ) ; List < ? > l = Lists . newArrayList ( iterable ) ; Collections . shuffle ( l , MathUtils . randomFromSeed ( seed ) ) ; return ImmutableList . copyOf ( l ) ; } 
public static List < ? > pick ( Iterable < ? > iterable , long amount , long seed ) { if ( iterable = = null | | amount < = 0 ) return ImmutableList . of ( ) ; List < ? > l = Lists . newArrayList ( iterable ) ; Collections . shuffle ( l , MathUtils . randomFromSeed ( seed ) ) ; if ( amount > = l . size ( ) ) return ImmutableList . copyOf ( l ) ; return ImmutableList . copyOf ( l . subList ( 0 , ( int ) amount ) ) ; } 
public static List < Double > randomNumbers ( long amount , double start , double end , long seed ) { Random r = MathUtils . randomFromSeed ( seed ) ; ImmutableList . Builder < Double > numbers = ImmutableList . builder ( ) ; for ( int i = 0 ; i < amount ; i + + ) { double v = start + ( r . nextDouble ( ) * ( end - start ) ) ; numbers . add ( v ) ; } return numbers . build ( ) ; } 
public static Random randomFromSeed ( long seed ) { return new Random ( seed * 1000000000 ) ; } 
public void testShuffle ( ) { Shuffling is stable: the same seed always returns the same sort order. assertElements(ListFunctions.shuffle(ImmutableList.of(), 42)); assertElements(ListFunctions.shuffle(ImmutableList.of(1), 42), 1); assertElements(ListFunctions.shuffle(ImmutableList.of(1, 2, 3, 4, 5), 42), 1, 3, 2, 4, 5); assertElements(ListFunctions.shuffle(ImmutableList.of(1, 2, 3, 4, 5), 33), 2, 1, 3, 4, 5); } 
private void assertElements ( Iterable < ? > iterable , Object . . . items ) { assertEquals ( ImmutableList . copyOf ( items ) , ImmutableList . copyOf ( iterable ) ) ; } 
public void testRandomNumbers ( ) { List < Double > numbers = MathFunctions . randomNumbers ( 3 , - 10.0 , 10.0 , 42 ) ; assertEquals ( 3.89263 , numbers . get ( 0 ) , 0.001 ) ; assertEquals ( 4.95359 , numbers . get ( 1 ) , 0.001 ) ; assertEquals ( 4.66839 , numbers . get ( 2 ) , 0.001 ) ; } 
public static List < ? > doSwitch ( Iterable list1 , Iterable list2 , Iterable list3 , long index ) { Iterable < ? > returnList ; switch ( ( int ) index % 3 ) { case 0 : returnList = list1 ; break ; case 1 : returnList = list2 ; break ; default : returnList = list3 ; break ; } if ( returnList = = null ) return ImmutableList . of ( ) ; return ImmutableList . < Object > copyOf ( returnList ) ; } 
public static List < ? > distinct ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; List < Object > newList = new ArrayList < Object > ( ) ; for ( Object object : iterable ) { if ( newList . contains ( object ) ) continue ; newList . add ( object ) ; } return ImmutableList . copyOf ( newList ) ; } 
public static List < Map < String , Object > > importCSV ( String fileName , String delimiter , String quotationCharacter ) { if ( fileName = = null | | fileName . trim ( ) . isEmpty ( ) ) return ImmutableList . of ( ) ; try { InputStreamReader in = new InputStreamReader ( new FileInputStream ( fileName ) , " UTF-8 " ) ; 
public void testImportCSV ( ) { List < Map < String , Object > > l = importSimpleCSV ( " src/test/files/colors.csv " ) ; assertEquals ( 5 , l . size ( ) ) ; Map < String , Object > black = l . get ( 0 ) ; assertResultsEqual ( black . keySet ( ) , " Name " , " Red " , " Green " , " Blue " ) ; assertEquals ( " Black " , black . get ( " Name " ) ) ; Numerical data is automatically converted to doubles. assertEquals(0.0, black.get("Red")); } 
public void testImportCSVUnicode ( ) { List < Map < String , Object > > l = importSimpleCSV ( " src/test/files/unicode.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > frederik = l . get ( 0 ) ; assertResultsEqual ( frederik . keySet ( ) , " Name " , " Age " ) ; assertEquals ( " Fr u00e9d u00ebr u00eck " , frederik . get ( " Name " ) ) ; Map < String , Object > bob = l . get ( 1 ) ; assertEquals ( " B u00f8b " , bob . get ( " Name " ) ) ; } 
public void testImportEmptyCSV ( ) { List l = importSimpleCSV ( null ) ; assertTrue ( l . isEmpty ( ) ) ; } 
public void testImportNonexistentCSV ( ) { importSimpleCSV ( " blah/blah.csv " ) ; } 
public void testImportCSVWithWhitespace ( ) { List < Map < String , Object > > l = importSimpleCSV ( " src/test/files/whitespace.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > alice = l . get ( 0 ) ; assertResultsEqual ( alice . keySet ( ) , " Name " , " Age " ) ; assertEquals ( " Alice " , alice . get ( " Name " ) ) ; Numerical data is automatically converted to doubles. assertEquals(41.0, alice.get("Age")); } 
public void testImportCSVWithBadHeaders ( ) { List < Map < String , Object > > l = importSimpleCSV ( " src/test/files/bad-headers.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > row1 = l . get ( 0 ) ; assertResultsEqual ( row1 . keySet ( ) , " Alpha " , " Column 2 " , " Column 3 " ) ; assertResultsEqual ( row1 . values ( ) , 1.0 , 2.0 , 3.0 ) ; } 
private List < Map < String , Object > > importSimpleCSV ( String fileName ) { return importCSV ( fileName , " comma " , " double " ) ; } 
public void testImportCSVWithDuplicateHeaders ( ) { List < Map < String , Object > > l = importSimpleCSV ( " src/test/files/duplicate-headers.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > row1 = l . get ( 0 ) ; assertResultsEqual ( row1 . keySet ( ) , " Strings " , " Numbers 1 " , " Integers " , " Numbers 2 " , " Floats " ) ; assertResultsEqual ( row1 . values ( ) , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 ) ; } 
public void testGroupingRenderedBeforeEnd ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 20 ) ) ; Node invert1Node = Node . ROOT . withName ( " negate1 " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; Node invert2Node = Node . ROOT . withName ( " negate2 " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , numberNode ) ; controller . addNode ( " / " , invert1Node ) ; controller . addNode ( " / " , invert2Node ) ; controller . connect ( " / " , numberNode , invert1Node , invert1Node . getInput ( " value " ) ) ; controller . connect ( " / " , numberNode , invert2Node , invert2Node . getInput ( " value " ) ) ; controller . setRenderedChild ( " / " , " number " ) ; controller . groupIntoNetwork ( " / " , ImmutableList . of ( numberNode , invert1Node , invert2Node ) ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /subnet1 " ) , 20.0 ) ; } 
private void unpublish ( ) { Port port = getActiveNetwork ( ) . getPortByChildReference ( nodePort . getNode ( ) , nodePort . getPort ( ) ) ; getDocument ( ) . unpublish ( port . getName ( ) ) ; } 
public static List < Map < String , Object > > importCSV ( String fileName , String delimiter , String quotationCharacter , String floatSeparator ) { if ( fileName = = null | | fileName . trim ( ) . isEmpty ( ) ) return ImmutableList . of ( ) ; try { InputStreamReader in = new InputStreamReader ( new FileInputStream ( fileName ) , " UTF-8 " ) ; 
public void testImportCSVWithDifferentFloatingPoint ( ) { List < Map < String , Object > > l = importCSV ( " src/test/files/floats.csv " , " semicolon " , " double " , " period " ) ; assertEquals ( 2 , l . size ( ) ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , 2.5 , 10.99 , 40000.6 ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , 25.0 , 1099.0 , 40.0 ) ; l = importCSV ( " src/test/files/floats.csv " , " semicolon " , " double " , " comma " ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , 25.0 , 1099.0 , 40.0 ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , 2.5 , 10.99 , 40000.6 ) ; } 
private List < Map < String , Object > > importSimpleCSV ( String fileName ) { return importCSV ( fileName , " comma " , " double " , " period " ) ; } 
private List < ? > convertResultsForPort ( Port port , List < ? > values ) { Class outputType = ListUtils . listClass ( values ) ; This is a special case: when working with geometry nodes, we may want to work with either single IGeometry objects or a list of Point's. In the latter case, we have to wrap these values in a list. if (outputType.equals(Point.class) && port.getType().equals("geometry") && port.hasValueRange()) return ImmutableList.of(values); ListConverter converter = conversionTable.get(outputType, port.getType()); if (converter != null) { return converter.convert(values); 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { showPopup ( e ) ; 
public void mouseReleased ( MouseEvent e ) { isDraggingNodes = false ; isDragSelecting = false ; if ( connectionOutput ! = null & & connectionInput ! = null ) { getDocument ( ) . connect ( connectionOutput . getName ( ) , connectionInput . node , connectionInput . port ) ; } connectionOutput = null ; if ( e . isPopupTrigger ( ) ) { showPopup ( e ) ; } repaint ( ) ; } 
private void showPopup ( MouseEvent e ) { Point pt = e . getPoint ( ) ; NodePort nodePort = getInputPortAt ( inverseViewTransformPoint ( pt ) ) ; if ( nodePort ! = null ) { JPopupMenu pMenu = new JPopupMenu ( ) ; 
public static Object skew ( Object shape , Point skew , Point origin ) { if ( shape = = null ) return null ; Transform = new Transform ( ) ; . translate ( origin ) ; . skew ( skew . x , skew . y ) ; . translate ( - origin . x , - origin . y ) ; if ( shape instanceof IGeometry ) { return . map ( ( IGeometry ) shape ) ; 
public static List < Map < String , Object > > importCSV ( String fileName , String delimiter , String quotationCharacter , String numberSeparator ) { if ( fileName = = null | | fileName . trim ( ) . isEmpty ( ) ) return ImmutableList . of ( ) ; try { InputStreamReader in = new InputStreamReader ( new FileInputStream ( fileName ) , " UTF-8 " ) ; 
private static Rectangle nodeRect ( Node node ) { return new Rectangle ( nodePoint ( node ) , getNodeDimension ( node ) ) ; } 
public static List < ? > shift ( Iterable < ? > iterable , long amount ) { if ( iterable = = null ) return ImmutableList . of ( ) ; int listSize = Iterables . size ( iterable ) ; if ( listSize = = 0 ) return ImmutableList . of ( ) ; while ( amount < 0 ) amount + = listSize ; int a = ( int ) amount % listSize ; if ( a = = 0 ) return ImmutableList . copyOf ( iterable ) ; Iterable < ? > tail = Iterables . skip ( iterable , a ) ; Iterable < ? > head = Iterables . limit ( iterable , a ) ; return ImmutableList . copyOf ( Iterables . concat ( tail , head ) ) ; } 
public static List < ? > repeat ( Iterable < ? > iterable , long amount , boolean perItem ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( amount < 1 ) return ImmutableList . of ( ) ; if ( amount = = 1 ) return ImmutableList . copyOf ( iterable ) ; if ( perItem ) { Iterator iterator = iterable . iterator ( ) ; 
public void testRepeat ( ) { assertElements ( ListFunctions . repeat ( ImmutableList . of ( ) , 0 , false ) ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( ) , 10 , false ) ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , - 1 , false ) ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , 0 , false ) ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , 1 , false ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , 2 , false ) , 1 , 2 , 3 , 1 , 2 , 3 ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 , 2 , 3 ) , 2 , true ) , 1 , 1 , 2 , 2 , 3 , 3 ) ; assertElements ( ListFunctions . repeat ( ImmutableList . of ( 1 ) , 5 , false ) , 1 , 1 , 1 , 1 , 1 ) ; } 
public void testNestedGenerator ( ) { Node makeStrings = Node . ROOT . withName ( " makeStrings " ) . withFunction ( " string/makeStrings " ) . withInputAdded ( Port . stringPort ( " value " , " A;B;C " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node repeat = Node . ROOT . withName ( " repeat " ) . withFunction ( " list/repeat " ) . withInputAdded ( Port . customPort ( " value " , " list " ) . withRange ( Port . Range . LIST ) ) . withInputAdded ( Port . intPort ( " amount " , 3 ) ) . withInputAdded ( Port . booleanPort ( " per_item " , false ) ) . withOutputRange ( Port . Range . LIST ) ; Node repeatNet = Node . NETWORK . withName ( " repeatNet " ) . withChildAdded ( repeat ) . withRenderedChild ( repeat ) . publish ( " repeat " , " value " , " strings " ) . withOutputRange ( Port . Range . VALUE ) ; Port publishedPort = repeatNet . getInput ( " strings " ) . withRange ( Port . Range . VALUE ) ; repeatNet = repeatNet . withInputChanged ( " strings " , publishedPort ) ; assertResultsEqual ( repeatNet ) ; Node net = Node . NETWORK . withChildAdded ( makeStrings ) . withChildAdded ( repeatNet ) . withRenderedChild ( repeatNet ) . connect ( " makeStrings " , " repeatNet " , " strings " ) ; assertResultsEqual ( net , ImmutableList . of ( " A " , " A " , " A " ) , ImmutableList . of ( " B " , " B " , " B " ) , ImmutableList . of ( " C " , " C " , " C " ) ) ; } 
public static List < ? > shift ( Iterable < ? > iterable , long amount ) { if ( iterable = = null ) return ImmutableList . of ( ) ; int listSize = Iterables . size ( iterable ) ; if ( listSize = = 0 ) return ImmutableList . of ( ) ; int a = ( int ) amount % listSize ; if ( a < 0 ) { a + = listSize ; } if ( a = = 0 ) return ImmutableList . copyOf ( iterable ) ; Iterable < ? > tail = Iterables . skip ( iterable , a ) ; Iterable < ? > head = Iterables . limit ( iterable , a ) ; return ImmutableList . copyOf ( Iterables . concat ( tail , head ) ) ; } 
public void testShift ( ) { assertElements ( ListFunctions . shift ( ImmutableList . of ( ) , 0 ) ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( ) , 10 ) ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 ) , 10 ) , 1 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , 1 ) , 2 , 3 , 1 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , 2 ) , 3 , 1 , 2 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , 3 ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , 4 ) , 2 , 3 , 1 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , - 1 ) , 3 , 1 , 2 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , - 2 ) , 2 , 3 , 1 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , - 3 ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . shift ( ImmutableList . of ( 1 , 2 , 3 ) , - 4 ) , 3 , 1 , 2 ) ; } 
public void updateAll ( ) { Node activeNode = getActiveNode ( ) ; if ( activeNode = = null ) { pane . setHeaderTitle ( " Ports " ) ; } else { pane . setHeaderTitle ( activeNode . getName ( ) ) ; } rebuildInterface ( ) ; validate ( ) ; repaint ( ) ; } 
public static PaneHeader withTitle ( String title ) { return new PaneHeader ( title ) ; } 
public static PaneHeader withoutTitle ( ) { return new PaneHeader ( null ) ; } 
private static NodeLibrary load ( String libraryName , File file , Reader r , NodeRepository nodeRepository ) throws XMLStreamException { XMLInputFactory xmlInputFactory = XMLInputFactory . newInstance ( ) ; XMLStreamReader reader = xmlInputFactory . createXMLStreamReader ( r ) ; NodeLibrary nodeLibrary = null ; while ( reader . hasNext ( ) ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) { String formatVersion = reader . getAttributeValue ( null , " formatVersion " ) ; if ( formatVersion ! = null & & ! CURRENT_FORMAT_VERSION . equals ( formatVersion ) ) { throw new OutdatedLibraryException ( file , " File uses version " + formatVersion + " , current version is " + CURRENT_FORMAT_VERSION + " . " ) ; } String uuidString = reader . getAttributeValue ( null , " uuid " ) ; UUID uuid = ( uuidString = = null ) ? UUID . randomUUID ( ) : UUID . fromString ( uuidString ) ; nodeLibrary = parseNDBX ( libraryName , file , reader , nodeRepository , uuid ) ; } else { throw new XMLStreamException ( " Only tag ndbx allowed, not " + tagName , reader . getLocation ( ) ) ; } } } return nodeLibrary ; } 
public static long round ( double a ) { return ( long ) a ; } 
public static UpgradeResult upgradeTo ( File file , String targetVersion ) throws LoadException { String currentXml = readFile ( file ) ; String currentVersion = parseFormatVersion ( currentXml ) ; ArrayList < String > warnings = new ArrayList < String > ( ) ; Avoid upgrades getting stuck in an infinite loop. int tries = 0; while (!currentVersion.equals(targetVersion) && tries < 100) { Method upgradeMethod = upgradeMap.get(currentVersion); if (upgradeMethod == null) { throw new LoadException(file, "Unsupported version " + currentVersion + ": this file is too old or too new."); } try { UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, currentXml); warnings.addAll(result.warnings); currentXml = result.xml; } catch (Exception e) { throw new LoadException(file, "Upgrading to " + currentVersion + " failed.", e); } currentVersion = parseFormatVersion(currentXml); tries++; } if (tries >= 100) { throw new LoadException(file, "Got stuck in an infinite loop when trying to upgrade from " + currentVersion); } return new UpgradeResult(file, currentXml, warnings); } 
private static String uniqueName ( String prefix , Set < String > existingNames ) { int counter = 1 ; while ( true ) { String suggestedName = prefix + counter ; 
private static void renamePortReference ( Elements elements , String attributeName , String oldNodeName , String newNodeName ) { for ( int i = 0 ; i < elements . size ( ) ; i + + ) { Element c = elements . get ( i ) ; 
private static void renameNodeReference ( Elements elements , String attributeName , String oldNodeName , String newNodeName ) { for ( int i = 0 ; i < elements . size ( ) ; i + + ) { Element c = elements . get ( i ) ; 
public void addWarning ( String warning ) { warnings . add ( warning ) ; } 
public static UpgradeStringResult upgrade2to3 ( String inputXml ) throws LoadException { UpgradeOp op1 = new ChangePrototypeOp ( " math.to_integer " , " math.round " ) ; UpgradeOp op2 = new RenameNodeOp ( " to_integer " , " round " ) ; return transformXml ( inputXml , " 3 " , op1 , op2 ) ; } 
private static UpgradeStringResult transformXml ( String xml , String newFormatVersion , UpgradeOp . . . ops ) { try { Document document = new Builder ( ) . build ( xml , null ) ; 
private static void transformXmlRecursive ( Element e , UpgradeOp op ) { op . apply ( e ) ; Elements children = e . getChildElements ( ) ; for ( int i = 0 ; i < children . size ( ) ; i + + ) { Element child = children . get ( i ) ; 
private static UpgradeStringResult transformDocument ( Document document , String newFormatVersion , Function < Element , String > function ) { Check that this is a NodeBox document and set the new formatVersion. Element root = document.getRootElement(); checkArgument(root.getLocalName().equals("ndbx"), "This is not a valid NodeBox document."); root.addAttribute(new Attribute("formatVersion", newFormatVersion)); Recursively transform all nodes. ArrayList<String> warnings = new ArrayList<String>(); transformElementsRecursive(root, "node", function, warnings); return new UpgradeStringResult(document.toXML(), warnings); } 
private static void transformElementsRecursive ( Element parent , String elementName , Function < Element , String > function , List < String > warnings ) { Elements nodes = parent . getChildElements ( elementName ) ; for ( int i = 0 ; i < nodes . size ( ) ; i + + ) { Element node = nodes . get ( i ) ; 
public void testUpgrade1to2 ( ) { File version1File = new File ( " src/test/files/upgrade-v1.ndbx " ) ; UpgradeResult result = NodeLibrary . upgrade ( version1File ) ; assertTrue ( " Result should contain updated position: " + result . getXml ( ) , result . getXml ( ) . contains ( " position= \" 12.00,2.00 \" " ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version1File , NodeRepository . of ( ) ) ; Node root = upgradedLibrary . getRoot ( ) ; Node alpha = root . getChild ( " alpha " ) ; assertEquals ( new Point ( 12 , 2 ) , alpha . getPosition ( ) ) ; } 
public void testUpgrade2to3 ( ) { File version2File = new File ( " src/test/files/upgrade-v2.ndbx " ) ; UpgradeResult result = NodeLibrary . upgradeTo ( version2File , " 3 " ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version2File , NodeRepository . of ( mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertTrue ( root . hasChild ( " round2 " ) ) ; Node round2 = root . getChild ( " round2 " ) ; assertEquals ( " round " , round2 . getPrototype ( ) . getName ( ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertTrue ( subnet1 . hasChild ( " round1 " ) ) ; Port value = subnet1 . getInput ( " value " ) ; assertEquals ( " round1.value " , value . getChildReference ( ) ) ; } 
public static NodeBoxDocument load ( File file ) { NodeLibrary library ; NodeBoxDocument document ; try { library = NodeLibrary . load ( file , Application . getInstance ( ) . getSystemRepository ( ) ) ; document = new NodeBoxDocument ( library ) ; document . setDocumentFile ( file ) ; } catch ( OutdatedLibraryException e ) { UpgradeResult result = NodeLibraryUpgrades . upgrade ( file ) ; The file is used here as the base name for finding relative libraries. library = result.getLibrary(file, Application.getInstance().getSystemRepository()); document = new NodeBoxDocument(library); document.showUpgradeResult(result); } catch (LoadException e) { throw new RuntimeException("Could not load " + file, e); } lastFilePath = file.getParentFile().getAbsolutePath(); return document; } 
public void showDocumentProperties ( ) { DocumentPropertiesDialog dialog = new DocumentPropertiesDialog ( this ) ; dialog . setVisible ( true ) ; if ( dialog . isCommitted ( ) ) { addEdit ( " Change document properties " ) ; 
private static Method upgradeMethod ( String methodName ) { try { return NodeLibraryUpgrades . class . getMethod ( methodName , String . class ) ; 
public static UpgradeResult upgrade ( File file ) throws LoadException { return upgradeTo ( file , NodeLibrary . CURRENT_FORMAT_VERSION ) ; } 
public void testParseFormatVersion ( ) { assertEquals ( " 1.0 " , NodeLibraryUpgrades . parseFormatVersion ( " <ndbx formatVersion='1.0'> " ) ) ; assertEquals ( " 2 " , NodeLibraryUpgrades . parseFormatVersion ( " <ndbx type= \" file \" formatVersion= \" 2 \" > " ) ) ; } 
public void testUpgrade1to2 ( ) { File version1File = new File ( " src/test/files/upgrade-v1.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version1File ) ; assertTrue ( " Result should contain updated position: " + result . getXml ( ) , result . getXml ( ) . contains ( " position= \" 12.00,2.00 \" " ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version1File , NodeRepository . of ( ) ) ; Node root = upgradedLibrary . getRoot ( ) ; Node alpha = root . getChild ( " alpha " ) ; assertEquals ( new Point ( 12 , 2 ) , alpha . getPosition ( ) ) ; } 
public void testUpgrade2to3 ( ) { File version2File = new File ( " src/test/files/upgrade-v2.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgradeTo ( version2File , " 3 " ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version2File , NodeRepository . of ( mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertTrue ( root . hasChild ( " round2 " ) ) ; Node round2 = root . getChild ( " round2 " ) ; assertEquals ( " round " , round2 . getPrototype ( ) . getName ( ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertTrue ( subnet1 . hasChild ( " round1 " ) ) ; Port value = subnet1 . getInput ( " value " ) ; assertEquals ( " round1.value " , value . getChildReference ( ) ) ; } 
public void testTooOldToUpgrade ( ) { File version09File = new File ( " src/test/files/upgrade-v0.9.ndbx " ) ; try { NodeLibraryUpgrades . upgrade ( version09File ) ; 
public void testTooNewToUpgrade ( ) { File version999Files = new File ( " src/test/files/upgrade-v999.ndbx " ) ; try { NodeLibraryUpgrades . upgrade ( version999Files ) ; 
public void testUpgrade2to3 ( ) { File version2File = new File ( " src/test/files/upgrade-v2.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version2File ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version2File , NodeRepository . of ( mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertTrue ( root . hasChild ( " round2 " ) ) ; Node round2 = root . getChild ( " round2 " ) ; assertEquals ( " round " , round2 . getPrototype ( ) . getName ( ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertTrue ( subnet1 . hasChild ( " round1 " ) ) ; assertEquals ( " round1 " , subnet1 . getRenderedChildName ( ) ) ; Port value = subnet1 . getInput ( " value " ) ; assertEquals ( " round1.value " , value . getChildReference ( ) ) ; } 
public void testUpgrade3to4 ( ) { File version3File = new File ( " src/test/files/upgrade-v3.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version3File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version3File , NodeRepository . of ( corevectorLibrary , listLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertEquals ( " make_point " , root . getChild ( " point1 " ) . getPrototype ( ) . getName ( ) ) ; assertTrue ( root . hasChild ( " point2 " ) ) ; assertEquals ( " point " , root . getChild ( " point2 " ) . getPrototype ( ) . getName ( ) ) ; assertTrue ( root . getConnections ( ) . contains ( new Connection ( " point2 " , " count1 " , " list " ) ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertTrue ( subnet1 . hasChild ( " point1 " ) ) ; assertEquals ( " point1 " , subnet1 . getRenderedChildName ( ) ) ; Port value = subnet1 . getInput ( " shape " ) ; assertEquals ( " point1.shape " , value . getChildReference ( ) ) ; } 
public static Path textpath ( String text , String fontName , double fontSize , String alignment , Point position , double width ) { Text . Align align ; try { align = Text . Align . valueOf ( alignment ) ; } catch ( IllegalArgumentException ignore ) { align = Text . Align . CENTER ; } if ( align = = Text . Align . LEFT ) { position = position . moved ( 0 , 0 ) ; } else if ( align = = Text . Align . CENTER ) { position = position . moved ( - width / 2 , 0 ) ; } else if ( align = = Text . Align . RIGHT ) { position = position . moved ( - width , 0 ) ; } Text = new Text ( text , position . x , position . y , width , 0 ) ; . setFontName ( fontName ) ; . setFontSize ( fontSize ) ; . setAlign ( align ) ; return . getPath ( ) ; } 
public void testUpgrade4to5 ( ) { File version4File = new File ( " src/test/files/upgrade-v4.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version4File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version4File , NodeRepository . of ( corevectorLibrary , mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertFalse ( root . getChild ( " textpath1 " ) . hasInput ( " height " ) ) ; assertNull ( root . getConnection ( " textpath2 " , " height " ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertFalse ( subnet1 . hasInput ( " height " ) ) ; Node subnet2 = root . getChild ( " subnet2 " ) ; assertFalse ( subnet2 . hasInput ( " height " ) ) ; } 
public static UpgradeStringResult upgrade1to2 ( String inputXml ) throws LoadException { Version 2: Vertical node networks 1. Rotate all nodes 90 degrees by reversing X and Y positions. 2. Convert from pixel units to grid units by dividing by GRID_CELL_SIZE. final int GRID_CELL_SIZE = 48; UpgradeOp verticalNodesOp = new UpgradeOp() { @Override public void apply(Element e) { if (!e.getLocalName().equals("node")) return; Attribute position = e.getAttribute("position"); if (position == null) return; Point pt = Point.valueOf(position.getValue()); Point reversedPoint = new Point(pt.y, pt.x); Point gridPoint = new Point(Math.round(reversedPoint.x / GRID_CELL_SIZE) * 3, Math.round(reversedPoint.y / GRID_CELL_SIZE)); position.setValue(String.valueOf(gridPoint)); } @Override public void end(Element root) { addWarning("Nodes have been rotated. Your network will look different."); } }; return transformXml(inputXml, "2", verticalNodesOp); } 
public void apply ( Element e ) { if ( ! e . getLocalName ( ) . equals ( " node " ) ) return ; Attribute position = e . getAttribute ( " position " ) ; if ( position = = null ) return ; Point pt = Point . valueOf ( position . getValue ( ) ) ; Point reversedPoint = new Point ( pt . y , pt . x ) ; Point gridPoint = new Point ( Math . round ( reversedPoint . x / GRID_CELL_SIZE ) * 3 , Math . round ( reversedPoint . y / GRID_CELL_SIZE ) ) ; position . setValue ( String . valueOf ( gridPoint ) ) ; } 
public void end ( Element root ) { addWarning ( " Nodes have been rotated. Your network will look different. " ) ; } 
public static UpgradeStringResult upgrade2to3 ( String inputXml ) throws LoadException { Version 3: Rename math.to_integer to math.round. UpgradeOp changePrototypeOp = new ChangePrototypeOp("math.to_integer", "math.round"); UpgradeOp renameOp = new RenameNodeOp("to_integer", "round"); return transformXml(inputXml, "3", changePrototypeOp, renameOp); } 
public static UpgradeStringResult upgrade3to4 ( String inputXml ) throws LoadException { Version 4: Convert corevector.to_points nodes to corevector.point nodes. UpgradeOp changePrototypeOp = new ChangePrototypeOp("corevector.to_points", "corevector.point"); UpgradeOp renameOp = new RenameNodeOp("to_points", "point"); return transformXml(inputXml, "4", changePrototypeOp, renameOp); } 
public static UpgradeStringResult upgrade4to5 ( String inputXml ) throws LoadException { Version 5: The corevector.textpath node loses the height port. UpgradeOp removeInputOp = new RemoveInputOp("corevector.textpath", "height"); return transformXml(inputXml, "5", removeInputOp); } 
private static void renameRenderedChildReference ( Element element , String oldNodeName , String newNodeName ) { Attribute renderedChildReference = element . getAttribute ( " renderedChild " ) ; if ( renderedChildReference = = null ) return ; String oldRenderedChild = renderedChildReference . getValue ( ) ; if ( oldRenderedChild . equals ( oldNodeName ) ) renderedChildReference . setValue ( newNodeName ) ; 
private static void removeConnection ( Element parent , String child , String input ) { Elements connections = parent . getChildElements ( " conn " ) ; for ( int i = 0 ; i < connections . size ( ) ; i + + ) { Element conn = connections . get ( i ) ; 
public static UpgradeStringResult upgrade5to6 ( String inputXml ) throws LoadException { Version 6: change delete.delete_selected boolean to menu options. Map<String, String> mappings = ImmutableMap.of("true", "selected", "false", "non-selected"); UpgradeOp renamePortOp = new RenamePortOp("corevector.delete", "delete_selected", "operation"); UpgradeOp changePortTypeOp = new ChangePortTypeOp("corevector.delete", "operation", "string", mappings); return transformXml(inputXml, "6", renamePortOp, changePortTypeOp); } 
private static void renamePortInElements ( Elements elements , String attributeName , String nodeName , String oldPortName , String newPortName ) { for ( int i = 0 ; i < elements . size ( ) ; i + + ) { Element c = elements . get ( i ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , oldPrototype ) ) { Attribute prototype = e . getAttribute ( " prototype " ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , nodePrototype ) ) { removeNodeInput ( e , inputToRemove ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , nodePrototype ) ) { String nodeName = e . getAttributeValue ( " name " ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , nodePrototype ) ) { Element port = portWithName ( e , portName ) ; 
public void testUpgrade5to6 ( ) { File version5File = new File ( " src/test/files/upgrade-v5.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version5File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version5File , NodeRepository . of ( corevectorLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; Node delete1 = root . getChild ( " delete1 " ) ; assertTrue ( delete1 . hasInput ( " operation " ) ) ; assertFalse ( delete1 . hasInput ( " delete_selected " ) ) ; assertEquals ( " selected " , delete1 . getInput ( " operation " ) . stringValue ( ) ) ; Node delete2 = root . getChild ( " delete2 " ) ; assertEquals ( " non-selected " , delete2 . getInput ( " operation " ) . stringValue ( ) ) ; } 
public static UpgradeStringResult upgrade5to6 ( String inputXml ) throws LoadException { Version 6: Change delete.delete_selected boolean to menu options. Map<String, String> mappings = ImmutableMap.of("true", "selected", "false", "non-selected"); UpgradeOp renamePortOp = new RenamePortOp("corevector.delete", "delete_selected", "operation"); UpgradeOp changePortTypeOp = new ChangePortTypeOp("corevector.delete", "operation", "string", mappings); return transformXml(inputXml, "6", renamePortOp, changePortTypeOp); } 
public static UpgradeStringResult upgrade6to7 ( String inputXml ) throws LoadException { Version 7: Replace instances of list.filter with list.cull. UpgradeOp changePrototypeOp = new ChangePrototypeOp("list.filter", "list.cull"); UpgradeOp renameOp = new RenameNodeOp("filter", "cull"); return transformXml(inputXml, "7", changePrototypeOp, renameOp); } 
public void testUpgrade6to7 ( ) { File version6File = new File ( " src/test/files/upgrade-v6.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version6File ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version6File , NodeRepository . of ( listLibrary , mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertFalse ( root . hasChild ( " filter1 " ) ) ; assertTrue ( root . hasChild ( " cull1 " ) ) ; assertEquals ( " cull1 " , root . getRenderedChildName ( ) ) ; assertResultsEqual ( root , 0.0 , 2.0 , 4.0 , 6.0 , 8.0 ) ; } 
public static Object first ( Iterable < ? > iterable ) { if ( iterable = = null ) return null ; Iterator iterator = iterable . iterator ( ) ; if ( iterator . hasNext ( ) ) { return iterator . next ( ) ; } return null ; } 
public static Object second ( Iterable < ? > iterable ) { if ( iterable = = null ) return null ; Iterator iterator = iterable . iterator ( ) ; if ( iterator . hasNext ( ) ) { iterator . next ( ) ; if ( iterator . hasNext ( ) ) { return iterator . next ( ) ; } } return null ; } 
public static Object last ( Iterable < ? > iterable ) { if ( iterable = = null ) return null ; try { return Iterables . getLast ( iterable ) ; 
public void testFirst ( ) { assertNull ( ListFunctions . first ( ImmutableList . of ( ) ) ) ; assertEquals ( ListFunctions . first ( ImmutableList . of ( 1 ) ) , 1 ) ; assertEquals ( ListFunctions . first ( ImmutableList . of ( 1 , 2 ) ) , 1 ) ; assertEquals ( ListFunctions . first ( ImmutableList . of ( 1 , 2 , 3 ) ) , 1 ) ; } 
public void testSecond ( ) { assertNull ( ListFunctions . second ( ImmutableList . of ( ) ) ) ; assertNull ( ListFunctions . second ( ImmutableList . of ( 1 ) ) ) ; assertEquals ( ListFunctions . second ( ImmutableList . of ( 1 , 2 ) ) , 2 ) ; assertEquals ( ListFunctions . second ( ImmutableList . of ( 1 , 2 , 3 ) ) , 2 ) ; } 
public void testLast ( ) { assertNull ( ListFunctions . last ( ImmutableList . of ( ) ) ) ; assertEquals ( ListFunctions . last ( ImmutableList . of ( 1 ) ) , 1 ) ; assertEquals ( ListFunctions . last ( ImmutableList . of ( 1 , 2 ) ) , 2 ) ; assertEquals ( ListFunctions . last ( ImmutableList . of ( 1 , 2 , 3 ) ) , 3 ) ; } 
public static List < ? > cull ( Iterable < ? > iterable , Iterable < Boolean > booleans ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( booleans = = null | | Iterables . isEmpty ( booleans ) ) return ImmutableList . copyOf ( iterable ) ; ImmutableList . Builder < Object > results = ImmutableList . builder ( ) ; Iterator < ? > booleanIterator = ( ( Iterable < ? > ) cycle ( booleans ) ) . iterator ( ) ; for ( Object object : iterable ) { boolean keep = ( Boolean ) booleanIterator . next ( ) ; if ( keep ) results . add ( object ) ; } return results . build ( ) ; } 
public static Point pointOnPath ( AbstractGeometry shape , double ) { if ( shape = = null ) return null ; = Math . abs ( % 100 ) ; return shape . pointAt ( / 100 ) ; } 
public static UpgradeStringResult upgrade7to8 ( String inputXml ) throws LoadException { Version 8: The corevector.point_on_path node loses the range port. UpgradeOp removeInputOp = new RemoveInputOp("corevector.point_on_path", "range"); return transformXml(inputXml, "8", removeInputOp); } 
public void testUpgrade7to8 ( ) { File version7File = new File ( " src/test/files/upgrade-v7.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version7File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version7File , NodeRepository . of ( corevectorLibrary , mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertFalse ( root . getChild ( " point_on_path1 " ) . hasInput ( " range " ) ) ; assertNull ( root . getConnection ( " point_on_path2 " , " range " ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertFalse ( subnet1 . hasInput ( " range " ) ) ; } 
private ImageFormat imageFormatForFile ( File file ) { if ( file . getName ( ) . toLowerCase ( ) . endsWith ( " .pdf " ) ) return ImageFormat . PDF ; return ImageFormat . PNG ; } 
public void doExport ( ) { File chosenFile = FileUtils . showSaveDialog ( this , lastExportPath , " png " , " PNG file " ) ; if ( chosenFile = = null ) return ; lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; exportToFile ( chosenFile , imageFormatForFile ( chosenFile ) ) ; } 
public String ensureFileExtension ( String file ) { if ( file . toLowerCase ( ) . endsWith ( " . " + getExtension ( ) ) ) return file ; return file + " . " + getExtension ( ) ; } 
public static boolean compare ( Comparable o1 , Comparable o2 , String comparator ) { int comparison = o1 . compareTo ( o2 ) ; if ( comparator . equals ( " < " ) ) { return comparison < 0 ; 
public static UpgradeStringResult upgrade8to9 ( String inputXml ) throws LoadException { Version 9: corevector's resample_by_amount and resample_by_length nodes are replaced by the more generic resample node. UpgradeOp addInputOp1 = new AddInputOp("corevector.resample_by_amount", "method", "string", "amount"); UpgradeOp changePrototypeOp1 = new ChangePrototypeOp("corevector.resample_by_amount", "corevector.resample"); UpgradeOp renameOp1 = new RenameNodeOp("resample_by_amount", "resample"); UpgradeOp addInputOp2 = new AddInputOp("corevector.resample_by_length", "method", "string", "length"); UpgradeOp changePrototypeOp2 = new ChangePrototypeOp("corevector.resample_by_length", "corevector.resample"); UpgradeOp renameOp2 = new RenameNodeOp("resample_by_length", "resample"); return transformXml(inputXml, "9", addInputOp1, changePrototypeOp1, renameOp1, 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , nodePrototype ) ) { Element port = new Element ( " port " ) ; 
public void testUpgrade8to9 ( ) { File version8File = new File ( " src/test/files/upgrade-v8.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version8File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version8File , NodeRepository . of ( corevectorLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertTrue ( root . hasChild ( " resample2 " ) ) ; assertTrue ( root . hasChild ( " resample3 " ) ) ; assertEquals ( " resample " , root . getChild ( " resample2 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( " amount " , root . getChild ( " resample2 " ) . getInput ( " method " ) . getValue ( ) ) ; assertEquals ( " resample " , root . getChild ( " resample3 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( " length " , root . getChild ( " resample3 " ) . getInput ( " method " ) . getValue ( ) ) ; assertEquals ( " rect1 " , root . getConnection ( " resample2 " , " shape " ) . getOutputNode ( ) ) ; assertEquals ( " rect1 " , root . getConnection ( " resample3 " , " shape " ) . getOutputNode ( ) ) ; assertTrue ( root . hasChild ( " subnet1 " ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertEquals ( " resample1 " , subnet1 . getRenderedChildName ( ) ) ; assertEquals ( " resample " , subnet1 . getChild ( " resample1 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( " amount " , subnet1 . getChild ( " resample1 " ) . getInput ( " method " ) . getValue ( ) ) ; assertEquals ( " resample1.shape " , subnet1 . getInput ( " shape " ) . getChildReference ( ) ) ; Node subnet2 = root . getChild ( " subnet2 " ) ; assertEquals ( " resample1 " , subnet2 . getRenderedChildName ( ) ) ; assertEquals ( " resample " , subnet2 . getChild ( " resample1 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( " length " , subnet2 . getChild ( " resample1 " ) . getInput ( " method " ) . getValue ( ) ) ; assertEquals ( " resample1.shape " , subnet2 . getInput ( " shape " ) . getChildReference ( ) ) ; } 
public static UpgradeStringResult upgrade9to10 ( String inputXml ) throws LoadException { Version 10: corevector's wiggle_contours, wiggle_paths and wiggle_points nodes are replaced by the more generic wiggle node. UpgradeOp addInputOp1 = new AddInputOp("corevector.wiggle_contours", "scope", "string", "contours"); UpgradeOp changePrototypeOp1 = new ChangePrototypeOp("corevector.wiggle_contours", "corevector.wiggle"); UpgradeOp renameOp1 = new RenameNodeOp("wiggle_contours", "wiggle"); UpgradeOp addInputOp2 = new AddInputOp("corevector.wiggle_paths", "scope", "string", "paths"); UpgradeOp changePrototypeOp2 = new ChangePrototypeOp("corevector.wiggle_paths", "corevector.wiggle"); UpgradeOp renameOp2 = new RenameNodeOp("wiggle_paths", "wiggle"); UpgradeOp addInputOp3 = new AddInputOp("corevector.wiggle_points", "scope", "string", "points"); UpgradeOp changePrototypeOp3 = new ChangePrototypeOp("corevector.wiggle_points", "corevector.wiggle"); UpgradeOp renameOp3 = new RenameNodeOp("wiggle_points", "wiggle"); return transformXml(inputXml, "10", addInputOp1, changePrototypeOp1, renameOp1, 
public void testUpgrade9to10 ( ) { File version9File = new File ( " src/test/files/upgrade-v9.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version9File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version9File , NodeRepository . of ( corevectorLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertTrue ( root . hasChild ( " wiggle2 " ) ) ; assertTrue ( root . hasChild ( " wiggle3 " ) ) ; assertTrue ( root . hasChild ( " wiggle4 " ) ) ; assertEquals ( " wiggle " , root . getChild ( " wiggle2 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( " contours " , root . getChild ( " wiggle2 " ) . getInput ( " scope " ) . getValue ( ) ) ; assertEquals ( " paths " , root . getChild ( " wiggle3 " ) . getInput ( " scope " ) . getValue ( ) ) ; assertEquals ( " points " , root . getChild ( " wiggle4 " ) . getInput ( " scope " ) . getValue ( ) ) ; assertEquals ( 7 , root . getConnections ( ) . size ( ) ) ; assertEquals ( " textpath1 " , root . getConnection ( " wiggle2 " , " shape " ) . getOutputNode ( ) ) ; assertTrue ( root . hasChild ( " subnet1 " ) ) ; assertEquals ( " wiggle1 " , root . getChild ( " subnet1 " ) . getRenderedChildName ( ) ) ; assertEquals ( " wiggle " , root . getChild ( " subnet2 " ) . getChild ( " wiggle1 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( " contours " , root . getChild ( " subnet1 " ) . getChild ( " wiggle1 " ) . getInput ( " scope " ) . getValue ( ) ) ; assertEquals ( " paths " , root . getChild ( " subnet2 " ) . getChild ( " wiggle1 " ) . getInput ( " scope " ) . getValue ( ) ) ; assertEquals ( " points " , root . getChild ( " subnet3 " ) . getChild ( " wiggle1 " ) . getInput ( " scope " ) . getValue ( ) ) ; assertEquals ( " wiggle1.shape " , root . getChild ( " subnet3 " ) . getInput ( " shape " ) . getChildReference ( ) ) ; } 
public static List < Point > grid ( long columns , long rows , double width , double height , Point position ) { double columnSize , left , rowSize , top ; if ( columns > 1 ) { columnSize = width / ( columns - 1 ) ; left = position . x - width / 2 ; } else { columnSize = left = position . x ; } if ( rows > 1 ) { rowSize = height / ( rows - 1 ) ; top = position . y - height / 2 ; } else { rowSize = top = position . y ; } ImmutableList . Builder < Point > builder = new ImmutableList . Builder < Point > ( ) ; for ( long rowIndex = 0 ; rowIndex < rows ; rowIndex + + ) { for ( long colIndex = 0 ; colIndex < columns ; colIndex + + ) { double x = left + colIndex * columnSize ; double y = top + rowIndex * rowSize ; builder . add ( new Point ( x , y ) ) ; } } return builder . build ( ) ; } 
private List < ? > convertResultsForPort ( Port port , List < ? > values ) { Class outputType = ListUtils . listClass ( values ) ; This is a special case: when working with geometry nodes, we may want to work with either single IGeometry objects or a list of Point's. In the latter case, we have to wrap these values in a list. if (outputType.equals(Point.class) && port.getType().equals("geometry") && port.hasValueRange()) return ImmutableList.of(values); return TypeConversions.convert(outputType, port.getType(), values); } 
protected void paintComponent ( Graphics g ) { Rectangle r = g . getClipBounds ( ) ; if ( ColorControl . this . isEnabled ( ) ) { g . setColor ( Color . darkGray ) ; } else { g . setColor ( Theme . PORT_LABEL_BACKGROUND ) ; } g . fillRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; if ( ColorControl . this . isEnabled ( ) ) { r . grow ( 1 , 1 ) ; } else { r . grow ( - 5 , - 5 ) ; } g . setColor ( color ) ; g . fillRect ( r . x , r . y , r . width - 1 , r . height - 1 ) ; } 
public static UpgradeStringResult upgrade10to11 ( String inputXml ) throws LoadException { UpgradeOp removeNodeOp = new RemoveNodeOp ( " corevector.draw_path " ) ; return transformXml ( inputXml , " 11 " , removeNodeOp ) ; } 
private static void renameRenderedChildReference ( Element element , String oldNodeName , String newNodeName ) { Attribute renderedChildReference = element . getAttribute ( " renderedChild " ) ; if ( renderedChildReference = = null ) return ; String oldRenderedChild = renderedChildReference . getValue ( ) ; if ( oldRenderedChild . equals ( oldNodeName ) ) { if ( newNodeName = = null | | newNodeName . length ( ) = = 0 ) 
private static void removeConnections ( Element parent , String child ) { Elements connections = parent . getChildElements ( " conn " ) ; for ( int i = 0 ; i < connections . size ( ) ; i + + ) { Element conn = connections . get ( i ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , nodePrototype ) ) { Element parent = ( Element ) e . getParent ( ) ; 
public void end ( Element root ) { if ( removedNodes . size ( ) > 0 ) addWarning ( String . format ( " The '%s' node became obsolete, the following nodes in your network got removed: %s " , nodePrototype , removedNodes ) ) ; 
public void testUpgrade10to11 ( ) { File version10File = new File ( " src/test/files/upgrade-v10.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version10File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version10File , NodeRepository . of ( corevectorLibrary , stringLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertFalse ( root . hasChild ( " draw_path1 " ) ) ; assertFalse ( root . hasChild ( " draw_path2 " ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertFalse ( subnet1 . hasRenderedChild ( ) ) ; assertFalse ( subnet1 . hasInput ( " path " ) ) ; assertEquals ( 1 , subnet1 . getChildren ( ) . size ( ) ) ; assertEquals ( 0 , root . getConnections ( ) . size ( ) ) ; } 
public void testGroupIntoNetwork ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 15 ) ) ; controller . addNode ( " / " , numberNode ) ; Node invertNode = Node . ROOT . withName ( " negate " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , invertNode ) ; controller . setRenderedChild ( " / " , " negate " ) ; controller . connect ( " / " , controller . getNode ( " /number " ) , invertNode , invertNode . getInput ( " value " ) ) ; Node subnet = controller . groupIntoNetwork ( " / " , ImmutableList . of ( numberNode , invertNode ) ) ; assertTrue ( subnet . hasChild ( " number " ) ) ; assertTrue ( subnet . hasChild ( " negate " ) ) ; assertEquals ( 1 , subnet . getConnections ( ) . size ( ) ) ; assertEquals ( 1 , controller . getRootNode ( ) . getChildren ( ) . size ( ) ) ; assertSame ( subnet , controller . getRootNode ( ) . getChild ( " network1 " ) ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /network1 " ) , - 15.0 ) ; } 
public void testGroupAndPublish ( ) { Node piNode = Node . ROOT . withName ( " pi " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 3.1415 ) ) ; controller . addNode ( " / " , piNode ) ; Node multiply1Node = Node . ROOT . withName ( " multiply1 " ) . withFunction ( " math/multiply " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 2 ) ) ; controller . addNode ( " / " , multiply1Node ) ; Node multiply2Node = Node . ROOT . withName ( " multiply2 " ) . withFunction ( " math/multiply " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 0 ) ) ; controller . addNode ( " / " , multiply2Node ) ; Node radiusNode = Node . ROOT . withName ( " radius " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 2 ) ) ; controller . addNode ( " / " , radiusNode ) ; controller . connect ( " / " , " pi " , " multiply1 " , " value1 " ) ; controller . connect ( " / " , " radius " , " multiply2 " , " value1 " ) ; controller . connect ( " / " , " multiply1 " , " multiply2 " , " value2 " ) ; controller . setRenderedChild ( " / " , " multiply2 " ) ; Node subnet1 = controller . groupIntoNetwork ( " / " , ImmutableList . of ( piNode , multiply1Node , multiply2Node ) ) ; Node root = controller . getRootNode ( ) ; assertEquals ( 2 , root . getChildren ( ) . size ( ) ) ; assertTrue ( root . hasChild ( radiusNode ) ) ; assertTrue ( root . hasChild ( subnet1 ) ) ; assertEquals ( 1 , subnet1 . getInputs ( ) . size ( ) ) ; assertEquals ( " value1 " , subnet1 . getInputs ( ) . get ( 0 ) . getName ( ) ) ; assertEquals ( 1 , root . getConnections ( ) . size ( ) ) ; assertEquals ( " radius " , root . getConnection ( " network1 " , " value1 " ) . getOutputNode ( ) ) ; } 
public void testGroupingAndPortNaming ( ) { Node number1Node = Node . ROOT . withName ( " number1 " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 2 ) ) ; controller . addNode ( " / " , number1Node ) ; Node multiply1Node = Node . ROOT . withName ( " multiply1 " ) . withFunction ( " math/multiply " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 3 ) ) ; controller . addNode ( " / " , multiply1Node ) ; Node add1Node = Node . ROOT . withName ( " add1 " ) . withFunction ( " math/add " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 3 ) ) ; controller . addNode ( " / " , add1Node ) ; Node divide1Node = Node . ROOT . withName ( " divide1 " ) . withFunction ( " math/divide " ) . withInputAdded ( Port . floatPort ( " value1 " , 0 ) ) . withInputAdded ( Port . floatPort ( " value2 " , 1 ) ) ; controller . addNode ( " / " , divide1Node ) ; controller . connect ( " / " , " number1 " , " multiply1 " , " value1 " ) ; controller . connect ( " / " , " number1 " , " add1 " , " value1 " ) ; controller . connect ( " / " , " multiply1 " , " divide1 " , " value1 " ) ; controller . connect ( " / " , " add1 " , " divide1 " , " value2 " ) ; controller . setRenderedChild ( " / " , " divide1 " ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /divide1 " ) , 1.2 ) ; Node subnet1 = controller . groupIntoNetwork ( " / " , ImmutableList . of ( multiply1Node , add1Node , divide1Node ) ) ; Node root = controller . getRootNode ( ) ; assertEquals ( 2 , root . getChildren ( ) . size ( ) ) ; assertTrue ( root . hasChild ( number1Node ) ) ; assertTrue ( root . hasChild ( subnet1 ) ) ; assertEquals ( 2 , subnet1 . getInputs ( ) . size ( ) ) ; List < Port > inputs = subnet1 . getInputs ( ) ; assertEquals ( " value1_1 " , inputs . get ( 0 ) . getName ( ) ) ; assertEquals ( " value1_2 " , inputs . get ( 1 ) . getName ( ) ) ; assertEquals ( 2 , root . getConnections ( ) . size ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " network1 " , " value1_1 " ) . getOutputNode ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " network1 " , " value1_2 " ) . getOutputNode ( ) ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /network1 " ) , 1.2 ) ; } 
public void testGroupingRenderedBeforeEnd ( ) { Node numberNode = Node . ROOT . withName ( " number " ) . withFunction ( " math/number " ) . withInputAdded ( Port . floatPort ( " value " , 20 ) ) ; Node invert1Node = Node . ROOT . withName ( " negate1 " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; Node invert2Node = Node . ROOT . withName ( " negate2 " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , numberNode ) ; controller . addNode ( " / " , invert1Node ) ; controller . addNode ( " / " , invert2Node ) ; controller . connect ( " / " , numberNode , invert1Node , invert1Node . getInput ( " value " ) ) ; controller . connect ( " / " , numberNode , invert2Node , invert2Node . getInput ( " value " ) ) ; controller . setRenderedChild ( " / " , " number " ) ; controller . groupIntoNetwork ( " / " , ImmutableList . of ( numberNode , invert1Node , invert2Node ) ) ; assertResultsEqual ( controller . getRootNode ( ) , controller . getNode ( " /network1 " ) , 20.0 ) ; } 
public static List < ? > slice ( Iterable < ? > iterable , long startIndex , long size , boolean invert ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( ! invert ) { Iterable < ? > skipped = Iterables . skip ( iterable , ( int ) startIndex ) ; 
public void testSubList ( ) { assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 0 , 100 , false ) , 1 , 2 , 3 , 4 ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( ) , 100 , 100 , false ) ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 1 , 2 , false ) , 2 , 3 ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 100 , 2 , false ) ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 0 , 100 , true ) ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( ) , 100 , 100 , true ) ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 1 , 2 , true ) , 1 , 4 ) ; assertElements ( ListFunctions . slice ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , 100 , 2 , true ) , 1 , 2 , 3 , 4 ) ; } 
public void testListOutputRange ( ) { Node slice = Node . ROOT . withName ( " slice " ) . withFunction ( " list/slice " ) . withInputAdded ( Port . stringPort ( " list " , " " ) . withRange ( Port . Range . LIST ) ) . withInputAdded ( Port . intPort ( " start " , 0 ) ) . withInputAdded ( Port . intPort ( " size " , 1000 ) ) . withInputAdded ( Port . booleanPort ( " invert " , false ) ) . withOutputRange ( Port . Range . LIST ) ; Node makeStrings = Node . ROOT . withName ( " makeStrings " ) . withFunction ( " string/makeStrings " ) . withInputAdded ( Port . stringPort ( " text " , " A;B;C " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node makeNumbers = Node . ROOT . withName ( " makeNumbers " ) . withFunction ( " math/makeNumbers " ) . withInputAdded ( Port . stringPort ( " text " , " 0;1;2 " ) ) . withInputAdded ( Port . stringPort ( " separator " , " ; " ) ) . withOutputRange ( Port . Range . LIST ) ; Node net = Node . NETWORK . withChildAdded ( makeStrings ) . withChildAdded ( makeNumbers ) . withChildAdded ( slice ) . connect ( " makeStrings " , " slice " , " list " ) . connect ( " makeNumbers " , " slice " , " start " ) ; assertResultsEqual ( net , slice , " A " , " B " , " C " , " B " , " C " , " C " ) ; } 
public Contour resampleByAmount ( int amount ) { Contour c = new Contour ( ) ; c . extend ( makePoints ( amount ) ) ; c . setClosed ( closed ) ; return c ; } 
public static BufferedImage readNodeImage ( File nodeImageFile ) { String imagePath = nodeImageFile . getAbsolutePath ( ) ; if ( fileImageCache . containsKey ( imagePath ) ) { return fileImageCache . get ( imagePath ) ; 
public int hashCode ( ) { if ( hashCode = = 0 ) { hashCode = Objects . hashCode ( x , y , type ) ; } return hashCode ; } 
public static UpgradeStringResult upgrade11to12 ( String inputXml ) throws LoadException { UpgradeOp renamePortOp1 = new RenamePortOp ( " corevector.shape_on_path " , " template " , " path " ) ; UpgradeOp renamePortOp2 = new RenamePortOp ( " corevector.shape_on_path " , " dist " , " spacing " ) ; UpgradeOp renamePortOp3 = new RenamePortOp ( " corevector.shape_on_path " , " start " , " margin " ) ; return transformXml ( inputXml , " 12 " , renamePortOp1 , renamePortOp2 , renamePortOp3 ) ; } 
public void testUpgrade11to12 ( ) { todo: implement } private void assertReadWriteEquals(NodeLibrary library, NodeRepository nodeRepository) { String xml = library.toXml(); assertEquals(library, NodeLibrary.load(library.getName(), xml, nodeRepository)); }} 
public void testUpgrade11to12 ( ) { File version11File = new File ( " src/test/files/upgrade-v11.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version11File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version11File , NodeRepository . of ( corevectorLibrary , mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; Node shapeOnPath1Node = root . getChild ( " shape_on_path1 " ) ; assertNotNull ( shapeOnPath1Node ) ; assertTrue ( shapeOnPath1Node . hasInput ( " path " ) ) ; assertEquals ( 10L , shapeOnPath1Node . getInput ( " amount " ) . getValue ( ) ) ; assertEquals ( 15.0 , shapeOnPath1Node . getInput ( " spacing " ) . getValue ( ) ) ; assertEquals ( 10.0 , shapeOnPath1Node . getInput ( " margin " ) . getValue ( ) ) ; assertEquals ( " rect1 " , root . getConnection ( " shape_on_path2 " , " path " ) . getOutputNode ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " shape_on_path2 " , " spacing " ) . getOutputNode ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " shape_on_path2 " , " margin " ) . getOutputNode ( ) ) ; Node subnet = root . getChild ( " subnet1 " ) ; assertEquals ( " shape_on_path1.path " , subnet . getInput ( " template " ) . getChildReference ( ) ) ; assertEquals ( " shape_on_path1.spacing " , subnet . getInput ( " dist " ) . getChildReference ( ) ) ; assertEquals ( " shape_on_path1.margin " , subnet . getInput ( " start " ) . getChildReference ( ) ) ; assertEquals ( " rect1 " , root . getConnection ( " subnet1 " , " template " ) . getOutputNode ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " subnet1 " , " dist " ) . getOutputNode ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " subnet1 " , " start " ) . getOutputNode ( ) ) ; } 
public void actionPerformed ( ActionEvent e ) { String s = hexField . getText ( ) . toLowerCase ( ) ; if ( ! s . startsWith ( " # " ) ) s = " # " + s ; if ( s . length ( ) = = 7 ) s = s + " ff " ; try { nodebox . graphics . Color c = new nodebox . graphics . Color ( s ) ; red = ( float ) c . getRed ( ) ; green = ( float ) c . getGreen ( ) ; blue = ( float ) c . getBlue ( ) ; alpha = ( float ) c . getAlpha ( ) ; } catch ( IllegalArgumentException ex ) { JOptionPane . showMessageDialog ( ColorDialog . this , ex . getMessage ( ) ) ; } updateColor ( ) ; } 
private void updatePanels ( ) { colorField . repaint ( ) ; for ( ColorPanel panel : panels ) { panel . updateDraggableNumber ( ) ; panel . repaint ( ) ; } hexField . setText ( new nodebox . graphics . Color ( newColor ) . toString ( ) ) ; } 
public void resetViewTransform ( ) { setViewTransform ( 0 , 0 , 1 ) ; repaint ( ) ; } 
public static NodeBoxDocument load ( File file ) { NodeLibrary library ; NodeBoxDocument document ; try { library = NodeLibrary . load ( file , Application . getInstance ( ) . getSystemRepository ( ) ) ; document = new NodeBoxDocument ( library ) ; document . setDocumentFile ( file ) ; } catch ( OutdatedLibraryException e ) { UpgradeResult result = NodeLibraryUpgrades . upgrade ( file ) ; The file is used here as the base name for finding relative libraries. library = result.getLibrary(file, Application.getInstance().getSystemRepository()); document = new NodeBoxDocument(library); document.setDocumentFile(file); document.showUpgradeResult(result); } catch (LoadException e) { throw new RuntimeException("Could not load " + file, e); } lastFilePath = file.getParentFile().getAbsolutePath(); return document; } 
public static < K , V > Map < K , V > zipMap ( Iterable < K > keys , Iterable < V > values ) { if ( keys = = null | | values = = null ) return ImmutableMap . of ( ) ; ImmutableMap . Builder < K , V > b = ImmutableMap . builder ( ) ; Iterator < K > keyIterator = keys . iterator ( ) ; Iterator < V > valueIterator = values . iterator ( ) ; while ( keyIterator . hasNext ( ) & & valueIterator . hasNext ( ) ) { K key = keyIterator . next ( ) ; V value = valueIterator . next ( ) ; b . put ( key , value ) ; } return b . build ( ) ; } 
public void testZipMap ( ) { assertEquals ( ImmutableMap . of ( ) , ListFunctions . zipMap ( null , null ) ) ; assertEquals ( ImmutableMap . of ( ) , ListFunctions . zipMap ( ImmutableList . of ( " a " ) , null ) ) ; assertEquals ( ImmutableMap . of ( ) , ListFunctions . zipMap ( null , ImmutableList . of ( 1 ) ) ) ; assertEquals ( ImmutableMap . of ( " a " , 1 ) , ListFunctions . zipMap ( ImmutableList . of ( " a " ) , ImmutableList . of ( 1 ) ) ) ; assertEquals ( ImmutableMap . of ( " a " , 1 ) , ListFunctions . zipMap ( ImmutableList . of ( " a " ) , ImmutableList . of ( 1 , 2 ) ) ) ; assertEquals ( ImmutableMap . of ( " a " , 1 ) , ListFunctions . zipMap ( ImmutableList . of ( " a " , " b " ) , ImmutableList . of ( 1 ) ) ) ; assertEquals ( ImmutableMap . of ( " a " , 1 , " b " , 2 ) , ListFunctions . zipMap ( ImmutableList . of ( " a " , " b " ) , ImmutableList . of ( 1 , 2 ) ) ) ; } 
private List < ? > clampResultsForPort ( Port port , List < ? > values ) { if ( port . getMinimumValue ( ) = = null & & port . getMaximumValue ( ) = = null ) return values ; ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; for ( Object v : values ) { b . add ( port . clampValue ( v ) ) ; } return b . build ( ) ; } 
public void testClamping ( ) { Port value = invertNode . getInput ( " value " ) ; value = value . withMaximumValue ( 10.0 ) ; Node clampedInvertNode = invertNode . withInputChanged ( " value " , value ) ; clampedInvertNode = clampedInvertNode . withInputValue ( " value " , 25.0 ) ; assertResultsEqual ( clampedInvertNode , - 10.0 ) ; Node number1 = numberNode . withInputValue ( " number " , 25.0 ) ; Node net = Node . NETWORK . withChildAdded ( clampedInvertNode ) . withChildAdded ( number1 ) . connect ( " number " , " negate " , " value " ) ; assertResultsEqual ( net , clampedInvertNode , - 10.0 ) ; } 
public void actionPerformed ( ActionEvent e ) { String s = hexField . getText ( ) . toLowerCase ( ) ; if ( ! s . startsWith ( " # " ) ) s = " # " + s ; if ( s . length ( ) = = 7 ) s = s + " ff " ; try { nodebox . graphics . Color c = new nodebox . graphics . Color ( s ) ; red = ( float ) c . getRed ( ) ; green = ( float ) c . getGreen ( ) ; blue = ( float ) c . getBlue ( ) ; alpha = ( float ) c . getAlpha ( ) ; } catch ( IllegalArgumentException ex ) { JOptionPane . showMessageDialog ( ColorDialog . this , ex . getMessage ( ) ) ; } updateHSB ( ) ; updateColor ( ) ; } 
public NodeLibrary withFile ( File newFile ) { return new NodeLibrary ( this . name , newFile , this . root , this . nodeRepository , this . functionRepository , this . properties , this . uuid ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " http:nodebox.net/ " ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " http:nodebox.net/node/documentation/tutorial/getting-started.html " ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " http:nodebox.net/node/documentation/ " ) ; } 
public static List < IGeometry > copy ( IGeometry shape , long copies , String order , Point translate , double rotate , Point scale ) { ImmutableList . Builder < IGeometry > builder = ImmutableList . builder ( ) ; Geometry geo = new Geometry ( ) ; double tx = 0 ; double ty = 0 ; double r = 0 ; double sx = 1.0 ; double sy = 1.0 ; char [ ] cOrder = order . toCharArray ( ) ; for ( long i = 0 ; i < copies ; i + + ) { Transform = new Transform ( ) ; Each letter of the order describes an operation. for (char op : cOrder) { if (op == 't') { t.translate(tx, ty); } else if (op == 'r') { t.rotate(r); } else if (op == 's') { t.scale(sx, sy); } } builder.add(t.map(shape)); tx += translate.x; ty += translate.y; r += rotate; sx += scale.x; sy += scale.y; } return builder.build(); } 
public static UpgradeStringResult upgrade3to4 ( String inputXml ) throws LoadException { Version 4: Convert corevector.to_points nodes to corevector.point nodes. UpgradeOp changePrototypeOp = new ChangePrototypeOp("corevector.to_points", "corevector.point"); UpgradeOp renameOp = new RenameNodeOp("to_points", "point"); todo: write test code for renamePortOp addition. UpgradeOp renamePortOp = new RenamePortOp("corevector.to_points", "shape", "value"); return transformXml(inputXml, "4", renamePortOp, changePrototypeOp, renameOp); } 
private static void writePort ( Document doc , Element parent , Node node , Port port , Port . Direction direction ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = node.getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getInput(port.getName()); If the port and its prototype are equal, don't write anything. if (port.equals(protoPort)) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); el.setAttribute("type", port.getType()); if (shouldWriteAttribute(node, port, Port.Attribute.CHILD_REFERENCE) && port.getChildReference() != null) el.setAttribute("childReference", port.getChildReference()); if (shouldWriteAttribute(node, port, Port.Attribute.WIDGET)) el.setAttribute("widget", port.getWidget().toString().toLowerCase()); if (shouldWriteAttribute(node, port, Port.Attribute.RANGE)) el.setAttribute("range", port.getRange().toString().toLowerCase()); if (port.isStandardType()) el.setAttribute("value", port.stringValue()); if (shouldWriteAttribute(node, port, Port.Attribute.MINIMUM_VALUE)) if (port.getMinimumValue() != null) el.setAttribute("min", String.format(Locale.US, "%s", port.getMinimumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MAXIMUM_VALUE)) if (port.getMaximumValue() != null) el.setAttribute("max", String.format(Locale.US, "%s", port.getMaximumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MENU_ITEMS)) writeMenuItems(doc, el, port.getMenuItems()); parent.appendChild(el); } 
public void testUpgrade3to4 ( ) { File version3File = new File ( " src/test/files/upgrade-v3.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version3File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version3File , NodeRepository . of ( corevectorLibrary , listLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertEquals ( " make_point " , root . getChild ( " point1 " ) . getPrototype ( ) . getName ( ) ) ; assertTrue ( root . hasChild ( " point2 " ) ) ; assertEquals ( " point " , root . getChild ( " point2 " ) . getPrototype ( ) . getName ( ) ) ; assertTrue ( root . getConnections ( ) . contains ( new Connection ( " point2 " , " count1 " , " list " ) ) ) ; Node subnet1 = root . getChild ( " subnet1 " ) ; assertTrue ( subnet1 . hasChild ( " point1 " ) ) ; assertEquals ( " point1 " , subnet1 . getRenderedChildName ( ) ) ; Port value = subnet1 . getInput ( " shape " ) ; assertEquals ( " point1.value " , value . getChildReference ( ) ) ; } 
public void frameDone ( double frame , Iterable < ? > results ) { movie . addFrame ( ObjectsRenderer . createMovieImage ( results , movieWidth , movieHeight ) ) ; } 
public static BufferedImage createMovieImage ( Iterable < ? > objects , int width , int height ) { Visualizer v = Viewer . getVisualizer ( objects , ListUtils . listClass ( objects ) ) ; BufferedImage tempImage = createImage ( v , objects ) ; BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = img . createGraphics ( ) ; g . setColor ( Color . WHITE ) ; g . fillRect ( 0 , 0 , width , height ) ; g . translate ( - ( tempImage . getWidth ( ) - width ) / 2 , - ( tempImage . getHeight ( ) - height ) / 2 ) ; Composite composite = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER ) ; g . setComposite ( composite ) ; g . drawRenderedImage ( tempImage , null ) ; img . flush ( ) ; return img ; } 
public void reload ( ) { controller . reloadFunctionRepository ( ) ; functionRepository . invalidateFunctionCache ( ) ; requestRender ( ) ; } 
public void invalidateFunctionCache ( ) { functionCache . clear ( ) ; } 
public void reload ( ) { this . functionMap = loadScript ( this . file ) ; Because we don't want this to happen asynchronously, get the results of the functionMap immediately. try { this.functionMap.get(); 
public void reloadFunctionRepository ( ) { nodeLibrary . getFunctionRepository ( ) . reload ( ) ; } 
private void initEventHandlers ( ) { setFocusable ( true ) ; This is disabled so we can detect the tab key. setFocusTraversalKeysEnabled(false); addKeyListener(this); addMouseListener(this); addMouseMotionListener(this); addMouseWheelListener(this); addFocusListener(this); } 
public void focusLost ( FocusEvent focusEvent ) { isSpacePressed = false ; isShiftPressed = false ; setCursor ( defaultCursor ) ; } 
public static BufferedImage createMovieImage ( Iterable < ? > objects , int width , int height ) { Visualizer v = Viewer . getVisualizer ( objects , ListUtils . listClass ( objects ) ) ; BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = img . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( Color . WHITE ) ; g . fillRect ( 0 , 0 , width , height ) ; g . translate ( width / 2 , height / 2 ) ; v . draw ( g , objects ) ; img . flush ( ) ; return img ; } 
public static String baseReverse ( String s ) { return new StringBuffer ( s ) . reverse ( ) . toString ( ) ; } 
public void testInheritedMethods ( ) { Method m = Functions . findMethod ( TestFunctions . class , " baseReverse " ) ; assertEquals ( " baseReverse " , m . getName ( ) ) ; assertEquals ( AbstractTestFunctions . class , m . getDeclaringClass ( ) ) ; } 
public void mouseReleased ( MouseEvent e ) { isDraggingNodes = false ; isDragSelecting = false ; if ( isAltPressed ) getDocument ( ) . stopEditing ( ) ; if ( connectionOutput ! = null & & connectionInput ! = null ) { getDocument ( ) . connect ( connectionOutput . getName ( ) , connectionInput . node , connectionInput . port ) ; } connectionOutput = null ; if ( e . isPopupTrigger ( ) ) { showPopup ( e ) ; } repaint ( ) ; } 
public void focusLost ( FocusEvent focusEvent ) { isSpacePressed = false ; isShiftPressed = false ; isAltPressed = false ; setCursor ( defaultCursor ) ; } 
public void dragCopy ( ) { List < Node > newNodes = controller . pasteNodes ( activeNetworkPath , getActiveNetwork ( ) , networkView . getSelectedNodes ( ) , 0 , 0 ) ; networkView . updateAll ( ) ; networkView . select ( newNodes ) ; } 
public Node withChildPositionChanged ( String childName , double xOffset , double yOffset ) { checkArgument ( hasChild ( childName ) , " Node %s does not have a child named %s. " , this , childName ) ; Node child = getChild ( childName ) ; return withChildReplaced ( childName , child . withPosition ( child . getPosition ( ) . moved ( xOffset , yOffset ) ) ) ; } 
public List < Node > pasteNodes ( String parentPath , Node nodesParent , Iterable < Node > nodes ) { return pasteNodes ( parentPath , nodesParent , nodes , 4 , 2 ) ; } 
public List < Node > pasteNodes ( String parentPath , Node nodesParent , Iterable < Node > nodes , double xOffset , double yOffset ) { Node parent = getNode ( parentPath ) ; Node newParent = parent . withChildrenAdded ( nodesParent , nodes ) ; for ( Node node : Iterables . skip ( newParent . getChildren ( ) , parent . getChildren ( ) . size ( ) ) ) newParent = newParent . withChildPositionChanged ( node . getName ( ) , xOffset , yOffset ) ; replaceNodeInPath ( parentPath , newParent ) ; return ImmutableList . copyOf ( Iterables . skip ( newParent . getChildren ( ) , parent . getChildren ( ) . size ( ) ) ) ; } 
public void toggleAnimation ( ) { if ( playButton . isChecked ( ) ) stopAnimation ( ) ; 
public void toggleAnimation ( ) { animationBar . toggleAnimation ( ) ; } 
public void doRewind ( ) { animationBar . rewindAnimation ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { getDocument ( ) . toggleAnimation ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { getDocument ( ) . doRewind ( ) ; } 
public boolean containsPoint ( Point point ) { if ( ! isVisible ( ) ) return false ; return getBounds ( ) . contains ( point ) ; } 
public void zoomView ( double scaleDelta ) { PointerInfo a = MouseInfo . getPointerInfo ( ) ; Point point = new Point ( a . getLocation ( ) ) ; for ( Zoom zoomListener : zoomListeners ) { if ( zoomListener . containsPoint ( point ) ) 
public void addZoomListener ( Zoom listener ) { zoomListeners . add ( listener ) ; } 
public void removeZoomListener ( Zoom listener ) { zoomListeners . remove ( listener ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . zoomView ( 1.05 ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . zoomView ( 0.95 ) ; } 
public void zoom ( double scaleDelta ) { if ( ! isVisible ( ) ) return ; double currentScale = getCamera ( ) . getViewScale ( ) ; double newScale = currentScale * scaleDelta ; if ( newScale < MIN_ZOOM ) { scaleDelta = MIN_ZOOM / currentScale ; } else if ( newScale > MAX_ZOOM ) { scaleDelta = MAX_ZOOM / currentScale ; } getCamera ( ) . scaleViewAboutPoint ( scaleDelta , getCamera ( ) . getWidth ( ) / 2 , getCamera ( ) . getHeight ( ) / 2 ) ; } 
public void zoom ( double scaleDelta ) ; public boolean containsPoint ( Point point ) ; } 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowDeactivated ( WindowEvent e ) { } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { doNext ( ) ; } 
private void doNext ( ) { dialogSuccessful = true ; setVisible ( false ) ; } 
public static void main ( String [ ] args ) { ExportDialog d = new ExportDialog ( null ) ; d . setVisible ( true ) ; } 
public void doExport ( ) { ExportDialog d = new ExportDialog ( this ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return ; nodebox . ui . ImageFormat chosenFormat = d . getFormat ( ) ; File chosenFile = FileUtils . showSaveDialog ( this , lastExportPath , " png,pdf " , " Image file " ) ; if ( chosenFile = = null ) return ; lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; exportToFile ( chosenFile , chosenFormat ) ; } 
private List < ? > postProcessResult ( Node node , Object result ) { if ( node . hasListOutputRange ( ) ) { TODO This is a temporary fix for networks that have no rendered nodes. They execute the "core/zero" function which returns a single value, not a list. if (result instanceof List<?>) { return (List<?>) result; } else { return ImmutableList.of(result); } } else if (result instanceof List) { List<?> results = (List<?>) result; if (results.isEmpty()) return results; Class outputType = ListUtils.listClass(results); if (outputType.equals(Point.class) && node.getOutputType().equals("geometry")) return results; } return result == null ? ImmutableList.of() : ImmutableList.of(result); } 
private void initInterface ( ) { setLayout ( new BorderLayout ( ) ) ; JPanel contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new GridLayout ( 3 , 1 , 10 , 0 ) ) ; contentPanel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 ) ) ; JLabel infoLabel = new JLabel ( ) ; infoLabel . setText ( " <html>There is already a file named " + file . getName ( ) + " in the chosen folder.<br>Do you want to replace it?</html> " ) ; infoLabel . setFont ( Theme . MESSAGE_FONT ) ; contentPanel . add ( infoLabel ) ; JPanel buttonPanel = new JPanel ( ) ; buttonPanel . setLayout ( new FlowLayout ( FlowLayout . RIGHT ) ) ; cancelButton = new JButton ( cancelAction ) ; saveButton = new JButton ( saveAction ) ; buttonPanel . add ( cancelButton ) ; buttonPanel . add ( saveButton ) ; contentPanel . add ( buttonPanel ) ; add ( contentPanel , BorderLayout . CENTER ) ; Dimension d = new Dimension ( 450 , 110 ) ; setPreferredSize ( d ) ; setMinimumSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; 
public void actionPerformed ( ActionEvent e ) { dialog . setVisible ( false ) ; } 
public void windowClosing ( WindowEvent we ) { dialog . setVisible ( false ) ; } 
public Point centerGridPoint ( ) { Point pt = pointToGridPoint ( new Point ( ( int ) ( getBounds ( ) . getWidth ( ) / 2 ) , ( int ) ( getBounds ( ) . getHeight ( ) / 2 ) ) ) ; return new Point ( ( int ) pt . getX ( ) - 1 , ( int ) pt . getY ( ) ) ; } 
public void showNodeSelectionDialog ( ) { showNodeSelectionDialog ( networkView . centerGridPoint ( ) ) ; } 
public static List < Double > runningTotal ( Iterable < Double > numbers ) { if ( noValues ( numbers ) ) return ImmutableList . of ( 0.0 ) ; double currentTotal = 0 ; ImmutableList . Builder < Double > b = ImmutableList . builder ( ) ; for ( Double d : numbers ) { b . add ( currentTotal ) ; currentTotal + = d ; } return b . build ( ) ; } 
public void frameDone ( double frame , Iterable < ? > results ) { movie . addFrame ( ObjectsRenderer . createMovieImage ( results , width , height ) ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . translate ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; for ( Object outputValue : outputValues ) { if ( outputValue instanceof Grob ) { 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final ExportViewer viewer = new ExportViewer ( ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame ) ; List < ? > results = context . renderNode ( exportNetwork ) ; Node renderedChild = exportNetwork . getRenderedChild ( ) ; viewer . setOutputValues ( ( List < Object > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; viewer . setVisible ( true ) ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . translate ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; Visualizer v = nodebox . client . Viewer . getVisualizer ( outputValues , ListUtils . listClass ( outputValues ) ) ; todo: handle canvas clipping v.draw(g2, outputValues); } 
public static UpgradeStringResult upgrade12to13 ( String inputXml ) throws LoadException { UpgradeOp renamePortOp1 = new RenamePortOp ( " corevector.text_on_path " , " shape " , " path " ) ; UpgradeOp renamePortOp2 = new RenamePortOp ( " corevector.text_on_path " , " position " , " margin " ) ; UpgradeOp renamePortOp3 = new RenamePortOp ( " corevector.text_on_path " , " offset " , " baseline_offset " ) ; UpgradeOp removeInputOp = new RemoveInputOp ( " corevector.text_on_path " , " keep_geometry " ) ; return transformXml ( inputXml , " 13 " , renamePortOp1 , renamePortOp2 , renamePortOp3 , removeInputOp ) ; } 
public void testUpgrade12to13 ( ) { File version12File = new File ( " src/test/files/upgrade-v12.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version12File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version12File , NodeRepository . of ( corevectorLibrary , mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; Node textOnPath1Node = root . getChild ( " text_on_path1 " ) ; assertNotNull ( textOnPath1Node ) ; assertTrue ( textOnPath1Node . hasInput ( " path " ) ) ; assertEquals ( 10.0 , textOnPath1Node . getInput ( " margin " ) . getValue ( ) ) ; assertEquals ( 5.0 , textOnPath1Node . getInput ( " baseline_offset " ) . getValue ( ) ) ; assertFalse ( textOnPath1Node . hasInput ( " keep_geometry " ) ) ; assertEquals ( " rect1 " , root . getConnection ( " text_on_path2 " , " path " ) . getOutputNode ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " text_on_path2 " , " margin " ) . getOutputNode ( ) ) ; assertEquals ( " number2 " , root . getConnection ( " text_on_path2 " , " baseline_offset " ) . getOutputNode ( ) ) ; Node subnet = root . getChild ( " subnet1 " ) ; assertEquals ( " text_on_path1.path " , subnet . getInput ( " shape " ) . getChildReference ( ) ) ; assertEquals ( " text_on_path1.margin " , subnet . getInput ( " position " ) . getChildReference ( ) ) ; assertEquals ( " text_on_path1.baseline_offset " , subnet . getInput ( " offset " ) . getChildReference ( ) ) ; assertFalse ( subnet . hasInput ( " keep_geometry " ) ) ; assertEquals ( " rect1 " , root . getConnection ( " subnet1 " , " shape " ) . getOutputNode ( ) ) ; assertEquals ( " number1 " , root . getConnection ( " subnet1 " , " position " ) . getOutputNode ( ) ) ; assertEquals ( " number2 " , root . getConnection ( " subnet1 " , " offset " ) . getOutputNode ( ) ) ; assertNull ( root . getConnection ( " subnet1 " , " keep_geometry " ) ) ; } 
public static Point centroid ( IGeometry shape ) { if ( shape = = null ) return Point . ZERO ; List < Point > points = shape . getPoints ( ) ; if ( points . isEmpty ( ) ) return Point . ZERO ; Point firstPoint = points . get ( 0 ) ; double xs = firstPoint . x ; double ys = firstPoint . y ; for ( Point pt : Iterables . skip ( points , 1 ) ) { xs + = pt . x ; ys + = pt . y ; } return new Point ( xs / points . size ( ) , ys / points . size ( ) ) ; } 
public Point apply ( Point point ) { if ( point = = null ) return Point . ZERO ; double x = MathUtils . snap ( point . x + position . x , distance , dStrength ) - position . x ; double y = MathUtils . snap ( point . y + position . y , distance , dStrength ) - position . y ; return new Point ( x , y , point . type ) ; } 
public static Path line ( Point p1 , Point p2 , long points ) { Path p = new Path ( ) ; p . line ( p1 . x , p1 . y , p2 . x , p2 . y ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; p = p . resampleByAmount ( ( int ) points , true ) ; return p ; } 
public static Path lineAngle ( Point point , double angle , double distance , long points ) { Point p2 = coordinates ( point , angle , distance ) ; Path p = new Path ( ) ; p . line ( point . x , point . y , p2 . x , p2 . y ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; p = p . resampleByAmount ( ( int ) points , true ) ; return p ; } 
public void focusLost ( FocusEvent e ) { commitTextFieldValue ( ) ; } 
public void actionPerformed ( ActionEvent e ) { commitTextFieldValue ( ) ; } 
private void commitTextFieldValue ( ) { setPortValue ( textField . getText ( ) ) ; 
public static Contour parseContour ( String s ) { s = s . replace ( " , " , " " ) ; Contour contour = new Contour ( ) ; boolean parseX = true ; Double x = null ; String lastString = null ; for ( String pointString : CONTOUR_SPLITTER . split ( s ) ) { lastString = pointString ; Double d = Double . parseDouble ( pointString ) ; if ( parseX ) { x = d ; parseX = false ; } else { contour . addPoint ( new Point ( x , d ) ) ; parseX = true ; } } if ( ! parseX ) throw new IllegalArgumentException ( " Could not parse point " + lastString ) ; return contour ; } 
public void frameDone ( double frame , Iterable < ? > results ) { File exportFile = new File ( directory , exportPrefix + " - " + String . format ( " %05d " , count ) ) ; exportToFile ( exportFile , results , format ) ; count + = 1 ; } 
public void testGeometryToPointsConversion ( ) { Node line = Node . ROOT . withName ( " line " ) . withFunction ( " corevector/line " ) . withInputAdded ( Port . pointPort ( " point1 " , new Point ( 10 , 20 ) ) ) . withInputAdded ( Port . pointPort ( " point2 " , new Point ( 30 , 40 ) ) ) . withInputAdded ( Port . intPort ( " points " , 2 ) ) ; Node point = Node . ROOT . withName ( " point " ) . withFunction ( " corevector/point " ) . withInputAdded ( Port . pointPort ( " value " , Point . ZERO ) ) ; Node net = Node . NETWORK . withChildAdded ( line ) . withChildAdded ( point ) . withRenderedChild ( point ) . connect ( " line " , " point " , " value " ) ; assertResultsEqual ( net , new Point ( 10 , 20 ) , new Point ( 30 , 40 ) ) ; } 
public static String formatNumber ( double value , String format ) { return String . format ( Locale . US , format , value ) ; } 
public void testConcatenate ( ) { assertEquals ( " a " , StringFunctions . concatenate ( " a " , null , null , null ) ) ; assertEquals ( " ab " , StringFunctions . concatenate ( " a " , " b " , null , null ) ) ; assertEquals ( " ad " , StringFunctions . concatenate ( " a " , null , null , " d " ) ) ; assertEquals ( " cd " , StringFunctions . concatenate ( null , null , " c " , " d " ) ) ; assertEquals ( " " , StringFunctions . concatenate ( null , null , null , null ) ) ; } 
public void testFormatNumber ( ) { assertEquals ( " 16.13 " , StringFunctions . formatNumber ( 16.127 , " %.2f " ) ) ; assertEquals ( " 12 " , StringFunctions . formatNumber ( 12 , " %.0f " ) ) ; assertEquals ( " 012 " , StringFunctions . formatNumber ( 12 , " %03.0f " ) ) ; assertEquals ( " 012 " , StringFunctions . formatNumber ( 12.25 , " %03.0f " ) ) ; assertEquals ( " 012 " , StringFunctions . formatNumber ( 11.55 , " %03.0f " ) ) ; assertEquals ( " 012.00 " , StringFunctions . formatNumber ( 12.0 , " %06.2f " ) ) ; } 
public static double wave ( double min , double max , double period , double offset , String waveType ) { float fmin = ( float ) min ; float fmax = ( float ) max ; float fperiod = ( float ) period ; AbstractWave wave ; if ( waveType . equals ( WAVE_TRIANGLE ) ) wave = TriangleWave . from ( fmin , fmax , fperiod ) ; else if ( waveType . equals ( WAVE_SQUARE ) ) wave = SquareWave . from ( fmin , fmax , fperiod ) ; else if ( waveType . equals ( WAVE_SAWTOOTH ) ) wave = SawtoothWave . from ( fmin , fmax , fperiod ) ; else wave = SineWave . from ( fmin , fmax , fperiod ) ; return wave . getValueAt ( ( float ) offset ) ; } 
public static UpgradeStringResult upgrade13to14 ( String inputXml ) throws LoadException { UpgradeOp renamePortOp1 = new RenamePortOp ( " math.wave " , " speed " , " period " ) ; UpgradeOp renamePortOp2 = new RenamePortOp ( " math.wave " , " frame " , " offset " ) ; return transformXml ( inputXml , " 14 " , renamePortOp1 , renamePortOp2 ) ; } 
public void testUpgrade13to14 ( ) { File version13File = new File ( " src/test/files/upgrade-v13.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version13File ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version13File , NodeRepository . of ( mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; Node waveNode = root . getChild ( " wave1 " ) ; assertFalse ( waveNode . hasInput ( " speed " ) ) ; assertFalse ( waveNode . hasInput ( " frame " ) ) ; assertEquals ( 100.0 , waveNode . getInput ( " period " ) . getValue ( ) ) ; assertEquals ( 20.0 , waveNode . getInput ( " offset " ) . getValue ( ) ) ; } 
public static UpgradeStringResult upgrade14to15 ( String inputXml ) throws LoadException { UpgradeOp renameNodeOp = new RenameNodeOp ( " make_strings " , " split " ) ; return transformXml ( inputXml , " 15 " , renameNodeOp ) ; } 
public void testUpgrade14to15 ( ) { File version14File = new File ( " src/test/files/upgrade-v14.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version14File ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version14File , NodeRepository . of ( stringLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertTrue ( root . hasChild ( " split1 " ) ) ; assertEquals ( " split1 " , root . getConnection ( " length1 " , " string " ) . getOutputNode ( ) ) ; Node subnet = root . getChild ( " subnet1 " ) ; assertEquals ( " split1 " , subnet . getRenderedChildName ( ) ) ; assertEquals ( " split1.string " , subnet . getInput ( " string " ) . getChildReference ( ) ) ; assertEquals ( " string1 " , root . getConnection ( " subnet1 " , " string " ) . getOutputNode ( ) ) ; assertEquals ( " subnet1 " , root . getConnection ( " length2 " , " string " ) . getOutputNode ( ) ) ; } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; nodeMenu = new JPopupMenu ( ) ; nodeMenu . add ( new SetRenderedAction ( ) ) ; nodeMenu . add ( new RenameAction ( ) ) ; nodeMenu . add ( new DeleteAction ( ) ) ; nodeMenu . add ( new GroupIntoNetworkAction ( null ) ) ; nodeMenu . add ( new GoInAction ( ) ) ; nodeMenu . add ( new HelpAction ( ) ) ; } 
public void testImportCSVWithMixedInput ( ) { List < Map < String , Object > > l = importSimpleCSV ( " src/test/files/mixed-input.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , 100.0 , 0.0 , " zero " , 0.0 ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , 255.0 , 100.0 , " 0 " , 255.0 ) ; } 
public void testImportCSVWithMixedInput ( ) { List < Map < String , Object > > l = importSimpleCSV ( " src/test/files/mixed-input.csv " ) ; assertEquals ( 4 , l . size ( ) ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , 100.0 , " 0 " , " zero " , 0.0 ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , 255.0 , " 100 " , " 0 " , 255.0 ) ; assertResultsEqual ( l . get ( 2 ) . values ( ) , 0.0 , " 100 k " , " 0 " , 255.0 ) ; assertResultsEqual ( l . get ( 3 ) . values ( ) , 100.0 , " 200 " , " 255.0 " , 0.0 ) ; } 
public void testImportCSVWithDifferentFloatingPoint ( ) { List < Map < String , Object > > l = importCSV ( " src/test/files/floats.csv " , " semicolon " , " double " , " period " ) ; assertEquals ( 2 , l . size ( ) ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , 2.5 , 10.99 , " 40,000.60 " , 10000.10 , " 10.000,10 " ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , 25.0 , 1099.0 , " 40.000,60 " , 20200.20 , " 20.200,20 " ) ; l = importCSV ( " src/test/files/floats.csv " , " semicolon " , " double " , " comma " ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , 25.0 , 1099.0 , " 40,000.60 " , " 10,000.10 " , 10000.10 ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , 2.5 , 10.99 , " 40.000,60 " , " 20,200.20 " , 20200.20 ) ; } 
public Node withChildInputRemoved ( String childName , String portName ) { checkArgument ( isNetwork , " Node %s is not a network node. " , this ) ; checkArgument ( hasChild ( childName ) , " Node %s does not have a child named %s. " , this , childName ) ; Node child = getChild ( childName ) ; checkArgument ( child . hasInput ( portName ) , " Node %s does not have an input port %s. " , childName , portName ) ; if ( hasPublishedInput ( childName , portName ) ) return unpublish ( childName , portName ) . withChildInputRemoved ( childName , portName ) ; if ( isConnected ( childName , portName ) ) return disconnect ( childName , portName ) . withChildInputRemoved ( childName , portName ) ; return withChildReplaced ( childName , child . withInputRemoved ( portName ) ) ; } 
private Node withChildInputChanged ( String childName , String portName , Port newPort ) { todo: checks checkArgument(isNetwork, "Node %s is not a network node.", this); return withChildReplaced(childName, getChild(childName).withInputChanged(portName, newPort)); } 
public Node withChildPositionChanged ( String childName , double xOffset , double yOffset ) { checkArgument ( isNetwork , " Node %s is not a network node. " , this ) ; checkArgument ( hasChild ( childName ) , " Node %s does not have a child named %s. " , this , childName ) ; Node child = getChild ( childName ) ; return withChildReplaced ( childName , child . withPosition ( child . getPosition ( ) . moved ( xOffset , yOffset ) ) ) ; } 
public Node withInputValue ( String portName , Object value ) { Port p = getInput ( portName ) ; checkNotNull ( p , " Input port %s does not exist on node %s. " , portName , this ) ; p = p . withValue ( value ) ; Node = this ; if ( isNetwork & & p . isPublishedPort ( ) ) { String childNodeName = p . getChildNodeName ( ) ; Node newChildNode = p . getChildNode ( this ) . withInputValue ( p . getChildPortName ( ) , value ) ; = . withChildReplaced ( childNodeName , newChildNode ) ; } return . withInputChanged ( portName , p ) ; } 
public boolean hasPublishedInput ( String publishedName ) { if ( ! isNetwork ) return false ; return hasInput ( publishedName ) & & getInput ( publishedName ) . isPublishedPort ( ) ; } 
public Node unpublish ( String childNodeName , String childPortName ) { checkArgument ( isNetwork , " Node %s is not a network node. " , this ) ; checkArgument ( hasChild ( childNodeName ) , " Node %s does not have a child named %s. " , this , childNodeName ) ; Node childNode = getChild ( childNodeName ) ; checkArgument ( childNode . hasInput ( childPortName ) , " Child node %s does not have a port named %s. " , childNodeName , childPortName ) ; Port childPort = childNode . getInput ( childPortName ) ; Port p = getPortByChildReference ( childNode , childPort ) ; return withInputRemoved ( p . getName ( ) ) ; } 
public Node unpublish ( String publishedName ) { checkArgument ( isNetwork , " Node %s is not a network node. " , this ) ; return withInputRemoved ( publishedName ) ; } 
public Node withRenderedChildName ( String name ) { checkArgument ( isNetwork , " Node %s is not a network node. " , this ) ; checkNotNull ( name , " Rendered child name cannot be null. " ) ; checkArgument ( name . isEmpty ( ) | | hasChild ( name ) , " Node does not have a child named %s. " , name ) ; return newNodeWithAttribute ( Attribute . RENDERED_CHILD_NAME , name ) ; } 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String category = this . category ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; boolean isNetwork = this . isNetwork ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case CATEGORY : category = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case IS_NETWORK : isNetwork = ( Boolean ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT or NETWORK, make it the prototype. if (this == ROOT || this == NETWORK) { prototype = this; } The name of a node can never be "_root" or "_network. if (name.equals("_root")) name = "node"; else if (name.equals("_network")) name = "network"; return new Node(prototype, name, category, description, image, function, position, inputs, outputType, outputRange, isNetwork, children, renderedChildName, connections, handle); 
public int hashCode ( ) { return Objects . hashCode ( prototype , name , category , description , image , function , position , inputs , outputType , outputRange , isNetwork , children , renderedChildName , connections , handle ) ; 
private static void parseNodeAttribute ( XMLStreamReader reader , Map < String , String > attributeMap , String attribute ) throws XMLStreamException { attributeMap . put ( attribute , reader . getAttributeValue ( null , attribute ) ) ; } 
private static Map parseNodeAttributes ( XMLStreamReader reader ) throws XMLStreamException { Map < String , String > attributeMap = new HashMap < String , String > ( ) ; String [ ] attributes = { " prototype " , " name " , " category " , " description " , " image " , " function " , " outputType " , " outputRange " , " position " , " renderedChild " , " handle " } ; for ( String attribute : attributes ) parseNodeAttribute ( reader , attributeMap , attribute ) ; return attributeMap ; } 
private static Node createNode ( Map < String , String > attributeMap , Node extendFromNode , Node parent , NodeRepository nodeRepository ) { String prototypeId = attributeMap . get ( " prototype " ) ; String name = attributeMap . get ( " name " ) ; String category = attributeMap . get ( " category " ) ; String description = attributeMap . get ( " description " ) ; String image = attributeMap . get ( " image " ) ; String function = attributeMap . get ( " function " ) ; String outputType = attributeMap . get ( " outputType " ) ; String outputRange = attributeMap . get ( " outputRange " ) ; String position = attributeMap . get ( " position " ) ; String handle = attributeMap . get ( " handle " ) ; Node prototype = prototypeId = = null ? extendFromNode : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) return null ; Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( category ! = null ) node = node . withCategory ( category ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputType ! = null ) node = node . withOutputType ( outputType ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; return node ; } 
private static Node parseNode ( XMLStreamReader reader , Node parent , NodeRepository nodeRepository ) throws XMLStreamException { Map < String , String > attributeMap = parseNodeAttributes ( reader ) ; Node node = createNode ( attributeMap , Node . ROOT , parent , nodeRepository ) ; String prototypeId = attributeMap . get ( " prototype " ) ; if ( node = = null ) { throw new XMLStreamException ( " Prototype " + prototypeId + " could not be found. " , reader . getLocation ( ) ) ; } while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " node " ) ) { if ( prototypeId = = null & & ! node . isNetwork ( ) ) node = createNode ( attributeMap , Node . NETWORK , parent , nodeRepository ) ; node = node . withChildAdded ( parseNode ( reader , node , nodeRepository ) ) ; } else if ( tagName . equals ( " port " ) ) { String portName = reader . getAttributeValue ( null , " name " ) ; Remove the port if it is already on the prototype. if (node.hasInput(portName)) { node = node.withInputChanged(portName, parsePort(reader, node.getInput(portName))); } else { node = node.withInputAdded(parsePort(reader, null)); } } else if (tagName.equals("conn")) { node = node.withConnectionAdded(parseConnection(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("node")) break; } } This has to come at the end, since the child first needs to exist. String renderedChildName = attributeMap.get("renderedChild"); if (renderedChildName != null) node = node.withRenderedChildName(renderedChildName); return node; } 
public void testValidSubnetworkResults ( ) { Node subnet1 = createAddNetwork ( " subnet1 " , 1.0 , 2.0 ) ; Node subnet2 = createAddNetwork ( " subnet2 " , 3.0 , 4.0 ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) ; Node net = Node . NETWORK . withChildAdded ( subnet1 ) . withChildAdded ( subnet2 ) . withChildAdded ( add1 ) . withRenderedChildName ( " add1 " ) . connect ( " subnet1 " , " add1 " , " v1 " ) . connect ( " subnet2 " , " add1 " , " v2 " ) ; assertResultsEqual ( net , add1 , 10.0 ) ; } 
public void testAddNode ( ) { NodeLibrary library ; Node parent = Node . NETWORK . withName ( " parent " ) ; controller . addNode ( " / " , parent ) ; library = controller . getNodeLibrary ( ) ; assertTrue ( library . getRoot ( ) . hasChild ( " parent " ) ) ; assertSame ( parent , library . getRoot ( ) . getChild ( " parent " ) ) ; assertSame ( parent , library . getNodeForPath ( " /parent " ) ) ; Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " /parent " , child ) ; library = controller . getNodeLibrary ( ) ; assertTrue ( library . getRoot ( ) . getChild ( " parent " ) . hasChild ( " child " ) ) ; assertSame ( child , library . getNodeForPath ( " /parent/child " ) ) ; assertNotSame ( " No longer the same since the new parent has an extra child. " , parent , library . getNodeForPath ( " /parent " ) ) ; } 
public void testPasteIntoSubnetwork ( ) { createTestNetwork ( ) ; controller . addNode ( " / " , Node . NETWORK . withName ( " subnet " ) ) ; controller . pasteNodes ( " /subnet " , controller . getRootNode ( ) , ImmutableList . of ( controller . getNode ( " /alpha " ) , controller . getNode ( " /beta " ) ) ) ; Node subnet = controller . getNode ( " /subnet " ) ; assertTrue ( subnet . hasChild ( " alpha " ) ) ; assertTrue ( subnet . hasChild ( " beta " ) ) ; assertTrue ( subnet . isConnected ( " alpha " ) ) ; assertTrue ( subnet . isConnected ( " beta " ) ) ; } 
public void testSimpleUnpublish ( ) { Node invertNode = Node . ROOT . withName ( " negate " ) . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 0 ) ) ; controller . addNode ( " / " , Node . NETWORK . withName ( " subnet " ) ) ; controller . addNode ( " /subnet " , invertNode ) ; controller . publish ( " /subnet " , " negate " , " value " , " " ) ; controller . unpublish ( " /subnet " , " " ) ; assertFalse ( controller . getNode ( " /subnet " ) . hasPublishedInput ( " " ) ) ; } 
public void testRenderedNode ( ) { Node child1 = Node . ROOT . withName ( " child1 " ) ; Node originalRoot = Node . NETWORK . withChildAdded ( child1 ) . withRenderedChild ( child1 ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , originalRoot , FunctionRepository . of ( ) ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; assertEquals ( " child1 " , library . getRoot ( ) . getRenderedChildName ( ) ) ; assertNotNull ( library . getRoot ( ) . getRenderedChild ( ) ) ; } 
public void testMenuPrototypeSerialization ( ) { Node letterPrototype = makeLetterMenuNode ( ) ; Node letterNode = letterPrototype . extend ( ) . withName ( " my_letter " ) . withInputValue ( " letter " , " b " ) ; Node originalRoot = Node . NETWORK . withChildAdded ( letterPrototype ) . withChildAdded ( letterNode ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , originalRoot ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Port letterPort = library . getRoot ( ) . getChild ( " my_letter " ) . getInput ( " letter " ) ; assertTrue ( letterPort . hasMenu ( ) ) ; assertEquals ( 2 , letterPort . getMenuItems ( ) . size ( ) ) ; assertEquals ( " b " , letterPort . getValue ( ) ) ; } 
private void assertPrototypeBeforeInstance ( String prototypeName , String . . . instanceNames ) { Node originalPrototype = Node . ROOT . withName ( prototypeName ) ; Node network = Node . NETWORK . withChildAdded ( originalPrototype ) ; for ( String instanceName : instanceNames ) { Node originalInstance = originalPrototype . extend ( ) . withName ( instanceName ) ; network = network . withChildAdded ( originalInstance ) ; } NodeLibrary originalLibrary = NodeLibrary . create ( " test " , network ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Node prototype = library . getRoot ( ) . getChild ( prototypeName ) ; for ( String instanceName : instanceNames ) { Node instance = library . getRoot ( ) . getChild ( instanceName ) ; 
public void testPublishedPortSerialization ( ) { Node inner = Node . ROOT . withName ( " inner " ) . withInputAdded ( Port . floatPort ( " value " , 0.0 ) ) . withFunction ( " math/number " ) ; Node outer = Node . NETWORK . withName ( " outer " ) . withChildAdded ( inner ) . publish ( " inner " , " value " , " v " ) . withInputValue ( " v " , 11.0 ) ; assertEquals ( 11 , outer . getChild ( " inner " ) . getInput ( " value " ) . intValue ( ) ) ; NodeLibrary originalLibrary = libraryWithChildren ( " test " , outer ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; assertTrue ( library . getNodeForPath ( " /outer " ) . hasPublishedInput ( " v " ) ) ; assertEquals ( 11 , library . getNodeForPath ( " /outer/inner " ) . getInput ( " value " ) . intValue ( ) ) ; } 
private NodeLibrary libraryWithChildren ( String libraryName , Node . . . children ) { Node root = Node . NETWORK . withName ( " root " ) ; for ( Node child : children ) { root = root . withChildAdded ( child ) ; } return NodeLibrary . create ( libraryName , root , FunctionRepository . of ( ) ) ; } 
public Node withChildInputRemoved ( String childName , String portName ) { checkArgument ( isNetwork ( ) , " Node %s is not a network node. " , this ) ; checkArgument ( hasChild ( childName ) , " Node %s does not have a child named %s. " , this , childName ) ; Node child = getChild ( childName ) ; checkArgument ( child . hasInput ( portName ) , " Node %s does not have an input port %s. " , childName , portName ) ; if ( hasPublishedInput ( childName , portName ) ) return unpublish ( childName , portName ) . withChildInputRemoved ( childName , portName ) ; if ( isConnected ( childName , portName ) ) return disconnect ( childName , portName ) . withChildInputRemoved ( childName , portName ) ; return withChildReplaced ( childName , child . withInputRemoved ( portName ) ) ; } 
private Node withChildInputChanged ( String childName , String portName , Port newPort ) { todo: checks checkArgument(isNetwork(), "Node %s is not a network node.", this); return withChildReplaced(childName, getChild(childName).withInputChanged(portName, newPort)); } 
public Node withChildPositionChanged ( String childName , double xOffset , double yOffset ) { checkArgument ( isNetwork ( ) , " Node %s is not a network node. " , this ) ; checkArgument ( hasChild ( childName ) , " Node %s does not have a child named %s. " , this , childName ) ; Node child = getChild ( childName ) ; return withChildReplaced ( childName , child . withPosition ( child . getPosition ( ) . moved ( xOffset , yOffset ) ) ) ; } 
public Node withInputValue ( String portName , Object value ) { Port p = getInput ( portName ) ; checkNotNull ( p , " Input port %s does not exist on node %s. " , portName , this ) ; p = p . withValue ( value ) ; Node = this ; if ( isNetwork ( ) & & p . isPublishedPort ( ) ) { String childNodeName = p . getChildNodeName ( ) ; Node newChildNode = p . getChildNode ( this ) . withInputValue ( p . getChildPortName ( ) , value ) ; = . withChildReplaced ( childNodeName , newChildNode ) ; } return . withInputChanged ( portName , p ) ; } 
public boolean hasPublishedInput ( String publishedName ) { if ( ! isNetwork ( ) ) return false ; return hasInput ( publishedName ) & & getInput ( publishedName ) . isPublishedPort ( ) ; } 
public Node unpublish ( String childNodeName , String childPortName ) { checkArgument ( isNetwork ( ) , " Node %s is not a network node. " , this ) ; checkArgument ( hasChild ( childNodeName ) , " Node %s does not have a child named %s. " , this , childNodeName ) ; Node childNode = getChild ( childNodeName ) ; checkArgument ( childNode . hasInput ( childPortName ) , " Child node %s does not have a port named %s. " , childNodeName , childPortName ) ; Port childPort = childNode . getInput ( childPortName ) ; Port p = getPortByChildReference ( childNode , childPort ) ; return withInputRemoved ( p . getName ( ) ) ; } 
public Node unpublish ( String publishedName ) { checkArgument ( isNetwork ( ) , " Node %s is not a network node. " , this ) ; return withInputRemoved ( publishedName ) ; } 
public Node withRenderedChildName ( String name ) { checkArgument ( isNetwork ( ) , " Node %s is not a network node. " , this ) ; checkNotNull ( name , " Rendered child name cannot be null. " ) ; checkArgument ( name . isEmpty ( ) | | hasChild ( name ) , " Node does not have a child named %s. " , name ) ; return newNodeWithAttribute ( Attribute . RENDERED_CHILD_NAME , name ) ; } 
private static Node lookupNode ( String nodeId , Node parent , NodeRepository nodeRepository ) { if ( nodeId . equals ( " _root " ) ) return Node . ROOT ; if ( nodeId . equals ( " _network " ) ) return Node . NETWORK ; if ( nodeId . contains ( " . " ) ) { return nodeRepository . getNode ( nodeId ) ; 
private void lookForLibraries ( ) { NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; systemRepository = NodeRepository . of ( mathLibrary , stringLibrary , colorLibrary , listLibrary , dataLibrary , corevectorLibrary ) ; 
public static BufferedImage findNodeImage ( NodeLibrary library , Node node ) { if ( node = = null | | node . getImage ( ) = = null | | node . getImage ( ) . isEmpty ( ) ) return null ; if ( ! library . getRoot ( ) . hasChild ( node ) ) return null ; File libraryDirectory = null ; if ( library . getFile ( ) ! = null ) libraryDirectory = library . getFile ( ) . getParentFile ( ) ; else if ( library . equals ( NodeLibrary . coreLibrary ) ) libraryDirectory = new File ( " libraries/core " ) ; if ( libraryDirectory ! = null ) { File nodeImageFile = new File ( libraryDirectory , node . getImage ( ) ) ; if ( nodeImageFile . exists ( ) ) { return readNodeImage ( nodeImageFile ) ; } } return null ; } 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String category = this . category ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; boolean isNetwork = this . isNetwork ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case CATEGORY : category = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case IS_NETWORK : isNetwork = ( Boolean ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT or NETWORK, make it the prototype. if (this == ROOT || this == NETWORK) { prototype = this; } The name of a node can never be "_root" or "network. if (name.equals("_root")) name = "node"; else if (name.equals("network")) name = "network1"; return new Node(prototype, name, category, description, image, function, position, inputs, outputType, outputRange, isNetwork, children, renderedChildName, connections, handle); 
private static Node lookupNode ( String nodeId , Node parent , NodeRepository nodeRepository ) { if ( nodeId . equals ( " _root " ) ) return Node . ROOT ; if ( nodeId . contains ( " . " ) ) { return nodeRepository . getNode ( nodeId ) ; 
public static NodeRepository empty ( ) { return new NodeRepository ( ImmutableMap . < String , NodeLibrary > of ( ) ) ; } 
public static NodeRepository of ( ) { return new NodeRepository ( ImmutableMap . < String , NodeLibrary > of ( " core " , NodeLibrary . coreLibrary ) ) ; } 
public static NodeRepository of ( NodeLibrary . . . libraries ) { ImmutableMap . Builder < String , NodeLibrary > builder = ImmutableMap . builder ( ) ; for ( NodeLibrary library : libraries ) { if ( library . getName ( ) . equals ( " core " ) ) continue ; builder . put ( library . getName ( ) , library ) ; } builder . put ( " core " , NodeLibrary . coreLibrary ) ; return new NodeRepository ( builder . build ( ) ) ; } 
private static Node parseNode ( XMLStreamReader reader , Node parent , NodeRepository nodeRepository ) throws XMLStreamException { Map < String , String > attributeMap = parseNodeAttributes ( reader ) ; Node node = createNode ( attributeMap , Node . ROOT , parent , nodeRepository ) ; String prototypeId = attributeMap . get ( " prototype " ) ; if ( node = = null ) { throw new XMLStreamException ( " Prototype " + prototypeId + " could not be found. " , reader . getLocation ( ) ) ; } while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " node " ) | | tagName . equals ( " importCoreNode " ) ) { if ( prototypeId = = null & & ! node . isNetwork ( ) ) node = createNode ( attributeMap , Node . NETWORK , parent , nodeRepository ) ; } if ( tagName . equals ( " node " ) ) { node = node . withChildAdded ( parseNode ( reader , node , nodeRepository ) ) ; } else if ( tagName . equals ( " importCoreNode " ) ) { String s = reader . getAttributeValue ( null , " ref " ) ; Node coreNode = Node . coreNodes . get ( s ) ; if ( coreNode = = null ) { throw new XMLStreamException ( " Core node ' " + s + " ' does not exist. " , reader . getLocation ( ) ) ; } node = node . withChildAdded ( coreNode ) ; } else if ( tagName . equals ( " port " ) ) { String portName = reader . getAttributeValue ( null , " name " ) ; Remove the port if it is already on the prototype. if (node.hasInput(portName)) { node = node.withInputChanged(portName, parsePort(reader, node.getInput(portName))); } else { node = node.withInputAdded(parsePort(reader, null)); } } else if (tagName.equals("conn")) { node = node.withConnectionAdded(parseConnection(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("node")) break; } } This has to come at the end, since the child first needs to exist. String renderedChildName = attributeMap.get("renderedChild"); if (renderedChildName != null) node = node.withRenderedChildName(renderedChildName); return node; } 
public void testCoreNodes ( ) { assertTrue ( NodeLibrary . coreLibrary . getRoot ( ) . hasChild ( Node . ROOT ) ) ; assertTrue ( NodeLibrary . coreLibrary . getRoot ( ) . hasChild ( Node . NETWORK ) ) ; } 
public void testNonExistingCoreNode ( ) { try { File f = new File ( " src/test/files/bad-corenode.ndbx " ) ; 
private static boolean shouldWriteAttribute ( Node node , Node . Attribute attribute ) { checkArgument ( node ! = Node . ROOT , " You cannot write out the ROOT node. " ) ; Object prototypeValue = node . getPrototype ( ) . getAttributeValue ( attribute ) ; Object nodeValue = node . getAttributeValue ( attribute ) ; if ( attribute ! = Node . Attribute . PROTOTYPE ) { checkNotNull ( prototypeValue , " Attribute %s of node %s is empty. " , attribute , node . getPrototype ( ) ) ; 
private static boolean shouldWriteAttribute ( Node node , Port port , Port . Attribute attribute ) { checkArgument ( node ! = Node . ROOT , " You cannot write out the ROOT node. " ) ; Port prototypePort = node . getPrototype ( ) . getInput ( port . getName ( ) ) ; If there is no prototype port, we should always write the attribute. if (prototypePort == null) return true; Object prototypeValue = prototypePort.getAttributeValue(attribute); Object value = port.getAttributeValue(attribute); Objects.equal does the correct null-comparison for min / max values. return !Objects.equal(prototypeValue, value); } 
public static void validateName ( String name ) throws InvalidNameException { Matcher m1 = NODE_NAME_PATTERN . matcher ( name ) ; Matcher m2 = DOUBLE_UNDERSCORE_PATTERN . matcher ( name ) ; Matcher m3 = RESERVED_WORD_PATTERN . matcher ( name ) ; if ( ! m1 . matches ( ) ) { throw new InvalidNameException ( null , name , " Names can only contain lowercase letters, numbers, and the underscore. Names cannot be longer than 29 characters. " ) ; } if ( m2 . matches ( ) ) { throw new InvalidNameException ( null , name , " Names starting with double underscore are reserved for internal use. " ) ; } if ( m3 . matches ( ) ) { throw new InvalidNameException ( null , name , " Names cannot be a reserved word (network, node). " ) ; 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String category = this . category ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; boolean isNetwork = this . isNetwork ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case CATEGORY : category = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case IS_NETWORK : isNetwork = ( Boolean ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT or NETWORK, make it the prototype. if (this == ROOT || this == NETWORK) { prototype = this; } The name of a node can never be "node" or "network". if (name.equals("node")) name = "node1"; else if (name.equals("network")) name = "network1"; return new Node(prototype, name, category, description, image, function, position, inputs, outputType, outputRange, isNetwork, children, renderedChildName, connections, handle); 
private void assertPortSerialization ( Port originalPort ) { Node originalNode ; originalNode = Node . ROOT . withInputAdded ( originalPort ) ; NodeLibrary originalLibrary = libraryWithChildren ( " test " , originalNode ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( ) ) ; Node node = library . getRoot ( ) . getChild ( " node1 " ) ; assertNotNull ( node ) ; Port port ; port = node . getInput ( originalPort . getName ( ) ) ; assertEquals ( originalPort . getName ( ) , port . getName ( ) ) ; assertEquals ( originalPort . getType ( ) , port . getType ( ) ) ; assertEquals ( originalPort . getValue ( ) , port . getValue ( ) ) ; } 
public void testRootName ( ) { assertEquals ( " node " , Node . ROOT . getName ( ) ) ; The moment we extend from root, the name changes. assertEquals("node1", Node.ROOT.withFunction("test").getName()); } 
public void testReservedRootName ( ) { Node . ROOT . withName ( " node " ) . getName ( ) ; } 
public void testChildWithInvalidName ( ) { Node root = Node . ROOT . withName ( " root " ) ; assertEquals ( " root " , root . getName ( ) ) ; Node . NETWORK . withChildAdded ( root ) ; } 
public void testChildInvalidRenaming ( ) { Node . NETWORK . withChildAdded ( Node . ROOT . withName ( " child " ) ) 
public static UpgradeStringResult upgrade15to16 ( String inputXml ) throws LoadException { Version 16: 'network' and 'node' are reserved names. Nodes with those names have to be renamed. Besides this, only the top level node in any network is allowed to have the name 'root'. UpgradeOp renameNodeOp1 = new ExactRenameNodeOp("network", "network"); UpgradeOp renameNodeOp2 = new ExactRenameNodeOp("node", "node"); ExactRenameNodeOp renameNodeOp3 = new ExactRenameNodeOp("root", "node"); renameNodeOp3.skipRootNode(); return transformXml(inputXml, "16", renameNodeOp1, renameNodeOp2, renameNodeOp3); } 
private void skipRootNode ( ) { this . shouldSkipRoot = true ; } 
public void testUpgrade15to16 ( ) { File version15File = new File ( " src/test/files/upgrade-v15.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version15File ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version15File , NodeRepository . of ( mathLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertEquals ( " root " , root . getName ( ) ) ; assertEquals ( " network2 " , root . getRenderedChildName ( ) ) ; assertEquals ( " number " , root . getChild ( " node3 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( " node3 " , root . getConnection ( " add1 " , " value1 " ) . getOutputNode ( ) ) ; assertEquals ( 5.0 , root . getChild ( " node2 " ) . getInput ( " value " ) . getValue ( ) ) ; assertEquals ( " abs " , root . getChild ( " root123 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( 11.0 , root . getChild ( " network1 " ) . getChild ( " node1 " ) . getInput ( " value " ) . getValue ( ) ) ; assertEquals ( " node1 " , root . getChild ( " network1 " ) . getRenderedChildName ( ) ) ; assertEquals ( " node1 " , root . getChild ( " network2 " ) . getRenderedChildName ( ) ) ; assertEquals ( " node2 " , root . getChild ( " network2 " ) . getChild ( " node1 " ) . getRenderedChildName ( ) ) ; assertEquals ( 17.0 , root . getChild ( " network2 " ) . getChild ( " node1 " ) . getChild ( " node2 " ) . getInput ( " value " ) . getValue ( ) ) ; } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; nodeMenu = new JPopupMenu ( ) ; nodeMenu . add ( new SetRenderedAction ( ) ) ; nodeMenu . add ( new RenameAction ( ) ) ; nodeMenu . add ( new DeleteAction ( ) ) ; nodeMenu . add ( new GroupIntoNetworkAction ( null ) ) ; goInSubnetworkMenuItem = nodeMenu . add ( new GoInAction ( ) ) ; nodeMenu . add ( new HelpAction ( ) ) ; } 
public void testNetworkName ( ) { assertEquals ( " network " , Node . NETWORK . getName ( ) ) ; The moment we extend from network, the name changes. assertEquals("network1", Node.NETWORK.withOutputType("int").getName()); } 
public void testReservedNetworkName ( ) { Node . NETWORK . withName ( " network " ) . getName ( ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " https:github.com/nodebox/nodebox/issues " ) ; } 
private int measureWidth ( ) { To measure text we need a graphics context. Create an image and use its' graphics context. BufferedImage tmp = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB); Graphics2D g2 = tmp.createGraphics(); g2.setFont(Theme.SMALL_BOLD_FONT); int width = normalImage.getWidth(null); width += IMAGE_TEXT_MARGIN; width += (int) g2.getFontMetrics().stringWidth(text); width += 1; Anti-aliasing can take up an extra pixel. return width; } 
public void mouseClicked ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; pressed = true ; armed = true ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; pressed = false ; if ( armed ) { armed = false ; if ( mode = = Mode . CHECK ) checked = ! checked ; try { actionMethod . invoke ( actionObject ) ; } catch ( Exception e1 ) { throw new RuntimeException ( " Could not invoke method " + actionMethod + " on object " + actionObject , e1 ) ; } repaint ( ) ; } } public void mouseEntered ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; if ( pressed ) { armed = true ; repaint ( ) ; } } public void mouseExited ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; armed = false ; repaint ( ) ; } public static enum Mode { PUSH , CHECK } } 
public String getName ( ) ; public Version getVersion ( ) ; public URL getIconFile ( ) ; public String getAppcastURL ( ) ; } 
public Version getVersion ( ) ; public URL getIconFile ( ) ; public String getAppcastURL ( ) ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final ExportViewer viewer = new ExportViewer ( ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame ) ; List < ? > results = context . renderNode ( exportNetwork ) ; Node renderedChild = exportNetwork . getRenderedChild ( ) ; viewer . setOutputValues ( results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; viewer . setVisible ( true ) ; } 
private static Map < String , String > parseNodeAttributes ( XMLStreamReader reader ) throws XMLStreamException { Map < String , String > attributeMap = new HashMap < String , String > ( ) ; String [ ] attributes = { " prototype " , " name " , " category " , " description " , " image " , " function " , " outputType " , " outputRange " , " position " , " renderedChild " , " handle " } ; for ( String attribute : attributes ) parseNodeAttribute ( reader , attributeMap , attribute ) ; return attributeMap ; } 
public static UpgradeStringResult upgrade15to16 ( String inputXml ) throws LoadException { Version 16: 'network' and 'node' are reserved names. Nodes with those names have to be renamed. Besides this, only the top level node in any network is allowed to have the name 'root'. UpgradeOp renameNodeOp1 = new ExactRenameNodeOp("network", "network"); UpgradeOp renameNodeOp2 = new ExactRenameNodeOp("node", "node"); ExactRenameNodeOp renameNodeOp3 = new ExactRenameNodeOp("root", "node"); renameNodeOp3.skipRootNode(); UpgradeOp addAttributeOp = new AddAttributeOp("corevector.geonet", "outputType", "geometry"); UpgradeOp changePrototypeOp = new ChangePrototypeOp("corevector.geonet", "core.network"); return transformXml(inputXml, "16", renameNodeOp1, renameNodeOp2, renameNodeOp3, addAttributeOp, changePrototypeOp); } 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , prototype ) ) { e . addAttribute ( new Attribute ( attributeName , attributeValue ) ) ; 
public void testUpgrade15to16 ( ) { File version15File = new File ( " src/test/files/upgrade-v15.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version15File ) ; NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version15File , NodeRepository . of ( mathLibrary , corevectorLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertEquals ( " root " , root . getName ( ) ) ; assertEquals ( " network2 " , root . getRenderedChildName ( ) ) ; assertEquals ( " number " , root . getChild ( " node3 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( " node3 " , root . getConnection ( " add1 " , " value1 " ) . getOutputNode ( ) ) ; assertEquals ( 5.0 , root . getChild ( " node2 " ) . getInput ( " value " ) . getValue ( ) ) ; assertEquals ( " abs " , root . getChild ( " root123 " ) . getPrototype ( ) . getName ( ) ) ; assertEquals ( 11.0 , root . getChild ( " network1 " ) . getChild ( " node1 " ) . getInput ( " value " ) . getValue ( ) ) ; assertEquals ( " node1 " , root . getChild ( " network1 " ) . getRenderedChildName ( ) ) ; assertEquals ( " node1 " , root . getChild ( " network2 " ) . getRenderedChildName ( ) ) ; assertEquals ( " node2 " , root . getChild ( " network2 " ) . getChild ( " node1 " ) . getRenderedChildName ( ) ) ; assertEquals ( 17.0 , root . getChild ( " network2 " ) . getChild ( " node1 " ) . getChild ( " node2 " ) . getInput ( " value " ) . getValue ( ) ) ; assertEquals ( Node . NETWORK , root . getChild ( " geonet1 " ) . getPrototype ( ) ) ; assertEquals ( " geometry " , root . getChild ( " geonet1 " ) . getOutputType ( ) ) ; } 
private void lookForLibraries ( ) { NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary realTimeLibrary = NodeLibrary . load ( new File ( " libraries/realTime/realTime.ndbx " ) , NodeRepository . of ( ) ) ; systemRepository = NodeRepository . of ( mathLibrary , stringLibrary , colorLibrary , listLibrary , dataLibrary , corevectorLibrary , realTimeLibrary ) ; 
public void run ( ) { ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewerPane . getViewer ( ) . getLastMousePosition ( ) ) ; final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame , data ) ; Throwable renderException = null ; startRendering ( context ) ; List < ? > results = null ; try { results = context . renderNode ( renderNetwork ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); if (renderException == null) { finishedRendering(renderNetwork, results); 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final ExportViewer viewer = new ExportViewer ( ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame , ImmutableMap . < String , Object > of ( ) ) ; List < ? > results = context . renderNode ( exportNetwork ) ; Node renderedChild = exportNetwork . getRenderedChild ( ) ; viewer . setOutputValues ( results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; viewer . setVisible ( true ) ; } 
public void mouseDragged ( MouseEvent e ) { We register the mouse drag as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); handle.mouseDragged(pointForEvent(e)); } lastMousePosition = pointForEvent(e); } 
public void mouseMoved ( MouseEvent e ) { Moving the mouse in the viewer area should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; if (hasVisibleHandle()) { handle.mouseMoved(pointForEvent(e)); } lastMousePosition = pointForEvent(e); } 
public static Point mousePosition ( NodeContext context ) { Point p = ( Point ) context . getData ( ) . get ( " mouse.position " ) ; if ( p ! = null ) { return p ; 
public static List < Point > bufferPoints ( Point point , long size ) { List < Point > buffer = pointBuffer . get ( ) ; if ( buffer = = null ) { buffer = new ArrayList < Point > ( 100 ) ; } buffer . add ( point ) ; if ( buffer . size ( ) > size ) { buffer . remove ( 0 ) ; } pointBuffer . set ( buffer ) ; return buffer ; } 
private static Rectangle inputPortRect ( Node node , Port port ) { if ( isHiddenPort ( port ) ) return new Rectangle ( ) ; Point pt = nodePoint ( node ) ; Rectangle portRect = new Rectangle ( pt . x + portOffset ( node , port ) , pt . y - PORT_HEIGHT , PORT_WIDTH , PORT_HEIGHT ) ; growHitRectangle ( portRect ) ; return portRect ; } 
private static boolean isHiddenPort ( Port port ) { return port . getType ( ) . equals ( Port . TYPE_STATE ) | | port . getType ( ) . equals ( Port . TYPE_CONTEXT ) ; } 
public void rewindAnimation ( ) { stopAnimation ( ) ; resetRenderResults ( ) ; setFrame ( 1 ) ; } 
private synchronized void resetRenderResults ( ) { renderResults = ImmutableMap . of ( ) ; } 
public void run ( ) { ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewerPane . getViewer ( ) . getLastMousePosition ( ) ) ; final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame , data , renderResults ) ; Throwable renderException = null ; startRendering ( context ) ; List < ? > results = null ; try { results = context . renderNode ( renderNetwork ) ; renderResults = context . getRenderResults ( ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); if (renderException == null) { finishedRendering(renderNetwork, results); 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final ExportViewer viewer = new ExportViewer ( ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame , ImmutableMap . < String , Object > of ( ) , renderResults ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; viewer . setVisible ( true ) ; } 
public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; 
public static List < Point > bufferPoints ( Point point , long size , final List < Point > previousPoints ) { ImmutableList . Builder < Point > newPoints = ImmutableList . builder ( ) ; if ( previousPoints . size ( ) = = size ) { newPoints . addAll ( Iterables . skip ( previousPoints , 1 ) ) ; } else { newPoints . addAll ( previousPoints ) ; } newPoints . add ( point ) ; return newPoints . build ( ) ; } 
public List < ? > renderNode ( Node node , Map < Port , ? > argumentMap ) { checkNotNull ( node ) ; checkNotNull ( functionRepository ) ; If the node has children, forgo the operation of the current node and evaluate the child. Object result; if (node.hasRenderedChild()) { result = renderChild(node, node.getRenderedChild(), argumentMap); } else { result = invokeNode(node, argumentMap); } List<?> results = postProcessResult(node, result); renderResults.put(node, results); return results; } 
public static List < String > glyphs ( String s ) { if ( s = = null ) { return ImmutableList . of ( ) ; } return ImmutableList . copyOf ( Splitter . fixedLength ( 1 ) . split ( s ) ) ; } 
public static List < String > randomGlyph ( String glyphSet , long amount , long seed ) { List < String > result = new ArrayList < String > ( ) ; Random r = new Random ( seed * 1000000000 ) ; for ( long i = 0 ; i < amount ; i + + ) { int index = ( int ) ( r . nextDouble ( ) * glyphSet . length ( ) ) ; result . add ( String . valueOf ( glyphSet . charAt ( index ) ) ) ; } return result ; } 
public static String asBinaryString ( String s , String digitSep , String byteSep ) { if ( s = = null ) { return s ; } byte [ ] bytes = s . getBytes ( ) ; StringBuilder result = new StringBuilder ( ) ; for ( byte b : bytes ) { int val = b ; for ( int i = 0 ; i < 8 ; i + + ) { result . append ( ( ( val & 128 ) = = 0 ? " 0 " : " 1 " ) ) ; if ( i < 7 ) { result . append ( digitSep ) ; } val < < = 1 ; } result . append ( byteSep ) ; } return result . toString ( ) ; } 
public static List < String > asBinaryList ( String s ) { List < String > result = new ArrayList < String > ( ) ; if ( s = = null ) { return result ; } byte [ ] bytes = s . getBytes ( ) ; for ( byte b : bytes ) { int val = b ; for ( int i = 0 ; i < 8 ; i + + ) { result . add ( ( val & 128 ) = = 0 ? " 0 " : " 1 " ) ; val < < = 1 ; } } return result ; } 
public static List < String > asNumberList ( String s , long radix , boolean padding ) { List < String > numberList = new ArrayList < String > ( ) ; if ( ( radix < 2 ) | | ( s = = null ) ) { return numberList ; } byte [ ] bytes = s . getBytes ( ) ; if ( padding ) { if ( radix = = 2 ) { binary for (byte b : bytes) { int cval = b; StringBuilder result = new StringBuilder(); for (int i = 0; i < 8; i++) { result.append( (cval & 128) == 0 ? "0" : "1" ); cval <<= 1; } numberList.add( result.toString() ); } } else if (radix == 3) { for (byte b : bytes) { int val = Integer.parseInt( Integer.toString( b, (int)radix ) ); numberList.add( String.format("%06d", val) ); } } else if ((radix > 3) && (radix < 7) ) { for (byte b : bytes) { int val = Integer.parseInt( Integer.toString( b, (int)radix ) ); numberList.add( String.format("%04d", val) ); } } else if ((radix < 15) ) { for (byte b : bytes) { StringBuilder result = new StringBuilder( Integer.toString( b, (int)radix ) ); for (int i = result.length(); i < 3; i++) { result.insert( 0, "0" ); zero pad the beginning of the string } numberList.add( result.toString() ); } } else { for (byte b : bytes) { StringBuilder result = new StringBuilder( Integer.toString( b, (int)radix ) ); for (int i = result.length(); i < 2; i++) { result.insert( 0, "0" ); zero pad the beginning of the string } numberList.add( result.toString() ); } } } else { if (radix == 2) { binary for (byte b : bytes) { int cval = b; StringBuilder result = new StringBuilder(); for (int i = 0; i < 8; i++) { result.append( (cval & 128) == 0 ? "0" : "1" ); cval <<= 1; } numberList.add( result.toString() ); } } else { for (byte b : bytes) { numberList.add( Integer.toString( b, (int)radix ) ); } } } return numberList; } 
public static String glyphAt ( String s , long index ) { if ( s = = null ) { return s ; } index - - ; input is indexed from 1 not 0 index = index % s.length(); wrap value return String.valueOf(s.charAt( (int)index)); } 
public static String countGlyphs ( String s ) { TODO return s; } 
public static boolean contains ( String s , String value ) { if ( ( s = = null ) | | ( value = = null ) ) { return false ; } return s . contains ( value ) ; } 
public static boolean endsWith ( String s , String value ) { if ( ( s = = null ) | | ( value = = null ) ) { return false ; } return s . endsWith ( value ) ; } 
public static boolean equal ( String s , String value , boolean caseSensitive ) { if ( ( s = = null ) | | ( value = = null ) ) { return false ; } if ( caseSensitive ) { return s . equals ( value ) ; 
public static String replace ( String s , String oldVal , String newVal ) { if ( ( oldVal = = null ) | | ( newVal = = null ) ) { return s ; } return s . replace ( oldVal , newVal ) ; } 
public static boolean startsWith ( String s , String value ) { if ( ( s = = null ) | | ( value = = null ) ) { return false ; } return s . startsWith ( value ) ; } 
public static String subString ( String s , long start , long end , boolean endOffset ) { if ( s = = null ) { return s ; } start - - ; input is indexed from 1 not 0 end--; start = start % s.length(); wrap values if (endOffset) { end = (end % s.length()) +1; } else { end = end % (s.length() +1); } return s.substring((int)start, (int)end); } 
public static String trim ( String s ) { if ( s = = null ) { return s ; } return s . trim ( ) ; } 
protected void paintComponent ( Graphics g ) { positions = new int [ segments . size ( ) ] ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setFont ( Theme . SMALL_BOLD_FONT ) ; g2 . drawImage ( addressGradient , 0 , 0 , getWidth ( ) , 25 , null ) ; int x = 10 ; int i = 0 ; for ( String segment : segments ) { if ( i = = armed ) { g2 . setColor ( Theme . TEXT_ARMED_COLOR ) ; } else { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } SwingUtils . drawShadowText ( g2 , segment , x , 16 ) ; int width = g2 . getFontMetrics ( ) . stringWidth ( segment ) ; x + = width + 5 ; positions [ i ] = x + 10 ; g2 . drawImage ( addressArrow , x , 1 , null ) ; x + = 15 ; i + + ; } if ( ! message . isEmpty ( ) ) { g2 . setColor ( Theme . TEXT_NORMAL_COLOR ) ; 
public void oscEvent ( OscMessage m ) { ImmutableList < Object > arguments = ImmutableList . copyOf ( m . arguments ( ) ) ; oscMessages . put ( m . addrPattern ( ) , arguments ) ; System . out . println ( " OSC " + m . addrPattern ( ) + " " + arguments ) ; } 
public void oscStatus ( OscStatus oscStatus ) { System . out . println ( " oscStatus = " + oscStatus ) ; } 
private static int randomOSCPort ( ) { return 1024 + ( int ) Math . round ( Math . random ( ) * 10000 ) ; } 
public void run ( ) { ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewerPane . getViewer ( ) . getLastMousePosition ( ) , " osc.messages " , oscMessages ) ; final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame , data , renderResults ) ; Throwable renderException = null ; startRendering ( context ) ; List < ? > results = null ; try { results = context . renderNode ( renderNetwork ) ; renderResults = context . getRenderResults ( ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); if (renderException == null) { finishedRendering(renderNetwork, results); 
public static List < Object > receiveOSC ( String address , NodeContext context ) { Map < String , List < Object > > oscMessages = ( Map < String , List < Object > > ) context . getData ( ) . get ( " osc.messages " ) ; if ( oscMessages ! = null ) { for ( Map . Entry < String , List < Object > > e : oscMessages . entrySet ( ) ) { 
public static List < String > characters ( String s ) { if ( s = = null ) { return ImmutableList . of ( ) ; } return ImmutableList . copyOf ( Splitter . fixedLength ( 1 ) . split ( s ) ) ; } 
public static List < String > randomCharacter ( String characterSet , long amount , long seed ) { List < String > result = new ArrayList < String > ( ) ; Random r = new Random ( seed * 1000000000 ) ; for ( long i = 0 ; i < amount ; i + + ) { int index = ( int ) ( r . nextDouble ( ) * characterSet . length ( ) ) ; result . add ( String . valueOf ( characterSet . charAt ( index ) ) ) ; } return result ; } 
public static String characterAt ( String s , long index ) { if ( s = = null ) { return s ; } index - - ; input is indexed from 1 not 0 index = index % s.length(); wrap value return String.valueOf(s.charAt( (int)index)); } 
public static String countCharacters ( String s ) { TODO return s; } 
private synchronized void render ( ) { If we're already rendering, return. if (isRendering.get()) return; Before starting the renderNetwork, turn the "should render" flag off and the "is rendering" flag on. synchronized (shouldRender) { synchronized (isRendering) { shouldRender.set(false); isRendering.set(true); } } final NodeLibrary renderLibrary = getNodeLibrary(); final Node renderNetwork = getRenderedNode(); checkState(currentRender == null, "Another render is still in progress."); currentRender = renderService.submit(new Runnable() { public void run() { 
public void toggleRenderRoot ( ) { document . requestRender ( ) ; } 
public boolean shouldAlwaysRenderRoot ( ) { return renderRootCheck . isChecked ( ) ; } 
private static Iterable < Map < Port , ? > > buildArgumentMaps ( final Map < Port , List < ? > > argumentsPerPort ) { final int minSize = smallestArgumentList ( argumentsPerPort ) ; if ( minSize = = 0 ) return Collections . emptyList ( ) ; final int maxSize = biggestArgumentList ( argumentsPerPort ) ; return new Iterable < Map < Port , ? > > ( ) { int i = 0 ; 
public Iterator < Map < Port , ? > > iterator ( ) { return new Iterator < Map < Port , ? > > ( ) { @Override 
public boolean hasNext ( ) { return i < maxSize ; } 
public void remove ( ) { throw new UnsupportedOperationException ( ) ; } 
public void set ( Graphics2D g ) { if ( awtColor = = null ) { awtColor = new java . awt . Color ( ( float ) getRed ( ) , ( float ) getGreen ( ) , ( float ) getBlue ( ) , ( float ) getAlpha ( ) ) ; } g . setColor ( awtColor ) ; } 
public void draw ( Graphics2D g ) { If we can't fill or stroke the path, there's nothing to draw. if (fillColor == null && strokeColor == null) return; GeneralPath gp = getGeneralPath(); If there are no points, there's nothing to draw. if (getPointCount() == 0) return; if (fillColor != null) { fillColor.set(g); g.fill(gp); } if (strokeWidth > 0 && strokeColor != null) { try { 
public boolean containsKey ( Object o ) { return POINT_FIELDS . contains ( o ) ; } 
public boolean containsValue ( Object o ) { return o ! = null & & ( o . equals ( x ) | | o . equals ( y ) | | o . equals ( type ) ) ; } 
public Number get ( Object o ) { if ( o = = null ) return null ; if ( o . equals ( " x " ) ) return x ; if ( o . equals ( " y " ) ) return y ; if ( o . equals ( " type " ) ) return type ; return null ; } 
public Number put ( String s , Number o ) { throw new UnsupportedOperationException ( " Points are immutable. " ) ; } 
public Number remove ( Object o ) { throw new UnsupportedOperationException ( " Points are immutable. " ) ; } 
public void putAll ( Map < ? extends String , ? extends Number > map ) { throw new UnsupportedOperationException ( " Points are immutable. " ) ; } 
public void clear ( ) { throw new UnsupportedOperationException ( " Points are immutable. " ) ; } 
public Set < String > keySet ( ) { return ImmutableSet . copyOf ( POINT_FIELDS ) ; } 
public Collection < Number > values ( ) { return ImmutableList . < Number > of ( x , y , type ) ; } 
public Set < Entry < String , Number > > entrySet ( ) { return ImmutableMap . < String , Number > of ( " x " , x , " y " , y , " type " , type ) . entrySet ( ) ; } 
public void draw ( Graphics2D g ) { If we can't fill or stroke the path, there's nothing to draw. if (fillColor == null && strokeColor == null) return; GeneralPath gp = getGeneralPath(); if (fillColor != null) { fillColor.set(g); g.fill(gp); } if (strokeWidth > 0 && strokeColor != null) { try { 
private Object invokeNode ( Node node , Map < Port , ? > argumentMap ) { List < Port > inputs = node . getInputs ( ) ; Object [ ] arguments = new Object [ inputs . size ( ) ] ; int i = 0 ; for ( Port port : inputs ) { Object argument ; if ( argumentMap . containsKey ( port ) ) { argument = argumentMap . get ( port ) ; } else if ( port . hasValueRange ( ) ) { argument = getPortValue ( port ) ; } else { The port expects a list but nothing is connected. Evaluate with an empty list. argument = ImmutableList.of(); } arguments[i] = argument; i++; } return invokeNode(node, arguments); } 
private Object invokeNode ( Node node , Object [ ] arguments ) { Function function = functionRepository . getFunction ( node . getFunction ( ) ) ; return invokeFunction ( node , function , arguments ) ; } 
private Object invokeFunction ( Node node , Function function , Object [ ] arguments ) throws NodeRenderException { try { return function . invoke ( arguments ) ; 
public boolean containsPoint ( Point point ) { if ( ! isVisible ( ) ) return false ; return getBounds ( ) . contains ( point ) ; } 
private nodebox . graphics . Point pointForEvent ( MouseEvent e ) { return new nodebox . graphics . Point ( e . getX ( ) , e . getY ( ) ) ; } 
public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; Draw background g2.setColor(getBackground()); g2.fill(g.getClipBounds()); paintObjects(g2); paintHandle(g2); paintPoints(g2); paintPointNumbers(g2); paintOrigin(g2); } 
public void paintObjects ( Graphics2D g ) { if ( currentVisualizer ! = null ) currentVisualizer . draw ( g , outputValues ) ; 
private void paintPoints ( Graphics2D g ) { if ( showPoints & & IGeometry . class . isAssignableFrom ( valuesClass ) ) { TODO Create a dynamic iterator that combines all output values into one flat sequence. 
private void paintPointNumbers ( Graphics2D g ) { if ( ! showPointNumbers ) return ; g . setFont ( Theme . SMALL_MONO_FONT ) ; g . setColor ( Color . BLUE ) ; int index = 0 ; if ( IGeometry . class . isAssignableFrom ( valuesClass ) ) { for ( Object o : outputValues ) { 
private void paintPointNumber ( Graphics2D g , nodebox . graphics . Point pt , int number ) { if ( pt . isOnCurve ( ) ) { g . setColor ( Color . BLUE ) ; } else { g . setColor ( Color . RED ) ; } g . drawString ( number + " " , ( int ) ( pt . x + 3 ) , ( int ) ( pt . y - 2 ) ) ; } 
public void paintOrigin ( Graphics2D g ) { Draw the origin. Point2D origin = new Point2D.Double(0, 0); int x = (int) Math.round(origin.getX()); int y = (int) Math.round(origin.getY()); if (showOrigin) { g.setColor(Color.DARK_GRAY); 
public void paintHandle ( Graphics2D g ) { if ( hasVisibleHandle ( ) ) { Create a canvas with a transparent background. 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { showPopup ( e ) ; 
public void mouseReleased ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { showPopup ( e ) ; 
public void showPopup ( MouseEvent e ) { if ( ! e . isPopupTrigger ( ) ) return ; viewerMenu . show ( Viewer . this , e . getX ( ) , e . getY ( ) ) ; } 
private void initEventHandlers ( ) { setFocusable ( true ) ; This is disabled so we can detect the tab key. setFocusTraversalKeysEnabled(false); addKeyListener(this); addMouseListener(this); addMouseMotionListener(this); addFocusListener(this); } 
public void focusLost ( FocusEvent focusEvent ) { isShiftPressed = false ; isAltPressed = false ; } 
public boolean isDragTrigger ( MouseEvent e ) { return isSpacePressed ( ) ; } 
public Point2D inverseViewTransformPoint ( Point p ) { Point2D pt = new Point2D . Double ( p . getX ( ) , p . getY ( ) ) ; return getInverseViewTransform ( ) . transform ( pt , null ) ; } 
public void zoom ( double scaleDelta , double x , double y ) { if ( ! isVisible ( ) ) return ; double currentScale = getViewScale ( ) ; double newScale = currentScale * scaleDelta ; if ( newScale < minZoom ) { scaleDelta = minZoom / viewScale ; } else if ( newScale > maxZoom ) { scaleDelta = maxZoom / viewScale ; } double vx = viewX - ( x - viewX ) * ( scaleDelta - 1 ) ; double vy = viewY - ( y - viewY ) * ( scaleDelta - 1 ) ; setViewTransform ( vx , vy , viewScale * scaleDelta ) ; repaint ( ) ; } 
public void keyPressed ( KeyEvent e ) { int keyCode = e . getKeyCode ( ) ; if ( keyCode = = KeyEvent . VK_SPACE ) { isSpacePressed = true ; 
public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) return ; If the space bar and mouse is pressed, we're getting ready to pan the view. if (isSpacePressed) { When panning the view use the original mouse point, not the one affected by the view transform. 
public void mouseReleased ( MouseEvent e ) { isPanning = false ; } 
public void mouseEntered ( MouseEvent e ) { grabFocus ( ) ; } 
public void mouseDragged ( MouseEvent e ) { if ( isPanning ( ) ) { When panning the view use the original mouse point, not the one affected by the view transform. 
public void mouseWheelMoved ( MouseWheelEvent e ) { double scaleDelta = 1.0 - ( e . getWheelRotation ( ) / 10.0 ) ; zoom ( scaleDelta , e . getX ( ) , e . getY ( ) ) ; } 
public void focusLost ( FocusEvent e ) { isSpacePressed = false ; isPanning = false ; setCursor ( defaultCursor ) ; } 
public void zoom ( double scaleDelta ) { super . zoom ( scaleDelta , getWidth ( ) / 2 , getHeight ( ) / 2 ) ; } 
private nodebox . graphics . Point pointForEvent ( MouseEvent e ) { Point2D pt = inverseViewTransformPoint ( e . getPoint ( ) ) ; return new nodebox . graphics . Point ( pt ) ; } 
public void mouseDragged ( MouseEvent e ) { We register the mouse drag as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (isPanning()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); 
public void paintComponent ( Graphics g ) { if ( ! viewPositioned ) { setViewPosition ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; viewPositioned = true ; } Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; Draw background g2.setColor(getBackground()); g2.fill(g.getClipBounds()); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(getViewTransform()); paintObjects(g2); paintHandle(g2); paintPoints(g2); paintPointNumbers(g2); Restore original transform g2.setClip(null); g2.setTransform(originalTransform); paintOrigin(g2); } 
public void paintOrigin ( Graphics2D g ) { if ( showOrigin ) { int x = ( int ) Math . round ( getViewX ( ) ) ; 
public static void sendOSC ( String address , long port , String route , Iterable < Double > iterable ) { OscMessage message = new OscMessage ( route ) ; Iterator iterator = iterable . iterator ( ) ; while ( iterator . hasNext ( ) ) { message . add ( ( ( Double ) iterator . next ( ) ) . floatValue ( ) ) ; } UdpClient c = new UdpClient ( address , ( int ) port ) ; c . send ( message . getBytes ( ) ) ; 
private void lookForLibraries ( ) { NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary realTimeLibrary = NodeLibrary . load ( new File ( " libraries/realtime/realtime.ndbx " ) , NodeRepository . of ( ) ) ; systemRepository = NodeRepository . of ( mathLibrary , stringLibrary , colorLibrary , listLibrary , dataLibrary , corevectorLibrary , realTimeLibrary ) ; 
public static void sendOSC ( String ipAddress , long port , String oscAddress , Iterable < Double > oscArguments ) { OscMessage message = new OscMessage ( oscAddress ) ; Iterator iterator = oscArguments . iterator ( ) ; while ( iterator . hasNext ( ) ) { message . add ( ( ( Double ) iterator . next ( ) ) . floatValue ( ) ) ; } UdpClient c = new UdpClient ( ipAddress , ( int ) port ) ; c . send ( message . getBytes ( ) ) ; } 
public void oscEvent ( OscMessage m ) { ImmutableList < Object > arguments = ImmutableList . copyOf ( m . arguments ( ) ) ; oscMessages . put ( m . addrPattern ( ) , arguments ) ; System . out . println ( " OSC " + m . addrPattern ( ) + " " + arguments ) ; } 
public void run ( ) { ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewerPane . getViewer ( ) . getLastMousePosition ( ) , " osc.messages " , oscMessages , " osc.cache " , new HashSet < String > ( ) ) ; final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame , data , renderResults ) ; Throwable renderException = null ; startRendering ( context ) ; List < ? > results = null ; try { results = context . renderNode ( renderNetwork ) ; renderResults = context . getRenderResults ( ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); Set<String> oscCache = (Set<String>) context.getData().get("osc.cache"); Map<String,List<Object>> oscCachedMessages = new HashMap<String,List<Object>>(); for (String key : oscCache) { if (oscMessages.containsKey(key)) oscCachedMessages.put(key, oscMessages.get(key)); } oscMessages = oscCachedMessages; if (renderException == null) { finishedRendering(renderNetwork, results); 
public void run ( ) { ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewerPane . getViewer ( ) . getLastMousePosition ( ) , " osc.messages " , oscMessages , " osc.cache " , new HashSet < String > ( ) ) ; final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame , data , renderResults ) ; Throwable renderException = null ; startRendering ( context ) ; List < ? > results = null ; try { results = context . renderNode ( renderNetwork ) ; context . renderAlwaysRenderedNodes ( renderNetwork ) ; renderResults = context . getRenderResults ( ) ; } catch ( NodeRenderException e ) { LOG . log ( Level . WARNING , " Error while processing " , e ) ; renderException = e ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Other error while processing " , e ) ; renderException = e ; } We finished rendering so set the renderNetwork flag off. isRendering.set(false); Set<String> oscCache = (Set<String>) context.getData().get("osc.cache"); Map<String,List<Object>> oscCachedMessages = new HashMap<String,List<Object>>(); for (String key : oscCache) { if (oscMessages.containsKey(key)) oscCachedMessages.put(key, oscMessages.get(key)); } oscMessages = oscCachedMessages; if (renderException == null) { finishedRendering(renderNetwork, results); 
public boolean isAlwaysRendered ( ) { return isAlwaysRendered ; } 
public Node withAlwaysRenderedSet ( boolean alwaysRendered ) { return newNodeWithAttribute ( Attribute . ALWAYS_RENDERED , alwaysRendered ) ; } 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String category = this . category ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; boolean isNetwork = this . isNetwork ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; boolean alwaysRendered = this . isAlwaysRendered ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case CATEGORY : category = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case IS_NETWORK : isNetwork = ( Boolean ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; case ALWAYS_RENDERED : alwaysRendered = ( Boolean ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT or NETWORK, make it the prototype. if (this == ROOT || this == NETWORK) { prototype = this; } The name of a node can never be "node" or "network". if (name.equals("node")) name = "node1"; else if (name.equals("network")) name = "network1"; return new Node(prototype, name, category, description, image, function, position, inputs, outputType, outputRange, isNetwork, children, renderedChildName, connections, handle, alwaysRendered); 
public int hashCode ( ) { return Objects . hashCode ( prototype , name , category , description , image , function , position , inputs , outputType , outputRange , isNetwork , children , renderedChildName , connections , handle , isAlwaysRendered ) ; 
private Object invokeNode ( Node node , Map < Port , ? > argumentMap ) { List < Port > inputs = node . getInputs ( ) ; Object [ ] arguments = new Object [ inputs . size ( ) ] ; int i = 0 ; for ( Port port : inputs ) { Object argument ; if ( argumentMap . containsKey ( port ) ) { argument = argumentMap . get ( port ) ; } else if ( port . hasValueRange ( ) ) { argument = getPortValue ( node , port ) ; } else { The port expects a list but nothing is connected. Evaluate with an empty list. argument = ImmutableList.of(); } arguments[i] = argument; i++; } return invokeNode(node, arguments); } 
private static Map < String , String > parseNodeAttributes ( XMLStreamReader reader ) throws XMLStreamException { Map < String , String > attributeMap = new HashMap < String , String > ( ) ; String [ ] attributes = { " prototype " , " name " , " category " , " description " , " image " , " function " , " outputType " , " outputRange " , " position " , " renderedChild " , " handle " , " alwaysRendered " } ; for ( String attribute : attributes ) parseNodeAttribute ( reader , attributeMap , attribute ) ; return attributeMap ; } 
private static Node createNode ( Map < String , String > attributeMap , Node extendFromNode , Node parent , NodeRepository nodeRepository ) { String prototypeId = attributeMap . get ( " prototype " ) ; String name = attributeMap . get ( " name " ) ; String category = attributeMap . get ( " category " ) ; String description = attributeMap . get ( " description " ) ; String image = attributeMap . get ( " image " ) ; String function = attributeMap . get ( " function " ) ; String outputType = attributeMap . get ( " outputType " ) ; String outputRange = attributeMap . get ( " outputRange " ) ; String position = attributeMap . get ( " position " ) ; String handle = attributeMap . get ( " handle " ) ; String alwaysRendered = attributeMap . get ( " alwaysRendered " ) ; Node prototype = prototypeId = = null ? extendFromNode : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) return null ; Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( category ! = null ) node = node . withCategory ( category ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputType ! = null ) node = node . withOutputType ( outputType ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; if ( alwaysRendered ! = null ) node = node . withAlwaysRenderedSet ( Boolean . parseBoolean ( alwaysRendered ) ) ; return node ; } 
private void lookForLibraries ( ) { NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary deviceLibrary = NodeLibrary . load ( new File ( " libraries/device/device.ndbx " ) , NodeRepository . of ( ) ) ; systemRepository = NodeRepository . of ( mathLibrary , stringLibrary , colorLibrary , listLibrary , dataLibrary , corevectorLibrary , deviceLibrary ) ; 
public void requestRender ( ) { If we're already rendering, request the next renderNetwork. if (isRendering.compareAndSet(false, true)) { If we're not rendering, start rendering. 
protected List < ? > doInBackground ( ) throws Exception { final NodeContext context = new NodeContext ( renderLibrary , getFunctionRepository ( ) , frame ) ; return context . renderNode ( renderNetwork ) ; } 
public void run ( ) { requestRender ( ) ; } 
public void oscEvent ( OscMessage m ) { ImmutableList < Object > arguments = ImmutableList . copyOf ( m . arguments ( ) ) ; oscMessages . put ( m . addrPattern ( ) , arguments ) ; } 
private static int randomOSCPort ( ) { return 1024 + ( int ) Math . round ( Math . random ( ) * 10000 ) ; } 
protected List < ? > doInBackground ( ) throws Exception { List < ? > results = context . renderNode ( renderNetwork ) ; context . renderAlwaysRenderedNodes ( renderNetwork ) ; renderResults = context . getRenderResults ( ) ; return results ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final ExportViewer viewer = new ExportViewer ( ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame , ImmutableMap . < String , Object > of ( ) , renderResults ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; viewer . setVisible ( true ) ; } 
public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; 
public void zoomView ( double scaleDelta ) { PointerInfo a = MouseInfo . getPointerInfo ( ) ; Point point = new Point ( a . getLocation ( ) ) ; for ( Zoom zoomListener : zoomListeners ) { if ( zoomListener . containsPoint ( point ) ) 
public void resetViewTransform ( ) { Point2D position = currentVisualizer . getOffset ( outputValues , getSize ( ) ) ; setViewTransform ( position . getX ( ) , position . getY ( ) , 1 ) ; } 
public void resetViewTransform ( ) { setViewTransform ( 0 , 0 , 1 ) ; } 
public void zoom ( double scaleDelta , double x , double y ) { if ( ! isVisible ( ) ) return ; double currentScale = getViewScale ( ) ; double newScale = currentScale * scaleDelta ; if ( newScale < minZoom ) { scaleDelta = minZoom / viewScale ; } else if ( newScale > maxZoom ) { scaleDelta = maxZoom / viewScale ; } double vx = viewX - ( x - viewX ) * ( scaleDelta - 1 ) ; double vy = viewY - ( y - viewY ) * ( scaleDelta - 1 ) ; setViewTransform ( vx , vy , viewScale * scaleDelta ) ; } 
private void lookForLibraries ( ) { NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary networkLibrary = NodeLibrary . load ( new File ( " libraries/network/network.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; systemRepository = NodeRepository . of ( mathLibrary , stringLibrary , colorLibrary , listLibrary , dataLibrary , networkLibrary , corevectorLibrary ) ; 
public static String httpGet ( final String url ) { synchronized ( url ) { try { 
public String call ( ) throws Exception { return _httpGet ( url ) ; } 
private static String _httpGet ( String url ) { HttpClient client = new DefaultHttpClient ( ) ; HttpGet request = new HttpGet ( url ) ; try { HttpResponse response = client . execute ( request ) ; 
public static List < Map < String , Object > > receiveOSC ( String oscAddressPrefix , NodeContext context ) { Map < String , List < Object > > oscMessages = ( Map < String , List < Object > > ) context . getData ( ) . get ( " osc.messages " ) ; if ( oscMessages = = null ) return ImmutableList . of ( ) ; if ( oscAddressPrefix . isEmpty ( ) ) return ImmutableList . of ( ) ; Pattern userPattern = Pattern . compile ( " (<[a-z0-9-_]+>)+ " ) ; Matcher upMatcher = userPattern . matcher ( oscAddressPrefix ) ; ImmutableList . Builder < String > builder = ImmutableList . builder ( ) ; while ( upMatcher . find ( ) ) { String s = upMatcher . group ( 0 ) ; if ( s . startsWith ( " < " ) & & s . endsWith ( " > " ) ) s = s . substring ( 1 , s . length ( ) - 1 ) ; builder . add ( s ) ; } ImmutableList < String > messageData = builder . build ( ) ; String convertedAddressPrefix = upMatcher . replaceAll ( " (XXXPLHXXX) " ) ; if ( ! convertedAddressPrefix . endsWith ( " * " ) ) convertedAddressPrefix = convertedAddressPrefix + " * " ; convertedAddressPrefix = convertedAddressPrefix . replaceAll ( " \\ * " , " .*? " ) ; convertedAddressPrefix = " ^ " + convertedAddressPrefix . replaceAll ( " (XXXPLHXXX) " , " [^ \\ /]* " ) + " $ " ; Pattern lookupPattern = Pattern . compile ( convertedAddressPrefix ) ; ImmutableList . Builder < Map < String , Object > > b = ImmutableList . builder ( ) ; for ( Map . Entry < String , List < Object > > e : oscMessages . entrySet ( ) ) { Matcher lpMatcher = lookupPattern . matcher ( e . getKey ( ) ) ; if ( lpMatcher . find ( ) ) { ImmutableMap . Builder < String , Object > mb = ImmutableMap . builder ( ) ; mb . put ( " address " , e . getKey ( ) ) ; for ( int i = 0 ; i < lpMatcher . groupCount ( ) ; i + + ) mb . put ( messageData . get ( i ) , lpMatcher . group ( i + 1 ) ) ; int i = 1 ; for ( Object o : e . getValue ( ) ) mb . put ( " col " + i + + , o ) ; b . add ( mb . build ( ) ) ; } } return b . build ( ) ; } 
public static Map < String , Object > httpGet ( final String url , final long timeoutSeconds ) { synchronized ( url ) { if ( responseCache . containsKey ( url ) ) { 
private static Map < String , Object > _httpGet ( String url ) { HttpClient client = new DefaultHttpClient ( ) ; HttpGet request = new HttpGet ( url ) ; try { HttpResponse response = client . execute ( request ) ; 
private static Map < String , Object > emptyResponse ( int statusCode ) { return ImmutableMap . < String , Object > of ( " text " , " " , 
private static long nowSeconds ( ) { return System . currentTimeMillis ( ) / 1000 ; } 
public static List < Map < String , Object > > receiveOSC ( String oscAddressPrefix , NodeContext context ) { Map < String , List < Object > > oscMessages = ( Map < String , List < Object > > ) context . getData ( ) . get ( " osc.messages " ) ; if ( oscMessages = = null ) return ImmutableList . of ( ) ; if ( oscAddressPrefix . isEmpty ( ) ) return ImmutableList . of ( ) ; Pattern userPattern = Pattern . compile ( " (<[a-z0-9-_]+?(?::[ifs]|:string|:int|:float)?>)+ " ) ; Matcher upMatcher = userPattern . matcher ( oscAddressPrefix ) ; Map < String , String > itemTypeMap = new HashMap < String , String > ( ) ; ImmutableList . Builder < String > builder = ImmutableList . builder ( ) ; while ( upMatcher . find ( ) ) { String s = upMatcher . group ( 0 ) ; if ( s . startsWith ( " < " ) & & s . endsWith ( " > " ) ) s = s . substring ( 1 , s . length ( ) - 1 ) ; String [ ] tokens = s . split ( " : " ) ; if ( tokens . length = = 2 ) { s = tokens [ 0 ] ; itemTypeMap . put ( s , tokens [ 1 ] . substring ( 0 , 1 ) ) ; } else itemTypeMap . put ( s , " s " ) ; builder . add ( s ) ; } ImmutableList < String > messageData = builder . build ( ) ; String convertedAddressPrefix = upMatcher . replaceAll ( " (XXXPLHXXX) " ) ; if ( ! convertedAddressPrefix . endsWith ( " * " ) ) convertedAddressPrefix = convertedAddressPrefix + " * " ; convertedAddressPrefix = convertedAddressPrefix . replaceAll ( " \\ * " , " .*? " ) ; convertedAddressPrefix = " ^ " + convertedAddressPrefix . replaceAll ( " (XXXPLHXXX) " , " [^ \\ /]* " ) + " $ " ; Pattern lookupPattern = Pattern . compile ( convertedAddressPrefix ) ; ImmutableList . Builder < Map < String , Object > > b = ImmutableList . builder ( ) ; for ( Map . Entry < String , List < Object > > e : oscMessages . entrySet ( ) ) { Matcher lpMatcher = lookupPattern . matcher ( e . getKey ( ) ) ; if ( lpMatcher . find ( ) ) { ImmutableMap . Builder < String , Object > mb = ImmutableMap . builder ( ) ; mb . put ( " address " , e . getKey ( ) ) ; for ( int i = 0 ; i < lpMatcher . groupCount ( ) ; i + + ) { String msg = messageData . get ( i ) ; String msgData = lpMatcher . group ( i + 1 ) ; if ( itemTypeMap . get ( msg ) . equals ( " s " ) ) { mb . put ( msg , msgData ) ; } else if ( itemTypeMap . get ( msg ) . equals ( " i " ) ) { try { mb . put ( msg , Integer . parseInt ( msgData ) ) ; } catch ( NumberFormatException nfe ) { mb . put ( msg , 0 ) ; } } else if ( itemTypeMap . get ( msg ) . equals ( " f " ) ) { try { mb . put ( msg , Double . parseDouble ( msgData ) ) ; } catch ( NumberFormatException nfe ) { mb . put ( msg , 0.0d ) ; } } } int i = 1 ; for ( Object o : e . getValue ( ) ) mb . put ( " col " + i + + , o ) ; b . add ( mb . build ( ) ) ; } } return b . build ( ) ; } 
protected JTextComponent createField ( ) { JPasswordField field = new JPasswordField ( ) ; field . putClientProperty ( " JComponent.sizeVariant " , " small " ) ; field . setFont ( Theme . SMALL_BOLD_FONT ) ; field . addActionListener ( this ) ; field . addFocusListener ( new FocusAdapter ( ) { public void focusLost ( FocusEvent e ) { commitTextFieldValue ( ) ; } } ) ; return field ; } 
protected void commitTextFieldValue ( ) { setPortValue ( field . getText ( ) ) ; } 
protected JTextComponent createField ( ) { JTextField textField = new JTextField ( ) ; textField . putClientProperty ( " JComponent.sizeVariant " , " small " ) ; textField . setFont ( Theme . SMALL_BOLD_FONT ) ; textField . addActionListener ( this ) ; textField . addFocusListener ( new FocusAdapter ( ) { public void focusLost ( FocusEvent e ) { commitTextFieldValue ( ) ; } } ) ; return textField ; } 
public static Map < String , Object > httpGet ( final String url , final String username , final String password , final long timeoutSeconds ) { Integer cacheKey = Objects . hashCode ( url , username , password ) ; synchronized ( cacheKey ) { if ( responseCache . containsKey ( cacheKey ) ) { 
private static Map < String , Object > _httpGet ( final String url , final String username , final String password ) { HttpGet request = new HttpGet ( url ) ; if ( username ! = null & & ! username . trim ( ) . isEmpty ( ) ) { UsernamePasswordCredentials credentials = new UsernamePasswordCredentials ( username , password ) ; BasicScheme scheme = new BasicScheme ( ) ; Header authorizationHeader ; try { authorizationHeader = scheme . authenticate ( credentials , request , new BasicHttpContext ( ) ) ; } catch ( AuthenticationException e ) { throw new RuntimeException ( e ) ; } request . addHeader ( authorizationHeader ) ; } try { DefaultHttpClient client = new DefaultHttpClient ( ) ; 
public static Map < String , Object > httpGet ( final String url , final String username , final String password , final long refreshTimeSeconds ) { Integer cacheKey = Objects . hashCode ( url , username , password ) ; synchronized ( cacheKey ) { if ( responseCache . containsKey ( cacheKey ) ) { 
private void applyPreferences ( ) { Preferences preferences = Preferences . userNodeForPackage ( Application . class ) ; ENABLE_DEVICE_SUPPORT = Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_DEVICE_SUPPORT , " false " ) ) ; } 
private void lookForLibraries ( ) { NodeLibrary mathLibrary = NodeLibrary . load ( new File ( " libraries/math/math.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary stringLibrary = NodeLibrary . load ( new File ( " libraries/string/string.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary colorLibrary = NodeLibrary . load ( new File ( " libraries/color/color.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary dataLibrary = NodeLibrary . load ( new File ( " libraries/data/data.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; if ( Application . ENABLE_DEVICE_SUPPORT ) { NodeLibrary deviceLibrary = NodeLibrary . load ( new File ( " libraries/device/device.ndbx " ) , NodeRepository . of ( ) ) ; 
public void oscEvent ( OscMessage m ) { ImmutableList < Object > arguments = ImmutableList . copyOf ( m . arguments ( ) ) ; oscMessages . put ( m . addrPattern ( ) , arguments ) ; } 
private boolean isDeviceSupportEnabled ( ) { return Boolean . valueOf ( preferences . get ( application . PREFERENCE_ENABLE_DEVICE_SUPPORT , " false " ) ) ; } 
private void readPreferences ( ) { enableDeviceSupportCheck . setSelected ( isDeviceSupportEnabled ( ) ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { boolean changed = false ; if ( isDeviceSupportEnabled ( ) ! = enableDeviceSupportCheck . isSelected ( ) ) { setEnableDeviceSupport ( enableDeviceSupportCheck . isSelected ( ) ) ; changed = true ; } if ( changed ) { JOptionPane . showMessageDialog ( this , " Please restart NodeBox for the changes to take effect. " ) ; try { preferences . flush ( ) ; } catch ( BackingStoreException e ) { throw new RuntimeException ( e ) ; } } dispose ( ) ; } 
public static Iterable < Object > queryJSON ( final Object json , final String query ) { if ( json instanceof Map ) { Map < ? , ? > requestMap = ( Map < ? , ? > ) json ; 
private void lookForLibraries ( ) { List < NodeLibrary > libraries = new ArrayList < NodeLibrary > ( ) ; libraries . add ( systemLibrary ( " math " ) ) ; libraries . add ( systemLibrary ( " string " ) ) ; libraries . add ( systemLibrary ( " color " ) ) ; libraries . add ( systemLibrary ( " list " ) ) ; libraries . add ( systemLibrary ( " data " ) ) ; libraries . add ( systemLibrary ( " corevector " ) ) ; if ( Application . ENABLE_DEVICE_SUPPORT ) { libraries . add ( systemLibrary ( " device " ) ) ; } systemRepository = NodeRepository . of ( libraries . toArray ( new NodeLibrary [ ] { } ) ) ; } 
private NodeLibrary systemLibrary ( String name ) { String fileName = String . format ( " libraries/%s/%s.ndbx " , name , name ) ; return NodeLibrary . load ( new File ( fileName ) , NodeRepository . of ( ) ) ; } 
private void readPreferences ( ) { enableDeviceSupportCheck . setSelected ( isDeviceSupportEnabled ( ) ) ; } 
private void initApplication ( ) { installDefaultExceptionHandler ( ) ; setNodeBoxVersion ( ) ; createNodeBoxDataDirectories ( ) ; applyPreferences ( ) ; registerForMacOSXEvents ( ) ; initPython ( ) ; } 
public void uncaughtException ( Thread , final Throwable e ) { SwingUtilities . invokeLater ( new Runnable ( ) { @Override 
public void run ( ) { ExceptionDialog d = new ExceptionDialog ( null , e ) ; d . setVisible ( true ) ; } 
private void applyPreferences ( ) { Preferences preferences = Preferences . userNodeForPackage ( Application . class ) ; ENABLE_DEVICE_SUPPORT = Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_DEVICE_SUPPORT , " false " ) ) ; ENABLE_NETWORK_SUPPORT = Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_NETWORK_SUPPORT , " false " ) ) ; } 
private void lookForLibraries ( ) { List < NodeLibrary > libraries = new ArrayList < NodeLibrary > ( ) ; libraries . add ( systemLibrary ( " math " ) ) ; libraries . add ( systemLibrary ( " string " ) ) ; libraries . add ( systemLibrary ( " color " ) ) ; libraries . add ( systemLibrary ( " list " ) ) ; libraries . add ( systemLibrary ( " data " ) ) ; libraries . add ( systemLibrary ( " corevector " ) ) ; if ( Application . ENABLE_DEVICE_SUPPORT ) { libraries . add ( systemLibrary ( " device " ) ) ; } if ( Application . ENABLE_NETWORK_SUPPORT ) { libraries . add ( systemLibrary ( " network " ) ) ; } systemRepository = NodeRepository . of ( libraries . toArray ( new NodeLibrary [ ] { } ) ) ; } 
public static UpgradeStringResult upgrade1to2 ( String inputXml ) throws LoadException { Version 2: Vertical node networks 1. Rotate all nodes 90 degrees by reversing X and Y positions. 2. Convert from pixel units to grid units by dividing by GRID_CELL_SIZE. final int GRID_CELL_SIZE = 48; UpgradeOp verticalNodesOp = new UpgradeOp() { @Override public void apply(Element e) { if (!e.getTagName().equals("node")) return; Attr position = e.getAttributeNode("position"); if (position == null) return; Point pt = Point.valueOf(position.getValue()); Point reversedPoint = new Point(pt.y, pt.x); Point gridPoint = new Point(Math.round(reversedPoint.x / GRID_CELL_SIZE) * 3, Math.round(reversedPoint.y / GRID_CELL_SIZE)); position.setValue(String.valueOf(gridPoint)); } @Override public void end(Element root) { addWarning("Nodes have been rotated. Your network will look different."); } }; return transformXml(inputXml, "2", verticalNodesOp); } 
public void apply ( Element e ) { if ( ! e . getTagName ( ) . equals ( " node " ) ) return ; Attr position = e . getAttributeNode ( " position " ) ; if ( position = = null ) return ; Point pt = Point . valueOf ( position . getValue ( ) ) ; Point reversedPoint = new Point ( pt . y , pt . x ) ; Point gridPoint = new Point ( Math . round ( reversedPoint . x / GRID_CELL_SIZE ) * 3 , Math . round ( reversedPoint . y / GRID_CELL_SIZE ) ) ; position . setValue ( String . valueOf ( gridPoint ) ) ; } 
private static void renameRenderedChildReference ( Element element , String oldNodeName , String newNodeName ) { Attr renderedChildReference = element . getAttributeNode ( " renderedChild " ) ; if ( renderedChildReference = = null ) return ; String oldRenderedChild = renderedChildReference . getValue ( ) ; if ( oldRenderedChild . equals ( oldNodeName ) ) { if ( newNodeName = = null | | newNodeName . length ( ) = = 0 ) 
private static void renamePortReference ( List < Element > elements , String attributeName , String oldNodeName , String newNodeName ) { for ( Element c : elements ) { Attr portReference = c . getAttributeNode ( attributeName ) ; 
private static void renamePortInNodeList ( List < Element > elements , String attributeName , String nodeName , String oldPortName , String newPortName ) { for ( Element c : elements ) { Attr portReference = c . getAttributeNode ( attributeName ) ; 
private static void renameNodeReference ( List < Element > elements , String attributeName , String oldNodeName , String newNodeName ) { for ( Element c : elements ) { Attr nodeRef = c . getAttributeNode ( attributeName ) ; 
private static void removeConnection ( Element parent , String child , String input ) { for ( Element conn : childElementsWithName ( parent , " conn " ) ) { String inputPort = conn . getAttribute ( " input " ) ; 
private static void removeConnections ( Element parent , String child ) { for ( Element conn : childElementsWithName ( parent , " conn " ) ) { String inputPort = conn . getAttribute ( " input " ) ; 
private static UpgradeStringResult transformXml ( String xml , String newFormatVersion , UpgradeOp . . . ops ) { try { 
private static void transformXmlRecursive ( Element e , UpgradeOp op ) { op . apply ( e ) ; for ( Element child : childElements ( e ) ) { transformXmlRecursive ( child , op ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , oldPrototype ) ) { Attr prototype = e . getAttributeNode ( " prototype " ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , prototype ) ) { e . setAttribute ( attributeName , attributeValue ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , nodePrototype ) ) { String nodeName = e . getAttribute ( " name " ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , nodePrototype ) ) { Element port = e . getOwnerDocument ( ) . createElement ( " port " ) ; 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , nodePrototype ) ) { Element parent = ( Element ) e . getParentNode ( ) ; 
public void testCallReceiveAll ( ) { assertEquals ( ImmutableList . of ( ImmutableMap . of ( " address " , " /2/multifader/11 " , " Column1 " , 0.5 , " Column2 " , 0 , " Column3 " , 0 ) , 
public void testCallReceiveSpecific ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader/8 " ) ; List < Map < String , Object > > expectedResult = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " Column " , 0.9 ) ) ; assertEquals ( expectedResult , context . renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader/8* " ) ; assertEquals ( expectedResult , context . renderNode ( oscReceiveNode2 ) ) ; } 
public void testCallReceivePrefix ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader " ) ; List < Map < String , Object > > expectedResult = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " Column " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " Column " , 0.9 ) ) ; assertEquals ( expectedResult , context . renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader* " ) ; assertEquals ( expectedResult , context . renderNode ( oscReceiveNode2 ) ) ; } 
public void testCallReceiveWildcard ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multi* " ) ; List < Map < String , Object > > expectedResult = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " Column1 " , 0.5 , " Column2 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " Column1 " , 0.9 , " Column2 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/2/15 " , " Column1 " , 0.1 , " Column2 " , 0.2 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/4/10 " , " Column1 " , 0.3 , " Column2 " , 0.6 ) ) ; assertEquals ( expectedResult , context . renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /2/*lti* " ) ; assertEquals ( expectedResult , context . renderNode ( oscReceiveNode2 ) ) ; Node oscReceiveNode3 = oscReceiveNode . withInputValue ( " prefix " , " *multi " ) ; assertEquals ( expectedResult , context . renderNode ( oscReceiveNode3 ) ) ; Node oscReceiveNode4 = oscReceiveNode . withInputValue ( " prefix " , " multi* " ) ; assertEquals ( ImmutableList . of ( ) , context . renderNode ( oscReceiveNode4 ) ) ; } 
public void testCallReceiveMessagePattern ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multitoggle/<x>/<y> " ) ; List < Map < String , Object > > expectedResult = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/2/15 " , " x " , " 2 " , " y " , " 15 " , " Column1 " , 0.1 , " Column2 " , 0.2 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/4/10 " , " x " , " 4 " , " y " , " 10 " , " Column1 " , 0.3 , " Column2 " , 0.6 ) ) ; assertEquals ( expectedResult , context . renderNode ( oscReceiveNode1 ) ) ; } 
public void testCallReceiveMessageTypedPattern ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid>/multifader/<faderid> " ) ; List < Map < String , Object > > expectedResult1 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " pageid " , " 2 " , " faderid " , " 11 " , " Column " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " pageid " , " 2 " , " faderid " , " 8 " , " Column " , 0.9 ) ) ; assertEquals ( expectedResult1 , context . renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid:string>/multifader/<faderid:s> " ) ; assertEquals ( expectedResult1 , context . renderNode ( oscReceiveNode2 ) ) ; Node oscReceiveNode3 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid:int>/multifader/<faderid:i> " ) ; List < Map < String , Object > > expectedResult3 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " pageid " , 2 , " faderid " , 11 , " Column " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " pageid " , 2 , " faderid " , 8 , " Column " , 0.9 ) ) ; assertEquals ( expectedResult3 , context . renderNode ( oscReceiveNode3 ) ) ; Node oscReceiveNode4 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid:f>/multifader/<faderid:float> " ) ; List < Map < String , Object > > expectedResult4 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " pageid " , 2.0 , " faderid " , 11.0 , " Column " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " pageid " , 2.0 , " faderid " , 8.0 , " Column " , 0.9 ) ) ; assertEquals ( expectedResult4 , context . renderNode ( oscReceiveNode4 ) ) ; Node oscReceiveNode5 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid:l>/multifader/<faderid> " ) ; assertEquals ( ImmutableList . of ( ) , context . renderNode ( oscReceiveNode5 ) ) ; } 
public void testCallReceiveAndSortData ( ) { Node oscReceiveNode1 = oscReceiveNode . withName ( " osc_receive1 " ) . withInputValue ( " prefix " , " <itemid:i> " ) ; Node net2 = Node . NETWORK . withChildAdded ( oscReceiveNode2 ) . withChildAdded ( sortNode1 ) . withRenderedChildName ( " sort1 " ) . connect ( " osc_receive2 " , " sort1 " , " list " ) ; List < Map < String , Object > > expectedResult2 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /r/g/b/20 " , " itemid " , 0 , " Column1 " , 0.15 , " Column2 " , 0.35 , " Column3 " , 0.77 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/2/15 " , " itemid " , 2 , " Column1 " , 0.1 , " Column2 " , 0.2 , " Column3 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/4/10 " , " itemid " , 4 , " Column1 " , 0.3 , " Column2 " , 0.6 , " Column3 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " itemid " , 8 , " Column1 " , 0.9 , " Column2 " , 0 , " Column3 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " itemid " , 11 , " Column1 " , 0.5 , " Column2 " , 0 , " Column3 " , 0 ) ) ; assertEquals ( expectedResult2 , context . renderNode ( net2 ) ) ; } 
public void testCallReceiveArguments ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader* " ) . withInputValue ( " args " , " v " ) ; List < Map < String , Object > > expectedResult1 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " v " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " v " , 0.9 ) ) ; assertEquals ( expectedResult1 , context . renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /2/multitoggle* " ) . withInputValue ( " args " , " x,y " ) ; List < Map < String , Object > > expectedResult2 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/2/15 " , " x " , 0.1 , " y " , 0.2 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/4/10 " , " x " , 0.3 , " y " , 0.6 ) ) ; assertEquals ( expectedResult2 , context . renderNode ( oscReceiveNode2 ) ) ; assertEquals ( expectedResult2 , context . renderNode ( oscReceiveNode2 . withInputValue ( " args " , " x ,y " ) ) ) ; assertEquals ( expectedResult2 , context . renderNode ( oscReceiveNode2 . withInputValue ( " args " , " x, y " ) ) ) ; } 
private NodeContext createNodeContextWithData ( Map < String , Object > data ) { return new NodeContext ( testLibrary , null , 1 , data , ImmutableMap . < Node , List < ? > > of ( ) ) ; } 
private NodeContext createNodeContextWithOSCData ( Map < String , List < Object > > oscMessages ) { Map < String , Object > data = ImmutableMap . < String , Object > of ( " osc.messages " , oscMessages ) ; return createNodeContextWithData ( data ) ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final ExportViewer viewer = new ExportViewer ( ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; final ImmutableMap < String , ? > data = ImmutableMap . of ( " osc.messages " , oscMessages ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame , data , renderResults ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; viewer . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; viewer . setVisible ( true ) ; } 
public static Iterable < ? > queryJSON ( final Object json , final String query ) { if ( json instanceof Map ) { Map < ? , ? > requestMap = ( Map < ? , ? > ) json ; 
private void initEventHandlers ( ) { setFocusable ( true ) ; This is disabled so we can detect the tab key. setFocusTraversalKeysEnabled(false); addKeyListener(new KeyHandler()); MouseHandler mh = new MouseHandler(); addMouseListener(mh); addMouseMotionListener(mh); addFocusListener(new FocusHandler()); } 
public Point centerGridPoint ( ) { Point pt = pointToGridPoint ( new Point ( ( int ) ( getBounds ( ) . getWidth ( ) / 2 ) , ( int ) ( getBounds ( ) . getHeight ( ) / 2 ) ) ) ; return new Point ( ( int ) pt . getX ( ) - 1 , ( int ) pt . getY ( ) ) ; } 
public void keyPressed ( KeyEvent e ) { int keyCode = e . getKeyCode ( ) ; if ( keyCode = = KeyEvent . VK_SHIFT ) { isShiftPressed = true ; 
public void mouseMoved ( MouseEvent e ) { Point2D pt = inverseViewTransformPoint ( e . getPoint ( ) ) ; overOutput = getNodeWithOutputPortAt ( pt ) ; overInput = getInputPortAt ( pt ) ; It is probably very inefficient to repaint the view every time the mouse moves. repaint(); } 
public void focusLost ( FocusEvent focusEvent ) { isShiftPressed = false ; isAltPressed = false ; } 
public void run ( ) { SwingUtilities . getWindowAncestor ( ZoomableView . this ) . addWindowFocusListener ( fh ) ; } 
public void windowLostFocus ( WindowEvent e ) { isSpacePressed = false ; isPanning = false ; setCursor ( defaultCursor ) ; } 
public void windowGainedFocus ( WindowEvent e ) { } @Override public void focusGained ( FocusEvent e ) { } @Override public void focusLost ( FocusEvent e ) { isSpacePressed = false ; setCursor ( defaultCursor ) ; } } } 
public void focusGained ( FocusEvent e ) { } @Override public void focusLost ( FocusEvent e ) { isSpacePressed = false ; setCursor ( defaultCursor ) ; } } } 
public void focusLost ( FocusEvent e ) { isSpacePressed = false ; setCursor ( defaultCursor ) ; } 
public String objectToString ( Object o ) { String s = o = = null ? " <null> " : o . toString ( ) ; if ( s . length ( ) < = MAX_VALUE_LENGTH ) { return s ; 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final Viewer viewer = new Viewer ( this ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( 600 , 600 ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; final ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewer . getLastMousePosition ( ) , " osc.messages " , oscMessages ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame , data , renderResults ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < Object > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } 
private Rectangle dragSelectRect ( ) { if ( dragStartPoint = = null | | dragCurrentPoint = = null ) return new Rectangle ( ) ; int x0 = ( int ) dragStartPoint . getX ( ) ; int y0 = ( int ) dragStartPoint . getY ( ) ; int x1 = ( int ) dragCurrentPoint . getX ( ) ; int y1 = ( int ) dragCurrentPoint . getY ( ) ; int x = Math . min ( x0 , x1 ) ; int y = Math . min ( y0 , y1 ) ; int w = ( int ) Math . abs ( dragCurrentPoint . getX ( ) - dragStartPoint . getX ( ) ) ; int h = ( int ) Math . abs ( dragCurrentPoint . getY ( ) - dragStartPoint . getY ( ) ) ; return new Rectangle ( x , y , w , h ) ; } 
public boolean containsPoint ( Point point ) { return isVisible ( ) & & getBounds ( ) . contains ( point ) ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final Viewer viewer = new Viewer ( this ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( 600 , 600 ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; final ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewer . getLastMousePosition ( ) , " osc.messages " , oscMessages ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame , data , renderResults ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < ? > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
public void mouseDragged ( MouseEvent e ) { We register the mouse drag as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (isPanning()) return; if (hasVisibleHandle()) { getDocument().addEdit(HANDLE_UNDO_TEXT, HANDLE_UNDO_TYPE, activeNode); handle.mouseDragged(pointForEvent(e)); } lastMousePosition = pointForEvent(e); } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final Viewer viewer = new Viewer ( ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( 600 , 600 ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; final ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewer . getLastMousePosition ( ) , " osc.messages " , oscMessages ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , frame , data , renderResults ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < ? > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
public void resetViewTransform ( ) { Point2D position = currentVisualizer . getOffset ( outputValues , getSize ( ) ) ; setViewTransform ( position . getX ( ) , position . getY ( ) , 1 ) ; } 
public boolean hasVisibleHandle ( ) { if ( handle = = null ) return false ; if ( ! showHandle ) return false ; Don't show handles for LastResortVisualizer and ColorVisualizer. if (currentVisualizer instanceof LastResortVisualizer) return false; if (currentVisualizer instanceof ColorVisualizer) return false; return handle.isVisible(); } 
public void actionPerformed ( ActionEvent e ) { Component c = getDocument ( ) . getFocusOwner ( ) ; getDocument ( ) . undo ( ) ; updateUndoRedoState ( ) ; } 
public void update ( ) { Component c = getDocument ( ) . getFocusOwner ( ) ; if ( undoManager ! = null & & undoManager . canUndo ( ) ) { setEnabled ( true ) ; 
public void actionPerformed ( ActionEvent e ) { Component c = getDocument ( ) . getFocusOwner ( ) ; getDocument ( ) . redo ( ) ; updateUndoRedoState ( ) ; } 
public void update ( ) { Component c = getDocument ( ) . getFocusOwner ( ) ; if ( undoManager ! = null & & undoManager . canRedo ( ) ) { setEnabled ( true ) ; 
public Node groupIntoNetwork ( String parentPath , Iterable < Node > nodes ) { return groupIntoNetwork ( parentPath , nodes , " network " ) ; } 
public void paintComponent ( Graphics g ) { if ( ! viewPositioned ) { setViewPosition ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; viewPositioned = true ; } Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; Draw background g2.setColor(getBackground()); g2.fill(g.getClipBounds()); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(getViewTransform()); paintObjects(g2); paintHandle(g2); paintPoints(g2); paintPointNumbers(g2); Restore original transform g2.setClip(null); g2.setTransform(originalTransform); g2.setStroke(new BasicStroke(1)); paintOrigin(g2); } 
public void close ( ) { document . closeFullScreenWindow ( ) ; } 
public void renderFullScreen ( ) { if ( fullScreenFrame ! = null ) closeFullScreenWindow ( ) ; fullScreenFrame = new FullScreenFrame ( this ) ; fullScreenFrame . setVisible ( true ) ; fullScreenFrame . setOutputValues ( lastRenderResult ) ; } 
public void closeFullScreenWindow ( ) { if ( fullScreenFrame ! = null ) { fullScreenFrame . setVisible ( false ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { getDocument ( ) . renderFullScreen ( ) ; } 
public int hashCode ( ) { return Objects . hashCode ( network , node , argumentMap ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof NodeArguments ) ) return false ; final NodeArguments other = ( NodeArguments ) o ; return Objects . equal ( network , other . network ) & & Objects . equal ( node , other . node ) 
private void renameNode ( Node node ) { String s = JOptionPane . showInputDialog ( this , " New name: " , node . getName ( ) ) ; if ( s = = null | | s . length ( ) = = 0 ) return ; try { getDocument ( ) . setNodeName ( node , s ) ; 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; if ( node ! = null ) { renameNode ( node ) ; 
public void testStoreIntermediateResults ( ) { Node increase = Node . ROOT . withName ( " increase " ) . withFunction ( " side-effects/increaseAndCount " ) . withInputAdded ( Port . floatPort ( " counter " , 42.0 ) ) ; Node network = Node . NETWORK . withChildAdded ( addNode ) . withChildAdded ( increase ) . connect ( " increase " , " add " , " v1 " ) . connect ( " increase " , " add " , " v2 " ) ; SideEffects . reset ( ) ; assertResultsEqual ( network , addNode , 86.0 ) ; assertEquals ( 1L , SideEffects . theCounter ) ; } 
public int hashCode ( ) { return Objects . hashCode ( major , minor , revision ) ; } 
public void zoom ( double scaleDelta ) { super . zoom ( scaleDelta , getWidth ( ) / 2.0 , getHeight ( ) / 2.0 ) ; } 
public void paintComponent ( Graphics g ) { if ( ! viewPositioned ) { setViewPosition ( getWidth ( ) / 2.0 , getHeight ( ) / 2.0 ) ; viewPositioned = true ; } Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; Draw background g2.setColor(getBackground()); g2.fill(g.getClipBounds()); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(getViewTransform()); paintObjects(g2); paintHandle(g2); paintPoints(g2); paintPointNumbers(g2); Restore original transform g2.setClip(null); g2.setTransform(originalTransform); g2.setStroke(new BasicStroke(1)); paintOrigin(g2); } 
public static synchronized Map < String , Object > httpGet ( final String url , final String username , final String password , final long refreshTimeSeconds ) { Integer cacheKey = Objects . hashCode ( url , username , password ) ; if ( responseCache . containsKey ( cacheKey ) ) { Response r = responseCache . get ( cacheKey ) ; long timeNow = nowSeconds ( ) ; long timeFetched = r . timeFetched ; if ( ( timeNow - timeFetched ) < = refreshTimeSeconds ) { return r . response ; } } Map < String , Object > r = _httpGet ( url , username , password ) ; Response res = new Response ( nowSeconds ( ) , r ) ; responseCache . put ( cacheKey , res ) ; return r ; } 
public static Object lookup ( Object o , String key ) { if ( key = = null ) return null ; return nestedLookup ( o , DOT_SPLITTER . split ( key ) ) ; } 
public static Object nestedLookup ( Object o , Iterable < String > keys ) { for ( String key : keys ) { o = fastLookup ( o , key ) ; if ( o = = null ) { break ; } } return o ; } 
private static Object fastLookup ( Object o , String key ) { if ( o = = null | | key = = null ) return null ; if ( o instanceof Map ) { Map m = ( Map ) o ; 
public void testNestedLookup ( ) { Map < String , Integer > m = ImmutableMap . of ( " alpha " , 1 , " beta " , 2 , " gamma " , 3 ) ; Map < String , Map < String , Integer > > mm = ImmutableMap . of ( " greek " , m ) ; assertEquals ( 1 , lookup ( mm , " greek.alpha " ) ) ; assertEquals ( 2 , lookup ( mm , " greek.beta " ) ) ; assertNull ( lookup ( mm , " greek.xxx " ) ) ; assertNull ( lookup ( mm , " greek.alpha.test " ) ) ; } 
public static List < ? > slice ( Iterable < ? > iterable , long startIndex , long size , boolean invert ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( ! invert ) { Iterable < ? > skipped = Iterables . skip ( iterable , ( int ) startIndex ) ; 
public static List < ? > distinct ( Iterable < ? > iterable , String key ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( key ! = null ) { key = key . trim ( ) . isEmpty ( ) ? null : key ; } Set < Integer > distinctKeys = new HashSet < Integer > ( ) ; ImmutableList . Builder < ? > b = ImmutableList . builder ( ) ; for ( Object object : iterable ) { final Integer hashCode ; if ( key = = null ) { hashCode = object = = null ? null : object . hashCode ( ) ; } else { Object v = DataFunctions . lookup ( object , key ) ; hashCode = v = = null ? null : v . hashCode ( ) ; } if ( hashCode ! = null & & distinctKeys . contains ( hashCode ) ) continue ; distinctKeys . add ( hashCode ) ; b . add ( object ) ; } return b . build ( ) ; } 
public static < K , V > Map < K , V > zipMap ( Iterable < K > keys , Iterable < V > values ) { if ( keys = = null | | values = = null ) return ImmutableMap . of ( ) ; ImmutableMap . Builder < K , V > b = ImmutableMap . builder ( ) ; Iterator < K > keyIterator = keys . iterator ( ) ; Iterator < V > valueIterator = values . iterator ( ) ; while ( keyIterator . hasNext ( ) & & valueIterator . hasNext ( ) ) { K key = keyIterator . next ( ) ; V value = valueIterator . next ( ) ; b . put ( key , value ) ; } return b . build ( ) ; } 
public void testDistinct ( ) { assertElements ( ListFunctions . distinct ( ImmutableList . of ( ) , null ) ) ; assertElements ( ListFunctions . distinct ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , null ) , 1 , 2 , 3 , 4 ) ; assertElements ( ListFunctions . distinct ( ImmutableList . of ( 4 , 3 , 2 , 1 ) , null ) , 4 , 3 , 2 , 1 ) ; assertElements ( ListFunctions . distinct ( ImmutableList . of ( 3 , 4 , 3 , 1 , 2 , 1 ) , null ) , 3 , 4 , 1 , 2 ) ; assertElements ( ListFunctions . distinct ( ImmutableList . of ( 3 , 4 , 3 , 2 , 1 ) , null ) , 3 , 4 , 2 , 1 ) ; } 
public void testDistinctWithKey ( ) { ImmutableMap < String , Integer > m1 = ImmutableMap . of ( " a " , 1 , " b " , 100 , " c " , 1234 ) ; ImmutableMap < String , Integer > m2 = ImmutableMap . of ( " a " , 2 , " b " , 100 , " c " , 2345 ) ; ImmutableMap < String , Integer > m3 = ImmutableMap . of ( " a " , 1 , " b " , 100 , " c " , 3456 ) ; ImmutableList < ImmutableMap < String , Integer > > l = ImmutableList . of ( m1 , m2 , m3 , m1 ) ; assertElements ( ListFunctions . distinct ( l , " " ) , m1 , m2 , m3 ) ; assertElements ( ListFunctions . distinct ( l , null ) , m1 , m2 , m3 ) ; assertElements ( ListFunctions . distinct ( l , " a " ) , m1 , m2 ) ; assertElements ( ListFunctions . distinct ( l , " b " ) , m1 ) ; assertElements ( ListFunctions . distinct ( l , " xxx " ) , m1 , m2 , m3 , m1 ) ; } 
public static Path findPath ( Point [ ] points , double curvature ) { if ( points . length = = 0 ) return null ; if ( points . length = = 1 ) { Path path = new Path ( ) ; path . moveto ( points [ 0 ] . x , points [ 0 ] . y ) ; return path ; } if ( points . length = = 2 ) { Path path = new Path ( ) ; path . moveto ( points [ 0 ] . x , points [ 0 ] . y ) ; path . lineto ( points [ 1 ] . x , points [ 1 ] . y ) ; return path ; } Zero curvature means straight lines. curvature = Math.max(0, Math.min(1, curvature)); if (curvature == 0) { Path path = new Path(); path.moveto(points[0].x, points[0].y); for (Point point : points) path.lineto(point.x, point.y); return path; } curvature = 4 + (1.0 - curvature) * 40; HashMap<Integer, Double> dx, dy, bi, ax, ay; dx = new HashMap<Integer, Double>(); dy = new HashMap<Integer, Double>(); bi = new HashMap<Integer, Double>(); ax = new HashMap<Integer, Double>(); ay = new HashMap<Integer, Double>(); dx.put(0, 0.0); dx.put(points.length - 1, 0.0); dy.put(0, 0.0); dy.put(points.length - 1, 0.0); bi.put(1, -0.25); ax.put(1, (points[2].x - points[0].x - dx.get(0)) / (curvature - bi.get(1))); ay.put(1, (points[2].y - points[0].y - dy.get(0)) / (curvature - bi.get(1))); for (int i = 2; i < points.length - 1; i++) { bi.put(i, -1 / (curvature + bi.get(i - 1))); ax.put(i, -(points[i + 1].x - points[i - 1].x - ax.get(i - 1)) * bi.get(i)); ay.put(i, -(points[i + 1].y - points[i - 1].y - ay.get(i - 1)) * bi.get(i)); } for (int i = points.length - 2; i >= 1; i--) { dx.put(i, ax.get(i) + dx.get(i + 1) * bi.get(i)); dy.put(i, ay.get(i) + dy.get(i + 1) * bi.get(i)); } Path path = new Path(); path.moveto(points[0].x, points[0].y); for (int i = 0; i < points.length - 1; i++) { path.curveto(points[i].x + dx.get(i), points[i].y + dy.get(i), points[i + 1].x - dx.get(i + 1), points[i + 1].y - dy.get(i + 1), points[i + 1].x, points[i + 1].y); } return path; } 
public static Path findPath ( Point [ ] points , double curvature ) { if ( points . length = = 0 ) return null ; if ( points . length = = 1 ) { Path path = new Path ( ) ; path . moveto ( points [ 0 ] . x , points [ 0 ] . y ) ; return path ; } if ( points . length = = 2 ) { Path path = new Path ( ) ; path . moveto ( points [ 0 ] . x , points [ 0 ] . y ) ; path . lineto ( points [ 1 ] . x , points [ 1 ] . y ) ; return path ; } Zero curvature means straight lines. curvature = Math.max(0, Math.min(1, curvature)); if (curvature == 0) { Path path = new Path(); path.moveto(points[0].x, points[0].y); for (Point point : points) path.lineto(point.x, point.y); return path; } curvature = 4 + (1.0 - curvature) * 40; HashMap<Integer, Double> dx, dy, bi, ax, ay; dx = new HashMap<Integer, Double>(); dy = new HashMap<Integer, Double>(); bi = new HashMap<Integer, Double>(); ax = new HashMap<Integer, Double>(); ay = new HashMap<Integer, Double>(); dx.put(0, 0.0); dx.put(points.length - 1, 0.0); dy.put(0, 0.0); dy.put(points.length - 1, 0.0); bi.put(1, 1 / curvature); ax.put(1, (points[2].x - points[0].x - dx.get(0)) * bi.get(1)); ay.put(1, (points[2].y - points[0].y - dy.get(0)) * bi.get(1)); for (int i = 2; i < points.length - 1; i++) { bi.put(i, -1 / (curvature + bi.get(i - 1))); ax.put(i, -(points[i + 1].x - points[i - 1].x - ax.get(i - 1)) * bi.get(i)); ay.put(i, -(points[i + 1].y - points[i - 1].y - ay.get(i - 1)) * bi.get(i)); } for (int i = points.length - 2; i >= 1; i--) { dx.put(i, ax.get(i) + dx.get(i + 1) * bi.get(i)); dy.put(i, ay.get(i) + dy.get(i + 1) * bi.get(i)); } Path path = new Path(); path.moveto(points[0].x, points[0].y); for (int i = 0; i < points.length - 1; i++) { path.curveto(points[i].x + dx.get(i), points[i].y + dy.get(i), points[i + 1].x - dx.get(i + 1), points[i + 1].y - dy.get(i + 1), points[i + 1].x, points[i + 1].y); } return path; } 
public static Device oscDevice ( String name , long port ) { return new Device ( name , TYPE_OSC , ImmutableMap . < String , String > of ( " port " , String . valueOf ( port ) ) ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof Device ) ) return false ; final Device other = ( Device ) o ; return Objects . equal ( name , other . name ) & & Objects . equal ( type , other . type ) 
public String toString ( ) { return String . format ( " <Device %s (%s)> " , name , type ) ; } 
private static NodeLibrary create ( String libraryName , Node root , NodeRepository nodeRepository , FunctionRepository functionRepository , UUID uuid ) { return new NodeLibrary ( libraryName , null , root , nodeRepository , functionRepository , ImmutableMap . < String , String > of ( ) , ImmutableList . < Device > of ( ) , uuid ) ; } 
public NodeLibrary withProperties ( Map < String , String > properties ) { return new NodeLibrary ( this . name , this . file , this . root , this . nodeRepository , this . functionRepository , ImmutableMap . copyOf ( properties ) , this . devices , this . uuid ) ; } 
public boolean hasDevice ( String name ) { for ( Device device : devices ) { if ( device . getName ( ) . equals ( name ) ) return true ; } return false ; } 
public NodeLibrary withDeviceAdded ( Device device ) { checkNotNull ( device , " Device cannot be null. " ) ; checkArgument ( ! hasDevice ( device . getName ( ) ) , " There is already a device named %s " , device . getName ( ) ) ; ImmutableList . Builder < Device > b = ImmutableList . builder ( ) ; b . addAll ( getDevices ( ) ) ; b . add ( device ) ; return new NodeLibrary ( this . name , this . file , this . root , this . nodeRepository , this . functionRepository , this . properties , b . build ( ) , this . uuid ) ; } 
public NodeLibrary withDeviceRemoved ( Device device ) { return withDeviceRemoved ( device . getName ( ) ) ; } 
private static NodeLibrary parseNDBX ( String libraryName , File file , XMLStreamReader reader , NodeRepository nodeRepository , UUID uuid ) throws XMLStreamException { List < FunctionLibrary > functionLibraries = new LinkedList < FunctionLibrary > ( ) ; Map < String , String > propertyMap = new HashMap < String , String > ( ) ; Node rootNode = Node . ROOT ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " property " ) ) { parseProperty ( reader , propertyMap ) ; } else if ( tagName . equals ( " link " ) ) { FunctionLibrary functionLibrary = parseLink ( file , reader ) ; functionLibraries . add ( functionLibrary ) ; } else if ( tagName . equals ( " node " ) ) { rootNode = parseNode ( reader , rootNode , nodeRepository ) ; } else { throw new XMLStreamException ( " Unknown tag " + tagName , reader . getLocation ( ) ) ; } } else if ( eventType = = XMLStreamConstants . END_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) break ; } } FunctionLibrary [ ] fl = functionLibraries . toArray ( new FunctionLibrary [ functionLibraries . size ( ) ] ) ; return new NodeLibrary ( libraryName , file , rootNode , nodeRepository , FunctionRepository . of ( fl ) , propertyMap , ImmutableList . < Device > of ( ) , uuid ) ; } 
public NodeLibrary withRoot ( Node newRoot ) { return new NodeLibrary ( this . name , this . file , newRoot , this . nodeRepository , this . functionRepository , this . properties , this . devices , this . uuid ) ; } 
public NodeLibrary withFunctionRepository ( FunctionRepository newRepository ) { return new NodeLibrary ( this . name , this . file , this . root , this . nodeRepository , newRepository , this . properties , this . devices , this . uuid ) ; } 
public NodeLibrary withFile ( File newFile ) { return new NodeLibrary ( this . name , newFile , this . root , this . nodeRepository , this . functionRepository , this . properties , this . devices , this . uuid ) ; } 
public static Device deviceForType ( String name , String type ) { checkNotNull ( type , " Type cannot be null. " ) ; checkArgument ( deviceTypes . contains ( type ) , " %s is not a valid device type. " , type ) ; If the type is not found in the default values, get() returns null, which is what we need for custom types. return new Device(name, type, ImmutableMap.<String, String>of()); } 
public Device withProperty ( String name , String value ) { Map < String , String > b = new HashMap < String , String > ( ) ; checkArgument ( isValidProperty ( name ) , " Property name '%s' is not valid. " , name ) ; b . putAll ( properties ) ; b . put ( name , value ) ; return new Device ( this . name , this . type , ImmutableMap . copyOf ( b ) ) ; } 
private boolean isValidProperty ( String name ) { checkNotNull ( name ) ; return validPropertyNames . get ( getType ( ) ) . matcher ( name ) . matches ( ) ; } 
private static void writeDevices ( Document doc , Element parent , List < Device > devices ) { for ( Device device : devices ) { Element el = doc . createElement ( " device " ) ; 
private static NodeLibrary parseNDBX ( String libraryName , File file , XMLStreamReader reader , NodeRepository nodeRepository , UUID uuid ) throws XMLStreamException { List < FunctionLibrary > functionLibraries = new LinkedList < FunctionLibrary > ( ) ; Map < String , String > propertyMap = new HashMap < String , String > ( ) ; Node rootNode = Node . ROOT ; List < Device > devices = new LinkedList < Device > ( ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " property " ) ) { parseProperty ( reader , propertyMap ) ; } else if ( tagName . equals ( " link " ) ) { FunctionLibrary functionLibrary = parseLink ( file , reader ) ; functionLibraries . add ( functionLibrary ) ; } else if ( tagName . equals ( " device " ) ) { Device device = parseDevice ( reader ) ; devices . add ( device ) ; } else if ( tagName . equals ( " node " ) ) { rootNode = parseNode ( reader , rootNode , nodeRepository ) ; } else { throw new XMLStreamException ( " Unknown tag " + tagName , reader . getLocation ( ) ) ; } } else if ( eventType = = XMLStreamConstants . END_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) break ; } } FunctionLibrary [ ] fl = functionLibraries . toArray ( new FunctionLibrary [ functionLibraries . size ( ) ] ) ; return new NodeLibrary ( libraryName , file , rootNode , nodeRepository , FunctionRepository . of ( fl ) , propertyMap , devices , uuid ) ; } 
private static Device parseDevice ( XMLStreamReader reader ) throws XMLStreamException { String name = reader . getAttributeValue ( null , " name " ) ; String type = reader . getAttributeValue ( null , " type " ) ; Device device = Device . deviceForType ( name , type ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " property " ) ) { String propertyName = reader . getAttributeValue ( null , " name " ) ; String propertyValue = reader . getAttributeValue ( null , " value " ) ; if ( propertyName = = null | | propertyValue = = null ) continue ; device = device . withProperty ( propertyName , propertyValue ) ; } } else if ( eventType = = XMLStreamConstants . END_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " device " ) ) break ; } } return device ; } 
public static DeviceHandler createDeviceHandler ( Device device ) { if ( device . getType ( ) . equals ( Device . TYPE_OSC ) ) return createOSCDeviceHandler ( device ) ; return null ; } 
private static DeviceHandler createOSCDeviceHandler ( Device device ) { String name = device . getName ( ) ; int port = Integer . parseInt ( ( String ) device . getProperties ( ) . get ( " port " ) ) ; boolean autostart = Boolean . parseBoolean ( ( String ) device . getProperties ( ) . get ( " autostart " ) ) ; OSCDeviceHandler handler = new OSCDeviceHandler ( device . getName ( ) , port ) ; if ( autostart ) handler . start ( ) ; return handler ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final Viewer viewer = new Viewer ( ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( 600 , 600 ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; final ImmutableMap < String , ? > data = ImmutableMap . of ( " mouse.position " , viewer . getLastMousePosition ( ) ) ; , "osc.messages", oscMessages); NodeContext context = new NodeContext(exportLibrary, exportFunctionRepository, frame, data, renderResults); List<?> results = context.renderNode(exportNetwork); renderResults = context.getRenderResults(); viewer.setOutputValues((List<?>) results); exportDelegate.frameDone(frame, results); SwingUtilities.invokeLater(new Runnable() { public void run() { d.tick(); } }); } exportDelegate.exportDone(); } catch (Exception e) { LOG.log(Level.WARNING, "Error while exporting", e); } finally { SwingUtilities.invokeLater(new Runnable() { public void run() { d.setVisible(false); frame.setVisible(false); } }); } } }); d.setThread(t); t.start(); frame.setVisible(true); } 
public void start ( int port ) { if ( oscP5 ! = null ) stop ( ) ; oscPort = port ; oscMessages . clear ( ) ; oscP5 = new OscP5 ( new Object ( ) , port ) ; oscP5 . addListener ( new OscEventListener ( ) { @Override 
public void oscStatus ( OscStatus ignored ) { } } ) ; } public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; oscPort = - 1 ; oscMessages . clear ( ) ; } } 
public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; oscPort = - 1 ; oscMessages . clear ( ) ; } 
public static Device oscDevice ( String name , long port , boolean autostart ) { return new Device ( name , TYPE_OSC , ImmutableMap . < String , String > of ( " port " , String . valueOf ( port ) , " autostart " , String . valueOf ( autostart ) ) ) ; } 
public static UpgradeStringResult upgrade16to17 ( String inputXml ) throws LoadException { UpgradeOp convertOSCPropertyOp = new ConvertOSCPropertyFormatOp ( ) ; return transformXml ( inputXml , " 17 " , convertOSCPropertyOp ) ; } 
public void testUpgrade16to17 ( ) { File version16File = new File ( " src/test/files/upgrade-v16.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version16File ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version16File , NodeRepository . of ( ) ) ; assertFalse ( upgradedLibrary . hasProperty ( " oscPort " ) ) ; assertTrue ( upgradedLibrary . hasDevice ( " osc1 " ) ) ; assertEquals ( 1 , upgradedLibrary . getDevices ( ) . size ( ) ) ; assertEquals ( " 2084 " , upgradedLibrary . getDevices ( ) . get ( 0 ) . getProperties ( ) . get ( " port " ) ) ; assertEquals ( " true " , upgradedLibrary . getDevices ( ) . get ( 0 ) . getProperties ( ) . get ( " autostart " ) ) ; } 
public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; } 
private static DeviceHandler createOSCDeviceHandler ( Device device ) { int port = Integer . parseInt ( ( String ) device . getProperties ( ) . get ( " port " ) ) ; boolean autostart = Boolean . parseBoolean ( ( String ) device . getProperties ( ) . get ( " autostart " ) ) ; OSCDeviceHandler handler = new OSCDeviceHandler ( device . getName ( ) , port , autostart ) ; if ( autostart ) handler . start ( ) ; return handler ; } 
public void showDevices ( ) { DevicesDialog dialog = new DevicesDialog ( this ) ; dialog . setVisible ( true ) ; } 
public void actionPerformed ( ActionEvent e ) { getDocument ( ) . showDevices ( ) ; } 
public void start ( ) { if ( oscP5 ! = null ) stop ( ) ; if ( oscPort = = - 1 ) return ; oscMessages . clear ( ) ; oscP5 = new OscP5 ( new Object ( ) , oscPort ) ; oscP5 . addListener ( new OscEventListener ( ) { @Override 
public void oscEvent ( OscMessage m ) { if ( ! isPaused ( ) ) { ImmutableList < Object > arguments = ImmutableList . copyOf ( m . arguments ( ) ) ; 
public void oscStatus ( OscStatus ignored ) { } } ) ; } public void pause ( ) { paused = true ; } public void resume ( ) { paused = false ; } public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } private class OSCDeviceControl extends AbstractDeviceControl { private JLabel deviceNameLabel ; private JTextField portNumberField ; private JCheckBox autoStartCheck ; private JButton startButton ; private JButton stopButton ; private JButton clearButton ; public OSCDeviceControl ( OSCDeviceHandler deviceHandler ) { super ( deviceHandler ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; Dimension d = new Dimension ( 450 , 30 ) ; setPreferredSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; deviceNameLabel = new JLabel ( deviceHandler . getName ( ) ) ; portNumberField = new JTextField ( ) ; portNumberField . setText ( String . valueOf ( getPort ( ) ) ) ; autoStartCheck = new JCheckBox ( " autostart " ) ; autoStartCheck . setSelected ( isAutoStart ( ) ) ; startButton = new JButton ( ) ; if ( isRunning ( ) ) { startButton . setText ( isPaused ( ) ? " Start " : " Pause " ) ; } else { startButton . setText ( " Start " ) ; } startButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { start ( ) ; startButton . setText ( " Pause " ) ; } else if ( isPaused ( ) ) { resume ( ) ; startButton . setText ( " Pause " ) ; } else { pause ( ) ; startButton . setText ( " Resume " ) ; } } } ) ; stopButton = new JButton ( " Stop " ) ; stopButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { stop ( ) ; startButton . setText ( " Start " ) ; } } ) ; clearButton = new JButton ( " Clear " ) ; clearButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } } ) ; add ( Box . createHorizontalStrut ( 10 ) ) ; add ( deviceNameLabel ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( portNumberField ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( autoStartCheck ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( startButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( stopButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( clearButton ) ; add ( Box . createHorizontalGlue ( ) ) ; } } } 
public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } 
public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { start ( ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { stop ( ) ; startButton . setText ( " Start " ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } 
public void setPropertyChangeListener ( OnPropertyChangeListener l ) ; public OnPropertyChangeListener getPropertyChangeListener ( ) ; public static interface OnPropertyChangeListener { public void onPropertyChange ( String deviceName , String key , String newValue ) ; } } 
public OnPropertyChangeListener getPropertyChangeListener ( ) ; public static interface OnPropertyChangeListener { public void onPropertyChange ( String deviceName , String key , String newValue ) ; } } 
public void onPropertyChange ( String deviceName , String key , String newValue ) ; } } 
public String getName ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; } 
public void onPropertyChange ( String deviceName , String key , String newValue ) { document . setDeviceProperty ( deviceName , key , newValue ) ; } 
public void oscStatus ( OscStatus ignored ) { } } ) ; } public void pause ( ) { paused = true ; } public void resume ( ) { paused = false ; } public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } private class OSCDeviceControl extends AbstractDeviceControl { private JLabel deviceNameLabel ; private JTextField portNumberField ; private JCheckBox autoStartCheck ; private JButton startButton ; private JButton stopButton ; private JButton clearButton ; public OSCDeviceControl ( OSCDeviceHandler deviceHandler ) { super ( deviceHandler ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; Dimension d = new Dimension ( 450 , 30 ) ; setPreferredSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; deviceNameLabel = new JLabel ( deviceHandler . getName ( ) ) ; portNumberField = new JTextField ( ) ; portNumberField . setText ( String . valueOf ( getPort ( ) ) ) ; autoStartCheck = new JCheckBox ( " autostart " ) ; autoStartCheck . setSelected ( isAutoStart ( ) ) ; autoStartCheck . addItemListener ( new ItemListener ( ) { @Override public void itemStateChanged ( ItemEvent itemEvent ) { autostart = autoStartCheck . isSelected ( ) ; setPropertyValue ( " autostart " , String . valueOf ( autostart ) ) ; } } ) ; startButton = new JButton ( ) ; if ( isRunning ( ) ) { startButton . setText ( isPaused ( ) ? " Start " : " Pause " ) ; } else { startButton . setText ( " Start " ) ; } startButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { start ( ) ; startButton . setText ( " Pause " ) ; } else if ( isPaused ( ) ) { resume ( ) ; startButton . setText ( " Pause " ) ; } else { pause ( ) ; startButton . setText ( " Resume " ) ; } } } ) ; stopButton = new JButton ( " Stop " ) ; stopButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { stop ( ) ; startButton . setText ( " Start " ) ; } } ) ; clearButton = new JButton ( " Clear " ) ; clearButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } } ) ; add ( Box . createHorizontalStrut ( 10 ) ) ; add ( deviceNameLabel ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( portNumberField ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( autoStartCheck ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( startButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( stopButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( clearButton ) ; add ( Box . createHorizontalGlue ( ) ) ; } } } 
public void itemStateChanged ( ItemEvent itemEvent ) { autostart = autoStartCheck . isSelected ( ) ; setPropertyValue ( " autostart " , String . valueOf ( autostart ) ) ; } 
public Device withProperty ( String name , String value ) { checkArgument ( isValidProperty ( name ) , " Property name '%s' is not valid. " , name ) ; Map < String , String > b = new HashMap < String , String > ( ) ; b . putAll ( properties ) ; b . put ( name , value ) ; return new Device ( this . name , this . type , ImmutableMap . copyOf ( b ) ) ; } 
public void mousePressed ( MouseEvent e ) { devicesPopup . show ( addDeviceButton , - 20 , 21 ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { DevicesDialog . this . setVisible ( false ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { removeDevice ( deviceHandler . getName ( ) ) ; } 
public void removeDevice ( String deviceName ) { todo: implement } private class DevicesPopupMenu extends JPopupMenu { private DevicesPopupMenu() { add(new AddDeviceHandlerAction("osc", "OSC")); } } private class AddDeviceHandlerAction extends AbstractAction { private String type; private AddDeviceHandlerAction(String type, String label) { super(label); this.type = type; } public void actionPerformed(ActionEvent actionEvent) { addDeviceHandler(type); } }} 
public void actionPerformed ( ActionEvent actionEvent ) { addDeviceHandler ( type ) ; } 
private static DeviceHandler createOSCDeviceHandler ( Device device ) { int port = Integer . parseInt ( device . getProperty ( " port " , " -1 " ) ) ; boolean autostart = Boolean . parseBoolean ( device . getProperty ( " autostart " , " false " ) ) ; OSCDeviceHandler handler = new OSCDeviceHandler ( device . getName ( ) , port , autostart ) ; if ( autostart ) handler . start ( ) ; return handler ; } 
public void actionPerformed ( ActionEvent actionEvent ) { document . removeDevice ( deviceHandler . getName ( ) ) ; rebuildInterface ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { document . addDevice ( type ) ; rebuildInterface ( ) ; } 
public void addDevice ( String deviceType ) { todo: undo / redo Device device = controller.addDevice(deviceType); DeviceHandler handler = DeviceHandlerFactory.createDeviceHandler(device); if (handler != null) deviceHandlers.add(handler); 
public void oscStatus ( OscStatus ignored ) { } } ) ; } public void pause ( ) { paused = true ; } public void resume ( ) { paused = false ; } public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } private class OSCDeviceControl extends AbstractDeviceControl { private JLabel deviceNameLabel ; private JTextField portNumberField ; private JCheckBox autoStartCheck ; private JButton startButton ; private JButton stopButton ; private JButton clearButton ; public OSCDeviceControl ( OSCDeviceHandler deviceHandler ) { super ( deviceHandler ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; Dimension d = new Dimension ( 450 , 30 ) ; setPreferredSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; deviceNameLabel = new JLabel ( deviceHandler . getName ( ) ) ; portNumberField = new JTextField ( ) ; portNumberField . setText ( String . valueOf ( getPort ( ) ) ) ; portNumberField . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . addFocusListener ( new FocusAdapter ( ) { @Override public void focusLost ( FocusEvent focusEvent ) { changePortNumber ( ) ; } } ) ; autoStartCheck = new JCheckBox ( " autostart " ) ; autoStartCheck . setSelected ( isAutoStart ( ) ) ; autoStartCheck . addItemListener ( new ItemListener ( ) { @Override public void itemStateChanged ( ItemEvent itemEvent ) { autostart = autoStartCheck . isSelected ( ) ; setPropertyValue ( " autostart " , String . valueOf ( autostart ) ) ; } } ) ; startButton = new JButton ( ) ; if ( isRunning ( ) ) { startButton . setText ( isPaused ( ) ? " Start " : " Pause " ) ; } else { startButton . setText ( " Start " ) ; } startButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { startOSC ( ) ; } else if ( isPaused ( ) ) { resumeOSC ( ) ; } else { pauseOSC ( ) ; } } } ) ; stopButton = new JButton ( " Stop " ) ; stopButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { stopOSC ( ) ; } } ) ; clearButton = new JButton ( " Clear " ) ; clearButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } } ) ; add ( Box . createHorizontalStrut ( 10 ) ) ; add ( deviceNameLabel ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( portNumberField ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( autoStartCheck ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( startButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( stopButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( clearButton ) ; add ( Box . createHorizontalGlue ( ) ) ; } private void startOSC ( ) { start ( ) ; if ( isRunning ( ) ) startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void resumeOSC ( ) { resume ( ) ; startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void pauseOSC ( ) { pause ( ) ; startButton . setText ( isRunning ( ) ? " Resume " : " Start " ) ; } private void stopOSC ( ) { stop ( ) ; startButton . setText ( " Start " ) ; } private void changePortNumber ( ) { try { int newPort = Integer . parseInt ( portNumberField . getText ( ) ) ; stopOSC ( ) ; oscPort = newPort ; setPropertyValue ( " port " , String . valueOf ( newPort ) ) ; } catch ( Exception e ) { todo: better error handling of invalid port values portNumberField.setText(String.valueOf(getPort())); return; } } }} 
public void actionPerformed ( ActionEvent actionEvent ) { changePortNumber ( ) ; } 
public void focusLost ( FocusEvent focusEvent ) { changePortNumber ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { startOSC ( ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { stopOSC ( ) ; } 
private void startOSC ( ) { start ( ) ; if ( isRunning ( ) ) startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; 
private void resumeOSC ( ) { resume ( ) ; startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } 
private void pauseOSC ( ) { pause ( ) ; startButton . setText ( isRunning ( ) ? " Resume " : " Start " ) ; } 
private void stopOSC ( ) { stop ( ) ; startButton . setText ( " Start " ) ; } 
private void changePortNumber ( ) { try { int newPort = Integer . parseInt ( portNumberField . getText ( ) ) ; 
public Device addDevice ( String deviceType ) { String deviceName = nodeLibrary . uniqueName ( deviceType ) ; Device device = Device . deviceForType ( deviceName , deviceType ) ; nodeLibrary = nodeLibrary . withDeviceAdded ( device ) ; return device ; } 
public void removeDevice ( String deviceName ) { nodeLibrary = nodeLibrary . withDeviceRemoved ( deviceName ) ; } 
public void showDevices ( ) { devicesDialog . setVisible ( true ) ; } 
public void oscStatus ( OscStatus ignored ) { } } ) ; } public void pause ( ) { paused = true ; } public void resume ( ) { paused = false ; } public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } private class OSCDeviceControl extends AbstractDeviceControl { private JLabel deviceNameLabel ; private JTextField portNumberField ; private JCheckBox autoStartCheck ; private JButton startButton ; private JButton stopButton ; private JButton clearButton ; public OSCDeviceControl ( OSCDeviceHandler deviceHandler ) { super ( deviceHandler ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; Dimension d = new Dimension ( 450 , 30 ) ; setPreferredSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; deviceNameLabel = new JLabel ( deviceHandler . getName ( ) ) ; portNumberField = new JTextField ( ) ; portNumberField . setText ( String . valueOf ( getPort ( ) ) ) ; portNumberField . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . addFocusListener ( new FocusAdapter ( ) { @Override public void focusLost ( FocusEvent focusEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . setPreferredSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; portNumberField . setMinimumSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; autoStartCheck = new JCheckBox ( " autostart " ) ; autoStartCheck . setSelected ( isAutoStart ( ) ) ; autoStartCheck . addItemListener ( new ItemListener ( ) { @Override public void itemStateChanged ( ItemEvent itemEvent ) { autostart = autoStartCheck . isSelected ( ) ; setPropertyValue ( " autostart " , String . valueOf ( autostart ) ) ; } } ) ; startButton = new JButton ( ) ; if ( isRunning ( ) ) { startButton . setText ( isPaused ( ) ? " Start " : " Pause " ) ; } else { startButton . setText ( " Start " ) ; } startButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { startOSC ( ) ; } else if ( isPaused ( ) ) { resumeOSC ( ) ; } else { pauseOSC ( ) ; } } } ) ; stopButton = new JButton ( " Stop " ) ; stopButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { stopOSC ( ) ; } } ) ; clearButton = new JButton ( " Clear " ) ; clearButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } } ) ; add ( Box . createHorizontalStrut ( 10 ) ) ; add ( deviceNameLabel ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( portNumberField ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( autoStartCheck ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( startButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( stopButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( clearButton ) ; add ( Box . createHorizontalGlue ( ) ) ; } private void startOSC ( ) { start ( ) ; if ( isRunning ( ) ) startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void resumeOSC ( ) { resume ( ) ; startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void pauseOSC ( ) { pause ( ) ; startButton . setText ( isRunning ( ) ? " Resume " : " Start " ) ; } private void stopOSC ( ) { stop ( ) ; startButton . setText ( " Start " ) ; } private void changePortNumber ( ) { try { int newPort = Integer . parseInt ( portNumberField . getText ( ) ) ; stopOSC ( ) ; oscPort = newPort ; setPropertyValue ( " port " , String . valueOf ( newPort ) ) ; } catch ( Exception e ) { todo: better error handling of invalid port values portNumberField.setText(String.valueOf(getPort())); return; } } }} 
public String getName ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map map ) ; } 
public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map map ) ; } 
public AbstractDeviceControl createControl ( ) ; public void addData ( Map map ) ; } 
public void oscStatus ( OscStatus ignored ) { } } ) ; } public void pause ( ) { paused = true ; } public void resume ( ) { paused = false ; } public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } public void addData ( Map map ) { map . put ( getName ( ) + " .messages " , getOscMessages ( ) ) ; } public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } private class OSCDeviceControl extends AbstractDeviceControl { private JLabel deviceNameLabel ; private JTextField portNumberField ; private JCheckBox autoStartCheck ; private JButton startButton ; private JButton stopButton ; private JButton clearButton ; public OSCDeviceControl ( OSCDeviceHandler deviceHandler ) { super ( deviceHandler ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; Dimension d = new Dimension ( 450 , 30 ) ; setPreferredSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; deviceNameLabel = new JLabel ( deviceHandler . getName ( ) ) ; portNumberField = new JTextField ( ) ; portNumberField . setText ( String . valueOf ( getPort ( ) ) ) ; portNumberField . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . addFocusListener ( new FocusAdapter ( ) { @Override public void focusLost ( FocusEvent focusEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . setPreferredSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; portNumberField . setMinimumSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; autoStartCheck = new JCheckBox ( " autostart " ) ; autoStartCheck . setSelected ( isAutoStart ( ) ) ; autoStartCheck . addItemListener ( new ItemListener ( ) { @Override public void itemStateChanged ( ItemEvent itemEvent ) { autostart = autoStartCheck . isSelected ( ) ; setPropertyValue ( " autostart " , String . valueOf ( autostart ) ) ; } } ) ; startButton = new JButton ( ) ; if ( isRunning ( ) ) { startButton . setText ( isPaused ( ) ? " Start " : " Pause " ) ; } else { startButton . setText ( " Start " ) ; } startButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { startOSC ( ) ; } else if ( isPaused ( ) ) { resumeOSC ( ) ; } else { pauseOSC ( ) ; } } } ) ; stopButton = new JButton ( " Stop " ) ; stopButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { stopOSC ( ) ; } } ) ; clearButton = new JButton ( " Clear " ) ; clearButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } } ) ; add ( Box . createHorizontalStrut ( 10 ) ) ; add ( deviceNameLabel ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( portNumberField ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( autoStartCheck ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( startButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( stopButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( clearButton ) ; add ( Box . createHorizontalGlue ( ) ) ; } private void startOSC ( ) { start ( ) ; if ( isRunning ( ) ) startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void resumeOSC ( ) { resume ( ) ; startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void pauseOSC ( ) { pause ( ) ; startButton . setText ( isRunning ( ) ? " Resume " : " Start " ) ; } private void stopOSC ( ) { stop ( ) ; startButton . setText ( " Start " ) ; } private void changePortNumber ( ) { try { int newPort = Integer . parseInt ( portNumberField . getText ( ) ) ; stopOSC ( ) ; oscPort = newPort ; setPropertyValue ( " port " , String . valueOf ( newPort ) ) ; } catch ( Exception e ) { todo: better error handling of invalid port values portNumberField.setText(String.valueOf(getPort())); return; } } }} 
public void addData ( Map map ) { map . put ( getName ( ) + " .messages " , getOscMessages ( ) ) ; } 
public String getName ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public void oscStatus ( OscStatus ignored ) { } } ) ; } public void pause ( ) { paused = true ; } public void resume ( ) { paused = false ; } @Override public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } @Override public void addData ( Map < String , Object > map ) { map . put ( getName ( ) + " .messages " , getOscMessages ( ) ) ; } @Override public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } private class OSCDeviceControl extends AbstractDeviceControl { private JLabel deviceNameLabel ; private JTextField portNumberField ; private JCheckBox autoStartCheck ; private JButton startButton ; private JButton stopButton ; private JButton clearButton ; public OSCDeviceControl ( OSCDeviceHandler deviceHandler ) { super ( deviceHandler ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; Dimension d = new Dimension ( 450 , 30 ) ; setPreferredSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; deviceNameLabel = new JLabel ( deviceHandler . getName ( ) ) ; portNumberField = new JTextField ( ) ; portNumberField . setText ( String . valueOf ( getPort ( ) ) ) ; portNumberField . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . addFocusListener ( new FocusAdapter ( ) { @Override public void focusLost ( FocusEvent focusEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . setPreferredSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; portNumberField . setMinimumSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; autoStartCheck = new JCheckBox ( " autostart " ) ; autoStartCheck . setSelected ( isAutoStart ( ) ) ; autoStartCheck . addItemListener ( new ItemListener ( ) { @Override public void itemStateChanged ( ItemEvent itemEvent ) { autostart = autoStartCheck . isSelected ( ) ; setPropertyValue ( " autostart " , String . valueOf ( autostart ) ) ; } } ) ; startButton = new JButton ( ) ; if ( isRunning ( ) ) { startButton . setText ( isPaused ( ) ? " Start " : " Pause " ) ; } else { startButton . setText ( " Start " ) ; } startButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { startOSC ( ) ; } else if ( isPaused ( ) ) { resumeOSC ( ) ; } else { pauseOSC ( ) ; } } } ) ; stopButton = new JButton ( " Stop " ) ; stopButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { stopOSC ( ) ; } } ) ; clearButton = new JButton ( " Clear " ) ; clearButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } } ) ; add ( Box . createHorizontalStrut ( 10 ) ) ; add ( deviceNameLabel ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( portNumberField ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( autoStartCheck ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( startButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( stopButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( clearButton ) ; add ( Box . createHorizontalGlue ( ) ) ; } private void startOSC ( ) { start ( ) ; if ( isRunning ( ) ) startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void resumeOSC ( ) { resume ( ) ; startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void pauseOSC ( ) { pause ( ) ; startButton . setText ( isRunning ( ) ? " Resume " : " Start " ) ; } private void stopOSC ( ) { stop ( ) ; startButton . setText ( " Start " ) ; } private void changePortNumber ( ) { try { int newPort = Integer . parseInt ( portNumberField . getText ( ) ) ; stopOSC ( ) ; oscPort = newPort ; setPropertyValue ( " port " , String . valueOf ( newPort ) ) ; } catch ( Exception e ) { todo: better error handling of invalid port values portNumberField.setText(String.valueOf(getPort())); return; } } }} 
public void addData ( Map < String , Object > map ) { map . put ( getName ( ) + " .messages " , getOscMessages ( ) ) ; } 
public void setup ( ) { minim = new Minim ( this ) ; player = minim . loadFile ( fileName , 1024 ) ; if ( loop ) player . loop ( ) ; 
public void draw ( ) { } @Override public void stop ( ) { if ( player ! = null ) player . close ( ) ; player = null ; if ( minim ! = null ) minim . stop ( ) ; } } 
public void stop ( ) { if ( player ! = null ) player . close ( ) ; player = null ; if ( minim ! = null ) minim . stop ( ) ; 
public void start ( ) { if ( frame ! = null ) stop ( ) ; frame = new JFrame ( ) ; applet = new MinimApplet ( getFileName ( ) , true ) ; applet . init ( ) ; frame . add ( applet ) ; } 
public void stop ( ) { if ( frame ! = null ) { applet . stop ( ) ; 
public void addData ( Map < String , Object > map ) { if ( applet ! = null & & applet . getPlayer ( ) ! = null ) map . put ( getName ( ) + " .player " , applet . getPlayer ( ) ) ; 
public AbstractDeviceControl createControl ( ) { return new AudioPlayerDeviceControl ( this ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { File f = FileUtils . showOpenDialog ( null , getFileName ( ) , " mp3,wav " , " Music files " ) ; if ( f ! = null ) { setFileName ( f . getAbsolutePath ( ) ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { start ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { stop ( ) ; } 
public static DeviceHandler createDeviceHandler ( Device device ) { if ( device . getType ( ) . equals ( Device . TYPE_OSC ) ) return createOSCDeviceHandler ( device ) ; else if ( device . getType ( ) . equals ( Device . TYPE_AUDIOPLAYER ) ) return createAudioPlayerDeviceHandler ( device ) ; return null ; } 
private static DeviceHandler createAudioPlayerDeviceHandler ( Device device ) { String fileName = device . getProperty ( " filename " , " " ) ; boolean autostart = Boolean . parseBoolean ( device . getProperty ( " autostart " , " false " ) ) ; AudioPlayerDeviceHandler handler = new AudioPlayerDeviceHandler ( device . getName ( ) , fileName , autostart ) ; if ( autostart ) handler . start ( ) ; return handler ; } 
public static List < Double > audioAnalysis ( String deviceName , long averages , NodeContext context ) { AudioPlayer player = ( AudioPlayer ) context . getData ( ) . get ( deviceName + " .player " ) ; if ( player = = null ) return ImmutableList . of ( ) ; FFT fft = new FFT ( player . bufferSize ( ) , player . sampleRate ( ) ) ; if ( averages > 0 ) fft . linAverages ( ( int ) averages ) ; fft . forward ( player . mix ) ; ImmutableList . Builder < Double > b = new ImmutableList . Builder < Double > ( ) ; if ( averages = = 0 ) { for ( int i = 0 ; i < fft . specSize ( ) ; i + + ) b . add ( ( double ) fft . getBand ( i ) ) ; } else { for ( int i = 0 ; i < fft . avgSize ( ) ; i + + ) b . add ( ( double ) fft . getAvg ( i ) ) ; } return b . build ( ) ; } 
public void toggleAnimation ( ) { document . toggleAnimation ( ) ; } 
public static String path ( String parentPath , String nodeName ) { checkNotNull ( parentPath ) ; checkNotNull ( nodeName ) ; checkArgument ( parentPath . startsWith ( " / " ) , " Only absolute paths are supported. " ) ; if ( nodeName . isEmpty ( ) ) return parentPath ; if ( parentPath . equals ( " / " ) ) { return " / " + nodeName ; 
public void testPath ( ) { assertEquals ( " /child " , Node . path ( " / " , Node . ROOT . withName ( " child " ) ) ) ; assertEquals ( " /parent/child " , Node . path ( " /parent " , Node . ROOT . withName ( " child " ) ) ) ; assertEquals ( " /parent " , Node . path ( " /parent " , " " ) ) ; } 
public static List < Object > filterData ( List < Object > rows , String key , String op , Object value ) { if ( value = = null ) return rows ; ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; try { double floatValue = Double . parseDouble ( value . toString ( ) ) ; for ( Object o : rows ) { if ( doubleMatches ( o , key , op , floatValue ) ) { b . add ( o ) ; } } } catch ( NumberFormatException e ) { for ( Object o : rows ) { if ( objectMatches ( o , key , op , value ) ) { b . add ( o ) ; } } } return b . build ( ) ; } 
private static boolean objectMatches ( Object o , String key , String op , Object value ) { if ( value = = null ) return false ; Object v = fastLookup ( o , key ) ; if ( op . equals ( " = " ) & & value . equals ( v ) ) { return true ; 
private static boolean doubleMatches ( Object o , String key , String op , double value ) { Object v = fastLookup ( o , key ) ; if ( v = = null ) return false ; TODO is this the best thing? double dv; if (v instanceof Double) { dv = (Double) v; } else if (v instanceof String) { try { dv = Double.parseDouble(v.toString()); } catch (NumberFormatException e) { We use a sentinel here so that it can still be non-equal. dv = Double.MAX_VALUE; } } else if (v instanceof Long) { dv = (double) (Long) v; } else if (v instanceof Integer) { dv = (double) (Integer) v; } else if (v instanceof Float) { dv = (double) (Float) v; } else { return false; } if (op.equals("=") && dv == value) { return true; 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final Viewer viewer = new Viewer ( ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( 600 , 600 ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " frame " , ( double ) frame ) ; data . put ( " mouse.position " , viewer . getLastMousePosition ( ) ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , data , renderResults ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < ? > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
private static Iterable < Map < Port , ? > > buildArgumentMaps ( final Map < Port , List < ? > > argumentsPerPort ) { final int minSize = smallestArgumentList ( argumentsPerPort ) ; if ( minSize = = 0 ) return Collections . emptyList ( ) ; final int maxSize = biggestArgumentList ( argumentsPerPort ) ; return new Iterable < Map < Port , ? > > ( ) { int i = 0 ; 
private NodeContext createNodeContextWithData ( Map < String , Object > data ) { return new NodeContext ( testLibrary , null , data ) ; } 
public void testFrame ( ) { Node frame = Node . ROOT . withName ( " frame " ) . withFunction ( " core/frame " ) . withInputAdded ( Port . customPort ( " context " , " context " ) ) ; Node frameNet = Node . NETWORK . withChildAdded ( frame ) . withRenderedChild ( frame ) ; NodeContext c = new NodeContext ( testLibrary , FunctionRepository . of ( ) , ImmutableMap . of ( " frame " , 42.0 ) ) ; List < ? > results = c . renderNode ( frameNet ) ; assertResultsEqual ( results , 42.0 ) ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final Viewer viewer = new Viewer ( ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( 600 , 600 ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " frame " , ( double ) frame ) ; data . put ( " mouse.position " , viewer . getLastMousePosition ( ) ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , data , renderResults , ImmutableMap . < String , Object > of ( ) ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < ? > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
public void testPortOverrides ( ) { Node number3 = numberNode . withName ( " number3 " ) . withInputValue ( " number " , 3.0 ) ; Node number5 = numberNode . withName ( " number5 " ) . withInputValue ( " number " , 5.0 ) ; Node net = Node . NETWORK . withChildAdded ( number3 ) . withChildAdded ( number5 ) . withChildAdded ( addNode ) . connect ( " number3 " , " add " , " v1 " ) . connect ( " number5 " , " add " , " v2 " ) . withRenderedChildName ( " add " ) ; With no overrides, the add node returns 8.0 assertResultsEqual(net, addNode, 8.0); ImmutableMap<String,?> overrides = ImmutableMap.of("number3.number", 10.0); NodeContext ctx = new NodeContext(testLibrary, null, ImmutableMap.<String,Object>of(), ImmutableMap.<Node,List<?>>of(), overrides); Iterable<?> values = ctx.renderChild(net, addNode); assertResultsEqual(values, 15.0); } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . translate ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; Visualizer v = VisualizerFactory . getVisualizer ( outputValues , ListUtils . listClass ( outputValues ) ) ; todo: handle canvas clipping v.draw(g2, outputValues); } 
public static BufferedImage createImage ( Iterable < ? > objects ) { Visualizer v = VisualizerFactory . getVisualizer ( objects , ListUtils . listClass ( objects ) ) ; return createImage ( v , objects ) ; } 
public static BufferedImage createMovieImage ( Iterable < ? > objects , int width , int height ) { Visualizer v = VisualizerFactory . getVisualizer ( objects , ListUtils . listClass ( objects ) ) ; BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = img . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( Color . WHITE ) ; g . fillRect ( 0 , 0 , width , height ) ; g . translate ( width / 2 , height / 2 ) ; v . draw ( g , objects ) ; img . flush ( ) ; return img ; } 
private List < ? > evaluatePort ( Node network , Node child , Port childPort , Map < Port , ? > networkArgumentMap ) { Node outputNode = findOutputNode ( network , child , childPort ) ; if ( outputNode ! = null ) { List < ? > result = renderChild ( network , outputNode , networkArgumentMap ) ; 
private List < ? > convertToFileNames ( List < ? > values ) { ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; for ( Object v : values ) { b . add ( convertToFileName ( v ) ) ; } return b . build ( ) ; } 
private static Map < String , Object > emptyResponse ( int statusCode ) { return ImmutableMap . < String , Object > of ( " body " , " " , 
private java . util . List < Node > filterNodes ( java . util . List < Node > nodes , String searchString ) { Pattern findFirstLettersPattern = Pattern . compile ( " ^ " + StringUtils . join ( searchString , " \\ w*_ " ) + " .* " ) ; Pattern findConsecutiveLettersPattern = Pattern . compile ( " .* " + searchString + " .* " ) ; Pattern findNonConsecutiveLettersPattern = Pattern . compile ( " .* " + StringUtils . join ( searchString , " \\ w* " ) + " .* " ) ; java . util . List < Node > sortedNodes = new ArrayList < Node > ( ) ; java . util . List < Node > firstLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > consecutiveLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > nonConsecutiveLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > descriptionNodes = new ArrayList < Node > ( ) ; for ( Node node : nodes ) { if ( node . getName ( ) . equals ( searchString ) ) sortedNodes . add ( node ) ; else if ( findFirstLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) firstLettersNodes . add ( node ) ; else if ( findConsecutiveLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) consecutiveLettersNodes . add ( node ) ; else if ( findNonConsecutiveLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) nonConsecutiveLettersNodes . add ( node ) ; else descriptionNodes . add ( node ) ; } Collections . sort ( firstLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( firstLettersNodes ) ; Collections . sort ( consecutiveLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( consecutiveLettersNodes ) ; Collections . sort ( nonConsecutiveLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( nonConsecutiveLettersNodes ) ; Collections . sort ( descriptionNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( descriptionNodes ) ; return sortedNodes ; } 
public static String join ( String charString , String separator ) { List lst = new ArrayList ( ) ; for ( Character c : charString . toCharArray ( ) ) lst . add ( c ) ; return join ( lst , separator ) ; } 
public void draw ( Graphics2D g ) { visualizer . draw ( g , objects ) ; } 
public void updateValues ( ) { Port port = getPort ( ) ; nameField . setText ( port . getName ( ) ) ; labelField . setText ( port . getLabel ( ) ) ; typeField . setText ( port . getType ( ) ) ; descriptionField . setText ( port . getDescription ( ) ) ; rangeBox . setSelectedItem ( getHumanizedRange ( port . getRange ( ) ) ) ; if ( port . isStandardType ( ) ) { widgetBox . setSelectedItem ( getHumanizedWidget ( port . getWidget ( ) ) ) ; valueField . setText ( port . getValue ( ) . toString ( ) ) ; } else valueField . setEnabled ( false ) ; Object minimumValue = port . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = port . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
private static void writePort ( Document doc , Element parent , Node node , Port port , Port . Direction direction ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = node.getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getInput(port.getName()); If the port and its prototype are equal, don't write anything. if (port.equals(protoPort)) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); el.setAttribute("type", port.getType()); if (shouldWriteAttribute(node, port, Port.Attribute.CHILD_REFERENCE) && port.getChildReference() != null) el.setAttribute("childReference", port.getChildReference()); if (shouldWriteAttribute(node, port, Port.Attribute.WIDGET)) el.setAttribute("widget", port.getWidget().toString().toLowerCase()); if (shouldWriteAttribute(node, port, Port.Attribute.RANGE)) el.setAttribute("range", port.getRange().toString().toLowerCase()); if (port.isStandardType()) el.setAttribute("value", port.stringValue()); if (shouldWriteAttribute(node, port, Port.Attribute.DESCRIPTION)) el.setAttribute("description", port.getDescription()); if (shouldWriteAttribute(node, port, Port.Attribute.MINIMUM_VALUE)) if (port.getMinimumValue() != null) el.setAttribute("min", String.format(Locale.US, "%s", port.getMinimumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MAXIMUM_VALUE)) if (port.getMaximumValue() != null) el.setAttribute("max", String.format(Locale.US, "%s", port.getMaximumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MENU_ITEMS)) writeMenuItems(doc, el, port.getMenuItems()); parent.appendChild(el); } 
private static Port parsePort ( XMLStreamReader reader , Port prototype ) throws XMLStreamException { Name and type are always required. String name = reader.getAttributeValue(null, "name"); String type = reader.getAttributeValue(null, "type"); String childReference = reader.getAttributeValue(null, "childReference"); String widget = reader.getAttributeValue(null, "widget"); String range = reader.getAttributeValue(null, "range"); String value = reader.getAttributeValue(null, "value"); String description = reader.getAttributeValue(null, "description"); String min = reader.getAttributeValue(null, "min"); String max = reader.getAttributeValue(null, "max"); Port port; if (prototype == null) { port = Port.portForType(name, type); } else { port = prototype; } Widget, value, min, max are optional and could come from the prototype. if (childReference != null) port = port.withParsedAttribute(Port.Attribute.CHILD_REFERENCE, childReference); if (widget != null) port = port.withParsedAttribute(Port.Attribute.WIDGET, widget); if (range != null) port = port.withParsedAttribute(Port.Attribute.RANGE, range); if (value != null) port = port.withParsedAttribute(Port.Attribute.VALUE, value); if (description != null) port = port.withParsedAttribute(Port.Attribute.DESCRIPTION, description); if (min != null) port = port.withParsedAttribute(Port.Attribute.MINIMUM_VALUE, min); if (max != null) port = port.withParsedAttribute(Port.Attribute.MAXIMUM_VALUE, max); ImmutableList.Builder<MenuItem> b = ImmutableList.builder(); while (true) { int eventType = reader.next(); if (eventType == XMLStreamConstants.START_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("menu")) { b.add(parseMenuItem(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("port")) break; } } ImmutableList<MenuItem> items = b.build(); if (!items.isEmpty()) port = port.withMenuItems(items); return port; } 
public static Port publishedPort ( Node childNode , Port childPort , String publishedName ) { checkNotNull ( childNode ) ; checkNotNull ( childPort ) ; String childReference = buildChildReference ( childNode , childPort ) ; return new Port ( publishedName , childPort . getType ( ) , childReference , childPort . getWidget ( ) , childPort . getRange ( ) , childPort . getValue ( ) , childPort . getDescription ( ) , childPort . getMinimumValue ( ) , childPort . getMaximumValue ( ) , childPort . getMenuItems ( ) ) ; } 
public static Port portForType ( String name , String type ) { checkNotNull ( type , " Type cannot be null. " ) ; If the type is not found in the default values, get() returns null, which is what we need for custom types. return new Port(name, type, null, defaultWidgetForType(type), DEFAULT_RANGE, DEFAULT_VALUES.get(type), "", null, null, ImmutableList.<MenuItem>of()); } 
public static Port parsedPort ( String name , String type , String stringValue ) { return parsedPort ( name , type , " " , DEFAULT_RANGE . toString ( ) . toLowerCase ( ) , stringValue , " " , null , null , ImmutableList . < MenuItem > of ( ) ) ; } 
public static Port parsedPort ( String name , String type , String widgetString , String rangeString , String valueString , String description , String minString , String maxString , ImmutableList < MenuItem > menuItems ) { checkNotNull ( name , " Name cannot be null. " ) ; checkNotNull ( type , " Type cannot be null. " ) ; if ( STANDARD_TYPES . contains ( type ) ) { Object value ; 
public Port withDescription ( String description ) { return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , description , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withChildReference ( Node childNode , Port childPort ) { checkNotNull ( childNode ) ; checkNotNull ( childPort ) ; String childReference = buildChildReference ( childNode , childPort ) ; return new Port ( getName ( ) , getType ( ) , childReference , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withValue ( Object value ) { checkState ( isStandardType ( ) , " You can only change the value of a standard type. " ) ; checkArgument ( correctValueForType ( value ) , " Value '%s' is not correct for %s port. " , value , getType ( ) ) ; return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , clampValue ( convertValue ( getType ( ) , value ) ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withWidget ( Widget widget ) { return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , widget , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withRange ( Range range ) { return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , range , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withMinimumValue ( Double minimumValue ) { checkArgument ( type . equals ( Port . TYPE_INT ) | | type . equals ( Port . TYPE_FLOAT ) , " You can only set a minimum value on int or float ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , minimumValue , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withMaximumValue ( Double maximumValue ) { checkArgument ( type . equals ( Port . TYPE_INT ) | | type . equals ( Port . TYPE_FLOAT ) , " You can only set a maximum value on int or float ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , maximumValue , getMenuItems ( ) ) ; } 
public Port withMenuItems ( Iterable < MenuItem > items ) { checkNotNull ( items ) ; checkArgument ( type . equals ( Port . TYPE_STRING ) , " You can only use menu items on string ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , items ) ; } 
public Port withParsedAttribute ( Attribute attribute , String valueString ) { checkNotNull ( valueString ) ; String name = this . name ; String type = this . type ; String childReference = this . childReference ; Widget widget = this . widget ; Range range = this . range ; Object value = this . value ; String description = this . description ; Double minimumValue = this . minimumValue ; Double maximumValue = this . maximumValue ; switch ( attribute ) { case DESCRIPTION : description = valueString ; break ; case CHILD_REFERENCE : childReference = valueString ; break ; case VALUE : checkArgument ( STANDARD_TYPES . contains ( type ) , " Port %s: you can only set the value for one of the standard types, not %s (value=%s) " , name , type , valueString ) ; value = parseValue ( type , valueString ) ; break ; case WIDGET : widget = parseWidget ( valueString ) ; break ; case RANGE : range = parseRange ( valueString ) ; break ; case MINIMUM_VALUE : minimumValue = Double . valueOf ( valueString ) ; break ; case MAXIMUM_VALUE : maximumValue = Double . valueOf ( valueString ) ; break ; default : throw new AssertionError ( " You cannot use withParsedAttribute with attribute " + attribute ) ; } return new Port ( name , type , childReference , widget , range , value , description , minimumValue , maximumValue , getMenuItems ( ) ) ; } 
public void openExamplesBrowser ( ) { if ( examplesBrowser = = null ) { examplesBrowser = new ExamplesBrowser ( ) ; } examplesBrowser . setVisible ( true ) ; examplesBrowser . toFront ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { selectCategory ( f ) ; } 
private void selectCategory ( File categoryFolder ) { List < Example > examples = getExamples ( categoryFolder ) ; examplesPanel . removeAll ( ) ; for ( final Example e : examples ) { JButton b = new JButton ( e . name , new ImageIcon ( e . thumbnail ) ) ; b . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { openExample ( e ) ; } } ) ; examplesPanel . add ( b ) ; } examplesPanel . validate ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { openExample ( e ) ; } 
private void openExample ( Example example ) { Application . getInstance ( ) . openDocument ( example . file ) ; } 
public boolean accept ( File file ) { return file . isDirectory ( ) & & ! file . isHidden ( ) ; } 
public boolean accept ( File projectDirectory ) { if ( ! projectDirectory . isDirectory ( ) ) return false ; return nodeBoxFileForDirectory ( projectDirectory ) . exists ( ) ; } 
public static File nodeBoxFileForDirectory ( File projectDirectory ) { return new File ( projectDirectory , projectDirectory . getName ( ) + " .ndbx " ) ; } 
public static Image thumbnailForLibraryFile ( File nodeBoxFile ) { if ( nodeBoxFile = = null ) return DEFAULT_EXAMPLE_IMAGE ; File projectDirectory = nodeBoxFile . getParentFile ( ) ; String baseName = FileUtils . getBaseName ( nodeBoxFile . getName ( ) ) ; File imageFile = new File ( projectDirectory , baseName + " .png " ) ; if ( imageFile . exists ( ) ) { try { 
public static Example fromNodeLibrary ( File nodeBoxFile , Map < String , String > propertyMap ) { String name = FileUtils . getBaseName ( nodeBoxFile . getName ( ) ) ; String title = getProperty ( propertyMap , " title " , name ) ; String description = getProperty ( propertyMap , " description " , " " ) ; String category = getProperty ( propertyMap , " category " , " Uncategorized " ) ; String subCategory = getProperty ( propertyMap , " subCategory " , " Uncategorized " ) ; Image thumbnail = thumbnailForLibraryFile ( nodeBoxFile ) ; return new Example ( nodeBoxFile , name , title , description , category , subCategory , thumbnail ) ; } 
public static void main ( String [ ] args ) { ExamplesBrowser browser = new ExamplesBrowser ( ) ; browser . setVisible ( true ) ; browser . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; } 
public void actionPerformed ( ActionEvent e ) { Application . getInstance ( ) . openExamplesBrowser ( ) ; } 
public static Map < String , String > parseHeader ( File f ) { try { XMLInputFactory xmlInputFactory = XMLInputFactory . newInstance ( ) ; XMLStreamReader reader = xmlInputFactory . createXMLStreamReader ( new FileReader ( f ) ) ; while ( reader . hasNext ( ) ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) { return parseHeader ( reader ) ; } else { throw new XMLStreamException ( " Only tag ndbx allowed, not " + tagName , reader . getLocation ( ) ) ; } } } } catch ( XMLStreamException e ) { throw new RuntimeException ( e ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } return Collections . emptyMap ( ) ; } 
private static Map < String , String > parseHeader ( XMLStreamReader reader ) throws XMLStreamException { Map < String , String > propertyMap = new HashMap < String , String > ( ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " property " ) ) { parseProperty ( reader , propertyMap ) ; } } else if ( eventType = = XMLStreamConstants . END_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) break ; } } return propertyMap ; } 
public void silentSet ( String portName , Object value ) { try { setValue ( getActiveNodePath ( ) , portName , value ) ; 
private PortControl constructControl ( Class controlClass , String activeNodePath , Port p ) { try { Constructor constructor = controlClass . getConstructor ( String . class , Port . class ) ; 
public void onValueChange ( String nodePath , String portName , Object newValue ) { document . setValue ( nodePath , portName , newValue ) ; } 
public Port getPort ( ) ; public String getDisplayName ( ) ; public void setDisplayName ( String displayName ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public String getDisplayName ( ) ; public void setDisplayName ( String displayName ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public void setDisplayName ( String displayName ) ; public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public void setValueForControl ( Object v ) ; public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public boolean isEnabled ( ) ; public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public boolean isVisible ( ) ; public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public void setValueChangeListener ( OnValueChangeListener l ) ; public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public OnValueChangeListener getValueChangeListener ( ) ; public static interface OnValueChangeListener { public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public void onValueChange ( String nodePath , String portName , Object newValue ) ; } } 
public void update ( ) ; public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void draw ( GraphicsContext ctx ) ; public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public void setVisible ( boolean visible ) ; public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean isVisible ( ) ; Mouse events public boolean mouseClicked(Point pt); public boolean mousePressed(Point pt); public boolean mouseReleased(Point pt); public boolean mouseEntered(Point pt); public boolean mouseExited(Point pt); public boolean mouseDragged(Point pt); public boolean mouseMoved(Point pt); public boolean keyTyped(int keyCode, int modifiers); public boolean keyPressed(int keyCode, int modifiers); public boolean keyReleased(int keyCode, int modifiers); Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseClicked ( Point pt ) ; public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mousePressed ( Point pt ) ; public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseReleased ( Point pt ) ; public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseEntered ( Point pt ) ; public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseExited ( Point pt ) ; public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseDragged ( Point pt ) ; public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean mouseMoved ( Point pt ) ; public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyTyped ( int keyCode , int modifiers ) ; public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyPressed ( int keyCode , int modifiers ) ; public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean keyReleased ( int keyCode , int modifiers ) ; Node update methods public boolean hasInput(String portName); public boolean isConnected(String portName); public Object getValue(String portName); public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean hasInput ( String portName ) ; public boolean isConnected ( String portName ) ; public Object getValue ( String portName ) ; public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean isConnected ( String portName ) ; public Object getValue ( String portName ) ; public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public Object getValue ( String portName ) ; public void updateHandle(); Event listener public HandleDelegate getHandleDelegate(); public void setHandleDelegate(HandleDelegate delegate);} 
public boolean hasInput ( String portName ) ; public boolean isConnected ( String portName ) ; public void updateHandle ( ) ; } 
public boolean isConnected ( String portName ) ; public void updateHandle ( ) ; } 
public Object getValue ( String portName ) ; public void updateHandle ( ) ; } 
public void setValue ( String nodePath , String portName , Object value ) ; public void updateHandle ( ) ; } 
private static DeviceHandler createAudioPlayerDeviceHandler ( Device device ) { String fileName = device . getProperty ( " filename " , " " ) ; AudioPlayerDeviceHandler handler = new AudioPlayerDeviceHandler ( device . getName ( ) , fileName ) ; return handler ; } 
public void actionPerformed ( ActionEvent actionEvent ) { File f = FileUtils . showOpenDialog ( null , getFileName ( ) , " mp3,wav " , " Music files " ) ; if ( f ! = null ) { File libraryFile = NodeBoxDocument . getCurrentDocument ( ) . getDocumentFile ( ) ; 
private void selectCategory ( File categoryFolder ) { List < Example > examples = getExamples ( categoryFolder ) ; examplesPanel . removeAll ( ) ; for ( final Example e : examples ) { ExampleButton b = new ExampleButton ( e . title , new ImageIcon ( e . thumbnail ) ) ; b . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { openExample ( e ) ; } } ) ; examplesPanel . add ( b ) ; } examplesPanel . validate ( ) ; } 
public static Example fromNodeLibrary ( File nodeBoxFile , Map < String , String > propertyMap ) { String name = FileUtils . getBaseName ( nodeBoxFile . getName ( ) ) ; String title = getProperty ( propertyMap , " title " , name ) ; String description = getProperty ( propertyMap , " description " , " " ) ; String category = getProperty ( propertyMap , " category " , " Uncategorized " ) ; String subCategory = getProperty ( propertyMap , " subCategory " , " Uncategorized " ) ; Image thumbnail = thumbnailForLibraryFile ( nodeBoxFile ) ; return new Example ( nodeBoxFile , name , title , description , category , subCategory , thumbnail ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; getIcon ( ) . paintIcon ( this , g , 0 , 0 ) ; g2 . setFont ( EXAMPLE_TITLE_FONT ) ; g2 . setColor ( EXAMPLE_TITLE_COLOR ) ; g2 . drawString ( getText ( ) , 1 , 117 ) ; } 
public void addLayoutComponent ( String s , Component component ) { components . add ( component ) ; 
public void removeLayoutComponent ( Component component ) { components . remove ( component ) ; } 
public Dimension preferredLayoutSize ( Container container ) { return container . getSize ( ) ; } 
public Dimension minimumLayoutSize ( Container container ) { return container . getSize ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { for ( CategoryButton b : categoryButtons ) { b . setActive ( false ) ; } b . setActive ( true ) ; selectCategory ( f ) ; } 
private void selectCategory ( File categoryFolder ) { List < Example > examples = getExamples ( categoryFolder ) ; examplesPanel . removeAll ( ) ; for ( final Example e : examples ) { ExampleButton b = new ExampleButton ( e . title , new ImageIcon ( e . thumbnail ) ) ; b . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { openExample ( e ) ; } } ) ; examplesPanel . add ( b ) ; } examplesPanel . validate ( ) ; examplesPanel . repaint ( ) ; } 
protected void paintComponent ( Graphics g ) { g . setColor ( new Color ( 240 , 240 , 240 ) ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) - 1 ) ; g . setColor ( new Color ( 200 , 200 , 200 ) ) ; g . drawLine ( 0 , getHeight ( ) - 1 , getWidth ( ) , getHeight ( ) - 1 ) ; } 
private boolean isActive ( ) { return active ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( active ) { g2 . setColor ( new Color ( 2 , 164 , 228 ) ) ; g2 . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; } else { g2 . setColor ( new Color ( 255 , 255 , 255 ) ) ; g2 . drawLine ( 0 , 0 , 0 , getHeight ( ) - 2 ) ; g2 . setColor ( new Color ( 210 , 210 , 210 ) ) ; g2 . drawLine ( getWidth ( ) - 1 , 0 , getWidth ( ) - 1 , getHeight ( ) - 2 ) ; } g2 . setFont ( new Font ( Font . DIALOG , Font . BOLD , 14 ) ) ; if ( active ) { g2 . setColor ( Color . WHITE ) ; } else { g2 . setColor ( new Color ( 160 , 160 , 160 ) ) ; } g2 . drawString ( getText ( ) , 10 , 20 ) ; 
private java . util . List < Node > filterNodes ( java . util . List < Node > nodes , String searchString ) { Pattern findFirstLettersPattern = Pattern . compile ( " ^ " + StringUtils . join ( searchString , " \\ w*_ " ) + " .* " ) ; Pattern findConsecutiveLettersPattern = Pattern . compile ( " .* " + searchString + " .* " ) ; Pattern findNonConsecutiveLettersPattern = Pattern . compile ( " .* " + StringUtils . join ( searchString , " \\ w* " ) + " .* " ) ; java . util . List < Node > sortedNodes = new ArrayList < Node > ( ) ; java . util . List < Node > firstLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > consecutiveLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > nonConsecutiveLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > descriptionNodes = new ArrayList < Node > ( ) ; for ( Node node : nodes ) { if ( node . getName ( ) . equals ( searchString ) ) sortedNodes . add ( node ) ; else if ( findFirstLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) firstLettersNodes . add ( node ) ; else if ( findConsecutiveLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) consecutiveLettersNodes . add ( node ) ; else if ( findNonConsecutiveLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) nonConsecutiveLettersNodes . add ( node ) ; else if ( node . getDescription ( ) . contains ( searchString ) ) descriptionNodes . add ( node ) ; } Collections . sort ( firstLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( firstLettersNodes ) ; Collections . sort ( consecutiveLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( consecutiveLettersNodes ) ; Collections . sort ( nonConsecutiveLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( nonConsecutiveLettersNodes ) ; Collections . sort ( descriptionNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( descriptionNodes ) ; return sortedNodes ; } 
protected void onViewTransformChanged ( double viewX , double viewY , double viewScale ) { document . setActiveNetworkPanZoom ( viewX , viewY , viewScale ) ; } 
public void updateValues ( ) { Port port = getPort ( ) ; nameField . setText ( port . getName ( ) ) ; labelField . setText ( port . getDisplayLabel ( ) ) ; typeField . setText ( port . getType ( ) ) ; descriptionField . setText ( port . getDescription ( ) ) ; rangeBox . setSelectedItem ( getHumanizedRange ( port . getRange ( ) ) ) ; if ( port . isStandardType ( ) ) { widgetBox . setSelectedItem ( getHumanizedWidget ( port . getWidget ( ) ) ) ; valueField . setText ( port . getValue ( ) . toString ( ) ) ; } else valueField . setEnabled ( false ) ; Object minimumValue = port . getMinimumValue ( ) ; String minimumValueString = minimumValue = = null ? " " : minimumValue . toString ( ) ; minimumValueCheck . setSelected ( minimumValue ! = null ) ; minimumValueField . setText ( minimumValueString ) ; minimumValueField . setEnabled ( minimumValue ! = null ) ; Object maximumValue = port . getMaximumValue ( ) ; String maximumValueString = maximumValue = = null ? " " : maximumValue . toString ( ) ; maximumValueCheck . setSelected ( maximumValue ! = null ) ; maximumValueField . setText ( maximumValueString ) ; maximumValueField . setEnabled ( maximumValue ! = null ) ; menuItemsTable . tableChanged ( new TableModelEvent ( menuItemsTable . getModel ( ) ) ) ; revalidate ( ) ; } 
private static void writePort ( Document doc , Element parent , Node node , Port port , Port . Direction direction ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = node.getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getInput(port.getName()); If the port and its prototype are equal, don't write anything. if (port.equals(protoPort)) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); el.setAttribute("type", port.getType()); if (shouldWriteAttribute(node, port, Port.Attribute.LABEL)) el.setAttribute("label", port.getLabel()); if (shouldWriteAttribute(node, port, Port.Attribute.CHILD_REFERENCE) && port.getChildReference() != null) el.setAttribute("childReference", port.getChildReference()); if (shouldWriteAttribute(node, port, Port.Attribute.WIDGET)) el.setAttribute("widget", port.getWidget().toString().toLowerCase()); if (shouldWriteAttribute(node, port, Port.Attribute.RANGE)) el.setAttribute("range", port.getRange().toString().toLowerCase()); if (port.isStandardType()) el.setAttribute("value", port.stringValue()); if (shouldWriteAttribute(node, port, Port.Attribute.DESCRIPTION)) el.setAttribute("description", port.getDescription()); if (shouldWriteAttribute(node, port, Port.Attribute.MINIMUM_VALUE)) if (port.getMinimumValue() != null) el.setAttribute("min", String.format(Locale.US, "%s", port.getMinimumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MAXIMUM_VALUE)) if (port.getMaximumValue() != null) el.setAttribute("max", String.format(Locale.US, "%s", port.getMaximumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MENU_ITEMS)) writeMenuItems(doc, el, port.getMenuItems()); parent.appendChild(el); } 
private static Port parsePort ( XMLStreamReader reader , Port prototype ) throws XMLStreamException { Name and type are always required. String name = reader.getAttributeValue(null, "name"); String type = reader.getAttributeValue(null, "type"); String label = reader.getAttributeValue(null, "label"); String childReference = reader.getAttributeValue(null, "childReference"); String widget = reader.getAttributeValue(null, "widget"); String range = reader.getAttributeValue(null, "range"); String value = reader.getAttributeValue(null, "value"); String description = reader.getAttributeValue(null, "description"); String min = reader.getAttributeValue(null, "min"); String max = reader.getAttributeValue(null, "max"); Port port; if (prototype == null) { port = Port.portForType(name, type); } else { port = prototype; } Widget, value, min, max are optional and could come from the prototype. if (label != null) port = port.withParsedAttribute(Port.Attribute.LABEL, label); if (childReference != null) port = port.withParsedAttribute(Port.Attribute.CHILD_REFERENCE, childReference); if (widget != null) port = port.withParsedAttribute(Port.Attribute.WIDGET, widget); if (range != null) port = port.withParsedAttribute(Port.Attribute.RANGE, range); if (value != null) port = port.withParsedAttribute(Port.Attribute.VALUE, value); if (description != null) port = port.withParsedAttribute(Port.Attribute.DESCRIPTION, description); if (min != null) port = port.withParsedAttribute(Port.Attribute.MINIMUM_VALUE, min); if (max != null) port = port.withParsedAttribute(Port.Attribute.MAXIMUM_VALUE, max); ImmutableList.Builder<MenuItem> b = ImmutableList.builder(); while (true) { int eventType = reader.next(); if (eventType == XMLStreamConstants.START_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("menu")) { b.add(parseMenuItem(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("port")) break; } } ImmutableList<MenuItem> items = b.build(); if (!items.isEmpty()) port = port.withMenuItems(items); return port; } 
public static Port publishedPort ( Node childNode , Port childPort , String publishedName ) { checkNotNull ( childNode ) ; checkNotNull ( childPort ) ; String childReference = buildChildReference ( childNode , childPort ) ; return new Port ( publishedName , childPort . getType ( ) , " " , childReference , childPort . getWidget ( ) , childPort . getRange ( ) , childPort . getValue ( ) , childPort . getDescription ( ) , childPort . getMinimumValue ( ) , childPort . getMaximumValue ( ) , childPort . getMenuItems ( ) ) ; } 
public static Port portForType ( String name , String type ) { checkNotNull ( type , " Type cannot be null. " ) ; If the type is not found in the default values, get() returns null, which is what we need for custom types. return new Port(name, type, "", null, defaultWidgetForType(type), DEFAULT_RANGE, DEFAULT_VALUES.get(type), "", null, null, ImmutableList.<MenuItem>of()); } 
public static Port parsedPort ( String name , String type , String stringValue ) { return parsedPort ( name , type , " " , " " , DEFAULT_RANGE . toString ( ) . toLowerCase ( ) , stringValue , " " , null , null , ImmutableList . < MenuItem > of ( ) ) ; } 
public static Port parsedPort ( String name , String type , String label , String widgetString , String rangeString , String valueString , String description , String minString , String maxString , ImmutableList < MenuItem > menuItems ) { checkNotNull ( name , " Name cannot be null. " ) ; checkNotNull ( type , " Type cannot be null. " ) ; if ( STANDARD_TYPES . contains ( type ) ) { Object value ; 
public Port withLabel ( String label ) { return new Port ( getName ( ) , getType ( ) , label , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withDescription ( String description ) { return new Port ( getName ( ) , getType ( ) , getLabel ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , description , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withChildReference ( Node childNode , Port childPort ) { checkNotNull ( childNode ) ; checkNotNull ( childPort ) ; String childReference = buildChildReference ( childNode , childPort ) ; return new Port ( getName ( ) , getType ( ) , this . label , childReference , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withValue ( Object value ) { checkState ( isStandardType ( ) , " You can only change the value of a standard type. " ) ; checkArgument ( correctValueForType ( value ) , " Value '%s' is not correct for %s port. " , value , getType ( ) ) ; return new Port ( getName ( ) , getType ( ) , getLabel ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , clampValue ( convertValue ( getType ( ) , value ) ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withWidget ( Widget widget ) { return new Port ( getName ( ) , getType ( ) , getLabel ( ) , getChildReference ( ) , widget , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withRange ( Range range ) { return new Port ( getName ( ) , getType ( ) , getLabel ( ) , getChildReference ( ) , getWidget ( ) , range , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withMinimumValue ( Double minimumValue ) { checkArgument ( type . equals ( Port . TYPE_INT ) | | type . equals ( Port . TYPE_FLOAT ) , " You can only set a minimum value on int or float ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getLabel ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , minimumValue , getMaximumValue ( ) , getMenuItems ( ) ) ; } 
public Port withMaximumValue ( Double maximumValue ) { checkArgument ( type . equals ( Port . TYPE_INT ) | | type . equals ( Port . TYPE_FLOAT ) , " You can only set a maximum value on int or float ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getLabel ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , maximumValue , getMenuItems ( ) ) ; } 
public Port withMenuItems ( Iterable < MenuItem > items ) { checkNotNull ( items ) ; checkArgument ( type . equals ( Port . TYPE_STRING ) , " You can only use menu items on string ports, not %s " , this ) ; return new Port ( getName ( ) , getType ( ) , getLabel ( ) , getChildReference ( ) , getWidget ( ) , getRange ( ) , getValue ( ) , getDescription ( ) , getMinimumValue ( ) , getMaximumValue ( ) , items ) ; } 
public Port withParsedAttribute ( Attribute attribute , String valueString ) { checkNotNull ( valueString ) ; String name = this . name ; String type = this . type ; String label = this . label ; String childReference = this . childReference ; Widget widget = this . widget ; Range range = this . range ; Object value = this . value ; String description = this . description ; Double minimumValue = this . minimumValue ; Double maximumValue = this . maximumValue ; switch ( attribute ) { case LABEL : label = valueString ; break ; case DESCRIPTION : description = valueString ; break ; case CHILD_REFERENCE : childReference = valueString ; break ; case VALUE : checkArgument ( STANDARD_TYPES . contains ( type ) , " Port %s: you can only set the value for one of the standard types, not %s (value=%s) " , name , type , valueString ) ; value = parseValue ( type , valueString ) ; break ; case WIDGET : widget = parseWidget ( valueString ) ; break ; case RANGE : range = parseRange ( valueString ) ; break ; case MINIMUM_VALUE : minimumValue = Double . valueOf ( valueString ) ; break ; case MAXIMUM_VALUE : maximumValue = Double . valueOf ( valueString ) ; break ; default : throw new AssertionError ( " You cannot use withParsedAttribute with attribute " + attribute ) ; } return new Port ( name , type , label , childReference , widget , range , value , description , minimumValue , maximumValue , getMenuItems ( ) ) ; } 
public List < ? > renderNode ( Node node , Map < Port , ? > argumentMap ) { checkNotNull ( node ) ; checkNotNull ( functionRepository ) ; If the node has children, forgo the operation of the current node and evaluate the child. Object result; if (node.isNetwork()) { if (node.hasRenderedChild()) result = renderChild(node, node.getRenderedChild(), argumentMap); else result = ImmutableList.of(); } else { result = invokeNode(node, argumentMap); } List<?> results = postProcessResult(node, result); renderResults.put(node, results); return results; } 
public void testRenderEmptyNetwork ( ) { Node network = Node . NETWORK ; assertResultsEqual ( network ) ; } 
public void testNestedFilter ( ) { Node makeNestedWords = Node . ROOT . withName ( " makeNestedWords " ) . withFunction ( " test/makeNestedWords " ) . withOutputType ( " string " ) . withOutputRange ( Port . Range . LIST ) ; Node length = Node . ROOT . withName ( " length " ) . withFunction ( " string/length " ) . withOutputType ( " string " ) . withInputAdded ( Port . stringPort ( " text " , " " ) ) ; Node lengthNet = Node . NETWORK . withName ( " lengthNet " ) . withChildAdded ( length ) . publish ( " length " , " text " , " text " ) . withRenderedChild ( length ) . withOutputRange ( Port . Range . VALUE ) ; Port textPort = lengthNet . getInput ( " text " ) . withRange ( Port . Range . VALUE ) ; lengthNet = lengthNet . withInputChanged ( " text " , textPort ) ; Node mainNetwork = Node . NETWORK . withChildAdded ( makeNestedWords ) . withChildAdded ( lengthNet ) . connect ( " makeNestedWords " , " lengthNet " , " text " ) . withRenderedChild ( lengthNet ) ; List < Integer > aCounts = ImmutableList . of ( 5 , 11 , 9 ) ; List < Integer > bCounts = ImmutableList . of ( 6 , 4 , 4 ) ; List < Integer > cCounts = ImmutableList . of ( 5 , 8 , 6 ) ; assertResultsEqual ( mainNetwork , aCounts , bCounts , cCounts ) ; } 
public static String join ( String charString , String separator ) { List < Character > lst = new ArrayList < Character > ( ) ; for ( Character c : charString . toCharArray ( ) ) lst . add ( c ) ; return join ( lst , separator ) ; } 
public static Example fromNodeLibrary ( File nodeBoxFile , Map < String , String > propertyMap ) { String name = FileUtils . getBaseName ( nodeBoxFile . getName ( ) ) ; String title = getProperty ( propertyMap , " title " , name ) ; String description = getProperty ( propertyMap , " description " , " " ) ; Image thumbnail = thumbnailForLibraryFile ( nodeBoxFile ) ; return new Example ( nodeBoxFile , name , title , description , thumbnail ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { reload ( ) ; } 
private void selectSubCategory ( SubCategory subCategory ) { List < Example > examples = subCategory . examples ; examplesPanel . removeAll ( ) ; for ( final Example e : examples ) { ExampleButton b = new ExampleButton ( e . title , new ImageIcon ( e . thumbnail ) ) ; b . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { openExample ( e ) ; } } ) ; examplesPanel . add ( b ) ; } examplesPanel . validate ( ) ; examplesPanel . repaint ( ) ; } 
public static List < Category > parseCategories ( File parentDirectory ) { File [ ] directories = parentDirectory . listFiles ( new FileFilter ( ) { @Override public boolean accept ( File file ) { return file . isDirectory ( ) & & ! file . isHidden ( ) ; } } ) ; ArrayList < Category > categories = new ArrayList < Category > ( ) ; for ( File d : directories ) { String name = fileToTitle ( d ) ; List < SubCategory > subCategories = parseSubCategories ( d ) ; categories . add ( new Category ( name , d , subCategories ) ) ; } return categories ; } 
private static List < SubCategory > parseSubCategories ( File directory ) { File [ ] directories = directory . listFiles ( new FileFilter ( ) { @Override public boolean accept ( File file ) { return file . isDirectory ( ) & & ! file . isHidden ( ) ; } } ) ; ArrayList < SubCategory > subCategories = new ArrayList < SubCategory > ( ) ; for ( File d : directories ) { String name = fileToTitle ( d ) ; List < Example > examples = parseExamples ( d ) ; subCategories . add ( new SubCategory ( name , d , examples ) ) ; } return subCategories ; } 
public static List < Example > parseExamples ( File directory ) { File [ ] directories = directory . listFiles ( new FileFilter ( ) { @Override public boolean accept ( File projectDirectory ) { return projectDirectory . isDirectory ( ) & & nodeBoxFileForDirectory ( projectDirectory ) . exists ( ) ; } } ) ; ArrayList < Example > examples = new ArrayList < Example > ( ) ; for ( File projectDirectory : directories ) { File nodeBoxFile = nodeBoxFileForDirectory ( projectDirectory ) ; Map < String , String > propertyMap = NodeLibrary . parseHeader ( nodeBoxFile ) ; examples . add ( Example . fromNodeLibrary ( nodeBoxFile , propertyMap ) ) ; } return examples ; } 
public boolean accept ( File projectDirectory ) { return projectDirectory . isDirectory ( ) & & nodeBoxFileForDirectory ( projectDirectory ) . exists ( ) ; } 
public static String fileToTitle ( File file ) { String baseName = FileUtils . getBaseName ( file . getName ( ) ) ; return NUMBERS_PREFIX_PATTERN . matcher ( baseName ) . replaceFirst ( " " ) ; } 
public static Example fromNodeLibrary ( File nodeBoxFile , Map < String , String > propertyMap ) { String title = getProperty ( propertyMap , " title " , fileToTitle ( nodeBoxFile ) ) ; String description = getProperty ( propertyMap , " description " , " " ) ; Image thumbnail = thumbnailForLibraryFile ( nodeBoxFile ) ; return new Example ( nodeBoxFile , title , description , thumbnail ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; if ( isSelected ( ) ) { g2 . setColor ( new Color ( 2 , 164 , 228 ) ) ; g2 . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; } else { g2 . setColor ( new Color ( 255 , 255 , 255 ) ) ; g2 . drawLine ( 0 , 0 , 0 , getHeight ( ) - 2 ) ; g2 . setColor ( new Color ( 210 , 210 , 210 ) ) ; g2 . drawLine ( getWidth ( ) - 1 , 0 , getWidth ( ) - 1 , getHeight ( ) - 2 ) ; } g2 . setFont ( new Font ( Font . DIALOG , Font . BOLD , 14 ) ) ; if ( isSelected ( ) ) { g2 . setColor ( Color . WHITE ) ; } else { g2 . setColor ( new Color ( 160 , 160 , 160 ) ) ; } g2 . drawString ( getText ( ) , 10 , 20 ) ; 
protected void paintComponent ( Graphics g ) { if ( isSelected ( ) ) { g . setColor ( new Color ( 2 , 164 , 228 ) ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; } g . setFont ( Theme . SMALL_FONT ) ; if ( isSelected ( ) ) { g . setColor ( Color . WHITE ) ; } else { g . setColor ( Color . BLACK ) ; } g . drawString ( getText ( ) , 5 , 20 ) ; } 
private static void forceSize ( Component c , int width , int height ) { Dimension d = new Dimension ( width , height ) ; c . setSize ( d ) ; c . setMinimumSize ( d ) ; c . setMaximumSize ( d ) ; c . setPreferredSize ( d ) ; } 
protected void paintComponent ( Graphics g ) { g . setColor ( new Color ( 210 , 210 , 210 ) ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; g . setColor ( new Color ( 225 , 225 , 225 ) ) ; g . drawLine ( 0 , 0 , getWidth ( ) , 0 ) ; g . setColor ( new Color ( 136 , 136 , 136 ) ) ; g . drawLine ( 0 , getHeight ( ) - 1 , getWidth ( ) , getHeight ( ) - 1 ) ; } 
private static void drawVLine ( Graphics g , int x , int y , int height ) { g . drawLine ( x , y , x , y + height ) ; } 
private static void drawHLine ( Graphics g , int x , int y , int width ) { g . drawLine ( x , y , x + width , y ) ; } 
protected void paintComponent ( Graphics g ) { g . setColor ( new Color ( 153 , 153 , 153 ) ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; g . setColor ( new Color ( 146 , 146 , 146 ) ) ; drawVLine ( g , getWidth ( ) - 3 , 0 , getHeight ( ) ) ; g . setColor ( new Color ( 133 , 133 , 133 ) ) ; drawVLine ( g , getWidth ( ) - 2 , 0 , getHeight ( ) ) ; g . setColor ( new Color ( 112 , 112 , 112 ) ) ; drawVLine ( g , getWidth ( ) - 1 , 0 , getHeight ( ) ) ; } 
protected void paintComponent ( Graphics g ) { int hMargin = 4 ; int vMargin = 3 ; Rectangle r = new Rectangle ( 0 , 0 , getWidth ( ) - 1 , getHeight ( ) - 1 ) ; r . grow ( - hMargin , - vMargin ) ; if ( isSelected ( ) ) { g . setColor ( new Color ( 198 , 198 , 198 ) ) ; g . fillRect ( r . x , r . y , r . width , r . height ) ; g . setColor ( new Color ( 166 , 166 , 166 ) ) ; g . drawRect ( r . x + 1 , r . y + 1 , r . width - 2 , r . height - 2 ) ; g . setColor ( new Color ( 119 , 119 , 119 ) ) ; g . drawLine ( r . x , r . y , r . x + r . width , r . y ) ; g . drawLine ( r . x , r . y , r . x , r . y + r . height ) ; g . setColor ( new Color ( 237 , 237 , 237 ) ) ; g . drawLine ( r . x , r . y + r . height , r . x + r . width , r . y + r . height ) ; g . drawLine ( r . x + r . width , r . y , r . x + r . width , r . y + r . height ) ; } else { g . setColor ( new Color ( 179 , 179 , 179 ) ) ; g . drawLine ( 0 , 2 , 0 , getHeight ( ) - 4 ) ; g . setColor ( new Color ( 237 , 237 , 237 ) ) ; g . drawLine ( 1 , 2 , 1 , getHeight ( ) - 4 ) ; } g . setFont ( Theme . SMALL_BOLD_FONT ) ; g . setFont ( Theme . SMALL_BOLD_FONT ) ; if ( isSelected ( ) ) { g . setColor ( Theme . TEXT_NORMAL_COLOR ) ; } else { g . setColor ( Theme . TEXT_HEADER_COLOR ) ; g.setColor(new Color(160, 160, 160)); } drawShadowText((Graphics2D) g, getText(), 10, 18); 
protected void paintComponent ( Graphics g ) { if ( isSelected ( ) ) { g . setColor ( new Color ( 196 , 196 , 196 ) ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; } else if ( isLastButton ( ) ) { g . setColor ( new Color ( 255 , 255 , 255 , 50 ) ) ; drawHLine ( g , 0 , 0 , getWidth ( ) - 2 ) ; g . setColor ( new Color ( 0 , 0 , 0 , 50 ) ) ; drawHLine ( g , 0 , getHeight ( ) - 2 , getWidth ( ) - 2 ) ; g . setColor ( new Color ( 255 , 255 , 255 , 50 ) ) ; drawHLine ( g , 0 , getHeight ( ) - 1 , getWidth ( ) - 2 ) ; } else { g . setColor ( new Color ( 255 , 255 , 255 , 50 ) ) ; drawHLine ( g , 0 , 0 , getWidth ( ) - 1 ) ; g . setColor ( new Color ( 0 , 0 , 0 , 50 ) ) ; drawHLine ( g , 0 , getHeight ( ) - 1 , getWidth ( ) - 1 ) ; } g . setFont ( Theme . SMALL_BOLD_FONT ) ; g . setColor ( Theme . TEXT_NORMAL_COLOR ) ; if ( isSelected ( ) ) { drawShadowText ( ( Graphics2D ) g , getText ( ) , 5 , 20 ) ; 
private boolean isLastButton ( ) { return getParent ( ) . getComponent ( getParent ( ) . getComponentCount ( ) - 1 ) = = SubCategoryButton . this ; } 
protected void paintComponent ( Graphics g ) { getIcon ( ) . paintIcon ( this , g , 0 , 0 ) ; g . setColor ( new Color ( 140 , 140 , 140 ) ) ; drawHLine ( g , 0 , 0 , 149 ) ; drawVLine ( g , 0 , 0 , 100 ) ; g . setColor ( new Color ( 237 , 237 , 237 ) ) ; drawHLine ( g , 0 , 100 , 149 ) ; drawVLine ( g , 149 , 0 , 100 ) ; g . setColor ( new Color ( 166 , 166 , 166 , 100 ) ) ; g . drawRect ( 1 , 1 , 147 , 98 ) ; g . setFont ( Theme . SMALL_BOLD_FONT ) ; g . setColor ( Theme . TEXT_NORMAL_COLOR ) ; drawShadowText ( ( Graphics2D ) g , getText ( ) , 0 , 113 ) ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final Viewer viewer = new Viewer ( ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( 600 , 600 ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " frame " , ( double ) frame ) ; data . put ( " mouse.position " , viewer . getLastMousePosition ( ) ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , data , renderResults , ImmutableMap . < String , Object > of ( ) ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < ? > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
public static String encodeURL ( final String s ) { try { return URLEncoder . encode ( s , " UTF-8 " ) ; 
public void testEncodeURL ( ) { assertEquals ( " foo " , NetworkFunctions . encodeURL ( " foo " ) ) ; assertEquals ( " foo+bar " , NetworkFunctions . encodeURL ( " foo bar " ) ) ; assertEquals ( " foo+%26+bar " , NetworkFunctions . encodeURL ( " foo & bar " ) ) ; } 
public void componentResized ( ComponentEvent e ) { updateExamplesPanelSize ( ) ; } 
private void selectSubCategory ( SubCategory subCategory ) { List < Example > examples = subCategory . examples ; examplesPanel . removeAll ( ) ; for ( final Example e : examples ) { ExampleButton b = new ExampleButton ( e . title , new ImageIcon ( e . thumbnail ) ) ; b . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { openExample ( e ) ; } } ) ; examplesPanel . add ( b ) ; } updateExamplesPanelSize ( ) ; examplesPanel . validate ( ) ; examplesPanel . repaint ( ) ; } 
private void updateExamplesPanelSize ( ) { Component scrollPane = examplesPanel . getParent ( ) ; int scrollPaneWidth = scrollPane . getWidth ( ) ; ExampleLayout exampleLayout = ( ExampleLayout ) examplesPanel . getLayout ( ) ; int contentsHeight = exampleLayout . calculateHeight ( examplesPanel , scrollPaneWidth ) ; examplesPanel . setSize ( scrollPaneWidth , contentsHeight ) ; } 
public void mouseEntered ( MouseEvent e ) { requestFocusInWindow ( ) ; } 
private void changedEvent ( ) { if ( filteredNodeListModel . getSearchString ( ) . equals ( searchField . getText ( ) ) ) return ; filteredNodeListModel . setSearchString ( searchField . getText ( ) ) ; Trigger a model reload. nodeList.setSelectedIndex(0); nodeList.ensureIndexIsVisible(0); nodeList.revalidate(); repaint(); } 
public NodeBoxDocument openExample ( File file ) { NodeBoxDocument doc = openDocument ( file ) ; if ( doc ! = null ) { doc . setNeedsResave ( true ) ; } return doc ; } 
private void openExample ( Example example ) { Application . getInstance ( ) . openExample ( example . file ) ; } 
public boolean save ( ) { if ( documentFile = = null | | needsResave ( ) ) { return saveAs ( ) ; 
private void lookForLibraries ( ) { List < NodeLibrary > libraries = new ArrayList < NodeLibrary > ( ) ; libraries . add ( systemLibrary ( " math " ) ) ; libraries . add ( systemLibrary ( " string " ) ) ; libraries . add ( systemLibrary ( " color " ) ) ; libraries . add ( systemLibrary ( " list " ) ) ; libraries . add ( systemLibrary ( " data " ) ) ; libraries . add ( systemLibrary ( " corevector " ) ) ; libraries . add ( systemLibrary ( " network " ) ) ; if ( Application . ENABLE_DEVICE_SUPPORT ) { libraries . add ( systemLibrary ( " device " ) ) ; } systemRepository = NodeRepository . of ( libraries . toArray ( new NodeLibrary [ ] { } ) ) ; } 
private boolean isDeviceSupportEnabled ( ) { return Boolean . valueOf ( preferences . get ( Application . PREFERENCE_ENABLE_DEVICE_SUPPORT , " false " ) ) ; } 
public static NodeLibrary load ( File f , NodeRepository nodeRepository ) throws LoadException { checkNotNull ( f , " File cannot be null. " ) ; String libraryName = FileUtils . stripExtension ( f ) ; try { return load ( libraryName , f , createFileReader ( f ) , nodeRepository ) ; 
public static Map < String , String > parseHeader ( File f ) { try { XMLInputFactory xmlInputFactory = XMLInputFactory . newInstance ( ) ; XMLStreamReader reader = xmlInputFactory . createXMLStreamReader ( createFileReader ( f ) ) ; while ( reader . hasNext ( ) ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) { return parseHeader ( reader ) ; } else { throw new XMLStreamException ( " Only tag ndbx allowed, not " + tagName , reader . getLocation ( ) ) ; } } } } catch ( XMLStreamException e ) { throw new RuntimeException ( e ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } return Collections . emptyMap ( ) ; } 
private static Reader createFileReader ( File file ) throws FileNotFoundException { try { return new InputStreamReader ( new FileInputStream ( file ) , " utf-8 " ) ; 
public static boolean logicOR ( Boolean b1 , Boolean b2 , String comparator ) { if ( comparator . equals ( " or " ) ) { return b1 | | b2 ; 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; nodemenu shows with nodes without comment nodeMenu = new JPopupMenu(); nodeMenu.add(new SetRenderedAction()); nodeMenu.add(new RenameAction()); nodeMenu.add(new DeleteAction()); nodeMenu.add(new GroupIntoNetworkAction(null)); goInSubnetworkMenuItem = nodeMenu.add(new GoInAction()); nodeMenu.add(new AddCommentAction());adds a comment nodeMenu.add(new HelpAction()); nodemenu2 shows with commented nodes nodeMenu2 = new JPopupMenu(); nodeMenu2.add(new SetRenderedAction()); nodeMenu2.add(new RenameAction()); nodeMenu2.add(new DeleteAction()); nodeMenu2.add(new GroupIntoNetworkAction(null)); goInSubnetworkMenuItem = nodeMenu2.add(new GoInAction()); nodeMenu2.add(new EditCommentAction());edits a comment nodeMenu2.add(new RemoveCommentAction());removes a remove nodeMenu2.add(new HelpAction()); } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; Draw background g2.setColor(Theme.NETWORK_BACKGROUND_COLOR); g2.fill(g.getClipBounds()); Paint the grid (The grid is not really affected by the view transform) paintGrid(g2); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(getViewTransform()); paintNodes(g2); paintConnections(g2); paintCurrentConnection(g2); paintPortTooltip(g2); paintDragSelection(g2); paintCommentBox(g2); Restore original transform g2.setTransform(originalTransform); } 
private void paintCommentBox ( Graphics2D g ) { tif ( overComment ! = null ) { tBufferedImage commentBox = null ; 
private void commentNode ( Node node ) { tString comment = JOptionPane . showInputDialog ( this , " New comment: " ) ; tif ( comment = = null | | comment . length ( ) = = 0 ) treturn ; ttry { tgetDocument ( ) . setNodeComment ( node , comment ) ; 
private void editCommentNode ( Node node ) { tString comment = JOptionPane . showInputDialog ( this , " Edit comment: " , node . getComment ( ) ) ; tgetDocument ( ) . setNodeComment ( node , comment ) ; } 
private boolean isCommented ( Node node ) { tif ( node . getComment ( ) . equals ( " " ) ) treturn false ; 
public void mouseMoved ( MouseEvent e ) { Point2D pt = inverseViewTransformPoint ( e . getPoint ( ) ) ; overOutput = getNodeWithOutputPortAt ( pt ) ; overInput = getInputPortAt ( pt ) ; check if mouse is over node with comment overComment = getNodeWithCommentAt(pt); It is probably very inefficient to repaint the view every time the mouse moves. repaint(); } 
public void actionPerformed ( ActionEvent e ) { tNode node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; tif ( node ! = null ) tgetDocument ( ) . setNodeComment ( node , " " ) ; 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; if ( node ! = null ) { editCommentNode ( node ) ; 
public void actionPerformed ( ActionEvent e ) { tNode node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; tif ( node ! = null ) { commentNode ( node ) ; 
public Node withComment ( String comment ) { treturn newNodeWithAttribute ( Attribute . COMMENT , comment ) ; } 
public Node withChildCommented ( String childName , String comment ) { Node newNode = getChild ( childName ) . withName ( childName ) . withComment ( comment ) ; return withChildReplaced(childName, newNode); } 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String comment = this . comment ; String category = this . category ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; boolean isNetwork = this . isNetwork ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; boolean alwaysRendered = this . isAlwaysRendered ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case COMMENT : tcomment = ( String ) value ; tbreak ; case CATEGORY : category = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case IS_NETWORK : isNetwork = ( Boolean ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; case ALWAYS_RENDERED : alwaysRendered = ( Boolean ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT or NETWORK, make it the prototype. if (this == ROOT || this == NETWORK) { prototype = this; } The name of a node can never be "node" or "network". if (name.equals("node")) name = "node1"; else if (name.equals("network")) name = "network1"; return new Node(prototype, name, comment, category, description, image, function, position, inputs, outputType, outputRange, isNetwork, children, renderedChildName, connections, handle, alwaysRendered); 
public int hashCode ( ) { return Objects . hashCode ( prototype , name , comment , category , description , image , function , position , inputs , outputType , outputRange , isNetwork , children , renderedChildName , connections , handle , isAlwaysRendered ) ; 
private static Map < String , String > parseNodeAttributes ( XMLStreamReader reader ) throws XMLStreamException { Map < String , String > attributeMap = new HashMap < String , String > ( ) ; String [ ] attributes = { " prototype " , " name " , " comment " , " category " , " description " , " image " , " function " , " outputType " , " outputRange " , " position " , " renderedChild " , " handle " , " alwaysRendered " } ; for ( String attribute : attributes ) parseNodeAttribute ( reader , attributeMap , attribute ) ; return attributeMap ; } 
private static Node createNode ( Map < String , String > attributeMap , Node extendFromNode , Node parent , NodeRepository nodeRepository ) { String prototypeId = attributeMap . get ( " prototype " ) ; String name = attributeMap . get ( " name " ) ; String comment = attributeMap . get ( " comment " ) ; node = node.withComment(comment); if (category != null) node = node.withCategory(category); if (description != null) node = node.withDescription(description); if (image != null) node = node.withImage(image); if (function != null) node = node.withFunction(function); if (outputType != null) node = node.withOutputType(outputType); if (outputRange != null) node = node.withOutputRange(Port.Range.valueOf(outputRange.toUpperCase())); if (position != null) node = node.withPosition(Point.valueOf(position)); if (handle != null) node = node.withHandle(handle); if (alwaysRendered != null) node = node.withAlwaysRenderedSet(Boolean.parseBoolean(alwaysRendered)); return node; } 
public void commentNode ( String parentPath , String nodeName , String comment ) { tNode newNode = getNode ( parentPath ) . withChildCommented ( nodeName , comment ) ; treplaceNodeInPath ( parentPath , newNode ) ; } 
public void testCommentNode ( ) { Node child = Node . ROOT . withName ( " child " ) ; controller . addNode ( " / " , child ) ; controller . commentNode ( " / " , " child " , " test " ) ; assertTrue ( controller . getRootNode ( ) . hasChild ( " child " ) ) ; assertTrue ( controller . getNode ( " /child " ) . getComment ( ) . equals ( " test " ) ) ; } 
public void testWithChildCommented ( ) { tNode alpha = Node . NETWORK . withName ( " alpha " ) ; tNode beta = Node . ROOT . withName ( " beta " ) ; tString testComment = " test " ; talpha = alpha . withChildAdded ( beta ) . withChildCommented ( " beta " , testComment ) ; tassertTrue ( alpha . getChild ( " beta " ) . getComment ( ) . equals ( " test " ) ) ; } 
private void initMenus ( ) { networkMenu = new JPopupMenu ( ) ; networkMenu . add ( new NewNodeAction ( ) ) ; networkMenu . add ( new ResetViewAction ( ) ) ; networkMenu . add ( new GoUpAction ( ) ) ; nodemenu shows with nodes without comment nodeMenu = new JPopupMenu(); nodeMenu.add(new SetRenderedAction()); nodeMenu.add(new RenameAction()); nodeMenu.add(new DeleteAction()); nodeMenu.add(new GroupIntoNetworkAction(null)); goInSubnetworkMenuItem = nodeMenu.add(new GoInAction()); nodeMenu.add(new AddCommentAction()); nodeMenu.add(new HelpAction()); nodemenu2 shows with commented nodes nodeMenu2 = new JPopupMenu(); nodeMenu2.add(new SetRenderedAction()); nodeMenu2.add(new RenameAction()); nodeMenu2.add(new DeleteAction()); nodeMenu2.add(new GroupIntoNetworkAction(null)); goInSubnetworkMenuItem = nodeMenu2.add(new GoInAction()); nodeMenu2.add(new EditCommentAction()); nodeMenu2.add(new RemoveCommentAction()); nodeMenu2.add(new HelpAction()); } 
private void paintCommentBox ( Graphics2D g ) { if ( overComment ! = null ) { Rectangle r = nodeRect ( overComment ) ; 
private void createComment ( Node node ) { String comment = JOptionPane . showInputDialog ( this , " New comment: " ) ; if ( comment = = null | | comment . length ( ) = = 0 ) return ; getDocument ( ) . setNodeComment ( node , comment ) ; } 
private void editComment ( Node node ) { String comment = JOptionPane . showInputDialog ( this , " Edit comment: " , node . getComment ( ) ) ; getDocument ( ) . setNodeComment ( node , comment ) ; } 
private boolean hasComment ( Node node ) { return ! node . getComment ( ) . isEmpty ( ) ; } 
public void mouseMoved ( MouseEvent e ) { Point2D pt = inverseViewTransformPoint ( e . getPoint ( ) ) ; overOutput = getNodeWithOutputPortAt ( pt ) ; overInput = getInputPortAt ( pt ) ; overComment = getNodeWithCommentAt ( pt ) ; It is probably very inefficient to repaint the view every time the mouse moves. repaint(); } 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; if ( node ! = null ) getDocument ( ) . setNodeComment ( node , " " ) ; 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; if ( node ! = null ) { editComment ( node ) ; 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; if ( node ! = null ) { createComment ( node ) ; 
public void windowClosed ( WindowEvent e ) { } public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private abstract class ExportDelegate { protected InterruptibleProgressDialog progressDialog ; void frameDone ( double frame , Iterable < ? > results ) { } void exportDone ( ) { } } private class NodeClipboard { private final Node network ; private final ImmutableList < Node > nodes ; private NodeClipboard ( Node network , Iterable < Node > nodes ) { this . network = network ; this . nodes = ImmutableList . copyOf ( nodes ) ; } } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowIconified ( WindowEvent e ) { } public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private abstract class ExportDelegate { protected InterruptibleProgressDialog progressDialog ; void frameDone ( double frame , Iterable < ? > results ) { } void exportDone ( ) { } } private class NodeClipboard { private final Node network ; private final ImmutableList < Node > nodes ; private NodeClipboard ( Node network , Iterable < Node > nodes ) { this . network = network ; this . nodes = ImmutableList . copyOf ( nodes ) ; } } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowDeiconified ( WindowEvent e ) { } public void windowActivated ( WindowEvent e ) { Application . getInstance ( ) . setCurrentDocument ( this ) ; } public void windowDeactivated ( WindowEvent e ) { } private abstract class ExportDelegate { protected InterruptibleProgressDialog progressDialog ; void frameDone ( double frame , Iterable < ? > results ) { } void exportDone ( ) { } } private class NodeClipboard { private final Node network ; private final ImmutableList < Node > nodes ; private NodeClipboard ( Node network , Iterable < Node > nodes ) { this . network = network ; this . nodes = ImmutableList . copyOf ( nodes ) ; } } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public void windowDeactivated ( WindowEvent e ) { } private abstract class ExportDelegate { protected InterruptibleProgressDialog progressDialog ; void frameDone ( double frame , Iterable < ? > results ) { } void exportDone ( ) { } } private class NodeClipboard { private final Node network ; private final ImmutableList < Node > nodes ; private NodeClipboard ( Node network , Iterable < Node > nodes ) { this . network = network ; this . nodes = ImmutableList . copyOf ( nodes ) ; } } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
void frameDone ( double frame , Iterable < ? > results ) { } void exportDone ( ) { } } private class NodeClipboard { private final Node network ; private final ImmutableList < Node > nodes ; private NodeClipboard ( Node network , Iterable < Node > nodes ) { this . network = network ; this . nodes = ImmutableList . copyOf ( nodes ) ; } } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
void exportDone ( ) { } } private class NodeClipboard { private final Node network ; private final ImmutableList < Node > nodes ; private NodeClipboard ( Node network , Iterable < Node > nodes ) { this . network = network ; this . nodes = ImmutableList . copyOf ( nodes ) ; } } private class ZoomInHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 1.05 ) ; } } private class ZoomOutHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent actionEvent ) { zoomView ( 0.95 ) ; } } private class FramesWriter extends StringWriter { private final ProgressDialog dialog ; public FramesWriter ( ProgressDialog d ) { super ( ) ; dialog = d ; } @Override public void write ( String s , int n1 , int n2 ) { super . write ( s , n1 , n2 ) ; if ( s . startsWith ( " frame= " ) ) { int frame = Integer . parseInt ( s . substring ( 6 , s . indexOf ( " fps " ) ) . trim ( ) ) ; dialog . updateProgress ( frame ) ; } } } } 
public Node withComment ( String comment ) { return newNodeWithAttribute ( Attribute . COMMENT , comment ) ; } 
public Node withChildCommented ( String childName , String comment ) { Node newNode = getChild ( childName ) . withComment ( comment ) ; return withChildReplaced ( childName , newNode ) ; } 
private Node newNodeWithAttribute ( Attribute attribute , Object value ) { Node prototype = this . prototype ; String name = this . name ; String comment = this . comment ; String category = this . category ; String description = this . description ; String image = this . image ; String function = this . function ; Point position = this . position ; ImmutableList < Port > inputs = this . inputs ; String outputType = this . outputType ; Port . Range outputRange = this . outputRange ; boolean isNetwork = this . isNetwork ; ImmutableList < Node > children = this . children ; String renderedChildName = this . renderedChildName ; ImmutableList < Connection > connections = this . connections ; String handle = this . handle ; boolean alwaysRendered = this . isAlwaysRendered ; switch ( attribute ) { case PROTOTYPE : prototype = ( Node ) value ; break ; case NAME : name = ( String ) value ; break ; case COMMENT : comment = ( String ) value ; break ; case CATEGORY : category = ( String ) value ; break ; case DESCRIPTION : description = ( String ) value ; break ; case IMAGE : image = ( String ) value ; break ; case FUNCTION : function = ( String ) value ; break ; case POSITION : position = ( Point ) value ; break ; case INPUTS : inputs = ( ImmutableList < Port > ) value ; break ; case OUTPUT_TYPE : outputType = ( String ) value ; break ; case OUTPUT_RANGE : outputRange = ( Port . Range ) value ; break ; case IS_NETWORK : isNetwork = ( Boolean ) value ; break ; case CHILDREN : children = ( ImmutableList < Node > ) value ; break ; case RENDERED_CHILD_NAME : renderedChildName = ( String ) value ; break ; case CONNECTIONS : connections = ( ImmutableList < Connection > ) value ; break ; case HANDLE : handle = ( String ) value ; break ; case ALWAYS_RENDERED : alwaysRendered = ( Boolean ) value ; break ; default : throw new AssertionError ( " Unknown attribute " + attribute ) ; } If we're "changing" an attribute on ROOT or NETWORK, make it the prototype. if (this == ROOT || this == NETWORK) { prototype = this; } The name of a node can never be "node" or "network". if (name.equals("node")) name = "node1"; else if (name.equals("network")) name = "network1"; return new Node(prototype, name, comment, category, description, image, function, position, inputs, outputType, outputRange, isNetwork, children, renderedChildName, connections, handle, alwaysRendered); 
public static Map < String , String > parseHeader ( File f ) { try { XMLInputFactory xmlInputFactory = XMLInputFactory . newInstance ( ) ; XMLStreamReader reader = xmlInputFactory . createXMLStreamReader ( createFileReader ( f ) ) ; while ( reader . hasNext ( ) ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) { return parseHeader ( reader ) ; } else { throw new XMLStreamException ( " Only tag ndbx allowed, not " + tagName , reader . getLocation ( ) ) ; } } } } catch ( XMLStreamException e ) { throw new RuntimeException ( e ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } return Collections . emptyMap ( ) ; } 
private static Map < String , String > parseHeader ( XMLStreamReader reader ) throws XMLStreamException { Map < String , String > propertyMap = new HashMap < String , String > ( ) ; while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " property " ) ) { parseProperty ( reader , propertyMap ) ; } } else if ( eventType = = XMLStreamConstants . END_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " ndbx " ) ) break ; } } return propertyMap ; } 
public NodeLibrary withDeviceAdded ( Device device ) { checkNotNull ( device , " Device cannot be null. " ) ; checkArgument ( ! hasDevice ( device . getName ( ) ) , " There is already a device named %s " , device . getName ( ) ) ; ImmutableList . Builder < Device > b = ImmutableList . builder ( ) ; b . addAll ( getDevices ( ) ) ; b . add ( device ) ; return new NodeLibrary ( this . name , this . file , this . root , this . nodeRepository , this . functionRepository , this . properties , b . build ( ) , this . uuid ) ; } 
private static Map < String , String > parseNodeAttributes ( XMLStreamReader reader ) throws XMLStreamException { Map < String , String > attributeMap = new HashMap < String , String > ( ) ; String [ ] attributes = { " prototype " , " name " , " comment " , " category " , " description " , " image " , " function " , " outputType " , " outputRange " , " position " , " renderedChild " , " handle " , " alwaysRendered " } ; for ( String attribute : attributes ) parseNodeAttribute ( reader , attributeMap , attribute ) ; return attributeMap ; } 
private static Node createNode ( Map < String , String > attributeMap , Node extendFromNode , Node parent , NodeRepository nodeRepository ) { String prototypeId = attributeMap . get ( " prototype " ) ; String name = attributeMap . get ( " name " ) ; String comment = attributeMap . get ( " comment " ) ; String category = attributeMap . get ( " category " ) ; String description = attributeMap . get ( " description " ) ; String image = attributeMap . get ( " image " ) ; String function = attributeMap . get ( " function " ) ; String outputType = attributeMap . get ( " outputType " ) ; String outputRange = attributeMap . get ( " outputRange " ) ; String position = attributeMap . get ( " position " ) ; String handle = attributeMap . get ( " handle " ) ; String alwaysRendered = attributeMap . get ( " alwaysRendered " ) ; Node prototype = prototypeId = = null ? extendFromNode : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) return null ; Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( comment ! = null ) node = node . withComment ( comment ) ; if ( category ! = null ) node = node . withCategory ( category ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputType ! = null ) node = node . withOutputType ( outputType ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; if ( alwaysRendered ! = null ) node = node . withAlwaysRenderedSet ( Boolean . parseBoolean ( alwaysRendered ) ) ; return node ; } 
private static Node parseNode ( XMLStreamReader reader , Node parent , NodeRepository nodeRepository ) throws XMLStreamException { Map < String , String > attributeMap = parseNodeAttributes ( reader ) ; Node node = createNode ( attributeMap , Node . ROOT , parent , nodeRepository ) ; String prototypeId = attributeMap . get ( " prototype " ) ; if ( node = = null ) { throw new XMLStreamException ( " Prototype " + prototypeId + " could not be found. " , reader . getLocation ( ) ) ; } while ( true ) { int eventType = reader . next ( ) ; if ( eventType = = XMLStreamConstants . START_ELEMENT ) { String tagName = reader . getLocalName ( ) ; if ( tagName . equals ( " node " ) | | tagName . equals ( " importCoreNode " ) ) { if ( prototypeId = = null & & ! node . isNetwork ( ) ) node = createNode ( attributeMap , Node . NETWORK , parent , nodeRepository ) ; } if ( tagName . equals ( " node " ) ) { node = node . withChildAdded ( parseNode ( reader , node , nodeRepository ) ) ; } else if ( tagName . equals ( " importCoreNode " ) ) { String s = reader . getAttributeValue ( null , " ref " ) ; Node coreNode = Node . coreNodes . get ( s ) ; if ( coreNode = = null ) { throw new XMLStreamException ( " Core node ' " + s + " ' does not exist. " , reader . getLocation ( ) ) ; } node = node . withChildAdded ( coreNode ) ; } else if ( tagName . equals ( " port " ) ) { String portName = reader . getAttributeValue ( null , " name " ) ; Remove the port if it is already on the prototype. if (node.hasInput(portName)) { node = node.withInputChanged(portName, parsePort(reader, node.getInput(portName))); } else { node = node.withInputAdded(parsePort(reader, null)); } } else if (tagName.equals("conn")) { node = node.withConnectionAdded(parseConnection(reader)); } else { throw new XMLStreamException("Unknown tag " + tagName, reader.getLocation()); } } else if (eventType == XMLStreamConstants.END_ELEMENT) { String tagName = reader.getLocalName(); if (tagName.equals("node")) break; } } This has to come at the end, since the child first needs to exist. String renderedChildName = attributeMap.get("renderedChild"); if (renderedChildName != null) node = node.withRenderedChildName(renderedChildName); return node; } 
public void commentNode ( String parentPath , String nodeName , String comment ) { Node newNode = getNode ( parentPath ) . withChildCommented ( nodeName , comment ) ; replaceNodeInPath ( parentPath , newNode ) ; } 
public void testUniqueNodeName ( ) { Node proto = Node . ROOT . withName ( " protoNode " ) ; controller . createNode ( " / " , proto ) ; controller . createNode ( " / " , proto ) ; controller . createNode ( " / " , proto ) ; Node rootNode = controller . getRootNode ( ) ; assertFalse ( rootNode . hasChild ( " protoNode " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode1 " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode2 " ) ) ; assertTrue ( rootNode . hasChild ( " protoNode3 " ) ) ; controller . removeNode ( " / " , " protoNode2 " ) ; rootNode = controller . getRootNode ( ) ; assertFalse ( rootNode . hasChild ( " protoNode2 " ) ) ; controller . createNode ( " / " , proto ) ; rootNode = controller . getRootNode ( ) ; assertTrue ( rootNode . hasChild ( " protoNode2 " ) ) ; assertFalse ( rootNode . hasChild ( " protoNode4 " ) ) ; } 
public void testWithChildCommented ( ) { Node net = Node . NETWORK . withName ( " net " ) ; Node alpha = Node . ROOT . withName ( " alpha " ) ; String testComment = " test " ; net = net . withChildAdded ( alpha ) . withChildCommented ( " alpha " , testComment ) ; assertTrue ( net . getChild ( " alpha " ) . getComment ( ) . equals ( testComment ) ) ; } 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; if ( node ! = null ) { getDocument ( ) . setNodeComment ( node , " " ) ; 
public boolean hasComment ( ) { return comment ! = null & & ! comment . trim ( ) . isEmpty ( ) ; } 
private JPopupMenu createNodeMenu ( Node node ) { JPopupMenu menu = new JPopupMenu ( ) ; menu . add ( new SetRenderedAction ( ) ) ; menu . add ( new RenameAction ( ) ) ; menu . add ( new DeleteAction ( ) ) ; menu . add ( new GroupIntoNetworkAction ( null ) ) ; if ( node . isNetwork ( ) ) { menu . add ( new GoInAction ( ) ) ; } if ( ! node . hasComment ( ) ) { menu . add ( new AddCommentAction ( ) ) ; } else { menu . add ( new EditCommentAction ( ) ) ; menu . add ( new RemoveCommentAction ( ) ) ; } menu . add ( new HelpAction ( ) ) ; return menu ; } 
private void addComment ( Node node ) { String comment = JOptionPane . showInputDialog ( this , " New comment: " ) ; if ( comment ! = null & & ! comment . trim ( ) . isEmpty ( ) ) { getDocument ( ) . setNodeComment ( node , comment ) ; 
public void actionPerformed ( ActionEvent e ) { Node node = getNodeAt ( inverseViewTransformPoint ( nodeMenuLocation ) ) ; if ( node ! = null ) { addComment ( node ) ; 
public static boolean logicOperator ( Boolean b1 , Boolean b2 , String comparator ) { if ( comparator . equals ( " or " ) ) { return b1 | | b2 ; 
private void exportToFile ( File file , Iterable < ? > objects , ImageFormat format ) { file = format . ensureFileExtension ( file ) ; ObjectsRenderer . render ( objects , getCanvasBounds ( ) . getBounds2D ( ) , file ) ; } 
public void frameDone ( double frame , Iterable < ? > results ) { movie . addFrame ( ObjectsRenderer . createMovieImage ( results , bounds ) ) ; } 
public static BufferedImage createMovieImage ( Iterable < ? > objects , Rectangle2D bounds ) { Visualizer v = VisualizerFactory . getVisualizer ( objects , ListUtils . listClass ( objects ) ) ; return createImage ( objects , v , bounds , Color . WHITE ) ; } 
private static BufferedImage createImage ( Iterable < ? > objects , Visualizer visualizer , Rectangle2D bounds , Color backgroundColor ) { final int width = ( int ) Math . round ( bounds . getWidth ( ) ) ; final int height = ( int ) Math . round ( bounds . getHeight ( ) ) ; BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = img . createGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; if ( backgroundColor ! = null ) { g . setColor ( backgroundColor ) ; g . fillRect ( 0 , 0 , width , height ) ; } g . translate ( - bounds . getX ( ) , - bounds . getY ( ) ) ; visualizer . draw ( g , objects ) ; img . flush ( ) ; return img ; } 
public void paintComponent ( Graphics g ) { if ( ! viewPositioned ) { setViewPosition ( getWidth ( ) / 2.0 , getHeight ( ) / 2.0 ) ; viewPositioned = true ; } Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ) ; Draw background g2.setColor(getBackground()); g2.fill(g.getClipBounds()); Set the view transform AffineTransform originalTransform = g2.getTransform(); g2.transform(getViewTransform()); paintBounds(g2); paintObjects(g2); paintHandle(g2); paintPoints(g2); paintPointNumbers(g2); Restore original transform g2.setClip(null); g2.setTransform(originalTransform); g2.setStroke(new BasicStroke(1)); paintOrigin(g2); } 
public void paintBounds ( Graphics2D g ) { if ( showBounds ) { g . setColor ( Color . DARK_GRAY ) ; 
public void toggleBounds ( ) { viewer . setShowBounds ( boundsCheck . isChecked ( ) ) ; } 
private boolean inDraggableArea ( Point pt ) { return ! getLeftButtonRect ( ) . contains ( pt ) & & ! getRightButtonRect ( ) . contains ( pt ) ; } 
public void mouseReleased ( MouseEvent e ) { if ( ! isEnabled ( ) ) return ; isDragging = false ; SwingUtilities . getRootPane ( this ) . setCursor ( Cursor . getDefaultCursor ( ) ) ; if ( oldValue ! = value ) fireStateChanged ( ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { shouldReplace = false ; dispose ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { shouldReplace = true ; dispose ( ) ; } 
public static boolean showForFile ( File file ) { ReplaceDialog dialog = new ReplaceDialog ( file ) ; dialog . setVisible ( true ) ; return dialog . shouldReplace ; } 
public static void main ( String [ ] args ) { boolean shouldReplace = ReplaceDialog . showForFile ( new File ( " /Users/demo/Projects/deep/nodebox/file.ndbx " ) ) ; System . out . println ( " shouldReplace = " + shouldReplace ) ; } 
private void renameNode ( Node node ) { String s = JOptionPane . showInputDialog ( this , " New name (no spaces, don't start with a digit): " , node . getName ( ) ) ; if ( s = = null | | s . length ( ) = = 0 ) return ; try { getDocument ( ) . setNodeName ( node , s ) ; 
public static void drawGrobs ( Graphics2D g , Iterable < Grob > objects ) { for ( Grob grob : objects ) { grob . draw ( g ) ; 
public static List < ? > doSwitch ( Iterable list1 , Iterable list2 , Iterable list3 , Iterable list4 , Iterable list5 , Iterable list6 , long index ) { Iterable < ? > returnList ; switch ( ( int ) index % 6 ) { case 0 : returnList = list1 ; break ; case 1 : returnList = list2 ; break ; case 2 : returnList = list3 ; break ; case 3 : returnList = list4 ; break ; case 4 : returnList = list5 ; break ; case 5 : returnList = list6 ; break ; default : throw new AssertionError ( ) ; } if ( returnList = = null ) return ImmutableList . of ( ) ; return ImmutableList . < Object > copyOf ( returnList ) ; } 
public static List < ? > distinct ( Iterable < ? > iterable , String key ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( key ! = null ) { key = key . trim ( ) . isEmpty ( ) ? null : key ; } Set < Integer > distinctKeys = new HashSet < Integer > ( ) ; ImmutableList . Builder < ? > b = ImmutableList . builder ( ) ; for ( Object object : iterable ) { final Integer hashCode ; if ( key = = null ) { hashCode = object = = null ? null : object . hashCode ( ) ; } else { Object v = DataFunctions . lookup ( object , key ) ; hashCode = v = = null ? null : v . hashCode ( ) ; } if ( hashCode ! = null & & distinctKeys . contains ( hashCode ) ) continue ; distinctKeys . add ( hashCode ) ; b . add ( object ) ; } return b . build ( ) ; } 
public static UpgradeResult upgradeTo ( File file , String targetVersion ) throws LoadException { String currentXml = readFile ( file ) ; String currentVersion = parseFormatVersion ( currentXml ) ; ArrayList < String > warnings = new ArrayList < String > ( ) ; Avoid upgrades getting stuck in an infinite loop. int tries = 0; while (!currentVersion.equals(targetVersion) && tries < 100) { Method upgradeMethod = upgradeMap.get(currentVersion); if (upgradeMethod == null) { throw new LoadException(file, "Unsupported version " + currentVersion + ": this file is too new. Try downloading a new version of NodeBox from http:nodebox.net/download/"); } try { UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, currentXml); warnings.addAll(result.warnings); currentXml = result.xml; } catch (Exception e) { throw new LoadException(file, "Upgrading to " + currentVersion + " failed.", e); } currentVersion = parseFormatVersion(currentXml); tries++; } if (tries >= 100) { throw new LoadException(file, "Got stuck in an infinite loop when trying to upgrade from " + currentVersion); } return new UpgradeResult(file, currentXml, warnings); } 
public static List < ? > combine ( Iterable list1 , Iterable list2 , Iterable list3 , Iterable list4 , Iterable list5 , Iterable list6 , Iterable list7 ) { Iterable < Iterable < ? > > nonNullLists = Iterables . filter ( Lists . < Iterable < ? > > newArrayList ( list1 , list2 , list3 , list4 , list5 , list6 , list7 ) , Predicates . notNull ( ) ) ; return ImmutableList . copyOf ( Iterables . concat ( nonNullLists ) ) ; } 
public void testCombine ( ) { assertElements ( ListFunctions . combine ( ImmutableList . of ( ) , ImmutableList . of ( ) , null , null , null , null , null ) ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( ) , null , null , null , null , null ) , 1 ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( 2 ) , null , null , null , null , null ) , 1 , 2 ) ; assertElements ( ListFunctions . combine ( ImmutableList . of ( 1 ) , ImmutableList . of ( 2 ) , null , null , null , null , ImmutableList . of ( 3 ) ) , 1 , 2 , 3 ) ; } 
public static UpgradeStringResult upgrade17to18 ( String inputXml ) throws LoadException { Version 18: "switch" and "combine" nodes have more ports. This doesn't change anything in the file but does make the files backward-incompatible. UpgradeOp convertOSCPropertyOp = new ConvertOSCPropertyFormatOp(); return transformXml(inputXml, "18"); } 
public static UpgradeResult upgradeTo ( File file , String targetVersion ) throws LoadException { String currentXml = readFile ( file ) ; String currentVersion = parseFormatVersion ( currentXml ) ; ArrayList < String > warnings = new ArrayList < String > ( ) ; Avoid upgrades getting stuck in an infinite loop. int tries = 0; if (currentVersion.equals("0.9")) { throw new LoadException(file, "This is a NodeBox 2 file. Download NodeBox 2 from http:beta.nodebox.net/"); } while (!currentVersion.equals(targetVersion) && tries < 100) { Method upgradeMethod = upgradeMap.get(currentVersion); if (upgradeMethod == null) { throw new LoadException(file, "Unsupported version " + currentVersion + ": this file is too new. Try downloading a new version of NodeBox from http:nodebox.net/download/"); } try { UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, currentXml); warnings.addAll(result.warnings); currentXml = result.xml; } catch (Exception e) { throw new LoadException(file, "Upgrading to " + currentVersion + " failed.", e); } currentVersion = parseFormatVersion(currentXml); tries++; } if (tries >= 100) { throw new LoadException(file, "Got stuck in an infinite loop when trying to upgrade from " + currentVersion); } return new UpgradeResult(file, currentXml, warnings); } 
private static void renamePortReference ( List < Element > elements , String attributeName , String oldNodeName , String newNodeName ) { for ( Element c : elements ) { Attr portReference = c . getAttributeNode ( attributeName ) ; 
private static void renamePortInNodeList ( List < Element > elements , String attributeName , String nodeName , String oldPortName , String newPortName ) { for ( Element c : elements ) { Attr portReference = c . getAttributeNode ( attributeName ) ; 
private static void renameNodeReference ( List < Element > elements , String attributeName , String oldNodeName , String newNodeName ) { for ( Element c : elements ) { Attr nodeRef = c . getAttributeNode ( attributeName ) ; 
private static void transformXmlRecursive ( Element e , UpgradeOp op ) { op . apply ( e ) ; for ( Element child : childElements ( e ) ) { transformXmlRecursive ( child , op ) ; 
public void mouseDragged ( MouseEvent e ) { tif ( isZooming ( ) ) { tPoint2D offset = minPoint ( e . getPoint ( ) , zoomEndPoint ) ; if (isPanning()) { When panning the view use the original mouse point, not the one affected by the view transform. 
public void mouseDragged ( MouseEvent e ) { if ( isZooming ( ) ) { How far have we moved? Point2D offset = minPoint(e.getPoint(), zoomEndPoint); Drag mouse left to zoom out, right to zoom in. zoom(1 + offset.getX() / 200.0, zoomStartPoint.getX(), zoomStartPoint.getY()); Reset the end point because zoom() takes incremental (delta) values zoomEndPoint = e.getPoint(); return; } if (isPanning()) { When panning the view use the original mouse point, not the one affected by the view transform. 
public static Color portTypeColor ( String type ) { Color portColor = PORT_COLORS . get ( type ) ; return portColor = = null ? PORT_COLORS . get ( " other " ) : portColor ; } 
public void setup ( ) { minim = new Minim ( this ) ; input = minim . getLineIn ( ) ; input . setVolume ( 0 ) ; input . setGain ( - 64 ) ; } 
public void draw ( ) { } @Override public void stop ( ) { if ( input ! = null ) input . close ( ) ; input = null ; if ( minim ! = null ) minim . stop ( ) ; } } 
public void stop ( ) { if ( input ! = null ) input . close ( ) ; input = null ; if ( minim ! = null ) minim . stop ( ) ; 
public void start ( ) { if ( frame ! = null ) stop ( ) ; frame = new JFrame ( ) ; applet = new MinimInputApplet ( ) ; applet . init ( ) ; frame . add ( applet ) ; } 
public void addData ( Map < String , Object > map ) { if ( applet ! = null & & applet . getInput ( ) ! = null ) map . put ( getName ( ) + " .source " , applet . getInput ( ) ) ; 
public AbstractDeviceControl createControl ( ) { return new AudioInputDeviceControl ( this ) ; } 
public void addData ( Map < String , Object > map ) { if ( applet ! = null & & applet . getPlayer ( ) ! = null ) map . put ( getName ( ) + " .source " , applet . getPlayer ( ) ) ; 
public static DeviceHandler createDeviceHandler ( Device device ) { if ( device . getType ( ) . equals ( Device . TYPE_OSC ) ) return createOSCDeviceHandler ( device ) ; else if ( device . getType ( ) . equals ( Device . TYPE_AUDIOPLAYER ) ) return createAudioPlayerDeviceHandler ( device ) ; else if ( device . getType ( ) . equals ( Device . TYPE_AUDIOINPUT ) ) return createAudioInputDeviceHandler ( device ) ; return null ; } 
private static DeviceHandler createAudioInputDeviceHandler ( Device device ) { AudioInputDeviceHandler handler = new AudioInputDeviceHandler ( device . getName ( ) ) ; return handler ; } 
public static List < Double > audioAnalysis ( String deviceName , long averages , NodeContext context ) { AudioSource source = ( AudioSource ) context . getData ( ) . get ( deviceName + " .source " ) ; if ( source = = null ) return ImmutableList . of ( ) ; FFT fft = new FFT ( source . bufferSize ( ) , source . sampleRate ( ) ) ; if ( averages > 0 ) fft . linAverages ( ( int ) averages ) ; fft . forward ( source . mix ) ; ImmutableList . Builder < Double > b = new ImmutableList . Builder < Double > ( ) ; if ( averages = = 0 ) { for ( int i = 0 ; i < fft . specSize ( ) ; i + + ) b . add ( ( double ) fft . getBand ( i ) ) ; } else { for ( int i = 0 ; i < fft . avgSize ( ) ; i + + ) b . add ( ( double ) fft . getAvg ( i ) ) ; } return b . build ( ) ; } 
private boolean isValidProperty ( String name ) { checkNotNull ( name ) ; if ( ! validPropertyNames . containsKey ( getType ( ) ) ) return false ; return validPropertyNames . get ( getType ( ) ) . matcher ( name ) . matches ( ) ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Node exportNetwork = library . getRoot ( ) ; final Viewer viewer = new Viewer ( ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( getCanvasWidth ( ) , getCanvasHeight ( ) ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < Node , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " frame " , ( double ) frame ) ; data . put ( " mouse.position " , viewer . getLastMousePosition ( ) ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , data , renderResults , ImmutableMap . < String , Object > of ( ) ) ; List < ? > results = context . renderNode ( exportNetwork ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < ? > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
public static long round ( double a ) { return Math . round ( a ) ; } 
public void testRound ( ) { assertEquals ( 5L , round ( 5.0 ) ) ; assertEquals ( 5L , round ( 5.4 ) ) ; assertEquals ( 6L , round ( 5.5 ) ) ; assertEquals ( 6L , round ( 5.9 ) ) ; } 
public Object findVar ( String name ) { Node node = ProcessingContext.getCurrentContext().getNode(); if (node == null) return null; return node.getInput(name); return null; } 
private double [ ] updateRGB ( ) { if ( s = = 0 ) return new double [ ] { this . v , this . v , this . v } ; 
private double [ ] updateHSB ( ) { double h = 0 ; double s = 0 ; double v = Math . max ( Math . max ( r , g ) , b ) ; double d = v - Math . min ( Math . min ( r , g ) , b ) ; if ( v ! = 0 ) s = d / v ; if ( s ! = 0 ) { if ( r = = v ) h = 0 + ( g - b ) / d ; else if ( g = = v ) h = 2 + ( b - r ) / d ; else h = 4 + ( r - g ) / d ; } h = h * ( 60.0 / 360 ) ; if ( h < 0 ) h = h + 1 ; return new double [ ] { h , s , v } ; } 
public double colorrange ( ) ; public double colorrange ( double range ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double colorrange ( double range ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( double x ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( double x , double y ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( double x , double y , double z ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( double x , double y , double z , double a ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color color ( Color c ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( double x ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( double x , double y ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( double x , double y , double z ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( double x , double y , double z , double a ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color fill ( Color c ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nofill ( ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( double x ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( double x , double y ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( double x , double y , double z ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( double x , double y , double z , double a ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Color stroke ( Color c ) ; public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void nostroke ( ) ; public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double strokewidth ( ) ; public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double strokewidth ( double w ) ; public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( ) ; public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName ) ; public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public String font ( String fontName , double fontSize ) ; public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double fontsize ( ) ; public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double fontsize ( double s ) ; public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double lineheight ( ) ; public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double lineheight ( double lineHeight ) ; public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( ) ; public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( Text . Align align ) ; public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( String align ) ; public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text . Align align ( int align ) ; public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y ) ; public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width ) ; public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width , double height ) ; public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width , double height , double alpha ) ; public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width , double height , boolean draw ) ; public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( String path , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( Image img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Image image ( BufferedImage img , double x , double y , double width , double height , double alpha , boolean draw ) ; public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( String path ) ; public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( Image img ) ; public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Size imagesize ( BufferedImage img ) ; public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , double x , double y ) ; public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , double x , double y , double width ) ; public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , double x , double y , double width , double height ) ; public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Text text ( String text , double x , double y , double width , double height , boolean draw ) ; public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , double x , double y ) ; public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , double x , double y , double width ) ; public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Path textpath ( String text , double x , double y , double width , double height ) ; public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text ) ; public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text , double width ) ; public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Rect textmetrics ( String text , double width , double height ) ; public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double textwidth ( String text ) ; public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double textwidth ( String text , double width ) ; public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double textheight ( String text ) ; public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public double textheight ( String text , double width ) ; public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type ) ; public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type ) ; public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type ) ; public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type , Object value ) ; public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type , Object value ) ; public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type , Object value ) ; public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , VarType type , Object value , double min , double max ) ; public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , String type , Object value , double min , double max ) ; public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public void var ( String name , int type , Object value , double min , double max ) ; public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public Object findVar ( String name ) ; public double random ( ) ; public long random ( int max ) ; public long random ( int min , int max ) ; public double random ( double max ) ; public double random ( double min , double max ) ; public Object choice ( List objects ) ; public Iterator < Point > grid ( int columns , int rows ) ; public Iterator < Point > grid ( int columns , int rows , double columnSize , double rowSize ) ; public void draw ( Grob g ) ; } 
public boolean isEmpty ( ) ; public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(double tx, double ty); void rotate(double degrees); void rotateRadians(double radians); void scale(double scale); void scale(double sx, double sy); void skew(double skew); void skew(double kx, double ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public Rect getBounds ( ) ; Transformations public void transform(Transform t); Cloning public Grob clone(); void translate(double tx, double ty); void rotate(double degrees); void rotateRadians(double radians); void scale(double scale); void scale(double sx, double sy); void skew(double skew); void skew(double kx, double ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public void transform ( Transform ) ; Cloning public Grob clone(); void translate(double tx, double ty); void rotate(double degrees); void rotateRadians(double radians); void scale(double scale); void scale(double sx, double sy); void skew(double skew); void skew(double kx, double ky); Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
public Grob clone ( ) ; void translate ( double tx , double ty ) ; void rotate ( double degrees ) ; void rotateRadians ( double radians ) ; void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void translate ( double tx , double ty ) ; void rotate ( double degrees ) ; void rotateRadians ( double radians ) ; void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void rotate ( double degrees ) ; void rotateRadians ( double radians ) ; void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void rotateRadians ( double radians ) ; void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void scale ( double scale ) ; void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void scale ( double sx , double sy ) ; void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void skew ( double skew ) ; void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void skew ( double kx , double ky ) ; Transform Delegate void setTransformDelegate(TransformDelegate d); TransformDelegate getTransformDelegate();} 
void setTransformDelegate ( TransformDelegate d ) ; TransformDelegate getTransformDelegate ( ) ; } 
public void draw ( Graphics2D g ) { setupTransform ( g ) ; You can only position an image using an affine transformation. We use the transformation to translate the image to the specified position, and scale it according to the given width and height. Transform imageTrans = new Transform(); Move to the image position. Convert x, y, which are centered coordinates, to "real" coordinates. double factor = getScaleFactor(); double finalWidth = image.getWidth() * factor; double finalHeight = image.getHeight() * factor; imageTrans.translate(x - finalWidth / 2, y - finalHeight / 2); Scaling only applies to image that have their desired width and/or height set. However, getScaleFactor return 1 if height/width are not set, in effect negating the effect of the scale. imageTrans.scale(getScaleFactor()); double a = clamp(alpha); Composite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) a); Composite oldComposite = g.getComposite(); g.setComposite(composite); g.drawRenderedImage(image, imageTrans.getAffineTransform()); g.setComposite(oldComposite); restoreTransform(g); } 
public static double snap ( double v , double distance , double strength ) { return ( v * ( 1.0 - strength ) ) + ( strength * java . lang . Math . round ( v / distance ) * distance ) ; } 
public static void initialize ( ) { if ( initialized ) return ; fontMapper = new DefaultFontMapper ( ) ; String osName = System . getProperty ( " os.name " ) ; if ( osName . startsWith ( " Windows " ) ) { TODO: Windows is not installed under C:\Windows all the time. fontMapper.insertDirectory("C:\\windows\\fonts"); } else if (osName.startsWith("Mac OS X")) { fontMapper.insertDirectory("/Library/Fonts"); String userHome = System.getProperty("user.home"); fontMapper.insertDirectory(userHome + "/Fonts"); } else { Where are the fonts in a UNIX install? } initialized = true; } 
public static void render ( Drawable drawable , Rect bounds , File file ) { render ( drawable , new Rectangle2D . Double ( 0 , 0 , bounds . width , bounds . height ) , file ) ; } 
public static void render ( Drawable drawable , Rectangle2D bounds , File file ) { initialize ( ) ; Rectangle size = new Rectangle ( ( float ) bounds . getWidth ( ) , ( float ) bounds . getHeight ( ) ) ; Document document = new Document ( size ) ; FileOutputStream fos ; try { fos = new FileOutputStream ( file ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( " The file " + file + " could not be created " , e ) ; } PdfWriter writer ; try { writer = PdfWriter . getInstance ( document , fos ) ; } catch ( DocumentException e ) { throw new RuntimeException ( " An error occurred while creating a PdfWriter object. " , e ) ; } document . open ( ) ; PdfContentByte contentByte = writer . getDirectContent ( ) ; Graphics2D g = new PdfGraphics2D ( contentByte , ( float ) bounds . getWidth ( ) , ( float ) bounds . getHeight ( ) , fontMapper ) ; g . translate ( - bounds . getX ( ) , - bounds . getY ( ) ) ; drawable . draw ( g ) ; g . dispose ( ) ; document . close ( ) ; } 
public void testHex ( ) { assertEquals ( new Color ( " #000 " ) , Color . BLACK ) ; assertEquals ( new Color ( " #f00 " ) , new Color ( 1 , 0 , 0 ) ) ; assertEquals ( new Color ( " #ffffff " ) , Color . WHITE ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { doRun ( ) ; } 
public static void main ( String [ ] args ) { RT . init ( ) ; try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception ignored ) { } System . setProperty ( " apple.laf.useScreenMenuBar " , " true " ) ; Playground frame = new Playground ( ) ; frame . setVisible ( true ) ; frame . codeArea . requestFocus ( ) ; frame . doRun ( ) ; } 
private void doRun ( ) { String source = codeArea . getText ( ) ; Object o = clojure . lang . Compiler . load ( new StringReader ( " (import '[nodebox.graphics Canvas Color Geometry Image Path PathElement Point Rect Size Text Transform]) " + source ) ) ; viewer . setResult ( o ) ; } 
protected void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setColor ( java . awt . Color . WHITE ) ; g2 . fill ( g . getClip ( ) ) ; g2 . setColor ( java . awt . Color . BLACK ) ; if ( result instanceof Grob ) { paintElement ( g2 , ( Grob ) result ) ; 
private void paintElement ( Graphics2D g , Grob e ) { g . setColor ( Color . DARK_GRAY ) ; e . draw ( g ) ; } 
private void paintPoints ( Graphics2D g , Iterable < Point > points ) { g . setColor ( java . awt . Color . BLUE ) ; for ( Point p : points ) { g . fillOval ( ( int ) p . x - 2 , ( int ) p . y - 2 , 4 , 4 ) ; 
private void paintObject ( Graphics2D g , Object object ) { g . setColor ( Color . DARK_GRAY ) ; g . setFont ( new Font ( Font . MONOSPACED , Font . PLAIN , 12 ) ) ; g . drawString ( object = = null ? " null " : object . toString ( ) , 10 , 20 ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { doRun ( ) ; } 
public void testMoved ( ) { Point p1 = new Point ( 10 , 20 ) ; Point p2 = p1 . moved ( 5 , 7 ) ; assertEquals ( p1 . x , 10.0 ) ; assertEquals ( p1 . y , 20.0 ) ; assertEquals ( p2 . x , 15.0 ) ; assertEquals ( p2 . y , 27.0 ) ; } 
public void setup ( ) { minim = new Minim ( this ) ; player = minim . loadFile ( fileName , 1024 ) ; beat = new BeatDetect ( player . bufferSize ( ) , player . sampleRate ( ) ) ; if ( loop ) player . loop ( ) ; 
public void setup ( ) { minim = new Minim ( this ) ; input = minim . getLineIn ( ) ; beat = new BeatDetect ( input . bufferSize ( ) , input . sampleRate ( ) ) ; input . setVolume ( 0 ) ; input . setGain ( - 64 ) ; } 
public static List < Map < String , Double > > audioWave ( String deviceName , NodeContext context ) { AudioSource source = ( AudioSource ) context . getData ( ) . get ( deviceName + " .source " ) ; if ( source = = null ) return ImmutableList . of ( ) ; ImmutableList . Builder < Map < String , Double > > b = ImmutableList . builder ( ) ; for ( int i = 0 ; i < source . bufferSize ( ) ; i + + ) { ImmutableMap . Builder < String , Double > mb = ImmutableMap . builder ( ) ; mb . put ( " left " , ( double ) source . left . get ( i ) ) ; mb . put ( " right " , ( double ) source . right . get ( i ) ) ; mb . put ( " mix " , ( double ) source . mix . get ( i ) ) ; b . add ( mb . build ( ) ) ; } return b . build ( ) ; } 
public static Map < String , Boolean > beatDetect ( String deviceName , NodeContext context ) { BeatDetect beat = ( BeatDetect ) context . getData ( ) . get ( deviceName + " .beat " ) ; if ( beat = = null ) return ImmutableMap . of ( ) ; ImmutableMap . Builder < String , Boolean > mb = ImmutableMap . builder ( ) ; mb . put ( " beat " , beat . isOnset ( ) ) ; mb . put ( " kick " , beat . isKick ( ) ) ; mb . put ( " snare " , beat . isSnare ( ) ) ; mb . put ( " hat " , beat . isHat ( ) ) ; return mb . build ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { document . addDevice ( type , name ) ; rebuildInterface ( ) ; } 
public void addDevice ( String deviceType , String deviceName ) { todo: undo / redo Device device = controller.addDevice(deviceType, deviceName); DeviceHandler handler = DeviceHandlerFactory.createDeviceHandler(device); if (handler != null) deviceHandlers.add(handler); 
public Device addDevice ( String deviceType ) { return addDevice ( deviceType , deviceType ) ; } 
public Device addDevice ( String deviceType , String name ) { String deviceName = nodeLibrary . uniqueName ( name ) ; Device device = Device . deviceForType ( deviceName , deviceType ) ; nodeLibrary = nodeLibrary . withDeviceAdded ( device ) ; return device ; } 
public static UpgradeStringResult upgrade18to19 ( String inputXml ) throws LoadException { Version 19: audioplayer devices previously had their default device name set to "audioplayer1". This has changed to "audio1", so to have backward compatibility we have to make sure the old name is set explicitly and not derived from the prototype. UpgradeOp renameDeviceNameOp1 = new SetOldDefaultAudioDeviceNameOp("device.audio_analysis", "device_name", "audioplayer1"); UpgradeOp renameDeviceNameOp2 = new SetOldDefaultAudioDeviceNameOp("device.audio_wave", "device_name", "audioplayer1"); UpgradeOp renameDeviceNameOp3 = new SetOldDefaultAudioDeviceNameOp("device.beat_detect", "device_name", "audioplayer1"); return transformXml(inputXml, "19", renameDeviceNameOp1, renameDeviceNameOp2, renameDeviceNameOp3); } 
public void apply ( Element e ) { if ( isNodeWithPrototype ( e , prototype ) ) { Element port = portWithName ( e , portName ) ; 
public void testUpgrade18to19 ( ) { File version18File = new File ( " src/test/files/upgrade-v18.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version18File ) ; NodeLibrary devicesLibrary = NodeLibrary . load ( new File ( " libraries/device/device.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version18File , NodeRepository . of ( devicesLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertEquals ( " audioplayer1 " , root . getChild ( " audio_analysis1 " ) . getInput ( " device_name " ) . getValue ( ) ) ; assertEquals ( " audioplayer2 " , root . getChild ( " audio_analysis2 " ) . getInput ( " device_name " ) . getValue ( ) ) ; assertEquals ( " audioplayer1 " , root . getChild ( " audio_wave1 " ) . getInput ( " device_name " ) . getValue ( ) ) ; assertEquals ( " audioplayer1 " , root . getChild ( " beat_detect1 " ) . getInput ( " device_name " ) . getValue ( ) ) ; } 
private static DeviceHandler createAudioInputDeviceHandler ( Device device ) { boolean autostart = Boolean . parseBoolean ( device . getProperty ( " autostart " , " false " ) ) ; AudioInputDeviceHandler handler = new AudioInputDeviceHandler ( device . getName ( ) , autostart ) ; if ( autostart ) handler . start ( ) ; return handler ; } 
public void mute ( ) { if ( player = = null ) return ; player . mute ( ) ; } 
public void unmute ( ) { if ( player = = null ) return ; player . unmute ( ) ; } 
public boolean isMuted ( ) { if ( player = = null ) return false ; return player . isMuted ( ) ; } 
public void toggleMute ( ) { if ( frame ! = null ) { if ( applet . isMuted ( ) ) { 
public void actionPerformed ( ActionEvent actionEvent ) { if ( frame ! = null ) { toggleMute ( ) ; 
public static List < Double > audioAnalysis ( String deviceName , String channel , long averages , NodeContext context ) { AudioSource source = ( AudioSource ) context . getData ( ) . get ( deviceName + " .source " ) ; if ( source = = null ) return ImmutableList . of ( ) ; FFT fft = new FFT ( source . bufferSize ( ) , source . sampleRate ( ) ) ; if ( averages > 0 ) fft . linAverages ( ( int ) averages ) ; if ( channel . equals ( " left " ) ) { fft . forward ( source . left ) ; } else if ( channel . equals ( " right " ) ) { fft . forward ( source . right ) ; } else { fft . forward ( source . mix ) ; } ImmutableList . Builder < Double > b = new ImmutableList . Builder < Double > ( ) ; if ( averages = = 0 ) { for ( int i = 0 ; i < fft . specSize ( ) ; i + + ) b . add ( ( double ) fft . getBand ( i ) ) ; } else { for ( int i = 0 ; i < fft . avgSize ( ) ; i + + ) b . add ( ( double ) fft . getAvg ( i ) ) ; } return b . build ( ) ; } 
public static List < Double > audioLogAvg ( String deviceName , String channel , long baseFreq , long bandsPerOctave , NodeContext context ) { AudioSource source = ( AudioSource ) context . getData ( ) . get ( deviceName + " .source " ) ; if ( source = = null ) return ImmutableList . of ( ) ; FFT fft = new FFT ( source . bufferSize ( ) , source . sampleRate ( ) ) ; fft . logAverages ( ( int ) baseFreq , ( int ) bandsPerOctave ) ; if ( channel . equals ( " left " ) ) { fft . forward ( source . left ) ; } else if ( channel . equals ( " right " ) ) { fft . forward ( source . right ) ; } else { fft . forward ( source . mix ) ; } ImmutableList . Builder < Double > b = new ImmutableList . Builder < Double > ( ) ; for ( int i = 0 ; i < fft . avgSize ( ) ; i + + ) b . add ( ( double ) fft . getAvg ( i ) ) ; return b . build ( ) ; } 
public static List < Double > audioAnalysis ( String deviceName , String channel , long averages , NodeContext context ) { AudioSource source = ( AudioSource ) context . getData ( ) . get ( deviceName + " .source " ) ; if ( source = = null ) return ImmutableList . of ( ) ; FFT fft = new FFT ( source . bufferSize ( ) , source . sampleRate ( ) ) ; fft . window ( FFT . HANN ) ; if ( averages > 0 ) fft . linAverages ( ( int ) averages ) ; if ( channel . equals ( " left " ) ) { fft . forward ( source . left ) ; } else if ( channel . equals ( " right " ) ) { fft . forward ( source . right ) ; } else { fft . forward ( source . mix ) ; } ImmutableList . Builder < Double > b = new ImmutableList . Builder < Double > ( ) ; if ( averages = = 0 ) { for ( int i = 0 ; i < fft . specSize ( ) ; i + + ) b . add ( ( double ) fft . getBand ( i ) ) ; } else { for ( int i = 0 ; i < fft . avgSize ( ) ; i + + ) b . add ( ( double ) fft . getAvg ( i ) ) ; } return b . build ( ) ; } 
public static List < Double > audioLogAvg ( String deviceName , String channel , long baseFreq , long bandsPerOctave , NodeContext context ) { AudioSource source = ( AudioSource ) context . getData ( ) . get ( deviceName + " .source " ) ; if ( source = = null ) return ImmutableList . of ( ) ; FFT fft = new FFT ( source . bufferSize ( ) , source . sampleRate ( ) ) ; fft . window ( FFT . HANN ) ; fft . logAverages ( ( int ) baseFreq , ( int ) bandsPerOctave ) ; if ( channel . equals ( " left " ) ) { fft . forward ( source . left ) ; } else if ( channel . equals ( " right " ) ) { fft . forward ( source . right ) ; } else { fft . forward ( source . mix ) ; } ImmutableList . Builder < Double > b = new ImmutableList . Builder < Double > ( ) ; for ( int i = 0 ; i < fft . avgSize ( ) ; i + + ) b . add ( ( double ) fft . getAvg ( i ) ) ; return b . build ( ) ; } 
public void startDeviceHandlers ( ) { if ( Application . ENABLE_DEVICE_SUPPORT ) { for ( DeviceHandler handler : deviceHandlers ) { 
public String getName ( ) ; public boolean isAutoStart ( ) ; public void start ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public boolean isAutoStart ( ) ; public void start ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public void start ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
private static DeviceHandler createOSCDeviceHandler ( Device device ) { int port = Integer . parseInt ( device . getProperty ( " port " , " -1 " ) ) ; boolean autostart = Boolean . parseBoolean ( device . getProperty ( " autostart " , " false " ) ) ; return new OSCDeviceHandler ( device . getName ( ) , port , autostart ) ; } 
private static DeviceHandler createAudioPlayerDeviceHandler ( Device device ) { String fileName = device . getProperty ( " filename " , " " ) ; boolean autostart = Boolean . parseBoolean ( device . getProperty ( " autostart " , " false " ) ) ; return new AudioPlayerDeviceHandler ( device . getName ( ) , fileName , autostart ) ; } 
private static DeviceHandler createAudioInputDeviceHandler ( Device device ) { boolean autostart = Boolean . parseBoolean ( device . getProperty ( " autostart " , " false " ) ) ; return new AudioInputDeviceHandler ( device . getName ( ) , autostart ) ; } 
public boolean startDeviceHandlers ( ) { boolean autostart = false ; if ( Application . ENABLE_DEVICE_SUPPORT ) { for ( DeviceHandler handler : deviceHandlers ) { if ( handler . isAutoStart ( ) ) { handler . start ( ) ; autostart = true ; } } } return autostart ; } 
public void stopDeviceHandlers ( ) { if ( Application . ENABLE_DEVICE_SUPPORT ) { for ( DeviceHandler handler : deviceHandlers ) { 
public void playAnimation ( ) { startDeviceHandlers ( ) ; animationTimer . start ( ) ; } 
public void stopAnimation ( ) { stopDeviceHandlers ( ) ; animationTimer . stop ( ) ; } 
public boolean isSyncedWithTimeline ( ) { return syncWithTimeline ; } 
public void itemStateChanged ( ItemEvent itemEvent ) { syncWithTimeline = syncWithTimelineCheck . isSelected ( ) ; setPropertyValue ( Device . TIMELINE_SYNC , String . valueOf ( syncWithTimeline ) ) ; } 
public String getName ( ) ; public boolean isSyncedWithTimeline ( ) ; public void start ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public boolean isSyncedWithTimeline ( ) ; public void start ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
private static boolean isSyncedWithTimeline ( Device device ) { return Boolean . parseBoolean ( device . getProperty ( Device . TIMELINE_SYNC , " false " ) ) ; } 
private static DeviceHandler createOSCDeviceHandler ( Device device ) { int port = Integer . parseInt ( device . getProperty ( " port " , " -1 " ) ) ; return new OSCDeviceHandler ( device . getName ( ) , port , isSyncedWithTimeline ( device ) ) ; } 
private static DeviceHandler createAudioPlayerDeviceHandler ( Device device ) { String fileName = device . getProperty ( " filename " , " " ) ; return new AudioPlayerDeviceHandler ( device . getName ( ) , fileName , isSyncedWithTimeline ( device ) ) ; } 
private static DeviceHandler createAudioInputDeviceHandler ( Device device ) { return new AudioInputDeviceHandler ( device . getName ( ) , isSyncedWithTimeline ( device ) ) ; } 
public void oscStatus ( OscStatus ignored ) { } } ) ; } public void pause ( ) { paused = true ; } public void resume ( ) { paused = false ; } @Override public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } @Override public void addData ( Map < String , Object > map ) { map . put ( getName ( ) + " .messages " , getOscMessages ( ) ) ; } @Override public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } private class OSCDeviceControl extends AbstractDeviceControl { private JLabel deviceNameLabel ; private JTextField portNumberField ; private JCheckBox syncWithTimelineCheck ; private JButton startButton ; private JButton stopButton ; private JButton clearButton ; public OSCDeviceControl ( OSCDeviceHandler deviceHandler ) { super ( deviceHandler ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; Dimension d = new Dimension ( 450 , 30 ) ; setPreferredSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; deviceNameLabel = new JLabel ( deviceHandler . getName ( ) ) ; portNumberField = new JTextField ( ) ; portNumberField . setText ( String . valueOf ( getPort ( ) ) ) ; portNumberField . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . addFocusListener ( new FocusAdapter ( ) { @Override public void focusLost ( FocusEvent focusEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . setPreferredSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; portNumberField . setMinimumSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; syncWithTimelineCheck = new JCheckBox ( " syncWithTimeline " ) ; syncWithTimelineCheck . setSelected ( isSyncedWithTimeline ( ) ) ; syncWithTimelineCheck . addItemListener ( new ItemListener ( ) { @Override public void itemStateChanged ( ItemEvent itemEvent ) { syncWithTimeline = syncWithTimelineCheck . isSelected ( ) ; setPropertyValue ( Device . TIMELINE_SYNC , String . valueOf ( syncWithTimeline ) ) ; } } ) ; startButton = new JButton ( ) ; if ( isRunning ( ) ) { startButton . setText ( isPaused ( ) ? " Start " : " Pause " ) ; } else { startButton . setText ( " Start " ) ; } startButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { startOSC ( ) ; } else if ( isPaused ( ) ) { resumeOSC ( ) ; } else { pauseOSC ( ) ; } } } ) ; stopButton = new JButton ( " Stop " ) ; stopButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { stopOSC ( ) ; } } ) ; clearButton = new JButton ( " Clear " ) ; clearButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } } ) ; add ( Box . createHorizontalStrut ( 10 ) ) ; add ( deviceNameLabel ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( portNumberField ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( syncWithTimelineCheck ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( startButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( stopButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( clearButton ) ; add ( Box . createHorizontalGlue ( ) ) ; } private void startOSC ( ) { start ( ) ; if ( isRunning ( ) ) startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void resumeOSC ( ) { resume ( ) ; startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; } private void pauseOSC ( ) { pause ( ) ; startButton . setText ( isRunning ( ) ? " Resume " : " Start " ) ; } private void stopOSC ( ) { stop ( ) ; startButton . setText ( " Start " ) ; } private void changePortNumber ( ) { try { int newPort = Integer . parseInt ( portNumberField . getText ( ) ) ; stopOSC ( ) ; oscPort = newPort ; setPropertyValue ( " port " , String . valueOf ( newPort ) ) ; } catch ( Exception e ) { todo: better error handling of invalid port values portNumberField.setText(String.valueOf(getPort())); return; } } }} 
public static Device oscDevice ( String name , long port , boolean syncWithTimeline ) { return new Device ( name , TYPE_OSC , ImmutableMap . < String , String > of ( " port " , String . valueOf ( port ) , TIMELINE_SYNC , String . valueOf ( syncWithTimeline ) ) ) ; } 
public static UpgradeStringResult upgrade19to20 ( String inputXml ) throws LoadException { UpgradeOp renameDevicePropertyOp1 = new ConvertDevicePropertyNameOp ( " osc " , " autostart " , " sync_with_timeline " ) ; UpgradeOp renameDevicePropertyOp2 = new ConvertDevicePropertyNameOp ( " audioplayer " , " autostart " , " sync_with_timeline " ) ; UpgradeOp renameDevicePropertyOp3 = new ConvertDevicePropertyNameOp ( " audioinput " , " autostart " , " sync_with_timeline " ) ; return transformXml ( inputXml , " 20 " , renameDevicePropertyOp1 , renameDevicePropertyOp2 , renameDevicePropertyOp3 ) ; } 
public void testUpgrade19to20 ( ) { File version19File = new File ( " src/test/files/upgrade-v19.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version19File ) ; NodeLibrary devicesLibrary = NodeLibrary . load ( new File ( " libraries/device/device.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version19File , NodeRepository . of ( devicesLibrary ) ) ; assertEquals ( " false " , upgradedLibrary . getDevice ( " audioinput1 " ) . getProperty ( " sync_with_timeline " ) ) ; assertEquals ( " true " , upgradedLibrary . getDevice ( " audioplayer1 " ) . getProperty ( " sync_with_timeline " ) ) ; assertEquals ( " true " , upgradedLibrary . getDevice ( " osc1 " ) . getProperty ( " sync_with_timeline " ) ) ; } 
public boolean isPaused ( ) { if ( player = = null ) return false ; return ! player . isPlaying ( ) ; } 
public void pause ( ) { if ( player = = null ) return ; player . pause ( ) ; } 
public void play ( ) { if ( player = = null ) return ; player . play ( ) ; } 
public void stopDeviceHandlers ( boolean pause ) { if ( Application . ENABLE_DEVICE_SUPPORT ) { for ( DeviceHandler handler : deviceHandlers ) { 
public void stopAnimation ( ) { stopDeviceHandlers ( true ) ; animationTimer . stop ( ) ; } 
public void rewindAnimation ( ) { stopAnimation ( ) ; stopDeviceHandlers ( false ) ; resetRenderResults ( ) ; setFrame ( 1 ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { start ( ) ; setButtons ( ) ; } 
public void actionPerformed ( ActionEvent actionEvent ) { stop ( ) ; setButtons ( ) ; } 
public void resume ( ) { if ( frame = = null ) { start ( ) ; 
public void pause ( ) { if ( frame ! = null ) { applet . pause ( ) ; 
public void actionPerformed ( ActionEvent actionEvent ) { if ( frame = = null ) { start ( ) ; } else if ( applet . isPaused ( ) ) { resume ( ) ; } else { pause ( ) ; } setButtons ( ) ; } 
public String getName ( ) ; public boolean isSyncedWithTimeline ( ) ; public void start ( ) ; public void pause ( ) ; public void resume ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public boolean isSyncedWithTimeline ( ) ; public void start ( ) ; public void pause ( ) ; public void resume ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public void start ( ) ; public void pause ( ) ; public void resume ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public void pause ( ) ; public void resume ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public void resume ( ) ; public void stop ( ) ; public AbstractDeviceControl createControl ( ) ; public void addData ( Map < String , Object > map ) ; } 
public void oscStatus ( OscStatus ignored ) { } } ) ; } @Override public void pause ( ) { paused = true ; } @Override public void resume ( ) { paused = false ; if ( oscP5 = = null ) start ( ) ; } @Override public void stop ( ) { if ( oscP5 ! = null ) oscP5 . stop ( ) ; oscP5 = null ; paused = false ; } @Override public void addData ( Map < String , Object > map ) { map . put ( getName ( ) + " .messages " , getOscMessages ( ) ) ; } @Override public AbstractDeviceControl createControl ( ) { return new OSCDeviceControl ( this ) ; } private class OSCDeviceControl extends AbstractDeviceControl { private JLabel deviceNameLabel ; private JTextField portNumberField ; private JCheckBox syncWithTimelineCheck ; private JButton startButton ; private JButton stopButton ; private JButton clearButton ; public OSCDeviceControl ( OSCDeviceHandler deviceHandler ) { super ( deviceHandler ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; Dimension d = new Dimension ( 550 , 30 ) ; setPreferredSize ( d ) ; setMaximumSize ( d ) ; setSize ( d ) ; deviceNameLabel = new JLabel ( deviceHandler . getName ( ) ) ; portNumberField = new JTextField ( ) ; portNumberField . setText ( String . valueOf ( getPort ( ) ) ) ; portNumberField . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . addFocusListener ( new FocusAdapter ( ) { @Override public void focusLost ( FocusEvent focusEvent ) { changePortNumber ( ) ; } } ) ; portNumberField . setPreferredSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; portNumberField . setMinimumSize ( new Dimension ( 70 , portNumberField . getHeight ( ) ) ) ; syncWithTimelineCheck = new JCheckBox ( " Sync with Timeline " ) ; syncWithTimelineCheck . setSelected ( isSyncedWithTimeline ( ) ) ; syncWithTimelineCheck . addItemListener ( new ItemListener ( ) { @Override public void itemStateChanged ( ItemEvent itemEvent ) { syncWithTimeline = syncWithTimelineCheck . isSelected ( ) ; setPropertyValue ( Device . TIMELINE_SYNC , String . valueOf ( syncWithTimeline ) ) ; } } ) ; startButton = new JButton ( ) ; if ( isRunning ( ) ) { startButton . setText ( isPaused ( ) ? " Start " : " Pause " ) ; } else { startButton . setText ( " Start " ) ; } startButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { if ( ! isRunning ( ) ) { startOSC ( ) ; } else if ( isPaused ( ) ) { resumeOSC ( ) ; } else { pauseOSC ( ) ; } } } ) ; stopButton = new JButton ( " Stop " ) ; stopButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { stopOSC ( ) ; } } ) ; stopButton . setEnabled ( oscP5 ! = null ) ; clearButton = new JButton ( " Clear " ) ; clearButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent actionEvent ) { oscMessages . clear ( ) ; } } ) ; add ( Box . createHorizontalStrut ( 10 ) ) ; add ( deviceNameLabel ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( portNumberField ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( syncWithTimelineCheck ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( startButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( stopButton ) ; add ( Box . createHorizontalStrut ( 5 ) ) ; add ( clearButton ) ; add ( Box . createHorizontalGlue ( ) ) ; } private void startOSC ( ) { start ( ) ; if ( isRunning ( ) ) startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; stopButton . setEnabled ( oscP5 ! = null ) ; } private void resumeOSC ( ) { resume ( ) ; startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; stopButton . setEnabled ( true ) ; } private void pauseOSC ( ) { pause ( ) ; startButton . setText ( isRunning ( ) ? " Resume " : " Start " ) ; stopButton . setEnabled ( true ) ; } private void stopOSC ( ) { stop ( ) ; startButton . setText ( " Start " ) ; stopButton . setEnabled ( false ) ; } private void changePortNumber ( ) { try { int newPort = Integer . parseInt ( portNumberField . getText ( ) ) ; stopOSC ( ) ; oscPort = newPort ; setPropertyValue ( " port " , String . valueOf ( newPort ) ) ; } catch ( Exception e ) { todo: better error handling of invalid port values portNumberField.setText(String.valueOf(getPort())); return; } } }} 
public void resume ( ) { paused = false ; if ( oscP5 = = null ) start ( ) ; 
private void startOSC ( ) { start ( ) ; if ( isRunning ( ) ) startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; stopButton . setEnabled ( oscP5 ! = null ) ; } 
private void resumeOSC ( ) { resume ( ) ; startButton . setText ( isRunning ( ) ? " Pause " : " Start " ) ; stopButton . setEnabled ( true ) ; } 
private void pauseOSC ( ) { pause ( ) ; startButton . setText ( isRunning ( ) ? " Resume " : " Start " ) ; stopButton . setEnabled ( true ) ; } 
private void stopOSC ( ) { stop ( ) ; startButton . setText ( " Start " ) ; stopButton . setEnabled ( false ) ; } 
public void playAnimation ( ) { if ( ! playButton . isChecked ( ) ) playButton . setChecked ( true ) ; document . playAnimation ( ) ; playButton . setText ( " Pause " ) ; playButton . setToolTipText ( " Pause Animation " ) ; playButton . setActionMethod ( this , " stopAnimation " ) ; forcePlayButtonWidth ( 52 ) ; } 
public void stopAnimation ( ) { if ( playButton . isChecked ( ) ) playButton . setChecked ( false ) ; document . stopAnimation ( ) ; playButton . setText ( " Play " ) ; playButton . setToolTipText ( " Play Animation " ) ; playButton . setActionMethod ( this , " playAnimation " ) ; forcePlayButtonWidth ( 52 ) ; } 
public void testUpgrade16to17 ( ) { File version16File = new File ( " src/test/files/upgrade-v16.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version16File ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version16File , NodeRepository . of ( ) ) ; assertFalse ( upgradedLibrary . hasProperty ( " oscPort " ) ) ; assertTrue ( upgradedLibrary . hasDevice ( " osc1 " ) ) ; assertEquals ( 1 , upgradedLibrary . getDevices ( ) . size ( ) ) ; assertEquals ( " 2084 " , upgradedLibrary . getDevices ( ) . get ( 0 ) . getProperties ( ) . get ( " port " ) ) ; assertEquals ( " true " , upgradedLibrary . getDevices ( ) . get ( 0 ) . getProperties ( ) . get ( " sync_with_timeline " ) ) ; was: autostart } 
private void selectAndClose ( ) { if ( nodeList . getModel ( ) . getSize ( ) = = 0 ) return ; selectedNode = ( Node ) nodeList . getSelectedValue ( ) ; closeDialog ( ) ; } 
public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; Application . getInstance ( ) . quit ( ) ; } 
private static NodeLibrary systemLibrary ( String systemLibraryDir , String name ) { String fileName = String . format ( " %s/%s/%s.ndbx " , systemLibraryDir , name , name ) ; return NodeLibrary . load ( new File ( fileName ) , NodeRepository . of ( ) ) ; } 
public static void printUsage ( ) { System . out . println ( " Usage: java -jar nodebox.jar [options] <inputFile.ndbx> " ) ; System . out . println ( " Options: " ) ; System . out . println ( " -o FILE Specify the output file. Only PNG is supported for now. (Default: inputFile.png) " ) ; System . out . println ( " -l DIR Location of the NodeBox system libraries directory. (Default: current directory) " ) ; } 
public static void main ( String [ ] args ) { String inputFile = null ; String outputFile = null ; String systemLibraryDir = null ; File inFile = null ; File outFile ; for ( int i = 0 ; i < args . length ; i + + ) { String arg = args [ i ] ; if ( arg . equals ( " -o " ) ) { outputFile = args [ i + 1 ] ; i + = 1 ; } else if ( arg . equals ( " -l " ) ) { systemLibraryDir = args [ i + 1 ] ; i + = 1 ; } else { inputFile = args [ i ] ; } } if ( inputFile = = null ) { printUsage ( ) ; System . exit ( - 1 ) ; } else { inFile = new File ( inputFile ) ; } if ( outputFile = = null ) { outFile = new File ( FileUtils . getBaseName ( inFile . getAbsolutePath ( ) ) + " .png " ) ; } else { outFile = new File ( outputFile ) ; } if ( systemLibraryDir = = null ) { systemLibraryDir = " libraries " ; } NodeRepository systemRepository = getSystemRepository ( systemLibraryDir ) ; NodeLibrary library ; try { library = NodeLibrary . load ( inFile , systemRepository ) ; } catch ( OutdatedLibraryException e ) { UpgradeResult result = NodeLibraryUpgrades . upgrade ( inFile ) ; The file is used here as the base name for finding relative libraries. library = result.getLibrary(inFile, systemRepository); } FunctionRepository functionRepository = FunctionRepository.combine(systemRepository.getFunctionRepository(), library.getFunctionRepository()); library.getRoot(); NodeContext ctx = new NodeContext(library, functionRepository); List<?> result = ctx.renderNode(library.getRoot()); Rect bounds = library.getBounds(); BufferedImage img = new BufferedImage( (int) Math.ceil(bounds.getWidth()), (int) Math.ceil(bounds.getHeight()), BufferedImage.TYPE_INT_ARGB); Graphics2D g = img.createGraphics(); g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g.translate(-bounds.getX(), -bounds.getY()); GrobVisualizer.INSTANCE.draw(g, result); img.flush(); try { ImageIO.write(img, "png", outFile); 
public void deleteSelection ( ) { Delete the nodes from the document document.removeNodes(getSelectedNodes()); Remove the deleted nodes from the current selection selectedNodes.clear(); } 
public void draw ( GraphicsContext ctx ) { Point cp = ( Point ) getValue ( positionName ) ; if ( cp = = null ) { return ; } double cx = cp . x ; double cy = cp . y ; double width = ( Double ) getValue ( widthName ) ; double height = ( Double ) getValue ( heightName ) ; double left = cx - width / 2 ; double right = cx + width / 2 ; double top = cy - height / 2 ; double bottom = cy + height / 2 ; Path cornerPath = new Path ( ) ; cornerPath . setFillColor ( HANDLE_COLOR ) ; cornerPath . setStrokeWidth ( 0 ) ; drawDot ( cornerPath , left , top ) ; drawDot ( cornerPath , right , top ) ; drawDot ( cornerPath , right , bottom ) ; drawDot ( cornerPath , left , bottom ) ; drawDot ( cornerPath , cx , cy ) ; ctx . draw ( cornerPath ) ; Path strokePath = new Path ( ) ; strokePath . setFillColor ( null ) ; strokePath . setStrokeColor ( HANDLE_COLOR ) ; strokePath . rect ( cx , cy , width , height ) ; ctx . draw ( strokePath ) ; } 
public static File getUserDataDirectory ( ) throws RuntimeException { if ( userDataDirectory ! = null ) return userDataDirectory ; if ( onMac ( ) ) { userDataDirectory = new File ( getHomeDirectory ( ) , " Library/ " + Application . NAME ) ; } else if ( onWindows ( ) ) { String localAppData ; HWND hwndOwner = null ; int nFolder = Shell32 . CSIDL_LOCAL_APPDATA ; HANDLE hToken = null ; int dwFlags = Shell32 . SHGFP_TYPE_CURRENT ; char [ ] pszPath = new char [ Shell32 . MAX_PATH ] ; int hResult = Shell32 . INSTANCE . SHGetFolderPath ( hwndOwner , nFolder , hToken , dwFlags , pszPath ) ; if ( Shell32 . S_OK = = hResult ) { String path = new String ( pszPath ) ; int len = path . indexOf ( '\0' ) ; localAppData = path . substring ( 0 , len ) ; } else { If the native call fails, use the home directory. localAppData = getHomeDirectory().getPath(); } userDataDirectory = new File(localAppData, Application.NAME); } else { userDataDirectory = new File(getHomeDirectory(), ".local/share/" + Application.NAME.toLowerCase(Locale.US)); } return userDataDirectory; } 
private int calcHashCode ( ) { return Objects . hashCode ( prototype , name , comment , category , description , image , function , position , inputs , outputType , outputRange , isNetwork , children , renderedChildName , connections , handle , isAlwaysRendered ) ; 
private java . util . List < Node > filterNodes ( java . util . List < Node > nodes , String searchString ) { Pattern findFirstLettersPattern = Pattern . compile ( " ^ " + StringUtils . join ( searchString , " \\ w*_ " ) + " .* " ) ; Pattern findConsecutiveLettersPattern = Pattern . compile ( " .* " + searchString + " .* " ) ; Pattern findNonConsecutiveLettersPattern = Pattern . compile ( " .* " + StringUtils . join ( searchString , " \\ w* " ) + " .* " ) ; java . util . List < Node > sortedNodes = new ArrayList < Node > ( ) ; java . util . List < Node > firstLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > consecutiveLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > nonConsecutiveLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > descriptionNodes = new ArrayList < Node > ( ) ; for ( Node node : nodes ) { if ( node . getName ( ) . equals ( searchString ) ) sortedNodes . add ( 0 , node ) ; else if ( node . getName ( ) . startsWith ( searchString ) ) firstLettersNodes . add ( node ) ; else if ( findFirstLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) firstLettersNodes . add ( node ) ; else if ( findConsecutiveLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) consecutiveLettersNodes . add ( node ) ; else if ( findNonConsecutiveLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) nonConsecutiveLettersNodes . add ( node ) ; else if ( node . getDescription ( ) . contains ( searchString ) ) descriptionNodes . add ( node ) ; } Collections . sort ( firstLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( firstLettersNodes ) ; Collections . sort ( consecutiveLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( consecutiveLettersNodes ) ; Collections . sort ( nonConsecutiveLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( nonConsecutiveLettersNodes ) ; Collections . sort ( descriptionNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( descriptionNodes ) ; return sortedNodes ; } 
private java . util . List < Node > filterNodes ( java . util . List < Node > nodes , String searchString ) { Pattern findFirstLettersPattern = Pattern . compile ( " ^ " + StringUtils . join ( searchString , " \\ w*_ " ) + " .* " ) ; Pattern findConsecutiveLettersPattern = Pattern . compile ( " .* " + searchString + " .* " ) ; Pattern findNonConsecutiveLettersPattern = Pattern . compile ( " .* " + StringUtils . join ( searchString , " \\ w* " ) + " .* " ) ; java . util . List < Node > sortedNodes = new ArrayList < Node > ( ) ; java . util . List < Node > startsWithNodes = new ArrayList < Node > ( ) ; java . util . List < Node > firstLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > consecutiveLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > nonConsecutiveLettersNodes = new ArrayList < Node > ( ) ; java . util . List < Node > descriptionNodes = new ArrayList < Node > ( ) ; for ( Node node : nodes ) { if ( node . getName ( ) . equals ( searchString ) ) sortedNodes . add ( 0 , node ) ; else if ( node . getName ( ) . startsWith ( searchString ) ) startsWithNodes . add ( node ) ; else if ( findFirstLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) firstLettersNodes . add ( node ) ; else if ( findConsecutiveLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) consecutiveLettersNodes . add ( node ) ; else if ( findNonConsecutiveLettersPattern . matcher ( node . getName ( ) ) . matches ( ) ) nonConsecutiveLettersNodes . add ( node ) ; else if ( node . getDescription ( ) . contains ( searchString ) ) descriptionNodes . add ( node ) ; } Collections . sort ( startsWithNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( startsWithNodes ) ; Collections . sort ( firstLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( firstLettersNodes ) ; Collections . sort ( consecutiveLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( consecutiveLettersNodes ) ; Collections . sort ( nonConsecutiveLettersNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( nonConsecutiveLettersNodes ) ; Collections . sort ( descriptionNodes , new NodeNameComparator ( ) ) ; sortedNodes . addAll ( descriptionNodes ) ; return sortedNodes ; } 
public static Point centroid ( IGeometry shape ) { if ( shape = = null ) return Point . ZERO ; Rect bounds = shape . getBounds ( ) ; return new Point ( bounds . x + bounds . width / 2 , bounds . y + bounds . height / 2 ) ; } 
public void doExport ( ) { ExportDialog d = new ExportDialog ( this ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return ; nodebox . ui . ImageFormat chosenFormat = d . getFormat ( ) ; File chosenFile = FileUtils . showSaveDialog ( this , lastExportPath , " png,pdf,svg " , " Image file " ) ; if ( chosenFile = = null ) return ; lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; exportToFile ( chosenFile , chosenFormat ) ; } 
public String toCSS ( ) { if ( ! isVisible ( ) ) { return " none " ; } StringBuilder sb = new StringBuilder ( ) ; int r256 = ( int ) Math . round ( r * 255 ) ; int g256 = ( int ) Math . round ( g * 255 ) ; int b256 = ( int ) Math . round ( b * 255 ) ; if ( a = = 1.0 ) { return " # " 
public static String smartFloat ( double v ) { if ( ( long ) v = = v ) { return String . valueOf ( ( long ) v ) ; 
public static void appendFloat ( StringBuilder sb , double v ) { sb . append ( smartFloat ( v ) ) ; } 
public static Element renderSVG ( Iterable < ? > objects , Rectangle2D bounds ) { LinkedList < Element > elements = new LinkedList < Element > ( ) ; for ( Object o : objects ) { if ( o instanceof Geometry ) { elements . add ( renderGeometry ( ( Geometry ) o ) ) ; } else if ( o instanceof Path ) { elements . add ( renderPath ( ( Path ) o ) ) ; } else { throw new RuntimeException ( " Don't know how to render " + o . getClass ( ) . getName ( ) ) ; } } StringBuilder viewBox = new StringBuilder ( ) ; appendFloat ( viewBox , bounds . getX ( ) ) ; viewBox . append ( ' ' ) ; appendFloat ( viewBox , bounds . getY ( ) ) ; viewBox . append ( ' ' ) ; appendFloat ( viewBox , bounds . getWidth ( ) ) ; viewBox . append ( ' ' ) ; appendFloat ( viewBox , bounds . getHeight ( ) ) ; Map < String , String > attrs = ImmutableMap . of ( " xmlns " , " http:www.w3.org/2000/svg " , " width " , smartFloat ( bounds . getWidth ( ) ) , " height " , smartFloat ( bounds . getHeight ( ) ) , " viewBox " , viewBox . toString ( ) ) ; return new Element ( " svg " , attrs , elements ) ; } 
public static String renderToString ( Iterable < ? > objects , Rectangle2D bounds ) { checkArgument ( objects ! = null ) ; Element svg = renderSVG ( objects , bounds ) ; return XML_DECLARATION + svg . toString ( 4 , 0 ) ; } 
public static void renderToFile ( Iterable < ? > objects , Rectangle2D bounds , File file ) { checkArgument ( objects ! = null ) ; FileUtils . writeFile ( file , renderToString ( objects , bounds ) ) ; } 
public boolean isSelfClosing ( ) { return this . children = = null ; } 
public String toString ( ) { return toString ( 4 , 0 ) ; } 
public String toString ( int indent , int start ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < start ; i + + ) { sb . append ( ' ' ) ; } sb . append ( " < " ) ; sb . append ( tag ) ; if ( attributes ! = null ) { for ( Map . Entry < String , String > entry : attributes . entrySet ( ) ) { sb . append ( " " ) ; sb . append ( entry . getKey ( ) ) ; sb . append ( " = \" " ) ; sb . append ( entry . getValue ( ) ) ; sb . append ( " \" " ) ; } } if ( isSelfClosing ( ) ) { sb . append ( " /> " ) ; } else { sb . append ( " > " ) ; for ( Element child : children ) { sb . append ( child . toString ( indent , start + indent ) ) ; sb . append ( '' ) ; } for ( int i = 0 ; i < start ; i + + ) { sb . append ( ' ' ) ; } sb . append ( " </ " ) ; sb . append ( tag ) ; sb . append ( " > " ) ; } return sb . toString ( ) ; } 
public void testRenderPath ( ) { SVGRenderer . Element el ; Path p = new Path ( ) ; p . line ( 10 , 20 , 30 , 40 ) ; el = renderPath ( p ) ; assertElementEquals ( " <path d= \" M10,20L30,40 \" /> " , el ) ; p . close ( ) ; el = renderPath ( p ) ; assertElementEquals ( " <path d= \" M10,20L30,40Z \" /> " , el ) ; } 
public void testColor ( ) { Path p = new Path ( ) ; p . line ( 10 , 20 , 30 , 40 ) ; p . setFill ( new Color ( " #334455 " ) ) ; SVGRenderer . Element el = renderPath ( p ) ; assertElementEquals ( " <path d= \" M10,20L30,40 \" fill= \" #334455 \" /> " , el ) ; } 
public void testRenderSVG ( ) { Path p = new Path ( ) ; p . line ( 10 , 20 , 30 , 40 ) ; String svg = renderToString ( ImmutableList . of ( p ) , new Rectangle2D . Float ( 0 , 0 , 800 , 600 ) ) ; assertEquals ( XML_DECLARATION + " <svg xmlns= \" http:www.w3.org/2000/svg \" width= \" 800 \" height= \" 600 \" viewBox= \" 0 0 800 600 \" > " + " <path d= \" M10,20L30,40 \" /> " + 
private void assertElementEquals ( String expected , SVGRenderer . Element el ) { assertEquals ( expected , el . toString ( ) ) ; } 
public static List < ? > distinct ( Iterable < ? > iterable , String key ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( key ! = null ) { key = key . trim ( ) . isEmpty ( ) ? null : key ; } Set < Integer > distinctKeys = new HashSet < Integer > ( ) ; ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; for ( Object object : iterable ) { final Integer hashCode ; if ( key = = null ) { hashCode = object = = null ? null : object . hashCode ( ) ; } else { Object v = DataFunctions . lookup ( object , key ) ; hashCode = v = = null ? null : v . hashCode ( ) ; } if ( hashCode ! = null & & distinctKeys . contains ( hashCode ) ) continue ; distinctKeys . add ( hashCode ) ; b . add ( object ) ; } return b . build ( ) ; } 
private void setNodeBoxVersion ( ) throws RuntimeException { Properties properties = new Properties ( ) ; try { InputStream in = Application . class . getResourceAsStream ( " /version.properties " ) ; 
private void lookForLibraries ( ) { List < NodeLibrary > libraries = new ArrayList < NodeLibrary > ( ) ; libraries . add ( NodeLibrary . loadSystemLibrary ( " math " ) ) ; libraries . add ( NodeLibrary . loadSystemLibrary ( " string " ) ) ; libraries . add ( NodeLibrary . loadSystemLibrary ( " color " ) ) ; libraries . add ( NodeLibrary . loadSystemLibrary ( " list " ) ) ; libraries . add ( NodeLibrary . loadSystemLibrary ( " data " ) ) ; libraries . add ( NodeLibrary . loadSystemLibrary ( " corevector " ) ) ; libraries . add ( NodeLibrary . loadSystemLibrary ( " network " ) ) ; if ( Application . ENABLE_DEVICE_SUPPORT ) { libraries . add ( NodeLibrary . loadSystemLibrary ( " device " ) ) ; } systemRepository = NodeRepository . of ( libraries . toArray ( new NodeLibrary [ ] { } ) ) ; } 
public static NodeLibrary loadSystemLibrary ( String libraryName ) throws LoadException { File libraryFile = new File ( systemLibrariesDir , String . format ( " %s/%s.ndbx " , libraryName , libraryName ) ) ; NodeRepository repository = libraryName . equals ( " core " ) ? NodeRepository . empty ( ) : NodeRepository . of ( ) ; return load ( libraryFile , repository ) ; } 
public synchronized static void initializePython ( ) { if ( isInitialized . get ( ) ) return ; Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = Platform.getUserDataDirectory() + Platform.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. File pythonLibraries = new File(libDir, "python.zip"); File nodeBoxLibraries = new File(libDir, "nodeboxlibs.zip"); Py.getSystemState().path.add(new PyString(pythonLibraries.getAbsolutePath())); Py.getSystemState().path.add(new PyString(nodeBoxLibraries.getAbsolutePath())); This folder contains unarchived NodeBox libraries. Only used in development. File developmentLibraries = new File("src/main/python"); Py.getSystemState().path.add(new PyString(developmentLibraries.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(Platform.getUserPythonDirectory().getAbsolutePath())); isInitialized.set(true); } 
public static void main ( String [ ] args ) { final Application app = new Application ( ) ; Ignore OS X's weird launch parameter. if (args.length == 1 && !args[0].startsWith("-psn")) { app.filesToLoad.add(new File(args[0])); } SwingUtilities.invokeLater(new Runnable() { public void run() { 
private ImageFormat imageFormatForFile ( File file ) { if ( file . getName ( ) . toLowerCase ( Locale . US ) . endsWith ( " .pdf " ) ) return ImageFormat . PDF ; return ImageFormat . PNG ; } 
private static void writePort ( Document doc , Element parent , Node node , Port port , Port . Direction direction ) { We only write out the ports that have changed with regards to the prototype. Node protoNode = node.getPrototype(); Port protoPort = null; if (protoNode != null) protoPort = protoNode.getInput(port.getName()); If the port and its prototype are equal, don't write anything. if (port.equals(protoPort)) return; Element el = doc.createElement("port"); el.setAttribute("name", port.getName()); el.setAttribute("type", port.getType()); if (shouldWriteAttribute(node, port, Port.Attribute.LABEL)) el.setAttribute("label", port.getLabel()); if (shouldWriteAttribute(node, port, Port.Attribute.CHILD_REFERENCE) && port.getChildReference() != null) el.setAttribute("childReference", port.getChildReference()); if (shouldWriteAttribute(node, port, Port.Attribute.WIDGET)) el.setAttribute("widget", port.getWidget().toString().toLowerCase(Locale.US)); if (shouldWriteAttribute(node, port, Port.Attribute.RANGE)) el.setAttribute("range", port.getRange().toString().toLowerCase(Locale.US)); if (port.isStandardType()) el.setAttribute("value", port.stringValue()); if (shouldWriteAttribute(node, port, Port.Attribute.DESCRIPTION)) el.setAttribute("description", port.getDescription()); if (shouldWriteAttribute(node, port, Port.Attribute.MINIMUM_VALUE)) if (port.getMinimumValue() != null) el.setAttribute("min", String.format(Locale.US, "%s", port.getMinimumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MAXIMUM_VALUE)) if (port.getMaximumValue() != null) el.setAttribute("max", String.format(Locale.US, "%s", port.getMaximumValue())); if (shouldWriteAttribute(node, port, Port.Attribute.MENU_ITEMS)) writeMenuItems(doc, el, port.getMenuItems()); parent.appendChild(el); } 
private static Node createNode ( Map < String , String > attributeMap , Node extendFromNode , Node parent , NodeRepository nodeRepository ) { String prototypeId = attributeMap . get ( " prototype " ) ; String name = attributeMap . get ( " name " ) ; String comment = attributeMap . get ( " comment " ) ; String category = attributeMap . get ( " category " ) ; String description = attributeMap . get ( " description " ) ; String image = attributeMap . get ( " image " ) ; String function = attributeMap . get ( " function " ) ; String outputType = attributeMap . get ( " outputType " ) ; String outputRange = attributeMap . get ( " outputRange " ) ; String position = attributeMap . get ( " position " ) ; String handle = attributeMap . get ( " handle " ) ; String alwaysRendered = attributeMap . get ( " alwaysRendered " ) ; Node prototype = prototypeId = = null ? extendFromNode : lookupNode ( prototypeId , parent , nodeRepository ) ; if ( prototype = = null ) return null ; Node node = prototype . extend ( ) ; if ( name ! = null ) node = node . withName ( name ) ; if ( comment ! = null ) node = node . withComment ( comment ) ; if ( category ! = null ) node = node . withCategory ( category ) ; if ( description ! = null ) node = node . withDescription ( description ) ; if ( image ! = null ) node = node . withImage ( image ) ; if ( function ! = null ) node = node . withFunction ( function ) ; if ( outputType ! = null ) node = node . withOutputType ( outputType ) ; if ( outputRange ! = null ) node = node . withOutputRange ( Port . Range . valueOf ( outputRange . toUpperCase ( Locale . US ) ) ) ; if ( position ! = null ) node = node . withPosition ( Point . valueOf ( position ) ) ; if ( handle ! = null ) node = node . withHandle ( handle ) ; if ( alwaysRendered ! = null ) node = node . withAlwaysRenderedSet ( Boolean . parseBoolean ( alwaysRendered ) ) ; return node ; } 
public static Port parsedPort ( String name , String type , String stringValue ) { return parsedPort ( name , type , " " , " " , DEFAULT_RANGE . toString ( ) . toLowerCase ( Locale . US ) , stringValue , " " , null , null , ImmutableList . < MenuItem > of ( ) ) ; } 
private static Widget parseWidget ( String valueString ) { return Widget . valueOf ( valueString . toUpperCase ( Locale . US ) ) ; } 
public void actionPerformed ( ActionEvent e ) { String s = hexField . getText ( ) . toLowerCase ( Locale . US ) ; if ( ! s . startsWith ( " # " ) ) s = " # " + s ; if ( s . length ( ) = = 7 ) s = s + " ff " ; try { nodebox . graphics . Color c = new nodebox . graphics . Color ( s ) ; red = ( float ) c . getRed ( ) ; green = ( float ) c . getGreen ( ) ; blue = ( float ) c . getBlue ( ) ; alpha = ( float ) c . getAlpha ( ) ; } catch ( IllegalArgumentException ex ) { JOptionPane . showMessageDialog ( ColorDialog . this , ex . getMessage ( ) ) ; } updateHSB ( ) ; updateColor ( ) ; } 
public static ImageFormat of ( String name ) { return FORMAT_MAP . get ( name . toUpperCase ( Locale . US ) ) ; } 
public String ensureFileExtension ( String file ) { if ( file . toLowerCase ( Locale . US ) . endsWith ( " . " + getExtension ( ) ) ) return file ; return file + " . " + getExtension ( ) ; } 
public void testPortRangeOverride ( ) { NodeLibrary listLibrary = NodeLibrary . load ( new File ( " libraries/list/list.ndbx " ) , NodeRepository . of ( ) ) ; Node slicePrototype = listLibrary . getRoot ( ) . getChild ( " slice " ) ; Node slice1 = slicePrototype . extend ( ) . withName ( " slice1 " ) . withInputChanged ( " list " , slicePrototype . getInput ( " list " ) . withRange ( Port . Range . VALUE ) ) ; NodeLibrary originalLibrary = NodeLibrary . create ( " test " , slice1 , NodeRepository . of ( listLibrary ) , functions ) ; NodeLibrary library = NodeLibrary . load ( " test " , originalLibrary . toXml ( ) , NodeRepository . of ( listLibrary ) ) ; assertEquals ( Port . Range . VALUE , library . getRoot ( ) . getInput ( " list " ) . getRange ( ) ) ; } 
public static List < ? > keys ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; ImmutableSet . Builder < String > b = ImmutableSet . builder ( ) ; for ( Object o : iterable ) { if ( o instanceof Map ) { Map m = ( Map ) o ; b . addAll ( m . keySet ( ) ) ; } } return b . build ( ) . asList ( ) ; } 
public void testKeys ( ) { assertEquals ( ImmutableList . of ( ) , ListFunctions . keys ( null ) ) ; assertEquals ( ImmutableList . of ( " a " ) , ListFunctions . keys ( ImmutableList . of ( ImmutableMap . of ( " a " , 1 ) ) ) ) ; assertEquals ( ImmutableList . of ( " a " ) , ListFunctions . keys ( ImmutableList . of ( ImmutableMap . of ( " a " , 1 ) , ImmutableMap . of ( " a " , 2 ) ) ) ) ; assertEquals ( ImmutableList . of ( " a " , " b " ) , ListFunctions . keys ( ImmutableList . of ( ImmutableMap . of ( " a " , 1 ) , ImmutableMap . of ( " b " , 2 ) ) ) ) ; } 
public static List < ? > keys ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; ImmutableSet . Builder < String > b = ImmutableSet . builder ( ) ; for ( Object o : iterable ) { if ( o instanceof Map ) { Map m = ( Map ) o ; b . addAll ( m . keySet ( ) ) ; } else { b . addAll ( ReflectionUtils . getProperties ( o ) ) ; } } return b . build ( ) . asList ( ) ; } 
public void renderFullScreen ( ) { if ( fullScreenFrame ! = null ) closeFullScreenWindow ( ) ; fullScreenFrame = new FullScreenFrame ( this ) ; fullScreenFrame . setVisible ( true ) ; fullScreenFrame . setOutputValues ( lastRenderResult ) ; fullScreenFrame . getViewer ( ) . setHandle ( viewerPane . getHandle ( ) ) ; } 
public void renderFullScreen ( ) { if ( fullScreenFrame ! = null ) closeFullScreenWindow ( ) ; fullScreenFrame = new FullScreenFrame ( this ) ; fullScreenFrame . setVisible ( true ) ; fullScreenFrame . setOutputValues ( lastRenderResult ) ; fullScreenFrame . getViewer ( ) . setHandle ( viewerPane . getHandle ( ) ) ; fullScreenFrame . getViewer ( ) . setShowHandle ( viewerPane . getViewer ( ) . hasVisibleHandle ( ) ) ; } 
public void mouseClicked ( MouseEvent e ) { We register the mouse click as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; handle.mouseClicked(pointForEvent(e)); } 
public void mousePressed ( MouseEvent e ) { We register the mouse press as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; handle.mousePressed(pointForEvent(e)); } 
public void mouseReleased ( MouseEvent e ) { We register the mouse release as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; handle.mouseReleased(pointForEvent(e)); } 
public void mouseEntered ( MouseEvent e ) { Entering the viewer with your mouse should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; handle.mouseEntered(pointForEvent(e)); } 
public void mouseExited ( MouseEvent e ) { Exiting the viewer with your mouse should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; handle.mouseExited(pointForEvent(e)); } 
public void mouseDragged ( MouseEvent e ) { We register the mouse drag as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (isPanning()) return; handle.mouseDragged(pointForEvent(e)); lastMousePosition = pointForEvent(e); } 
public void mouseMoved ( MouseEvent e ) { Moving the mouse in the viewer area should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; handle.mouseMoved(pointForEvent(e)); lastMousePosition = pointForEvent(e); } 
public void keyTyped ( KeyEvent e ) { handle . keyTyped ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; } 
public void keyPressed ( KeyEvent e ) { handle . keyPressed ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; } 
public void mouseClicked ( MouseEvent e ) { We register the mouse click as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (handle != null) handle.mouseClicked(pointForEvent(e)); 
public void mousePressed ( MouseEvent e ) { We register the mouse press as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (handle != null) handle.mousePressed(pointForEvent(e)); 
public void mouseReleased ( MouseEvent e ) { We register the mouse release as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (handle != null) handle.mouseReleased(pointForEvent(e)); 
public void mouseEntered ( MouseEvent e ) { Entering the viewer with your mouse should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; if (handle != null) handle.mouseEntered(pointForEvent(e)); 
public void mouseExited ( MouseEvent e ) { Exiting the viewer with your mouse should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; if (handle != null) handle.mouseExited(pointForEvent(e)); 
public void mouseDragged ( MouseEvent e ) { We register the mouse drag as an edit since it can trigger a change to the node. if (e.isPopupTrigger()) return; if (isPanning()) return; if (handle != null) handle.mouseDragged(pointForEvent(e)); lastMousePosition = pointForEvent(e); } 
public void mouseMoved ( MouseEvent e ) { Moving the mouse in the viewer area should not change the node, so we do not register an edit. if (e.isPopupTrigger()) return; if (handle != null) handle.mouseMoved(pointForEvent(e)); lastMousePosition = pointForEvent(e); } 
public void keyTyped ( KeyEvent e ) { if ( handle ! = null ) handle . keyTyped ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public void keyPressed ( KeyEvent e ) { if ( handle ! = null ) handle . keyPressed ( e . getKeyCode ( ) , e . getModifiersEx ( ) ) ; 
public static List < IGeometry > copy ( IGeometry shape , long copies , String order , Point translate , double rotate , Point scale ) { ImmutableList . Builder < IGeometry > builder = ImmutableList . builder ( ) ; Geometry geo = new Geometry ( ) ; double tx = 0 ; double ty = 0 ; double r = 0 ; double sx = 1.0 ; double sy = 1.0 ; char [ ] cOrder = order . toCharArray ( ) ; for ( long i = 0 ; i < copies ; i + + ) { Transform = new Transform ( ) ; Each letter of the order describes an operation. for (char op : cOrder) { if (op == 't') { t.translate(tx, ty); } else if (op == 'r') { t.rotate(r); } else if (op == 's') { t.scale(sx, sy); } } builder.add(t.map(shape)); tx += translate.x; ty += translate.y; r += rotate; sx += scale.x / 100 - 1; sy += scale.y / 100 - 1; } return builder.build(); } 
public static UpgradeStringResult upgrade20to21 ( String inputXml ) throws LoadException { Version 21: Use percentages for the scale parameter in the copy node, like in the scale node. UpgradeOp copyScaleValueOp = new UpgradeOp() { @Override public void apply(Element e) { if (!e.getTagName().equals("node")) return; if (isNodeWithPrototype(e, "corevector.copy")) { Element scalePort = portWithName(e, "scale"); if (scalePort != null) { Attr scaleValue = scalePort.getAttributeNode("value"); if (scaleValue == null) { return; } Point pt = Point.valueOf(scaleValue.getValue()); pt = new Point((pt.x + 1) * 100, (pt.y + 1) * 100); scaleValue.setValue(String.valueOf(pt)); } } } }; return transformXml(inputXml, "21", copyScaleValueOp); } 
public void apply ( Element e ) { if ( ! e . getTagName ( ) . equals ( " node " ) ) return ; if ( isNodeWithPrototype ( e , " corevector.copy " ) ) { Element scalePort = portWithName ( e , " scale " ) ; 
public void testUpgrade20to21 ( ) { File version20File = new File ( " src/test/files/upgrade-v20.ndbx " ) ; UpgradeResult result = NodeLibraryUpgrades . upgrade ( version20File ) ; NodeLibrary corevectorLibrary = NodeLibrary . load ( new File ( " libraries/corevector/corevector.ndbx " ) , NodeRepository . of ( ) ) ; NodeLibrary upgradedLibrary = result . getLibrary ( version20File , NodeRepository . of ( corevectorLibrary ) ) ; Node root = upgradedLibrary . getRoot ( ) ; assertEquals ( new Point ( 200 , 150 ) , root . getChild ( " copy1 " ) . getInput ( " scale " ) . getValue ( ) ) ; assertEquals ( new Point ( 100 , 100 ) , root . getChild ( " copy2 " ) . getInput ( " scale " ) . getValue ( ) ) ; } 
public static Colorizable colorize ( Colorizable shape , Color fill , Color stroke , double strokeWidth ) { if ( shape = = null ) return null ; Colorizable newShape = shape . clone ( ) ; newShape . setFill ( fill ) ; if ( strokeWidth > 0 ) { newShape . setStrokeColor ( stroke ) ; newShape . setStrokeWidth ( strokeWidth ) ; } else { newShape . setStrokeColor ( null ) ; newShape . setStrokeWidth ( 0 ) ; } return newShape ; } 
public void updateFunctionLibraries ( ) { functionLibraries = new ArrayList < > ( ) ; functionLibraries . addAll ( functionRepository . getLibraries ( ) ) ; functionLibraries . remove ( CoreFunctions . LIBRARY ) ; } 
public void initPanel ( ) { The panel uses an absolute layout. setLayout(null); Category categoryField = new JTextField(20); categoryField.addActionListener(this); categoryField.addFocusListener(this); addRow("Category", categoryField); Description descriptionField = new JTextField(20); descriptionField.addActionListener(this); descriptionField.addFocusListener(this); addRow("Description", descriptionField); Image imageField = new JTextField(20); imageField.addActionListener(this); imageField.addFocusListener(this); addRow("Image", imageField); Output Type outputTypeField = new JTextField(20); outputTypeField.addActionListener(this); outputTypeField.addFocusListener(this); addRow("Output Type", outputTypeField); Output Range outputRangeBox = new JComboBox<>(humanizedRanges); outputRangeBox.addActionListener(this); addRow("Output Range", outputRangeBox); Function functionField = new JTextField(20); functionField.addActionListener(this); functionField.addFocusListener(this); addRow("Function", functionField); Handle Function handleField = new JTextField(20); handleField.addActionListener(this); handleField.addFocusListener(this); addRow("Handle Function", handleField); } 
public void actionPerformed ( ActionEvent e ) { Font font = ( Font ) fontChooser . getSelectedItem ( ) ; if ( font = = null ) return ; setPortValue ( font . getFontName ( ) ) ; } 
public synchronized String nextWithPrefix ( String prefix ) { int number = MoreObjects . firstNonNull ( prefixMap . get ( prefix ) , 0 ) ; number + + ; prefixMap . put ( prefix , number ) ; return prefix + number ; } 
public static List < ? > doSwitch ( Iterable list1 , Iterable list2 , Iterable list3 , Iterable list4 , Iterable list5 , Iterable list6 , long index ) { Iterable < ? > returnList ; switch ( ( int ) index % 6 ) { case 0 : returnList = list1 ; break ; case 1 : returnList = list2 ; break ; case 2 : returnList = list3 ; break ; case 3 : returnList = list4 ; break ; case 4 : returnList = list5 ; break ; case 5 : returnList = list6 ; break ; default : throw new AssertionError ( ) ; } if ( returnList = = null ) return ImmutableList . of ( ) ; return ImmutableList . copyOf ( returnList ) ; } 
public static List < ? > distinct ( Iterable < ? > iterable , String key ) { if ( iterable = = null ) return ImmutableList . of ( ) ; if ( key ! = null ) { key = key . trim ( ) . isEmpty ( ) ? null : key ; } Set < Integer > distinctKeys = new HashSet < > ( ) ; ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; for ( Object object : iterable ) { if ( object = = null ) continue ; final Integer hashCode ; if ( key = = null ) { hashCode = object . hashCode ( ) ; } else { Object v = DataFunctions . lookup ( object , key ) ; hashCode = v = = null ? null : v . hashCode ( ) ; } if ( hashCode ! = null & & distinctKeys . contains ( hashCode ) ) continue ; distinctKeys . add ( hashCode ) ; b . add ( object ) ; } return b . build ( ) ; } 
public static List < ? > keys ( Iterable < ? > iterable ) { if ( iterable = = null ) return ImmutableList . of ( ) ; ImmutableSet . Builder < String > b = ImmutableSet . < String > builder ( ) ; for ( Object o : iterable ) { if ( o instanceof Map ) { @SuppressWarnings ( " unchecked " ) Map < String , ? > m = ( Map < String , ? > ) o ; b . addAll ( m . keySet ( ) ) ; } else { b . addAll ( ReflectionUtils . getProperties ( o ) ) ; } } return b . build ( ) . asList ( ) ; } 
public void testCull ( ) { assertElements ( ListFunctions . cull ( ImmutableList . of ( ) , ImmutableList . < Boolean > of ( ) ) ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . < Boolean > of ( ) ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . of ( true ) ) , 1 , 2 , 3 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 ) , ImmutableList . of ( false ) ) ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , ImmutableList . of ( false , true ) ) , 2 , 4 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , ImmutableList . of ( true , false ) ) , 1 , 3 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , ImmutableList . of ( true , true , false ) ) , 1 , 2 , 4 ) ; assertElements ( ListFunctions . cull ( ImmutableList . of ( 1 , 2 , 3 , 4 ) , ImmutableList . of ( true , false , true , true , true ) ) , 1 , 3 , 4 ) ; } 
public void testListClass ( ) { assertSame ( Integer . class , listClass ( Lists . newArrayList ( 1 , 2 ) ) ) ; assertSame ( String . class , listClass ( ImmutableList . of ( " a " , " b " ) ) ) ; assertSame ( Number . class , listClass ( Lists . < Number > newArrayList ( 1 , 2.0 ) ) ) ; assertSame ( Object . class , listClass ( ImmutableList . of ( ) ) ) ; assertSame ( Object . class , listClass ( Lists . newArrayList ( 1 , null , 2 ) ) ) ; assertSame ( Object . class , listClass ( Lists . newArrayList ( null , null , 1 ) ) ) ; assertSame ( nodebox . graphics . Path . class , listClass ( Lists . newArrayList ( new nodebox . graphics . Path ( ) , new nodebox . graphics . Path ( ) ) ) ) ; assertSame ( nodebox . graphics . Geometry . class , listClass ( Lists . newArrayList ( new nodebox . graphics . Geometry ( ) , new nodebox . graphics . Geometry ( ) ) ) ) ; assertSame ( nodebox . graphics . AbstractGeometry . class , listClass ( Lists . < IGeometry > newArrayList ( new nodebox . graphics . Path ( ) , new nodebox . graphics . Geometry ( ) ) ) ) ; assertSame ( Object . class , listClass ( Lists . < IGeometry > newArrayList ( new nodebox . graphics . Geometry ( ) , null , new nodebox . graphics . Path ( ) ) ) ) ; } 
public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } 
public void actionPerformed ( ActionEvent e ) { doNext ( ) ; } 
public void actionPerformed ( ActionEvent e ) { portName = nameField . getText ( ) ; String selectedType = ( String ) box . getSelectedItem ( ) ; portType = selectedType . equals ( " custom " ) ? customTypeField . getText ( ) . toLowerCase ( Locale . US ) : selectedType ; dispose ( ) ; } 
public static void enableOSXFullscreen ( Window window ) { Preconditions . checkNotNull ( window ) ; try { Class util = Class . forName ( " com.apple.eawt.FullScreenUtilities " ) ; 
public static Path connect ( List < Point > points , boolean closed ) { if ( points = = null ) return null ; Path p = new Path ( ) ; for ( Point pt : points ) { p . addPoint ( pt ) ; } if ( closed ) p . close ( ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; p . setStrokeWidth ( 1 ) ; return p ; } 
public static Path freehand ( String pathString ) { if ( pathString = = null ) return new Path ( ) ; Path p = parsePath ( pathString ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; p . setStrokeWidth ( 1 ) ; return p ; } 
public static Path line ( Point p1 , Point p2 , long points ) { Path p = new Path ( ) ; p . line ( p1 . x , p1 . y , p2 . x , p2 . y ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; p . setStrokeWidth ( 1 ) ; p = p . resampleByAmount ( ( int ) points , true ) ; return p ; } 
public static Path lineAngle ( Point point , double angle , double distance , long points ) { Point p2 = coordinates ( point , angle , distance ) ; Path p = new Path ( ) ; p . line ( point . x , point . y , p2 . x , p2 . y ) ; p . setFill ( null ) ; p . setStroke ( Color . BLACK ) ; p . setStrokeWidth ( 1 ) ; p = p . resampleByAmount ( ( int ) points , true ) ; return p ; } 
public static void main ( String [ ] args ) { String inputFile = null ; String outputFile = null ; String systemLibraryDir = null ; File inFile = null ; File outFile ; for ( int i = 0 ; i < args . length ; i + + ) { String arg = args [ i ] ; if ( arg . equals ( " -o " ) ) { outputFile = args [ i + 1 ] ; i + = 1 ; } else if ( arg . equals ( " -l " ) ) { systemLibraryDir = args [ i + 1 ] ; i + = 1 ; } else { inputFile = args [ i ] ; } } if ( inputFile = = null ) { printUsage ( ) ; System . exit ( - 1 ) ; } else { inFile = new File ( inputFile ) ; } if ( outputFile = = null ) { outFile = new File ( FileUtils . getBaseName ( inFile . getAbsolutePath ( ) ) + " .png " ) ; } else { outFile = new File ( outputFile ) ; } if ( systemLibraryDir = = null ) { systemLibraryDir = " libraries " ; } NodeRepository systemRepository = getSystemRepository ( systemLibraryDir ) ; NodeLibrary library ; try { library = NodeLibrary . load ( inFile , systemRepository ) ; } catch ( OutdatedLibraryException e ) { UpgradeResult result = NodeLibraryUpgrades . upgrade ( inFile ) ; The file is used here as the base name for finding relative libraries. library = result.getLibrary(inFile, systemRepository); } FunctionRepository functionRepository = FunctionRepository.combine(systemRepository.getFunctionRepository(), library.getFunctionRepository()); library.getRoot(); NodeContext ctx = new NodeContext(library, functionRepository); List<?> result = ctx.renderNode("/"); Rect bounds = library.getBounds(); BufferedImage img = new BufferedImage( (int) Math.ceil(bounds.getWidth()), (int) Math.ceil(bounds.getHeight()), BufferedImage.TYPE_INT_ARGB); Graphics2D g = img.createGraphics(); g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g.translate(-bounds.getX(), -bounds.getY()); GrobVisualizer.INSTANCE.draw(g, result); img.flush(); try { ImageIO.write(img, "png", outFile); 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Viewer viewer = new Viewer ( ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( getCanvasWidth ( ) , getCanvasHeight ( ) ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < String , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " frame " , ( double ) frame ) ; data . put ( " mouse.position " , viewer . getLastMousePosition ( ) ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , data , renderResults , ImmutableMap . < String , Object > of ( ) ) ; List < ? > results = context . renderNode ( " / " ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < ? > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
public void run ( ) { try { Map < String , List < ? > > renderResults = ImmutableMap . of ( ) ; 
public List < ? > renderNode ( String nodePath ) throws NodeRenderException { return renderNode ( nodePath , Collections . < Port , Object > emptyMap ( ) ) ; } 
public List < ? > renderNode ( String nodePath , Map < Port , ? > argumentMap ) { checkNotNull ( getNodeForPath ( nodePath ) ) ; checkNotNull ( functionRepository ) ; If the node has children, forgo the operation of the current node and evaluate the child. Object result; Node node = getNodeForPath(nodePath); if (node.isNetwork()) { if (node.hasRenderedChild()) { result = renderChild(nodePath, node.getRenderedChild(), argumentMap); } else result = ImmutableList.of(); } else { result = invokeNode(nodePath, argumentMap); } List<?> results = postProcessResult(nodePath, result); renderResults.put(nodePath, results); return results; } 
private List < ? > postProcessResult ( String nodePath , Object result ) { Node node = getNodeForPath ( nodePath ) ; if ( node . hasListOutputRange ( ) ) { TODO This is a temporary fix for networks that have no rendered nodes. They execute the "core/zero" function which returns a single value, not a list. if (result instanceof List<?>) { return (List<?>) result; } else { return ImmutableList.of(result); } } else if (result instanceof List) { List<?> results = (List<?>) result; if (results.isEmpty()) return results; Class outputType = ListUtils.listClass(results); if (outputType.equals(Point.class) && node.getOutputType().equals("geometry")) return results; } return result == null ? ImmutableList.of() : ImmutableList.of(result); } 
public List < ? > renderChild ( String networkPath , Node child ) throws NodeRenderException { return renderChild ( networkPath , child , Collections . < Port , Object > emptyMap ( ) ) ; } 
private Object invokeNode ( String nodePath , Map < Port , ? > argumentMap ) { List < Port > inputs = nodeMap . get ( nodePath ) . getInputs ( ) ; Object [ ] arguments = new Object [ inputs . size ( ) ] ; int i = 0 ; for ( Port port : inputs ) { Object argument ; if ( argumentMap . containsKey ( port ) ) { argument = argumentMap . get ( port ) ; } else if ( port . hasValueRange ( ) ) { argument = getPortValue ( nodePath , port ) ; } else { The port expects a list but nothing is connected. Evaluate with an empty list. argument = ImmutableList.of(); } arguments[i] = argument; i++; } return invokeNode(nodePath, arguments); } 
private Object invokeNode ( String nodePath , Object [ ] arguments ) { Node node = getNodeForPath ( nodePath ) ; Function function = functionRepository . getFunction ( node . getFunction ( ) ) ; return invokeFunction ( node , function , arguments ) ; } 
private List < ? > evaluatePort ( String networkPath , Node child , Port childPort , Map < Port , ? > networkArgumentMap ) { Node outputNode = findOutputNode ( nodeMap . get ( networkPath ) , child , childPort ) ; if ( outputNode ! = null ) { List < ? > result = renderChild ( networkPath , outputNode , networkArgumentMap ) ; 
private List < ? > renderNode ( Node node ) { return new NodeContext ( testLibrary . withRoot ( node ) ) . renderNode ( " / " ) ; } 
public void testAdd ( ) { Node addNode = Node . ROOT . withName ( " add " ) . withOutputType ( " int " ) . withFunction ( " clojure-math/add " ) ; Iterable < ? > results = renderNode ( addNode ) ; assertResultsEqual ( results , 0 L ) ; } 
public void testAddWithArguments ( ) { Node addNode = Node . ROOT . withName ( " add " ) . withFunction ( " clojure-math/add " ) . withOutputType ( " int " ) . withInputAdded ( Port . intPort ( " v1 " , 1 ) ) . withInputAdded ( Port . intPort ( " v2 " , 2 ) ) . withInputAdded ( Port . intPort ( " v3 " , 3 ) ) ; Iterable < ? > results = renderNode ( addNode ) ; assertResultsEqual ( results , 6L ) ; } 
private List < ? > renderNode ( Node node ) { Map < String , Object > data = ImmutableMap . < String , Object > of ( " osc.messages " , oscMessages ) ; return new NodeContext ( testLibrary . withRoot ( node ) , null , data ) . renderNode ( " / " ) ; } 
public void testCallReceiveSpecific ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader/8 " ) ; List < Map < String , Object > > expectedResult = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " Column " , 0.9 ) ) ; assertEquals ( expectedResult , renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader/8* " ) ; assertEquals ( expectedResult , renderNode ( oscReceiveNode2 ) ) ; } 
public void testCallReceivePrefix ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader " ) ; List < Map < String , Object > > expectedResult = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " Column " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " Column " , 0.9 ) ) ; assertEquals ( expectedResult , renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader* " ) ; assertEquals ( expectedResult , renderNode ( oscReceiveNode2 ) ) ; } 
public void testCallReceiveWildcard ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multi* " ) ; List < Map < String , Object > > expectedResult = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " Column1 " , 0.5 , " Column2 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " Column1 " , 0.9 , " Column2 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/2/15 " , " Column1 " , 0.1 , " Column2 " , 0.2 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/4/10 " , " Column1 " , 0.3 , " Column2 " , 0.6 ) ) ; assertEquals ( expectedResult , renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /2/*lti* " ) ; assertEquals ( expectedResult , renderNode ( oscReceiveNode2 ) ) ; Node oscReceiveNode3 = oscReceiveNode . withInputValue ( " prefix " , " *multi " ) ; assertEquals ( expectedResult , renderNode ( oscReceiveNode3 ) ) ; Node oscReceiveNode4 = oscReceiveNode . withInputValue ( " prefix " , " multi* " ) ; assertEquals ( ImmutableList . of ( ) , renderNode ( oscReceiveNode4 ) ) ; } 
public void testCallReceiveMessagePattern ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multitoggle/<x>/<y> " ) ; List < Map < String , Object > > expectedResult = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/2/15 " , " x " , " 2 " , " y " , " 15 " , " Column1 " , 0.1 , " Column2 " , 0.2 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/4/10 " , " x " , " 4 " , " y " , " 10 " , " Column1 " , 0.3 , " Column2 " , 0.6 ) ) ; assertEquals ( expectedResult , renderNode ( oscReceiveNode1 ) ) ; } 
public void testCallReceiveMessageTypedPattern ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid>/multifader/<faderid> " ) ; List < Map < String , Object > > expectedResult1 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " pageid " , " 2 " , " faderid " , " 11 " , " Column " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " pageid " , " 2 " , " faderid " , " 8 " , " Column " , 0.9 ) ) ; assertEquals ( expectedResult1 , renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid:string>/multifader/<faderid:s> " ) ; assertEquals ( expectedResult1 , renderNode ( oscReceiveNode2 ) ) ; Node oscReceiveNode3 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid:int>/multifader/<faderid:i> " ) ; List < Map < String , Object > > expectedResult3 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " pageid " , 2 , " faderid " , 11 , " Column " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " pageid " , 2 , " faderid " , 8 , " Column " , 0.9 ) ) ; assertEquals ( expectedResult3 , renderNode ( oscReceiveNode3 ) ) ; Node oscReceiveNode4 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid:f>/multifader/<faderid:float> " ) ; List < Map < String , Object > > expectedResult4 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " pageid " , 2.0 , " faderid " , 11.0 , " Column " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " pageid " , 2.0 , " faderid " , 8.0 , " Column " , 0.9 ) ) ; assertEquals ( expectedResult4 , renderNode ( oscReceiveNode4 ) ) ; Node oscReceiveNode5 = oscReceiveNode . withInputValue ( " prefix " , " /<pageid:l>/multifader/<faderid> " ) ; assertEquals ( ImmutableList . of ( ) , renderNode ( oscReceiveNode5 ) ) ; } 
public void testCallReceiveAndSortData ( ) { Node oscReceiveNode1 = oscReceiveNode . withName ( " osc_receive1 " ) . withInputValue ( " prefix " , " <itemid:i> " ) ; Node net2 = Node . NETWORK . withChildAdded ( oscReceiveNode2 ) . withChildAdded ( sortNode1 ) . withRenderedChildName ( " sort1 " ) . connect ( " osc_receive2 " , " sort1 " , " list " ) ; List < Map < String , Object > > expectedResult2 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /r/g/b/20 " , " itemid " , 0 , " Column1 " , 0.15 , " Column2 " , 0.35 , " Column3 " , 0.77 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/2/15 " , " itemid " , 2 , " Column1 " , 0.1 , " Column2 " , 0.2 , " Column3 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/4/10 " , " itemid " , 4 , " Column1 " , 0.3 , " Column2 " , 0.6 , " Column3 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " itemid " , 8 , " Column1 " , 0.9 , " Column2 " , 0 , " Column3 " , 0 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " itemid " , 11 , " Column1 " , 0.5 , " Column2 " , 0 , " Column3 " , 0 ) ) ; assertEquals ( expectedResult2 , renderNode ( net2 ) ) ; } 
public void testCallReceiveArguments ( ) { Node oscReceiveNode1 = oscReceiveNode . withInputValue ( " prefix " , " /2/multifader* " ) . withInputValue ( " args " , " v " ) ; List < Map < String , Object > > expectedResult1 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multifader/11 " , " v " , 0.5 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multifader/8 " , " v " , 0.9 ) ) ; assertEquals ( expectedResult1 , renderNode ( oscReceiveNode1 ) ) ; Node oscReceiveNode2 = oscReceiveNode . withInputValue ( " prefix " , " /2/multitoggle* " ) . withInputValue ( " args " , " x,y " ) ; List < Map < String , Object > > expectedResult2 = ImmutableList . < Map < String , Object > > of ( ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/2/15 " , " x " , 0.1 , " y " , 0.2 ) , ImmutableMap . < String , Object > of ( " address " , " /2/multitoggle/4/10 " , " x " , 0.3 , " y " , 0.6 ) ) ; assertEquals ( expectedResult2 , renderNode ( oscReceiveNode2 ) ) ; assertEquals ( expectedResult2 , renderNode ( oscReceiveNode2 . withInputValue ( " args " , " x ,y " ) ) ) ; assertEquals ( expectedResult2 , renderNode ( oscReceiveNode2 . withInputValue ( " args " , " x, y " ) ) ) ; } 
public void testCallInvertWithNoArguments ( ) { Node invertNode = Node . ROOT . withFunction ( " math/negate " ) ; renderNode ( invertNode ) ; } 
public void testCallInvert ( ) { Node invertNode = Node . ROOT . withFunction ( " math/negate " ) . withInputAdded ( Port . floatPort ( " value " , 5 ) ) ; assertEquals ( ImmutableList . of ( - 5.0 ) , renderNode ( invertNode ) ) ; } 
public void testPortOrder ( ) { Node subtract1 = Node . ROOT . withFunction ( " math/subtract " ) . withInputAdded ( Port . floatPort ( " a " , 10 ) ) . withInputAdded ( Port . floatPort ( " b " , 3 ) ) ; assertEquals ( ImmutableList . of ( 7.0 ) , renderNode ( subtract1 ) ) ; Node subtract2 = Node . ROOT . withName ( " subtract2 " ) . withFunction ( " math/subtract " ) . withInputAdded ( Port . floatPort ( " b " , 3 ) ) . withInputAdded ( Port . floatPort ( " a " , 10 ) ) ; assertEquals ( ImmutableList . of ( - 7.0 ) , renderNode ( subtract2 ) ) ; } 
public void testAdd ( ) { Node addNode = Node . ROOT . withName ( " add " ) . withFunction ( " py-functions/add " ) ; Iterable < ? > results = renderNode ( addNode ) ; assertResultsEqual ( results , 0 L ) ; } 
public void testAddWithArguments ( ) { Node addNode = Node . ROOT . withName ( " add " ) . withFunction ( " py-functions/add " ) . withInputAdded ( Port . intPort ( " v1 " , 1 ) ) . withInputAdded ( Port . intPort ( " v2 " , 2 ) ) . withInputAdded ( Port . intPort ( " v3 " , 3 ) ) ; Iterable < ? > results = renderNode ( addNode ) ; assertResultsEqual ( results , 6L ) ; } 
public void testMultiplyFloat ( ) { Node multiplyNode = Node . ROOT . withName ( " multiply " ) . withFunction ( " py-functions/multiply " ) . withInputAdded ( Port . floatPort ( " v1 " , 10 ) ) . withInputAdded ( Port . floatPort ( " v2 " , 2 ) ) ; Iterable < ? > results = renderNode ( multiplyNode ) ; assertResultsEqual ( results , 20.0 ) ; } 
public void testMultiplyString ( ) { Node multiplyNode = Node . ROOT . withName ( " multiply " ) . withFunction ( " py-functions/multiply " ) . withInputAdded ( Port . stringPort ( " v1 " , " spam " ) ) . withInputAdded ( Port . intPort ( " v2 " , 3 ) ) ; Iterable < ? > results = renderNode ( multiplyNode ) ; assertResultsEqual ( results , " spamspamspam " ) ; } 
private List < ? > renderChild ( Node network , Node child ) { return new NodeContext ( testLibrary . withRoot ( network ) ) . renderChild ( " / " , child ) ; } 
public void setUp ( ) throws Exception { SideEffects . reset ( ) ; } 
public void testSingleOutput ( ) { List < ? > results = renderNode ( valuesToPointNode ) ; assertEquals ( 1 , results . size ( ) ) ; assertResultsEqual ( results , Point . ZERO ) ; } 
public void testSameOutputPort ( ) { Node invert1 = invertNode . extend ( ) . withName ( " invert1 " ) . withInputValue ( " value " , 1.0 ) ; Node invert2 = invertNode . extend ( ) . withName ( " invert2 " ) . withInputValue ( " value " , 10.0 ) ; assertResultsEqual ( renderNode ( invert1 ) , - 1.0 ) ; assertResultsEqual ( renderNode ( invert2 ) , - 10.0 ) ; } 
public void testListAwareProcessing ( ) { Node makeNumbers1 = makeNumbersNode . extend ( ) . withInputValue ( " string " , " 1 2 3 4 " ) ; assertResultsEqual ( renderNode ( makeNumbers1 ) , 1.0 , 2.0 , 3.0 , 4.0 ) ; } 
public void testListUnawareProcessing ( ) { Node invert1 = invertNode . extend ( ) . withName ( " invert1 " ) . withInputValue ( " value " , 42.0 ) ; assertResultsEqual ( renderNode ( invert1 ) , - 42.0 ) ; } 
public void testConnectedListProcessing ( ) { Node makeNumbers1 = makeNumbersNode . extend ( ) . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 4 " ) ; Node invert1 = invertNode . extend ( ) . withName ( " invert1 " ) ; Node net = Node . NETWORK . withChildAdded ( makeNumbers1 ) . withChildAdded ( invert1 ) . connect ( " makeNumbers1 " , " invert1 " , " value " ) . withRenderedChildName ( " invert1 " ) ; assertResultsEqual ( renderChild ( net , invert1 ) , - 1.0 , - 2.0 , - 3.0 , - 4.0 ) ; } 
public void testInputSideEffect ( ) { Node getNumberNode = Node . ROOT . withFunction ( " side-effects/getNumber " ) ; SideEffects . theInput = 42 ; assertResultsEqual ( renderNode ( getNumberNode ) , 42L ) ; } 
public void testOutputSideEffect ( ) { Node setNumberNode = Node . ROOT . withFunction ( " side-effects/setNumber " ) . withInputAdded ( Port . intPort ( " number " , 42 ) ) ; renderNode ( setNumberNode ) ; assertEquals ( SideEffects . theOutput , 42L ) ; } 
public void testSamePrototypeTwice ( ) { Node invert1Node = invertNode . withName ( " invert1 " ) . withInputValue ( " value " , 42.0 ) ; Node invert2Node = invertNode . withName ( " invert2 " ) ; Node net = Node . NETWORK . withChildAdded ( invert1Node ) . withChildAdded ( invert2Node ) . connect ( " invert1 " , " invert2 " , " value " ) ; assertResultsEqual ( renderChild ( net , invert2Node ) , 42.0 ) ; } 
public void testListWithValue ( ) { Node makeNumbers1 = makeNumbersNode . withName ( " makeNumbers1 " ) . withInputValue ( " string " , " 1 2 3 " ) ; Node add1 = addNode . extend ( ) . withName ( " add1 " ) . withInputValue ( " v2 " , 100.0 ) ; Node net = Node . NETWORK . withChildAdded ( makeNumbers1 ) . withChildAdded ( add1 ) . connect ( " makeNumbers1 " , " add1 " , " v1 " ) ; assertResultsEqual ( renderChild ( net , add1 ) , 101.0 , 102.0 , 103.0 ) ; } 
public void testLongestList ( ) { Node net = Node . NETWORK . withChildAdded ( threeNumbers ) . withChildAdded ( fiveNumbers ) . withChildAdded ( addNode ) . connect ( " threeNumbers " , addNode . getName ( ) , " v1 " ) . connect ( " fiveNumbers " , addNode . getName ( ) , " v2 " ) ; assertResultsEqual ( renderChild ( net , addNode ) , 101.0 , 202.0 , 303.0 , 401.0 , 502.0 ) ; } 
public void testPortRangeMatching ( ) { Node sum = Node . ROOT . withName ( " sum " ) . withFunction ( " math/sum " ) . withInputAdded ( Port . floatPort ( " numbers " , 0 ) ) . withInputRange ( " numbers " , Port . Range . LIST ) ; Node net = Node . NETWORK . withChildAdded ( sum ) . withChildAdded ( threeNumbers ) . connect ( " threeNumbers " , sum . getName ( ) , " numbers " ) ; assertResultsEqual ( renderChild ( net , sum ) , 6.0 ) ; } 
public void testFrame ( ) { Node frame = Node . ROOT . withName ( " frame " ) . withFunction ( " core/frame " ) . withInputAdded ( Port . customPort ( " context " , " context " ) ) ; Node frameNet = Node . NETWORK . withChildAdded ( frame ) . withRenderedChild ( frame ) ; NodeContext c = new NodeContext ( testLibrary . withRoot ( frameNet ) , FunctionRepository . of ( ) , ImmutableMap . of ( " frame " , 42.0 ) ) ; List < ? > results = c . renderNode ( " / " ) ; assertResultsEqual ( results , 42.0 ) ; } 
public void testPortOverrides ( ) { Node number3 = numberNode . withName ( " number3 " ) . withInputValue ( " number " , 3.0 ) ; Node number5 = numberNode . withName ( " number5 " ) . withInputValue ( " number " , 5.0 ) ; Node net = Node . NETWORK . withChildAdded ( number3 ) . withChildAdded ( number5 ) . withChildAdded ( addNode ) . connect ( " number3 " , " add " , " v1 " ) . connect ( " number5 " , " add " , " v2 " ) . withRenderedChildName ( " add " ) ; With no overrides, the add node returns 8.0 assertResultsEqual(net, addNode, 8.0); ImmutableMap<String, ?> overrides = ImmutableMap.of("number3.number", 10.0); NodeContext ctx = new NodeContext(testLibrary.withRoot(net), null, ImmutableMap.<String, Object>of(), ImmutableMap.<String, List<?>>of(), overrides); Iterable<?> values = ctx.renderChild("/", addNode); assertResultsEqual(values, 15.0); } 
public void testPrototypeInSameLibrary ( ) { You can refer to a prototype in the same library as the current node. Node invert = Node.ROOT .withName("negate") .withFunction("math/negate") .withInputAdded(Port.floatPort("number", 0)); Node invert1 = invert.extend().withName("invert1").withInputValue("number", 42.0); Node net = Node.NETWORK .withName("root") .withChildAdded(invert) .withChildAdded(invert1) .withRenderedChild(invert1); NodeLibrary originalLibrary = NodeLibrary.create("test", net, FunctionRepository.of(MathFunctions.LIBRARY)); Assert the original library returns the correct result. NodeContext context = new NodeContext(originalLibrary); assertResultsEqual(context.renderNode("/"), -42.0); Persist / load the library and assert it still returns the correct result. NodeLibrary restoredLibrary = NodeLibrary.load("test", originalLibrary.toXml(), NodeRepository.of()); context = new NodeContext(restoredLibrary); assertResultsEqual(context.renderNode("/"), -42.0); } 
public void testRelativePathsInWidgets ( ) { NodeLibrary library = NodeLibrary . load ( new File ( " src/test/files/relative-file.ndbx " ) , NodeRepository . of ( ) ) ; NodeContext context = new NodeContext ( library ) ; Iterable < ? > results = context . renderNode ( " / " ) ; Object firstResult = results . iterator ( ) . next ( ) ; assertEquals ( true , firstResult ) ; } 
private void assertSingleResult ( Double expected , Node node , FunctionRepository functionRepository ) { NodeLibrary testLibrary = NodeLibrary . create ( " test " , node , functionRepository ) ; NodeContext context = new NodeContext ( testLibrary ) ; List < Object > values = ImmutableList . copyOf ( context . renderNode ( " / " ) ) ; assertEquals ( 1 , values . size ( ) ) ; assertEquals ( expected , values . get ( 0 ) ) ; } 
public static void assertResultsEqual ( Node network , Node child , Object . . . args ) { NodeContext context = new NodeContext ( testLibrary . withRoot ( network ) ) ; Iterable < ? > values = context . renderChild ( " / " , child ) ; assertResultsEqual ( values , args ) ; } 
public static void assertResultsEqual ( Node node , Object . . . args ) { NodeContext context = new NodeContext ( testLibrary . withRoot ( node ) ) ; Iterable < ? > values = context . renderNode ( " / " ) ; assertResultsEqual ( values , args ) ; } 
public void start ( ) { if ( frame ! = null ) { stop ( ) ; } frame = new JFrame ( ) ; applet = new MinimInputApplet ( ) ; applet . init ( ) ; frame . add ( applet ) ; } 
private static void drawCanvasBounds ( Graphics2D g , Canvas canvas ) { Rectangle2D canvasBounds = canvas . getBounds ( ) . getRectangle2D ( ) ; g . setColor ( Color . DARK_GRAY ) ; g . setStroke ( new BasicStroke ( 1f ) ) ; g . draw ( canvasBounds ) ; } 
public void draw ( Graphics2D g , Iterable < ? > objects ) { int x = 0 ; int y = 0 ; for ( Object o : objects ) { Color c = ( Color ) o ; 
private static void drawColor ( Graphics2D g , Color c , int x , int y ) { g . setColor ( java . awt . Color . WHITE ) ; g . fillRoundRect ( x , y , COLOR_SIZE + 6 , COLOR_SIZE + 6 , 3 , 3 ) ; g . setColor ( java . awt . Color . LIGHT_GRAY ) ; g . drawRoundRect ( x , y , COLOR_SIZE + 6 , COLOR_SIZE + 6 , 3 , 3 ) ; g . setColor ( c . getAwtColor ( ) ) ; g . fillRect ( x + 3 , y + 3 , COLOR_SIZE , COLOR_SIZE ) ; } 
public void draw ( Graphics2D g , Iterable < ? > objects ) { if ( objects = = null ) { return ; } g . setColor ( Theme . TEXT_NORMAL_COLOR ) ; g . setFont ( Theme . EDITOR_FONT ) ; AffineTransform = g . getTransform ( ) ; for ( Object o : objects ) { String s = o . toString ( ) ; for ( String line : s . split ( " " ) ) { g . drawString ( line , 5 , 20 ) ; g . translate ( 0 , 14 ) ; } g . drawLine ( - 100 , 10 , 1000 , 10 ) ; g . translate ( 0 , 14 ) ; } g . setTransform ( ) ; } 
public static String subString ( String s , long start , long end , boolean endOffset ) { if ( s = = null ) { return s ; } if ( end < start ) { return " " ; } if ( start < 0 & & end < 0 ) { start = s . length ( ) + start ; end = s . length ( ) + end ; } if ( endOffset ) { end + + ; } return s . substring ( ( int ) Math . max ( 0 , start ) , ( int ) Math . min ( s . length ( ) , end ) ) ; } 
public static String characterAt ( String s , long index ) { if ( s = = null | | s . isEmpty ( ) ) { return s ; } if ( index < 0 ) { index = s . length ( ) + index ; } if ( index > = s . length ( ) | | index < 0 ) { return " " ; } return String . valueOf ( s . charAt ( ( int ) index ) ) ; } 
public boolean hasInput ( String portName ) ; public boolean isConnected ( String portName ) ; public void updateHandle ( ) ; } 
public boolean isConnected ( String portName ) ; public void updateHandle ( ) ; } 
public synchronized static void initializePython ( ) { if ( isInitialized . get ( ) ) return ; Set the Jython package cache directory. Properties jythonProperties = new Properties(); String jythonCacheDir = Platform.getUserDataDirectory() + Platform.SEP + "_jythoncache"; jythonProperties.put("python.cachedir", jythonCacheDir); Initialize Python. PySystemState.initialize(System.getProperties(), jythonProperties, new String[]{""}); Add the built-in Python libraries. File nodeBoxLibraries = new File(libDir, "nodeboxlibs.zip"); Py.getSystemState().path.add(new PyString(nodeBoxLibraries.getAbsolutePath())); This folder contains unarchived NodeBox libraries. Only used in development. File developmentLibraries = new File("src/main/python"); Py.getSystemState().path.add(new PyString(developmentLibraries.getAbsolutePath())); Add the user's Python directory. Py.getSystemState().path.add(new PyString(Platform.getUserPythonDirectory().getAbsolutePath())); isInitialized.set(true); } 
private ExportFormat imageFormatForFile ( File file ) { if ( file . getName ( ) . toLowerCase ( Locale . US ) . endsWith ( " .pdf " ) ) return ExportFormat . PDF ; return ExportFormat . PNG ; } 
public void doExport ( ) { ExportDialog d = new ExportDialog ( this ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return ; ExportFormat chosenFormat = d . getFormat ( ) ; File chosenFile = FileUtils . showSaveDialog ( this , lastExportPath , " png,pdf,svg,csv " , " Image file " ) ; if ( chosenFile = = null ) return ; lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; exportToFile ( chosenFile , chosenFormat ) ; } 
private void exportToFile ( File file , ExportFormat format ) { get data from last export. if (lastRenderResult == null) { JOptionPane.showMessageDialog(this, "There is no last render result."); 
private void exportToFile ( File file , Iterable < ? > objects , ExportFormat format ) { file = format . ensureFileExtension ( file ) ; ObjectsRenderer . render ( objects , getCanvasBounds ( ) . getBounds2D ( ) , file ) ; } 
public boolean exportRange ( ) { File exportDirectory = lastExportPath = = null ? null : new File ( lastExportPath ) ; if ( exportDirectory ! = null & & ! exportDirectory . exists ( ) ) exportDirectory = null ; ExportRangeDialog d = new ExportRangeDialog ( this , exportDirectory ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return false ; String exportPrefix = d . getExportPrefix ( ) ; File directory = d . getExportDirectory ( ) ; int fromValue = d . getFromValue ( ) ; int toValue = d . getToValue ( ) ; ExportFormat format = d . getFormat ( ) ; if ( directory = = null ) return false ; lastExportPath = directory . getAbsolutePath ( ) ; exportRange ( exportPrefix , directory , fromValue , toValue , format ) ; return true ; } 
static Set < String > keySet ( Object o ) { if ( o instanceof Geometry ) { return ImmutableSet . of ( " x " , " y " , " width " , " height " ) ; 
static Map < String , ? > objectAsMap ( Object o ) { if ( o instanceof Geometry ) { Geometry geo = ( Geometry ) o ; 
private static String valueInQuotes ( String s ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( '"' ) ; int l = s . length ( ) ; for ( int i = 0 ; i < l ; i + + ) { char c = s . charAt ( i ) ; if ( c = = '"' ) { sb . append ( '"' ) ; } sb . append ( c ) ; } sb . append ( '"' ) ; return sb . toString ( ) ; } 
public static String renderToString ( Iterable < ? > objects , char delimiter ) { checkArgument ( objects ! = null ) ; HashSet < String > keySet = new HashSet < > ( ) ; for ( Object o : objects ) { keySet . addAll ( keySet ( o ) ) ; } StringBuilder sb = new StringBuilder ( ) ; Write header boolean first = true; for (String k : keySet) { if (first) { first = false; } else { sb.append(delimiter); } sb.append(valueInQuotes(k)); } sb.append(''); Write table for (Object o : objects) { Map<String, ?> m = objectAsMap(o); first = true; for (String k : keySet) { if (first) { first = false; } else { sb.append(delimiter); } String v = m.get(k).toString(); sb.append(valueInQuotes(v)); } sb.append(''); } return sb.toString(); } 
public static void renderToFile ( Iterable < ? > objects , File file , char delimiter ) { checkArgument ( objects ! = null ) ; FileUtils . writeFile ( file , renderToString ( objects , delimiter ) ) ; } 
public static ExportFormat of ( String name ) { return FORMAT_MAP . get ( name . toUpperCase ( Locale . US ) ) ; } 
public void testPath ( ) { Path p = new Path ( ) ; p . cornerRect ( 10 , 20 , 30 , 40 ) ; Set < String > keys = CSVRenderer . keySet ( p ) ; assertEquals ( ImmutableSet . of ( " d " , " fill " , " stroke " , " stroke-width " , " x " , " y " , " width " , " height " ) , keys ) ; Map < String , ? > m = CSVRenderer . objectAsMap ( p ) ; assertEquals ( m . get ( " x " ) , 10.0 ) ; assertEquals ( m . get ( " y " ) , 20.0 ) ; assertEquals ( m . get ( " width " ) , 30.0 ) ; assertEquals ( m . get ( " height " ) , 40.0 ) ; } 
public void testNumber ( ) { Double d = 42.0 ; assertEquals ( ImmutableSet . of ( " value " ) , CSVRenderer . keySet ( d ) ) ; assertEquals ( ImmutableMap . of ( " value " , 42.0 ) , CSVRenderer . objectAsMap ( d ) ) ; } 
public void testNull ( ) { assertEquals ( ImmutableSet . of ( " value " ) , CSVRenderer . keySet ( null ) ) ; assertEquals ( ImmutableMap . of ( " value " , " null " ) , CSVRenderer . objectAsMap ( null ) ) ; } 
public void testMap ( ) { Map < String , Integer > data = ImmutableMap . of ( " alpha " , 1 , " beta " , 2 , " gamma " , 3 ) ; assertEquals ( ImmutableSet . of ( " alpha " , " beta " , " gamma " ) , CSVRenderer . keySet ( data ) ) ; assertEquals ( data , CSVRenderer . objectAsMap ( data ) ) ; List < Map < String , Integer > > objects = ImmutableList . of ( data ) ; String s = CSVRenderer . renderToString ( objects , ';' ) ; assertEquals ( " \" alpha \" ; \" beta \" ; \" gamma \" \" 1 \" ; \" 2 \" ; \" 3 \" " , s ) ; } 
public void testEscaping ( ) { List < String > objects = ImmutableList . of ( " How \" are \" you? " ) ; assertEquals ( ImmutableSet . of ( " value " ) , CSVRenderer . keySet ( objects . get ( 0 ) ) ) ; String s = CSVRenderer . renderToString ( objects , ';' ) ; assertEquals ( " \" value \" \" How \" \" are \" \" you? \" " , s ) ; } 
public void testEnsureFileFormat ( ) { assertEquals ( " test.pdf " , ExportFormat . PDF . ensureFileExtension ( " test " ) ) ; assertEquals ( " test.pdf " , ExportFormat . PDF . ensureFileExtension ( " test.pdf " ) ) ; assertEquals ( " test..pdf " , ExportFormat . PDF . ensureFileExtension ( " test. " ) ) ; assertEquals ( " test.png.pdf " , ExportFormat . PDF . ensureFileExtension ( " test.png " ) ) ; assertEquals ( " test.something.pdf " , ExportFormat . PDF . ensureFileExtension ( " test.something " ) ) ; assertEquals ( " a.b.c.pdf " , ExportFormat . PDF . ensureFileExtension ( " a.b.c " ) ) ; assertEquals ( " /a/b/c.pdf " , ExportFormat . PDF . ensureFileExtension ( " /a/b/c " ) ) ; assertEquals ( " /a/b/c.png.pdf " , ExportFormat . PDF . ensureFileExtension ( " /a/b/c.png " ) ) ; assertEquals ( new File ( " /a/b.test/c.pdf " ) . getAbsolutePath ( ) , ExportFormat . PDF . ensureFileExtension ( new File ( " /a/b.test/c " ) ) . getAbsolutePath ( ) ) ; } 
public void doExport ( ) { ExportDialog d = new ExportDialog ( this ) ; d . setLocationRelativeTo ( this ) ; d . setVisible ( true ) ; if ( ! d . isDialogSuccessful ( ) ) return ; ExportFormat chosenFormat = d . getFormat ( ) ; Map < String , ? > options = d . getExportOptions ( ) ; File chosenFile = FileUtils . showSaveDialog ( this , lastExportPath , " png,pdf,svg,csv " , " Image file " ) ; if ( chosenFile = = null ) return ; lastExportPath = chosenFile . getParentFile ( ) . getAbsolutePath ( ) ; exportToFile ( chosenFile , chosenFormat , options ) ; } 
private void exportToFile ( File file , ExportFormat format , Map < String , ? > options ) { get data from last export. if (lastRenderResult == null) { JOptionPane.showMessageDialog(this, "There is no last render result."); 
private void exportToFile ( File file , Iterable < ? > objects , ExportFormat format , Map < String , ? > options ) { file = format . ensureFileExtension ( file ) ; ObjectsRenderer . render ( objects , getCanvasBounds ( ) . getBounds2D ( ) , file , options ) ; } 
public void frameDone ( double frame , Iterable < ? > results ) { File exportFile = new File ( directory , exportPrefix + " - " + String . format ( " %05d " , count ) ) ; exportToFile ( exportFile , results , format , ImmutableMap . < String , Object > of ( ) ) ; count + = 1 ; } 
public static String concatenate ( String s1 , String s2 , String s3 , String s4 , String s5 , String s6 , String s7 ) { StringBuilder sb = new StringBuilder ( ) ; if ( s1 ! = null ) { sb . append ( s1 ) ; } if ( s2 ! = null ) { sb . append ( s2 ) ; } if ( s3 ! = null ) { sb . append ( s3 ) ; } if ( s4 ! = null ) { sb . append ( s4 ) ; } if ( s5 ! = null ) { sb . append ( s5 ) ; } if ( s6 ! = null ) { sb . append ( s6 ) ; } if ( s7 ! = null ) { sb . append ( s7 ) ; } return sb . toString ( ) ; } 
public void testConcatenate ( ) { assertEquals ( " a " , StringFunctions . concatenate ( " a " , null , null , null , null , null , null ) ) ; assertEquals ( " ab " , StringFunctions . concatenate ( " a " , " b " , null , null , null , null , null ) ) ; assertEquals ( " ad " , StringFunctions . concatenate ( " a " , null , null , " d " , null , null , null ) ) ; assertEquals ( " cd " , StringFunctions . concatenate ( null , null , " c " , " d " , null , null , null ) ) ; assertEquals ( " " , StringFunctions . concatenate ( null , null , null , null , null , null , null ) ) ; } 
public static String renderToString ( Iterable < ? > objects , char delimiter ) { checkArgument ( objects ! = null ) ; Set < String > keySet = new LinkedHashSet < > ( ) ; for ( Object o : objects ) { keySet . addAll ( keySet ( o ) ) ; } StringBuilder sb = new StringBuilder ( ) ; Write header boolean first = true; for (String k : keySet) { if (first) { first = false; } else { sb.append(delimiter); } sb.append(valueInQuotes(k)); } sb.append(''); Write table for (Object o : objects) { Map<String, ?> m = objectAsMap(o); first = true; for (String k : keySet) { if (first) { first = false; } else { sb.append(delimiter); } String v = m.get(k).toString(); sb.append(valueInQuotes(v)); } sb.append(''); } return sb.toString(); } 
public static String renderToString ( Iterable < ? > objects , char delimiter , boolean quotes ) { checkArgument ( objects ! = null ) ; Set < String > keySet = new LinkedHashSet < > ( ) ; for ( Object o : objects ) { keySet . addAll ( keySet ( o ) ) ; } StringBuilder sb = new StringBuilder ( ) ; Write header boolean first = true; for (String k : keySet) { if (first) { first = false; } else { sb.append(delimiter); } sb.append(quotes ? valueInQuotes(k) : k); } sb.append(''); Write table for (Object o : objects) { Map<String, ?> m = objectAsMap(o); first = true; for (String k : keySet) { if (first) { first = false; } else { sb.append(delimiter); } String v = m.get(k).toString(); sb.append(quotes ? valueInQuotes(v) : v); } sb.append(''); } return sb.toString(); } 
public static void renderToFile ( Iterable < ? > objects , File file , char delimiter , boolean quotes ) { checkArgument ( objects ! = null ) ; FileUtils . writeFile ( file , renderToString ( objects , delimiter , quotes ) ) ; } 
public void testMap ( ) { Map < String , Integer > data = ImmutableMap . of ( " alpha " , 1 , " beta " , 2 , " gamma " , 3 ) ; assertEquals ( ImmutableSet . of ( " alpha " , " beta " , " gamma " ) , CSVRenderer . keySet ( data ) ) ; assertEquals ( data , CSVRenderer . objectAsMap ( data ) ) ; List < Map < String , Integer > > objects = ImmutableList . of ( data ) ; String s = CSVRenderer . renderToString ( objects , ';' , true ) ; assertEquals ( " \" alpha \" ; \" beta \" ; \" gamma \" \" 1 \" ; \" 2 \" ; \" 3 \" " , s ) ; } 
public void testEscaping ( ) { List < String > objects = ImmutableList . of ( " How \" are \" you? " ) ; assertEquals ( ImmutableSet . of ( " value " ) , CSVRenderer . keySet ( objects . get ( 0 ) ) ) ; String s1 = CSVRenderer . renderToString ( objects , ';' , true ) ; assertEquals ( " \" value \" \" How \" \" are \" \" you? \" " , s1 ) ; String s2 = CSVRenderer . renderToString ( objects , ';' , false ) ; assertEquals ( " value nHow \" are \" you? " , s2 ) ; } 
public static List < Object > filterData ( List < Object > rows , String key , String op , Object value ) { if ( value = = null ) return rows ; ImmutableList . Builder < Object > b = ImmutableList . builder ( ) ; try { double floatValue = Double . parseDouble ( value . toString ( ) ) ; for ( Object o : rows ) { if ( doubleMatches ( o , key , op , floatValue ) ) { b . add ( o ) ; } } } catch ( NumberFormatException e ) { for ( Object o : rows ) { if ( objectMatches ( o , key , op , value ) ) { b . add ( o ) ; } } } return b . build ( ) ; } 
public static List < Map < String , Object > > makeTable ( String headers , List < ? > l1 , List < ? > l2 , List < ? > l3 , List < ? > l4 , List < ? > l5 , List < ? > l6 ) { List < String > dirtyHeaderList = Arrays . asList ( headers . split ( " [,;] " ) ) ; ArrayList < String > headerList = new ArrayList < > ( 6 ) ; int dirtyHeaderListSize = dirtyHeaderList . size ( ) ; for ( int i = 0 ; i < 6 ; i + + ) { String key = i < dirtyHeaderListSize ? dirtyHeaderList . get ( i ) : null ; if ( key = = null ) { key = " list " + ( i + 1 ) ; } else { key = key . trim ( ) ; if ( key . length ( ) = = 0 ) { key = " list " + ( i + 1 ) ; } } headerList . add ( key ) ; } ArrayList < List < ? > > lists = new ArrayList < > ( 6 ) ; lists . add ( l1 ) ; lists . add ( l2 ) ; lists . add ( l3 ) ; lists . add ( l4 ) ; lists . add ( l5 ) ; lists . add ( l6 ) ; int colCount = nonEmptyListSize ( lists ) ; int rowCount = maxListSize ( lists ) ; ImmutableList . Builder < Map < String , Object > > result = new ImmutableList . Builder < > ( ) ; for ( int rowIndex = 0 ; rowIndex < rowCount ; rowIndex + + ) { ImmutableMap . Builder < String , Object > row = ImmutableMap . builder ( ) ; for ( int colIndex = 0 ; colIndex < colCount ; colIndex + + ) { String key = headerList . get ( colIndex ) ; List < ? > l = lists . get ( colIndex ) ; if ( l ! = null & & ! l . isEmpty ( ) ) { row . put ( key , rowIndex < l . size ( ) ? l . get ( rowIndex ) : " " ) ; } } result . add ( row . build ( ) ) ; } return result . build ( ) ; } 
private static int nonEmptyListSize ( List < List < ? > > lists ) { int index = - 1 ; for ( int i = 0 ; i < lists . size ( ) ; i + + ) { if ( lists . get ( i ) ! = null & & ! lists . get ( i ) . isEmpty ( ) ) { index = i ; } } return index + 1 ; } 
private static int maxListSize ( List < List < ? > > lists ) { int maxSize = 0 ; for ( List < ? > l : lists ) { if ( l ! = null ) { maxSize = Math . max ( maxSize , l . size ( ) ) ; } } return maxSize ; } 
public void testImportCSVWithDuplicateHeaders ( ) { List < Map < String , Object > > l = importSimpleCSV ( " src/test/files/duplicate-headers.csv " ) ; assertEquals ( 2 , l . size ( ) ) ; Map < String , Object > row1 = l . get ( 0 ) ; assertResultsEqual ( row1 . keySet ( ) , " Strings " , " Numbers 1 " , " Integers " , " Numbers 2 " , " Floats " ) ; assertResultsEqual ( row1 . values ( ) , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 ) ; } 
public void testMakeTable ( ) { List < String > alphaList = ImmutableList . of ( " a0 " , " a1 " ) ; List < String > betaList = ImmutableList . of ( " b0 " , " b1 " ) ; List < Map < String , Object > > l = makeTable ( " alpha,beta " , alphaList , betaList , null , null , null , null ) ; assertEquals ( 2 , l . size ( ) ) ; assertEquals ( l . get ( 0 ) . keySet ( ) , ImmutableSet . of ( " alpha " , " beta " ) ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , " a0 " , " b0 " ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , " a1 " , " b1 " ) ; } 
public void testMakeTableWithNoData ( ) { List < Map < String , Object > > l = makeTable ( " alpha,beta " , null , null , null , null , null , null ) ; assertEquals ( 0 , l . size ( ) ) ; } 
public void testMakeTableAutoHeaders ( ) { List < String > alphaList = ImmutableList . of ( " a0 " , " a1 " ) ; List < String > betaList = ImmutableList . of ( " b0 " , " b1 " ) ; List < Map < String , Object > > l = makeTable ( " alpha " , alphaList , betaList , null , null , null , null ) ; assertEquals ( 2 , l . size ( ) ) ; assertEquals ( l . get ( 0 ) . keySet ( ) , ImmutableSet . of ( " alpha " , " list2 " ) ) ; } 
public void testMakeTableHeadersWithSpaces ( ) { List < String > alphaList = ImmutableList . of ( " a0 " , " a1 " ) ; List < String > betaList = ImmutableList . of ( " b0 " , " b1 " ) ; List < Map < String , Object > > l = makeTable ( " alpha; beta " , alphaList , betaList , null , null , null , null ) ; assertEquals ( l . get ( 0 ) . keySet ( ) , ImmutableSet . of ( " alpha " , " beta " ) ) ; } 
public void testMakeTableDifferentSizedLists ( ) { List < String > alphaList = ImmutableList . of ( " a0 " , " a1 " ) ; List < String > betaList = ImmutableList . of ( " b0 " ) ; List < Map < String , Object > > l = makeTable ( " alpha " , alphaList , betaList , null , null , null , null ) ; assertEquals ( 2 , l . size ( ) ) ; assertEquals ( l . get ( 0 ) . keySet ( ) , ImmutableSet . of ( " alpha " , " list2 " ) ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , " a0 " , " b0 " ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , " a1 " , " " ) ; } 
public void testMakeTableWithNoDataForColumn ( ) { List < String > alphaList = ImmutableList . of ( " a0 " , " a1 " ) ; List < String > gammaList = ImmutableList . of ( " c0 " , " c1 " ) ; List < Map < String , Object > > l = makeTable ( " alpha,beta,gamma " , alphaList , ImmutableList . of ( ) , gammaList , null , null , null ) ; assertEquals ( 2 , l . size ( ) ) ; assertEquals ( l . get ( 0 ) . keySet ( ) , ImmutableSet . of ( " alpha " , " gamma " ) ) ; assertResultsEqual ( l . get ( 0 ) . values ( ) , " a0 " , " c0 " ) ; assertResultsEqual ( l . get ( 1 ) . values ( ) , " a1 " , " c1 " ) ; } 
private static Rectangle inputPortRect ( Node node , Port port , boolean isConnecting ) { if ( isHiddenPort ( port ) ) return new Rectangle ( ) ; Point pt = nodePoint ( node ) ; int portWidth = ! isConnecting ? PORT_WIDTH : PORT_WIDTH + PORT_MARGIN ; int portHeight = ! isConnecting ? PORT_HEIGHT : PORT_HEIGHT + NODE_HEIGHT ; Rectangle portRect = new Rectangle ( pt . x + portOffset ( node , port ) , pt . y - PORT_HEIGHT , portWidth , portHeight ) ; growHitRectangle ( portRect ) ; return portRect ; } 
public void mouseMoved ( MouseEvent e ) { Point2D pt = inverseViewTransformPoint ( e . getPoint ( ) ) ; overOutput = getNodeWithOutputPortAt ( pt ) ; overInput = getInputPortAt ( pt , false ) ; overComment = getNodeWithCommentAt ( pt ) ; It is probably very inefficient to repaint the view every time the mouse moves. repaint(); } 
private void showPopup ( MouseEvent e ) { Point pt = e . getPoint ( ) ; NodePort nodePort = getInputPortAt ( inverseViewTransformPoint ( pt ) , false ) ; if ( nodePort ! = null ) { JPopupMenu pMenu = new JPopupMenu ( ) ; 
public static List < String > importText ( String fileName ) { if ( fileName = = null | | fileName . trim ( ) . isEmpty ( ) ) return ImmutableList . of ( ) ; try { ImmutableList . Builder < String > lines = ImmutableList . builder ( ) ; 
private static Rectangle outputPortRect ( Node node ) { Point pt = nodePoint ( node ) ; Rectangle portRect = new Rectangle ( pt . x , pt . y + NODE_HEIGHT - 10 , PORT_WIDTH + 10 , PORT_HEIGHT + 10 ) ; growHitRectangle ( portRect ) ; return portRect ; } 
public void connect ( String outputNode , String inputNode , String inputPort ) { if ( outputNode . equals ( inputNode ) ) return ; addEdit ( " Connect " ) ; controller . connect ( activeNetworkPath , outputNode , inputNode , inputPort ) ; portView . updateAll ( ) ; viewerPane . updateHandle ( ) ; requestRender ( ) ; } 
public void save ( StringWriter sw ) { PrintWriter out = new PrintWriter ( sw , true ) ; ArrayList < String > commandList = new ArrayList < String > ( ) ; commandList . add ( FFMPEG_BINARY . getAbsolutePath ( ) ) ; commandList . add ( " -hide_banner " ) ; Hide the FFMPEG compilation banner commandList.add("-y"); Overwrite target if exists commandList.add("-i"); commandList.add(temporaryFileTemplate); Input images commandList.addAll(videoFormat.getArgumentList(this)); Video format specific arguments commandList.add(movieFilename); Target file name ProcessBuilder pb = new ProcessBuilder(commandList); if (verbose) { for (String cmd : pb.command()) { System.out.print(cmd + " "); } System.out.println(); } pb.redirectErrorStream(true); Process p; try { p = pb.start(); p.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = in.readLine()) != null) out.println(line); p.waitFor(); if (verbose) { System.out.println(sw.toString()); } } catch (IOException | InterruptedException e) { cleanupAndThrowException(e); } cleanup(); } 
public static void main ( String [ ] args ) { int width = 640 ; int height = 480 ; Create a new movie. Movie movie = new Movie("test.mp4", MP4VideoFormat.LosslessFormat, width, height); movie.setVerbose(true); / Initialize an image to draw on. BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); Graphics2D g = (Graphics2D) img.getGraphics(); g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); for (int frame = 0; frame < 20; frame++) { System.out.println("frame = " + frame); Clear the canvas and draw some simple circles. g.setColor(Color.WHITE); g.fillRect(0, 0, width, height); Random r = new Random(0); for (int j = 0; j < 100; j++) { g.setColor(new Color(r.nextInt(255), 255, r.nextInt(255))); g.fillOval(r.nextInt(width) + frame, r.nextInt(height) + frame, 30, 30); } Add the image to the movie. movie.addFrame(img); } Export the movie. movie.save(); } 
public String toString ( ) { return " NotarizationStatus{ " + " status=' " + status + '\'' + 
private static String runShellCommand ( List < String > command ) throws IOException , InterruptedException { Process process = new ProcessBuilder ( ) . command ( command ) . start ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; process . waitFor ( ) ; StringBuilder builder = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) ! = null ) { builder . append ( line ) ; builder . append ( '' ) ; } return builder . toString ( ) ; } 
public static void main ( String [ ] args ) { File dmgFile = new File ( args [ 0 ] ) ; if ( ! dmgFile . exists ( ) ) { System . out . println ( " File " + args [ 0 ] + " does not exist. " ) ; return ; } String requestUUID = startNotarization ( dmgFile ) ; boolean success = waitForNotarization ( requestUUID ) ; if ( success ) { stapleNotarization ( dmgFile ) ; 
private static String startNotarization ( File dmgFile ) { ArrayList<String> command = new ArrayList<>(); command.add("cat"); command.add("_notarize_output.txt"); ArrayList<String> command = new ArrayList<>(); command.add("xcrun"); command.add("altool"); command.add("--notarize-app"); command.add("--primary-bundle-id"); command.add("be.emrg.nodebox"); command.add("--username"); command.add("frederik@debleser.be"); command.add("--password"); command.add("@keychain:Developer-altool"); command.add("--file"); command.add(dmgFile.getAbsolutePath()); try { String result = runShellCommand(command); 
private static boolean waitForNotarization ( String requestUUID ) { NotarizationStatus status ; do { status = getNotarizationStatus ( requestUUID ) ; System . out . println ( status ) ; if ( ! status . status . equals ( " in progress " ) ) { break ; } try { Thread . sleep ( 30 * SECONDS ) ; } catch ( InterruptedException ignored ) { } } while ( true ) ; if ( status . status . equals ( " success " ) ) { return true ; 
private static void stapleNotarization ( File dmgFile ) { ArrayList < String > command = new ArrayList < > ( ) ; command.add("cat"); command.add("_notarize_staple.txt"); command.add("xcrun"); command.add("stapler"); command.add("staple"); command.add(dmgFile.getAbsolutePath()); try { String result = runShellCommand(command); 
public static void main ( String [ ] args ) { File projectDir = new File ( " . " ) ; scanRecursive ( new File ( " dist/mac " ) , projectDir ) ; signFile ( new File ( " dist/mac/NodeBox.app " ) , projectDir ) ; } 
public static void scanRecursive ( File dir , File projectDir ) { for ( File f : Objects . requireNonNull ( dir . listFiles ( ) ) ) { if ( f . isDirectory ( ) ) { 
private static void signFile ( File f , File projectDir ) { ArrayList < String > command = new ArrayList < > ( ) ; command . add ( " codesign " ) ; command . add ( " --sign " ) ; command . add ( " Developer ID Application: Frederik De Bleser (5X78EYG9RH) " ) ; command . add ( " --timestamp " ) ; command . add ( " --deep " ) ; command . add ( " -vvvv " ) ; command . add ( " -f " ) ; command . add ( " --entitlements " ) ; command . add ( new File ( projectDir , " platform/mac/NodeBox.entitlements " ) . getAbsolutePath ( ) ) ; command . add ( " --options " ) ; command . add ( " runtime " ) ; command . add ( f . getAbsolutePath ( ) ) ; System . out . println ( " command = " + command ) ; try { new ProcessBuilder ( ) . directory ( f . getParentFile ( ) ) . inheritIO ( ) . command ( command ) . start ( ) . waitFor ( ) ; 
private void registerForMacOSXEvents ( ) throws RuntimeException { if ( ! Platform . onMac ( ) ) return ; try { tOSXEventsHandler handler = new OSXEventsHandler ( ) ; tDesktop . getDesktop ( ) . setQuitHandler ( handler ) ; tDesktop . getDesktop ( ) . setAboutHandler ( handler ) ; tDesktop . getDesktop ( ) . setPreferencesHandler ( handler ) ; Desktop.getDesktop().setOpenFileHandler(handler); Unsure how to deal properly with this one, opening files works without setting a handler? } catch (Exception e) { throw new RuntimeException("Error while setting the OS X events.", e); } On the Mac, if all windows are closed the menu bar will be empty. To solve this, we create an off-screen window with the same menu bar as visible windows. hiddenFrame = new JFrame(); hiddenFrame.setJMenuBar(new NodeBoxMenuBar()); hiddenFrame.setUndecorated(true); hiddenFrame.setSize(0, 0); hiddenFrame.setLocation(-100, -100); hiddenFrame.pack(); hiddenFrame.setVisible(true); } 
public void handleAbout ( java . awt . desktop . AboutEvent e ) { tshowAbout ( ) ; } 
 public void handlePreferences ( java . awt . desktop . PreferencesEvent e ) { tshowPreferences ( ) ; } 
public void handleQuitRequestWith ( java . awt . desktop . QuitEvent e , java . awt . desktop . QuitResponse response ) { java . util . List < NodeBoxDocument > documents = new ArrayList < NodeBoxDocument > ( getDocuments ( ) ) ; for ( NodeBoxDocument d : documents ) { if ( ! d . close ( ) ) { response . cancelQuit ( ) ; treturn ; } } tresponse . performQuit ( ) ; } 
private void registerForMacOSXEvents ( ) throws RuntimeException { if ( ! Platform . onMac ( ) ) return ; try { OSXEventsHandler handler = new OSXEventsHandler ( ) ; Desktop . getDesktop ( ) . setQuitHandler ( handler ) ; Desktop . getDesktop ( ) . setAboutHandler ( handler ) ; Desktop . getDesktop ( ) . setPreferencesHandler ( handler ) ; Desktop . getDesktop ( ) . setOpenFileHandler ( handler ) ; Unsure how to deal properly with this one, opening files works without setting a handler? } catch (Exception e) { throw new RuntimeException("Error while setting the OS X events.", e); } On the Mac, if all windows are closed the menu bar will be empty. To solve this, we create an off-screen window with the same menu bar as visible windows. hiddenFrame = new JFrame(); hiddenFrame.setJMenuBar(new NodeBoxMenuBar()); hiddenFrame.setUndecorated(true); hiddenFrame.setSize(0, 0); hiddenFrame.setLocation(-100, -100); hiddenFrame.pack(); hiddenFrame.setVisible(true); } 
public void handleAbout ( java . awt . desktop . AboutEvent e ) { showAbout ( ) ; } 
public void handlePreferences ( java . awt . desktop . PreferencesEvent e ) { showPreferences ( ) ; } 
public void handleQuitRequestWith ( java . awt . desktop . QuitEvent e , java . awt . desktop . QuitResponse response ) { java . util . List < NodeBoxDocument > documents = new ArrayList < NodeBoxDocument > ( getDocuments ( ) ) ; for ( NodeBoxDocument d : documents ) { if ( ! d . close ( ) ) { response . cancelQuit ( ) ; return ; } } response . performQuit ( ) ; } 
public void readFromFile ( File file ) { This method is called in the Desktop handler. If the application is still starting up, don't open the document immediately but place it in a file loading queue. if (startingUp.get()) { filesToLoad.add(file); 
public static void info ( String message ) { LOGGER . log ( Level . INFO , message ) ; } 
public static void warn ( String message ) { LOGGER . log ( Level . WARNING , message ) ; } 
public static void warn ( String message , Throwable ) { LOGGER . log ( Level . WARNING , message , ) ; } 
public static void error ( String message ) { LOGGER . log ( Level . SEVERE , message ) ; } 
public static void error ( String message , Throwable ) { LOGGER . log ( Level . SEVERE , message , ) ; } 
public static void main ( String [ ] args ) { Log . info ( " Starting NodeBox " ) ; final Application app = new Application ( ) ; Ignore OS X's weird launch parameter. if (args.length == 1 && !args[0].startsWith("-psn")) { app.filesToLoad.add(new File(args[0])); } SwingUtilities.invokeLater(new Runnable() { public void run() { 
public void mouseDragged ( MouseEvent e ) { isDragging = true ; JComponent c = ColorWell . this ; Point pt = e . getPoint ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getWindowAncestor ( c ) ; pt = SwingUtilities . convertPoint ( c , pt , frame . getContentPane ( ) ) ; MouseEvent newEvent = new MouseEvent ( colorPicker , e . getID ( ) , e . getWhen ( ) , e . getModifiersEx ( ) , ( int ) pt . getX ( ) , ( int ) pt . getY ( ) , e . getClickCount ( ) , e . isPopupTrigger ( ) , e . getButton ( ) ) ; colorPicker . dispatchEvent ( newEvent ) ; } 
private boolean saveToFile ( File file ) { try { getNodeLibrary ( ) . store ( file ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , " An error occurred while saving the file. " , " NodeBox " , JOptionPane . ERROR_MESSAGE ) ; Log . error ( " An error occurred while saving the file. " , e ) ; return false ; } documentChanged = false ; updateTitle ( ) ; return true ; } 
private void exportThreadedRange ( final NodeLibrary library , final int fromValue , final int toValue , final ExportDelegate exportDelegate ) { int frameCount = toValue - fromValue ; final InterruptibleProgressDialog d = new InterruptibleProgressDialog ( this , " Exporting " + frameCount + " frames... " ) ; d . setTaskCount ( toValue - fromValue + 1 ) ; d . setVisible ( true ) ; exportDelegate . progressDialog = d ; final NodeLibrary exportLibrary = getNodeLibrary ( ) ; final FunctionRepository exportFunctionRepository = getFunctionRepository ( ) ; final Viewer viewer = new Viewer ( ) ; final JFrame frame = new JFrame ( ) ; frame . setLayout ( new BorderLayout ( ) ) ; frame . setSize ( getCanvasWidth ( ) , getCanvasHeight ( ) ) ; frame . setTitle ( " Exporting... " ) ; frame . add ( viewer , BorderLayout . CENTER ) ; frame . setLocationRelativeTo ( null ) ; Thread = new Thread ( new Runnable ( ) { public void run ( ) { try { Map < String , List < ? > > renderResults = ImmutableMap . of ( ) ; for ( int frame = fromValue ; frame < = toValue ; frame + + ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) break ; HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " frame " , ( double ) frame ) ; data . put ( " mouse.position " , viewer . getLastMousePosition ( ) ) ; NodeContext context = new NodeContext ( exportLibrary , exportFunctionRepository , data , renderResults , ImmutableMap . < String , Object > of ( ) ) ; List < ? > results = context . renderNode ( " / " ) ; renderResults = context . getRenderResults ( ) ; viewer . setOutputValues ( ( List < ? > ) results ) ; exportDelegate . frameDone ( frame , results ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . tick ( ) ; } } ) ; } exportDelegate . exportDone ( ) ; } catch ( Exception e ) { Log . warn ( " Error while exporting " , e ) ; } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { d . setVisible ( false ) ; frame . setVisible ( false ) ; } } ) ; } } } ) ; d . setThread ( ) ; . start ( ) ; frame . setVisible ( true ) ; } 
public void save ( StringWriter sw ) { Log . info ( String . format ( " Exporting movie %s with inputs %s (ffmpeg %s) " , movieFilename , temporaryFileTemplate , FFMPEG_BINARY . getAbsolutePath ( ) ) ) ; PrintWriter out = new PrintWriter ( sw , true ) ; ArrayList < String > commandList = new ArrayList < String > ( ) ; commandList . add ( FFMPEG_BINARY . getAbsolutePath ( ) ) ; commandList . add ( " -hide_banner " ) ; Hide the FFMPEG compilation banner commandList.add("-y"); Overwrite target if exists commandList.add("-i"); commandList.add(temporaryFileTemplate); Input images commandList.addAll(videoFormat.getArgumentList(this)); Video format specific arguments commandList.add(movieFilename); Target file name ProcessBuilder pb = new ProcessBuilder(commandList); if (verbose) { for (String cmd : pb.command()) { System.out.print(cmd + " "); } System.out.println(); } pb.redirectErrorStream(true); Process p; try { p = pb.start(); p.getOutputStream().close(); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = in.readLine()) != null) out.println(line); p.waitFor(); if (verbose) { System.out.println(sw.toString()); } } catch (IOException | InterruptedException e) { cleanupAndThrowException(e); } cleanup(); } 
private void cleanupAndThrowException ( Throwable ) { cleanup ( ) ; Log . error ( " Error while exporting movie " , ) ; throw new RuntimeException ( ) ; } 
public boolean ensureUserDataDir ( ) { return getUserDataDir ( ) . mkdirs ( ) ; } 
public static boolean ensureUserDataDir ( ) { return platform . getUserDataDir ( ) . mkdirs ( ) ; } 
public static boolean ensureUserLogDir ( ) { return platform . getUserLogDir ( ) . mkdirs ( ) ; } 
public void checkerEncounteredError ( UpdateChecker checker , Throwable ) { hideUpdateCheckDialog ( ) ; Delegate method. if (delegate != null) if (delegate.checkerEncounteredError(checker, t)) return; if (checker.isSilent()) { Log.warn("Update checker encountered error.", t); 
private static String readFile ( File file ) { try { return Files . asCharSource ( file , Charsets . UTF_8 ) . read ( ) ; 
private static Map < String , Object > _httpGet ( final String url , final String username , final String password ) { HttpGet request = new HttpGet ( url ) ; if ( username ! = null & & ! username . trim ( ) . isEmpty ( ) ) { UsernamePasswordCredentials credentials = new UsernamePasswordCredentials ( username , password ) ; BasicScheme scheme = new BasicScheme ( ) ; Header authorizationHeader ; try { authorizationHeader = scheme . authenticate ( credentials , request , new BasicHttpContext ( ) ) ; } catch ( AuthenticationException e ) { throw new RuntimeException ( e ) ; } request . addHeader ( authorizationHeader ) ; } try { CloseableHttpClient client = HttpClients . createDefault ( ) ; 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " https:nodebox.net/ " ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " https:nodebox.net/node/documentation/tutorial/getting-started.html " ) ; } 
public void actionPerformed ( ActionEvent e ) { Platform . openURL ( " https:nodebox.net/node/documentation/ " ) ; } 
public static UpgradeResult upgradeTo ( File file , String targetVersion ) throws LoadException { String currentXml = readFile ( file ) ; String currentVersion = parseFormatVersion ( currentXml ) ; ArrayList < String > warnings = new ArrayList < String > ( ) ; Avoid upgrades getting stuck in an infinite loop. int tries = 0; if (currentVersion.equals("0.9")) { throw new LoadException(file, "This is a NodeBox 2 file and is no longer supported."); } while (!currentVersion.equals(targetVersion) && tries < 100) { Method upgradeMethod = upgradeMap.get(currentVersion); if (upgradeMethod == null) { throw new LoadException(file, "Unsupported version " + currentVersion + ": this file is too new. Try downloading a new version of NodeBox from https:nodebox.net/download/"); } try { UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, currentXml); warnings.addAll(result.warnings); currentXml = result.xml; } catch (Exception e) { throw new LoadException(file, "Upgrading to " + currentVersion + " failed.", e); } currentVersion = parseFormatVersion(currentXml); tries++; } if (tries >= 100) { throw new LoadException(file, "Got stuck in an infinite loop when trying to upgrade from " + currentVersion); } return new UpgradeResult(file, currentXml, warnings); } 
