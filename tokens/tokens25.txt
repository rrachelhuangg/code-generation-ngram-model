public static String toMultiPath ( List < String > paths ) { return StringUtils . join ( paths . iterator ( ) , File . pathSeparator ) ; } 
public static String toMultiPath ( String [ ] paths ) { return StringUtils . join ( paths , File . pathSeparator ) ; } 
public static String [ ] findFiles ( File dir , String pattern ) { DirectoryScanner scanner = new DirectoryScanner ( ) ; scanner . setBasedir ( dir ) ; scanner . setIncludes ( new String [ ] { pattern } ) ; scanner . addDefaultExcludes ( ) ; scanner . scan ( ) ; return scanner . getIncludedFiles ( ) ; } 
public static String toClasspathString ( ClassLoader cl ) throws Exception { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } StringBuilder back = new StringBuilder ( ) ; while ( cl ! = null ) { if ( cl instanceof URLClassLoader ) { URLClassLoader ucl = ( URLClassLoader ) cl ; URL [ ] urls = ucl . getURLs ( ) ; for ( URL url : urls ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( url . getFile ( ) ) ; } } cl = cl . getParent ( ) ; } return back . toString ( ) ; } 
public void addEnvVar ( String key , String value ) { env_ . add ( key + " = " + value ) ; } 
public void addJvmArgs ( String . . . args ) { if ( args = = null ) { return ; } for ( String arg : args ) { jvmArgs_ . add ( arg ) ; 
public void addArgs ( String . . . args ) { if ( args = = null ) { return ; } for ( String arg : args ) { args_ . add ( arg ) ; 
public void addOption ( String key , String value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } args_ . add ( key ) ; args_ . add ( value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } args_ . add ( key ) ; args_ . add ( value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | ( key = = null ) ) { return ; } args_ . add ( key ) ; } 
private String [ ] buildCommand ( ) { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs_ . size ( ) + args_ . size ( ) ) ; back . add ( javaExec_ ) ; back . addAll ( jvmArgs_ ) ; back . add ( mainClassName_ ) ; back . addAll ( args_ ) ; return back . toArray ( new String [ back . size ( ) ] ) ; } 
public void run ( boolean displayCmd ) throws Exception { run ( displayCmd , true ) ; } 
protected List < String > getClasspathElements ( ) throws Exception { return project . getCompileClasspathElements ( ) ; } 
protected File getOutputDir ( ) throws Exception { return outputDir . getAbsoluteFile ( ) ; } 
protected File getSourceDir ( ) throws Exception { return sourceDir . getAbsoluteFile ( ) ; } 
abstract protected File getOutputDir ( ) throws Exception ; abstract protected File getSourceDir ( ) throws Exception ; abstract protected List < String > getClasspathElements ( ) throws Exception ; @Override protected void doExecute ( ) throws Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } File sourceDir = normalize ( getSourceDir ( ) ) ; if ( ! sourceDir . exists ( ) ) { return ; } int nbFiles = compile ( sourceDir , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : getLog ( ) . warn ( " No source files found. " ) ; break ; case 0 : getLog ( ) . info ( " Nothing to compile - all classes are up to date " ) ; ; break ; default : break ; } } protected File normalize ( File f ) { try { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { String [ ] sourceFiles = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; if ( sourceFiles . length = = 0 ) { return - 1 ; } int sourceDirPathLength = sourceDir . getAbsolutePath ( ) . length ( ) ; filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = lastCompileAtFile.lastModified(); ArrayList<File> files = new ArrayList<File>(sourceFiles.length); for (String x : sourceFiles) { File f = new File(sourceDir, x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getAbsolutePath().substring(sourceDirPathLength+1))); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); }} 
abstract protected File getSourceDir ( ) throws Exception ; abstract protected List < String > getClasspathElements ( ) throws Exception ; @Override protected void doExecute ( ) throws Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } File sourceDir = normalize ( getSourceDir ( ) ) ; if ( ! sourceDir . exists ( ) ) { return ; } int nbFiles = compile ( sourceDir , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : getLog ( ) . warn ( " No source files found. " ) ; break ; case 0 : getLog ( ) . info ( " Nothing to compile - all classes are up to date " ) ; ; break ; default : break ; } } protected File normalize ( File f ) { try { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { String [ ] sourceFiles = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; if ( sourceFiles . length = = 0 ) { return - 1 ; } int sourceDirPathLength = sourceDir . getAbsolutePath ( ) . length ( ) ; filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = lastCompileAtFile.lastModified(); ArrayList<File> files = new ArrayList<File>(sourceFiles.length); for (String x : sourceFiles) { File f = new File(sourceDir, x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getAbsolutePath().substring(sourceDirPathLength+1))); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); }} 
abstract protected List < String > getClasspathElements ( ) throws Exception ; @Override protected void doExecute ( ) throws Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } File sourceDir = normalize ( getSourceDir ( ) ) ; if ( ! sourceDir . exists ( ) ) { return ; } int nbFiles = compile ( sourceDir , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : getLog ( ) . warn ( " No source files found. " ) ; break ; case 0 : getLog ( ) . info ( " Nothing to compile - all classes are up to date " ) ; ; break ; default : break ; } } protected File normalize ( File f ) { try { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { String [ ] sourceFiles = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; if ( sourceFiles . length = = 0 ) { return - 1 ; } int sourceDirPathLength = sourceDir . getAbsolutePath ( ) . length ( ) ; filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = lastCompileAtFile.lastModified(); ArrayList<File> files = new ArrayList<File>(sourceFiles.length); for (String x : sourceFiles) { File f = new File(sourceDir, x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getAbsolutePath().substring(sourceDirPathLength+1))); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); }} 
protected void doExecute ( ) throws Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } File sourceDir = normalize ( getSourceDir ( ) ) ; if ( ! sourceDir . exists ( ) ) { return ; } int nbFiles = compile ( sourceDir , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : 
protected File normalize ( File f ) { try { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { String [ ] sourceFiles = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; if ( sourceFiles . length = = 0 ) { return - 1 ; } int sourceDirPathLength = sourceDir . getAbsolutePath ( ) . length ( ) ; filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = lastCompileAtFile.lastModified(); ArrayList<File> files = new ArrayList<File>(sourceFiles.length); for (String x : sourceFiles) { File f = new File(sourceDir, x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getAbsolutePath().substring(sourceDirPathLength+1))); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaCommand jcmd = new JavaCommand ( this , mainConsole , classpathStr , jvmArgs , args ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
protected List < String > getClasspathElements ( ) throws Exception { throw new UnsupportedOperationException ( " USELESS " ) ; } 
protected File getOutputDir ( ) throws Exception { throw new UnsupportedOperationException ( " USELESS " ) ; } 
protected File getSourceDir ( ) throws Exception { throw new UnsupportedOperationException ( " USELESS " ) ; } 
protected JavaCommand getScalaCommand ( ) throws Exception { JavaCommand jcmd = super . getScalaCommand ( ) ; if ( useFsc ) { jcmd . addOption ( " verbose " , verbose ) ; } return jcmd ; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = normalize ( mainOutputDir ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = normalize ( mainSourceDir ) ; testOutputDir = normalize ( testOutputDir ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } testSourceDir = normalize ( testSourceDir ) ; if ( useFsc ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { int nbFile = 0 ; 
private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaCommand jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; } 
public void run ( ) { try { getLog ( ) . info ( " stop server(s)... " ) ; 
private String [ ] findSourceFiles ( ) { if ( sourceFiles_ = = null ) { sourceFiles_ = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; } return sourceFiles_ ; } 
public boolean canGenerateReport ( ) { try { sourceDir = sourceDir . getCanonicalFile ( ) ; } catch ( IOException exc ) { sourceDir = sourceDir . getAbsoluteFile ( ) ; } return sourceDir . exists ( ) & & ( findSourceFiles ( ) . length ! = 0 ) ; } 
public void doExecute ( ) throws Exception { SiteRendererSink sink = siteRenderer.createSink(new File(project.getReporting().getOutputDirectory(), getOutputName() + ".html"); generate(null, Locale.getDefault()); } 
protected JavaCommand getScalaCommand ( ) throws Exception { String oldClazz = scalaClassName ; if ( isScala271 ) { scalaClassName = " scala.tools.nsc.ScalaDoc " ; } if ( StringUtils . isNotEmpty ( scaladocClassName ) ) { scalaClassName = scaladocClassName ; } JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; scalaClassName = oldClazz ; return cmd ; } 
public void generate ( Sink sink , Locale locale ) throws MavenReportException { try { if ( ! canGenerateReport ( ) ) { 
public void doExecute ( ) throws Exception { JavaCommand jcmd = null ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -help " ) ; jcmd . addArgs ( " -X " ) ; jcmd . addArgs ( " -Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -version " ) ; jcmd . run ( displayCmd ) ; } 
protected Set < Artifact > resolveDependencyArtifacts ( MavenProject theProject ) throws Exception { AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( new ArtifactFilter ( ) { public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } } ) ; Set < Artifact > artifacts = theProject . createArtifacts ( factory , Artifact . SCOPE_RUNTIME , filter ) ; for ( Artifact artifact : artifacts ) { resolver . resolve ( artifact , remoteRepos , localRepo ) ; } return artifacts ; } 
public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } 
protected Set < Artifact > resolveArtifactDependencies ( Artifact artifact ) throws Exception { Artifact pomArtifact = factory . createArtifact ( artifact . getGroupId ( ) , artifact . getArtifactId ( ) , artifact . getVersion ( ) , " " , " pom " ) ; MavenProject pomProject = mavenProjectBuilder . buildFromRepository ( pomArtifact , remoteRepos , localRepo ) ; return resolveDependencyArtifacts ( pomProject ) ; } 
protected void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) throws Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , " jar " ) , classpath ) ; } 
protected void addToClasspath ( Artifact artifact , Set < String > classpath ) throws Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( artifact . getFile ( ) . getCanonicalPath ( ) ) ; for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { classpath . add ( dep . getFile ( ) . getCanonicalPath ( ) ) ; 
public void execute ( ) throws MojoExecutionException , MojoFailureException { try { doExecute ( ) ; 
protected abstract void doExecute ( ) throws Exception ; protected JavaCommand getScalaCommand ( ) throws Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) throws Exception { JavaCommand cmd = new JavaCommand ( this , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-decoder " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-dbc " , scalaVersion , classpath ) ; if ( scalaJars ! = null ) { for ( BasicArtifact artifact : scalaJars ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } private String getBootClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; return JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } } 
protected JavaCommand getScalaCommand ( ) throws Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected JavaCommand getEmptyScalaCommand ( String mainClass ) throws Exception { JavaCommand cmd = new JavaCommand ( this , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-decoder " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-dbc " , scalaVersion , classpath ) ; if ( scalaJars ! = null ) { for ( BasicArtifact artifact : scalaJars ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
private String getBootClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; return JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
protected void doExecute ( ) throws Exception { JavaCommand jcmd = new JavaCommand ( this , mainClass , JavaCommand . toMultiPath ( project . getRuntimeClasspathElements ( ) ) , jvmArgs , args ) ; jcmd . run ( displayCmd ) ; } 
public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( skip ) { return ; } super . execute ( ) ; } 
protected List < String > getClasspathElements ( ) throws Exception { return project . getTestClasspathElements ( ) ; } 
protected File getOutputDir ( ) throws Exception { return testOutputDir . getAbsoluteFile ( ) ; } 
protected File getSourceDir ( ) throws Exception { return testSourceDir . getAbsoluteFile ( ) ; } 
public void run ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( in_ ) ) ; 
public void run ( ) { try { byte [ ] buffer = new byte [ 512 ] ; 
public String toString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( '-' ) . append ( modifier ) ; } return str . toString ( ) ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( major < o . major ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( minor > o . minor ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( minor < o . minor ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( bugfix > o . bugfix ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( bugfix < o . bugfix ) ) { back = - 1 ; } return back ; } 
protected void doExecute ( ) throws Exception { tJavaCommand jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { tjcmd = new JavaCommand ( this , mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args ) ; } else if ( StringUtils . isNotEmpty ( launcher ) & & ( launchers ! = null ) ) { tfor ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { tjcmd = new JavaCommand ( this , launchers [ i ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args ) ; } } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) throws Exception { tJavaCommand jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { tjcmd = new JavaCommand ( this , mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { tfor ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { tgetLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; tjcmd = new JavaCommand ( this , launchers [ i ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args ) ; } } } else { tgetLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; tjcmd = new JavaCommand ( this , launchers [ 0 ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
public void execute ( ) throws MojoExecutionException , MojoFailureException { try { tcheckScalaVersion ( ) ; 
protected abstract void doExecute ( ) throws Exception ; protected JavaCommand getScalaCommand ( ) throws Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) throws Exception { JavaCommand cmd = new JavaCommand ( this , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( SCALA_GROUPID , " scala-decoder " , scalaVersion , classpath ) ; addToClasspath ( SCALA_GROUPID , " scala-dbc " , scalaVersion , classpath ) ; if ( scalaJars ! = null ) { for ( BasicArtifact artifact : scalaJars ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } private String getBootClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , classpath ) ; return JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } } 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( SCALA_GROUPID , " scala-decoder " , scalaVersion , classpath ) ; addToClasspath ( SCALA_GROUPID , " scala-dbc " , scalaVersion , classpath ) ; if ( scalaJars ! = null ) { for ( BasicArtifact artifact : scalaJars ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
private String getBootClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , classpath ) ; return JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
public void execute ( ) throws MojoExecutionException { ttry { if ( sourceDir ! = null ) { 
protected abstract void doExecute ( ) throws Exception ; protected JavaCommand getScalaCommand ( ) throws Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) throws Exception { JavaCommand cmd = new JavaCommand ( this , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (scalaJars != null) { for(BasicArtifact artifact: scalaJars) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); } private String getBootClasspath() throws Exception { Set<String> classpath = new HashSet<String>(); addToClasspath(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, scalaVersion, classpath); return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); }} 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (scalaJars != null) { for(BasicArtifact artifact: scalaJars) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
public void testCompare ( ) throws Exception { assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; } 
protected JavaCommand getScalaCommand ( ) throws Exception { String oldClazz = scalaClassName ; boolean isPreviousScala271 = ( new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( scalaVersion ) ) > 0 ) ; if ( ! isPreviousScala271 ) { scalaClassName = " scala.tools.nsc.ScalaDoc " ; } if ( StringUtils . isNotEmpty ( scaladocClassName ) ) { scalaClassName = scaladocClassName ; } JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; if ( isPreviousScala271 ) { cmd . addArgs ( " -Ydoc " ) ; } scalaClassName = oldClazz ; return cmd ; } 
public void execute ( ) throws MojoExecutionException , MojoFailureException { try { checkScalaVersion ( ) ; 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { tthrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { tthrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } tcurrentScriptIndex + + ; compileScript(scriptDir, destFile, classpath); 
private boolean hasMavenProjectDependency ( Set < String > classpath ) tthrows MalformedURLException { ttry { tList < URL > urls = new ArrayList < URL > ( ) ; 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader ) tthrows Exception { tClass < ? > compiledScript = loader . loadClass ( scriptBaseName ( ) ) ; ttry { ttry { 
private URLClassLoader createScriptClassloader ( File scriptDir , tSet < String > classpath ) throws MalformedURLException { tList < URL > urls = new ArrayList < URL > ( ) ; } 
private void compileScript ( File scriptDir , File destFile , tSet < String > classpath ) throws Exception { tJavaCommand jcmd = getScalaCommand ( ) ; tjcmd . addArgs ( " -classpath " , JavaCommand . toMultiPath ( new ArrayList < String > ( classpath ) ) ) ; tjcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; tjcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; tjcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; tjcmd . run ( displayCmd ) ; } 
private void configureClasspath ( Set < String > classpath ) throws Exception , tDependencyResolutionRequiredException { tMavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; tCollection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { tgetLog ( ) . warn ( " No scopes were included " ) ; } else { tString [ ] include = includeScopes . split ( " , " ) ; tfor ( String string : include ) { tScopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { ttoInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { tgetLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { tString [ ] exclude = excludeScopes . split ( " , " ) ; tfor ( String string : exclude ) { tScopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { ttoInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { tgetLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } tfor ( Dependency dependency : toInclude ) { taddToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath ) ; } if ( addToClasspath ! = null ) { tclasspath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { tArrayList < String > toRemove = new ArrayList < String > ( ) ; tString [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; tfor ( String string : classpath ) { tfor ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { ttoRemove . add ( string ) ; } } } tclasspath . removeAll ( toRemove ) ; } tString outputDirectory = project . getBuild ( ) . getOutputDirectory ( ) ; if ( ! outputDirectory . endsWith ( " / " ) ) { getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) tthrows IOException { tdestFile . delete ( ) ; tFileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; tPrintStream out = new PrintStream ( fileOutputStream ) ; ttry { tBufferedReader reader ; 
private String scriptBaseName ( ) { if ( scriptFile = = null ) { treturn " embeddedScript_ " + currentScriptIndex ; 
private void delete ( File scriptDir ) { if ( scriptDir . isDirectory ( ) ) { tfor ( File file : scriptDir . listFiles ( ) ) { tdelete ( file ) ; } } tscriptDir . deleteOnExit ( ) ; tscriptDir . delete ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) tthrows DependencyResolutionRequiredException { treturn project . getCompileDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) tthrows DependencyResolutionRequiredException { treturn project . getRuntimeDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) tthrows DependencyResolutionRequiredException { treturn project . getTestDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) tthrows DependencyResolutionRequiredException { treturn project . getSystemDependencies ( ) ; } 
public abstract Collection < Dependency > elements ( tMavenProjectAdapter project ) tthrows DependencyResolutionRequiredException ; public static Scopes lookup ( String name ) { tfor ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . trim ( ) . equalsIgnoreCase ( name . trim ( ) ) ) { treturn scope ; } } treturn null ; } } } 
public static Scopes lookup ( String name ) { tfor ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . trim ( ) . equalsIgnoreCase ( name . trim ( ) ) ) { treturn scope ; } } treturn null ; } 
public List < String > getCompileClasspathElements ( ) tthrows DependencyResolutionRequiredException { treturn wrapped . getCompileClasspathElements ( ) ; } 
public List < String > getRuntimeClasspathElements ( ) tthrows DependencyResolutionRequiredException { treturn wrapped . getRuntimeClasspathElements ( ) ; } 
public List < String > getSystemClasspathElements ( ) tthrows DependencyResolutionRequiredException { treturn wrapped . getSystemClasspathElements ( ) ; } 
public List < String > getTestClasspathElements ( ) tthrows DependencyResolutionRequiredException { treturn wrapped . getTestClasspathElements ( ) ; } 
public String apply ( String key , String defaultValue ) { tString result = apply ( key ) ; if ( result = = null ) { treturn defaultValue ; 
public void update ( String key , String value ) { if ( key . equals ( " build.directory " ) | | key . equals ( " project.build.directory " ) 
public void update ( String key , int value ) { tupdate ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , boolean value ) { tupdate ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , double value ) { tupdate ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , long value ) { tupdate ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , char value ) { tupdate ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , float value ) { tupdate ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , byte value ) { tupdate ( key , String . valueOf ( value ) ) ; } 
public void addAttachedArtifact ( Artifact artifact ) { twrapped . addAttachedArtifact ( artifact ) ; } 
public void addCompileSourceRoot ( String path ) { twrapped . addCompileSourceRoot ( path ) ; } 
public void addContributor ( Contributor contributor ) { twrapped . addContributor ( contributor ) ; } 
public void addDeveloper ( Developer developer ) { twrapped . addDeveloper ( developer ) ; } 
public void addLicense ( License license ) { twrapped . addLicense ( license ) ; } 
public void addMailingList ( MailingList mailingList ) { twrapped . addMailingList ( mailingList ) ; } 
public void addProjectReference ( MavenProject project ) { twrapped . addProjectReference ( project ) ; } 
public void addResource ( Resource resource ) { twrapped . addResource ( resource ) ; } 
public void addScriptSourceRoot ( String path ) { twrapped . addScriptSourceRoot ( path ) ; } 
public void addTestCompileSourceRoot ( String path ) { twrapped . addTestCompileSourceRoot ( path ) ; } 
public void addTestResource ( Resource testResource ) { twrapped . addTestResource ( testResource ) ; } 
public Set < Artifact > createArtifacts ( ArtifactFactory artifactFactory , tString inheritedScope , ArtifactFilter dependencyFilter ) tthrows InvalidDependencyVersionException { treturn wrapped . createArtifacts ( artifactFactory , inheritedScope , tdependencyFilter ) ; 
public Xpp3Dom getGoalConfiguration ( String arg0 , String arg1 , String arg2 , tString arg3 ) { treturn wrapped . getGoalConfiguration ( arg0 , arg1 , arg2 , arg3 ) ; } 
public String getModulePathAdjustment ( MavenProject arg0 ) throws IOException { treturn wrapped . getModulePathAdjustment ( arg0 ) ; } 
public void injectPluginManagementInfo ( Plugin arg0 ) { twrapped . injectPluginManagementInfo ( arg0 ) ; } 
public boolean isExecutionRoot ( ) { treturn wrapped . isExecutionRoot ( ) ; } 
public Artifact replaceWithActiveArtifact ( Artifact arg0 ) { treturn wrapped . replaceWithActiveArtifact ( arg0 ) ; } 
public void setDistributionManagement ( tDistributionManagement distributionManagement ) { twrapped . setDistributionManagement ( distributionManagement ) ; } 
public void setReleaseArtifactRepository ( ArtifactRepository releaseArtifactRepository ) { twrapped . setReleaseArtifactRepository ( releaseArtifactRepository ) ; } 
public void setSnapshotArtifactRepository ( ArtifactRepository snapshotArtifactRepository ) { twrapped . setSnapshotArtifactRepository ( snapshotArtifactRepository ) ; } 
public void writeModel ( Writer writer ) throws IOException { twrapped . writeModel ( writer ) ; } 
public void writeOriginalModel ( Writer writer ) throws IOException { twrapped . writeOriginalModel ( writer ) ; } 
protected abstract void doExecute ( ) throws Exception ; protected JavaCommand getScalaCommand ( ) throws Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) throws Exception { JavaCommand cmd = new JavaCommand ( this , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); } private String getBootClasspath() throws Exception { Set<String> classpath = new HashSet<String>(); addToClasspath(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, scalaVersion, classpath); return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); }} 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
protected void doExecute ( ) throws Exception { JavaCommand jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaCommand ( this , mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaCommand ( this , launchers [ i ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaCommand ( this , launchers [ 0 ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
public static void main ( String [ ] args ) { tJavaClass test = new JavaClass ( ) ; ttest . abstractJavaMethod ( ) ; } 
protected List < String > getSourceDirectories ( ) throws Exception { tList < String > sources = project . getCompileSourceRoots ( ) ; tString scalaSourceDir = sourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { tsources . add ( scalaSourceDir ) ; } treturn sources ; } 
abstract protected File getOutputDir ( ) throws Exception ; abstract protected List < String > getClasspathElements ( ) throws Exception ; private static List<String> removeEmptyCompileSourceRoots( List<String> compileSourceRootsList ) { List<String> newCompileSourceRootsList = new ArrayList<String>(); if ( compileSourceRootsList != null ) { copy as I may be modifying it for ( String srcDir : compileSourceRootsList ) { if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() ) { newCompileSourceRootsList.add( srcDir ); } } } return newCompileSourceRootsList; }} 
abstract protected List < String > getClasspathElements ( ) throws Exception ; private static List<String> removeEmptyCompileSourceRoots( List<String> compileSourceRootsList ) { List<String> newCompileSourceRootsList = new ArrayList<String>(); if ( compileSourceRootsList != null ) { copy as I may be modifying it for ( String srcDir : compileSourceRootsList ) { if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() ) { newCompileSourceRootsList.add( srcDir ); } } } return newCompileSourceRootsList; }} 
abstract protected List < String > getSourceDirectories ( ) throws Exception ; @Override protected void doExecute ( ) throws Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } int nbFiles = compile ( getSourceDirectories ( ) , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : getLog ( ) . warn ( " No source files found. " ) ; break ; case 0 : getLog ( ) . info ( " Nothing to compile - all classes are up to date " ) ; ; break ; default : break ; } } protected File normalize ( File f ) { try { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { tgetLog ( ) . warn ( " Using older form of compile " ) ; treturn compile ( Arrays . asList ( sourceDir . getAbsolutePath ( ) ) , outputDir , classpathElements , compileInLoop ) ; } protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } private static List<String> removeEmptyCompileSourceRoots( List<String> compileSourceRootsList ) { List<String> newCompileSourceRootsList = new ArrayList<String>(); if ( compileSourceRootsList != null ) { copy as I may be modifying it for ( String srcDir : compileSourceRootsList ) { if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() ) { newCompileSourceRootsList.add( srcDir ); } } } return newCompileSourceRootsList; }} 
protected void doExecute ( ) throws Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } int nbFiles = compile ( getSourceDirectories ( ) , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { tgetLog ( ) . warn ( " Using older form of compile " ) ; treturn compile ( Arrays . asList ( sourceDir . getAbsolutePath ( ) ) , outputDir , classpathElements , compileInLoop ) ; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSource ( List < String > sourceRootDirs , String extension ) { List < String > sourceFiles = new ArrayList < String > ( ) ; return sourceFiles; } 
private static List < String > removeEmptyCompileSourceRoots ( List < String > compileSourceRootsList ) { List < String > newCompileSourceRootsList = new ArrayList < String > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for ( String srcDir : compileSourceRootsList ) { if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() ) { newCompileSourceRootsList.add( srcDir ); } } } return newCompileSourceRootsList; } 
protected List < String > getSourceDirectories ( ) throws Exception { throw new UnsupportedOperationException ( " USELESS " ) ; } 
protected List < String > getSourceDirectories ( ) throws Exception { tList < String > sources = project . getTestCompileSourceRoots ( ) ; tString scalaSourceDir = testSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { tsources . add ( scalaSourceDir ) ; } treturn sources ; } 
private List < String > findSource ( List < String > sourceRootDirs , String extension ) { List < String > sourceFiles = new ArrayList < String > ( ) ; return sourceFiles; } 
protected List < String > getSourceDirectories ( ) throws Exception { tList < String > sources = project . getCompileSourceRoots ( ) ; return sources; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected abstract void doExecute ( ) throws Exception ; protected JavaCommand getScalaCommand ( ) throws Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) throws Exception { JavaCommand cmd = new JavaCommand ( this , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; }} 
protected boolean isJavaSupportedByCompiler ( ) { treturn new VersionNumber ( scalaVersion ) . compareTo ( new VersionNumber ( " 2.7.2 " ) ) > = 0 ; } 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { return compile(Arrays.asList(sourceDir.getAbsolutePath()), outputDir, classpathElements, compileInLoop); } 
public void testJdkSplit ( ) throws Exception { assertEquals ( 6 , " hello " . split ( " | " ) . length ) ; assertEquals ( 1 , " hello " . split ( " \\ | " ) . length ) ; assertEquals ( 2 , " hel|lo " . split ( " \\ | " ) . length ) ; assertEquals ( 3 , " hel||lo " . split ( " \\ | " ) . length ) ; } 
public void testStringUtilsSplit ( ) throws Exception { assertEquals ( 1 , StringUtils . split ( " hello " , " | " ) . length ) ; assertEquals ( 1 , StringUtils . split ( " hello| " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel|lo " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel||lo " , " | " ) . length ) ; } 
protected JavaCommand getScalaCommand ( ) throws Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { tSet < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { tSet < String > ignoreClasspath = new HashSet < String > ( ) ; taddToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , tignoreClasspath ) ; taddToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , tscalaVersion , ignoreClasspath ) ; tfor ( BasicArtifact artifact : compilerPlugins ) { } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = new JavaCommand ( this , mainConsole , classpathStr , jvmArgs , args ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { JavaMainCaller jcmd = super . getScalaCommand ( ) ; if ( useFsc ) { jcmd . addOption ( " verbose " , verbose ) ; } return jcmd ; } 
private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { String oldClazz = scalaClassName ; boolean isPreviousScala271 = ( new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( scalaVersion ) ) > 0 ) ; if ( ! isPreviousScala271 ) { scalaClassName = " scala.tools.nsc.ScalaDoc " ; } if ( StringUtils . isNotEmpty ( scaladocClassName ) ) { scalaClassName = scaladocClassName ; } JavaMainCaller cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; if ( isPreviousScala271 ) { cmd . addArgs ( " -Ydoc " ) ; } scalaClassName = oldClazz ; return cmd ; } 
public void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -help " ) ; jcmd . addArgs ( " -X " ) ; jcmd . addArgs ( " -Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -version " ) ; jcmd . run ( displayCmd ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { JavaMainCaller cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
protected void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaCommand ( this , mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaCommand ( this , launchers [ i ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaCommand ( this , launchers [ 0 ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
private void compileScript ( File scriptDir , File destFile , tSet < String > classpath ) throws Exception { tJavaMainCaller jcmd = getScalaCommand ( ) ; tjcmd . addArgs ( " -classpath " , JavaCommand . toMultiPath ( new ArrayList < String > ( classpath ) ) ) ; tjcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; tjcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; tjcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; tjcmd . run ( displayCmd ) ; } 
public void addOption ( String key , String value ) { if ( ( value = = null ) | | ( key = = null ) ) { treturn ; } taddArgs ( key , value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | ( key = = null ) ) { treturn ; } taddArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | ( key = = null ) ) { return ; } taddArgs ( key ) ; } 
public void addArgs ( String . . . args ) { if ( args ! = null ) { tthis . args . addAll ( Arrays . asList ( args ) ) ; 
public void addEnvVar ( String key , String value ) { tthis . env . add ( key + " = " + value ) ; 
public void run ( boolean displayCmd ) throws Exception { trun ( displayCmd , true ) ; } 
public abstract void addEnvVar ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void setLogOnly ( boolean v ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void run ( boolean displayCmd ) throws Exception ; public abstract void spawn ( boolean displayCmd ) throws Exception ; } 
public abstract void run ( boolean displayCmd , boolean throwFailure ) tthrows Exception ; public abstract void spawn ( boolean displayCmd ) throws Exception ; } 
public void run ( boolean displayCmd , boolean throwFailure ) throws Exception { ttry { trunInternal ( displayCmd ) ; 
public void spawn ( final boolean displayCmd ) throws Exception { tThread = new Thread ( ) { @Override public void run ( ) { ttry { trunInternal ( displayCmd ) ; } catch ( Exception e ) { } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { String oldClazz = scalaClassName ; This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(new VersionNumber(scalaVersion)) > 0); if (!isPreviousScala271) { scalaClassName = "scala.tools.nsc.ScalaDoc"; } if (StringUtils.isNotEmpty(scaladocClassName)) { scalaClassName = scaladocClassName; } JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName); cmd.addArgs(args); cmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ cmd.addArgs("-Ydoc"); } scalaClassName = oldClazz; return cmd; } 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { getLog().warn("Using older form of compile"); return compile(Arrays.asList(sourceDir.getAbsolutePath()), outputDir, classpathElements, compileInLoop); } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = -1; if (lastCompileAtFile.exists() && outputDir.exists() && (outputDir.list().length > 0)) { lastCompileAt = lastCompileAtFile.lastModified(); } ArrayList<File> files = new ArrayList<File>(scalaSourceFiles.size()); for (String x : scalaSourceFiles) { File f = new File(x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } Add java files to the source, so we make sure we can have nested dependencies BUT only when not compiling in "loop" fashion and when we're not using an older version of scala if(!compileInLoop && sendJavaToScalac && isJavaSupportedByCompiler()) { List<String> javaSourceFiles = findSource(sourceRootDirs,"java"); for(String javaSourceFile : javaSourceFiles) { files.add(new File(javaSourceFile)); } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSource ( List < String > sourceRootDirs , String extension ) { List < String > sourceFiles = new ArrayList < String > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for(String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = JavaCommand.findFiles(dir, "**/*." + extension); for(String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile.getAbsolutePath()); } } return sourceFiles; } 
protected Set < Artifact > resolveDependencyArtifacts ( MavenProject theProject ) throws Exception { AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( new ArtifactFilter ( ) { public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } } ) ; TODO follow the dependenciesManagement and override rules Set<Artifact> artifacts = theProject.createArtifacts(factory, Artifact.SCOPE_RUNTIME, filter); for (Artifact artifact : artifacts) { resolver.resolve(artifact, remoteRepos, localRepo); } return artifacts; } 
private void checkCorrectVersionsOfScalaLibrary ( ) throws Exception { tgetLog ( ) . info ( " Checking for multiple versions of scala " ) ; checkArtifactForScalaVersion(dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
private void checkArtifactForScalaVersion ( DependencyNode rootNode ) throws Exception { tfinal CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( scalaVersion , getLog ( ) ) ; tCollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { if ( failOnMultipleScalaVersions ) { 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { tList < ArtifactFilter > filters = new ArrayList < ArtifactFilter > ( ) ; tfilters . add ( new ScalaDistroArtifactFilter ( ) ) ; treturn new AndDependencyNodeFilter ( filters ) ; } 
public boolean isScalaDistroArtifact ( Artifact artifact ) { treturn SCALA_DISTRO_GROUP . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & tSCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
public boolean include ( Artifact artifact ) { SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public boolean accept ( DependencyNode node ) { treturn include ( node . getArtifact ( ) ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
public void addJvmArgs ( String . . . args ) { if ( args ! = null ) { for ( String arg : args ) { 
protected String [ ] buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( javaExec ) ; back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; return back . toArray ( new String [ back . size ( ) ] ) ; } 
private File createArgFile ( ) throws IOException { final File argFile = File . createTempFile ( " scala-maven- " , " .args " ) ; argFile . deleteOnExit ( ) ; final PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( argFile ) ) ) ; try { for ( String arg : args ) { out . println ( arg ) ; } } finally { out . close ( ) ; } return argFile ; } 
protected String [ ] buildCommand ( ) throws IOException { ArrayList < String > back = new ArrayList < String > ( 3 + jvmArgs . size ( ) ) ; back . add ( javaExec ) ; back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . add ( " @ " + createArgFile ( ) . getAbsolutePath ( ) ) ; return back . toArray ( new String [ back . size ( ) ] ) ; } 
private String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " .* \\ s.* " ) ) { return '"' + arg + '"' ; } return arg ; } 
private File createArgFile ( ) throws IOException { final File argFile = File . createTempFile ( " scala-maven- " , " .args " ) ; argFile . deleteOnExit ( ) ; final PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( argFile ) ) ) ; try { for ( String arg : args ) { out . println ( escapeArgumentForScalacArgumentFile ( arg ) ) ; } } finally { out . close ( ) ; } return argFile ; } 
protected String [ ] buildCommand ( ) throws IOException { ArrayList < String > back = new ArrayList < String > ( 3 + jvmArgs . size ( ) ) ; back . add ( javaExec ) ; back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; String fileName = createArgFile ( ) . getCanonicalPath ( ) ; back . add ( " @ " + fileName ) ; return back . toArray ( new String [ back . size ( ) ] ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
public boolean canGenerateReport ( ) { try { sourceDir = sourceDir . getCanonicalFile ( ) ; } catch ( IOException exc ) { sourceDir = sourceDir . getAbsoluteFile ( ) ; } there is source to compile boolean back = sourceDir.exists() && (findSourceFiles().length != 0); there is modules to aggregate back = back || ((project.isExecutionRoot() || forceAggregate) && StringUtils.isNotEmpty(vscaladocVersion) && (new VersionNumber(vscaladocVersion).compareTo(new VersionNumber("1.1")) >= 0) && project.getCollectedProjects().size() > 0); return back; } 
protected JavaMainCaller newScalaDocCmd ( ) throws Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addOption ( " -classpath " , JavaCommand . toMultiPath ( project . getCompileClasspathElements ( ) ) ) ; jcmd . addOption ( " -sourcepath " , sourceDir . getAbsolutePath ( ) ) ; jcmd . addOption ( " -bottom " , getBottomText ( ) ) ; jcmd . addOption ( " -charset " , charset ) ; jcmd . addOption ( " -doctitle " , doctitle ) ; jcmd . addOption ( " -footer " , footer ) ; jcmd . addOption ( " -header " , header ) ; jcmd . addOption ( " -linksource " , linksource ) ; jcmd . addOption ( " -nocomment " , nocomment ) ; jcmd . addOption ( " -stylesheetfile " , stylesheetfile ) ; jcmd . addOption ( " -top " , top ) ; jcmd . addOption ( " -windowtitle " , windowtitle ) ; return jcmd ; } 
public void addOption ( String key , String value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } addArgs ( key , value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | ( key = = null ) ) { return ; } addArgs ( key ) ; } 
public void addArgs ( String . . . args ) { if ( args ! = null ) { this . args . addAll ( Arrays . asList ( args ) ) ; 
public void addEnvVar ( String key , String value ) { this . env . add ( key + " = " + value ) ; 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = new JavaCommand ( this , mainConsole , classpathStr , jvmArgs , args ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = new JavaCommand ( this , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { if( new VersionNumber(scalaVersion).compareTo(new VersionNumber("2.7.4")) >= 0) { TODO - Version 2.8.0 and above support passing arguments in a file via the @ argument. getLog().info("use scala command with args in file"); cmd = new ScalaCommandWIthArgsInFile(this, mainClass, getToolClasspath(), null, null); } else { getLog().info("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaCommand(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } } else { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
protected void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaCommand ( this , mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaCommand ( this , launchers [ i ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaCommand ( this , launchers [ 0 ] . mainClass , JavaCommand . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
public void addJvmArgs ( String . . . args ) { if ( args ! = null ) { for ( String arg : args ) { 
public void addToClasspath ( File entry ) throws Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; 
protected String [ ] buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . toArray ( new String [ back . size ( ) ] ) ; } 
private long lengthOf ( List < String > l , long sepLength ) throws Exception { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
private static String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " .* \\ s.* " ) ) { return '"' + arg + '"' ; } return arg ; } 
private static String unescapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . charAt ( 0 ) = = '"' & & arg . charAt ( arg . length ( ) - 1 ) = = '"' ) { return arg . substring ( 1 , arg . length ( ) - 1 ) ; } return arg ; } 
public static File createArgFile ( List < String > args ) throws IOException { final File argFile = File . createTempFile ( " scala-maven- " , " .args " ) ; argFile . deleteOnExit ( ) ; final PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( argFile ) ) ) ; try { for ( String arg : args ) { out . println ( escapeArgumentForScalacArgumentFile ( arg ) ) ; } } finally { out . close ( ) ; } return argFile ; } 
public static List < String > readArgFile ( File argFile ) throws IOException { ArrayList < String > back = new ArrayList < String > ( ) ; final BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ; try { String line = null ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } finally { in . close ( ) ; } return back ; } 
public static String locateJar ( Class < ? > c ) throws ClassNotFoundException { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*:(.*)!.*$ " ) ; 
public static void main ( String [ ] args ) { try { String mainClassName = args [ 0 ] ; 
public void addJvmArgs ( String . . . args ) { } 
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ args . size ( ) ] ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , cl ) ; } 
protected String [ ] buildCommand ( ) throws IOException { ArrayList < String > back = new ArrayList < String > ( 3 + jvmArgs . size ( ) ) ; back . add ( javaExec ) ; back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; String fileName = MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ; back . add ( " @ " + fileName ) ; return back . toArray ( new String [ back . size ( ) ] ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { if( new VersionNumber(scalaVersion).compareTo(new VersionNumber("2.8.0")) >= 0) { TODO - Version 2.8.0 and above support passing arguments in a file via the @ argument. getLog().info("use scala command with args in file"); cmd = new ScalaCommandWIthArgsInFile(this, mainClass, getToolClasspath(), null, null); } else { getLog().info("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaCommand(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } } else { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
public static File createArgFile ( List < String > args ) throws IOException { final File argFile = File . createTempFile ( " scala-maven- " , " .args " ) ; argFile.deleteOnExit(); final PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile))); try { for(String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } finally { out.close(); } return argFile; } 
protected String [ ] buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; System . out . println ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . toArray ( new String [ back . size ( ) ] ) ; } 
public static String locateJar ( Class < ? > c ) throws ClassNotFoundException { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; 
protected String [ ] buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . toArray ( new String [ back . size ( ) ] ) ; } 
public static String locateJar ( Class < ? > c ) throws Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; long lastCompileAt = - 1 ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { lastCompileAt = lastCompileAtFile . lastModified ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( ! compileInLoop ) { getLog ( ) . info ( String . format ( " Compiling %d source files to %s " , files . size ( ) , outputDir . getAbsolutePath ( ) ) ) ; } long now = System . currentTimeMillis ( ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , JavaCommand . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSourceWithFilters ( List < String > sourceRootDirs ) { List < String > sourceFiles = new ArrayList < String > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for(String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = JavaCommand.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for(String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile.getAbsolutePath()); } } return sourceFiles; } 
private String [ ] findSourceFiles ( ) { if ( sourceFiles_ = = null ) { if ( includes . isEmpty ( ) ) { tincludes . add ( " **/*.scala " ) ; } sourceFiles_ = JavaCommand . findFiles ( sourceDir , includes . toArray ( new String [ includes . size ( ) ] ) , excludes . toArray ( new String [ excludes . size ( ) ] ) ) ; } return sourceFiles_ ; } 
public static String [ ] findFiles ( File dir , String pattern ) { return findFiles ( dir , new String [ ] { pattern } , new String [ 0 ] ) ; } 
public static String [ ] findFiles ( File dir , String [ ] includes , String [ ] excludes ) { DirectoryScanner scanner = new DirectoryScanner ( ) ; scanner . setBasedir ( dir ) ; scanner . setIncludes ( includes ) ; scanner . setExcludes ( excludes ) ; scanner . addDefaultExcludes ( ) ; scanner . scan ( ) ; return scanner . getIncludedFiles ( ) ; } 
protected void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) throws Exception { addToClasspath ( groupId , artifactId , version , classpath , true ) ; } 
protected void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) throws Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , " jar " ) , classpath , addDependencies ) ; } 
protected void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) throws Exception { tresolver . resolve ( artifact , remoteRepos , localRepo ) ; tclasspath . add ( artifact . getFile ( ) . getCanonicalPath ( ) ) ; if ( addDependencies ) { tfor ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
private Set < String > getCompilerPlugins ( ) throws Exception { tSet < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { tSet < String > ignoreClasspath = new HashSet < String > ( ) ; taddToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , tignoreClasspath ) ; taddToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , tscalaVersion , ignoreClasspath ) ; tfor ( BasicArtifact artifact : compilerPlugins ) { tSystem . out . println ( " compiler plugin: " + artifact . toString ( ) ) ; } 
private void configureClasspath ( Set < String > classpath ) throws Exception , tDependencyResolutionRequiredException { tMavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; tCollection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { tgetLog ( ) . warn ( " No scopes were included " ) ; } else { tString [ ] include = includeScopes . split ( " , " ) ; tfor ( String string : include ) { tScopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { ttoInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { tgetLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { tString [ ] exclude = excludeScopes . split ( " , " ) ; tfor ( String string : exclude ) { tScopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { ttoInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { tgetLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } tfor ( Dependency dependency : toInclude ) { taddToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , true ) ; } if ( addToClasspath ! = null ) { tclasspath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { tArrayList < String > toRemove = new ArrayList < String > ( ) ; tString [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; tfor ( String string : classpath ) { tfor ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { ttoRemove . add ( string ) ; } } } tclasspath . removeAll ( toRemove ) ; } tString outputDirectory = project . getBuild ( ) . getOutputDirectory ( ) ; if ( ! outputDirectory . endsWith ( " / " ) ) { getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; if ( interpreterNeedsToBeLocal ( ) ) { tList < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; tboolean noJline = false ; if ( args ! = null ) { tfor ( String arg : args ) { tlist . add ( arg ) ; if ( args . equals ( " -Ynojline " ) ) { tnoJline = true ; } } } tlist . add ( " -cp " ) ; tlist . add ( classpathStr ) ; tjcmd = new ReflectionJavaMainCaller ( this , mainConsole , classpathStr , jvmArgs , list . toArray ( new String [ list . size ( ) ] ) ) ; } else { tjcmd = new JavaCommand ( this , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; } if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
private boolean interpreterNeedsToBeLocal ( ) { treturn System . getProperty ( " os.name " ) . toLowerCase ( ) . contains ( " windows " ) ; } 
protected void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) throws Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( artifact . getFile ( ) . getCanonicalPath ( ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
private void checkCorrectVersionsOfScalaLibrary ( ) throws Exception { getLog ( ) . info ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 checkArtifactForScalaVersion(dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
private void checkArtifactForScalaVersion ( DependencyNode rootNode ) throws Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( scalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { if ( failOnMultipleScalaVersions ) { 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < ArtifactFilter > filters = new ArrayList < ArtifactFilter > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { if( new VersionNumber(scalaVersion).compareTo(new VersionNumber("2.8.0")) >= 0) { TODO - Version 2.8.0 and above support passing arguments in a file via the @ argument. getLog().info("use scala command with args in file"); cmd = new ScalaCommandWIthArgsInFile(this, mainClass, getToolClasspath(), null, null); } else { getLog().info("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaCommand(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } } else { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
protected boolean isJavaSupportedByCompiler ( ) { return new VersionNumber ( scalaVersion ) . compareTo ( new VersionNumber ( " 2.7.2 " ) ) > = 0 ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { System . out . println ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; long lastCompileAt = - 1 ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { lastCompileAt = lastCompileAtFile . lastModified ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( ! compileInLoop ) { getLog ( ) . info ( String . format ( " Compiling %d source files to %s " , files . size ( ) , outputDir . getAbsolutePath ( ) ) ) ; } long now = System . currentTimeMillis ( ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , JavaCommand . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; if ( interpreterNeedsToBeLocal ( ) ) { List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new ReflectionJavaMainCaller ( this , mainConsole , classpathStr , jvmArgs , list . toArray ( new String [ list . size ( ) ] ) ) ; } else { jcmd = new JavaCommand ( this , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; } if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
private boolean interpreterNeedsToBeLocal ( ) { return System . getProperty ( " os.name " ) . toLowerCase ( ) . contains ( " windows " ) ; } 
private String [ ] findSourceFiles ( ) { if ( sourceFiles_ = = null ) { if ( includes . isEmpty ( ) ) { includes . add ( " **/*.scala " ) ; } sourceFiles_ = JavaCommand . findFiles ( sourceDir , includes . toArray ( new String [ includes . size ( ) ] ) , excludes . toArray ( new String [ excludes . size ( ) ] ) ) ; } return sourceFiles_ ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) if( new VersionNumber(scalaVersion).compareTo(new VersionNumber("2.8.0")) >= 0) { TODO - Version 2.8.0 and above support passing arguments in a file via the @ argument. getLog().info("use scala command with args in file"); cmd = new ScalaCommandWIthArgsInFile(this, mainClass, getToolClasspath(), null, null); } else { getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaCommand(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } } else { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; if ( interpreterNeedsToBeLocal ( ) ) { List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new ReflectionJavaMainCaller ( this , mainConsole , classpathStr , jvmArgs , list . toArray ( new String [ list . size ( ) ] ) ) ; } else { jcmd = new JavaCommand ( this , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; } if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . run ( displayCmd ) ; } 
public abstract void addEnvVar ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) public abstract void run(boolean displayCmd) throws Exception; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void run ( boolean displayCmd ) throws Exception ; public abstract void spawn ( boolean displayCmd ) throws Exception ; } 
public abstract void run ( boolean displayCmd , boolean throwFailure ) throws Exception ; public abstract void spawn ( boolean displayCmd ) throws Exception ; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; long lastCompileAt = - 1 ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { lastCompileAt = lastCompileAtFile . lastModified ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( ! compileInLoop ) { getLog ( ) . info ( String . format ( " Compiling %d source files to %s " , files . size ( ) , outputDir . getAbsolutePath ( ) ) ) ; } long now = System . currentTimeMillis ( ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSourceWithFilters ( List < String > sourceRootDirs ) { List < String > sourceFiles = new ArrayList < String > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for(String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for(String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile.getAbsolutePath()); } } return sourceFiles; } 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; if ( interpreterNeedsToBeLocal ( ) ) { List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new JavaMainCallerInProcess ( this , mainConsole , classpathStr , jvmArgs , list . toArray ( new String [ list . size ( ) ] ) ) ; } else { jcmd = new JavaMainCallerByFork ( this , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; } if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . run ( displayCmd ) ; } 
private String [ ] findSourceFiles ( ) { if ( sourceFiles_ = = null ) { if ( includes . isEmpty ( ) ) { includes . add ( " **/*.scala " ) ; } sourceFiles_ = MainHelper . findFiles ( sourceDir , includes . toArray ( new String [ includes . size ( ) ] ) , excludes . toArray ( new String [ excludes . size ( ) ] ) ) ; } return sourceFiles_ ; } 
protected JavaMainCaller newScalaDocCmd ( ) throws Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addOption ( " -classpath " , MainHelper . toMultiPath ( project . getCompileClasspathElements ( ) ) ) ; jcmd . addOption ( " -sourcepath " , sourceDir . getAbsolutePath ( ) ) ; jcmd . addOption ( " -bottom " , getBottomText ( ) ) ; jcmd . addOption ( " -charset " , charset ) ; jcmd . addOption ( " -doctitle " , doctitle ) ; jcmd . addOption ( " -footer " , footer ) ; jcmd . addOption ( " -header " , header ) ; jcmd . addOption ( " -linksource " , linksource ) ; jcmd . addOption ( " -nocomment " , nocomment ) ; jcmd . addOption ( " -stylesheetfile " , stylesheetfile ) ; jcmd . addOption ( " -top " , top ) ; jcmd . addOption ( " -windowtitle " , windowtitle ) ; return jcmd ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } else { cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
private String getBootClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , classpath ) ; return MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
protected void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( this , mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ i ] . mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ 0 ] . mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } currentScriptIndex + + ; prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); File destFile = new File(scriptDir + "/" + scriptBaseName() + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); URLClassLoader loader = createScriptClassloader(scriptDir, classpath); boolean mavenProjectDependency = hasMavenProjectDependency(classpath); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
private boolean hasMavenProjectDependency ( Set < String > classpath ) throws MalformedURLException { try { List < URL > urls = new ArrayList < URL > ( ) ; 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader ) throws Exception { Class < ? > compiledScript = loader . loadClass ( scriptBaseName ( ) ) ; try { try { 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) throws MalformedURLException { List < URL > urls = new ArrayList < URL > ( ) ; add the script directory to the classpath urls.add(scriptDir.toURI().toURL()); for (String string : classpath) { urls.add(new URL("file:" + string)); } URLClassLoader loader = new URLClassLoader(urls.toArray(new URL[urls .size()]), getClass().getClassLoader()); return loader; } 
private void compileScript ( File scriptDir , File destFile , Set < String > classpath ) throws Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( new ArrayList < String > ( classpath ) ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
private void configureClasspath ( Set < String > classpath ) throws Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : toInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , true ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > toRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( toRemove ) ; } String outputDirectory = project . getBuild ( ) . getOutputDirectory ( ) ; if ( ! outputDirectory . endsWith ( " / " ) ) { need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); addToClasspath("org.scala-lang", "scala-compiler", scalaVersion, classpath); addToClasspath("org.scala-lang", "scala-library", scalaVersion, classpath); getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) throws IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream ) ; try { BufferedReader reader ; 
private String scriptBaseName ( ) { if ( scriptFile = = null ) { return " embeddedScript_ " + currentScriptIndex ; 
private void delete ( File scriptDir ) { if ( scriptDir . isDirectory ( ) ) { for ( File file : scriptDir . listFiles ( ) ) { delete ( file ) ; } } scriptDir . deleteOnExit ( ) ; scriptDir . delete ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getCompileDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getRuntimeDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getTestDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getSystemDependencies ( ) ; } 
public abstract Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException ; public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . trim ( ) . equalsIgnoreCase ( name . trim ( ) ) ) { return scope ; } } return null ; } } } 
public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . trim ( ) . equalsIgnoreCase ( name . trim ( ) ) ) { return scope ; } } return null ; } 
protected String [ ] buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . toArray ( new String [ back . size ( ) ] ) ; } 
private long lengthOf ( List < String > l , long sepLength ) throws Exception { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
public void addJvmArgs ( String . . . args ) { TODO - Ignore classpath } public void run(boolean displayCmd, boolean throwFailure) throws Exception { try { runInternal(displayCmd); } catch (Exception e) { if(throwFailure) { throw e; } } } private void runInternal(boolean displayCmd) throws Exception { String[] argArray = args.toArray(new String[args.size()]); if(displayCmd) { requester.getLog().info("cmd : " + mainClassName + "(" + StringUtils.join(argArray, ",")+")"); } MainHelper.runMain(mainClassName, args, cl); }} 
public void run ( boolean displayCmd , boolean throwFailure ) throws Exception { try { runInternal ( displayCmd ) ; 
public void spawn ( final boolean displayCmd ) throws Exception { Thread = new Thread ( ) { @Override public void run ( ) { try { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } } }; t.start(); } 
public void run ( ) { try { runInternal ( displayCmd ) ; 
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ args . size ( ) ] ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , cl ) ; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; long lastCompileAt = - 1 ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { lastCompileAt = lastCompileAtFile . lastModified ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( ! compileInLoop ) { getLog ( ) . info ( String . format ( " Compiling %d source files to %s " , files . size ( ) , outputDir . getAbsolutePath ( ) ) ) ; } if ( files . size ( ) < 1 ) { return 0 ; } long now = System . currentTimeMillis ( ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSourceWithFilters ( List < String > sourceRootDirs ) { List < String > sourceFiles = new ArrayList < String > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile.getAbsolutePath()); } } return sourceFiles; } 
public boolean endVisit ( DependencyNode node ) { return ! _failed ; } 
public boolean isScalaDistroArtifact ( Artifact artifact ) { return SCALA_DISTRO_GROUP . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
protected String [ ] buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . toArray ( new String [ back . size ( ) ] ) ; } 
private long lengthOf ( List < String > l , long sepLength ) throws Exception { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
public void addJvmArgs ( String . . . args ) { TODO - Ignore classpath for (String arg : args) { requester.getLog().warn("jvmArgs are ignored when run in process :" + arg); 
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ args . size ( ) ] ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , cl ) ; } 
public void addJvmArgs ( String . . . args ) { TODO - Ignore classpath if (args != null) { for (String arg : args) { 
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ args . size ( ) ] ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
protected void doExecute ( ) throws Exception { System . out . println ( sendRequestAdd ( ) ) ; System . out . println ( sendRequestCompile ( ) ) ; } 
private String toYaml ( MavenProject project ) throws Exception { HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) ) ; data . put ( " sourcesDirs " , getSourceDirectories ( ) ) ; if ( includes ! = null ) { data . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { data . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } data . put ( " targetDir " , outputDir . getCanonicalPath ( ) ) ; data . put ( " classpath " , project . getCompileClasspathElements ( ) ) ; if ( args ! = null ) { data . put ( " args " , args ) ; } Yaml yaml = new Yaml ( ) ; return yaml . dump ( data ) ; } 
protected List < String > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = sourceDir.getCanonicalPath(); if(!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return sources; } 
protected String sendRequestAdd ( ) throws Exception { String yamlDef = toYaml ( project ) ; String back = " " ; try { back = sendRequest ( " add " , yamlDef ) ; } catch ( java . net . ConnectException exc ) { startNewServer ( ) ; back = sendRequest ( " add " , yamlDef ) ; } return back ; } 
protected String sendRequestCompile ( ) throws Exception { return sendRequest ( " compile " , null ) ; } 
protected String sendRequestStop ( ) throws Exception { return sendRequest ( " stop " , null ) ; } 
protected String sendRequest ( String action , String data ) throws Exception { URL url = new URL ( " http:127.0.0.1:27616/ " + action ) ; URLConnection cnx = url . openConnection ( ) ; cnx . setDoOutput ( StringUtils . isNotEmpty ( data ) ) ; cnx . setDoInput ( true ) ; if ( StringUtils . isNotEmpty ( data ) ) { IOUtil . copy ( data , cnx . getOutputStream ( ) ) ; IOUtil . close ( cnx . getOutputStream ( ) ) ; } String back = IOUtil . toString ( cnx . getInputStream ( ) ) ; IOUtil . close ( cnx . getInputStream ( ) ) ; return back ; } 
private void startNewServer ( ) throws Exception { getLog ( ) . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-tools " , " scala-tools-server " , " 0.1-SNAPSHOT " , classpath ) ; JavaMainCaller jcmd = new JavaMainCallerByFork ( this , " org.scala_tools.server.HttpServer " , MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) , null , null , forceUseArgFile ) ; jcmd . spawn ( displayCmd ) ; boolean started = false ; while ( ! started ) { try { 
public void addJvmArgs ( String . . . args ) { TODO - Ignore classpath if(args != null) { for (String arg : args) { 
protected void doExecute ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new JavaMainCallerInProcess ( this , mainConsole , classpathStr , jvmArgs , list . toArray ( new String [ list . size ( ) ] ) ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . run ( displayCmd ) ; } 
private List < File > findSourceWithFilters ( List < String > sourceRootDirs ) { List < File > sourceFiles = new ArrayList < File > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile); } } return sourceFiles; } 
private String toYaml ( MavenProject project ) throws Exception { HashMap < String , Object > dataCompile = new HashMap < String , Object > ( ) ; dataCompile . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /main " ) ; dataCompile . put ( " sourcesDirs " , getSourceDirectories ( ) ) ; if ( includes ! = null ) { dataCompile . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataCompile . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataCompile . put ( " targetDir " , outputDir . getCanonicalPath ( ) ) ; dataCompile . put ( " classpath " , project . getCompileClasspathElements ( ) ) ; if ( args ! = null ) { dataCompile . put ( " args " , args ) ; } dataCompile . put ( " dependency-link-path " , localRepo . pathOf ( project . getArtifact ( ) ) ) ; HashMap < String , Object > dataTest = new HashMap < String , Object > ( ) ; dataTest . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /test " ) ; dataTest . put ( " sourcesDirs " , project . getTestCompileSourceRoots ( ) ) ; if ( includes ! = null ) { dataTest . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataTest . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataTest . put ( " targetDir " , testOutputDir . getCanonicalPath ( ) ) ; dataTest . put ( " classpath " , project . getTestClasspathElements ( ) ) ; if ( args ! = null ) { dataTest . put ( " args " , args ) ; } Yaml yaml = new Yaml ( ) ; return yaml . dump ( dataCompile ) + " /n---/n " + yaml . dump ( dataTest ) ; } 
private void startNewServer ( ) throws Exception { getLog ( ) . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-tools " , " scala-tools-server " , stsVersion , classpath ) ; JavaMainCaller jcmd = new JavaMainCallerByFork ( this , " org.scala_tools.server.HttpServer " , MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) , null , null , forceUseArgFile ) ; jcmd . spawn ( displayCmd ) ; boolean started = false ; while ( ! started ) { try { 
private List < File > normalize ( List < String > compileSourceRootsList ) { List < File > newCompileSourceRootsList = new ArrayList < File > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = normalize(new File(srcDir)); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { getLog().warn("Using older form of compile"); return compile(Arrays.asList(sourceDir), outputDir, classpathElements, compileInLoop); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long now = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , now ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, now); } getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - now) / 1000)); _lastCompileAt = now; return files.size(); } 
private List < File > findSourceWithFilters ( List < File > sourceRootDirs ) { List < File > sourceFiles = new ArrayList < File > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile); } } return sourceFiles; } 
private void notifyCompilation ( List < File > files ) throws Exception { if ( notifyCompilation ) { for ( File f : files ) { 
private long findLastSuccessfullCompilation ( File outputDir ) throws Exception { long back = - 1 ; final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { back = lastCompileAtFile . lastModified ( ) ; } return back ; } 
private void setLastSuccessfullCompilation ( File outputDir , long v ) throws Exception { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; if ( lastCompileAtFile . exists ( ) ) { } else { FileUtils . fileWrite ( lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } lastCompileAtFile . setLastModified ( v ) ; } 
public abstract void addEnvVar ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) public abstract void run(boolean displayCmd) throws Exception; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void run ( boolean displayCmd ) throws Exception ; public abstract void spawn ( boolean displayCmd ) throws Exception ; } 
public abstract boolean run ( boolean displayCmd , boolean throwFailure ) throws Exception ; public abstract void spawn ( boolean displayCmd ) throws Exception ; } 
protected void processLine ( String line , int level ) { if ( line . toLowerCase ( ) . indexOf ( " error " ) > - 1 ) { requester . getLog ( ) . error ( line ) ; 
public boolean run ( boolean displayCmd , boolean throwFailure ) throws Exception { try { runInternal ( displayCmd ) ; 
public void addOption ( String key , String value ) { if ( StringUtils . isEmpty ( value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key ) ; } 
public void addArgs ( String . . . args ) { if ( args ! = null ) { for ( String arg : args ) { 
protected List < String > getSourceDirectories ( ) throws Exception { throw new UnsupportedOperationException ( " USELESS " ) ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { long t0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long t1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , t1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
public abstract void addEnvVar ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) public abstract void run(boolean displayCmd) throws Exception; public abstract void spawn(boolean displayCmd) throws Exception;} 
protected void processLine ( String line , int level ) { if ( line . toLowerCase ( ) . indexOf ( " error " ) > - 1 ) { requester . getLog ( ) . error ( line ) ; 
public void redirectToLog ( ) { requester . getLog ( ) . warn ( " redirection to log is not supported for 'inProcess' mode " ) ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { long t0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long t1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , t1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } 
private List < File > findSourceWithFilters ( List < File > sourceRootDirs ) { List < File > sourceFiles = new ArrayList < File > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile); } } scalac is sensible to scala file order, file system can't garanty file order => unreproductible build error across platform to garanty reproductible command line we order file by path (os dependend). Collections.sort(sourceFiles); return sourceFiles; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(new VersionNumber(scalaVersion)) > 0); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } jcmd.addOption("-classpath", MainHelper.toMultiPath(project.getCompileClasspathElements())); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(new VersionNumber(scalaVersion)) <= 0) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
public void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) throws Exception { addToClasspath ( groupId , artifactId , version , classpath , true ) ; } 
public void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) throws Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , " jar " ) , classpath , addDependencies ) ; } 
protected void doExecute ( ) throws Exception { super . doExecute ( ) ; System . out . println ( scs . sendRequestCompile ( ) ) ; } 
protected void doExecute ( ) throws Exception { super . doExecute ( ) ; String yaml = toYaml ( project ) . toString ( ) ; if ( dumpYaml ) { FileUtils . fileWrite ( project . getBuild ( ) . getDirectory ( ) + " /project.yaml " , " UTF-8 " , yaml ) ; } TODO use parser and maven logger to print (and find warning, error,...) System.out.println(scs.sendRequestCreateOrUpdate(yaml)); if (compileAfterInit) { System.out.println(scs.sendRequestCompile()); 
private CharSequence toYaml ( MavenProject project ) throws Exception { HashMap < String , Object > dataCompile = new HashMap < String , Object > ( ) ; dataCompile . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /main " ) ; dataCompile . put ( " sourceDirs " , getSourceDirectories ( ) ) ; if ( includes ! = null ) { dataCompile . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataCompile . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataCompile . put ( " targetDir " , outputDir . getCanonicalPath ( ) ) ; dataCompile . put ( " classpath " , project . getCompileClasspathElements ( ) ) ; if ( args ! = null ) { dataCompile . put ( " args " , args ) ; } dataCompile . put ( " exported " , new File ( localRepo . getBasedir ( ) , localRepo . pathOf ( project . getArtifact ( ) ) ) . getCanonicalPath ( ) ) ; HashMap < String , Object > dataTest = new HashMap < String , Object > ( ) ; dataTest . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /test " ) ; dataTest . put ( " sourceDirs " , project . getTestCompileSourceRoots ( ) ) ; if ( includes ! = null ) { dataTest . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataTest . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataTest . put ( " targetDir " , testOutputDir . getCanonicalPath ( ) ) ; dataTest . put ( " classpath " , project . getTestClasspathElements ( ) ) ; if ( args ! = null ) { dataTest . put ( " args " , args ) ; } Yaml yaml = new Yaml ( ) ; StringBuilder back = new StringBuilder ( ) ; back . append ( yaml . dump ( dataCompile ) ) .append("---") .append(yaml.dump(dataTest)) ; return back; } 
protected void doExecute ( ) throws Exception { scs = new ScalacsClient ( this , csVersion ) ; } 
protected void doExecute ( ) throws Exception { super . doExecute ( ) ; System . out . println ( scs . sendRequestStop ( ) ) ; } 
public String toString ( ) { return level + " * " + category + " * " + file + " * " + line + " * " + column + " * " + offset + " * " + length + " * " + text + " * " ; } 
public String sendRequestCreateOrUpdate ( String yamlDef ) throws Exception { String back = " " ; try { back = sendRequest ( " createOrUpdate " , yamlDef ) ; } catch ( java . net . ConnectException exc ) { startNewServer ( ) ; back = sendRequest ( " createOrUpdate " , yamlDef ) ; } return back ; } 
public String sendRequestRemove ( String projectName ) throws Exception { return sendRequest ( " remove?p= " + projectName , null ) ; } 
public String sendRequestCompile ( ) throws Exception { return sendRequest ( " compile " , null ) ; } 
public String sendRequestClean ( ) throws Exception { return sendRequest ( " clean " , null ) ; } 
public String sendRequestStop ( ) throws Exception { return sendRequest ( " stop " , null ) ; } 
protected String sendRequest ( String action , String data ) throws Exception { URL url = new URL ( " http:127.0.0.1:27616/ " + action ) ; traceUrl ( url ) ; URLConnection cnx = url . openConnection ( ) ; cnx . setDoOutput ( StringUtils . isNotEmpty ( data ) ) ; cnx . setDoInput ( true ) ; if ( StringUtils . isNotEmpty ( data ) ) { OutputStream os = cnx . getOutputStream ( ) ; try { IOUtil . copy ( new StringReader ( data ) , os ) ; } finally { IOUtil . close ( os ) ; } } InputStream is = cnx . getInputStream ( ) ; try { String back = IOUtil . toString ( is ) ; 
public void traceUrl ( URL url ) throws Exception { _log . debug ( " request : " + url ) ; } 
public void startNewServer ( ) throws Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath(_mojo.SCALA_GROUPID, "scala-compiler", _mojo.scalaVersion, classpath); _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); jcmd.spawn(_mojo.displayCmd); boolean started = false; while (!started) { try { 
public void spawn ( boolean displayCmd ) throws Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; displayCmd ( displayCmd , cmd ) ; ProcessBuilder pb = new ProcessBuilder ( cmd ) ; pb . redirectErrorStream ( true ) ; pb . start ( ) ; } 
private void displayCmd ( boolean displayCmd , List < String > cmd ) { if ( displayCmd ) { requester . getLog ( ) . info ( " cmd: " + " " + StringUtils . join ( cmd . iterator ( ) , " " ) ) ; 
protected List < String > buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back ; } 
public void spawn ( boolean displayCmd ) throws Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < String > ( ) ; String cmdStr = StringUtils . join ( cmd . iterator ( ) , " " ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . add ( cmdStr ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . add ( cmdStr ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); pb.start(); } 
protected void doExecute ( ) throws Exception { super . doExecute ( ) ; System . out . println ( scs . sendRequestCompile ( project . getArtifactId ( ) + " - " + project . getVersion ( ) , true , true ) ) ; } 
protected void doExecute ( ) throws Exception { super . doExecute ( ) ; System . out . println ( scs . sendRequestCompile ( project . getArtifactId ( ) + " - " + project . getVersion ( ) , false , false ) ) ; } 
protected void doExecute ( ) throws Exception { super . doExecute ( ) ; String yaml = toYaml ( project ) . toString ( ) ; if ( dumpYaml ) { new File ( project . getBuild ( ) . getDirectory ( ) ) . mkdirs ( ) ; FileUtils . fileWrite ( project . getBuild ( ) . getDirectory ( ) + " /project.yaml " , " UTF-8 " , yaml ) ; } TODO use parser and maven logger to print (and find warning, error,...) System.out.println(scs.sendRequestCreateOrUpdate(yaml)); if (compileAfterInit) { System.out.println(scs.sendRequestCompile(project.getArtifactId()+"-"+project.getVersion(), true, true)); 
protected void doExecute ( ) throws Exception { scs = new ScalacsClient ( this , csVersion , jvmArgs ) ; } 
public String sendRequestCompile ( String projectName , boolean withDependencies , boolean withDependent ) throws Exception { StringBuilder query = new StringBuilder ( " compile? " ) ; if ( StringUtils . isNotEmpty ( projectName ) ) { query . append ( " p= " ) . append ( projectName ) ; if ( ! withDependencies ) { query . append ( " &noDependencies=true " ) ; } if ( ! withDependent ) { query . append ( " &noDependent=true " ) ; } } return sendRequest ( query . toString ( ) , null ) ; } 
public void startNewServer ( ) throws Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); _mojo.addToClasspath("org.scala-tools.sbt", "sbt-launch", "0.7.2", classpath, true); File scalaCsBootConf = installConf(new File(System.getProperty("user.home"), ".sbt-launch/scalacs-"+ _csVersion +".boot.properties")); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "xsbt.boot.Boot", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), _jvmArgs, new String[]{scalaCsBootConf.getCanonicalPath()}, false); jcmd.spawn(_mojo.displayCmd); boolean started = false; for(int i = 60; i>0 && !started; i--) { try { System.out.print("."); Thread.sleep(1000); sendRequest("ping", null); started = true; System.out.println(" started"); } catch (java.net.ConnectException exc) { started = false; useless but more readable } } if (!started) { throw new IllegalStateException("can't start and connect to scalacs"); 
private File installConf ( File scalaCsBootConf ) throws Exception { if ( ! scalaCsBootConf . isFile ( ) ) { scalaCsBootConf . getParentFile ( ) . mkdirs ( ) ; InputStream is = null ; StringWriter sw = new StringWriter ( ) ; try { is = this . getClass ( ) . getResourceAsStream ( " scalacs.boot.properties " ) ; IOUtil . copy ( is , sw ) ; } finally { IOUtil . close ( is ) ; IOUtil . close ( sw ) ; } Properties p = new Properties ( System . getProperties ( ) ) ; p . setProperty ( " scalacs.version " , _csVersion ) ; p . setProperty ( " scalacs.directory " , scalaCsBootConf . getParentFile ( ) . getCanonicalPath ( ) ) ; String cfg = StringUtils . interpolate ( sw . toString ( ) , p ) ; FileUtils . fileWrite ( scalaCsBootConf . getCanonicalPath ( ) , " UTF-8 " , cfg ) ; } return scalaCsBootConf ; } 
public abstract void addEnvVar ( String key , String value ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) public abstract void run(boolean displayCmd) throws Exception; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void run ( boolean displayCmd ) throws Exception ; public abstract SpawnMonitor spawn ( boolean displayCmd ) throws Exception ; } 
public abstract boolean run ( boolean displayCmd , boolean throwFailure ) throws Exception ; public abstract SpawnMonitor spawn ( boolean displayCmd ) throws Exception ; } 
public abstract SpawnMonitor spawn ( boolean displayCmd ) throws Exception ; } 
public SpawnMonitor spawn ( boolean displayCmd ) throws Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < String > ( ) ; String cmdStr = StringUtils . join ( cmd . iterator ( ) , " " ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . add ( cmdStr ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . add ( cmdStr ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return new SpawnMonitor(){ public boolean isRunning() throws Exception { 
public boolean isRunning ( ) throws Exception { try { p . exitValue ( ) ; 
public SpawnMonitor spawn ( final boolean displayCmd ) throws Exception { final Thread = new Thread ( ) { @Override public void run ( ) { try { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } } }; t.start(); return new SpawnMonitor() { public boolean isRunning() throws Exception { 
public boolean isRunning ( ) throws Exception { return . isAlive ( ) ; } 
protected CharSequence doRequest ( ) throws Exception { return scs . sendRequestCompile ( projectNamePattern ( ) , true , true ) ; } 
protected CharSequence doRequest ( ) throws Exception { return scs . sendRequestCompile ( projectNamePattern ( ) , false , false ) ; } 
protected CharSequence doRequest ( ) throws Exception { String yaml = toYaml ( project ) . toString ( ) ; if ( dumpYaml ) { new File ( project . getBuild ( ) . getDirectory ( ) ) . mkdirs ( ) ; FileUtils . fileWrite ( project . getBuild ( ) . getDirectory ( ) + " /project.yaml " , " UTF-8 " , yaml ) ; } StringBuilder back = new StringBuilder ( ) ; back . append ( scs . sendRequestCreateOrUpdate ( yaml ) ) ; if ( compileAfterInit ) { back . append ( scs . sendRequestCompile ( project . getArtifactId ( ) + " - " + project . getVersion ( ) , true , true ) ) ; } return back ; } 
private CharSequence toYaml ( MavenProject project ) throws Exception { HashMap < String , Object > dataCompile = new HashMap < String , Object > ( ) ; dataCompile . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /main " ) ; dataCompile . put ( " sourceDirs " , getSourceDirectories ( ) ) ; if ( includes ! = null ) { dataCompile . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataCompile . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataCompile . put ( " targetDir " , outputDir . getCanonicalPath ( ) ) ; dataCompile . put ( " classpath " , project . getCompileClasspathElements ( ) ) ; if ( args ! = null ) { dataCompile . put ( " args " , args ) ; } dataCompile . put ( " exported " , new File ( localRepo . getBasedir ( ) , localRepo . pathOf ( project . getArtifact ( ) ) ) . getCanonicalPath ( ) ) ; HashMap < String , Object > dataTest = new HashMap < String , Object > ( ) ; dataTest . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /test " ) ; dataTest . put ( " sourceDirs " , project . getTestCompileSourceRoots ( ) ) ; if ( includes ! = null ) { dataTest . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataTest . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataTest . put ( " targetDir " , testOutputDir . getCanonicalPath ( ) ) ; dataTest . put ( " classpath " , project . getTestClasspathElements ( ) ) ; if ( args ! = null ) { dataTest . put ( " args " , args ) ; } Yaml yaml = new Yaml ( ) ; List < HashMap < String , Object > > prjs = new LinkedList < HashMap < String , Object > > ( ) ; prjs . add ( dataCompile ) ; prjs . add ( dataTest ) ; return yaml . dumpAll ( prjs . iterator ( ) ) ; } 
final protected void doExecute ( ) throws Exception { scs = new ScalacsClient ( this , csVersion , jvmArgs ) ; String output = doRequest ( ) . toString ( ) ; TODO use parser and maven logger to print (and find warning, error,...) TODO use Stream instead of String to allow progressive display (when scalacs will support it) System.out.println(output); if (output.contains("-ERROR")) { throw new MojoFailureException("ScalaCS reply with ERRORs"); 
protected abstract CharSequence doRequest ( ) throws Exception ; protected String projectNamePattern ( ) throws Exception { return project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /.* " ; } } 
protected String projectNamePattern ( ) throws Exception { return project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /.* " ; } 
protected CharSequence doRequest ( ) throws Exception { return scs . sendRequestStop ( ) ; } 
protected CharSequence doRequest ( ) throws Exception { return scs . sendRequestCompile ( null , true , true ) ; } 
protected CharSequence doRequest ( ) throws Exception { return scs . sendRequestRemove ( projectNamePattern ( ) ) ; } 
public String sendRequestCompile ( String projectName , boolean withDependencies , boolean withDependent ) throws Exception { StringBuilder query = new StringBuilder ( " compile " ) ; if ( StringUtils . isNotEmpty ( projectName ) ) { query . append ( " ?p= " ) . append ( projectName ) ; if ( ! withDependencies ) { query . append ( " &noDependencies=true " ) ; } not supported by scalacs 0.2 if (!withDependent) { query.append("&noDependent=true"); } } return sendRequest(query.toString(), null); } 
public void traceUrl ( URL url ) throws Exception { String msg = " request : " + url ; if ( _mojo . displayCmd ) { _log . info ( msg ) ; 
public void startNewServer ( ) throws Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); _mojo.addToClasspath("org.scala-tools.sbt", "sbt-launch", "0.7.2", classpath, true); String[] jvmArgs = new String[(_jvmArgs == null)?1:_jvmArgs.length + 1]; File installDir = new File(System.getProperty("user.home"), ".sbt-launch"); jvmArgs[0] = "-Dsbt.boot.properties="+ installConf(new File(installDir, "scalacs-"+ _csVersion +".boot.properties")).getCanonicalPath(); if (_jvmArgs != null) { System.arraycopy(_jvmArgs, 0, jvmArgs, 1, _jvmArgs.length); } FileTailer tailer = new FileTailer(new File(installDir, "update.log")); boolean started = false; try { JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "xsbt.boot.Boot", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), jvmArgs, null, false); SpawnMonitor mon = jcmd.spawn(_mojo.displayCmd); for(int i = 60; i>0 && !started && mon.isRunning(); i--) { try { if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } else { System.out.print("."); } Thread.sleep(1000); sendRequest("ping", null); started = true; } catch (java.net.ConnectException exc) { started = false; useless but more readable } } if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } System.out.println(""); } finally { tailer.close(); } if (!started) { throw new IllegalStateException("can't start and connect to scalacs"); 
private File installConf ( File scalaCsBootConf ) throws Exception { if ( ! scalaCsBootConf . isFile ( ) ) { scalaCsBootConf . getParentFile ( ) . mkdirs ( ) ; InputStream is = null ; StringWriter sw = new StringWriter ( ) ; try { is = this . getClass ( ) . getResourceAsStream ( BOOT_PROP_RSRC ) ; if ( is = = null ) { is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( BOOT_PROP_RSRC ) ; } if ( is = = null ) { String abspath = " / " + this . getClass ( ) . getPackage ( ) . getName ( ) . replace ( '.' , '/' ) + " / " + BOOT_PROP_RSRC ; is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( abspath ) ; if ( is = = null ) { throw new IllegalStateException ( " can't find " + abspath + " in the classpath " ) ; } } IOUtil . copy ( is , sw ) ; } finally { IOUtil . close ( is ) ; IOUtil . close ( sw ) ; } Properties p = new Properties ( System . getProperties ( ) ) ; p . setProperty ( " scalacs.version " , _csVersion ) ; p . setProperty ( " scalacs.directory " , scalaCsBootConf . getParentFile ( ) . getCanonicalPath ( ) ) ; String cfg = StringUtils . interpolate ( sw . toString ( ) , p ) ; FileUtils . fileWrite ( scalaCsBootConf . getCanonicalPath ( ) , " UTF-8 " , cfg ) ; } return scalaCsBootConf ; } 
public CharSequence whatNew ( ) throws Exception { StringBuilder back = new StringBuilder ( ) ; if ( _raf = = null & & _file . isFile ( ) ) { _raf = new RandomAccessFile ( _file , " r " ) ; } if ( _raf ! = null ) { Compare the length of the file to the file pointer long fileLength = _file.length(); if( fileLength < _filePointer ) { Log file must have been rotated or deleted; reopen the file and reset the file pointer close(); _raf = new RandomAccessFile(_file, "r" ); _filePointer = 0; } if( fileLength > _filePointer ) { There is data to read _raf.seek( _filePointer ); back = _raf.readUTF(); String line = null; while( (line = _raf.readLine())!= null ) { back.append( line ).append(''); } _filePointer = _raf.getFilePointer(); } } return back; } 
public void close ( ) { try { if ( _raf ! = null ) { 
final protected void doExecute ( ) throws Exception { scs = new ScalacsClient ( this , csGroupId , csArtifactId , csVersion , jvmArgs ) ; String output = doRequest ( ) . toString ( ) ; TODO use parser and maven logger to print (and find warning, error,...) TODO use Stream instead of String to allow progressive display (when scalacs will support it) System.out.println(output); if (output.contains("-ERROR")) { throw new MojoFailureException("ScalaCS reply with ERRORs"); 
public void startNewServer ( ) throws Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); _mojo.addToClasspath("org.scala-tools.sbt", "sbt-launch", "0.7.2", classpath, true); String[] jvmArgs = new String[(_jvmArgs == null)?1:_jvmArgs.length + 1]; File installDir = new File(System.getProperty("user.home"), ".sbt-launch"); jvmArgs[0] = "-Dsbt.boot.properties="+ installConf(new File(installDir, _csArtifactId + "-"+ _csVersion +".boot.properties")).getCanonicalPath(); if (_jvmArgs != null) { System.arraycopy(_jvmArgs, 0, jvmArgs, 1, _jvmArgs.length); } FileTailer tailer = new FileTailer(new File(installDir, "update.log")); boolean started = false; try { JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "xsbt.boot.Boot", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), jvmArgs, null, false); SpawnMonitor mon = jcmd.spawn(_mojo.displayCmd); for(int i = 60; i>0 && !started && mon.isRunning(); i--) { try { if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } else { System.out.print("."); } Thread.sleep(1000); sendRequest("ping", null); started = true; } catch (java.net.ConnectException exc) { started = false; useless but more readable } } if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } System.out.println(""); } finally { tailer.close(); } if (!started) { throw new IllegalStateException("can't start and connect to scalacs"); 
private File installConf ( File scalaCsBootConf ) throws Exception { if ( ! scalaCsBootConf . isFile ( ) ) { scalaCsBootConf . getParentFile ( ) . mkdirs ( ) ; InputStream is = null ; StringWriter sw = new StringWriter ( ) ; try { is = this . getClass ( ) . getResourceAsStream ( BOOT_PROP_RSRC ) ; if ( is = = null ) { is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( BOOT_PROP_RSRC ) ; } if ( is = = null ) { String abspath = " / " + this . getClass ( ) . getPackage ( ) . getName ( ) . replace ( '.' , '/' ) + " / " + BOOT_PROP_RSRC ; is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( abspath ) ; if ( is = = null ) { throw new IllegalStateException ( " can't find " + abspath + " in the classpath " ) ; } } IOUtil . copy ( is , sw ) ; } finally { IOUtil . close ( is ) ; IOUtil . close ( sw ) ; } Properties p = new Properties ( System . getProperties ( ) ) ; p . setProperty ( " scalacs.groupId " , _csGroupId ) ; p . setProperty ( " scalacs.artifactId " , _csArtifactId ) ; p . setProperty ( " scalacs.version " , _csVersion ) ; p . setProperty ( " scalacs.directory " , scalaCsBootConf . getParentFile ( ) . getCanonicalPath ( ) ) ; String cfg = StringUtils . interpolate ( sw . toString ( ) , p ) ; FileUtils . fileWrite ( scalaCsBootConf . getCanonicalPath ( ) , " UTF-8 " , cfg ) ; } return scalaCsBootConf ; } 
public String toString ( ) { return " BasicArtifact( " + groupId + " , " + artifactId + " , " + version + " ) " ; } 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", scalaVersion, classpath); addToClasspath("org.scala-lang", "scala-library", scalaVersion, classpath); addToClasspath("jline", "jline", "0.9.94", classpath); classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
private void checkArtifactForScalaVersion ( DependencyNode rootNode ) throws Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( scalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
public void logScalaDependents ( ) { _log . warn ( " Expected all dependencies to require Scala version: " + _version ) ; for ( String dependString : scalaDependentArtifactStrings ) { _log . warn ( dependString ) ; 
public static String makeArtifactNameString ( Artifact artifact ) { TODO - Handle version ranges... if(artifact == null) { return "<null artifact>"; } return artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getVersion(); } 
public void execute ( ) throws MojoExecutionException , MojoFailureException { try { String oldWay = System . getProperty ( " maven.scala.version " ) ; 
public void execute ( ) throws MojoExecutionException { try { if ( sourceDir ! = null ) { 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } currentScriptIndex + + ; if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = Scopes . PLUGIN . name ( ) ; } } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); File destFile = new File(scriptDir + "/" + scriptBaseName() + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); URLClassLoader loader = createScriptClassloader(scriptDir, classpath); boolean mavenProjectDependency = hasMavenProjectDependency(classpath); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
private void configureClasspath ( Set < String > classpath ) throws Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : toInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , true ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > toRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( toRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); addToClasspath("org.scala-lang", "scala-compiler", scalaVersion, classpath); addToClasspath("org.scala-lang", "scala-library", scalaVersion, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { Plugin me = ( Plugin ) project . getBuild ( ) . getPluginsAsMap ( ) . get ( " org.scala-tools:maven-scala-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( ( Collection < Dependency > ) me . getDependencies ( ) ) ; return back ; } 
public abstract Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException ; public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . trim ( ) . equalsIgnoreCase ( name . trim ( ) ) ) { return scope ; } } return null ; } } } 
public static String toClasspathString ( ClassLoader cl ) throws Exception { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new LinkedList < String > ( ) ; appendUrltoClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . toString ( ) ; } 
public static void appendUrltoClasspathCollection ( ClassLoader cl , Collection < String > classpath ) throws Exception { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } while ( cl ! = null ) { if ( cl instanceof URLClassLoader ) { 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { Plugin me = ( Plugin ) project . getBuild ( ) . getPluginsAsMap ( ) . get ( " org.scala-tools:maven-scala-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( ( Collection < Dependency > ) me . getDependencies ( ) ) ; return back ; } 
protected List < String > getClasspathElements ( ) throws Exception { return TychoUtilities . addOsgiClasspathElements ( project , project . getCompileClasspathElements ( ) ) ; } 
public Method run ( ) throws Exception { Method m = mpClazz . getDeclaredMethod ( " getContextValue " , String . class ) ; m . setAccessible ( true ) ; return m ; } 
public Method run ( ) throws Exception { Method m = cpeClazz . getDeclaredMethod ( " getLocations " ) ; m . setAccessible ( true ) ; return m ; } 
public static List < String > addOsgiClasspathElements ( MavenProject project , List < String > defaultClasspathElements ) { if ( getLocationsMethod = = null ) { return defaultClasspathElements ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return defaultClasspathElements ; List < String > osgiClasspath = new ArrayList < String > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } osgiClasspath . addAll ( defaultClasspathElements ) ; return osgiClasspath ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(new VersionNumber(scalaVersion)) > 0); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } List<String> paths = project.getCompileClasspathElements(); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(new VersionNumber(scalaVersion)) <= 0) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
public void generate ( @SuppressWarnings ( " unused " ) Sink sink , @SuppressWarnings ( " unused " ) Locale locale ) throws MavenReportException { try { if ( ! canGenerateReport ( ) ) { 
protected void tryAggregateUpper ( MavenProject prj ) throws Exception { if ( prj ! = null & & prj . hasParent ( ) ) { MavenProject parent = prj . getParent ( ) ; 
private String scriptBaseName ( ) { if ( scriptFile = = null ) { return " embeddedScript_ " + currentScriptIndex ; } int dot = scriptFile . getName ( ) . lastIndexOf ( '.' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + currentScriptIndex ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + currentScriptIndex ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getCompileDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getRuntimeDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getTestDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getSystemDependencies ( ) ; } 
protected List < String > getSourceDirectories ( ) throws Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = testSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return sources ; } 
public void startNewServer ( ) throws Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); _mojo.addToClasspath("org.scala-tools.sbt", "sbt-launch", "0.7.2", classpath, true); String[] jvmArgs = new String[(_jvmArgs == null)?1:_jvmArgs.length + 1]; File installDir = new File(System.getProperty("user.home"), ".sbt-launch"); jvmArgs[0] = "-Dsbt.boot.properties="+ installConf(new File(installDir, _csArtifactId + "-"+ _csVersion +".boot.properties")).getCanonicalPath(); if (_jvmArgs != null) { System.arraycopy(_jvmArgs, 0, jvmArgs, 1, _jvmArgs.length); } FileTailer tailer = new FileTailer(new File(installDir, "update.log")); boolean started = false; try { JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "xsbt.boot.Boot", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), jvmArgs, null, false); SpawnMonitor mon = jcmd.spawn(_mojo.displayCmd); for(int i = 60; i>0 && !started && mon.isRunning(); i--) { try { if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } else { System.out.print("."); } Thread.sleep(1000); sendRequest("ping", null); started = true; } catch (java.net.ConnectException exc) { started = false; useless but more readable } } if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } System.out.println(""); } finally { tailer.close(); } if (!started) { throw new IllegalStateException("can't start and connect to scalacs"); } _mojo.getLog().info("scalacs connected"); } 
public boolean endVisit ( @SuppressWarnings ( " unused " ) DependencyNode node ) { return ! _failed ; } 
protected void processLine ( String line , @SuppressWarnings ( " unused " ) int level ) { if ( line . toLowerCase ( ) . indexOf ( " error " ) > - 1 ) { requester . getLog ( ) . error ( line ) ; 
public static String locateJar ( Class < ? > c ) throws Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; Matcher m = p . matcher ( location . toString ( ) ) ; if ( m . find ( ) ) { return URLDecoder . decode ( m . group ( 1 ) , " UTF-8 " ) ; } throw new ClassNotFoundException ( " Cannot parse location of ' " + location + " '. Probably not loaded from a Jar " ) ; } throw new ClassNotFoundException ( " Cannot find class ' " + c . getName ( ) + " using the classloader " ) ; } 
public List < String > getCompileClasspathElements ( ) throws DependencyResolutionRequiredException { return wrapped . getCompileClasspathElements ( ) ; } 
public List < String > getRuntimeClasspathElements ( ) throws DependencyResolutionRequiredException { return wrapped . getRuntimeClasspathElements ( ) ; } 
public List < String > getSystemClasspathElements ( ) throws DependencyResolutionRequiredException { return wrapped . getSystemClasspathElements ( ) ; } 
public List < String > getTestClasspathElements ( ) throws DependencyResolutionRequiredException { return wrapped . getTestClasspathElements ( ) ; } 
public String apply ( String key , String defaultValue ) { String result = apply ( key ) ; if ( result = = null ) { return defaultValue ; } return result ; } 
public void update ( String key , String value ) { if ( key . equals ( " build.directory " ) | | key . equals ( " project.build.directory " ) 
public void update ( String key , int value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , boolean value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , double value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , long value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , char value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , float value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , byte value ) { update ( key , String . valueOf ( value ) ) ; } 
public void addAttachedArtifact ( Artifact artifact ) { wrapped . addAttachedArtifact ( artifact ) ; } 
public void addCompileSourceRoot ( String path ) { wrapped . addCompileSourceRoot ( path ) ; } 
public void addContributor ( Contributor contributor ) { wrapped . addContributor ( contributor ) ; } 
public void addDeveloper ( Developer developer ) { wrapped . addDeveloper ( developer ) ; } 
public void addLicense ( License license ) { wrapped . addLicense ( license ) ; } 
public void addMailingList ( MailingList mailingList ) { wrapped . addMailingList ( mailingList ) ; } 
public void addPlugin ( Plugin plugin ) { wrapped . addPlugin ( plugin ) ; } 
public void addProjectReference ( MavenProject project ) { wrapped . addProjectReference ( project ) ; } 
public void addResource ( Resource resource ) { wrapped . addResource ( resource ) ; } 
public void addScriptSourceRoot ( String path ) { wrapped . addScriptSourceRoot ( path ) ; } 
public void addTestCompileSourceRoot ( String path ) { wrapped . addTestCompileSourceRoot ( path ) ; } 
public void addTestResource ( Resource testResource ) { wrapped . addTestResource ( testResource ) ; } 
public Set < Artifact > createArtifacts ( ArtifactFactory artifactFactory , String inheritedScope , ArtifactFilter dependencyFilter ) throws InvalidDependencyVersionException { return wrapped . createArtifacts ( artifactFactory , inheritedScope , dependencyFilter ) ; 
public boolean equals ( Object arg0 ) { return wrapped . equals ( arg0 ) ; } 
public Xpp3Dom getGoalConfiguration ( String arg0 , String arg1 , String arg2 , String arg3 ) { return wrapped . getGoalConfiguration ( arg0 , arg1 , arg2 , arg3 ) ; } 
public String getModulePathAdjustment ( MavenProject arg0 ) throws IOException { return wrapped . getModulePathAdjustment ( arg0 ) ; } 
public boolean hasParent ( ) { return wrapped . hasParent ( ) ; } 
public void injectPluginManagementInfo ( Plugin arg0 ) { wrapped . injectPluginManagementInfo ( arg0 ) ; } 
public boolean isExecutionRoot ( ) { return wrapped . isExecutionRoot ( ) ; } 
public Artifact replaceWithActiveArtifact ( Artifact arg0 ) { return wrapped . replaceWithActiveArtifact ( arg0 ) ; } 
public void setDistributionManagement ( DistributionManagement distributionManagement ) { wrapped . setDistributionManagement ( distributionManagement ) ; } 
public void setReleaseArtifactRepository ( ArtifactRepository releaseArtifactRepository ) { wrapped . setReleaseArtifactRepository ( releaseArtifactRepository ) ; } 
public void setSnapshotArtifactRepository ( ArtifactRepository snapshotArtifactRepository ) { wrapped . setSnapshotArtifactRepository ( snapshotArtifactRepository ) ; } 
public void writeModel ( Writer writer ) throws IOException { wrapped . writeModel ( writer ) ; } 
public void writeOriginalModel ( Writer writer ) throws IOException { wrapped . writeOriginalModel ( writer ) ; } 
public boolean canGenerateReport ( ) { try { sourceDir = sourceDir . getCanonicalFile ( ) ; } catch ( IOException exc ) { sourceDir = sourceDir . getAbsoluteFile ( ) ; } there is source to compile boolean back = sourceDir.exists() && (findSourceFiles().length != 0); there is modules to aggregate back = back || ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0); return back; } 
private boolean canAggregate ( ) { return StringUtils . isNotEmpty ( vscaladocVersion ) & & ( new VersionNumber ( vscaladocVersion ) . compareTo ( new VersionNumber ( " 1.1 " ) ) > = 0 ) ; } 
protected void tryAggregateUpper ( MavenProject prj ) throws Exception { if ( prj ! = null & & prj . hasParent ( ) & & canAggregate ( ) ) { MavenProject parent = prj . getParent ( ) ; 
public List < LogEvent > parse ( String response ) throws Exception { List < LogEvent > back = new LinkedList < LogEvent > ( ) ; BufferedReader in = new BufferedReader ( new StringReader ( response ) ) ; try { for ( String l = in . readLine ( ) ; l ! = null ; l = in . readLine ( ) ) { Matcher m = linePattern . matcher ( l ) ; if ( m . matches ( ) ) { LogEvent e = new LogEvent ( ) ; e . level = Level . valueOf ( m . group ( 1 ) . toUpperCase ( ) ) ; e . category = m . group ( 2 ) ; e . text = m . group ( 4 ) . replace ( '$' , '' ) ; Matcher ml = locationPattern . matcher ( m . group ( 3 ) ) ; if ( ml . matches ( ) ) { e . file = new File ( ml . group ( 1 ) ) ; e . line = Integer . parseInt ( m . group ( 2 ) ) ; e . column = Integer . parseInt ( m . group ( 3 ) ) ; e . offset = Integer . parseInt ( m . group ( 4 ) ) ; e . length = Integer . parseInt ( m . group ( 5 ) ) ; } back . add ( e ) ; } } } finally { IOUtil . close ( in ) ; } return back ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { JavaMainCaller jcmd = super . getScalaCommand ( ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " -verbose " , verbose ) ; } return jcmd ; } 
protected void postCompileActions ( ) { } private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
protected void postCompileActions ( ) throws Exception { } private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { long t0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long t1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , t1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected boolean hasCompileErrors ( ) { return compileErrors ; } 
protected void clearCompileErrors ( ) { compileErrors = false ; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = normalize ( mainOutputDir ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = normalize ( mainSourceDir ) ; testOutputDir = normalize ( testOutputDir ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } testSourceDir = normalize ( testSourceDir ) ; if ( useFsc ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
public void sayHello ( ) { System . out . println ( " Java says:Hello Scala! " ) ; tHelloScala . sayHello ( ) ; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = sourceDir.getCanonicalPath(); if(!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. String sv = findScalaVersion().toString(); Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); addToClasspath("jline", "jline", "0.9.94", classpath); classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected List < File > getSourceDirectories ( ) throws Exception { throw new UnsupportedOperationException ( " USELESS " ) ; } 
public boolean canGenerateReport ( ) { there is modules to aggregate boolean back = ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0); back = back || (findSourceFiles().size() != 0); return back; } 
private List < File > findSourceFiles ( ) { if ( _sourceFiles = = null ) { try { _sourceFiles = findSourceWithFilters ( ) ; } catch ( Exception exc ) { throw new RuntimeException ( " can't define source to process " , exc ) ; } } return _sourceFiles ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(findScalaVersion()) > 0); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } List<String> paths = project.getCompileClasspathElements(); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(findScalaVersion()) <= 0) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
protected void checkScalaVersion ( ) throws Exception { if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( findScalaVersion ( ) . toString ( ) ) ; 
private void checkCorrectVersionsOfScalaLibrary ( String requiredScalaVersion ) throws Exception { getLog ( ) . info ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
private void checkArtifactForScalaVersion ( String requiredScalaVersion , DependencyNode rootNode ) throws Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , findScalaVersion ( ) . toString ( ) , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
private String getBootClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) , classpath ) ; return MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
protected boolean isJavaSupportedByCompiler ( ) throws Exception { return findScalaVersion ( ) . compareTo ( new VersionNumber ( " 2.7.2 " ) ) > = 0 ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; String sv = findScalaVersion ( ) . toString ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , sv , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
private void configureClasspath ( Set < String > classpath ) throws Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : toInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , true ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > toRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( toRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); String sv = findScalaVersion().toString(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected List < File > normalize ( List < String > compileSourceRootsList ) { List < File > newCompileSourceRootsList = new ArrayList < File > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = normalize(new File(srcDir)); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = testSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; } 
public String toString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . toString ( ) ; } 
public void testParse ( ) throws Exception { tassertParseVN ( " 2.7.1 " , 2 , 7 , 1 , null ) ; tassertParseVN ( " 2.7 " , 2 , 7 , 0 , null ) ; tassertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; tassertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; tassertParseVN ( " 2.7.RC " , 2 , 7 , 0 , " .RC " ) ; tassertParseVN ( " 2.7-RC " , 2 , 7 , 0 , " -RC " ) ; tassertParseVN ( " 2.7.1-SNAPSHOT " , 2 , 7 , 1 , " -SNAPSHOT " ) ; } 
private void assertParseVN ( String str , int major , int minor , int bugfix , String modifier ) { tVersionNumber v = new VersionNumber ( str ) ; assertEquals ( " test major of " + str , major , v . major ) ; assertEquals ( " test minor of " + str , minor , v . minor ) ; assertEquals ( " test bugfix of " + str , bugfix , v . bugfix ) ; assertEquals ( " est modifier of " + str , modifier , v . modifier ) ; } 
protected List < File > findSourceWithFilters ( ) throws Exception { return findSourceWithFilters ( getSourceDirectories ( ) ) ; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = sourceDir.getCanonicalPath(); if (!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
protected void doExecute ( ) throws Exception { if ( StringUtils . isNotEmpty ( _mainClass ) ) { File cfg = makeJsonCfg ( ) ; 
private void toJson ( Object pojo , boolean prettyPrint , File f ) throws Exception { ObjectMapper m = new ObjectMapper ( ) ; JsonFactory jf = new JsonFactory ( ) ; JsonGenerator jg = jf . createJsonGenerator ( f , JsonEncoding . UTF8 ) ; if ( prettyPrint ) { jg . useDefaultPrettyPrinter ( ) ; } m . writeValue ( jg , pojo ) ; } 
private File makeJsonCfg ( ) throws Exception { initFilters ( ) ; File dir = new File ( project . getBuild ( ) . getDirectory ( ) ) ; dir . mkdirs ( ) ; File f = new File ( dir , " vscaladoc2_cfg.json " ) ; toJson ( new Cfg ( this ) , _prettyPrint , f ) ; return f ; } 
protected List < List < String > > makeDependencies ( ScalaGenJsonMojo data ) throws Exception { List < List < String > > back = new ArrayList < List < String > > ( ) ; @SuppressWarnings ( " unchecked " ) List < Artifact > deps = data . project . getCompileArtifacts ( ) ; for ( Artifact dep : deps ) { List < String > e = new ArrayList < String > ( 3 ) ; e . add ( dep . getFile ( ) . getCanonicalPath ( ) ) ; e . add ( dep . getArtifactId ( ) ) ; e . add ( dep . getVersion ( ) ) ; back . add ( e ) ; } return back ; } 
protected List < List < Object > > makeSources ( ScalaGenJsonMojo data ) throws Exception { List < List < Object > > back = new ArrayList < List < Object > > ( ) ; List < File > dirs = data . getSourceDirectories ( ) ; List < String > includes = new ArrayList < String > ( data . includes ) ; List < String > excludes = new ArrayList < String > ( data . excludes ) ; for ( File dir : dirs ) { List < Object > e = new ArrayList < Object > ( 3 ) ; e . add ( dir . getCanonicalPath ( ) ) ; e . add ( excludes ) ; e . add ( includes ) ; back . add ( e ) ; } return back ; } 
protected List < List < String > > makeArtifacts ( ScalaGenJsonMojo data ) throws Exception { List < List < String > > back = new ArrayList < List < String > > ( ) ; @SuppressWarnings ( " unchecked " ) List < MavenProject > modules = data . project . getCollectedProjects ( ) ; for ( MavenProject module : modules ) { List < String > e = new ArrayList < String > ( 2 ) ; e . add ( module . getArtifactId ( ) ) ; e . add ( module . getVersion ( ) ) ; back . add ( e ) ; } return back ; } 
protected List < File > findSourceWithFilters ( List < File > sourceRootDirs ) throws Exception { List < File > sourceFiles = new ArrayList < File > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile); } } scalac is sensible to scala file order, file system can't garanty file order => unreproductible build error across platform to garanty reproductible command line we order file by path (os dependend). Collections.sort(sourceFiles); return sourceFiles; } 
private String makeKind ( ScalaGenJsonMojo data ) { String back = null ; String pkg = data . project . getPackaging ( ) ; if ( " pom " . equals ( pkg ) ) { back = " group " ; } else { back = pkg ; } return back ; } 
protected List < List < String > > makeDependencies ( ScalaGenJsonMojo data ) throws Exception { List < List < String > > back = new ArrayList < List < String > > ( ) ; @SuppressWarnings ( " unchecked " ) List < Artifact > deps = data . project . getCompileArtifacts ( ) ; for ( Artifact dep : deps ) { List < String > e = new ArrayList < String > ( 3 ) ; e . add ( dep . getFile ( ) . getCanonicalPath ( ) ) ; e . add ( dep . getArtifactId ( ) + " / " + dep . getVersion ( ) ) ; back . add ( e ) ; } return back ; } 
protected List < String > makeArtifacts ( ScalaGenJsonMojo data ) throws Exception { List < String > back = new ArrayList < String > ( ) ; @SuppressWarnings ( " unchecked " ) List < MavenProject > modules = data . project . getCollectedProjects ( ) ; for ( MavenProject module : modules ) { back . add ( module . getArtifactId ( ) + " / " + module . getVersion ( ) ) ; } return back ; } 
private void toJson ( Object pojo , boolean prettyPrint , File f ) throws Exception { ObjectMapper m = new ObjectMapper ( ) ; JsonFactory jf = new JsonFactory ( ) ; JsonGenerator jg = jf . createJsonGenerator ( f , JsonEncoding . UTF8 ) ; if ( prettyPrint ) { jg . useDefaultPrettyPrinter ( ) ; } ObjectNode tree = m . valueToTree ( pojo ) ; if ( StringUtils . isNotEmpty ( overrideJson ) ) { JsonNode overrideTree = m . readValue ( overrideJson , JsonNode . class ) ; Iterator < String > ks = overrideTree . getFieldNames ( ) ; while ( ks . hasNext ( ) ) { String k = ks . next ( ) ; JsonNode v = overrideTree . get ( k ) ; tree . put ( k , v ) ; } } m . writeTree ( jg , tree ) ; } 
protected void doExecute ( ) throws Exception { if ( StringUtils . isNotEmpty ( _mainClass ) ) { Cfg cfg = new Cfg ( this ) ; 
private File makeJsonCfg ( Cfg cfg ) throws Exception { initFilters ( ) ; File dir = new File ( project . getBuild ( ) . getDirectory ( ) ) ; dir . mkdirs ( ) ; File f = new File ( dir , " vscaladoc2_cfg.json " ) ; toJson ( cfg , _prettyPrint , f ) ; return f ; } 
private void registerApidocArchiveForInstall ( Cfg cfg ) throws Exception { File apidocArchiveFile = new File ( System . getProperty ( " user.home " ) , " .config/vscaladoc2/apis/ " + cfg . artifactId + " / " + cfg . version + " -apidoc.jar.gz " ) . getCanonicalFile ( ) ; if ( apidocArchiveFile . exists ( ) ) { projectHelper . attachArtifact ( project , " jar.gz " , " apidoc " , apidocArchiveFile ) ; 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) throws MalformedURLException { List < URL > urls = new ArrayList < URL > ( ) ; urls.add(new File(string).toURI().toURL()); } URLClassLoader loader = new URLClassLoader(urls.toArray(new URL[urls .size()]), getClass().getClassLoader()); return loader; } 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. String sv = findScalaVersion().toString(); Set<String> classpath = new HashSet<String>(); addCompilerToClasspath(sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); addToClasspath("jline", "jline", "0.9.94", classpath); classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected void addCompilerToClasspath ( String version , Set < String > classpath ) throws Exception { if ( StringUtils . isEmpty ( scalaHome ) ) { addToClasspath ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , version , classpath ) ; 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addCompilerToClasspath ( findScalaVersion ( ) . toString ( ) , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; String sv = findScalaVersion ( ) . toString ( ) ; addCompilerToClasspath ( sv , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
private void configureClasspath ( Set < String > classpath ) throws Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : toInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , true ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > toRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( toRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); String sv = findScalaVersion().toString(); addCompilerToClasspath(sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. String sv = findScalaVersion().toString(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(sv, classpath); addLibraryToClasspath(sv, classpath); addToClasspath("jline", "jline", "0.9.94", classpath); classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected void addLibraryToClasspath ( String version , Set < String > classpath ) throws Exception { if ( StringUtils . isEmpty ( scalaHome ) ) { addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , version , classpath ) ; 
private String getBootClasspath ( ) throws Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addLibraryToClasspath ( findScalaVersion ( ) . toString ( ) , classpath ) ; return MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < String > ( ) ; String sv = findScalaVersion ( ) . toString ( ) ; addCompilerToClasspath ( sv , ignoreClasspath ) ; addLibraryToClasspath ( sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
private void configureClasspath ( Set < String > classpath ) throws Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : toInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , true ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > toRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( toRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); String sv = findScalaVersion().toString(); addCompilerToClasspath(sv, classpath); addLibraryToClasspath(sv, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); String sv = scalaVersion.toString(); Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", sv, classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
public static String pathOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
public static File fileOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath); if(!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); String sv = scalaVersion.toString(); Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", sv, classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+ javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = FileUtils . fileOf ( mainSourceDir , useCanonicalPath ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } testSourceDir = FileUtils . fileOf ( testSourceDir , useCanonicalPath ) ; if ( useFsc ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath); if (!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
protected void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) throws Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( FileUtils . pathOf ( artifact . getFile ( ) , useCanonicalPath ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
protected List < File > findSourceWithFilters ( List < File > sourceRootDirs ) throws Exception { List < File > sourceFiles = new ArrayList < File > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensible to scala file order, file system can't garanty file order => unreproductible build error across platform to garanty reproductible command line we order file by path (os dependend). Collections.sort(sourceFiles); return sourceFiles; } 
protected List < File > normalize ( List < String > compileSourceRootsList ) throws Exception { List < File > newCompileSourceRootsList = new ArrayList < File > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = FileUtils.fileOf(new File(srcDir), useCanonicalPath); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
private static String scriptBaseNameOf ( File scriptFile , int idx ) { if ( scriptFile = = null ) { return " embeddedScript_ " + idx ; } int dot = scriptFile . getName ( ) . lastIndexOf ( '.' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + idx ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + idx ; } 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = Scopes . PLUGIN . name ( ) ; } } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); URLClassLoader loader = createScriptClassloader(scriptDir, classpath); boolean mavenProjectDependency = hasMavenProjectDependency(classpath); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader , String baseName ) throws Exception { Class < ? > compiledScript = loader . loadClass ( baseName ) ; try { try { 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) throws IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream ) ; try { BufferedReader reader ; 
protected void processLine ( String line , @SuppressWarnings ( " unused " ) int level ) { try { _previous = LogProcessorUtils . levelStateOf ( line , _previous ) ; 
public static LevelState levelStateOf ( String line , LevelState previous ) throws Exception { LevelState back = new LevelState ( ) ; String lineLowerCase = line . toLowerCase ( ) ; if ( lineLowerCase . indexOf ( " error " ) > - 1 ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . indexOf ( " warn " ) > - 1 ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; } 
private LevelState assertLevelState ( String input , LevelState previous , Level expectedLevel , String expectedUntilContains ) throws Exception { LevelState back = LogProcessorUtils . levelStateOf ( input , previous ) ; assertEquals ( expectedLevel , back . level ) ; assertEquals ( expectedUntilContains , back . untilContains ) ; return back ; } 
public void testJdkSplit ( ) throws Exception { LevelState previous = new LevelState ( ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala:-1: info: compiling " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514 " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Recompiling 1 files " , previous , Level . INFO , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " two errors found " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " BUILD ERROR " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " wrap: org.apache.commons.exec.ExecuteException: Process exited with an error: 1(Exit value: 1) " , previous , Level . ERROR , null ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(findScalaVersion()) > 0); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<String>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(findScalaVersion()) <= 0) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
private String getBootClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) , classpath ) ; addToClasspath ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) , classpath ) ; return MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
public void doExecute ( ) throws Exception { if ( skip ) { getLog ( ) . info ( " Skipping javadoc generation " ) ; return ; } try { generate ( null , Locale . getDefault ( ) ) ; 
protected void failOnError ( String prefix , Exception e ) throws MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } throw new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); String sv = scalaVersion.toString(); Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", sv, classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+ javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { Plugin me = ( Plugin ) project . getBuild ( ) . getPluginsAsMap ( ) . get ( " net.alchim31.maven:scala-maven-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( ( Collection < Dependency > ) me . getDependencies ( ) ) ; return back ; } 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader , String baseName ) throws Exception { Class < ? > compiledScript = loader . loadClass ( baseName ) ; ClassLoader currentCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; try { try { 
protected void processLine ( String line , int level ) { try { _previous = LogProcessorUtils . levelStateOf ( line , _previous ) ; 
protected JavaMainCaller getScalaCommand ( ) throws Exception { JavaMainCaller cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected List < String > getClasspathElements ( ) throws Exception { List < String > back = project . getCompileClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getOutputDirectory ( ) ) ; back . add ( getOutputDir ( ) . getAbsolutePath ( ) ) ; back = TychoUtilities . addOsgiClasspathElements ( project , back ) ; return back ; } 
protected List < String > getClasspathElements ( ) throws Exception { List < String > back = project . getTestClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; back . add ( getOutputDir ( ) . getAbsolutePath ( ) ) ; return back ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); } else { cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
protected void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; Toolchain toolchain = toolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( this , mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile , toolchain ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ i ] . mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , toolchain ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ 0 ] . mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , toolchain ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
public void compile ( List < String > classpathElements , List < File > sourcesList , File outputDir , List < String > scalacOptions , List < String > javacOptions ) { Seq < File > classpath = listToSeq ( pathsToFiles ( classpathElements ) ) ; Seq < File > sources = listToSeq ( sourcesList ) ; Seq < String > soptions = listToSeq ( scalacOptions ) ; Seq < String > joptions = listToSeq ( javacOptions ) ; compiler . compile ( classpath , sources , outputDir , soptions , joptions ) ; } 
public < A > Seq < A > listToSeq ( List < A > list ) { return JavaConverters . collectionAsScalaIterableConverter ( list ) . asScala ( ) . toSeq ( ) ; } 
public List < File > pathsToFiles ( List < String > paths ) { List < File > files = new ArrayList < File > ( paths . size ( ) ) ; for ( String path : paths ) { files . add ( new File ( path ) ) ; } return files ; } 
public void error ( F0 < String > msg ) { if ( log . isErrorEnabled ( ) ) { log . error ( msg . apply ( ) ) ; 
public void warn ( F0 < String > msg ) { if ( log . isWarnEnabled ( ) ) { log . warn ( msg . apply ( ) ) ; 
public void info ( F0 < String > msg ) { if ( log . isInfoEnabled ( ) ) { log . info ( msg . apply ( ) ) ; 
public void debug ( F0 < String > msg ) { if ( log . isDebugEnabled ( ) ) { log . debug ( msg . apply ( ) ) ; 
public void trace ( F0 < Throwable > exception ) { if ( log . isDebugEnabled ( ) ) { log . debug ( exception . apply ( ) ) ; 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( INCREMENTAL . equals ( recompileMode ) ) { return incrementalCompile ( getClasspathElements ( ) , getSourceDirectories ( ) , outputDir ) ; } long t0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long t1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , t1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir ) throws Exception , InterruptedException { String scalaVersion = findScalaVersion ( ) . toString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = " org.scala-sbt " ; String xsbtiArtifactId = " interface " ; String compilerInterfaceArtifactId = " compiler-interface " ; String sbtVersion = findVersionFromPluginArtifacts ( " org.scala-sbt " , " sbt-incremental-compiler " ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , " src " ) ; if ( incremental = = null ) incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , getLog ( ) ) ; List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; incremental . compile ( classpathElements , sources , outputDir , scalacOptions , new ArrayList < String > ( ) ) ; return 1 ; } 
private String findScalaVersionFromDependencies ( ) throws Exception { return findVersionFromDependencies ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID ) ; } 
private void checkCorrectVersionsOfScalaLibrary ( String requiredScalaVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
protected JavaMainCaller getScalaCommand ( ) throws Exception { JavaMainCaller cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected List < String > getScalaOptions ( ) throws Exception { List < String > options = new ArrayList < String > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; return options ; } 
protected File getLibraryJar ( ) throws Exception { return getArtifactJar ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getCompilerJar ( ) throws Exception { return getArtifactJar ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getArtifactJar ( String groupId , String artifactId , String version ) throws Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , " jar " ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected File getArtifactJar ( String groupId , String artifactId , String version , String classifier ) throws Exception { Artifact artifact = factory . createArtifactWithClassifier ( groupId , artifactId , version , " jar " , classifier ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected List < File > findSourceWithFilters ( List < File > sourceRootDirs ) throws Exception { List < File > sourceFiles = new ArrayList < File > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensible to scala file order, file system can't garanty file order => unreproductible build error across platform to garanty reproductible command line we order file by path (os dependend). Collections.sort(sourceFiles); return sourceFiles; } 
public String toString ( ) { return " BasicArtifact( " + groupId + " , " + artifactId + " , " + version + " , " + classifier + " ) " ; } 
public void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) throws Exception { addToClasspath ( factory . createDependencyArtifact ( groupId , artifactId , VersionRange . createFromVersion ( version ) , " jar " , classifier , Artifact . SCOPE_RUNTIME ) , classpath , addDependencies ) ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; String sv = findScalaVersion ( ) . toString ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , sv , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
public static Analysis readAnalysis ( File file ) { AnalysisStore store = analysisStore ( file ) ; Option < Tuple2 < Analysis , CompileSetup > > result = store . get ( ) ; if ( result . isDefined ( ) ) { return result . get ( ) . _1 ( ) ; 
public static AnalysisStore analysisStore ( File file ) { Format < String > formatString = DefaultProtocol$ . MODULE$ . StringFormat ( ) ; Format < File > formatFile = fileFormat ( ) ; Format < Stamp > formatStamp = stampFormat ( hashStampFormat ( ) , lastModFormat ( ) , existsFormat ( ) ) ; Format < Map < File , Stamp > > formatMapFileStamp = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatStamp ) ; Format < Map < File , String > > formatMapFileString = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatString ) ; Format < Stamps > formatStamps = stampsFormat ( formatMapFileStamp , formatMapFileStamp , formatMapFileStamp , formatMapFileString ) ; Format < Map < File , Source > > formatMapFileSource = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , sourceFormat ( ) ) ; Format < Map < String , Source > > formatMapStringSource = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatString , sourceFormat ( ) ) ; Format < APIs > formatAPIs = apisFormat ( formatMapFileSource , formatMapStringSource ) ; Format < Set < File > > formatSetFile = DefaultProtocol$ . MODULE$ . immutableSetFormat ( formatFile ) ; Format < Set < String > > formatSetString = DefaultProtocol$ . MODULE$ . immutableSetFormat ( formatString ) ; Format < Map < File , Set < File > > > formatMapFileSetFile = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatSetFile ) ; Format < Map < File , Set < String > > > formatMapFileSetString = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatSetString ) ; Format < Map < String , Set < File > > > formatMapStringSetFile = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatString , formatSetFile ) ; Format < Relation < File , File > > formatRFF = relationFormat ( formatMapFileSetFile , formatMapFileSetFile ) ; Format < Relation < File , String > > formatRFS = relationFormat ( formatMapFileSetString , formatMapStringSetFile ) ; Format < Relations > formatRelations = relationsFormat ( formatRFF , formatRFF , formatRFF , formatRFS , formatRFS ) ; Format < Problem > formatProblem = problemFormat ( positionFormat ( ) , formatString , severityFormat ( ) ) ; Format < SourceInfo > formatSourceInfo = infoFormat ( formatProblem ) ; Format < Map < File , SourceInfo > > formatMapFileSourceInfo = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatSourceInfo ) ; Format < SourceInfos > formatSourceInfos = infosFormat ( formatMapFileSourceInfo ) ; Format < Analysis > formatAnalysis = analysisFormat ( formatStamps , formatAPIs , formatRelations , formatSourceInfos ) ; Format < CompileOptions > formatOptions = optsFormat ( formatString ) ; Format < CompileSetup > formatSetup = setupFormat ( formatFile , formatOptions , formatString , orderFormat ( ) ) ; return FileBasedStore . apply ( file , formatAnalysis , formatSetup ) ; } 
public static File cacheLocation ( File file ) { return new File ( new File ( file . getParent ( ) , " cache " ) , file . getName ( ) ) ; } 
public < A > Seq < A > emptySeq ( ) { return scala . collection . Seq$ . MODULE$ . < A > empty ( ) ; } 
public ClassLoader scalaLoader ( File libraryJar , File compilerJar ) throws Exception { File [ ] allJars = { libraryJar , compilerJar } ; return new URLClassLoader ( FileUtils . toURLs ( allJars ) , getClass ( ) . getClassLoader ( ) . getParent ( ) ) ; } 
public File compilerInterface ( String sbtVersion , File interfaceSrcJar , File xsbtiJar , sbt . ScalaInstance scalaInstance , xsbti . Logger log ) { File componentDir = new File ( SBT_INC_DIR , sbtVersion ) ; String id = COMPILER_INTERFACE_ID + " - " + scalaInstance . actualVersion ( ) + " - " + JAVA_VERSION ; File interfaceDir = new File ( componentDir , id ) ; interfaceDir . mkdirs ( ) ; File interfaceJar = new File ( interfaceDir , COMPILER_INTERFACE_ID + " .jar " ) ; if ( ! interfaceJar . exists ( ) ) { IC . compileInterfaceJar ( COMPILER_INTERFACE_ID , interfaceSrcJar , interfaceJar , xsbtiJar , scalaInstance , log ) ; } return interfaceJar ; } 
public void compile ( List < String > classpathElements , List < File > sourcesList , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = pathsToFiles ( classpathElements ) ; File [ ] classpath = fullClasspath . toArray ( new File [ fullClasspath . size ( ) ] ) ; File [ ] sources = sourcesList . toArray ( new File [ sourcesList . size ( ) ] ) ; String [ ] soptions = scalacOptions . toArray ( new String [ scalacOptions . size ( ) ] ) ; String [ ] joptions = javacOptions . toArray ( new String [ javacOptions . size ( ) ] ) ; Options options = new Options ( classpath , sources , classesDirectory , soptions , joptions ) ; Setup setup = new Setup ( classesDirectory , compilerCache ) ; Inputs inputs = new Inputs ( compilers , options , setup ) ; IC . compile ( inputs , logger ) ; } 
public File [ ] classpath ( ) { return classpath ; } 
public File classesDirectory ( ) { return classesDirectory ; } 
public String [ ] options ( ) { return scalacOptions ; } 
public String [ ] javacOptions ( ) { return javacOptions ; } 
public CompileOrder order ( ) { return CompileOrder . Mixed ; } 
public Maybe < Analysis > analysisMap ( File file ) { return SbtAnalysis . analysisMap ( file , classesDirectory ) ; } 
public DefinesClass definesClass ( File file ) { return SbtLocate . definesClass ( file ) ; } 
public GlobalsCache cache ( ) { return compilerCache ; } 
public xsbti . compile . Compilers < AnalyzingCompiler > compilers ( ) { return compilers ; } 
public xsbti . compile . Options options ( ) { return options ; } 
public xsbti . compile . Setup < Analysis > setup ( ) { return setup ; } 
public static DefinesClass definesClass ( File file ) { if ( file . isDirectory ( ) ) { return new DirectoryDefinesClass ( file ) ; 
public boolean apply ( String className ) { return entries . contains ( className ) ; } 
public boolean apply ( String className ) { return Locate . classFile ( file , className ) . isFile ( ) ; } 
public boolean apply ( String className ) { return false ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir ) throws Exception , InterruptedException { String scalaVersion = findScalaVersion ( ) . toString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; if ( incremental = = null ) incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; incremental . compile ( classpathElements , sources , outputDir , scalacOptions , new ArrayList < String > ( ) ) ; return 1 ; } 
public void compile ( List < String > classpathElements , List < File > sourcesList , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = pathsToFiles ( classpathElements ) ; File [ ] classpath = fullClasspath . toArray ( new File [ fullClasspath . size ( ) ] ) ; File [ ] sources = sourcesList . toArray ( new File [ sourcesList . size ( ) ] ) ; String [ ] soptions = scalacOptions . toArray ( new String [ scalacOptions . size ( ) ] ) ; String [ ] joptions = javacOptions . toArray ( new String [ javacOptions . size ( ) ] ) ; Options options = new Options ( classpath , sources , classesDirectory , soptions , joptions ) ; Setup setup = new Setup ( fullClasspath , classesDirectory , compilerCache ) ; Inputs inputs = new Inputs ( compilers , options , setup ) ; IC . compile ( inputs , logger ) ; } 
public Maybe < Analysis > analysisMap ( File file ) { Maybe < Analysis > analysis = analysisMap . get ( file ) ; return ( analysis = = null ) ? SbtAnalysis . JUST_EMPTY_ANALYSIS : analysis ; } 
public static synchronized Analysis get ( File cacheFile ) { Analysis analysis = null ; SoftReference < Analysis > ref = cached . get ( cacheFile ) ; if ( ref ! = null ) { analysis = ref . get ( ) ; } if ( analysis = = null ) { if ( cacheFile . exists ( ) ) { analysis = IC . readAnalysis ( cacheFile ) ; } else { analysis = EMPTY_ANALYSIS ; } cached . put ( cacheFile , new SoftReference ( analysis ) ) ; } return analysis ; } 
public static synchronized void put ( File cacheFile , Analysis analysis ) { cached . put ( cacheFile , new SoftReference ( analysis ) ) ; } 
public void compile ( List < String > classpathElements , List < File > sourcesList , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = pathsToFiles ( classpathElements ) ; File [ ] classpath = fullClasspath . toArray ( new File [ fullClasspath . size ( ) ] ) ; File [ ] sources = sourcesList . toArray ( new File [ sourcesList . size ( ) ] ) ; String [ ] soptions = scalacOptions . toArray ( new String [ scalacOptions . size ( ) ] ) ; String [ ] joptions = javacOptions . toArray ( new String [ javacOptions . size ( ) ] ) ; Options options = new Options ( classpath , sources , classesDirectory , soptions , joptions ) ; Setup setup = new Setup ( fullClasspath , classesDirectory , compilerCache ) ; Inputs inputs = new Inputs ( compilers , options , setup ) ; Analysis analysis = IC . compile ( inputs , logger ) ; SbtAnalysis . put ( SbtAnalysis . cacheLocation ( classesDirectory ) , analysis ) ; } 
public Maybe < Analysis > analysisMap ( File file ) { Maybe < Analysis > analysis = analysisCache . get ( file ) ; return ( analysis = = null ) ? SbtAnalysis . JUST_EMPTY_ANALYSIS : analysis ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { long t0 = System . currentTimeMillis ( ) ; LastCompilationInfo lastCompilationInfo = LastCompilationInfo . find ( sourceRootDirs , outputDir ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = lastCompilationInfo . getLastSuccessfullTS ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long t1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , t1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) throws Exception { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . toString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . toString ( ) . hashCode ( ) + " .timestamp " ) , outputDir ) ; } 
long getLastSuccessfullTS ( ) throws Exception { long back = - 1 ; if ( _lastCompileAtFile . exists ( ) & & _outputDir . exists ( ) & & ( _outputDir . list ( ) . length > 0 ) ) { back = _lastCompileAtFile . lastModified ( ) ; } return back ; } 
void setLastSuccessfullTS ( long v ) throws Exception { if ( ! _lastCompileAtFile . exists ( ) ) { FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
public static File fallbackCacheLocation ( File file ) { return new File ( new File ( file . getParent ( ) , " analysis " ) , file . getName ( ) ) ; } 
public void compile ( List < String > classpathElements , List < File > sourcesList , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap ) { List < File > fullClasspath = pathsToFiles ( classpathElements ) ; File [ ] classpath = fullClasspath . toArray ( new File [ fullClasspath . size ( ) ] ) ; File [ ] sources = sourcesList . toArray ( new File [ sourcesList . size ( ) ] ) ; String [ ] soptions = scalacOptions . toArray ( new String [ scalacOptions . size ( ) ] ) ; String [ ] joptions = javacOptions . toArray ( new String [ javacOptions . size ( ) ] ) ; Options options = new Options ( classpath , sources , classesDirectory , soptions , joptions ) ; cacheFile = ( cacheFile ! = null ) ? cacheFile : SbtAnalysis . fallbackCacheLocation ( classesDirectory ) ; Setup setup = new Setup ( fullClasspath , classesDirectory , cacheFile , cacheMap , compilerCache ) ; Inputs inputs = new Inputs ( compilers , options , setup ) ; Analysis analysis = IC . compile ( inputs , logger ) ; SbtAnalysis . put ( cacheFile , analysis ) ; } 
protected File getAnalysisCacheFile ( ) throws Exception { return analysisCacheFile . getAbsoluteFile ( ) ; } 
protected int compile ( File sourceDir , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { getLog().warn("Using older form of compile"); return compile(Arrays.asList(sourceDir), outputDir, analysisCacheFile, classpathElements, compileInLoop); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( INCREMENTAL . equals ( recompileMode ) ) { return incrementalCompile ( getClasspathElements ( ) , getSourceDirectories ( ) , outputDir , analysisCacheFile ) ; } long t0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long t1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , t1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile ) throws Exception , InterruptedException { String scalaVersion = findScalaVersion ( ) . toString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; if ( incremental = = null ) incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; incremental . compile ( classpathElements , sources , outputDir , scalacOptions , new ArrayList < String > ( ) , cacheFile , cacheMap ) ; return 1 ; } 
protected File defaultAnalysisDirectory ( MavenProject project ) { return new File ( project . getBuild ( ) . getDirectory ( ) , " analysis " ) ; } 
protected File defaultAnalysisCacheFile ( MavenProject project ) { return new File ( defaultAnalysisDirectory ( project ) , " compile " ) ; } 
protected File defaultTestAnalysisCacheFile ( MavenProject project ) { return new File ( defaultAnalysisDirectory ( project ) , " test-compile " ) ; } 
protected File getAnalysisCacheFile ( ) throws Exception { throw new UnsupportedOperationException ( " USELESS " ) ; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = FileUtils . fileOf ( mainSourceDir , useCanonicalPath ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } testSourceDir = FileUtils . fileOf ( testSourceDir , useCanonicalPath ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected File getAnalysisCacheFile ( ) throws Exception { return testAnalysisCacheFile . getAbsoluteFile ( ) ; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < String > ( sources ) ; clone the list to keep the original unmodified sources.add(scalaSourceDir); } return normalize(sources); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile ) throws Exception , InterruptedException { if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . toString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; } List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap ) ; return 1 ; } 
protected List < String > getJavacOptions ( ) throws Exception { List < String > options = new ArrayList < String > ( ) ; if ( javacArgs ! = null ) Collections . addAll ( options , javacArgs ) ; if ( StringUtils . isNotEmpty ( addJavacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addJavacArgs , " | " ) ) ; } return options ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( INCREMENTAL . equals ( recompileMode ) ) { return incrementalCompile ( classpathElements , sourceRootDirs , outputDir , analysisCacheFile , compileInLoop ) ; } long t0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long t1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , t1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , Boolean compileInLoop ) throws Exception , InterruptedException { if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . toString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; } List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = FileUtils . fileOf ( mainSourceDir , useCanonicalPath ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } testSourceDir = FileUtils . fileOf ( testSourceDir , useCanonicalPath ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & ! INCREMENTAL . equals ( recompileMode ) ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < String > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } List < String > testSources = new ArrayList < String > ( project . getTestCompileSourceRoots ( ) ) ; testSources . add ( FileUtils . pathOf ( testSourceDir , useCanonicalPath ) ) ; List < File > testSourceDirs = normalize ( testSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & ! INCREMENTAL . equals ( recompileMode ) ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception , InterruptedException { if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . toString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; } List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { long t0 = System . currentTimeMillis ( ) ; LastCompilationInfo lastCompilationInfo = LastCompilationInfo . find ( sourceRootDirs , outputDir ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = lastCompilationInfo . getLastSuccessfullTS ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } long t1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , t1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
public void compile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) throws Exception { if ( useServer ) { zincCompile ( baseDir , classpathElements , sources , classesDirectory , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) throws Exception { List < String > arguments = new ArrayList < String > ( ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . toMultiPath ( extraPaths ) ) ; arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . toMultiPath ( classpathElements ) ) ; arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -J " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
private List < File > pathsToFiles ( List < String > paths ) { List < File > files = new ArrayList < File > ( paths . size ( ) ) ; for ( String path : paths ) { files . add ( new File ( path ) ) ; } return files ; } 
private String logLevelToString ( Log log ) { if ( log . isDebugEnabled ( ) ) return " debug " ; else if ( log . isInfoEnabled ( ) ) return " info " ; 
private String cacheMapToString ( Map < File , File > cacheMap ) throws Exception { String analysisMap = " " ; boolean addComma = false ; for ( Map . Entry < File , File > entry : cacheMap . entrySet ( ) ) { if ( addComma ) analysisMap + = " , " ; analysisMap + = entry . getKey ( ) . getAbsolutePath ( ) ; analysisMap + = " : " ; analysisMap + = entry . getValue ( ) . getAbsolutePath ( ) ; addComma = true ; } return analysisMap ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . toString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( useZincServer , zincPort , scalaVersion , libraryJar , compilerJar , extraJars , sbtVersion , xsbtiJar , interfaceSrcJar , getLog ( ) ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
protected Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) throws Exception { Set < Artifact > result = new HashSet < Artifact > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , " pom " ) ; MavenProject project = mavenProjectBuilder . buildFromRepository ( pom , remoteRepos , localRepo ) ; Set < Artifact > dependencies = resolveDependencyArtifacts ( project ) ; result . addAll ( dependencies ) ; for ( Artifact dependency : dependencies ) { Set < Artifact > transitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( transitive ) ; } return result ; } 
private String logLevelToString ( Log l ) { if ( l . isDebugEnabled ( ) ) return " debug " ; else if ( l . isInfoEnabled ( ) ) return " info " ; 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this dupliated here? if (!outputDir.exists()) { outputDir.mkdirs(); } return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected File defaultAnalysisDirectory ( MavenProject p ) { return new File ( p . getBuild ( ) . getDirectory ( ) , " analysis " ) ; } 
protected File defaultAnalysisCacheFile ( MavenProject p ) { return new File ( defaultAnalysisDirectory ( p ) , " compile " ) ; } 
protected File defaultTestAnalysisCacheFile ( MavenProject p ) { return new File ( defaultAnalysisDirectory ( p ) , " test-compile " ) ; } 
private void toJson ( Object pojo , boolean prettyPrint , File f ) throws Exception { ObjectMapper m = new ObjectMapper ( ) ; JsonFactory jf = new JsonFactory ( ) ; JsonGenerator jg = jf . createJsonGenerator ( f , JsonEncoding . UTF8 ) ; try { if ( prettyPrint ) { 
protected List < List < String > > makeDependencies ( ScalaGenJsonMojo data ) throws Exception { List < List < String > > back = new ArrayList < List < String > > ( ) ; List < Artifact > deps = data . project . getCompileArtifacts ( ) ; for ( Artifact dep : deps ) { List < String > e = new ArrayList < String > ( 3 ) ; e . add ( dep . getFile ( ) . getCanonicalPath ( ) ) ; e . add ( dep . getArtifactId ( ) + " / " + dep . getVersion ( ) ) ; back . add ( e ) ; } return back ; } 
protected List < String > makeArtifacts ( ScalaGenJsonMojo data ) throws Exception { List < String > back = new ArrayList < String > ( ) ; List < MavenProject > modules = data . project . getCollectedProjects ( ) ; for ( MavenProject module : modules ) { back . add ( module . getArtifactId ( ) + " / " + module . getVersion ( ) ) ; } return back ; } 
protected Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) throws Exception { Set < Artifact > result = new HashSet < Artifact > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , " pom " ) ; MavenProject p = mavenProjectBuilder . buildFromRepository ( pom , remoteRepos , localRepo ) ; Set < Artifact > d = resolveDependencyArtifacts ( p ) ; result . addAll ( d ) ; for ( Artifact dependency : d ) { Set < Artifact > transitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( transitive ) ; } return result ; } 
protected File getPluginArtifactJar ( String groupId , String artifactId , String version ) throws Exception { return getPluginArtifactJar ( groupId , artifactId , version , null ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { Plugin me = project . getBuild ( ) . getPluginsAsMap ( ) . get ( " net.alchim31.maven:scala-maven-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( me . getDependencies ( ) ) ; return back ; } 
public void addJvmArgs ( String . . . args1 ) { if ( args1 ! = null ) { for ( String arg : args1 ) { 
public void addArgs ( String . . . args1 ) { if ( args1 ! = null ) { for ( String arg : args1 ) { 
private void tryDeleteArgFile ( List < String > cmd ) throws Exception { tString last = cmd . get ( cmd . size ( ) - 1 ) ; if ( last . endsWith ( MainHelper . argFileSuffix ) ) { tFile f = new File ( last ) ; 
public static File createArgFile ( List < String > args ) throws IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); final PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile))); try { for(String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } finally { out.close(); } return argFile; } 
private String cacheMapToString ( Map < File , File > cacheMap ) throws Exception { String analysisMap = " " ; boolean addComma = false ; for ( Map . Entry < File , File > entry : cacheMap . entrySet ( ) ) { if ( addComma ) analysisMap + = " , " ; analysisMap + = entry . getKey ( ) . getAbsolutePath ( ) ; analysisMap + = " ; " ; analysisMap + = entry . getValue ( ) . getAbsolutePath ( ) ; addComma = true ; } return analysisMap ; } 
private String cacheMapToString ( Map < File , File > cacheMap ) throws Exception { String analysisMap = " " ; boolean addArgSeparator = false ; for ( Map . Entry < File , File > entry : cacheMap . entrySet ( ) ) { if ( addArgSeparator ) analysisMap + = ANALYSIS_MAP_ARG_SEPARATOR ; analysisMap + = entry . getKey ( ) . getAbsolutePath ( ) ; analysisMap + = ANALYSIS_MAP_PAIR_SEPARATOR ; analysisMap + = entry . getValue ( ) . getAbsolutePath ( ) ; addArgSeparator = true ; } return analysisMap ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . toString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; tincremental = new SbtIncrementalCompiler ( useZincServer , zincPort , scalaVersion , libraryJar , compilerJar , extraJars , sbtVersion , xsbtiJar , interfaceSrcJar , getLog ( ) ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
private boolean hasMavenProjectDependency ( Set < String > classpath ) throws MalformedURLException { try { List < URL > urls = new ArrayList < URL > ( ) ; 
private void configureClasspath ( Set < String > classpath ) throws Exception , DependencyResolutionRequiredException { Collection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : toInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , true ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > toRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( toRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); String sv = findScalaVersion().toString(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
public Collection < Dependency > elements ( MavenProject project ) throws DependencyResolutionRequiredException { return project . getCompileDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProject project ) throws DependencyResolutionRequiredException { return project . getRuntimeDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProject project ) throws DependencyResolutionRequiredException { return project . getTestDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProject project ) throws DependencyResolutionRequiredException { return project . getSystemDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProject project ) throws DependencyResolutionRequiredException { Plugin me = project . getBuild ( ) . getPluginsAsMap ( ) . get ( " net.alchim31.maven:scala-maven-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( me . getDependencies ( ) ) ; return back ; } 
public abstract Collection < Dependency > elements ( MavenProject project ) throws DependencyResolutionRequiredException ; public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . trim ( ) . equalsIgnoreCase ( name . trim ( ) ) ) { return scope ; } } return null ; } } } 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = Scopes . PLUGIN . name ( ) ; } } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = true;hasMavenProjectDependency(loader); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
public void testClassworldSeftFirstStrategy ( ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
protected List < String > getJavacOptions ( ) throws Exception { List < String > options = new ArrayList < String > ( ) ; if ( javacArgs ! = null ) Collections . addAll ( options , javacArgs ) ; if ( StringUtils . isNotEmpty ( addJavacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addJavacArgs , " | " ) ) ; } issue #116 if (javacGenerateDebugSymbols) { options.add("-g"); } return options; } 
private String getBootClasspath ( ) throws Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) , classpath ) ; addToClasspath(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString(), classpath); return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
protected List < String > getJavacOptions ( ) throws Exception { List < String > options = new ArrayList < String > ( ) ; if ( javacArgs ! = null ) Collections . addAll ( options , javacArgs ) ; if ( StringUtils . isNotEmpty ( addJavacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addJavacArgs , " | " ) ) ; } issue #116 if (javacGenerateDebugSymbols) { options.add("-g"); } if (target != null) { options.add("-target"); options.add(target); } if (source != null) { options.add("-source"); options.add(source); } if (encoding != null) { options.add("-encoding"); options.add(encoding); } return options; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < String > ( ) ; String sv = findScalaVersion ( ) . toString ( ) ; addCompilerToClasspath ( sv , ignoreClasspath ) ; addLibraryToClasspath ( sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", scalaVersion.toString(), classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected void addLibraryToClasspath ( Set < String > classpath ) throws Exception { classpath . add ( FileUtils . pathOf ( getLibraryJar ( ) , useCanonicalPath ) ) ; } 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addCompilerToClasspath ( classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
private String getBootClasspath ( ) throws Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addLibraryToClasspath ( classpath ) ; return MainHelper . toMultiPath ( classpath . toArray ( new String [ classpath . size ( ) ] ) ) ; } 
protected File getLibraryJar ( ) throws Exception { if ( ! StringUtils . isEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-library.jar " ) ; } return getArtifactJar ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getCompilerJar ( ) throws Exception { if ( ! StringUtils . isEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-compiler.jar " ) ; } return getArtifactJar ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < String > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
private void configureClasspath ( Set < String > classpath ) throws Exception , DependencyResolutionRequiredException { Collection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : toInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , true ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > toRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( toRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; tincremental = new SbtIncrementalCompiler ( useZincServer , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
public boolean include ( Artifact artifact ) { SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public boolean accept ( DependencyNode node ) { treturn include ( node . getArtifact ( ) ) ; } 
public SpawnMonitor spawn ( boolean displayCmd ) throws Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < String > ( ) ; String cmdStr = StringUtils . join ( cmd . iterator ( ) , " " ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . add ( cmdStr ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . add ( cmdStr ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return new SpawnMonitor(){ @Override 
public void addJvmArgs ( String . . . args0 ) { TODO - Ignore classpath if (args0 != null) { for (String arg : args0) { 
public SpawnMonitor spawn ( final boolean displayCmd ) throws Exception { final Thread = new Thread ( ) { @Override public void run ( ) { try { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } } }; t.start(); return new SpawnMonitor() { @Override 
public void addJvmArgs ( String . . . args0 ) { if ( args0 ! = null ) { for ( String arg : args0 ) { 
protected Set < Artifact > resolveDependencyArtifacts ( MavenProject theProject ) throws Exception { AndArtifactFilter filter = new AndArtifactFilter(); filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST)); filter.add(new ArtifactFilter(){ public boolean include(Artifact artifact) { return !artifact.isOptional(); } }); TODO follow the dependenciesManagement and override rules Set<Artifact> artifacts = theProject.createArtifacts(factory, Artifact.SCOPE_RUNTIME, filter); for (Artifact artifact : artifacts) { resolver.resolve(artifact, remoteRepos, localRepo); } return artifacts; return theProject.getArtifacts(); } 
public void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) throws Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( " jar " ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
private void configureClasspath ( Set < String > classpath ) throws Exception , DependencyResolutionRequiredException { Collection < Dependency > toInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . toUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : toInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency ) , classpath , true ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > toRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . trim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . trim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( toRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected Set < Artifact > resolveDependencyArtifacts ( MavenProject theProject ) throws Exception { AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( new ArtifactFilter ( ) { public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } } ) ; TODO follow the dependenciesManagement and override rules Set<Artifact> artifacts = theProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, filter); for (Artifact artifact : artifacts) { resolver.resolve(artifact, remoteRepos, localRepo); } return artifacts; } 
protected void checkScalaVersion ( ) throws Exception { String sv = findScalaVersion ( ) . toString ( ) ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { getLog ( ) . warn ( String . format ( " local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s " , scalaHome , sv ) ) ; } if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( sv ) ; 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) throws Exception { List < String > arguments = new ArrayList < String > ( ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . toMultiPath ( extraPaths ) ) ; arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . toMultiPath ( classpathElements ) ) ; arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -C " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); } else { cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null); } HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); } return cmd; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if(fork) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<String>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
protected File getLibraryJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-library.jar " ) ; } return getArtifactJar ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getCompilerJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-compiler.jar " ) ; } return getArtifactJar ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
public boolean isZero ( ) { return ( major = = 0 ) & & ( minor = = 0 ) & & ( bugfix = = 0 ) ; } 
public void addToClasspath ( File entry ) throws Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean found = false ; boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; if ( isClasspath ) { item = item + File . pathSeparator + entry . getCanonicalPath ( ) ; jvmArgs . set ( i , item ) ; isClasspath = false ; found = true ; break ; } isClasspath = " -classpath " . equals ( item ) ; } if ( ! found ) { addJvmArgs ( " -classpath " , entry . getCanonicalPath ( ) ) ; 
protected List < File > findSourceWithFilters ( List < File > sourceRootDirs ) throws Exception { List < File > sourceFiles = new ArrayList < File > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensitive to scala file order, file system can't guarantee file order => unreproducible build error across platforms sort files by path (OS dependent) to guarantee reproducible command line. Collections.sort(sourceFiles); return sourceFiles; } 
public SpawnMonitor spawn ( boolean displayCmd ) throws Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < String > ( ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . addAll ( cmd ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . addAll ( cmd ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return new SpawnMonitor(){ @Override 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) throws Exception { List < String > arguments = new ArrayList < String > ( extraArgs ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . toMultiPath ( extraPaths ) ) ; arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . toMultiPath ( classpathElements ) ) ; arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -C " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < String > ( ) : ( List < String > ) Arrays . asList ( addZincArgs . split ( " \\ | " ) ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; tincremental = new SbtIncrementalCompiler ( useZincServer , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) , zincArgs ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = true;hasMavenProjectDependency(loader); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this dupliated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if(failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
private void checkArtifactForScalaVersion ( VersionNumber requiredScalaVersion , DependencyNode rootNode ) throws Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
public String toString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . toString ( ) ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( major < o . major ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( minor > o . minor ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( minor < o . minor ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( bugfix > o . bugfix ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( bugfix < o . bugfix ) ) { back = - 1 ; } return back ; } 
public boolean isZero ( ) { return ( major = = 0 ) & & ( minor = = 0 ) & & ( bugfix = = 0 ) ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( major < o . major ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( minor > - 1 ) & & ( minor > o . minor ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( minor > - 1 ) & & ( minor < o . minor ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( bugfix > - 1 ) & & ( bugfix > o . bugfix ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( bugfix > - 1 ) & & ( bugfix < o . bugfix ) ) { back = - 1 ; } return back ; } 
public void testCompare ( ) throws Exception { assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; } 
public void testParse ( ) throws Exception { assertParseVN ( " 2.7.1 " , 2 , 7 , 1 , null ) ; assertParseVN ( " 2.7 " , 2 , 7 , 0 , null ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.RC " , 2 , 7 , 0 , " .RC " ) ; assertParseVN ( " 2.7-RC " , 2 , 7 , 0 , " -RC " ) ; assertParseVN ( " 2.7.1-SNAPSHOT " , 2 , 7 , 1 , " -SNAPSHOT " ) ; } 
private void assertParseVN ( String str , int major , int minor , int bugfix , String modifier ) { VersionNumber v = new VersionNumber ( str ) ; assertEquals ( " test major of " + str , major , v . major ) ; assertEquals ( " test minor of " + str , minor , v . minor ) ; assertEquals ( " test bugfix of " + str , bugfix , v . bugfix ) ; assertEquals ( " est modifier of " + str , modifier , v . modifier ) ; } 
public void testCompareMask ( ) throws Exception { assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7-rc " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.0 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.2-rc1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; } 
private String findScalaVersionFromDependencies ( ) throws Exception { return findVersionFromDependencies ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID ) ; } 
private void checkArtifactForScalaVersion ( VersionNumber requiredScalaVersion , DependencyNode rootNode ) throws Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) , getScalaOrganization ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < ArtifactFilter > filters = new ArrayList < ArtifactFilter > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( getScalaOrganization ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
protected File getLibraryJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-library.jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getCompilerJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-compiler.jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
public boolean isScalaDistroArtifact ( Artifact artifact ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
public boolean include ( Artifact artifact ) { SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) throws Exception { List < String > arguments = new ArrayList < String > ( extraArgs ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . toMultiPath ( extraPaths ) ) ; if ( ! classpathElements . isEmpty ( ) ) { arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . toMultiPath ( classpathElements ) ) ; } arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -C " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
protected List < String > getClasspathElements ( ) throws Exception { List < String > back = project . getCompileClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); back = TychoUtilities.addOsgiClasspathElements(project, back); return back; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this dupliated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<String>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { if (!paths.isEmpty())jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
private void compileScript ( File scriptDir , File destFile , Set < String > classpath ) throws Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; if ( ! classpath . isEmpty ( ) ) jcmd . addArgs ( " -classpath " , MainHelper . toMultiPath ( new ArrayList < String > ( classpath ) ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
protected List < String > getClasspathElements ( ) throws Exception { List < String > back = project . getTestClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); return back; } 
public static void main ( String [ ] args ) { System . out . println ( " Hello world " ) ; } 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private void compileScript ( File scriptDir , File destFile , URLClassLoader loader ) throws Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toClasspathString ( loader ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); if (new VersionNumber("2.11.0").compareTo(scalaVersion) <= 0) { addToClasspath("jline", "jline", scalaVersion.toString(), classpath); } else if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", scalaVersion.toString(), classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); if (new VersionNumber("2.11.0").compareTo(scalaVersion) <= 0) { String version = scalaVersion.major + "." + scalaVersion.minor; addToClasspath("jline", "jline", version, classpath); } else if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", scalaVersion.toString(), classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
private IncOptions defaultOptions ( ) { sbt . inc . IncOptions defaultSbtOptions = sbt . inc . IncOptions . Default ( ) ; return new IncOptions ( defaultSbtOptions . transitiveStep ( ) , 
protected void doExecute ( ) throws Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); if (new VersionNumber("2.11.0").compareTo(scalaVersion) <= 0) { addToClasspath("jline", "jline", "2.12", classpath); } else if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", scalaVersion.toString(), classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader , String baseName ) throws Exception { Class < ? > compiledScript = loader . loadClass ( baseName ) ; ClassLoader currentCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; try { try { 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) throws IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream ) ; BufferedReader reader = null ; try { if ( scriptFile ! = null ) { 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) throws IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream , false , encoding ) ; BufferedReader reader = null ; try { if ( scriptFile ! = null ) { 
public void testJdkSplit ( ) throws Exception { assertEquals ( " Are you using JDK > 7? This failure is expected above JDK 7. " , 6 , " hello " . split ( " | " ) . length ) ; assertEquals ( 1 , " hello " . split ( " \\ | " ) . length ) ; assertEquals ( 2 , " hel|lo " . split ( " \\ | " ) . length ) ; assertEquals ( 3 , " hel||lo " . split ( " \\ | " ) . length ) ; } 
public static String fromToolchain ( Toolchain toolchain ) { String _javaExec = null ; if ( toolchain ! = null ) _javaExec = toolchain . findTool ( " java " ) ; if ( toolchain = = null | | _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; if ( _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { throw new IllegalStateException ( " Couldn't locate java, try setting JAVA_HOME environment variable. " ) ; } } _javaExec + = File . separator + " bin " + File . separator + " java " ; } return _javaExec ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { String _javaExec = null ; if ( toolchain ! = null ) _javaExec = toolchain . findTool ( " java " ) ; if ( toolchain = = null | | _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; if ( _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { throw new IllegalStateException ( " Couldn't locate java, try setting JAVA_HOME environment variable. " ) ; } } _javaExec + = File . separator + " bin " + File . separator + " java " ; } return _javaExec ; } 
public void compile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder , Toolchain toolchain ) throws Exception { if ( useServer ) { zincCompile ( baseDir , classpathElements , sources , classesDirectory , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder , toolchain ) ; 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder , Toolchain toolchain ) throws Exception { List < String > arguments = new ArrayList < String > ( extraArgs ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . toMultiPath ( extraPaths ) ) ; if ( ! classpathElements . isEmpty ( ) ) { arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . toMultiPath ( classpathElements ) ) ; } arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } String javaHome = JavaLocator . findHomeFromToolchain ( toolchain ) ; if ( javaHome ! = null ) { log . info ( " Toolchain in scala-maven-plugin: " + javaHome ) ; arguments . add ( " -java-home " ) ; arguments . add ( javaHome ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -C " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < String > ( ) : ( List < String > ) Arrays . asList ( addZincArgs . split ( " \\ | " ) ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; tincremental = new SbtIncrementalCompiler ( useZincServer , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) , zincArgs ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder , toolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
public static String findHomeFromToolchain ( Toolchain toolchain ) { String executable = findExecutableFromToolchain ( toolchain ) ; if ( executable ! = null ) { File executableParent = new File ( executable ) . getParentFile ( ) ; 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) throws Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if(fork) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
public void testClassworldSeftFirstStrategy ( ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
protected void doExecute ( ) throws Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private void handleJavaRebel ( final JavaMainCaller jcmd ) throws IOException { if ( this . javaRebelPath ! = null ) { final String canonicalJavaRebelPath = this . javaRebelPath . getCanonicalPath ( ) ; 
private Set < String > setupClassPathForConsole ( final VersionNumber scalaVersion ) throws Exception { final Set < String > classpath = new HashSet < String > ( ) ; classpath . addAll ( this . setupProjectClasspaths ( ) ) ; classpath . addAll ( this . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < String > setupProjectClasspaths ( ) throws Exception { final Set < String > classpath = new HashSet < String > ( ) ; super . addCompilerToClasspath ( classpath ) ; super . addLibraryToClasspath ( classpath ) ; if ( this . useTestClasspath ) { classpath . addAll ( super . project . getTestClasspathElements ( ) ) ; } if ( this . useRuntimeClasspath ) { classpath . addAll ( super . project . getRuntimeClasspathElements ( ) ) ; } return classpath ; } 
private Set < String > setupConsoleClasspaths ( final VersionNumber scalaVersion ) throws Exception { final Set < String > classpath = new HashSet < String > ( ) ; super . addToClasspath ( this . resolveJLine ( scalaVersion , this . fallbackJLine ( scalaVersion ) ) , classpath , true ) ; return classpath ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) throws Exception { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . toString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { super . getLog ( ) . warn ( a . toString ( ) ) ; if ( this . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; if ( artifactId . equals ( ScalaConsoleMojo . JLINE ) & & ( groupId . equals ( ScalaConsoleMojo . JLINE ) | | 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scala2_12_0M4.compareTo(scalaVersion) <= 0) { return super.factory.createArtifact(ScalaConsoleMojo.JLINE, ScalaConsoleMojo.JLINE, "2.14.1", "", ScalaMojoSupport.JAR); 
protected final Artifact scalaCompilerArtifact ( final String scalaVersion ) { return this . factory . createArtifact ( this . getScalaOrganization ( ) , ScalaMojoSupport . SCALA_COMPILER_ARTIFACTID , 
protected final Set < Artifact > resolveArtifactDependencies ( final Artifact artifact ) throws Exception { final AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( new ArtifactFilter ( ) { public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } } ) ; Use the collection filter as the resolution filter. return resolveDependencyArtifacts(artifact, filter, 
public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } 
protected final Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter ) throws Exception { return this . resolveDependencyArtifacts ( artifact , collectionFilter , 
protected final Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) throws Exception { final ArtifactResolutionRequest arr = this . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return this.resolver.resolve(arr).getArtifacts(); } 
private ArtifactResolutionRequest createArtifactResolutionRequest ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = new ArtifactResolutionRequest ( ) ; arr . setArtifact ( artifact ) ; arr . setCollectionFilter ( collectionFilter ) ; arr . setResolutionFilter ( resolutionFilter ) ; arr . setResolveRoot ( false ) ; arr . setResolveTransitively ( true ) ; arr . setRemoteRepositories ( remoteRepositories ) ; arr . setLocalRepository ( localRepository ) ; return arr ; } 
public void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) throws Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) , classpath , addDependencies ) ; } 
public void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) throws Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( ScalaMojoSupport . JAR ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { return this . getScalaCommand ( this . fork , this . scalaClassName ) ; 
protected final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) throws Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected final JavaMainCaller getEmptyScalaCommand ( final String mainClass ) throws Exception { return this . getEmptyScalaCommand ( mainClass , this . fork ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) throws Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != this.fork) { super.getLog().info("Fork behavior overridden"); super.getLog().info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if(forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
protected File getArtifactJar ( String groupId , String artifactId , String version ) throws Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected File getArtifactJar ( String groupId , String artifactId , String version , String classifier ) throws Exception { Artifact artifact = factory . createArtifactWithClassifier ( groupId , artifactId , version , ScalaMojoSupport . JAR , classifier ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) throws Exception { Set < Artifact > result = new HashSet < Artifact > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , ScalaMojoSupport . POM ) ; Set < Artifact > d = resolveArtifactDependencies ( pom ) ; result . addAll ( d ) ; for ( Artifact dependency : d ) { Set < Artifact > transitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( transitive ) ; } return result ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < String > ( ) : ( List < String > ) Arrays . asList ( StringUtils . split ( addZincArgs , " | " ) ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; tincremental = new SbtIncrementalCompiler ( useZincServer , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) , zincArgs ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder , toolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) throws Exception { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . toString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( this . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
public void jdkSplit ( ) throws Exception { LevelState previous = new LevelState ( ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala:-1: info: compiling " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514 " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Recompiling 1 files " , previous , Level . INFO , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " two errors found " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " BUILD ERROR " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " wrap: org.apache.commons.exec.ExecuteException: Process exited with an error: 1(Exit value: 1) " , previous , Level . ERROR , null ) ; } 
public void stringUtilsSplit ( ) throws Exception { assertEquals ( 1 , StringUtils . split ( " hello " , " | " ) . length ) ; assertEquals ( 1 , StringUtils . split ( " hello| " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel|lo " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel||lo " , " | " ) . length ) ; } 
public void classworldSeftFirstStrategy ( ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
public void compare ( ) throws Exception { assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; } 
public void parse ( ) throws Exception { assertParseVN ( " 2.7.1 " , 2 , 7 , 1 , null ) ; assertParseVN ( " 2.7 " , 2 , 7 , 0 , null ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.RC " , 2 , 7 , 0 , " .RC " ) ; assertParseVN ( " 2.7-RC " , 2 , 7 , 0 , " -RC " ) ; assertParseVN ( " 2.7.1-SNAPSHOT " , 2 , 7 , 1 , " -SNAPSHOT " ) ; } 
public void compareMask ( ) throws Exception { assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7-rc " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.0 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.2-rc1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; } 
private void assertParseVN ( String str , int major , int minor , int bugfix , String modifier ) { VersionNumber v = new VersionNumber ( str ) ; assertEquals ( " test major of " + str , major , v . major ) ; assertEquals ( " test minor of " + str , minor , v . minor ) ; assertEquals ( " test bugfix of " + str , bugfix , v . bugfix ) ; assertEquals ( " est modifier of " + str , modifier , v . modifier ) ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { String _javaExec = null ; if ( toolchain ! = null ) { _javaExec = toolchain . findTool ( " java " ) ; } if ( toolchain = = null | | _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; if ( _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { throw new IllegalStateException ( " Couldn't locate java, try setting JAVA_HOME environment variable. " ) ; } } _javaExec + = File . separator + " bin " + File . separator + " java " ; } return _javaExec ; } 
public static String findHomeFromToolchain ( Toolchain toolchain ) { String executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParent ( ) ; } 
public void shouldReturnNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain toolchain = new NullReturningToolChain ( ) ; System . setProperty ( " java.home " , " test " ) ; assertEquals ( " test/bin/java " , JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) throws Exception { Toolchain toolchain = new ReturningToolChain ( ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
public void shouldThrowExceptionWhenNothingCouldBeFound ( ) { Toolchain toolchain = new NullReturningToolChain ( ) ; System . clearProperty ( " java.home " ) ; environmentVariables . set ( " JAVA_HOME " , null ) ; try { JavaLocator . findExecutableFromToolchain ( toolchain ) ; 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) throws Exception { String home = JavaLocator . findHomeFromToolchain ( new TestStringReturningToolChain ( ) ) ; assertEquals ( " parent " , home ) ; } 
public void shouldReturnWhenFileIsNotPresent ( ) throws Exception { String home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( ) ) ; assertNull ( home ) ; } 
public String findTool ( String s ) { return null ; } 
public String findTool ( String s ) { return " parent/child/my-path-to-java " ; } 
public String findTool ( String s ) { return " my-path-to-java " ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { String _javaExec = null ; if ( toolchain ! = null ) { _javaExec = toolchain . findTool ( " java " ) ; } if ( toolchain = = null | | _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; Points to JRE home if (_javaExec == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } } _javaExec += File.separator + "bin" + File.separator + "java"; } return _javaExec; } 
public void shouldReturnNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain toolchain = new NullReturningToolChain ( ) ; environmentVariables . set ( " JAVA_HOME " , " test " ) ; assertEquals ( " test/bin/java " , JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) throws Exception { String home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( ) ) ; assertNull ( home ) ; } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if(failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(project.getProjectBuildingRequest(), null)); } 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < DependencyNodeFilter > filters = new ArrayList < DependencyNodeFilter > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( getScalaOrganization ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if(failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = project.getProjectBuildingRequest(); request.setProject(project); checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(request, null)); } 
private static void downloadFileFromURL ( String urlString , File destination ) throws Exception { URL website = new URL ( urlString ) ; ReadableByteChannel rbc ; rbc = Channels . newChannel ( website . openStream ( ) ) ; FileOutputStream fos = new FileOutputStream ( destination ) ; fos . getChannel ( ) . transferFrom ( rbc , 0 , Long . MAX_VALUE ) ; fos . close ( ) ; rbc . close ( ) ; } 
protected void doExecute ( ) throws Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
public void doExecute ( ) throws Exception { if ( skip ) { getLog ( ) . info ( " Skipping javadoc generation " ) ; return ; } try { generate ( null , Locale . getDefault ( ) ) ; 
protected void failOnError ( String prefix , Exception e ) throws MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } throw new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < String > ( ) : ( List < String > ) Arrays . asList ( StringUtils . split ( addZincArgs , " | " ) ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; tincremental = new SbtIncrementalCompiler ( useZincServer , zincHost , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) , zincArgs ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; try { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder , toolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<String>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { if (!paths.isEmpty())jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
protected List < String > getClasspathElements ( ) throws Exception { List < String > back = project . getCompileClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); if (addToClasspath != null) { back.addAll(Arrays.asList(StringUtils.split(addToClasspath,","))); } back.addAll(TychoUtilities.addOsgiClasspathElements(project, back)); return back; } 
public Optional < CompileAnalysis > analysis ( File classpathEntry ) { return Optional . empty ( ) ; } 
public DefinesClass definesClass ( File classpathEntry ) { return Locate . definesClass ( classpathEntry ) ; } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , String compileOrder ) { Inputs inputs = compiler . inputs ( classpathElements . stream ( ) . map ( File : : new ) . toArray ( size - > new File [ size ] ) , classpath sources.toArray(new File[]{}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[]{}), scalacOptions javacOptions.toArray(new String[]{}), javacOptions 100, maxErrors new Function[]{}, sourcePositionMappers toCompileOrder(compileOrder), order compilers, setup, compiler.emptyPreviousResult() ); Optional<AnalysisContents> analysisContents = analysisStore.get(); if (analysisContents.isPresent()) { AnalysisContents analysisContents0 = analysisContents.get(); CompileAnalysis previousAnalysis = analysisContents0.getAnalysis(); MiniSetup previousSetup = analysisContents0.getMiniSetup(); PreviousResult previousResult = PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup)); inputs = inputs.withPreviousResult(previousResult); } CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
private CompileOrder toCompileOrder ( String name ) { if ( name . equalsIgnoreCase ( CompileOrder . Mixed . name ( ) ) ) { return CompileOrder . Mixed ; 
public void trace ( Function0 < Throwable > ) { if ( log . isDebugEnabled ( ) ) { log . debug ( . apply ( ) ) ; 
public void success ( Function0 < String > message ) { if ( log . isInfoEnabled ( ) ) { log . info ( " Success: " + message . apply ( ) ) ; 
public void log ( Enumeration . Value level , Function0 < String > message ) { if ( level . equals ( Level . Error ( ) ) ) { log . error ( message . apply ( ) ) ; 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < > ( ) : Arrays . asList ( StringUtils . split ( addZincArgs , " | " ) ) ; tincremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , zincArgs , cacheFile ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; try { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
protected File getLibraryJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_LIBRARY_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getReflectJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_REFLECT_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_REFLECT_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getCompilerJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_COMPILER_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getCompilerBridgeJar ( ) throws Exception { VersionNumber scalaVersion = findScalaVersion ( ) ; String zincVersion = findVersionFromPluginArtifacts ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . ZINC_ARTIFACT_ID ) ) ; return getArtifactJar ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . COMPILER_BRIDGE_ARTIFACT_ID ) , zincVersion ) ; } 
public String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + major + '.' + minor ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { lgtm [java/constant-comparison] back = 1; } if ((back == 0) && (major < o.major)) { back = -1; } if ((back == 0) && (minor > o.minor)) { back = 1; } if ((back == 0) && (minor < o.minor)) { back = -1; } if ((back == 0) && (bugfix > o.bugfix)) { back = 1; } if ((back == 0) && (bugfix < o.bugfix)) { back = -1; } return back; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { lgtm [java/constant-comparison] back = 1; } if ((back == 0) && (major < o.major)) { back = -1; } if ((back == 0) && (minor > -1) && (minor > o.minor)) { back = 1; } if ((back == 0) && (minor > -1) && (minor < o.minor)) { back = -1; } if ((back == 0) && (bugfix > -1) && (bugfix > o.bugfix)) { back = 1; } if ((back == 0) && (bugfix > -1) && (bugfix < o.bugfix)) { back = -1; } return back; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; tincremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , cacheFile ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; try { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { Inputs inputs = compiler . inputs ( classpathElements . stream ( ) . map ( File : : new ) . toArray ( size - > new File [ size ] ) , classpath sources.toArray(new File[]{}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[]{}), scalacOptions javacOptions.toArray(new String[]{}), javacOptions 100, maxErrors new Function[]{}, sourcePositionMappers compileOrder, order compilers, setup, compiler.emptyPreviousResult() ); Optional<AnalysisContents> analysisContents = analysisStore.get(); if (analysisContents.isPresent()) { AnalysisContents analysisContents0 = analysisContents.get(); CompileAnalysis previousAnalysis = analysisContents0.getAnalysis(); MiniSetup previousSetup = analysisContents0.getMiniSetup(); PreviousResult previousResult = PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup)); inputs = inputs.withPreviousResult(previousResult); } CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; tincremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , cacheFile , compileOrder ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; try { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
public static String pathOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
public static File fileOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) throws Exception { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . toString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . toString ( ) . hashCode ( ) + " .timestamp " ) , outputDir ) ; } 
long getLastSuccessfullTS ( ) throws Exception { long back = - 1 ; if ( _lastCompileAtFile . exists ( ) & & _outputDir . exists ( ) & & ( _outputDir . list ( ) . length > 0 ) ) { back = _lastCompileAtFile . lastModified ( ) ; } return back ; } 
void setLastSuccessfullTS ( long v ) throws Exception { if ( ! _lastCompileAtFile . exists ( ) ) { FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; incremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , cacheFile , compileOrder ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; try { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
protected void doExecute ( ) throws Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private Set < String > setupClassPathForConsole ( final VersionNumber scalaVersion ) throws Exception { final Set < String > classpath = new HashSet < String > ( ) ; classpath . addAll ( this . setupProjectClasspaths ( ) ) ; classpath . addAll ( this . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < String > setupProjectClasspaths ( ) throws Exception { final Set < String > classpath = new HashSet < String > ( ) ; super . addCompilerToClasspath ( classpath ) ; super . addLibraryToClasspath ( classpath ) ; if ( this . useTestClasspath ) { classpath . addAll ( super . project . getTestClasspathElements ( ) ) ; } if ( this . useRuntimeClasspath ) { classpath . addAll ( super . project . getRuntimeClasspathElements ( ) ) ; } return classpath ; } 
private Set < String > setupConsoleClasspaths ( final VersionNumber scalaVersion ) throws Exception { final Set < String > classpath = new HashSet < String > ( ) ; super . addToClasspath ( this . resolveJLine ( scalaVersion , this . fallbackJLine ( scalaVersion ) ) , classpath , true ) ; return classpath ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) throws Exception { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . toString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( this . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; if ( artifactId . equals ( ScalaConsoleMojo . JLINE ) & & ( groupId . equals ( ScalaConsoleMojo . JLINE ) | | 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scala2_12_0M4.compareTo(scalaVersion) <= 0) { return super.factory.createArtifact(ScalaConsoleMojo.JLINE, ScalaConsoleMojo.JLINE, "2.14.1", "", ScalaMojoSupport.JAR); 
protected List < File > getSourceDirectories ( ) throws Exception { throw new UnsupportedOperationException ( " USELESS " ) ; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < String > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } List < String > testSources = new ArrayList < String > ( project . getTestCompileSourceRoots ( ) ) ; testSources . add ( FileUtils . pathOf ( testSourceDir , useCanonicalPath ) ) ; List < File > testSourceDirs = normalize ( testSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & ! INCREMENTAL . equals ( recompileMode ) ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected void postCompileActions ( ) throws Exception { } private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } } } 
protected void addLibraryToClasspath ( Set < String > classpath ) throws Exception { classpath . add ( FileUtils . pathOf ( getLibraryJar ( ) , useCanonicalPath ) ) ; } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if(failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = project.getProjectBuildingRequest(); request.setProject(project); checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(request, null)); } 
protected final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) throws Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected List < String > getJavacOptions ( ) throws Exception { List < String > options = new ArrayList < String > ( ) ; if ( javacArgs ! = null ) Collections . addAll ( options , javacArgs ) ; if ( StringUtils . isNotEmpty ( addJavacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addJavacArgs , " | " ) ) ; } issue #116 if (javacGenerateDebugSymbols) { options.add("-g"); } if (target != null) { options.add("-target"); options.add(target); } if (source != null) { options.add("-source"); options.add(source); } if (encoding != null) { options.add("-encoding"); options.add(encoding); } return options; } 
protected File getLibraryJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_LIBRARY_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getCompilerJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_COMPILER_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
private static String scriptBaseNameOf ( File scriptFile , int idx ) { if ( scriptFile = = null ) { return " embeddedScript_ " + idx ; } int dot = scriptFile . getName ( ) . lastIndexOf ( '.' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + idx ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + idx ; } 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
protected List < String > getClasspathElements ( ) throws Exception { List < String > back = project . getTestClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); return back; } 
public String toString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . toString ( ) ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { lgtm [java/constant-comparison] back = 1; } if ((back == 0) && (major < o.major)) { back = -1; } if ((back == 0) && (minor > o.minor)) { back = 1; } if ((back == 0) && (minor < o.minor)) { back = -1; } if ((back == 0) && (bugfix > o.bugfix)) { back = 1; } if ((back == 0) && (bugfix < o.bugfix)) { back = -1; } return back; } 
public boolean isZero ( ) { return ( major = = 0 ) & & ( minor = = 0 ) & & ( bugfix = = 0 ) ; } 
public String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + major + '.' + minor ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { lgtm [java/constant-comparison] back = 1; } if ((back == 0) && (major < o.major)) { back = -1; } if ((back == 0) && (minor > -1) && (minor > o.minor)) { back = 1; } if ((back == 0) && (minor > -1) && (minor < o.minor)) { back = -1; } if ((back == 0) && (bugfix > -1) && (bugfix > o.bugfix)) { back = 1; } if ((back == 0) && (bugfix > -1) && (bugfix < o.bugfix)) { back = -1; } return back; } 
public boolean include ( Artifact artifact ) { TODO - Are we checking the right artifacts? return scalaOrganization.equalsIgnoreCase(artifact.getGroupId()) && SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public boolean accept ( DependencyNode node ) { return include ( node . getArtifact ( ) ) ; } 
protected void processLine ( String line , int level ) { try { _previous = LogProcessorUtils . levelStateOf ( line , _previous ) ; 
public void addToClasspath ( File entry ) throws Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean found = false ; boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; if ( isClasspath ) { item = item + File . pathSeparator + entry . getCanonicalPath ( ) ; jvmArgs . set ( i , item ) ; isClasspath = false ; found = true ; break ; } isClasspath = " -classpath " . equals ( item ) ; } if ( ! found ) { addJvmArgs ( " -classpath " , entry . getCanonicalPath ( ) ) ; 
public static LevelState levelStateOf ( String line , LevelState previous ) throws Exception { LevelState back = new LevelState ( ) ; String lineLowerCase = line . toLowerCase ( ) ; if ( lineLowerCase . indexOf ( " error " ) > - 1 ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . indexOf ( " warn " ) > - 1 ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; } 
public static File createArgFile ( List < String > args ) throws IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); final PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile))); try { for(String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } finally { out.close(); } return argFile; } 
public static List < String > readArgFile ( File argFile ) throws IOException { ArrayList < String > back = new ArrayList < String > ( ) ; final BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ; try { String line = null ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } finally { in . close ( ) ; } return back ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { String _javaExec = null ; if ( toolchain ! = null ) { _javaExec = toolchain . findTool ( " java " ) ; } if ( toolchain = = null | | _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; Points to JRE home if (_javaExec == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } } _javaExec += File.separator + "bin" + File.separator + "java"; } return _javaExec; } 
public static String findHomeFromToolchain ( Toolchain toolchain ) { String executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParent ( ) ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; incremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , cacheFile , compileOrder ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; try { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = true ; } else { throw e ; } } return 1 ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) throws Exception { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . toString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( this . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; if ( artifactId . equals ( ScalaConsoleMojo . JLINE ) & & ( groupId . equals ( ScalaConsoleMojo . JLINE ) | | 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } Inputs inputs = compiler . inputs ( fullClasspath . toArray ( new File [ ] { } ) , classpath sources.toArray(new File[]{}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[]{}), scalacOptions javacOptions.toArray(new String[]{}), javacOptions 100, maxErrors new Function[]{}, sourcePositionMappers compileOrder, order compilers, setup, compiler.emptyPreviousResult() ); Optional<AnalysisContents> analysisContents = analysisStore.get(); if (analysisContents.isPresent()) { AnalysisContents analysisContents0 = analysisContents.get(); CompileAnalysis previousAnalysis = analysisContents0.getAnalysis(); MiniSetup previousSetup = analysisContents0.getMiniSetup(); PreviousResult previousResult = PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup)); inputs = inputs.withPreviousResult(previousResult); } CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception , InterruptedException { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); File reflectJar = getReflectJar(); File compilerJar = getCompilerJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File compilerBridgeJar = getCompilerBridgeJar(); incremental = new SbtIncrementalCompiler(libraryJar, reflectJar, compilerJar, findScalaVersion(), extraJars, compilerBridgeJar, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < String > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } List < String > testSources = new ArrayList < String > ( project . getTestCompileSourceRoots ( ) ) ; testSources . add ( FileUtils . pathOf ( testSourceDir , useCanonicalPath ) ) ; List < File > testSourceDirs = normalize ( testSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & recompileMode ! = RecompileMode . incremental ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
public void execute ( ) { try { if ( sourceDir ! = null ) { 
static String pathOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
static File fileOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < > ( sources ) ; clone the list to keep the original unmodified sources.add(scalaSourceDir); } return normalize(sources); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . toString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . toString ( ) . hashCode ( ) + " .timestamp " ) , outputDir ) ; } 
private int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); File reflectJar = getReflectJar(); File compilerJar = getCompilerJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File compilerBridgeJar = getCompilerBridgeJar(); incremental = new SbtIncrementalCompiler(libraryJar, reflectJar, compilerJar, findScalaVersion(), extraJars, compilerBridgeJar, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void doExecute ( ) throws Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[]{})); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private Set < String > setupClassPathForConsole ( final VersionNumber scalaVersion ) throws Exception { final Set < String > classpath = new HashSet < > ( ) ; classpath . addAll ( this . setupProjectClasspaths ( ) ) ; classpath . addAll ( this . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < String > setupProjectClasspaths ( ) throws Exception { final Set < String > classpath = new HashSet < > ( ) ; super . addCompilerToClasspath ( classpath ) ; super . addLibraryToClasspath ( classpath ) ; if ( this . useTestClasspath ) { classpath . addAll ( super . project . getTestClasspathElements ( ) ) ; } if ( this . useRuntimeClasspath ) { classpath . addAll ( super . project . getRuntimeClasspathElements ( ) ) ; } return classpath ; } 
private Set < String > setupConsoleClasspaths ( final VersionNumber scalaVersion ) throws Exception { final Set < String > classpath = new HashSet < > ( ) ; addToClasspath ( this . resolveJLine ( scalaVersion , this . fallbackJLine ( scalaVersion ) ) , classpath , true ) ; return classpath ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . toString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( this . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; return artifactId . equals ( ScalaConsoleMojo . JLINE ) & & groupId . equals ( ScalaConsoleMojo . JLINE ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { JavaMainCaller jcmd = super . getScalaCommand ( ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " -verbose " , true ) ; } return jcmd ; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } List < String > testSources = new ArrayList < > ( project . getTestCompileSourceRoots ( ) ) ; testSources . add ( FileUtils . pathOf ( testSourceDir , useCanonicalPath ) ) ; List < File > testSourceDirs = normalize ( testSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & recompileMode ! = RecompileMode . incremental ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
private void failOnError ( String prefix , Exception e ) throws MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } throw new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { if (!paths.isEmpty())jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
private void tryAggregateUpper ( MavenProject prj ) throws Exception { if ( prj ! = null & & prj . hasParent ( ) & & canAggregate ( ) ) { MavenProject parent = prj . getParent ( ) ; 
public void doExecute ( ) throws Exception { JavaMainCaller jcmd ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -help " ) ; jcmd . addArgs ( " -X " ) ; jcmd . addArgs ( " -Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -version " ) ; jcmd . run ( displayCmd ) ; } 
final Artifact scalaCompilerArtifact ( final String scalaVersion ) { return this . factory . createArtifact ( this . getScalaOrganization ( ) , ScalaMojoSupport . SCALA_COMPILER_ARTIFACTID , 
final Set < Artifact > resolveArtifactDependencies ( final Artifact artifact ) { final AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( art - > ! art . isOptional ( ) ) ; Use the collection filter as the resolution filter. return resolveDependencyArtifacts(artifact, filter, 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter ) { return resolveDependencyArtifacts ( artifact , collectionFilter , 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = this . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return this.resolver.resolve(arr).getArtifacts(); } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) throws Exception { addToClasspath ( groupId , artifactId , version , classpath , true ) ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) throws Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) , classpath , addDependencies ) ; } 
private void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) throws Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( ScalaMojoSupport . JAR ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) throws Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( FileUtils . pathOf ( artifact . getFile ( ) , useCanonicalPath ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
void addLibraryToClasspath ( Set < String > classpath ) throws Exception { classpath . add ( FileUtils . pathOf ( getLibraryJar ( ) , useCanonicalPath ) ) ; } 
private String findScalaVersionFromDependencies ( ) { return findVersionFromDependencies ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID ) ; } 
void checkScalaVersion ( ) throws Exception { String sv = findScalaVersion ( ) . toString ( ) ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { getLog ( ) . warn ( String . format ( " local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s " , scalaHome , sv ) ) ; } if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( sv ) ; 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < DependencyNodeFilter > filters = new ArrayList < > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( getScalaOrganization ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { return getScalaCommand ( fork , scalaClassName ) ; } 
final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) throws Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
final JavaMainCaller getEmptyScalaCommand ( final String mainClass ) throws Exception { return getEmptyScalaCommand ( mainClass , fork ) ; } 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) throws Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog().info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if(forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new LinkedHashSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return MainHelper . toMultiPath ( classpath . toArray ( new String [ ] { } ) ) ; } 
protected List < String > getScalaOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; return options ; } 
private File getArtifactJar ( String groupId , String artifactId , String version ) throws Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
private Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) throws Exception { Set < Artifact > result = new HashSet < > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , ScalaMojoSupport . POM ) ; Set < Artifact > d = resolveArtifactDependencies ( pom ) ; result . addAll ( d ) ; for ( Artifact dependency : d ) { Set < Artifact > transitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( transitive ) ; } return result ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
List < File > findSourceWithFilters ( ) throws Exception { return findSourceWithFilters ( getSourceDirectories ( ) ) ; } 
List < File > findSourceWithFilters ( List < File > sourceRootDirs ) throws Exception { List < File > sourceFiles = new ArrayList < > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[]{}), excludes.toArray(new String[]{})); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensitive to scala file order, file system can't guarantee file order => unreproducible build error across platforms sort files by path (OS dependent) to guarantee reproducible command line. Collections.sort(sourceFiles); return sourceFiles; } 
List < File > normalize ( List < String > compileSourceRootsList ) throws Exception { List < File > newCompileSourceRootsList = new ArrayList < > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = FileUtils.fileOf(new File(srcDir), useCanonicalPath); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
static List < String > addOsgiClasspathElements ( MavenProject project , List < String > defaultClasspathElements ) { if ( getLocationsMethod = = null ) { return defaultClasspathElements ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return defaultClasspathElements ; List < String > osgiClasspath = new ArrayList < > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } osgiClasspath . addAll ( defaultClasspathElements ) ; return osgiClasspath ; } 
String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + major + '.' + minor ; } 
private boolean isScalaDistroArtifact ( Artifact artifact ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
void addJvmArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , String value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , File value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , boolean value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) void run(boolean displayCmd) throws Exception; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void run ( boolean displayCmd ) throws Exception ; SpawnMonitor spawn ( boolean displayCmd ) throws Exception ; } 
boolean run ( boolean displayCmd , boolean throwFailure ) throws Exception ; SpawnMonitor spawn ( boolean displayCmd ) throws Exception ; } 
public SpawnMonitor spawn ( boolean displayCmd ) throws Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < > ( ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . addAll ( cmd ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . addAll ( cmd ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return () -> { try { 
private List < String > buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back ; } 
private void tryDeleteArgFile ( List < String > cmd ) { tString last = cmd . get ( cmd . size ( ) - 1 ) ; if ( last . endsWith ( MainHelper . argFileSuffix ) ) { tFile f = new File ( last ) ; 
private long lengthOf ( List < String > l , long sepLength ) { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
public SpawnMonitor spawn ( final boolean displayCmd ) { final Thread = new Thread ( ( ) - > { try { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } }); t.start(); return t::isAlive; } 
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ ] { } ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
public static LevelState levelStateOf ( String line , LevelState previous ) { LevelState back = new LevelState ( ) ; String lineLowerCase = line . toLowerCase ( ) ; if ( lineLowerCase . contains ( " error " ) ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . contains ( " warn " ) ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; } 
public static String toClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new LinkedList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . toString ( ) ; } 
private static void appendUrlToClasspathCollection ( ClassLoader cl , Collection < String > classpath ) { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } while ( cl ! = null ) { if ( cl instanceof URLClassLoader ) { 
static File createArgFile ( List < String > args ) throws IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile)))) { for (String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } return argFile; } 
static List < String > readArgFile ( File argFile ) throws IOException { ArrayList < String > back = new ArrayList < > ( ) ; try ( BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ) { String line ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } return back ; } 
static String locateJar ( Class < ? > c ) throws Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; Matcher m = p . matcher ( location . toString ( ) ) ; if ( m . find ( ) ) { return URLDecoder . decode ( m . group ( 1 ) , " UTF-8 " ) ; } throw new ClassNotFoundException ( " Cannot parse location of ' " + location + " '. Probably not loaded from a Jar " ) ; } throw new ClassNotFoundException ( " Cannot find class ' " + c . getName ( ) + " using the classloader " ) ; } 
static String findHomeFromToolchain ( Toolchain toolchain ) { String executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParent ( ) ; } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } Inputs inputs = compiler . inputs ( fullClasspath . toArray ( new File [ ] { } ) , classpath sources.toArray(new File[] {}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors new Function[] {}, sourcePositionMappers compileOrder, order compilers, setup, compiler.emptyPreviousResult()); Optional<AnalysisContents> analysisContents = analysisStore.get(); if (analysisContents.isPresent()) { AnalysisContents analysisContents0 = analysisContents.get(); CompileAnalysis previousAnalysis = analysisContents0.getAnalysis(); MiniSetup previousSetup = analysisContents0.getMiniSetup(); PreviousResult previousResult = PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup)); inputs = inputs.withPreviousResult(previousResult); } CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
static String pathOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
static File fileOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < > ( sources ) ; clone the list to keep the original unmodified sources.add(scalaSourceDir); } return normalize(sources); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info( String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . toString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . toString ( ) . hashCode ( ) + " .timestamp " ) , outputDir ) ; 
private int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); File reflectJar = getReflectJar(); File compilerJar = getCompilerJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File compilerBridgeJar = getCompilerBridgeJar(); incremental = new SbtIncrementalCompiler(libraryJar, reflectJar, compilerJar, findScalaVersion(), extraJars, compilerBridgeJar, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void doExecute ( ) throws Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[] {})); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . toString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( this . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scala2_12_0M4.compareTo(scalaVersion) <= 0) { return super.factory.createArtifact(ScalaConsoleMojo.JLINE, ScalaConsoleMojo.JLINE, "2.14.1", "", 
protected void postCompileActions ( ) throws Exception { } private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) 
private void failOnError ( String prefix , Exception e ) throws MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } throw new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath); if (!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
public boolean canGenerateReport ( ) { there is modules to aggregate boolean back = ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0); back = back || (findSourceFiles().size() != 0); return back; } 
private boolean canAggregate ( ) { return StringUtils . isNotEmpty ( vscaladocVersion ) & & ( new VersionNumber ( vscaladocVersion ) . compareTo ( new VersionNumber ( " 1.1 " ) ) > = 0 ) ; 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271) { jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { if (!paths.isEmpty()) jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
final Artifact scalaCompilerArtifact ( final String scalaVersion ) { return this . factory . createArtifact ( this . getScalaOrganization ( ) , ScalaMojoSupport . SCALA_COMPILER_ARTIFACTID , scalaVersion , " " , ScalaMojoSupport . POM ) ; 
final Set < Artifact > resolveArtifactDependencies ( final Artifact artifact ) { final AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( art - > ! art . isOptional ( ) ) ; Use the collection filter as the resolution filter. return resolveDependencyArtifacts(artifact, filter, filter); } 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter ) { return resolveDependencyArtifacts ( artifact , collectionFilter , resolutionFilter , this . remoteRepos , this . localRepo ) ; 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = this . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return this.resolver.resolve(arr).getArtifacts(); } 
private ArtifactResolutionRequest createArtifactResolutionRequest ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = new ArtifactResolutionRequest ( ) ; arr . setArtifact ( artifact ) ; arr . setCollectionFilter ( collectionFilter ) ; arr . setResolutionFilter ( resolutionFilter ) ; arr . setResolveRoot ( false ) ; arr . setResolveTransitively ( true ) ; arr . setRemoteRepositories ( remoteRepositories ) ; arr . setLocalRepository ( localRepository ) ; return arr ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) throws Exception { addToClasspath ( groupId , artifactId , version , classpath , true ) ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) throws Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) , 
private void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) throws Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( ScalaMojoSupport . JAR ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
void checkScalaVersion ( ) throws Exception { String sv = findScalaVersion ( ) . toString ( ) ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { getLog ( ) . warn ( String . format ( " local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s " , scalaHome , sv ) ) ; } if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( sv ) ; 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = project.getProjectBuildingRequest(); request.setProject(project); checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(request, null)); } 
private void checkArtifactForScalaVersion ( VersionNumber requiredScalaVersion , DependencyNode rootNode ) throws Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) , getScalaOrganization ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) throws Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) throws Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog().info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if (forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for (String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new LinkedHashSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return MainHelper . toMultiPath ( classpath . toArray ( new String [ ] { } ) ) ; } 
protected List < String > getScalaOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; return options ; } 
protected File getCompilerJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_COMPILER_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; } 
protected File getCompilerBridgeJar ( ) throws Exception { VersionNumber scalaVersion = findScalaVersion ( ) ; String zincVersion = findVersionFromPluginArtifacts ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . ZINC_ARTIFACT_ID ) ) ; return getArtifactJar ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . COMPILER_BRIDGE_ARTIFACT_ID ) , 
protected List < File > getCompilerDependencies ( ) throws Exception { List < File > d = new ArrayList < > ( ) ; if ( StringUtils . isEmpty ( scalaHome ) ) { for ( Artifact artifact : getAllDependencies ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ) { d . add ( artifact . getFile ( ) ) ; } } else { for ( File f : new File ( scalaHome , " lib " ) . listFiles ( ) ) { String name = f . getName ( ) ; if ( name . endsWith ( " .jar " ) & & ! name . contains ( " scala-library " ) & & ! name . contains ( " scala-compiler " ) ) { d . add ( f ) ; } } } return d ; } 
private File getArtifactJar ( String groupId , String artifactId , String version ) throws Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
private Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) throws Exception { Set < Artifact > result = new HashSet < > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , ScalaMojoSupport . POM ) ; Set < Artifact > d = resolveArtifactDependencies ( pom ) ; result . addAll ( d ) ; for ( Artifact dependency : d ) { Set < Artifact > transitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( transitive ) ; } return result ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; Toolchain toolchain = toolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( this , mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile , toolchain ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ i ] . mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , toolchain ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ 0 ] . mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , toolchain ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript.importFrom("mojo", MavenProject.class.getPackage().getName()); rScript.importFrom("mojo", MavenSession.class.getPackage().getName()); rScript.importFrom("mojo", Log.class.getPackage().getName()); rScript.importFrom("mojo", "org.apache.maven"); add the script directory to the classpath rScript.addURL(scriptDir.toURI().toURL()); for (String string : classpath) { rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
List < File > findSourceWithFilters ( List < File > sourceRootDirs ) throws Exception { List < File > sourceFiles = new ArrayList < > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[] {}), excludes.toArray(new String[] {})); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensitive to scala file order, file system can't guarantee file order => unreproducible build error across platforms sort files by path (OS dependent) to guarantee reproducible command line. Collections.sort(sourceFiles); return sourceFiles; } 
protected List < String > getClasspathElements ( ) throws Exception { List < String > back = project . getTestClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); return back; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = testSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; } 
public String toString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . toString ( ) ; } 
private boolean isScalaDistroArtifact ( Artifact artifact ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
public void logScalaDependents ( ) { _log . warn ( " Expected all dependencies to require Scala version: " + _version ) ; for ( String dependString : scalaDependentArtifactStrings ) { _log . warn ( dependString ) ; 
public boolean include ( Artifact artifact ) { TODO - Are we checking the right artifacts? return scalaOrganization.equalsIgnoreCase(artifact.getGroupId()) && SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public static String makeArtifactNameString ( Artifact artifact ) { TODO - Handle version ranges... if (artifact == null) { return "<null artifact>"; } return artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getVersion(); } 
void addJvmArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , String value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , File value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , boolean value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) void run(boolean displayCmd) throws Exception; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void run ( boolean displayCmd ) throws Exception ; SpawnMonitor spawn ( boolean displayCmd ) throws Exception ; } 
public SpawnMonitor spawn ( boolean displayCmd ) throws Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < > ( ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . addAll ( cmd ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . addAll ( cmd ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return () -> { try { 
private void tryDeleteArgFile ( List < String > cmd ) { String last = cmd . get ( cmd . size ( ) - 1 ) ; if ( last . endsWith ( MainHelper . argFileSuffix ) ) { File f = new File ( last ) ; 
public void addJvmArgs ( String . . . args0 ) { TODO - Ignore classpath if (args0 != null) { for (String arg : args0) { 
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ ] { } ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
public void addJvmArgs ( String . . . args0 ) { if ( args0 ! = null ) { for ( String arg : args0 ) { 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addArgs ( String . . . args1 ) { if ( args1 ! = null ) { for ( String arg : args1 ) { 
public static String toClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new LinkedList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . toString ( ) ; } 
private static String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " .* \\ s.* " ) ) { return '"' + arg + '"' ; } return arg ; } 
private static String unescapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . charAt ( 0 ) = = '"' & & arg . charAt ( arg . length ( ) - 1 ) = = '"' ) { return arg . substring ( 1 , arg . length ( ) - 1 ) ; } return arg ; } 
static File createArgFile ( List < String > args ) throws IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile)))) { for (String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } return argFile; } 
static String locateJar ( Class < ? > c ) throws Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; Matcher m = p . matcher ( location . toString ( ) ) ; if ( m . find ( ) ) { return URLDecoder . decode ( m . group ( 1 ) , " UTF-8 " ) ; } throw new ClassNotFoundException ( " Cannot parse location of ' " + location + " '. Probably not loaded from a Jar " ) ; } throw new ClassNotFoundException ( " Cannot find class ' " + c . getName ( ) + " using the classloader " ) ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { String _javaExec = null ; if ( toolchain ! = null ) { _javaExec = toolchain . findTool ( " java " ) ; } if ( toolchain = = null | | _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; Points to JRE home if (_javaExec == null) { throw new IllegalStateException( "Couldn't locate java, try setting JAVA_HOME environment variable."); } } _javaExec += File.separator + "bin" + File.separator + "java"; } return _javaExec; } 
static String findHomeFromToolchain ( Toolchain toolchain ) { String executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParent ( ) ; } 
public void jdkSplit ( ) throws Exception { LevelState previous = new LevelState ( ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala:-1: info: compiling " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514 " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Recompiling 1 files " , previous , Level . INFO , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " two errors found " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " BUILD ERROR " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " wrap: org.apache.commons.exec.ExecuteException: Process exited with an error: 1(Exit value: 1) " , previous , 
private LevelState assertLevelState ( String input , LevelState previous , Level expectedLevel , String expectedUntilContains ) throws Exception { LevelState back = LogProcessorUtils . levelStateOf ( input , previous ) ; assertEquals ( expectedLevel , back . level ) ; assertEquals ( expectedUntilContains , back . untilContains ) ; return back ; } 
public void classworldSeftFirstStrategy ( ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
public void compare ( ) throws Exception { assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; } 
public void parse ( ) throws Exception { assertParseVN ( " 2.7.1 " , 2 , 7 , 1 , null ) ; assertParseVN ( " 2.7 " , 2 , 7 , 0 , null ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.RC " , 2 , 7 , 0 , " .RC " ) ; assertParseVN ( " 2.7-RC " , 2 , 7 , 0 , " -RC " ) ; assertParseVN ( " 2.7.1-SNAPSHOT " , 2 , 7 , 1 , " -SNAPSHOT " ) ; } 
public void compareMask ( ) throws Exception { assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7-rc " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.0 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.2-rc1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; } 
String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + ( modifier = = null ? ( major + " . " + minor ) : toString ( ) ) ; } 
protected File getCompilerBridgeJar ( ) throws Exception { VersionNumber scalaVersion = findScalaVersion ( ) ; String zincVersion = findVersionFromPluginArtifacts ( SbtIncrementalCompiler . SBT_GROUP_ID , SbtIncrementalCompiler . ZINC_ARTIFACT_ID ) ; return getArtifactJar ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . COMPILER_BRIDGE_ARTIFACT_ID ) , 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) throws Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info( String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private PreviousResult previousResult ( ) { Optional < AnalysisContents > analysisContents = analysisStore . get ( ) ; if ( analysisContents . isPresent ( ) ) { AnalysisContents analysisContents0 = analysisContents . get ( ) ; 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } Inputs inputs = compiler . inputs ( fullClasspath.toArray(new File[] {}), classpath sources.toArray(new File[] {}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors new Function[] {}, sourcePositionMappers compileOrder, order compilers, compilers setup, setup previousResult(), pr Optional.empty() temporaryClassesDirectory ); CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } CompileOptions options = CompileOptions . of ( fullClasspath.toArray(new File[] {}), classpath sources.toArray(new File[] {}), sources classesDirectory, scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors pos -> pos, sourcePositionMappers compileOrder, order Optional.empty() temporaryClassesDirectory ); Inputs inputs = Inputs.of(compilers, options, setup, previousResult()); CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
protected File getCompilerBridgeJar ( ) throws Exception { VersionNumber scalaVersion = findScalaVersion ( ) ; String zincVersion = findVersionFromPluginArtifacts ( SBT_GROUP_ID , ZINC_ARTIFACT_ID ) ; return getArtifactJar ( SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( COMPILER_BRIDGE_ARTIFACT_ID ) , zincVersion ) ; 
private int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, getCompilerBridgeJar(), getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected File getArtifactJar ( String groupId , String artifactId , String version ) throws Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } CompileOptions options = CompileOptions . of ( fullClasspath.toArray(new File[] {}), classpath sources.toArray(new File[] {}), sources classesDirectory, scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors pos -> pos, sourcePositionMappers compileOrder, order Optional.empty() temporaryClassesDirectory ); Inputs inputs = Inputs.of(compilers, options, setup, previousResult()); CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
private String compilerBridgeArtifactId ( String scalaVersion ) { if ( scalaVersion . startsWith ( " 2.10. " ) ) { return " compiler-bridge_2.10 " ; 
private Artifact createJarArtifact ( String groupId , String artifactId , String version , String classifier ) { return classifier = = null ? repositorySystem . createArtifact ( groupId , artifactId , version , ScalaMojoSupport . JAR ) : repositorySystem . createArtifactWithClassifier ( groupId , artifactId , version , ScalaMojoSupport . JAR , 
private Set < Artifact > resolve ( Artifact artifact , boolean transitively ) { ArtifactResolutionRequest request = new ArtifactResolutionRequest ( ) .setArtifact(artifact) .setResolveRoot(true) .setResolveTransitively(transitively) .setServers(session.getRequest().getServers()) .setMirrors(session.getRequest().getMirrors()) .setProxies(session.getRequest().getProxies()) .setLocalRepository(session.getLocalRepository()) .setRemoteRepositories(session.getCurrentProject().getRemoteArtifactRepositories()); return repositorySystem.resolve(request).getArtifacts(); } 
private int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
final Artifact scalaCompilerArtifact ( String scalaVersion ) { return factory . createArtifact ( getScalaOrganization ( ) , ScalaMojoSupport . SCALA_COMPILER_ARTIFACTID , scalaVersion , " " , ScalaMojoSupport . POM ) ; 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = this . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return factory.resolve(arr).getArtifacts(); } 
public static List < File > listDirectoryContent ( Path directory , Function < File , Boolean > filter ) throws IOException { List < File > files = new ArrayList < > ( ) ; Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) { File f = file . toFile ( ) ; if ( filter . apply ( f ) ) { files . add ( f ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { File f = dir . toFile ( ) ; if ( ! dir . equals ( directory ) & & filter . apply ( f ) ) { files . add ( f ) ; } return FileVisitResult . CONTINUE ; } } ) ; return files ; } 
public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) { File f = file . toFile ( ) ; if ( filter . apply ( f ) ) { files . add ( f ) ; } return FileVisitResult . CONTINUE ; } 
public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { File f = dir . toFile ( ) ; if ( ! dir . equals ( directory ) & & filter . apply ( f ) ) { files . add ( f ) ; } return FileVisitResult . CONTINUE ; } 
public static void deleteDirectory ( Path directory ) { try { Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { 
public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } 
public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } 
public void shouldReturnNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain toolchain = new NullReturningToolChain ( ) ; environmentVariables . set ( " JAVA_HOME " , " test " ) ; assertEquals ( Paths . get ( " test " , " bin " , " java " ) . toString ( ) , JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
static List < String > addOsgiClasspathElements ( MavenProject project ) { if ( getLocationsMethod = = null ) { return Collections . emptyList ( ) ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return Collections . emptyList ( ) ; List < String > osgiClasspath = new ArrayList < > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } return osgiClasspath ; } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest()); request.setProject(project); checkArtifactForScalaVersion(requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null)); } 
public void log ( Enumeration . Value level , Function0 < String > message ) { String s = message . apply ( ) ; String prefix = " [ " + level . toString ( ) + " ] " ; if ( s . regionMatches ( true , 0 , prefix , 0 , prefix . length ( ) ) ) { s = s . substring ( prefix . length ( ) ) ; } if ( level . equals ( Level . Error ( ) ) ) { log . error ( s ) ; 
public void compile ( Set < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } CompileOptions options = CompileOptions . of ( fullClasspath.toArray(new File[] {}), classpath sources.toArray(new File[] {}), sources classesDirectory, scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors pos -> pos, sourcePositionMappers compileOrder, order Optional.empty() temporaryClassesDirectory ); Inputs inputs = Inputs.of(compilers, options, setup, previousResult()); CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < String > classpathElements , boolean compileInLoop ) throws Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info( String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271) { jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 Set<String> paths = new HashSet<>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { addAdditionalDependencies(paths); if (!paths.isEmpty()) jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
protected void addAdditionalDependencies ( Set < String > back ) throws Exception { if ( additionalDependencies ! = null ) { for ( Dependency dependency : additionalDependencies ) { 
protected Set < String > getClasspathElements ( ) throws Exception { Set < String > back = new HashSet < > ( project . getTestClasspathElements ( ) ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; addAdditionalDependencies ( back ) ; return back ; } 
public static String toMultiPath ( Collection < String > paths ) { return StringUtils . join ( paths . iterator ( ) , File . pathSeparator ) ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { String javaExec = null ; if ( toolchain ! = null ) { javaExec = toolchain . findTool ( " java " ) ; } if ( javaExec = = null ) { String javaHome = System . getenv ( " JAVA_HOME " ) ; if ( javaHome = = null ) { javaHome = System . getProperty ( " java.home " ) ; fallback to JRE } if (javaHome == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } javaExec = javaHome + File.separator + "bin" + File.separator + "java"; } return javaExec; } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) throws Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog().info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if (forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for (String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, getToolchain()); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
public static File findHomeFromToolchain ( Toolchain toolchain ) { String executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; } 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) { File home = JavaLocator . findHomeFromToolchain ( new TestStringReturningToolChain ( ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( ) ) ; assertNull ( home ) ; } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = new SbtIncrementalCompiler(libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < String > classpathElements , boolean compileInLoop ) throws Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info( String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = new SbtIncrementalCompiler(libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, javaHome.toPath(), new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources.stream().map(File::toPath).collect(Collectors.toList()), outputDir.toPath(), scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
public static List < Path > listDirectoryContent ( Path directory , Function < Path , Boolean > filter ) throws IOException { List < Path > paths = new ArrayList < > ( ) ; Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } } ) ; return paths ; } 
public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } 
public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } 
public void trace ( Function0 < Throwable > ) { if ( log . isDebugEnabled ( ) ) { log . debug ( . apply ( ) ) ; 
public void success ( Function0 < String > message ) { if ( log . isInfoEnabled ( ) ) { log . info ( " Success: " + message . apply ( ) ) ; 
public void log ( Enumeration . Value level , Function0 < String > message ) { String s = message . apply ( ) ; String prefix = " [ " + level . toString ( ) + " ] " ; if ( s . regionMatches ( true , 0 , prefix , 0 , prefix . length ( ) ) ) { s = s . substring ( prefix . length ( ) ) ; } if ( level . equals ( Level . Error ( ) ) ) { log . error ( s ) ; 
public String toString ( ) { return " BasicArtifact( " + groupId + " , " + artifactId + " , " + version + " , " + classifier + " ) " ; } 
static String pathOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
static File fileOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
public Set < Artifact > getJarAndDependencies ( String groupId , String artifactId , String version , String classifier ) { Artifact artifact = createJarArtifact ( groupId , artifactId , version , classifier ) ; return resolve ( artifact , true ) ; } 
private Artifact createJarArtifact ( String groupId , String artifactId , String version , String classifier ) { return classifier = = null ? repositorySystem . createArtifact ( groupId , artifactId , version , ScalaMojoSupport . JAR ) 
private Set < Artifact > resolve ( Artifact artifact , boolean transitively ) { ArtifactResolutionRequest request = new ArtifactResolutionRequest ( ) .setArtifact(artifact) .setResolveRoot(true) .setResolveTransitively(transitively) .setServers(session.getRequest().getServers()) .setMirrors(session.getRequest().getMirrors()) .setProxies(session.getRequest().getProxies()) .setLocalRepository(session.getLocalRepository()) .setRemoteRepositories(session.getCurrentProject().getRemoteArtifactRepositories()); return repositorySystem.resolve(request).getArtifacts(); } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < > ( sources ) ; clone the list to keep the original unmodified sources.add(scalaSourceDir); } return normalize(sources); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < String > classpathElements , boolean compileInLoop ) throws Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile( classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog() .info( String.format( "Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private void notifyCompilation ( List < File > files ) throws Exception { if ( notifyCompilation ) { for ( File f : files ) { 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . toString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . toString ( ) . hashCode ( ) + " .timestamp " ) , 
void setLastSuccessfullTS ( long v ) throws Exception { if ( ! _lastCompileAtFile . exists ( ) ) { FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, javaHome.toPath(), new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile( classpathElements, sources.stream().map(File::toPath).collect(Collectors.toList()), outputDir.toPath(), scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void doExecute ( ) throws Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[] {})); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private void handleJavaRebel ( final JavaMainCaller jcmd ) throws IOException { if ( this . javaRebelPath ! = null ) { final String canonicalJavaRebelPath = this . javaRebelPath . getCanonicalPath ( ) ; 
private Set < String > setupClassPathForConsole ( final VersionNumber scalaVersion ) throws Exception { final Set < String > classpath = new HashSet < > ( ) ; classpath . addAll ( this . setupProjectClasspaths ( ) ) ; classpath . addAll ( this . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < String > setupProjectClasspaths ( ) throws Exception { final Set < String > classpath = new HashSet < > ( ) ; super . addCompilerToClasspath ( classpath ) ; super . addLibraryToClasspath ( classpath ) ; if ( this . useTestClasspath ) { classpath . addAll ( super . project . getTestClasspathElements ( ) ) ; } if ( this . useRuntimeClasspath ) { classpath . addAll ( super . project . getRuntimeClasspathElements ( ) ) ; } return classpath ; } 
private Set < String > setupConsoleClasspaths ( final VersionNumber scalaVersion ) throws Exception { final Set < String > classpath = new HashSet < > ( ) ; addToClasspath ( this . resolveJLine ( scalaVersion , this . fallbackJLine ( scalaVersion ) ) , classpath , true ) ; return classpath ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . toString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( this . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; return artifactId . equals ( ScalaConsoleMojo . JLINE ) & & groupId . equals ( ScalaConsoleMojo . JLINE ) ; } 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scala2_12_0M4.compareTo(scalaVersion) <= 0) { return super.factory.createArtifact( 
protected JavaMainCaller getScalaCommand ( ) throws Exception { JavaMainCaller jcmd = super . getScalaCommand ( ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " -verbose " , true ) ; } return jcmd ; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } List < String > testSources = new ArrayList < > ( project . getTestCompileSourceRoots ( ) ) ; testSources . add ( FileUtils . pathOf ( testSourceDir , useCanonicalPath ) ) ; List < File > testSourceDirs = normalize ( testSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & recompileMode ! = RecompileMode . incremental ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected void postCompileActions ( ) throws Exception { } private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) 
public void run ( ) { try { getLog ( ) . info ( " stop server(s)... " ) ; 
public void doExecute ( ) throws Exception { if ( skip ) { getLog ( ) . info ( " Skipping javadoc generation " ) ; return ; } try { generate ( null , Locale . getDefault ( ) ) ; 
private void failOnError ( String prefix , Exception e ) throws MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } throw new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
public boolean canGenerateReport ( ) { there is modules to aggregate boolean back = ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0); back = back || (findSourceFiles().size() != 0); return back; } 
private List < File > findSourceFiles ( ) { if ( _sourceFiles = = null ) { try { _sourceFiles = findSourceWithFilters ( ) ; } catch ( Exception exc ) { throw new RuntimeException ( " can't define source to process " , exc ) ; } } return _sourceFiles ; } 
private boolean canAggregate ( ) { return StringUtils . isNotEmpty ( vscaladocVersion ) & & ( new VersionNumber ( vscaladocVersion ) . compareTo ( new VersionNumber ( " 1.1 " ) ) > = 0 ) ; 
public void doExecute ( ) throws Exception { SiteRendererSink sink = siteRenderer.createSink(new File(project.getReporting().getOutputDirectory(), getOutputName() + ".html"); generate(null, Locale.getDefault()); } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271) { jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 Set<String> paths = new HashSet<>(project.getCompileClasspathElements()); paths.remove( project .getBuild() .getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { addAdditionalDependencies(paths); if (!paths.isEmpty()) jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
public void generate ( Sink sink , Locale locale ) throws MavenReportException { try { if ( ! canGenerateReport ( ) ) { 
private void tryAggregateUpper ( MavenProject prj ) throws Exception { if ( prj ! = null & & prj . hasParent ( ) & & canAggregate ( ) ) { MavenProject parent = prj . getParent ( ) ; 
public void doExecute ( ) throws Exception { JavaMainCaller jcmd ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -help " ) ; jcmd . addArgs ( " -X " ) ; jcmd . addArgs ( " -Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -version " ) ; jcmd . run ( displayCmd ) ; } 
final Artifact scalaCompilerArtifact ( String scalaVersion ) { return factory . createArtifact ( getScalaOrganization ( ) , 
final Set < Artifact > resolveArtifactDependencies ( final Artifact artifact ) { final AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( art - > ! art . isOptional ( ) ) ; Use the collection filter as the resolution filter. return resolveDependencyArtifacts(artifact, filter, filter); } 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter ) { return resolveDependencyArtifacts ( artifact , collectionFilter , resolutionFilter , this . remoteRepos , this . localRepo ) ; 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = this . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return factory.resolve(arr).getArtifacts(); } 
private ArtifactResolutionRequest createArtifactResolutionRequest ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = new ArtifactResolutionRequest ( ) ; arr . setArtifact ( artifact ) ; arr . setCollectionFilter ( collectionFilter ) ; arr . setResolutionFilter ( resolutionFilter ) ; arr . setResolveRoot ( false ) ; arr . setResolveTransitively ( true ) ; arr . setRemoteRepositories ( remoteRepositories ) ; arr . setLocalRepository ( localRepository ) ; return arr ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) throws Exception { addToClasspath ( groupId , artifactId , version , classpath , true ) ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) throws Exception { addToClasspath ( factory . createArtifact ( 
private void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) throws Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( ScalaMojoSupport . JAR ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) throws Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( FileUtils . pathOf ( artifact . getFile ( ) , useCanonicalPath ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
void addLibraryToClasspath ( Set < String > classpath ) throws Exception { classpath . add ( FileUtils . pathOf ( getLibraryJar ( ) , useCanonicalPath ) ) ; } 
public void execute ( ) throws MojoExecutionException , MojoFailureException { try { String oldWay = System . getProperty ( " maven.scala.version " ) ; 
private String findScalaVersionFromDependencies ( ) { return findVersionFromDependencies ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID ) ; } 
void checkScalaVersion ( ) throws Exception { String sv = findScalaVersion ( ) . toString ( ) ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { getLog ( ) . warn ( String . format ( " local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s " , scalaHome , sv ) ) ; } if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( sv ) ; 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest()); request.setProject(project); checkArtifactForScalaVersion( requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null)); 
private void checkArtifactForScalaVersion ( VersionNumber requiredScalaVersion , DependencyNode rootNode ) throws Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) , getScalaOrganization ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < DependencyNodeFilter > filters = new ArrayList < > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( getScalaOrganization ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { return getScalaCommand ( fork , scalaClassName ) ; } 
final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) throws Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
final JavaMainCaller getEmptyScalaCommand ( final String mainClass ) throws Exception { return getEmptyScalaCommand ( mainClass , fork ) ; } 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) throws Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog() .info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if (forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for (String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork( this, mainClass, cp, null, null, forceUseArgFile, getToolchain()); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
private String getToolClasspath ( ) throws Exception { Set < String > classpath = new LinkedHashSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return MainHelper . toMultiPath ( classpath . toArray ( new String [ ] { } ) ) ; } 
protected List < String > getScalaOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; return options ; } 
protected File getLibraryJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_LIBRARY_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; 
protected File getReflectJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_REFLECT_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_REFLECT_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; 
protected File getCompilerJar ( ) throws Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_COMPILER_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ; 
protected File getArtifactJar ( String groupId , String artifactId , String version ) throws Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected boolean isJavaSupportedByCompiler ( ) throws Exception { return findScalaVersion ( ) . compareTo ( new VersionNumber ( " 2.7.2 " ) ) > = 0 ; } 
private Set < String > getCompilerPlugins ( ) throws Exception { Set < String > plugins = new HashSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<>(); TODO - Pull in transitive dependencies. addToClasspath( artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; Toolchain toolchain = toolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( this , mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile , toolchain ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ i ] . mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , toolchain ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ 0 ] . mainClass , MainHelper . toMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , toolchain ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
private static String scriptBaseNameOf ( File scriptFile , int idx ) { if ( scriptFile = = null ) { return " embeddedScript_ " + idx ; } int dot = scriptFile . getName ( ) . lastIndexOf ( '.' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + idx ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + idx ; } 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader , String baseName ) throws Exception { Class < ? > compiledScript = loader . loadClass ( baseName ) ; ClassLoader currentCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; try { try { 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript.importFrom("mojo", MavenProject.class.getPackage().getName()); rScript.importFrom("mojo", MavenSession.class.getPackage().getName()); rScript.importFrom("mojo", Log.class.getPackage().getName()); rScript.importFrom("mojo", "org.apache.maven"); add the script directory to the classpath rScript.addURL(scriptDir.toURI().toURL()); for (String string : classpath) { rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
private void compileScript ( File scriptDir , File destFile , URLClassLoader loader ) throws Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . toClasspathString ( loader ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) throws IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream , false , encoding ) ; BufferedReader reader = null ; try { if ( scriptFile ! = null ) { 
private void delete ( File scriptDir ) { if ( scriptDir . isDirectory ( ) ) { for ( File file : scriptDir . listFiles ( ) ) { delete ( file ) ; } } scriptDir . deleteOnExit ( ) ; scriptDir . delete ( ) ; } 
List < File > findSourceWithFilters ( ) throws Exception { return findSourceWithFilters ( getSourceDirectories ( ) ) ; } 
List < File > findSourceWithFilters ( List < File > sourceRootDirs ) throws Exception { List < File > sourceFiles = new ArrayList < > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles( dir, includes.toArray(new String[] {}), excludes.toArray(new String[] {})); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensitive to scala file order, file system can't guarantee file order => unreproducible build error across platforms sort files by path (OS dependent) to guarantee reproducible command line. Collections.sort(sourceFiles); return sourceFiles; } 
List < File > normalize ( List < String > compileSourceRootsList ) throws Exception { List < File > newCompileSourceRootsList = new ArrayList < > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = FileUtils.fileOf(new File(srcDir), useCanonicalPath); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
protected void addAdditionalDependencies ( Set < String > back ) throws Exception { if ( additionalDependencies ! = null ) { for ( Dependency dependency : additionalDependencies ) { 
public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( skip ) { return ; } super . execute ( ) ; } 
protected Set < String > getClasspathElements ( ) throws Exception { Set < String > back = new HashSet < > ( project . getTestClasspathElements ( ) ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; addAdditionalDependencies ( back ) ; return back ; } 
protected List < File > getSourceDirectories ( ) throws Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = testSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; } 
static List < String > addOsgiClasspathElements ( MavenProject project ) { if ( getLocationsMethod = = null ) { return Collections . emptyList ( ) ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return Collections . emptyList ( ) ; List < String > osgiClasspath = new ArrayList < > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } return osgiClasspath ; } 
public String toString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . toString ( ) ; } 
String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + ( modifier = = null ? ( major + " . " + minor ) : toString ( ) ) ; } 
private boolean isScalaDistroArtifact ( Artifact artifact ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
public void logScalaDependents ( ) { _log . warn ( " Expected all dependencies to require Scala version: " + _version ) ; for ( String dependString : scalaDependentArtifactStrings ) { _log . warn ( dependString ) ; 
public boolean include ( Artifact artifact ) { TODO - Are we checking the right artifacts? return scalaOrganization.equalsIgnoreCase(artifact.getGroupId()) && SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public boolean accept ( DependencyNode node ) { return include ( node . getArtifact ( ) ) ; } 
public static String makeArtifactNameString ( Artifact artifact ) { TODO - Handle version ranges... if (artifact == null) { return "<null artifact>"; } return artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getVersion(); } 
void addJvmArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , String value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , File value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , boolean value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) void run(boolean displayCmd) throws Exception; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void run ( boolean displayCmd ) throws Exception ; SpawnMonitor spawn ( boolean displayCmd ) throws Exception ; } 
boolean run ( boolean displayCmd , boolean throwFailure ) throws Exception ; SpawnMonitor spawn ( boolean displayCmd ) throws Exception ; } 
public boolean run ( boolean displayCmd , boolean throwFailure ) throws Exception { List < String > cmd = buildCommand ( ) ; displayCmd ( displayCmd , cmd ) ; Executor exec = new DefaultExecutor ( ) ; err and out are redirected to out if (!_redirectToLog) { exec.setStreamHandler(new PumpStreamHandler(System.out, System.err, System.in)); } else { exec.setStreamHandler( new PumpStreamHandler( new LogOutputStream() { private LevelState _previous = new LevelState(); @Override protected void processLine(String line, int level) { try { _previous = LogProcessorUtils.levelStateOf(line, _previous); switch (_previous.level) { case ERROR: requester.getLog().error(line); break; case WARNING: requester.getLog().warn(line); break; default: requester.getLog().info(line); break; } } catch (Exception e) { e.printStackTrace(); } } })); } CommandLine cl = new CommandLine(cmd.get(0)); for (int i = 1; i < cmd.size(); i++) { cl.addArgument(cmd.get(i), false); } try { int exitValue = exec.execute(cl); 
public SpawnMonitor spawn ( boolean displayCmd ) throws Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < > ( ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . addAll ( cmd ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . addAll ( cmd ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return () -> { try { 
private void displayCmd ( boolean displayCmd , List < String > cmd ) { if ( displayCmd ) { requester . getLog ( ) . info ( " cmd: " + " " + StringUtils . join ( cmd . iterator ( ) , " " ) ) ; 
private List < String > buildCommand ( ) throws Exception { ArrayList < String > back = new ArrayList < > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back ; } 
private void tryDeleteArgFile ( List < String > cmd ) { String last = cmd . get ( cmd . size ( ) - 1 ) ; if ( last . endsWith ( MainHelper . argFileSuffix ) ) { File f = new File ( last ) ; 
private long lengthOf ( List < String > l , long sepLength ) { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
public void addJvmArgs ( String . . . args0 ) { TODO - Ignore classpath if (args0 != null) { for (String arg : args0) { 
public boolean run ( boolean displayCmd , boolean throwFailure ) throws Exception { try { runInternal ( displayCmd ) ; 
public SpawnMonitor spawn ( final boolean displayCmd ) { final Thread = new Thread ( ( ) - > { try { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } }); t.start(); return t::isAlive; } 
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ ] { } ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
public void redirectToLog ( ) { requester . getLog ( ) . warn ( " redirection to log is not supported for 'inProcess' mode " ) ; } 
public void addJvmArgs ( String . . . args0 ) { if ( args0 ! = null ) { for ( String arg : args0 ) { 
public void addToClasspath ( File entry ) throws Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean found = false ; boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; if ( isClasspath ) { item = item + File . pathSeparator + entry . getCanonicalPath ( ) ; jvmArgs . set ( i , item ) ; isClasspath = false ; found = true ; break ; } isClasspath = " -classpath " . equals ( item ) ; } if ( ! found ) { addJvmArgs ( " -classpath " , entry . getCanonicalPath ( ) ) ; 
public void addOption ( String key , String value ) { if ( StringUtils . isEmpty ( value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key ) ; } 
public void addArgs ( String . . . args1 ) { if ( args1 ! = null ) { for ( String arg : args1 ) { 
public void run ( boolean displayCmd ) throws Exception { run ( displayCmd , true ) ; } 
public static LevelState levelStateOf ( String line , LevelState previous ) { LevelState back = new LevelState ( ) ; String lineLowerCase = line . toLowerCase ( ) ; if ( lineLowerCase . contains ( " error " ) ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . contains ( " warn " ) ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; } 
public static String toMultiPath ( Collection < String > paths ) { return StringUtils . join ( paths . iterator ( ) , File . pathSeparator ) ; } 
public static String toMultiPath ( String [ ] paths ) { return StringUtils . join ( paths , File . pathSeparator ) ; } 
public static String [ ] findFiles ( File dir , String [ ] includes , String [ ] excludes ) { DirectoryScanner scanner = new DirectoryScanner ( ) ; scanner . setBasedir ( dir ) ; scanner . setIncludes ( includes ) ; scanner . setExcludes ( excludes ) ; scanner . addDefaultExcludes ( ) ; scanner . scan ( ) ; return scanner . getIncludedFiles ( ) ; } 
public static String toClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new LinkedList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . toString ( ) ; } 
private static void appendUrlToClasspathCollection ( ClassLoader cl , Collection < String > classpath ) { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } while ( cl ! = null ) { if ( cl instanceof URLClassLoader ) { 
private static String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " .* \\ s.* " ) ) { return '"' + arg + '"' ; } return arg ; } 
private static String unescapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . charAt ( 0 ) = = '"' & & arg . charAt ( arg . length ( ) - 1 ) = = '"' ) { return arg . substring ( 1 , arg . length ( ) - 1 ) ; } return arg ; } 
static File createArgFile ( List < String > args ) throws IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile)))) { for (String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } return argFile; } 
static List < String > readArgFile ( File argFile ) throws IOException { ArrayList < String > back = new ArrayList < > ( ) ; try ( BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ) { String line ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } return back ; } 
static void runMain ( String mainClassName , List < String > args , ClassLoader cl ) throws Exception { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } Class < ? > mainClass = cl . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( " main " , String [ ] . class ) ; int mods = mainMethod . getModifiers ( ) ; if ( mainMethod . getReturnType ( ) ! = void . class | | ! Modifier . isStatic ( mods ) | | ! Modifier . isPublic ( mods ) ) { throw new NoSuchMethodException ( " main " ) ; } String [ ] argArray = args . toArray ( new String [ ] { } ) ; TODO - Redirect System.in System.err and System.out mainMethod.invoke(null, new Object[] {argArray}); } 
static String locateJar ( Class < ? > c ) throws Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; Matcher m = p . matcher ( location . toString ( ) ) ; if ( m . find ( ) ) { return URLDecoder . decode ( m . group ( 1 ) , " UTF-8 " ) ; } throw new ClassNotFoundException ( " Cannot parse location of ' " + location + " '. Probably not loaded from a Jar " ) ; } throw new ClassNotFoundException ( " Cannot find class ' " + c . getName ( ) + " using the classloader " ) ; 
public static void main ( String [ ] args ) { try { String mainClassName = args [ 0 ] ; 
public static List < Path > listDirectoryContent ( Path directory , Function < Path , Boolean > filter ) throws IOException { List < Path > paths = new ArrayList < > ( ) ; Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } } ) ; return paths ; } 
public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } 
public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } 
public static void deleteDirectory ( Path directory ) { try { Files . walkFileTree ( 
public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } 
public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { String javaExec = null ; if ( toolchain ! = null ) { javaExec = toolchain . findTool ( " java " ) ; } if ( javaExec = = null ) { String javaHome = System . getenv ( " JAVA_HOME " ) ; if ( javaHome = = null ) { javaHome = System . getProperty ( " java.home " ) ; fallback to JRE } if (javaHome == null) { throw new IllegalStateException( "Couldn't locate java, try setting JAVA_HOME environment variable."); } javaExec = javaHome + File.separator + "bin" + File.separator + "java"; } return javaExec; } 
public static File findHomeFromToolchain ( Toolchain toolchain ) { String executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; } 
public void jdkSplit ( ) throws Exception { LevelState previous = new LevelState ( ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala:-1: info: compiling " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514 " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Recompiling 1 files " , previous , Level . INFO , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " two errors found " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " BUILD ERROR " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( 
private LevelState assertLevelState ( String input , LevelState previous , Level expectedLevel , String expectedUntilContains ) throws Exception { LevelState back = LogProcessorUtils . levelStateOf ( input , previous ) ; assertEquals ( expectedLevel , back . level ) ; assertEquals ( expectedUntilContains , back . untilContains ) ; return back ; } 
public void stringUtilsSplit ( ) throws Exception { assertEquals ( 1 , StringUtils . split ( " hello " , " | " ) . length ) ; assertEquals ( 1 , StringUtils . split ( " hello| " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel|lo " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel||lo " , " | " ) . length ) ; } 
public void classworldSeftFirstStrategy ( ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
public void shouldReturnNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain toolchain = new NullReturningToolChain ( ) ; environmentVariables . set ( " JAVA_HOME " , " test " ) ; assertEquals ( Paths . get ( " test " , " bin " , " java " ) . toString ( ) , 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) throws Exception { Toolchain toolchain = new ReturningToolChain ( ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
public void shouldThrowExceptionWhenNothingCouldBeFound ( ) { Toolchain toolchain = new NullReturningToolChain ( ) ; System . clearProperty ( " java.home " ) ; environmentVariables . set ( " JAVA_HOME " , null ) ; try { JavaLocator . findExecutableFromToolchain ( toolchain ) ; 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) { File home = JavaLocator . findHomeFromToolchain ( new TestStringReturningToolChain ( ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( ) ) ; assertNull ( home ) ; } 
public String findTool ( String s ) { return " parent/child/my-path-to-java " ; } 
public String findTool ( String s ) { return " my-path-to-java " ; } 
private Set < Artifact > resolve ( Artifact artifact , boolean transitively ) { ArtifactResolutionRequest request = new ArtifactResolutionRequest ( ) . setArtifact ( artifact ) . setResolveRoot ( true ) . setResolveTransitively ( transitively ) . setServers ( session . getRequest ( ) . getServers ( ) ) . setMirrors ( session . getRequest ( ) . getMirrors ( ) ) . setProxies ( session . getRequest ( ) . getProxies ( ) ) . setLocalRepository ( session . getLocalRepository ( ) ) . setRemoteRepositories ( session . getCurrentProject ( ) . getRemoteArtifactRepositories ( ) ) ; return repositorySystem . resolve ( request ) . getArtifacts ( ) ; } 
public Class < ? > loadClass ( String className , boolean resolve ) throws ClassNotFoundException { if ( className . startsWith ( " xsbti. " ) ) { We can't use the loadClass overload with two arguments because it's 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scalaVersion.major == 3) { return super.factory.createArtifact( 
protected final Artifact scalaCompilerArtifact ( String scalaVersion ) { return factory . createArtifact ( getScalaOrganization ( ) , 
private String findScalaVersionFromDependencies ( ) { return findVersionFromDependencies ( getScalaOrganization ( ) , 
protected File getLibraryJar ( ) throws Exception { return getLibraryJar ( findScalaVersion ( ) ) ; } 
protected File getLibraryJar ( VersionNumber versionNumber ) throws Exception { String scalaLibrary = _scalaVersionN . major = = 3 ? getScala3ArtifactId ( SCALA3_LIBRARY_ARTIFACTID ) : SCALA_LIBRARY_ARTIFACTID ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , scalaLibrary + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , scalaLibrary , versionNumber . toString ( ) ) ; } 
protected File getReflectJar ( ) throws Exception { if ( _scalaVersionN . major ! = 3 ) { String scalaReflect = _scalaVersionN . major = = 3 ? getScala3ArtifactId ( SCALA3_REFLECT_ARTIFACTID ) : SCALA_REFLECT_ARTIFACTID ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , scalaReflect + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , scalaReflect , findScalaVersion ( ) . toString ( ) ) ; } return null ; } 
protected File getCompilerJar ( ) throws Exception { return getCompilerJar ( findScalaVersion ( ) ) ; } 
protected File getCompilerJar ( VersionNumber versionNumber ) throws Exception { String scalaCompile = _scalaVersionN . major = = 3 ? getScala3ArtifactId ( SCALA3_COMPILER_ARTIFACTID ) : SCALA_COMPILER_ARTIFACTID ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , scalaCompile + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , scalaCompile , versionNumber . toString ( ) ) ; } 
protected List < File > getCompilerDependencies ( ) throws Exception { List < File > d = new ArrayList < > ( ) ; if ( StringUtils . isEmpty ( scalaHome ) ) { for ( Artifact artifact : getAllDependencies ( getScalaOrganization ( ) , _scalaVersionN . major = = 3 ? getScala3ArtifactId ( SCALA3_COMPILER_ARTIFACTID ) : SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . toString ( ) ) ) { d . add ( artifact . getFile ( ) ) ; } } else { for ( File f : new File ( scalaHome , " lib " ) . listFiles ( ) ) { String name = f . getName ( ) ; if ( name . endsWith ( " .jar " ) & & ( ! name . contains ( " scala-library " ) | | ! name . contains ( " scala3-library " ) ) & & ( ! name . contains ( " scala-compiler " ) | | ! name . contains ( " scala3-compiler " ) ) ) { d . add ( f ) ; } } } return d ; } 
private boolean isScalaDistroArtifact ( Artifact artifact ) { if ( _version . major = = 2 | | _version . major = = 3 ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) 
public void addToClasspath ( File entry ) throws Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean found = false ; boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; if ( isClasspath ) { item = item + File . pathSeparator + entry . getCanonicalPath ( ) ; jvmArgs . set ( i , item ) ; found = true ; break ; } isClasspath = " -classpath " . equals ( item ) ; } if ( ! found ) { addJvmArgs ( " -classpath " , entry . getCanonicalPath ( ) ) ; 
private Artifact createJarArtifact ( String groupId , String artifactId , String version , String classifier ) { return classifier = = null ? repositorySystem . createArtifact ( groupId , artifactId , version , JAR ) 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < File > classpathElements , boolean compileInLoop ) throws Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile( classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog() .info( String.format( "Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", FileUtils.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } try { if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } } catch (Exception e) { compileErrors = true; getLog().error("exception compilation error occurred!!!", e); } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private int incrementalCompile ( Set < File > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { Context sc = findScalaContext(); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); ScalaInstance instance = makeScalaInstance(sc); incremental = new SbtIncrementalCompiler( javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder, instance); } classpathElements.remove(outputDir); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile( classpathElements.stream().map(File::toPath).collect(Collectors.toSet()), sources.stream().map(File::toPath).collect(Collectors.toList()), outputDir.toPath(), scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void doExecute ( ) throws Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaContext().version(); final Set<File> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = FileUtils.toMultiPath(classpath); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private Set < File > setupClassPathForConsole ( final VersionNumber scalaVersion ) throws Exception { final Set < File > classpath = new HashSet < > ( ) ; classpath . addAll ( this . setupProjectClasspaths ( ) ) ; classpath . addAll ( this . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < File > setupConsoleClasspaths ( final VersionNumber scalaVersion ) throws Exception { final Set < File > classpath = new HashSet < > ( ) ; Artifact a = this . resolveJLine ( this . fallbackJLine ( scalaVersion ) ) ; addToClasspath ( a . getGroupId ( ) , a . getArtifactId ( ) , a . getVersion ( ) , a . getClassifier ( ) , classpath , true ) ; return classpath ; } 
private Artifact resolveJLine ( final Artifact defaultFallback ) throws Exception { final Set < Artifact > compilerDeps = super . findScalaContext ( ) . findCompilerAndDependencies ( ) ; for ( final Artifact a : compilerDeps ) { if ( this . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
public MavenArtifactResolver findMavenArtifactResolver ( ) { if ( mavenArtifactResolver = = null ) { mavenArtifactResolver = new MavenArtifactResolver ( factory , session ) ; } return mavenArtifactResolver ; } 
public Context findScalaContext ( ) throws Exception { reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be stateless) if (scalaContext == null) { VersionNumber scalaVersion = findScalaVersion(); ArtifactIds aids = (scalaVersion.major == 3) ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2(); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : scalaVersion; if (requiredScalaVersion.compareTo(scalaVersion) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", scalaVersion, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } scalaContext = StringUtils.isNotEmpty(scalaHome) ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome)) : new Context4ScalaRemote( scalaVersion, requiredScalaVersion, aids, scalaOrganization, findMavenArtifactResolver()); } return scalaContext; } 
void addCompilerToClasspath ( Set < File > classpath ) throws Exception { Context sc = findScalaContext ( ) ; for ( Artifact dep : sc . findCompilerAndDependencies ( ) ) { classpath . add ( dep . getFile ( ) ) ; 
void addLibraryToClasspath ( Set < File > classpath ) throws Exception { Context sc = findScalaContext ( ) ; for ( Artifact dep : sc . findLibraryAndDependencies ( ) ) { classpath . add ( dep . getFile ( ) ) ; 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) throws Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest()); request.setProject(project); checkArtifactForScalaVersion( findScalaContext(), dependencyGraphBuilder.buildDependencyGraph(request, null)); 
private void checkArtifactForScalaVersion ( Context scalaContext , DependencyNode rootNode ) throws Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( scalaContext , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) throws Exception { List < DependencyNodeFilter > filters = new ArrayList < > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( findScalaContext ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
private String getToolClasspath ( ) throws Exception { Set < File > classpath = new TreeSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , " " , classpath , true ) ; } } return FileUtils . toMultiPath ( classpath ) ; } 
private Set < File > getCompilerPlugins ( ) throws Exception { Set < File > plugins = new HashSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < File > ignoreClasspath = new LinkedHashSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<File> pluginClassPath = new HashSet<>(); addToClasspath( artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; Toolchain toolchain = toolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( this , mainClass , FileUtils . toMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , jvmArgs , args , forceUseArgFile , toolchain ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ i ] . mainClass , FileUtils . toMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , toolchain ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( this , launchers [ 0 ] . mainClass , FileUtils . toMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , toolchain ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<File> classpath = new HashSet<>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < File > classpath ) throws Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript.importFrom("mojo", MavenProject.class.getPackage().getName()); rScript.importFrom("mojo", MavenSession.class.getPackage().getName()); rScript.importFrom("mojo", Log.class.getPackage().getName()); rScript.importFrom("mojo", "org.apache.maven"); add the script directory to the classpath rScript.addURL(scriptDir.toURI().toURL()); for (File f : classpath) { rScript.addURL(f.toURI().toURL()); } return rScript; } 
protected void addAdditionalDependencies ( Set < File > back ) throws Exception { if ( additionalDependencies ! = null ) { for ( Dependency dependency : additionalDependencies ) { 
protected Set < File > getClasspathElements ( ) throws Exception { Set < File > back = FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; addAdditionalDependencies ( back ) ; return back ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; VersionNumber that = ( VersionNumber ) o ; return major = = that . major & & minor = = that . minor 
public int hashCode ( ) { return Objects . hash ( major , minor , bugfix , modifier ) ; } 
public VersionNumber max ( VersionNumber v ) { if ( this . compareTo ( v ) < 0 ) return v ; return this ; } 
List < String > scalaDistroArtifactIds ( ) throws Exception ; String scalaLibraryArtifactId ( ) throws Exception ; String scalaCompilerArtifactId ( ) throws Exception ; } 
String scalaLibraryArtifactId ( ) throws Exception ; String scalaCompilerArtifactId ( ) throws Exception ; } 
public List < String > scalaDistroArtifactIds ( ) throws Exception { return SCALA_DISTRO_ARTIFACTS ; } 
public String scalaLibraryArtifactId ( ) throws Exception { return SCALA_LIBRARY_ARTIFACTID ; } 
public String scalaCompilerArtifactId ( ) throws Exception { return SCALA_COMPILER_ARTIFACTID ; } 
public String scalaLibraryArtifactId ( ) throws Exception { return getScala3ArtifactId ( SCALA_LIBRARY_ARTIFACTID ) ; } 
public String scalaCompilerArtifactId ( ) throws Exception { return getScala3ArtifactId ( SCALA_COMPILER_ARTIFACTID ) ; } 
public void logScalaDependents ( ) { _log . warn ( " Expected all dependencies to require Scala version: " + _scalaContext . version ( ) ) ; for ( String dependString : scalaDependentArtifactStrings ) { _log . warn ( dependString ) ; 
boolean hasInDistro ( Artifact artifact ) throws Exception ; VersionNumber version ( ) ; VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) throws Exception ; Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; } 
VersionNumber version ( ) ; VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) throws Exception ; Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; } 
VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) throws Exception ; Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; } 
Set < Artifact > findLibraryAndDependencies ( ) throws Exception ; Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; } 
public boolean hasInDistro ( Artifact artifact ) throws Exception { return false ; } 
public VersionNumber versionCompat ( ) { return scalaCompatVersion ; } 
public Set < Artifact > findLibraryAndDependencies ( ) throws Exception { File lib = new File ( scalaHome , " lib " ) ; File f = new File ( lib , aids . scalaLibraryArtifactId ( ) + " .jar " ) ; Set < Artifact > d = new TreeSet < > ( ) ; d . add ( new LocalFileArtifact ( " local " , aids . scalaLibraryArtifactId ( ) , scalaVersion . toString ( ) , f ) ) ; return d ; } 
public Set < Artifact > findCompilerAndDependencies ( ) throws Exception { String compiler = aids.scalaCompilerArtifactId(); Set<Artifact> d = new TreeSet<>(); for (File f : new File(scalaHome, "lib").listFiles()) { String name = f.getName(); if (name.endsWith(".jar")) { d.add( new LocalFileArtifact( "local", name.substring(0, name.length() - 4), scalaVersion.toString(), f)); } } return d; } 
public void addMetadata ( ArtifactMetadata metadata ) { throw new UnsupportedOperationException ( " not implemented " ) ; } 
public void updateVersion ( String version , ArtifactRepository localRepository ) { throw new UnsupportedOperationException ( " not implemented " ) ; } 
public void selectVersion ( String version ) { throw new UnsupportedOperationException ( " not implemented " ) ; } 
public ArtifactVersion getSelectedVersion ( ) throws OverConstrainedVersionException { throw new UnsupportedOperationException ( " not implemented " ) ; } 
public boolean isSelectedVersionKnown ( ) throws OverConstrainedVersionException { throw new UnsupportedOperationException ( " not implemented " ) ; } 
public int compareTo ( Artifact o ) { int c = groupId . compareTo ( o . getGroupId ( ) ) ; if ( c ! = 0 ) return c ; c = artifactId . compareTo ( o . getArtifactId ( ) ) ; if ( c ! = 0 ) return c ; TODO compare on classifier ? return version.compareTo(o.getVersion()); } 
public boolean hasInDistro ( Artifact artifact ) throws Exception { return scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & aids . scalaDistroArtifactIds ( ) . contains ( artifact . getArtifactId ( ) ) ; 
public Set < Artifact > findLibraryAndDependencies ( ) throws Exception { return mavenArtifactResolver . getJarAndDependencies ( scalaOrganization , aids . scalaLibraryArtifactId ( ) , scalaVersion . toString ( ) , null ) ; 
public Set < Artifact > findCompilerAndDependencies ( ) throws Exception { return mavenArtifactResolver . getJarAndDependencies ( scalaOrganization , aids . scalaCompilerArtifactId ( ) , scalaVersion . toString ( ) , null ) ; 
public boolean include ( Artifact artifact ) { try { return scalaContext . hasInDistro ( artifact ) ; 
public void max ( ) throws Exception { assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.2-rc1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.8 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( new VersionNumber ( " 3.0 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 3.0 " ) ) ) ; 
private Set < File > setupClassPathForConsole ( final VersionNumber scalaVersion ) throws Exception { final Set < File > classpath = new TreeSet < File > ( ) ; classpath . addAll ( this . setupProjectClasspaths ( ) ) ; classpath . addAll ( this . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < File > setupConsoleClasspaths ( final VersionNumber scalaVersion ) throws Exception { final Set < File > classpath = new TreeSet < File > ( ) ; Artifact a = this . resolveJLine ( this . fallbackJLine ( scalaVersion ) ) ; addToClasspath ( a . getGroupId ( ) , a . getArtifactId ( ) , a . getVersion ( ) , a . getClassifier ( ) , classpath , true ) ; return classpath ; } 
private Set < File > getCompilerPlugins ( ) throws Exception { Set < File > plugins = new TreeSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < File > ignoreClasspath = new TreeSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . toString ( ) ) ; TODO - Ensure proper scala version for plugins Set<File> pluginClassPath = new TreeSet<>(); addToClasspath( artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<File> classpath = new TreeSet<File>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
protected Set < File > getClasspathElements ( ) throws Exception { Set < File > back = FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ; back . remove ( new File ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ) ; addAdditionalDependencies ( back ) ; return back ; } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { Context sc = findScalaContext ( ) ; return getScalaCommand ( fork , sc . compilerMainClassName ( scalaClassName , false ) ) ; } 
protected void doExecute ( ) throws Exception { Context sc = findScalaContext ( ) ; Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, sc.consoleMainClassName(mainConsole)); Determine Scala Version final VersionNumber scalaVersion = super.findScalaContext().version(); final Set<File> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = FileUtils.toMultiPath(classpath); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
protected JavaMainCaller getScalaCommand ( ) throws Exception { Context sc = findScalaContext ( ) ; JavaMainCaller jcmd = getScalaCommand ( fork , sc . compilerMainClassName ( scalaClassName , useFsc ) ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " -verbose " , true ) ; } return jcmd ; } 
protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( ! testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } List < String > testSources = new ArrayList < > ( project . getTestCompileSourceRoots ( ) ) ; testSources . add ( FileUtils . pathOf ( testSourceDir , useCanonicalPath ) ) ; List < File > testSourceDirs = normalize ( testSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & recompileMode ! = RecompileMode . incremental ) { getLog ( ) . info ( " use fsc for compilation " ) ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
List < String > scalaDistroArtifactIds ( ) throws Exception ; String scalaLibraryArtifactId ( ) throws Exception ; String scalaCompilerArtifactId ( ) throws Exception ; String compilerMainClassName ( boolean useFsc ) throws Exception ; String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( VersionNumber sv ) throws Exception ; } 
String scalaLibraryArtifactId ( ) throws Exception ; String scalaCompilerArtifactId ( ) throws Exception ; String compilerMainClassName ( boolean useFsc ) throws Exception ; String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( VersionNumber sv ) throws Exception ; } 
String scalaCompilerArtifactId ( ) throws Exception ; String compilerMainClassName ( boolean useFsc ) throws Exception ; String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( VersionNumber sv ) throws Exception ; } 
String compilerMainClassName ( boolean useFsc ) throws Exception ; String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( VersionNumber sv ) throws Exception ; } 
String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( VersionNumber sv ) throws Exception ; } 
public String compilerMainClassName ( boolean useFsc ) throws Exception { return useFsc ? " scala.tools.nsc.CompileClient " : " scala.tools.nsc.Main " ; } 
public String consoleMainClassName ( ) throws Exception { return " scala.tools.nsc.MainGenericRunner " ; } 
public String apidocMainClassName ( VersionNumber sv ) throws Exception { boolean isPreviousScala271 = ( new VersionNumber ( " 2.7.1 " ) . compareTo ( sv ) > 0 & & ! sv . isZero ( ) ) ; if ( ! isPreviousScala271 ) { return " scala.tools.nsc.ScalaDoc " ; 
public String compilerMainClassName ( boolean useFsc ) throws Exception { return " dotty.tools.dotc.Main " ; } 
public String consoleMainClassName ( ) throws Exception { return "dotty.tools.dotc.Run"; return "dotty.tools.repl.Main"; } 
public String apidocMainClassName ( VersionNumber sv ) throws Exception { return " dotty.tools.dotc.Main " ; } 
boolean hasInDistro ( Artifact artifact ) throws Exception ; VersionNumber version ( ) ; VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) throws Exception ; Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; String compilerMainClassName ( String override , boolean useFsc ) throws Exception ; String consoleMainClassName ( String override ) throws Exception ; String apidocMainClassName ( String override ) throws Exception ; } 
VersionNumber version ( ) ; VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) throws Exception ; Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; String compilerMainClassName ( String override , boolean useFsc ) throws Exception ; String consoleMainClassName ( String override ) throws Exception ; String apidocMainClassName ( String override ) throws Exception ; } 
VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) throws Exception ; Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; String compilerMainClassName ( String override , boolean useFsc ) throws Exception ; String consoleMainClassName ( String override ) throws Exception ; String apidocMainClassName ( String override ) throws Exception ; } 
Set < Artifact > findLibraryAndDependencies ( ) throws Exception ; Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; String compilerMainClassName ( String override , boolean useFsc ) throws Exception ; String consoleMainClassName ( String override ) throws Exception ; String apidocMainClassName ( String override ) throws Exception ; } 
Set < Artifact > findCompilerAndDependencies ( ) throws Exception ; String compilerMainClassName ( String override , boolean useFsc ) throws Exception ; String consoleMainClassName ( String override ) throws Exception ; String apidocMainClassName ( String override ) throws Exception ; } 
String compilerMainClassName ( String override , boolean useFsc ) throws Exception ; String consoleMainClassName ( String override ) throws Exception ; String apidocMainClassName ( String override ) throws Exception ; } 
String consoleMainClassName ( String override ) throws Exception ; String apidocMainClassName ( String override ) throws Exception ; } 
public String compilerMainClassName ( String override , boolean useFsc ) throws Exception { if ( StringUtils . isEmpty ( override ) ) { return this . aids . compilerMainClassName ( useFsc ) ; 
public String consoleMainClassName ( String override ) throws Exception { if ( StringUtils . isEmpty ( override ) ) { return this . aids . consoleMainClassName ( ) ; 
public String apidocMainClassName ( String override ) throws Exception { if ( StringUtils . isEmpty ( override ) ) { return this . aids . apidocMainClassName ( this . scalaVersion ) ; 
public boolean canGenerateReport ( ) { return findSourceFiles ( ) . size ( ) ! = 0 ; } 
List < String > scalaDistroArtifactIds ( ) throws Exception ; String scalaLibraryArtifactId ( ) throws Exception ; String scalaCompilerArtifactId ( ) throws Exception ; String compilerMainClassName ( boolean useFsc ) throws Exception ; String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( ) throws Exception ; } 
String scalaLibraryArtifactId ( ) throws Exception ; String scalaCompilerArtifactId ( ) throws Exception ; String compilerMainClassName ( boolean useFsc ) throws Exception ; String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( ) throws Exception ; } 
String scalaCompilerArtifactId ( ) throws Exception ; String compilerMainClassName ( boolean useFsc ) throws Exception ; String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( ) throws Exception ; } 
String compilerMainClassName ( boolean useFsc ) throws Exception ; String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( ) throws Exception ; } 
String consoleMainClassName ( ) throws Exception ; String apidocMainClassName ( ) throws Exception ; } 
public String apidocMainClassName ( ) throws Exception { return " scala.tools.nsc.ScalaDoc " ; } 
public String apidocMainClassName ( ) throws Exception { return " dotty.tools.dotc.Main " ; } 
public String apidocMainClassName ( String override ) throws Exception { if ( StringUtils . isEmpty ( override ) ) { return this . aids . apidocMainClassName ( ) ; 
public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( skipMain ) { getLog ( ) . info ( " Not compiling main sources " ) ; return ; } super . execute ( ) ; } 
public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( skip ) { getLog ( ) . info ( " Not compiling test sources " ) ; return ; } super . execute ( ) ; } 
public Context findScalaContext ( ) throws Exception { reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be stateless) if (scalaContext == null) { VersionNumber scalaVersion = findScalaVersion(); ArtifactIds aids = scalaVersion.major == 3 ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2(); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : scalaVersion; if (requiredScalaVersion.compareTo(scalaVersion) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", scalaVersion, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } scalaContext = StringUtils.isNotEmpty(scalaHome) ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome)) : new Context4ScalaRemote( scalaVersion, requiredScalaVersion, aids, scalaOrganization, findMavenArtifactResolver()); } return scalaContext; } 
protected List < String > getScalaOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( scalacTarget ! = null & & ! scalacTarget . isEmpty ( ) ) { options . add ( " -target: " + scalacTarget ) ; } if ( scalacRelease ! = null & & ! scalacRelease . isEmpty ( ) ) { options . add ( " -release " ) ; options . add ( scalacRelease ) ; } return options ; } 
protected List < String > getScalaOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( target ! = null & & ! target . isEmpty ( ) ) { options . add ( " -target: " + target ) ; } if ( release ! = null & & ! release . isEmpty ( ) ) { options . add ( " -release " ) ; options . add ( release ) ; } return options ; } 
public Context findScalaContext ( ) throws Exception { reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be stateless) if (scalaContext == null) { VersionNumber scalaVersion = findScalaVersion(); ArtifactIds aids = scalaVersion.major == 3 ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2(); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : scalaVersion; if (requiredScalaVersion.compareTo(scalaVersion) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", scalaVersion, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } scalaContext = StringUtils.isNotEmpty(scalaHome) ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome)) : new Context4ScalaRemote( scalaVersion, requiredScalaVersion, aids, scalaOrganization, findMavenArtifactResolver()); } return scalaContext; } 
private VersionNumber findScalaVersion ( ) throws Exception { if ( detectedScalaVersion = = null ) { detectedScalaVersion = findScalaVersion0 ( ) ; } return detectedScalaVersion ; } 
private int incrementalCompile ( Set < File > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { Context sc = findScalaContext(); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); ScalaInstance instance = makeScalaInstance(sc); incremental = new SbtIncrementalCompiler( javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder, instance); } classpathElements.remove(outputDir); List<String> scalacOptions = getScalacOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile( classpathElements.stream().map(File::toPath).collect(Collectors.toSet()), sources.stream().map(File::toPath).collect(Collectors.toList()), outputDir.toPath(), scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected List < String > getScalacOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( target ! = null & & ! target . isEmpty ( ) ) { options . add ( " -target: " + target ) ; } if ( release ! = null & & ! release . isEmpty ( ) ) { options . add ( " -release " ) ; options . add ( release ) ; } return options ; } 
static String targetOption ( String target , VersionNumber scalaVersion ) { if ( scalaVersion . major = = 2 ) { if ( scalaVersion . minor < = 12 ) { if ( target . equals ( " 1.5 " ) | | target . equals ( " 5 " ) ) { return " jvm-1.5 " ; } else if ( target . equals ( " 1.6 " ) | | target . equals ( " 6 " ) ) { return " jvm-1.6 " ; } else if ( target . equals ( " 1.7 " ) | | target . equals ( " 7 " ) ) { return " jvm-1.7 " ; } else if ( target . equals ( " 1.8 " ) | | target . equals ( " 8 " ) ) { return " jvm-1.8 " ; } else { invalid or unsupported option, just ignore return null; } } else if (target.equals("1.5")) { return "5"; } else if (target.equals("1.6")) { return "6"; } else if (target.equals("1.7")) { return "7"; } else if (target.equals("1.8")) { return "8"; } } return target; } 
protected List < String > getScalacOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( target ! = null & & ! target . isEmpty ( ) ) { String targetOption = targetOption ( target , findScalaVersion ( ) ) ; if ( targetOption ! = null ) { options . add ( " -target: " + targetOption ) ; } } if ( release ! = null & & ! release . isEmpty ( ) ) { options . add ( " -release " ) ; options . add ( release ) ; } return options ; } 
public void scala2_11_should_generate_prefixed_target ( ) { assertEquals ( " jvm-1.5 " , ScalaMojoSupport . targetOption ( " 1.5 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.5 " , ScalaMojoSupport . targetOption ( " 5 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.6 " , ScalaMojoSupport . targetOption ( " 1.6 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.6 " , ScalaMojoSupport . targetOption ( " 6 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.7 " , ScalaMojoSupport . targetOption ( " 1.7 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.7 " , ScalaMojoSupport . targetOption ( " 7 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.8 " , ScalaMojoSupport . targetOption ( " 1.8 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.8 " , ScalaMojoSupport . targetOption ( " 8 " , new VersionNumber ( " 2.11.12 " ) ) ) ; } 
public void scala2_11_should_generate_null_for_unsupported_java_versions ( ) { assertNull ( ScalaMojoSupport . targetOption ( " 11 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertNull ( ScalaMojoSupport . targetOption ( " 17 " , new VersionNumber ( " 2.11.12 " ) ) ) ; } 
public void scala2_12_should_generate_prefixed_target ( ) { assertEquals ( " jvm-1.5 " , ScalaMojoSupport . targetOption ( " 1.5 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.5 " , ScalaMojoSupport . targetOption ( " 5 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.6 " , ScalaMojoSupport . targetOption ( " 1.6 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.6 " , ScalaMojoSupport . targetOption ( " 6 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.7 " , ScalaMojoSupport . targetOption ( " 1.7 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.7 " , ScalaMojoSupport . targetOption ( " 7 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.8 " , ScalaMojoSupport . targetOption ( " 1.8 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.8 " , ScalaMojoSupport . targetOption ( " 8 " , new VersionNumber ( " 2.12.11 " ) ) ) ; } 
public void scala2_12_should_generate_null_for_unsupported_java_versions ( ) { assertNull ( ScalaMojoSupport . targetOption ( " 11 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertNull ( ScalaMojoSupport . targetOption ( " 17 " , new VersionNumber ( " 2.12.11 " ) ) ) ; } 
public void scala2_13_should_generate_non_prefixed_target ( ) { assertEquals ( " 5 " , ScalaMojoSupport . targetOption ( " 1.5 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 5 " , ScalaMojoSupport . targetOption ( " 5 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 6 " , ScalaMojoSupport . targetOption ( " 1.6 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 6 " , ScalaMojoSupport . targetOption ( " 6 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 7 " , ScalaMojoSupport . targetOption ( " 1.7 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 7 " , ScalaMojoSupport . targetOption ( " 7 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 8 " , ScalaMojoSupport . targetOption ( " 1.8 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 8 " , ScalaMojoSupport . targetOption ( " 8 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 11 " , ScalaMojoSupport . targetOption ( " 11 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 17 " , ScalaMojoSupport . targetOption ( " 17 " , new VersionNumber ( " 2.13.8 " ) ) ) ; } 
protected List < String > getScalacOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( target ! = null & & ! target . isEmpty ( ) ) { String targetOption = targetOption ( target , findScalaVersion ( ) ) ; if ( targetOption ! = null ) { options . add ( " -target: " + targetOption ) ; } } if ( release ! = null & & ! release . isEmpty ( ) ) { VersionNumber scalaVersion = findScalaVersion ( ) ; if ( scalaVersion . major > 2 | | ( scalaVersion . major = = 2 & & scalaVersion . minor > = 12 ) ) { options . add ( " -release " ) ; options . add ( release ) ; } } return options ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < File > classpathElements , boolean compileInLoop ) throws Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile( classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfulTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfulTS(t1); } return retCode; } getLog() .info( String.format( "Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", FileUtils.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } try { if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfulTS(t1); } else { compileErrors = true; } } catch (Exception e) { compileErrors = true; getLog().error("exception compilation error occurred!!!", e); } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
void setLastSuccessfulTS ( long v ) throws Exception { if ( ! _lastCompileAtFile . exists ( ) ) { FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) throws IOException { if ( toolchain ! = null ) { String fromToolChain = toolchain . findTool ( " java " ) ; if ( fromToolChain ! = null ) { return fromToolChain ; } } String javaCommand = " java " + ( IS_WINDOWS ? " .exe " : " " ) ; String javaHomeSystemProperty = System . getProperty ( " java.home " ) ; if ( javaHomeSystemProperty ! = null ) { if ( javaHomeSystemProperty . endsWith ( File . separator + " jre " ) ) { Old JDK versions contain a JRE. We might be pointing to that. We want to try to use the JDK instead as we need javac in order to compile mixed Java-Scala projects. File javaExecFile = new File(javaHomeSystemProperty + File.separator + ".." + File.separator + "bin", javaCommand); if (javaExecFile.isFile()) { getCanonicalPath to get rid of ".." return javaExecFile.getCanonicalPath(); } } old standalone JRE or modern JDK File javaExecFile = new File(javaHomeSystemProperty + File.separator + "bin", javaCommand); if (javaExecFile.isFile()) { return javaExecFile.getAbsolutePath(); } else { throw new IllegalStateException("Couldn't locate java in defined java.home system property."); } } fallback: try to resolve from JAVA_HOME String javaHomeEnvVar = System.getenv("JAVA_HOME"); if (javaHomeEnvVar == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } File javaExecFile = new File(javaHomeEnvVar + File.separator + "bin", javaCommand); if (javaExecFile.isFile()) { return javaExecFile.getAbsolutePath(); 
public static File findHomeFromToolchain ( Toolchain toolchain ) throws IOException { String executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; } 
public void shouldReturnNotNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) throws IOException { Toolchain toolchain = new ReturningToolChain ( null ) ; assertNotNull ( JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) throws Exception { Toolchain toolchain = new ReturningToolChain ( " my-path-to-java " ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
public void shouldThrowExceptionWhenNothingCouldBeFound ( ) throws IOException { Toolchain toolchain = new ReturningToolChain ( null ) ; System . clearProperty ( " java.home " ) ; environmentVariables . set ( " JAVA_HOME " , null ) ; try { JavaLocator . findExecutableFromToolchain ( toolchain ) ; 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) throws IOException { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " parent/child/my-path-to-java " ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) throws IOException { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " my-path-to-java " ) ) ; assertNull ( home ) ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { if ( toolchain ! = null ) { String fromToolChain = toolchain . findTool ( " java " ) ; if ( fromToolChain ! = null ) { return fromToolChain ; } } String javaCommand = " java " + ( IS_WINDOWS ? " .exe " : " " ) ; String javaHomeSystemProperty = System . getProperty ( " java.home " ) ; if ( javaHomeSystemProperty ! = null ) { Path javaHomePath = Paths . get ( javaHomeSystemProperty ) ; if ( javaHomePath . endsWith ( " jre " ) ) { Old JDK versions contain a JRE. We might be pointing to that. We want to try to use the JDK instead as we need javac in order to compile mixed Java-Scala projects. Path javaExecPath = javaHomePath.resolveSibling("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); } } old standalone JRE or modern JDK Path javaExecPath = javaHomePath.resolve("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); } else { throw new IllegalStateException("Couldn't locate java in defined java.home system property."); } } fallback: try to resolve from JAVA_HOME String javaHomeEnvVar = System.getenv("JAVA_HOME"); if (javaHomeEnvVar == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } Path javaExecPath = Paths.get(javaHomeEnvVar).resolve("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); 
public void shouldReturnNotNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain toolchain = new ReturningToolChain ( null ) ; assertNotNull ( JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) { Toolchain toolchain = new ReturningToolChain ( " my-path-to-java " ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( toolchain ) ) ; } 
public void shouldThrowExceptionWhenNothingCouldBeFound ( ) { Toolchain toolchain = new ReturningToolChain ( null ) ; System . clearProperty ( " java.home " ) ; environmentVariables . set ( " JAVA_HOME " , null ) ; try { JavaLocator . findExecutableFromToolchain ( toolchain ) ; 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " parent/child/my-path-to-java " ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " my-path-to-java " ) ) ; assertNull ( home ) ; } 
public static String findExecutableFromToolchain ( Toolchain toolchain ) { if ( toolchain ! = null ) { String fromToolChain = toolchain . findTool ( " java " ) ; if ( fromToolChain ! = null ) { return fromToolChain ; } } String javaCommand = " java " + ( IS_WINDOWS ? " .exe " : " " ) ; String javaHomeSystemProperty = System . getProperty ( " java.home " ) ; if ( javaHomeSystemProperty ! = null ) { Path javaHomePath = Paths . get ( javaHomeSystemProperty ) ; if ( javaHomePath . endsWith ( " jre " ) ) { Old JDK versions contain a JRE. We might be pointing to that. We want to try to use the JDK instead as we need javac in order to compile mixed Java-Scala projects. Path javaExecPath = javaHomePath.resolveSibling("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); } } old standalone JRE or modern JDK Path javaExecPath = javaHomePath.resolve("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); } else { throw new IllegalStateException( "Couldn't locate java in defined java.home system property."); } } fallback: try to resolve from JAVA_HOME String javaHomeEnvVar = System.getenv("JAVA_HOME"); if (javaHomeEnvVar == null) { throw new IllegalStateException( "Couldn't locate java, try setting JAVA_HOME environment variable."); } Path javaExecPath = Paths.get(javaHomeEnvVar).resolve("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); 
protected List < String > getScalacOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; VersionNumber scalaVersion = findScalaVersion ( ) ; boolean targetIsDefined = StringUtils . isNotEmpty ( target ) ; boolean releaseIsDefined = StringUtils . isNotEmpty ( release ) ; boolean targetIsDeprecated = scalaVersion . compareTo ( new VersionNumber ( " 2.13.9 " ) ) > = 0 ; boolean releaseIsSupported = scalaVersion . compareTo ( new VersionNumber ( " 2.12.0 " ) ) > = 0 ; target's default is "maven.compiler.target"'s default, which is 1.8 if (targetIsDefined) { String targetOption = targetOption(target, scalaVersion); if (targetOption != null) { if (!targetIsDeprecated) { options.add("-target:" + targetOption); } else if (!releaseIsDefined) { -target is deprecated in favor of -release no user-defined release specified set release instead, so we don't get a deprecation warning options.add("-release"); options.add(targetOption); } } } release's default is "maven.compiler.release"'s default, which is null if (releaseIsDefined && releaseIsSupported) { options.add("-release"); options.add(release); } return options; } 
public static String toClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new ArrayList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . toString ( ) ; } 
private Set < Artifact > resolve ( Artifact artifact , boolean transitively ) { ArtifactResolutionRequest request = new ArtifactResolutionRequest ( ) . setArtifact ( artifact ) . setResolveRoot ( true ) . setResolveTransitively ( transitively ) . setServers ( session . getRequest ( ) . getServers ( ) ) . setMirrors ( session . getRequest ( ) . getMirrors ( ) ) . setProxies ( session . getRequest ( ) . getProxies ( ) ) . setLocalRepository ( session . getLocalRepository ( ) ) . setRemoteRepositories ( session . getCurrentProject ( ) . getRemoteArtifactRepositories ( ) ) ; return repositorySystem . resolve ( request ) . getArtifacts ( ) . stream ( ) . filter ( art - > ! Artifact . SCOPE_TEST . equals ( art . getScope ( ) ) ) 
private Artifact resolveJLine ( final Artifact defaultFallback ) throws Exception { final Set < Artifact > compilerDeps = findScalaContext ( ) . findCompilerAndDependencies ( ) ; for ( final Artifact a : compilerDeps ) { if ( filterForJline ( a ) ) { return a ; } } getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . toString ( ) ) ) ; return defaultFallback ; } 
static File getCompiledBridgeJar ( VersionNumber scalaVersion , ScalaInstance scalaInstance , File secondaryCacheDir , MavenArtifactResolver resolver , Log mavenLogger ) throws Exception { eg org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar String bridgeArtifactId = compilerBridgeArtifactId(scalaVersion.toString()); if (secondaryCacheDir == null) { secondaryCacheDir = DEFAULT_SECONDARY_CACHE_DIR; } secondaryCacheDir.mkdirs(); return scalaVersion.major == 3 ? getScala3CompilerBridgeJar(scalaVersion, bridgeArtifactId, resolver) 
private static String compilerBridgeArtifactId ( String scalaVersion ) { if ( scalaVersion . startsWith ( " 2.10. " ) ) { return " compiler-bridge_2.10 " ; 
private static File getScala3CompilerBridgeJar ( VersionNumber scalaVersion , String bridgeArtifactId , MavenArtifactResolver resolver ) { return resolver . getJar ( SBT_GROUP_ID_SCALA3 , bridgeArtifactId , scalaVersion . toString ( ) , " " ) 
private static List < Tuple2 < File , String > > computeZipEntries ( List < Path > paths , Path rootDir ) { int rootDirLength = rootDir . toString ( ) . length ( ) ; Stream < Tuple2 < File , String > > stream = paths . stream ( ) . map ( path - > { String zipPath = path . toString ( ) . substring ( rootDirLength + 1 ) . replace ( File . separator , " / " ) ; if ( Files . isDirectory ( path ) ) { zipPath = zipPath + " / " ; } return new Tuple2 < > ( path . toFile ( ) , zipPath ) ; } ) ; return stream . collect ( Collectors . toList ( ) ) ; } 
private < T > void writeCollection ( List < String > args , Collection < T > collection , Function < T , String > f ) { args . add ( String . valueOf ( collection . size ( ) ) ) ; for ( T entry : collection ) { args . add ( f . apply ( entry ) ) ; 
public String [ ] generateArgs ( ) { List < String > args = new ArrayList < > ( ) ; args . add ( javaHome . toString ( ) ) ; args . add ( cacheFile . getPath ( ) ) ; args . add ( compileOrder . name ( ) ) ; args . add ( compilerBridgeJar . getPath ( ) ) ; args . add ( scalaVersion ) ; writeCollection ( args , compilerAndDependencies , File : : getPath ) ; writeCollection ( args , libraryAndDependencies , File : : getPath ) ; writeCollection ( args , classpathElements , File : : getPath ) ; writeCollection ( args , sources , File : : getPath ) ; args . add ( classesDirectory . toString ( ) ) ; writeCollection ( args , scalacOptions , Function . identity ( ) ) ; writeCollection ( args , javacOptions , Function . identity ( ) ) ; args . add ( String . valueOf ( debugEnabled ) ) ; return args . toArray ( new String [ ] { } ) ; } 
private static < T > List < T > readList ( String [ ] args , AtomicInteger index , Function < String , T > f ) { int size = Integer . parseInt ( args [ index . getAndIncrement ( ) ] ) ; List < T > list = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i + + ) { list . add ( f . apply ( args [ index . getAndIncrement ( ) ] ) ) ; } return list ; } 
static Args parseArgs ( String [ ] args ) { AtomicInteger index = new AtomicInteger ( ) ; File javaHome = new File ( args [ index . getAndIncrement ( ) ] ) ; File cacheFile = new File ( args [ index . getAndIncrement ( ) ] ) ; CompileOrder compileOrder = CompileOrder . valueOf ( args [ index . getAndIncrement ( ) ] ) ; File compilerBridgeJar = new File ( args [ index . getAndIncrement ( ) ] ) ; String scalaVersion = args [ index . getAndIncrement ( ) ] ; List < File > compilerAndDependencies = readList ( args , index , File : : new ) ; List < File > libraryAndDependencies = readList ( args , index , File : : new ) ; List < File > classpathElements = readList ( args , index , File : : new ) ; List < File > sources = readList ( args , index , File : : new ) ; File classesDirectory = new File ( args [ index . getAndIncrement ( ) ] ) ; List < String > scalacOptions = readList ( args , index , Function . identity ( ) ) ; List < String > javacOptions = readList ( args , index , Function . identity ( ) ) ; boolean debugEnabled = Boolean . parseBoolean ( args [ index . getAndIncrement ( ) ] ) ; return new Args ( javaHome , 
public static void main ( String [ ] args ) { Args parsedArgs = Args . parseArgs ( args ) ; Logger sbtLogger = new Logger ( ) { @Override public void log ( Enumeration . Value level , Function0 < String > message ) { ForkLogLevel forkLogLevel = null ; if ( level . equals ( Level . Error ( ) ) ) { forkLogLevel = ForkLogLevel . ERROR ; } else if ( level . equals ( Level . Warn ( ) ) ) { forkLogLevel = ForkLogLevel . WARN ; } else if ( level . equals ( Level . Info ( ) ) ) { forkLogLevel = ForkLogLevel . INFO ; } else if ( level . equals ( Level . Debug ( ) ) & & parsedArgs . debugEnabled ) { forkLogLevel = ForkLogLevel . DEBUG ; } if ( forkLogLevel ! = null ) { System . out . println ( forkLogLevel . addHeader ( message . apply ( ) ) ) ; } } @Override public void success ( Function0 < String > message ) { log ( Level . Info ( ) , message ) ; } @Override public void trace ( Function0 < Throwable > ) { } } ; ScalaInstance scalaInstance = ScalaInstances . makeScalaInstance ( parsedArgs . scalaVersion , parsedArgs . compilerAndDependencies , parsedArgs . libraryAndDependencies ) ; SbtIncrementalCompiler incrementalCompiler = SbtIncrementalCompilers . makeInProcess ( parsedArgs . javaHome , parsedArgs . cacheFile , parsedArgs . compileOrder , scalaInstance , parsedArgs . compilerBridgeJar , sbtLogger ) ; incrementalCompiler . compile ( parsedArgs . classpathElements , 
public void log ( Enumeration . Value level , Function0 < String > message ) { ForkLogLevel forkLogLevel = null ; if ( level . equals ( Level . Error ( ) ) ) { forkLogLevel = ForkLogLevel . ERROR ; } else if ( level . equals ( Level . Warn ( ) ) ) { forkLogLevel = ForkLogLevel . WARN ; } else if ( level . equals ( Level . Info ( ) ) ) { forkLogLevel = ForkLogLevel . INFO ; } else if ( level . equals ( Level . Debug ( ) ) & & parsedArgs . debugEnabled ) { forkLogLevel = ForkLogLevel . DEBUG ; } if ( forkLogLevel ! = null ) { System . out . println ( forkLogLevel . addHeader ( message . apply ( ) ) ) ; 
public void success ( Function0 < String > message ) { log ( Level . Info ( ) , message ) ; } 
public void trace ( Function0 < Throwable > ) { } } ; ScalaInstance scalaInstance = ScalaInstances . makeScalaInstance ( parsedArgs . scalaVersion , parsedArgs . compilerAndDependencies , parsedArgs . libraryAndDependencies ) ; SbtIncrementalCompiler incrementalCompiler = SbtIncrementalCompilers . makeInProcess ( parsedArgs . javaHome , parsedArgs . cacheFile , parsedArgs . compileOrder , scalaInstance , parsedArgs . compilerBridgeJar , sbtLogger ) ; incrementalCompiler . compile ( parsedArgs . classpathElements , parsedArgs . sources , parsedArgs . classesDirectory , parsedArgs . scalacOptions , parsedArgs . javacOptions ) ; } } 
void compile ( Collection < File > classpathElements , Collection < File > sources , File classesDirectory , Collection < String > scalacOptions , Collection < String > javacOptions ) ; } 
public static SbtIncrementalCompiler make ( File javaHome , MavenArtifactResolver resolver , File secondaryCacheDir , Log mavenLogger , File cacheFile , CompileOrder compileOrder , VersionNumber scalaVersion , Collection < File > compilerAndDependencies , Collection < File > libraryAndDependencies , String [ ] jvmArgs , File javaExec , List < File > forkBootClasspath ) throws Exception { ScalaInstance scalaInstance = ScalaInstances . makeScalaInstance ( scalaVersion . toString ( ) , compilerAndDependencies , libraryAndDependencies ) ; File compilerBridgeJar = CompilerBridgeFactory . getCompiledBridgeJar ( scalaVersion , scalaInstance , secondaryCacheDir , resolver , mavenLogger ) ; if ( jvmArgs = = null | | jvmArgs . length = = 0 ) { return makeInProcess ( 
static SbtIncrementalCompiler makeInProcess ( File javaHome , File cacheFile , CompileOrder compileOrder , ScalaInstance scalaInstance , File compilerBridgeJar , Logger sbtLogger ) { Compilers compilers = makeCompilers ( scalaInstance , javaHome , compilerBridgeJar ) ; AnalysisStore analysisStore = AnalysisStore . getCachedStore ( FileAnalysisStore . binary ( cacheFile ) ) ; Setup setup = makeSetup ( cacheFile , sbtLogger ) ; IncrementalCompiler compiler = ZincUtil . defaultIncrementalCompiler ( ) ; return new InProcessSbtIncrementalCompiler ( compilers , analysisStore , setup , compiler , compileOrder , sbtLogger ) ; 
private static SbtIncrementalCompiler makeForkedProcess ( File javaHome , File cacheFile , CompileOrder compileOrder , File compilerBridgeJar , VersionNumber scalaVersion , Collection < File > compilerAndDependencies , Collection < File > libraryAndDependencies , Log mavenLogger , String [ ] jvmArgs , File javaExec , List < File > pluginArtifacts ) { List < String > forkClasspath = pluginArtifacts . stream ( ) . map ( File : : getPath ) . collect ( Collectors . toList ( ) ) ; return ( classpathElements , sources , classesDirectory , scalacOptions , javacOptions ) - > { try { 
public void onException ( Exception ) { mavenLogger . error ( ) ; } 
public void onError ( String content ) { mavenLogger . error ( content ) ; } 
public void onWarn ( String content ) { mavenLogger . warn ( content ) ; } 
public void onInfo ( String content ) { mavenLogger . info ( content ) ; } 
public void onDebug ( String content ) { mavenLogger . debug ( content ) ; } 
protected void processLine ( String line , int level ) { forkLogger . processLine ( line ) ; } 
public void close ( ) throws IOException { forkLogger . forceNextLineToFlush ( ) ; super . close ( ) ; } 
private static Compilers makeCompilers ( ScalaInstance scalaInstance , File javaHome , File compilerBridgeJar ) { ScalaCompiler scalaCompiler = new AnalyzingCompiler ( scalaInstance , scalaInstance ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), provider ClasspathOptionsUtil.auto(), classpathOptions new FunctionWrappers.FromJavaConsumer<>(noop -> {}), onArgsHandler Option.apply(null) classLoaderCache ); return ZincUtil.compilers( scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome.toPath()), scalaCompiler); 
public DefinesClass definesClass ( VirtualFile classpathEntry ) { return classpathEntry . name ( ) . equals ( " rt.jar " ) ? className - > false 
void setLastSuccessfulTS ( long v ) throws Exception { if ( ! _lastCompileAtFile . exists ( ) ) { org . codehaus . plexus . util . FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
private int incrementalCompile ( Set < File > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) throws Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { Context sc = findScalaContext(); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = SbtIncrementalCompilers.make( javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder, sc.version(), sc.findCompilerAndDependencies().stream() .map(Artifact::getFile) .collect(Collectors.toList()), sc.findLibraryAndDependencies().stream() .map(Artifact::getFile) .collect(Collectors.toList()), jvmArgs, JavaLocator.findExecutableFromToolchain(getToolchain()), pluginArtifacts.stream().map(Artifact::getFile).collect(Collectors.toList())); } try { incremental.compile( classpathElements, sources, outputDir, getScalacOptions(), getJavacOptions()); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void postCompileActions ( ) throws Exception { } private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; org . codehaus . plexus . util . FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; org . codehaus . plexus . util . FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) throws Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog() .info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if (forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for (String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork( getLog(), mainClass, cp, null, null, forceUseArgFile, JavaLocator.findExecutableFromToolchain(getToolchain())); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(getLog(), mainClass, toolcp, null, null); } return cmd; } 
protected void doExecute ( ) throws Exception { JavaMainCaller jcmd = null ; File javaExec = JavaLocator . findExecutableFromToolchain ( getToolchain ( ) ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( getLog ( ) , mainClass , FileUtils . toMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , jvmArgs , args , forceUseArgFile , javaExec ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( getLog ( ) , launchers [ i ] . mainClass , FileUtils . toMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , javaExec ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( getLog ( ) , launchers [ 0 ] . mainClass , FileUtils . toMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , javaExec ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) throws Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<File> classpath = new TreeSet<>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private static String toWindowsShortName ( String value ) { if ( IS_WINDOWS ) { int programFilesIndex = value . indexOf ( " Program Files " ) ; if ( programFilesIndex > = 0 ) { Could be "Program Files" or "Program Files (x86)" int firstSeparatorAfterProgramFiles = value.indexOf(File.separator, programFilesIndex + "Program Files".length()); File longNameDir = firstSeparatorAfterProgramFiles < 0 ? new File(value) : C:\\Program Files with trailing separator new File(value.substring(0, firstSeparatorAfterProgramFiles)); chop child Some other sibling dir could be PrograXXX and might shift short name index so, we can't be sure "Program Files" is "Progra~1" and "Program Files (x86)" is "Progra~2" for (int i = 0; i < 10; i++) { File shortNameDir = new File(longNameDir.getParent(), "Progra~" + i); if (shortNameDir.equals(longNameDir)) { return shortNameDir.toString(); } } } } return value; } 
public void run ( OutputStream os ) throws Exception { File booterJar = createBooterJar ( classpath , ForkMain . class . getName ( ) , args ) ; CommandLine command = new CommandLine ( toWindowsShortName ( javaExecutable . getCanonicalPath ( ) ) ) ; command . addArguments ( jvmArgs , false ) ; command . addArgument ( " -jar " ) ; command . addArgument ( booterJar . getCanonicalPath ( ) ) ; command . addArgument ( mainClassName ) ; Executor exec = new DefaultExecutor ( ) ; exec . setStreamHandler ( new PumpStreamHandler ( os ) ) ; int exitValue = exec . execute ( command ) ; if ( exitValue ! = 0 ) { throw new MojoFailureException ( " command line returned non-zero value: " + exitValue ) ; 
private static File createBooterJar ( List < String > classPath , String startClassName , String [ ] args ) throws IOException { File file = File . createTempFile ( BOOTER_JAR_NAME , " .jar " ) ; file . deleteOnExit ( ) ; String cp = classPath . stream ( ) . map ( element - > getURL ( new File ( element ) ) . toExternalForm ( ) ) . collect ( Collectors . joining ( " " ) ) ; Manifest manifest = new Manifest ( ) ; manifest . getMainAttributes ( ) . putValue ( Attributes . Name . MANIFEST_VERSION . toString ( ) , " 1.0 " ) ; manifest . getMainAttributes ( ) . putValue ( Attributes . Name . MAIN_CLASS . toString ( ) , startClassName ) ; manifest . getMainAttributes ( ) . putValue ( Attributes . Name . CLASS_PATH . toString ( ) , cp ) ; try ( JarOutputStream jos = new JarOutputStream ( new BufferedOutputStream ( Files . newOutputStream ( file . toPath ( ) ) ) ) ) { jos . setLevel ( JarOutputStream . STORED ) ; JarEntry manifestJarEntry = new JarEntry ( " META-INF/MANIFEST.MF " ) ; jos . putNextEntry ( manifestJarEntry ) ; manifest . write ( jos ) ; jos . closeEntry ( ) ; JarEntry argsJarEntry = new JarEntry ( ForkMain . ARGS_FILE ) ; jos . putNextEntry ( argsJarEntry ) ; jos . write ( Arrays . stream ( args ) . collect ( Collectors . joining ( " " ) ) . getBytes ( StandardCharsets . UTF_8 ) ) ; jos . closeEntry ( ) ; } return file ; } 
public static ForkLogLevel level ( String line ) { if ( line . startsWith ( DEBUG . header ) ) { return DEBUG ; } else if ( line . startsWith ( INFO . header ) ) { return INFO ; } else if ( line . startsWith ( WARN . header ) ) { return WARN ; } else if ( line . startsWith ( ERROR . header ) ) { return ERROR ; } return null ; } 
public String removeHeader ( String line ) { return line . substring ( header . length ( ) ) ; } 
public abstract void onException ( Exception ) ; public abstract void onError ( String content ) ; public abstract void onWarn ( String content ) ; public abstract void onInfo ( String content ) ; public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . toString ( ) ) ; break ; case WARN : onWarn ( buffer . toString ( ) ) ; break ; case INFO : onInfo ( buffer . toString ( ) ) ; break ; case DEBUG : onDebug ( buffer . toString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { try { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = true ; } } 
public abstract void onError ( String content ) ; public abstract void onWarn ( String content ) ; public abstract void onInfo ( String content ) ; public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . toString ( ) ) ; break ; case WARN : onWarn ( buffer . toString ( ) ) ; break ; case INFO : onInfo ( buffer . toString ( ) ) ; break ; case DEBUG : onDebug ( buffer . toString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { try { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = true ; } } 
public abstract void onWarn ( String content ) ; public abstract void onInfo ( String content ) ; public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . toString ( ) ) ; break ; case WARN : onWarn ( buffer . toString ( ) ) ; break ; case INFO : onInfo ( buffer . toString ( ) ) ; break ; case DEBUG : onDebug ( buffer . toString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { try { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = true ; } } 
public abstract void onInfo ( String content ) ; public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . toString ( ) ) ; break ; case WARN : onWarn ( buffer . toString ( ) ) ; break ; case INFO : onInfo ( buffer . toString ( ) ) ; break ; case DEBUG : onDebug ( buffer . toString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { try { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = true ; } } 
public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . toString ( ) ) ; break ; case WARN : onWarn ( buffer . toString ( ) ) ; break ; case INFO : onInfo ( buffer . toString ( ) ) ; break ; case DEBUG : onDebug ( buffer . toString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { try { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = true ; } } 
private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { 
public final void processLine ( String line ) { try { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; 
public static void main ( String [ ] args ) { try { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
private static void runMain ( ClassLoader cl , String mainClassName , String [ ] args ) throws Exception { Class < ? > mainClass = cl . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( " main " , String [ ] . class ) ; int mods = mainMethod . getModifiers ( ) ; if ( mainMethod . getReturnType ( ) ! = void . class | | ! Modifier . isStatic ( mods ) | | ! Modifier . isPublic ( mods ) ) { throw new NoSuchMethodException ( " main " ) ; } mainMethod . invoke ( null , new Object [ ] { args } ) ; } 
private static String [ ] readArgFile ( ClassLoader cl ) throws IOException { List < String > args = new ArrayList < > ( ) ; try ( BufferedReader reader = new BufferedReader ( 
public boolean run ( boolean displayCmd , boolean throwFailure ) throws Exception { List < String > cmd = buildCommand ( ) ; displayCmd ( displayCmd , cmd ) ; Executor exec = new DefaultExecutor ( ) ; err and out are redirected to out if (!_redirectToLog) { exec.setStreamHandler(new PumpStreamHandler(System.out, System.err, System.in)); } else { exec.setStreamHandler( new PumpStreamHandler( new LogOutputStream() { private LevelState _previous = new LevelState(); @Override protected void processLine(String line, int level) { try { _previous = LogProcessorUtils.levelStateOf(line, _previous); switch (_previous.level) { case ERROR: mavenLogger.error(line); break; case WARNING: mavenLogger.warn(line); break; default: mavenLogger.info(line); } } catch (Exception e) { e.printStackTrace(); } } })); } CommandLine cl = new CommandLine(cmd.get(0)); for (int i = 1; i < cmd.size(); i++) { cl.addArgument(cmd.get(i), false); } try { int exitValue = exec.execute(cl); 
private void displayCmd ( boolean displayCmd , List < String > cmd ) { if ( displayCmd ) { mavenLogger . info ( " cmd: " + " " + StringUtils . join ( cmd . iterator ( ) , " " ) ) ; 
private List < String > buildCommand ( ) throws Exception { List < String > back = new ArrayList < > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec . getPath ( ) ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; mavenLogger . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back ; } 
private void runInternal ( boolean displayCmd ) throws Exception { String [ ] argArray = args . toArray ( new String [ ] { } ) ; if ( displayCmd ) { mavenLogger . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
public void redirectToLog ( ) { mavenLogger . warn ( " redirection to log is not supported for 'inProcess' mode " ) ; } 
public static String pathOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
public static File fileOf ( File f , boolean canonical ) throws Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
public static Set < File > fromStrings ( Collection < String > s ) { return s . stream ( ) . map ( File : : new ) . collect ( Collectors . toSet ( ) ) ; } 
public static String toMultiPath ( Collection < File > paths ) { return paths . stream ( ) . map ( File : : getPath ) . collect ( Collectors . joining ( File . pathSeparator ) ) ; } 
public static File findExecutableFromToolchain ( Toolchain toolchain ) { if ( toolchain ! = null ) { String fromToolChain = toolchain . findTool ( " java " ) ; if ( fromToolChain ! = null ) { return new File ( fromToolChain ) ; } } String javaCommand = " java " + ( IS_WINDOWS ? " .exe " : " " ) ; String javaHomeSystemProperty = System . getProperty ( " java.home " ) ; if ( javaHomeSystemProperty ! = null ) { Path javaHomePath = Paths . get ( javaHomeSystemProperty ) ; if ( javaHomePath . endsWith ( " jre " ) ) { Old JDK versions contain a JRE. We might be pointing to that. We want to try to use the JDK instead as we need javac in order to compile mixed Java-Scala projects. File javaExecPath = javaHomePath.resolveSibling("bin").resolve(javaCommand).toFile(); if (javaExecPath.isFile()) { return javaExecPath; } } old standalone JRE or modern JDK File javaExecPath = javaHomePath.resolve("bin").resolve(javaCommand).toFile(); if (javaExecPath.isFile()) { return javaExecPath; } else { throw new IllegalStateException( "Couldn't locate java in defined java.home system property."); } } fallback: try to resolve from JAVA_HOME String javaHomeEnvVar = System.getenv("JAVA_HOME"); if (javaHomeEnvVar == null) { throw new IllegalStateException( "Couldn't locate java, try setting JAVA_HOME environment variable."); } File javaExecPath = Paths.get(javaHomeEnvVar).resolve("bin").resolve(javaCommand).toFile(); if (javaExecPath.isFile()) { return javaExecPath; 
public static File findHomeFromToolchain ( Toolchain toolchain ) { File executable = findExecutableFromToolchain ( toolchain ) ; File executableParent = executable . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; } 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) { Toolchain toolchain = new ReturningToolChain ( " my-path-to-java " ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( toolchain ) . getPath ( ) ) ; } 
private static String computeTargetOption ( String target ) { if ( target . equals ( " 1.5 " ) | | target . equals ( " 5 " ) ) { return " jvm-1.5 " ; } else if ( target . equals ( " 1.6 " ) | | target . equals ( " 6 " ) ) { return " jvm-1.6 " ; } else if ( target . equals ( " 1.7 " ) | | target . equals ( " 7 " ) ) { return " jvm-1.7 " ; } else if ( target . equals ( " 1.8 " ) | | target . equals ( " 8 " ) ) { return " jvm-1.8 " ; } return null ; } 
private static String computeReleaseOptionFromTarget ( String target ) { if ( target . equals ( " 1.5 " ) ) { return " 5 " ; } else if ( target . equals ( " 1.6 " ) ) { return " 6 " ; } else if ( target . equals ( " 1.7 " ) ) { return " 7 " ; } else if ( target . equals ( " 1.8 " ) ) { return " 8 " ; } return target ; } 
static List < String > computeBytecodeVersionOptions ( String target , String release , VersionNumber scalaVersion ) { List < String > options = new ArrayList < > ( ) ; boolean targetIsDefined = StringUtils . isNotEmpty ( target ) ; boolean releaseIsDefined = StringUtils . isNotEmpty ( release ) ; boolean releaseIsSupported = scalaVersion . compareTo ( new VersionNumber ( " 2.12.0 " ) ) > = 0 ; String releaseOrJavaOutputVersionOptionName = scalaVersion . compareTo ( new VersionNumber ( " 3.1.2 " ) ) > = 0 ? " -java-output-version " : " -release " ; if ( releaseIsDefined & & releaseIsSupported ) { release's default is "maven.compiler.release"'s default, which is null options.add(releaseOrJavaOutputVersionOptionName); options.add(release); } else if (targetIsDefined) { target's default is "maven.compiler.target"'s default, which is 1.8 if (releaseIsSupported) { options.add(releaseOrJavaOutputVersionOptionName); options.add(computeReleaseOptionFromTarget(target)); } else { String correctTarget = computeTargetOption(target); if (correctTarget != null) { options.add("-target:" + correctTarget); } } } return options; } 
protected List < String > getScalacOptions ( ) throws Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; options . addAll ( computeBytecodeVersionOptions ( target , release , findScalaVersion ( ) ) ) ; return options ; } 
public void scala2_11_should_generate_prefixed_target ( ) { assertEquals ( asList ( " -target:jvm-1.5 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.5 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.5 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 5 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.6 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.6 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.6 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 6 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.7 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.7 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.7 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 7 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.8 " ) , 
public void scala2_11_should_generate_nothing_for_unsupported_java_versions ( ) { assertTrue ( ScalaMojoSupport . computeBytecodeVersionOptions ( " 11 " , null , new VersionNumber ( " 2.11.12 " ) ) . isEmpty ( ) ) ; assertTrue ( ScalaMojoSupport . computeBytecodeVersionOptions ( " 17 " , null , new VersionNumber ( " 2.11.12 " ) ) 
public void scala2_12_should_generate_release ( ) { assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 8 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( asList ( " -release " , " 11 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 11 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( asList ( " -release " , " 17 " ) , 
public void scala2_13_should_generate_release ( ) { assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 2.13.10 " ) ) ) ; assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 8 " , new VersionNumber ( " 2.13.10 " ) ) ) ; assertEquals ( asList ( " -release " , " 11 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 11 " , new VersionNumber ( " 2.13.10 " ) ) ) ; assertEquals ( asList ( " -release " , " 17 " ) , 
public void scala3_1_1_should_generate_release ( ) { assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 3.1.1 " ) ) ) ; assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 8 " , new VersionNumber ( " 3.1.1 " ) ) ) ; assertEquals ( asList ( " -release " , " 11 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 11 " , new VersionNumber ( " 3.1.1 " ) ) ) ; assertEquals ( asList ( " -release " , " 17 " ) , 
public void scala3_1_2_should_generate_java_output_version ( ) { assertEquals ( asList ( " -java-output-version " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 3.1.2 " ) ) ) ; assertEquals ( asList ( " -java-output-version " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 8 " , new VersionNumber ( " 3.1.2 " ) ) ) ; assertEquals ( asList ( " -java-output-version " , " 11 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 11 " , new VersionNumber ( " 3.1.2 " ) ) ) ; assertEquals ( asList ( " -java-output-version " , " 17 " ) , 
