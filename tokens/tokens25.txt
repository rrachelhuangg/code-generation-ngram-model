public static String oMultiPath ( List < String > paths ) { return StringUtils . join ( paths . iterator ( ) , File . pathSeparator ) ; } 
public static String oMultiPath ( String [ ] paths ) { return StringUtils . join ( paths , File . pathSeparator ) ; } 
public static String [ ] findFiles ( File dir , String pattern ) { DirectoryScanner scanner = new DirectoryScanner ( ) ; scanner . setBasedir ( dir ) ; scanner . setIncludes ( new String [ ] { pattern } ) ; scanner . addDefaultExcludes ( ) ; scanner . scan ( ) ; return scanner . getIncludedFiles ( ) ; } 
public static String oClasspathString ( ClassLoader cl ) hrows Exception { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } StringBuilder back = new StringBuilder ( ) ; while ( cl ! = null ) { if ( cl instanceof URLClassLoader ) { URLClassLoader ucl = ( URLClassLoader ) cl ; URL [ ] urls = ucl . getURLs ( ) ; for ( URL url : urls ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( url . getFile ( ) ) ; } } cl = cl . getParent ( ) ; } return back . oString ( ) ; } 
public void addEnvVar ( String key , String value ) { env_ . add ( key + " = " + value ) ; } 
public void addJvmArgs ( String . . . args ) { if ( args = = null ) { return ; } for ( String arg : args ) { jvmArgs_ . add ( arg ) ; 
public void addArgs ( String . . . args ) { if ( args = = null ) { return ; } for ( String arg : args ) { args_ . add ( arg ) ; 
public void addOption ( String key , String value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } args_ . add ( key ) ; args_ . add ( value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } args_ . add ( key ) ; args_ . add ( value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | ( key = = null ) ) { return ; } args_ . add ( key ) ; } 
private String [ ] buildCommand ( ) { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs_ . size ( ) + args_ . size ( ) ) ; back . add ( javaExec_ ) ; back . addAll ( jvmArgs_ ) ; back . add ( mainClassName_ ) ; back . addAll ( args_ ) ; return back . oArray ( new String [ back . size ( ) ] ) ; } 
public void run ( boolean displayCmd ) hrows Exception { run ( displayCmd , rue ) ; } 
protected List < String > getClasspathElements ( ) hrows Exception { return project . getCompileClasspathElements ( ) ; } 
protected File getOutputDir ( ) hrows Exception { return outputDir . getAbsoluteFile ( ) ; } 
protected File getSourceDir ( ) hrows Exception { return sourceDir . getAbsoluteFile ( ) ; } 
abstract protected File getOutputDir ( ) hrows Exception ; abstract protected File getSourceDir ( ) hrows Exception ; abstract protected List < String > getClasspathElements ( ) hrows Exception ; @Override protected void doExecute ( ) hrows Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } File sourceDir = normalize ( getSourceDir ( ) ) ; if ( ! sourceDir . exists ( ) ) { return ; } int nbFiles = compile ( sourceDir , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : getLog ( ) . warn ( " No source files found. " ) ; break ; case 0 : getLog ( ) . info ( " Nothing to compile - all classes are up to date " ) ; ; break ; default : break ; } } protected File normalize ( File f ) { ry { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { String [ ] sourceFiles = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; if ( sourceFiles . length = = 0 ) { return - 1 ; } int sourceDirPathLength = sourceDir . getAbsolutePath ( ) . length ( ) ; filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = lastCompileAtFile.lastModified(); ArrayList<File> files = new ArrayList<File>(sourceFiles.length); for (String x : sourceFiles) { File f = new File(sourceDir, x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getAbsolutePath().substring(sourceDirPathLength+1))); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); }} 
abstract protected File getSourceDir ( ) hrows Exception ; abstract protected List < String > getClasspathElements ( ) hrows Exception ; @Override protected void doExecute ( ) hrows Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } File sourceDir = normalize ( getSourceDir ( ) ) ; if ( ! sourceDir . exists ( ) ) { return ; } int nbFiles = compile ( sourceDir , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : getLog ( ) . warn ( " No source files found. " ) ; break ; case 0 : getLog ( ) . info ( " Nothing to compile - all classes are up to date " ) ; ; break ; default : break ; } } protected File normalize ( File f ) { ry { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { String [ ] sourceFiles = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; if ( sourceFiles . length = = 0 ) { return - 1 ; } int sourceDirPathLength = sourceDir . getAbsolutePath ( ) . length ( ) ; filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = lastCompileAtFile.lastModified(); ArrayList<File> files = new ArrayList<File>(sourceFiles.length); for (String x : sourceFiles) { File f = new File(sourceDir, x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getAbsolutePath().substring(sourceDirPathLength+1))); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); }} 
abstract protected List < String > getClasspathElements ( ) hrows Exception ; @Override protected void doExecute ( ) hrows Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } File sourceDir = normalize ( getSourceDir ( ) ) ; if ( ! sourceDir . exists ( ) ) { return ; } int nbFiles = compile ( sourceDir , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : getLog ( ) . warn ( " No source files found. " ) ; break ; case 0 : getLog ( ) . info ( " Nothing to compile - all classes are up to date " ) ; ; break ; default : break ; } } protected File normalize ( File f ) { ry { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { String [ ] sourceFiles = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; if ( sourceFiles . length = = 0 ) { return - 1 ; } int sourceDirPathLength = sourceDir . getAbsolutePath ( ) . length ( ) ; filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = lastCompileAtFile.lastModified(); ArrayList<File> files = new ArrayList<File>(sourceFiles.length); for (String x : sourceFiles) { File f = new File(sourceDir, x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getAbsolutePath().substring(sourceDirPathLength+1))); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); }} 
protected void doExecute ( ) hrows Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } File sourceDir = normalize ( getSourceDir ( ) ) ; if ( ! sourceDir . exists ( ) ) { return ; } int nbFiles = compile ( sourceDir , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : 
protected File normalize ( File f ) { ry { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { String [ ] sourceFiles = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; if ( sourceFiles . length = = 0 ) { return - 1 ; } int sourceDirPathLength = sourceDir . getAbsolutePath ( ) . length ( ) ; filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = lastCompileAtFile.lastModified(); ArrayList<File> files = new ArrayList<File>(sourceFiles.length); for (String x : sourceFiles) { File f = new File(sourceDir, x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getAbsolutePath().substring(sourceDirPathLength+1))); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaCommand jcmd = new JavaCommand ( his , mainConsole , classpathStr , jvmArgs , args ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
protected List < String > getClasspathElements ( ) hrows Exception { hrow new UnsupportedOperationException ( " USELESS " ) ; } 
protected File getOutputDir ( ) hrows Exception { hrow new UnsupportedOperationException ( " USELESS " ) ; } 
protected File getSourceDir ( ) hrows Exception { hrow new UnsupportedOperationException ( " USELESS " ) ; } 
protected JavaCommand getScalaCommand ( ) hrows Exception { JavaCommand jcmd = super . getScalaCommand ( ) ; if ( useFsc ) { jcmd . addOption ( " verbose " , verbose ) ; } return jcmd ; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = normalize ( mainOutputDir ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = normalize ( mainSourceDir ) ; estOutputDir = normalize ( estOutputDir ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } estSourceDir = normalize ( estSourceDir ) ; if ( useFsc ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { int nbFile = 0 ; 
private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaCommand jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; } 
public void run ( ) { ry { getLog ( ) . info ( " stop server(s)... " ) ; 
private String [ ] findSourceFiles ( ) { if ( sourceFiles_ = = null ) { sourceFiles_ = JavaCommand . findFiles ( sourceDir , " **/*.scala " ) ; } return sourceFiles_ ; } 
public boolean canGenerateReport ( ) { ry { sourceDir = sourceDir . getCanonicalFile ( ) ; } catch ( IOException exc ) { sourceDir = sourceDir . getAbsoluteFile ( ) ; } return sourceDir . exists ( ) & & ( findSourceFiles ( ) . length ! = 0 ) ; } 
public void doExecute ( ) hrows Exception { SiteRendererSink sink = siteRenderer.createSink(new File(project.getReporting().getOutputDirectory(), getOutputName() + ".html"); generate(null, Locale.getDefault()); } 
protected JavaCommand getScalaCommand ( ) hrows Exception { String oldClazz = scalaClassName ; if ( isScala271 ) { scalaClassName = " scala.tools.nsc.ScalaDoc " ; } if ( StringUtils . isNotEmpty ( scaladocClassName ) ) { scalaClassName = scaladocClassName ; } JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; scalaClassName = oldClazz ; return cmd ; } 
public void generate ( Sink sink , Locale locale ) hrows MavenReportException { ry { if ( ! canGenerateReport ( ) ) { 
public void doExecute ( ) hrows Exception { JavaCommand jcmd = null ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -help " ) ; jcmd . addArgs ( " -X " ) ; jcmd . addArgs ( " -Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -version " ) ; jcmd . run ( displayCmd ) ; } 
protected Set < Artifact > resolveDependencyArtifacts ( MavenProject heProject ) hrows Exception { AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( new ArtifactFilter ( ) { public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } } ) ; Set < Artifact > artifacts = heProject . createArtifacts ( factory , Artifact . SCOPE_RUNTIME , filter ) ; for ( Artifact artifact : artifacts ) { resolver . resolve ( artifact , remoteRepos , localRepo ) ; } return artifacts ; } 
public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } 
protected Set < Artifact > resolveArtifactDependencies ( Artifact artifact ) hrows Exception { Artifact pomArtifact = factory . createArtifact ( artifact . getGroupId ( ) , artifact . getArtifactId ( ) , artifact . getVersion ( ) , " " , " pom " ) ; MavenProject pomProject = mavenProjectBuilder . buildFromRepository ( pomArtifact , remoteRepos , localRepo ) ; return resolveDependencyArtifacts ( pomProject ) ; } 
protected void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) hrows Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , " jar " ) , classpath ) ; } 
protected void addToClasspath ( Artifact artifact , Set < String > classpath ) hrows Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( artifact . getFile ( ) . getCanonicalPath ( ) ) ; for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { classpath . add ( dep . getFile ( ) . getCanonicalPath ( ) ) ; 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { ry { doExecute ( ) ; 
protected abstract void doExecute ( ) hrows Exception ; protected JavaCommand getScalaCommand ( ) hrows Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) hrows Exception { JavaCommand cmd = new JavaCommand ( his , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-decoder " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-dbc " , scalaVersion , classpath ) ; if ( scalaJars ! = null ) { for ( BasicArtifact artifact : scalaJars ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; return JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } } 
protected JavaCommand getScalaCommand ( ) hrows Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected JavaCommand getEmptyScalaCommand ( String mainClass ) hrows Exception { JavaCommand cmd = new JavaCommand ( his , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-decoder " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-dbc " , scalaVersion , classpath ) ; if ( scalaJars ! = null ) { for ( BasicArtifact artifact : scalaJars ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; return JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
protected void doExecute ( ) hrows Exception { JavaCommand jcmd = new JavaCommand ( his , mainClass , JavaCommand . oMultiPath ( project . getRuntimeClasspathElements ( ) ) , jvmArgs , args ) ; jcmd . run ( displayCmd ) ; } 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { if ( skip ) { return ; } super . execute ( ) ; } 
protected List < String > getClasspathElements ( ) hrows Exception { return project . getTestClasspathElements ( ) ; } 
protected File getOutputDir ( ) hrows Exception { return estOutputDir . getAbsoluteFile ( ) ; } 
protected File getSourceDir ( ) hrows Exception { return estSourceDir . getAbsoluteFile ( ) ; } 
public void run ( ) { BufferedReader reader = null ; ry { reader = new BufferedReader ( new InputStreamReader ( in_ ) ) ; 
public void run ( ) { ry { byte [ ] buffer = new byte [ 512 ] ; 
public String oString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( '-' ) . append ( modifier ) ; } return str . oString ( ) ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( major < o . major ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( minor > o . minor ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( minor < o . minor ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( bugfix > o . bugfix ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( bugfix < o . bugfix ) ) { back = - 1 ; } return back ; } 
protected void doExecute ( ) hrows Exception { JavaCommand jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaCommand ( his , mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args ) ; } else if ( StringUtils . isNotEmpty ( launcher ) & & ( launchers ! = null ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { jcmd = new JavaCommand ( his , launchers [ i ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args ) ; } } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) hrows Exception { JavaCommand jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaCommand ( his , mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaCommand ( his , launchers [ i ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaCommand ( his , launchers [ 0 ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { ry { checkScalaVersion ( ) ; 
protected abstract void doExecute ( ) hrows Exception ; protected JavaCommand getScalaCommand ( ) hrows Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) hrows Exception { JavaCommand cmd = new JavaCommand ( his , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( SCALA_GROUPID , " scala-decoder " , scalaVersion , classpath ) ; addToClasspath ( SCALA_GROUPID , " scala-dbc " , scalaVersion , classpath ) ; if ( scalaJars ! = null ) { for ( BasicArtifact artifact : scalaJars ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , classpath ) ; return JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } } 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( SCALA_GROUPID , " scala-decoder " , scalaVersion , classpath ) ; addToClasspath ( SCALA_GROUPID , " scala-dbc " , scalaVersion , classpath ) ; if ( scalaJars ! = null ) { for ( BasicArtifact artifact : scalaJars ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , classpath ) ; return JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
public void execute ( ) hrows MojoExecutionException { try { if ( sourceDir ! = null ) { 
protected abstract void doExecute ( ) hrows Exception ; protected JavaCommand getScalaCommand ( ) hrows Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) hrows Exception { JavaCommand cmd = new JavaCommand ( his , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (scalaJars != null) { for(BasicArtifact artifact: scalaJars) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); } private String getBootClasspath() throws Exception { Set<String> classpath = new HashSet<String>(); addToClasspath(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, scalaVersion, classpath); return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); }} 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (scalaJars != null) { for(BasicArtifact artifact: scalaJars) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
public void estCompare ( ) hrows Exception { assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; } 
protected JavaCommand getScalaCommand ( ) hrows Exception { String oldClazz = scalaClassName ; boolean isPreviousScala271 = ( new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( scalaVersion ) ) > 0 ) ; if ( ! isPreviousScala271 ) { scalaClassName = " scala.tools.nsc.ScalaDoc " ; } if ( StringUtils . isNotEmpty ( scaladocClassName ) ) { scalaClassName = scaladocClassName ; } JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; if ( isPreviousScala271 ) { cmd . addArgs ( " -Ydoc " ) ; } scalaClassName = oldClazz ; return cmd ; } 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { ry { checkScalaVersion ( ) ; 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { throw new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { throw new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } currentScriptIndex + + ; compileScript(scriptDir, destFile, classpath); 
private boolean hasMavenProjectDependency ( Set < String > classpath ) throws MalformedURLException { try { List < URL > urls = new ArrayList < URL > ( ) ; 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader ) throws Exception { Class < ? > compiledScript = loader . loadClass ( scriptBaseName ( ) ) ; try { try { 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) hrows MalformedURLException { List < URL > urls = new ArrayList < URL > ( ) ; } 
private void compileScript ( File scriptDir , File destFile , Set < String > classpath ) hrows Exception { JavaCommand jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , JavaCommand . oMultiPath ( new ArrayList < String > ( classpath ) ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project . getBuild ( ) . getOutputDirectory ( ) ; if ( ! outputDirectory . endsWith ( " / " ) ) { getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) throws IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream ) ; try { BufferedReader reader ; 
private String scriptBaseName ( ) { if ( scriptFile = = null ) { return " embeddedScript_ " + currentScriptIndex ; 
private void delete ( File scriptDir ) { if ( scriptDir . isDirectory ( ) ) { for ( File file : scriptDir . listFiles ( ) ) { delete ( file ) ; } } scriptDir . deleteOnExit ( ) ; scriptDir . delete ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getCompileDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getRuntimeDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getTestDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException { return project . getSystemDependencies ( ) ; } 
public abstract Collection < Dependency > elements ( MavenProjectAdapter project ) throws DependencyResolutionRequiredException ; public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . rim ( ) . equalsIgnoreCase ( name . rim ( ) ) ) { return scope ; } } return null ; } } } 
public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . rim ( ) . equalsIgnoreCase ( name . rim ( ) ) ) { return scope ; } } return null ; } 
public List < String > getCompileClasspathElements ( ) throws DependencyResolutionRequiredException { return wrapped . getCompileClasspathElements ( ) ; } 
public List < String > getRuntimeClasspathElements ( ) throws DependencyResolutionRequiredException { return wrapped . getRuntimeClasspathElements ( ) ; } 
public List < String > getSystemClasspathElements ( ) throws DependencyResolutionRequiredException { return wrapped . getSystemClasspathElements ( ) ; } 
public List < String > getTestClasspathElements ( ) throws DependencyResolutionRequiredException { return wrapped . getTestClasspathElements ( ) ; } 
public String apply ( String key , String defaultValue ) { String result = apply ( key ) ; if ( result = = null ) { return defaultValue ; 
public void update ( String key , String value ) { if ( key . equals ( " build.directory " ) | | key . equals ( " project.build.directory " ) 
public void update ( String key , int value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , boolean value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , double value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , long value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , char value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , float value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , byte value ) { update ( key , String . valueOf ( value ) ) ; } 
public void addAttachedArtifact ( Artifact artifact ) { wrapped . addAttachedArtifact ( artifact ) ; } 
public void addCompileSourceRoot ( String path ) { wrapped . addCompileSourceRoot ( path ) ; } 
public void addContributor ( Contributor contributor ) { wrapped . addContributor ( contributor ) ; } 
public void addDeveloper ( Developer developer ) { wrapped . addDeveloper ( developer ) ; } 
public void addLicense ( License license ) { wrapped . addLicense ( license ) ; } 
public void addMailingList ( MailingList mailingList ) { wrapped . addMailingList ( mailingList ) ; } 
public void addProjectReference ( MavenProject project ) { wrapped . addProjectReference ( project ) ; } 
public void addResource ( Resource resource ) { wrapped . addResource ( resource ) ; } 
public void addScriptSourceRoot ( String path ) { wrapped . addScriptSourceRoot ( path ) ; } 
public void addTestCompileSourceRoot ( String path ) { wrapped . addTestCompileSourceRoot ( path ) ; } 
public void addTestResource ( Resource estResource ) { wrapped . addTestResource ( estResource ) ; } 
public Set < Artifact > createArtifacts ( ArtifactFactory artifactFactory , String inheritedScope , ArtifactFilter dependencyFilter ) throws InvalidDependencyVersionException { return wrapped . createArtifacts ( artifactFactory , inheritedScope , dependencyFilter ) ; 
public Xpp3Dom getGoalConfiguration ( String arg0 , String arg1 , String arg2 , String arg3 ) { return wrapped . getGoalConfiguration ( arg0 , arg1 , arg2 , arg3 ) ; } 
public String getModulePathAdjustment ( MavenProject arg0 ) hrows IOException { return wrapped . getModulePathAdjustment ( arg0 ) ; } 
public void injectPluginManagementInfo ( Plugin arg0 ) { wrapped . injectPluginManagementInfo ( arg0 ) ; } 
public boolean isExecutionRoot ( ) { return wrapped . isExecutionRoot ( ) ; } 
public Artifact replaceWithActiveArtifact ( Artifact arg0 ) { return wrapped . replaceWithActiveArtifact ( arg0 ) ; } 
public void setDistributionManagement ( DistributionManagement distributionManagement ) { wrapped . setDistributionManagement ( distributionManagement ) ; } 
public void setReleaseArtifactRepository ( ArtifactRepository releaseArtifactRepository ) { wrapped . setReleaseArtifactRepository ( releaseArtifactRepository ) ; } 
public void setSnapshotArtifactRepository ( ArtifactRepository snapshotArtifactRepository ) { wrapped . setSnapshotArtifactRepository ( snapshotArtifactRepository ) ; } 
public void writeModel ( Writer writer ) hrows IOException { wrapped . writeModel ( writer ) ; } 
public void writeOriginalModel ( Writer writer ) hrows IOException { wrapped . writeOriginalModel ( writer ) ; } 
protected abstract void doExecute ( ) hrows Exception ; protected JavaCommand getScalaCommand ( ) hrows Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) hrows Exception { JavaCommand cmd = new JavaCommand ( his , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); } private String getBootClasspath() throws Exception { Set<String> classpath = new HashSet<String>(); addToClasspath(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, scalaVersion, classpath); return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); }} 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return JavaCommand.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
protected void doExecute ( ) hrows Exception { JavaCommand jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaCommand ( his , mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaCommand ( his , launchers [ i ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaCommand ( his , launchers [ 0 ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
public static void main ( String [ ] args ) { JavaClass est = new JavaClass ( ) ; test . abstractJavaMethod ( ) ; } 
protected List < String > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = sourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return sources ; } 
abstract protected File getOutputDir ( ) hrows Exception ; abstract protected List < String > getClasspathElements ( ) hrows Exception ; private static List<String> removeEmptyCompileSourceRoots( List<String> compileSourceRootsList ) { List<String> newCompileSourceRootsList = new ArrayList<String>(); if ( compileSourceRootsList != null ) { copy as I may be modifying it for ( String srcDir : compileSourceRootsList ) { if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() ) { newCompileSourceRootsList.add( srcDir ); } } } return newCompileSourceRootsList; }} 
abstract protected List < String > getClasspathElements ( ) hrows Exception ; private static List<String> removeEmptyCompileSourceRoots( List<String> compileSourceRootsList ) { List<String> newCompileSourceRootsList = new ArrayList<String>(); if ( compileSourceRootsList != null ) { copy as I may be modifying it for ( String srcDir : compileSourceRootsList ) { if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() ) { newCompileSourceRootsList.add( srcDir ); } } } return newCompileSourceRootsList; }} 
abstract protected List < String > getSourceDirectories ( ) hrows Exception ; @Override protected void doExecute ( ) hrows Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } int nbFiles = compile ( getSourceDirectories ( ) , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : getLog ( ) . warn ( " No source files found. " ) ; break ; case 0 : getLog ( ) . info ( " Nothing to compile - all classes are up to date " ) ; ; break ; default : break ; } } protected File normalize ( File f ) { ry { f = f . getCanonicalFile ( ) ; } catch ( IOException exc ) { f = f . getAbsoluteFile ( ) ; } return f ; } protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { getLog ( ) . warn ( " Using older form of compile " ) ; return compile ( Arrays . asList ( sourceDir . getAbsolutePath ( ) ) , outputDir , classpathElements , compileInLoop ) ; } protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } private static List<String> removeEmptyCompileSourceRoots( List<String> compileSourceRootsList ) { List<String> newCompileSourceRootsList = new ArrayList<String>(); if ( compileSourceRootsList != null ) { copy as I may be modifying it for ( String srcDir : compileSourceRootsList ) { if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() ) { newCompileSourceRootsList.add( srcDir ); } } } return newCompileSourceRootsList; }} 
protected void doExecute ( ) hrows Exception { File outputDir = normalize ( getOutputDir ( ) ) ; if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } int nbFiles = compile ( getSourceDirectories ( ) , outputDir , getClasspathElements ( ) , false ) ; switch ( nbFiles ) { case - 1 : 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { getLog ( ) . warn ( " Using older form of compile " ) ; return compile ( Arrays . asList ( sourceDir . getAbsolutePath ( ) ) , outputDir , classpathElements , compileInLoop ) ; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSource ( List < String > sourceRootDirs , String extension ) { List < String > sourceFiles = new ArrayList < String > ( ) ; return sourceFiles; } 
private static List < String > removeEmptyCompileSourceRoots ( List < String > compileSourceRootsList ) { List < String > newCompileSourceRootsList = new ArrayList < String > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for ( String srcDir : compileSourceRootsList ) { if ( !newCompileSourceRootsList.contains( srcDir ) && new File( srcDir ).exists() ) { newCompileSourceRootsList.add( srcDir ); } } } return newCompileSourceRootsList; } 
protected List < String > getSourceDirectories ( ) hrows Exception { hrow new UnsupportedOperationException ( " USELESS " ) ; } 
protected List < String > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = estSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return sources ; } 
private List < String > findSource ( List < String > sourceRootDirs , String extension ) { List < String > sourceFiles = new ArrayList < String > ( ) ; return sourceFiles; } 
protected List < String > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; return sources; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaCommand jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected abstract void doExecute ( ) hrows Exception ; protected JavaCommand getScalaCommand ( ) hrows Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } protected JavaCommand getEmptyScalaCommand ( String mainClass ) hrows Exception { JavaCommand cmd = new JavaCommand ( his , mainClass , getToolClasspath ( ) , null , null ) ; cmd . addJvmArgs ( " -Xbootclasspath/a: " + getBootClasspath ( ) ) ; return cmd ; } private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; }} 
protected boolean isJavaSupportedByCompiler ( ) { return new VersionNumber ( scalaVersion ) . compareTo ( new VersionNumber ( " 2.7.2 " ) ) > = 0 ; } 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { return compile(Arrays.asList(sourceDir.getAbsolutePath()), outputDir, classpathElements, compileInLoop); } 
public void estJdkSplit ( ) hrows Exception { assertEquals ( 6 , " hello " . split ( " | " ) . length ) ; assertEquals ( 1 , " hello " . split ( " \\ | " ) . length ) ; assertEquals ( 2 , " hel|lo " . split ( " \\ | " ) . length ) ; assertEquals ( 3 , " hel||lo " . split ( " \\ | " ) . length ) ; } 
public void estStringUtilsSplit ( ) hrows Exception { assertEquals ( 1 , StringUtils . split ( " hello " , " | " ) . length ) ; assertEquals ( 1 , StringUtils . split ( " hello| " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel|lo " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel||lo " , " | " ) . length ) ; } 
protected JavaCommand getScalaCommand ( ) hrows Exception { JavaCommand cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = new JavaCommand ( his , mainConsole , classpathStr , jvmArgs , args ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { JavaMainCaller jcmd = super . getScalaCommand ( ) ; if ( useFsc ) { jcmd . addOption ( " verbose " , verbose ) ; } return jcmd ; } 
private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { String oldClazz = scalaClassName ; boolean isPreviousScala271 = ( new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( scalaVersion ) ) > 0 ) ; if ( ! isPreviousScala271 ) { scalaClassName = " scala.tools.nsc.ScalaDoc " ; } if ( StringUtils . isNotEmpty ( scaladocClassName ) ) { scalaClassName = scaladocClassName ; } JavaMainCaller cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; cmd . addJvmArgs ( jvmArgs ) ; if ( isPreviousScala271 ) { cmd . addArgs ( " -Ydoc " ) ; } scalaClassName = oldClazz ; return cmd ; } 
public void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -help " ) ; jcmd . addArgs ( " -X " ) ; jcmd . addArgs ( " -Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -version " ) ; jcmd . run ( displayCmd ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { JavaMainCaller cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
protected void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaCommand ( his , mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaCommand ( his , launchers [ i ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaCommand ( his , launchers [ 0 ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
private void compileScript ( File scriptDir , File destFile , Set < String > classpath ) hrows Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , JavaCommand . oMultiPath ( new ArrayList < String > ( classpath ) ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
public void addOption ( String key , String value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } addArgs ( key , value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | ( key = = null ) ) { return ; } addArgs ( key ) ; } 
public void addArgs ( String . . . args ) { if ( args ! = null ) { this . args . addAll ( Arrays . asList ( args ) ) ; 
public void addEnvVar ( String key , String value ) { this . env . add ( key + " = " + value ) ; 
public void run ( boolean displayCmd ) hrows Exception { run ( displayCmd , rue ) ; } 
public abstract void addEnvVar ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void setLogOnly ( boolean v ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void run ( boolean displayCmd ) hrows Exception ; public abstract void spawn ( boolean displayCmd ) hrows Exception ; } 
public abstract void run ( boolean displayCmd , boolean hrowFailure ) throws Exception ; public abstract void spawn ( boolean displayCmd ) hrows Exception ; } 
public void run ( boolean displayCmd , boolean hrowFailure ) hrows Exception { try { runInternal ( displayCmd ) ; 
public void spawn ( final boolean displayCmd ) hrows Exception { Thread = new Thread ( ) { @Override public void run ( ) { try { runInternal ( displayCmd ) ; } catch ( Exception e ) { } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { String oldClazz = scalaClassName ; This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(new VersionNumber(scalaVersion)) > 0); if (!isPreviousScala271) { scalaClassName = "scala.tools.nsc.ScalaDoc"; } if (StringUtils.isNotEmpty(scaladocClassName)) { scalaClassName = scaladocClassName; } JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName); cmd.addArgs(args); cmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ cmd.addArgs("-Ydoc"); } scalaClassName = oldClazz; return cmd; } 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { getLog().warn("Using older form of compile"); return compile(Arrays.asList(sourceDir.getAbsolutePath()), outputDir, classpathElements, compileInLoop); } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { List < String > scalaSourceFiles = findSource ( sourceRootDirs , " scala " ) ; if ( scalaSourceFiles . size ( ) = = 0 ) { return - 1 ; } filter uptodate File lastCompileAtFile = new File(outputDir + ".timestamp"); long lastCompileAt = -1; if (lastCompileAtFile.exists() && outputDir.exists() && (outputDir.list().length > 0)) { lastCompileAt = lastCompileAtFile.lastModified(); } ArrayList<File> files = new ArrayList<File>(scalaSourceFiles.size()); for (String x : scalaSourceFiles) { File f = new File(x); if (f.lastModified() >= lastCompileAt) { files.add(f); } } if (files.size() == 0) { return 0; } Add java files to the source, so we make sure we can have nested dependencies BUT only when not compiling in "loop" fashion and when we're not using an older version of scala if(!compileInLoop && sendJavaToScalac && isJavaSupportedByCompiler()) { List<String> javaSourceFiles = findSource(sourceRootDirs,"java"); for(String javaSourceFile : javaSourceFiles) { files.add(new File(javaSourceFile)); } } if (!compileInLoop) { getLog().info(String.format("Compiling %d source files to %s", files.size(), outputDir.getAbsolutePath())); } long now = System.currentTimeMillis(); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-classpath", JavaCommand.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSource ( List < String > sourceRootDirs , String extension ) { List < String > sourceFiles = new ArrayList < String > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for(String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = JavaCommand.findFiles(dir, "**/*." + extension); for(String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile.getAbsolutePath()); } } return sourceFiles; } 
protected Set < Artifact > resolveDependencyArtifacts ( MavenProject heProject ) hrows Exception { AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( new ArtifactFilter ( ) { public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } } ) ; TODO follow the dependenciesManagement and override rules Set<Artifact> artifacts = theProject.createArtifacts(factory, Artifact.SCOPE_RUNTIME, filter); for (Artifact artifact : artifacts) { resolver.resolve(artifact, remoteRepos, localRepo); } return artifacts; } 
private void checkCorrectVersionsOfScalaLibrary ( ) hrows Exception { getLog ( ) . info ( " Checking for multiple versions of scala " ) ; checkArtifactForScalaVersion(dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
private void checkArtifactForScalaVersion ( DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( scalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { if ( failOnMultipleScalaVersions ) { 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < ArtifactFilter > filters = new ArrayList < ArtifactFilter > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
public boolean isScalaDistroArtifact ( Artifact artifact ) { return SCALA_DISTRO_GROUP . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
public boolean include ( Artifact artifact ) { SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public boolean accept ( DependencyNode node ) { return include ( node . getArtifact ( ) ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
public void addJvmArgs ( String . . . args ) { if ( args ! = null ) { for ( String arg : args ) { 
protected String [ ] buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( javaExec ) ; back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; return back . oArray ( new String [ back . size ( ) ] ) ; } 
private File createArgFile ( ) hrows IOException { final File argFile = File . createTempFile ( " scala-maven- " , " .args " ) ; argFile . deleteOnExit ( ) ; final PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( argFile ) ) ) ; ry { for ( String arg : args ) { out . println ( arg ) ; } } finally { out . close ( ) ; } return argFile ; } 
protected String [ ] buildCommand ( ) hrows IOException { ArrayList < String > back = new ArrayList < String > ( 3 + jvmArgs . size ( ) ) ; back . add ( javaExec ) ; back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . add ( " @ " + createArgFile ( ) . getAbsolutePath ( ) ) ; return back . oArray ( new String [ back . size ( ) ] ) ; } 
private String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " .* \\ s.* " ) ) { return '"' + arg + '"' ; } return arg ; } 
private File createArgFile ( ) hrows IOException { final File argFile = File . createTempFile ( " scala-maven- " , " .args " ) ; argFile . deleteOnExit ( ) ; final PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( argFile ) ) ) ; ry { for ( String arg : args ) { out . println ( escapeArgumentForScalacArgumentFile ( arg ) ) ; } } finally { out . close ( ) ; } return argFile ; } 
protected String [ ] buildCommand ( ) hrows IOException { ArrayList < String > back = new ArrayList < String > ( 3 + jvmArgs . size ( ) ) ; back . add ( javaExec ) ; back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; String fileName = createArgFile ( ) . getCanonicalPath ( ) ; back . add ( " @ " + fileName ) ; return back . oArray ( new String [ back . size ( ) ] ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
public boolean canGenerateReport ( ) { ry { sourceDir = sourceDir . getCanonicalFile ( ) ; } catch ( IOException exc ) { sourceDir = sourceDir . getAbsoluteFile ( ) ; } there is source to compile boolean back = sourceDir.exists() && (findSourceFiles().length != 0); there is modules to aggregate back = back || ((project.isExecutionRoot() || forceAggregate) && StringUtils.isNotEmpty(vscaladocVersion) && (new VersionNumber(vscaladocVersion).compareTo(new VersionNumber("1.1")) >= 0) && project.getCollectedProjects().size() > 0); return back; } 
protected JavaMainCaller newScalaDocCmd ( ) hrows Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addOption ( " -classpath " , JavaCommand . oMultiPath ( project . getCompileClasspathElements ( ) ) ) ; jcmd . addOption ( " -sourcepath " , sourceDir . getAbsolutePath ( ) ) ; jcmd . addOption ( " -bottom " , getBottomText ( ) ) ; jcmd . addOption ( " -charset " , charset ) ; jcmd . addOption ( " -doctitle " , doctitle ) ; jcmd . addOption ( " -footer " , footer ) ; jcmd . addOption ( " -header " , header ) ; jcmd . addOption ( " -linksource " , linksource ) ; jcmd . addOption ( " -nocomment " , nocomment ) ; jcmd . addOption ( " -stylesheetfile " , stylesheetfile ) ; jcmd . addOption ( " -top " , op ) ; jcmd . addOption ( " -windowtitle " , windowtitle ) ; return jcmd ; } 
public void addOption ( String key , String value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } addArgs ( key , value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | ( key = = null ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | ( key = = null ) ) { return ; } addArgs ( key ) ; } 
public void addArgs ( String . . . args ) { if ( args ! = null ) { his . args . addAll ( Arrays . asList ( args ) ) ; 
public void addEnvVar ( String key , String value ) { his . env . add ( key + " = " + value ) ; 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = new JavaCommand ( his , mainConsole , classpathStr , jvmArgs , args ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = new JavaCommand ( his , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { if( new VersionNumber(scalaVersion).compareTo(new VersionNumber("2.7.4")) >= 0) { TODO - Version 2.8.0 and above support passing arguments in a file via the @ argument. getLog().info("use scala command with args in file"); cmd = new ScalaCommandWIthArgsInFile(this, mainClass, getToolClasspath(), null, null); } else { getLog().info("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaCommand(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } } else { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
protected void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaCommand ( his , mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaCommand ( his , launchers [ i ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaCommand ( his , launchers [ 0 ] . mainClass , JavaCommand . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
public void addJvmArgs ( String . . . args ) { if ( args ! = null ) { for ( String arg : args ) { 
public void addToClasspath ( File entry ) hrows Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; 
protected String [ ] buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . oArray ( new String [ back . size ( ) ] ) ; } 
private long lengthOf ( List < String > l , long sepLength ) hrows Exception { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
private static String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " .* \\ s.* " ) ) { return '"' + arg + '"' ; } return arg ; } 
private static String unescapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . charAt ( 0 ) = = '"' & & arg . charAt ( arg . length ( ) - 1 ) = = '"' ) { return arg . substring ( 1 , arg . length ( ) - 1 ) ; } return arg ; } 
public static File createArgFile ( List < String > args ) hrows IOException { final File argFile = File . createTempFile ( " scala-maven- " , " .args " ) ; argFile . deleteOnExit ( ) ; final PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( argFile ) ) ) ; ry { for ( String arg : args ) { out . println ( escapeArgumentForScalacArgumentFile ( arg ) ) ; } } finally { out . close ( ) ; } return argFile ; } 
public static List < String > readArgFile ( File argFile ) hrows IOException { ArrayList < String > back = new ArrayList < String > ( ) ; final BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ; ry { String line = null ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } finally { in . close ( ) ; } return back ; } 
public static String locateJar ( Class < ? > c ) hrows ClassNotFoundException { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*:(.*)!.*$ " ) ; 
public static void main ( String [ ] args ) { ry { String mainClassName = args [ 0 ] ; 
public void addJvmArgs ( String . . . args ) { } 
private void runInternal ( boolean displayCmd ) hrows Exception { String [ ] argArray = args . oArray ( new String [ args . size ( ) ] ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , cl ) ; } 
protected String [ ] buildCommand ( ) hrows IOException { ArrayList < String > back = new ArrayList < String > ( 3 + jvmArgs . size ( ) ) ; back . add ( javaExec ) ; back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; String fileName = MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ; back . add ( " @ " + fileName ) ; return back . oArray ( new String [ back . size ( ) ] ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { if( new VersionNumber(scalaVersion).compareTo(new VersionNumber("2.8.0")) >= 0) { TODO - Version 2.8.0 and above support passing arguments in a file via the @ argument. getLog().info("use scala command with args in file"); cmd = new ScalaCommandWIthArgsInFile(this, mainClass, getToolClasspath(), null, null); } else { getLog().info("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaCommand(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } } else { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
public static File createArgFile ( List < String > args ) hrows IOException { final File argFile = File . createTempFile ( " scala-maven- " , " .args " ) ; argFile.deleteOnExit(); final PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile))); try { for(String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } finally { out.close(); } return argFile; } 
protected String [ ] buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; System . out . println ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . oArray ( new String [ back . size ( ) ] ) ; } 
public static String locateJar ( Class < ? > c ) hrows ClassNotFoundException { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; 
protected String [ ] buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . oArray ( new String [ back . size ( ) ] ) ; } 
public static String locateJar ( Class < ? > c ) hrows Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; long lastCompileAt = - 1 ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { lastCompileAt = lastCompileAtFile . lastModified ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( ! compileInLoop ) { getLog ( ) . info ( String . format ( " Compiling %d source files to %s " , files . size ( ) , outputDir . getAbsolutePath ( ) ) ) ; } long now = System . currentTimeMillis ( ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , JavaCommand . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSourceWithFilters ( List < String > sourceRootDirs ) { List < String > sourceFiles = new ArrayList < String > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for(String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = JavaCommand.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for(String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile.getAbsolutePath()); } } return sourceFiles; } 
private String [ ] findSourceFiles ( ) { if ( sourceFiles_ = = null ) { if ( includes . isEmpty ( ) ) { includes . add ( " **/*.scala " ) ; } sourceFiles_ = JavaCommand . findFiles ( sourceDir , includes . oArray ( new String [ includes . size ( ) ] ) , excludes . oArray ( new String [ excludes . size ( ) ] ) ) ; } return sourceFiles_ ; } 
public static String [ ] findFiles ( File dir , String pattern ) { return findFiles ( dir , new String [ ] { pattern } , new String [ 0 ] ) ; } 
public static String [ ] findFiles ( File dir , String [ ] includes , String [ ] excludes ) { DirectoryScanner scanner = new DirectoryScanner ( ) ; scanner . setBasedir ( dir ) ; scanner . setIncludes ( includes ) ; scanner . setExcludes ( excludes ) ; scanner . addDefaultExcludes ( ) ; scanner . scan ( ) ; return scanner . getIncludedFiles ( ) ; } 
protected void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) hrows Exception { addToClasspath ( groupId , artifactId , version , classpath , rue ) ; } 
protected void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) hrows Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , " jar " ) , classpath , addDependencies ) ; } 
protected void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) hrows Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( artifact . getFile ( ) . getCanonicalPath ( ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { System . out . println ( " compiler plugin: " + artifact . oString ( ) ) ; } 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { toInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { toRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project . getBuild ( ) . getOutputDirectory ( ) ; if ( ! outputDirectory . endsWith ( " / " ) ) { getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; if ( interpreterNeedsToBeLocal ( ) ) { List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; boolean noJline = false ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; if ( args . equals ( " -Ynojline " ) ) { noJline = rue ; } } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new ReflectionJavaMainCaller ( his , mainConsole , classpathStr , jvmArgs , list . oArray ( new String [ list . size ( ) ] ) ) ; } else { jcmd = new JavaCommand ( his , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; } if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
private boolean interpreterNeedsToBeLocal ( ) { return System . getProperty ( " os.name " ) . oLowerCase ( ) . contains ( " windows " ) ; } 
protected void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) hrows Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( artifact . getFile ( ) . getCanonicalPath ( ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
private void checkCorrectVersionsOfScalaLibrary ( ) hrows Exception { getLog ( ) . info ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 checkArtifactForScalaVersion(dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
private void checkArtifactForScalaVersion ( DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( scalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { if ( failOnMultipleScalaVersions ) { 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < ArtifactFilter > filters = new ArrayList < ArtifactFilter > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { if( new VersionNumber(scalaVersion).compareTo(new VersionNumber("2.8.0")) >= 0) { TODO - Version 2.8.0 and above support passing arguments in a file via the @ argument. getLog().info("use scala command with args in file"); cmd = new ScalaCommandWIthArgsInFile(this, mainClass, getToolClasspath(), null, null); } else { getLog().info("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaCommand(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } } else { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
protected boolean isJavaSupportedByCompiler ( ) { return new VersionNumber ( scalaVersion ) . compareTo ( new VersionNumber ( " 2.7.2 " ) ) > = 0 ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { System . out . println ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; long lastCompileAt = - 1 ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { lastCompileAt = lastCompileAtFile . lastModified ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( ! compileInLoop ) { getLog ( ) . info ( String . format ( " Compiling %d source files to %s " , files . size ( ) , outputDir . getAbsolutePath ( ) ) ) ; } long now = System . currentTimeMillis ( ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , JavaCommand . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; if ( interpreterNeedsToBeLocal ( ) ) { List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new ReflectionJavaMainCaller ( his , mainConsole , classpathStr , jvmArgs , list . oArray ( new String [ list . size ( ) ] ) ) ; } else { jcmd = new JavaCommand ( his , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; } if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . setLogOnly ( false ) ; jcmd . run ( displayCmd ) ; } 
private boolean interpreterNeedsToBeLocal ( ) { return System . getProperty ( " os.name " ) . oLowerCase ( ) . contains ( " windows " ) ; } 
private String [ ] findSourceFiles ( ) { if ( sourceFiles_ = = null ) { if ( includes . isEmpty ( ) ) { includes . add ( " **/*.scala " ) ; } sourceFiles_ = JavaCommand . findFiles ( sourceDir , includes . oArray ( new String [ includes . size ( ) ] ) , excludes . oArray ( new String [ excludes . size ( ) ] ) ) ; } return sourceFiles_ ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) if( new VersionNumber(scalaVersion).compareTo(new VersionNumber("2.8.0")) >= 0) { TODO - Version 2.8.0 and above support passing arguments in a file via the @ argument. getLog().info("use scala command with args in file"); cmd = new ScalaCommandWIthArgsInFile(this, mainClass, getToolClasspath(), null, null); } else { getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaCommand(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } } else { cmd = new ReflectionJavaMainCaller(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = JavaCommand . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; if ( interpreterNeedsToBeLocal ( ) ) { List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new ReflectionJavaMainCaller ( his , mainConsole , classpathStr , jvmArgs , list . oArray ( new String [ list . size ( ) ] ) ) ; } else { jcmd = new JavaCommand ( his , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; } if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . run ( displayCmd ) ; } 
public abstract void addEnvVar ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) public abstract void run(boolean displayCmd) throws Exception; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void run ( boolean displayCmd ) hrows Exception ; public abstract void spawn ( boolean displayCmd ) hrows Exception ; } 
public abstract void run ( boolean displayCmd , boolean hrowFailure ) hrows Exception ; public abstract void spawn ( boolean displayCmd ) hrows Exception ; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; long lastCompileAt = - 1 ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { lastCompileAt = lastCompileAtFile . lastModified ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( ! compileInLoop ) { getLog ( ) . info ( String . format ( " Compiling %d source files to %s " , files . size ( ) , outputDir . getAbsolutePath ( ) ) ) ; } long now = System . currentTimeMillis ( ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSourceWithFilters ( List < String > sourceRootDirs ) { List < String > sourceFiles = new ArrayList < String > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for(String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for(String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile.getAbsolutePath()); } } return sourceFiles; } 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; if ( interpreterNeedsToBeLocal ( ) ) { List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new JavaMainCallerInProcess ( his , mainConsole , classpathStr , jvmArgs , list . oArray ( new String [ list . size ( ) ] ) ) ; } else { jcmd = new JavaMainCallerByFork ( his , mainConsole , classpathStr , jvmArgs , args , forceUseArgFile ) ; } if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . run ( displayCmd ) ; } 
private String [ ] findSourceFiles ( ) { if ( sourceFiles_ = = null ) { if ( includes . isEmpty ( ) ) { includes . add ( " **/*.scala " ) ; } sourceFiles_ = MainHelper . findFiles ( sourceDir , includes . oArray ( new String [ includes . size ( ) ] ) , excludes . oArray ( new String [ excludes . size ( ) ] ) ) ; } return sourceFiles_ ; } 
protected JavaMainCaller newScalaDocCmd ( ) hrows Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addOption ( " -classpath " , MainHelper . oMultiPath ( project . getCompileClasspathElements ( ) ) ) ; jcmd . addOption ( " -sourcepath " , sourceDir . getAbsolutePath ( ) ) ; jcmd . addOption ( " -bottom " , getBottomText ( ) ) ; jcmd . addOption ( " -charset " , charset ) ; jcmd . addOption ( " -doctitle " , doctitle ) ; jcmd . addOption ( " -footer " , footer ) ; jcmd . addOption ( " -header " , header ) ; jcmd . addOption ( " -linksource " , linksource ) ; jcmd . addOption ( " -nocomment " , nocomment ) ; jcmd . addOption ( " -stylesheetfile " , stylesheetfile ) ; jcmd . addOption ( " -top " , op ) ; jcmd . addOption ( " -windowtitle " , windowtitle ) ; return jcmd ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile); } else { cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , scalaVersion , classpath ) ; return MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
protected void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( his , mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ i ] . mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ 0 ] . mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } currentScriptIndex + + ; prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); File destFile = new File(scriptDir + "/" + scriptBaseName() + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); URLClassLoader loader = createScriptClassloader(scriptDir, classpath); boolean mavenProjectDependency = hasMavenProjectDependency(classpath); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
private boolean hasMavenProjectDependency ( Set < String > classpath ) hrows MalformedURLException { ry { List < URL > urls = new ArrayList < URL > ( ) ; 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader ) hrows Exception { Class < ? > compiledScript = loader . loadClass ( scriptBaseName ( ) ) ; ry { ry { 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) hrows MalformedURLException { List < URL > urls = new ArrayList < URL > ( ) ; add the script directory to the classpath urls.add(scriptDir.toURI().toURL()); for (String string : classpath) { urls.add(new URL("file:" + string)); } URLClassLoader loader = new URLClassLoader(urls.toArray(new URL[urls .size()]), getClass().getClassLoader()); return loader; } 
private void compileScript ( File scriptDir , File destFile , Set < String > classpath ) hrows Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( new ArrayList < String > ( classpath ) ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { oRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project . getBuild ( ) . getOutputDirectory ( ) ; if ( ! outputDirectory . endsWith ( " / " ) ) { need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); addToClasspath("org.scala-lang", "scala-compiler", scalaVersion, classpath); addToClasspath("org.scala-lang", "scala-library", scalaVersion, classpath); getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) hrows IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream ) ; ry { BufferedReader reader ; 
private String scriptBaseName ( ) { if ( scriptFile = = null ) { return " embeddedScript_ " + currentScriptIndex ; 
private void delete ( File scriptDir ) { if ( scriptDir . isDirectory ( ) ) { for ( File file : scriptDir . listFiles ( ) ) { delete ( file ) ; } } scriptDir . deleteOnExit ( ) ; scriptDir . delete ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { return project . getCompileDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { return project . getRuntimeDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { return project . getTestDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { return project . getSystemDependencies ( ) ; } 
public abstract Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException ; public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . rim ( ) . equalsIgnoreCase ( name . rim ( ) ) ) { return scope ; } } return null ; } } } 
public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . rim ( ) . equalsIgnoreCase ( name . rim ( ) ) ) { return scope ; } } return null ; } 
protected String [ ] buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . oArray ( new String [ back . size ( ) ] ) ; } 
private long lengthOf ( List < String > l , long sepLength ) hrows Exception { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
public void addJvmArgs ( String . . . args ) { TODO - Ignore classpath } public void run(boolean displayCmd, boolean throwFailure) throws Exception { try { runInternal(displayCmd); } catch (Exception e) { if(throwFailure) { throw e; } } } private void runInternal(boolean displayCmd) throws Exception { String[] argArray = args.toArray(new String[args.size()]); if(displayCmd) { requester.getLog().info("cmd : " + mainClassName + "(" + StringUtils.join(argArray, ",")+")"); } MainHelper.runMain(mainClassName, args, cl); }} 
public void run ( boolean displayCmd , boolean hrowFailure ) hrows Exception { ry { runInternal ( displayCmd ) ; 
public void spawn ( final boolean displayCmd ) hrows Exception { Thread = new Thread ( ) { @Override public void run ( ) { ry { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } } }; t.start(); } 
public void run ( ) { ry { runInternal ( displayCmd ) ; 
private void runInternal ( boolean displayCmd ) hrows Exception { String [ ] argArray = args . oArray ( new String [ args . size ( ) ] ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , cl ) ; } 
protected int compile ( List < String > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; long lastCompileAt = - 1 ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { lastCompileAt = lastCompileAtFile . lastModified ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( ! compileInLoop ) { getLog ( ) . info ( String . format ( " Compiling %d source files to %s " , files . size ( ) , outputDir . getAbsolutePath ( ) ) ) ; } if ( files . size ( ) < 1 ) { return 0 ; } long now = System . currentTimeMillis ( ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); if (compileInLoop) { getLog().info(String.format("%tR compiling %s", now, f.getName())); } } jcmd.run(displayCmd, !compileInLoop); if (lastCompileAtFile.exists()) { lastCompileAtFile.setLastModified(now); } else { FileUtils.fileWrite(lastCompileAtFile.getAbsolutePath(), "."); } return files.size(); } 
private List < String > findSourceWithFilters ( List < String > sourceRootDirs ) { List < String > sourceFiles = new ArrayList < String > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile.getAbsolutePath()); } } return sourceFiles; } 
public boolean endVisit ( DependencyNode node ) { return ! _failed ; } 
public boolean isScalaDistroArtifact ( Artifact artifact ) { return SCALA_DISTRO_GROUP . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
protected String [ ] buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back . oArray ( new String [ back . size ( ) ] ) ; } 
private long lengthOf ( List < String > l , long sepLength ) hrows Exception { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
public void addJvmArgs ( String . . . args ) { TODO - Ignore classpath for (String arg : args) { requester.getLog().warn("jvmArgs are ignored when run in process :" + arg); 
private void runInternal ( boolean displayCmd ) hrows Exception { String [ ] argArray = args . oArray ( new String [ args . size ( ) ] ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , cl ) ; } 
public void addJvmArgs ( String . . . args ) { TODO - Ignore classpath if (args != null) { for (String arg : args) { 
private void runInternal ( boolean displayCmd ) hrows Exception { String [ ] argArray = args . oArray ( new String [ args . size ( ) ] ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
protected void doExecute ( ) hrows Exception { System . out . println ( sendRequestAdd ( ) ) ; System . out . println ( sendRequestCompile ( ) ) ; } 
private String oYaml ( MavenProject project ) hrows Exception { HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) ) ; data . put ( " sourcesDirs " , getSourceDirectories ( ) ) ; if ( includes ! = null ) { data . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { data . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } data . put ( " argetDir " , outputDir . getCanonicalPath ( ) ) ; data . put ( " classpath " , project . getCompileClasspathElements ( ) ) ; if ( args ! = null ) { data . put ( " args " , args ) ; } Yaml yaml = new Yaml ( ) ; return yaml . dump ( data ) ; } 
protected List < String > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = sourceDir.getCanonicalPath(); if(!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return sources; } 
protected String sendRequestAdd ( ) hrows Exception { String yamlDef = oYaml ( project ) ; String back = " " ; ry { back = sendRequest ( " add " , yamlDef ) ; } catch ( java . net . ConnectException exc ) { startNewServer ( ) ; back = sendRequest ( " add " , yamlDef ) ; } return back ; } 
protected String sendRequestCompile ( ) hrows Exception { return sendRequest ( " compile " , null ) ; } 
protected String sendRequestStop ( ) hrows Exception { return sendRequest ( " stop " , null ) ; } 
protected String sendRequest ( String action , String data ) hrows Exception { URL url = new URL ( " http:127.0.0.1:27616/ " + action ) ; URLConnection cnx = url . openConnection ( ) ; cnx . setDoOutput ( StringUtils . isNotEmpty ( data ) ) ; cnx . setDoInput ( rue ) ; if ( StringUtils . isNotEmpty ( data ) ) { IOUtil . copy ( data , cnx . getOutputStream ( ) ) ; IOUtil . close ( cnx . getOutputStream ( ) ) ; } String back = IOUtil . oString ( cnx . getInputStream ( ) ) ; IOUtil . close ( cnx . getInputStream ( ) ) ; return back ; } 
private void startNewServer ( ) hrows Exception { getLog ( ) . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-tools " , " scala-tools-server " , " 0.1-SNAPSHOT " , classpath ) ; JavaMainCaller jcmd = new JavaMainCallerByFork ( his , " org.scala_tools.server.HttpServer " , MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) , null , null , forceUseArgFile ) ; jcmd . spawn ( displayCmd ) ; boolean started = false ; while ( ! started ) { ry { 
public void addJvmArgs ( String . . . args ) { TODO - Ignore classpath if(args != null) { for (String arg : args) { 
protected void doExecute ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( " org.scala-lang " , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-lang " , " scala-library " , scalaVersion , classpath ) ; addToClasspath ( " jline " , " jline " , " 0.9.94 " , classpath ) ; classpath . addAll ( project . getCompileClasspathElements ( ) ) ; if ( useTestClasspath ) { classpath . addAll ( project . getTestClasspathElements ( ) ) ; } if ( useRuntimeClasspath ) { classpath . addAll ( project . getRuntimeClasspathElements ( ) ) ; } String classpathStr = MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; JavaMainCaller jcmd = null ; List < String > list = new ArrayList < String > ( args ! = null ? args . length + 3 : 3 ) ; if ( args ! = null ) { for ( String arg : args ) { list . add ( arg ) ; } } list . add ( " -cp " ) ; list . add ( classpathStr ) ; jcmd = new JavaMainCallerInProcess ( his , mainConsole , classpathStr , jvmArgs , list . oArray ( new String [ list . size ( ) ] ) ) ; if ( javaRebelPath ! = null ) { if ( ! javaRebelPath . exists ( ) ) { getLog ( ) . warn ( " javaRevelPath ' " + javaRebelPath . getCanonicalPath ( ) + " ' not found " ) ; } else { jcmd . addJvmArgs ( " -noverify " , " -javaagent: " + javaRebelPath . getCanonicalPath ( ) ) ; } } jcmd . run ( displayCmd ) ; } 
private List < File > findSourceWithFilters ( List < String > sourceRootDirs ) { List < File > sourceFiles = new ArrayList < File > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (String rootSourceDir : normalizeSourceRoots(sourceRootDirs)) { File dir = normalize(new File(rootSourceDir)); String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile); } } return sourceFiles; } 
private String oYaml ( MavenProject project ) hrows Exception { HashMap < String , Object > dataCompile = new HashMap < String , Object > ( ) ; dataCompile . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /main " ) ; dataCompile . put ( " sourcesDirs " , getSourceDirectories ( ) ) ; if ( includes ! = null ) { dataCompile . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataCompile . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataCompile . put ( " argetDir " , outputDir . getCanonicalPath ( ) ) ; dataCompile . put ( " classpath " , project . getCompileClasspathElements ( ) ) ; if ( args ! = null ) { dataCompile . put ( " args " , args ) ; } dataCompile . put ( " dependency-link-path " , localRepo . pathOf ( project . getArtifact ( ) ) ) ; HashMap < String , Object > dataTest = new HashMap < String , Object > ( ) ; dataTest . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /test " ) ; dataTest . put ( " sourcesDirs " , project . getTestCompileSourceRoots ( ) ) ; if ( includes ! = null ) { dataTest . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataTest . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataTest . put ( " argetDir " , estOutputDir . getCanonicalPath ( ) ) ; dataTest . put ( " classpath " , project . getTestClasspathElements ( ) ) ; if ( args ! = null ) { dataTest . put ( " args " , args ) ; } Yaml yaml = new Yaml ( ) ; return yaml . dump ( dataCompile ) + " /n---/n " + yaml . dump ( dataTest ) ; } 
private void startNewServer ( ) hrows Exception { getLog ( ) . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , scalaVersion , classpath ) ; addToClasspath ( " org.scala-tools " , " scala-tools-server " , stsVersion , classpath ) ; JavaMainCaller jcmd = new JavaMainCallerByFork ( his , " org.scala_tools.server.HttpServer " , MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) , null , null , forceUseArgFile ) ; jcmd . spawn ( displayCmd ) ; boolean started = false ; while ( ! started ) { ry { 
private List < File > normalize ( List < String > compileSourceRootsList ) { List < File > newCompileSourceRootsList = new ArrayList < File > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = normalize(new File(srcDir)); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
protected int compile ( File sourceDir , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { getLog().warn("Using older form of compile"); return compile(Arrays.asList(sourceDir), outputDir, classpathElements, compileInLoop); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long now = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , now ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, now); } getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - now) / 1000)); _lastCompileAt = now; return files.size(); } 
private List < File > findSourceWithFilters ( List < File > sourceRootDirs ) { List < File > sourceFiles = new ArrayList < File > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile); } } return sourceFiles; } 
private void notifyCompilation ( List < File > files ) hrows Exception { if ( notifyCompilation ) { for ( File f : files ) { 
private long findLastSuccessfullCompilation ( File outputDir ) hrows Exception { long back = - 1 ; final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; if ( lastCompileAtFile . exists ( ) & & outputDir . exists ( ) & & ( outputDir . list ( ) . length > 0 ) ) { back = lastCompileAtFile . lastModified ( ) ; } return back ; } 
private void setLastSuccessfullCompilation ( File outputDir , long v ) hrows Exception { final File lastCompileAtFile = new File ( outputDir + " .timestamp " ) ; if ( lastCompileAtFile . exists ( ) ) { } else { FileUtils . fileWrite ( lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } lastCompileAtFile . setLastModified ( v ) ; } 
public abstract void addEnvVar ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) public abstract void run(boolean displayCmd) throws Exception; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void run ( boolean displayCmd ) hrows Exception ; public abstract void spawn ( boolean displayCmd ) hrows Exception ; } 
public abstract boolean run ( boolean displayCmd , boolean hrowFailure ) hrows Exception ; public abstract void spawn ( boolean displayCmd ) hrows Exception ; } 
protected void processLine ( String line , int level ) { if ( line . oLowerCase ( ) . indexOf ( " error " ) > - 1 ) { requester . getLog ( ) . error ( line ) ; 
public boolean run ( boolean displayCmd , boolean hrowFailure ) hrows Exception { ry { runInternal ( displayCmd ) ; 
public void addOption ( String key , String value ) { if ( StringUtils . isEmpty ( value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key ) ; } 
public void addArgs ( String . . . args ) { if ( args ! = null ) { for ( String arg : args ) { 
protected List < String > getSourceDirectories ( ) hrows Exception { hrow new UnsupportedOperationException ( " USELESS " ) ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { long 0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , compileInLoop , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long 1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , 1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
public abstract void addEnvVar ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; public abstract void spawn(boolean displayCmd) throws Exception;} 
public abstract void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) public abstract void run(boolean displayCmd) throws Exception; public abstract void spawn(boolean displayCmd) throws Exception;} 
protected void processLine ( String line , int level ) { if ( line . oLowerCase ( ) . indexOf ( " error " ) > - 1 ) { requester . getLog ( ) . error ( line ) ; 
public void redirectToLog ( ) { requester . getLog ( ) . warn ( " redirection to log is not supported for 'inProcess' mode " ) ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { long 0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long 1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , 1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } 
private List < File > findSourceWithFilters ( List < File > sourceRootDirs ) { List < File > sourceFiles = new ArrayList < File > ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile); } } scalac is sensible to scala file order, file system can't garanty file order => unreproductible build error across platform to garanty reproductible command line we order file by path (os dependend). Collections.sort(sourceFiles); return sourceFiles; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(new VersionNumber(scalaVersion)) > 0); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } jcmd.addOption("-classpath", MainHelper.toMultiPath(project.getCompileClasspathElements())); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(new VersionNumber(scalaVersion)) <= 0) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
public void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) hrows Exception { addToClasspath ( groupId , artifactId , version , classpath , rue ) ; } 
public void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) hrows Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , " jar " ) , classpath , addDependencies ) ; } 
protected void doExecute ( ) hrows Exception { super . doExecute ( ) ; System . out . println ( scs . sendRequestCompile ( ) ) ; } 
protected void doExecute ( ) hrows Exception { super . doExecute ( ) ; String yaml = oYaml ( project ) . oString ( ) ; if ( dumpYaml ) { FileUtils . fileWrite ( project . getBuild ( ) . getDirectory ( ) + " /project.yaml " , " UTF-8 " , yaml ) ; } TODO use parser and maven logger to print (and find warning, error,...) System.out.println(scs.sendRequestCreateOrUpdate(yaml)); if (compileAfterInit) { System.out.println(scs.sendRequestCompile()); 
private CharSequence oYaml ( MavenProject project ) hrows Exception { HashMap < String , Object > dataCompile = new HashMap < String , Object > ( ) ; dataCompile . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /main " ) ; dataCompile . put ( " sourceDirs " , getSourceDirectories ( ) ) ; if ( includes ! = null ) { dataCompile . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataCompile . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataCompile . put ( " argetDir " , outputDir . getCanonicalPath ( ) ) ; dataCompile . put ( " classpath " , project . getCompileClasspathElements ( ) ) ; if ( args ! = null ) { dataCompile . put ( " args " , args ) ; } dataCompile . put ( " exported " , new File ( localRepo . getBasedir ( ) , localRepo . pathOf ( project . getArtifact ( ) ) ) . getCanonicalPath ( ) ) ; HashMap < String , Object > dataTest = new HashMap < String , Object > ( ) ; dataTest . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /test " ) ; dataTest . put ( " sourceDirs " , project . getTestCompileSourceRoots ( ) ) ; if ( includes ! = null ) { dataTest . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataTest . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataTest . put ( " argetDir " , estOutputDir . getCanonicalPath ( ) ) ; dataTest . put ( " classpath " , project . getTestClasspathElements ( ) ) ; if ( args ! = null ) { dataTest . put ( " args " , args ) ; } Yaml yaml = new Yaml ( ) ; StringBuilder back = new StringBuilder ( ) ; back . append ( yaml . dump ( dataCompile ) ) .append("---") .append(yaml.dump(dataTest)) ; return back; } 
protected void doExecute ( ) hrows Exception { scs = new ScalacsClient ( his , csVersion ) ; } 
protected void doExecute ( ) hrows Exception { super . doExecute ( ) ; System . out . println ( scs . sendRequestStop ( ) ) ; } 
public String oString ( ) { return level + " * " + category + " * " + file + " * " + line + " * " + column + " * " + offset + " * " + length + " * " + ext + " * " ; } 
public String sendRequestCreateOrUpdate ( String yamlDef ) hrows Exception { String back = " " ; ry { back = sendRequest ( " createOrUpdate " , yamlDef ) ; } catch ( java . net . ConnectException exc ) { startNewServer ( ) ; back = sendRequest ( " createOrUpdate " , yamlDef ) ; } return back ; } 
public String sendRequestRemove ( String projectName ) hrows Exception { return sendRequest ( " remove?p= " + projectName , null ) ; } 
public String sendRequestCompile ( ) hrows Exception { return sendRequest ( " compile " , null ) ; } 
public String sendRequestClean ( ) hrows Exception { return sendRequest ( " clean " , null ) ; } 
public String sendRequestStop ( ) hrows Exception { return sendRequest ( " stop " , null ) ; } 
protected String sendRequest ( String action , String data ) hrows Exception { URL url = new URL ( " http:127.0.0.1:27616/ " + action ) ; raceUrl ( url ) ; URLConnection cnx = url . openConnection ( ) ; cnx . setDoOutput ( StringUtils . isNotEmpty ( data ) ) ; cnx . setDoInput ( rue ) ; if ( StringUtils . isNotEmpty ( data ) ) { OutputStream os = cnx . getOutputStream ( ) ; ry { IOUtil . copy ( new StringReader ( data ) , os ) ; } finally { IOUtil . close ( os ) ; } } InputStream is = cnx . getInputStream ( ) ; ry { String back = IOUtil . oString ( is ) ; 
public void raceUrl ( URL url ) hrows Exception { _log . debug ( " request : " + url ) ; } 
public void startNewServer ( ) hrows Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath(_mojo.SCALA_GROUPID, "scala-compiler", _mojo.scalaVersion, classpath); _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); jcmd.spawn(_mojo.displayCmd); boolean started = false; while (!started) { try { 
public void spawn ( boolean displayCmd ) hrows Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; displayCmd ( displayCmd , cmd ) ; ProcessBuilder pb = new ProcessBuilder ( cmd ) ; pb . redirectErrorStream ( rue ) ; pb . start ( ) ; } 
private void displayCmd ( boolean displayCmd , List < String > cmd ) { if ( displayCmd ) { requester . getLog ( ) . info ( " cmd: " + " " + StringUtils . join ( cmd . iterator ( ) , " " ) ) ; 
protected List < String > buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < String > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back ; } 
public void spawn ( boolean displayCmd ) hrows Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < String > ( ) ; String cmdStr = StringUtils . join ( cmd . iterator ( ) , " " ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . add ( cmdStr ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . add ( cmdStr ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); pb.start(); } 
protected void doExecute ( ) hrows Exception { super . doExecute ( ) ; System . out . println ( scs . sendRequestCompile ( project . getArtifactId ( ) + " - " + project . getVersion ( ) , rue , rue ) ) ; } 
protected void doExecute ( ) hrows Exception { super . doExecute ( ) ; System . out . println ( scs . sendRequestCompile ( project . getArtifactId ( ) + " - " + project . getVersion ( ) , false , false ) ) ; } 
protected void doExecute ( ) hrows Exception { super . doExecute ( ) ; String yaml = oYaml ( project ) . oString ( ) ; if ( dumpYaml ) { new File ( project . getBuild ( ) . getDirectory ( ) ) . mkdirs ( ) ; FileUtils . fileWrite ( project . getBuild ( ) . getDirectory ( ) + " /project.yaml " , " UTF-8 " , yaml ) ; } TODO use parser and maven logger to print (and find warning, error,...) System.out.println(scs.sendRequestCreateOrUpdate(yaml)); if (compileAfterInit) { System.out.println(scs.sendRequestCompile(project.getArtifactId()+"-"+project.getVersion(), true, true)); 
protected void doExecute ( ) hrows Exception { scs = new ScalacsClient ( his , csVersion , jvmArgs ) ; } 
public String sendRequestCompile ( String projectName , boolean withDependencies , boolean withDependent ) hrows Exception { StringBuilder query = new StringBuilder ( " compile? " ) ; if ( StringUtils . isNotEmpty ( projectName ) ) { query . append ( " p= " ) . append ( projectName ) ; if ( ! withDependencies ) { query . append ( " &noDependencies=true " ) ; } if ( ! withDependent ) { query . append ( " &noDependent=true " ) ; } } return sendRequest ( query . oString ( ) , null ) ; } 
public void startNewServer ( ) hrows Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); _mojo.addToClasspath("org.scala-tools.sbt", "sbt-launch", "0.7.2", classpath, true); File scalaCsBootConf = installConf(new File(System.getProperty("user.home"), ".sbt-launch/scalacs-"+ _csVersion +".boot.properties")); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "xsbt.boot.Boot", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), _jvmArgs, new String[]{scalaCsBootConf.getCanonicalPath()}, false); jcmd.spawn(_mojo.displayCmd); boolean started = false; for(int i = 60; i>0 && !started; i--) { try { System.out.print("."); Thread.sleep(1000); sendRequest("ping", null); started = true; System.out.println(" started"); } catch (java.net.ConnectException exc) { started = false; useless but more readable } } if (!started) { throw new IllegalStateException("can't start and connect to scalacs"); 
private File installConf ( File scalaCsBootConf ) hrows Exception { if ( ! scalaCsBootConf . isFile ( ) ) { scalaCsBootConf . getParentFile ( ) . mkdirs ( ) ; InputStream is = null ; StringWriter sw = new StringWriter ( ) ; ry { is = his . getClass ( ) . getResourceAsStream ( " scalacs.boot.properties " ) ; IOUtil . copy ( is , sw ) ; } finally { IOUtil . close ( is ) ; IOUtil . close ( sw ) ; } Properties p = new Properties ( System . getProperties ( ) ) ; p . setProperty ( " scalacs.version " , _csVersion ) ; p . setProperty ( " scalacs.directory " , scalaCsBootConf . getParentFile ( ) . getCanonicalPath ( ) ) ; String cfg = StringUtils . interpolate ( sw . oString ( ) , p ) ; FileUtils . fileWrite ( scalaCsBootConf . getCanonicalPath ( ) , " UTF-8 " , cfg ) ; } return scalaCsBootConf ; } 
public abstract void addEnvVar ( String key , String value ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addJvmArgs ( String . . . args ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addArgs ( String . . . args ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , String value ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , File value ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void addOption ( String key , boolean value ) ; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) public abstract void run(boolean displayCmd) throws Exception; public abstract SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
public abstract void run ( boolean displayCmd ) hrows Exception ; public abstract SpawnMonitor spawn ( boolean displayCmd ) hrows Exception ; } 
public abstract boolean run ( boolean displayCmd , boolean hrowFailure ) hrows Exception ; public abstract SpawnMonitor spawn ( boolean displayCmd ) hrows Exception ; } 
public abstract SpawnMonitor spawn ( boolean displayCmd ) hrows Exception ; } 
public SpawnMonitor spawn ( boolean displayCmd ) hrows Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < String > ( ) ; String cmdStr = StringUtils . join ( cmd . iterator ( ) , " " ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . add ( cmdStr ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . add ( cmdStr ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return new SpawnMonitor(){ public boolean isRunning() throws Exception { 
public boolean isRunning ( ) hrows Exception { ry { p . exitValue ( ) ; 
public SpawnMonitor spawn ( final boolean displayCmd ) hrows Exception { final Thread = new Thread ( ) { @Override public void run ( ) { ry { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } } }; t.start(); return new SpawnMonitor() { public boolean isRunning() throws Exception { 
public boolean isRunning ( ) hrows Exception { return . isAlive ( ) ; } 
protected CharSequence doRequest ( ) hrows Exception { return scs . sendRequestCompile ( projectNamePattern ( ) , rue , rue ) ; } 
protected CharSequence doRequest ( ) hrows Exception { return scs . sendRequestCompile ( projectNamePattern ( ) , false , false ) ; } 
protected CharSequence doRequest ( ) hrows Exception { String yaml = oYaml ( project ) . oString ( ) ; if ( dumpYaml ) { new File ( project . getBuild ( ) . getDirectory ( ) ) . mkdirs ( ) ; FileUtils . fileWrite ( project . getBuild ( ) . getDirectory ( ) + " /project.yaml " , " UTF-8 " , yaml ) ; } StringBuilder back = new StringBuilder ( ) ; back . append ( scs . sendRequestCreateOrUpdate ( yaml ) ) ; if ( compileAfterInit ) { back . append ( scs . sendRequestCompile ( project . getArtifactId ( ) + " - " + project . getVersion ( ) , rue , rue ) ) ; } return back ; } 
private CharSequence oYaml ( MavenProject project ) hrows Exception { HashMap < String , Object > dataCompile = new HashMap < String , Object > ( ) ; dataCompile . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /main " ) ; dataCompile . put ( " sourceDirs " , getSourceDirectories ( ) ) ; if ( includes ! = null ) { dataCompile . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataCompile . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataCompile . put ( " argetDir " , outputDir . getCanonicalPath ( ) ) ; dataCompile . put ( " classpath " , project . getCompileClasspathElements ( ) ) ; if ( args ! = null ) { dataCompile . put ( " args " , args ) ; } dataCompile . put ( " exported " , new File ( localRepo . getBasedir ( ) , localRepo . pathOf ( project . getArtifact ( ) ) ) . getCanonicalPath ( ) ) ; HashMap < String , Object > dataTest = new HashMap < String , Object > ( ) ; dataTest . put ( " name " , project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /test " ) ; dataTest . put ( " sourceDirs " , project . getTestCompileSourceRoots ( ) ) ; if ( includes ! = null ) { dataTest . put ( " includes " , new ArrayList < String > ( includes ) ) ; } if ( excludes ! = null ) { dataTest . put ( " excludes " , new ArrayList < String > ( excludes ) ) ; } dataTest . put ( " argetDir " , estOutputDir . getCanonicalPath ( ) ) ; dataTest . put ( " classpath " , project . getTestClasspathElements ( ) ) ; if ( args ! = null ) { dataTest . put ( " args " , args ) ; } Yaml yaml = new Yaml ( ) ; List < HashMap < String , Object > > prjs = new LinkedList < HashMap < String , Object > > ( ) ; prjs . add ( dataCompile ) ; prjs . add ( dataTest ) ; return yaml . dumpAll ( prjs . iterator ( ) ) ; } 
final protected void doExecute ( ) hrows Exception { scs = new ScalacsClient ( his , csVersion , jvmArgs ) ; String output = doRequest ( ) . oString ( ) ; TODO use parser and maven logger to print (and find warning, error,...) TODO use Stream instead of String to allow progressive display (when scalacs will support it) System.out.println(output); if (output.contains("-ERROR")) { throw new MojoFailureException("ScalaCS reply with ERRORs"); 
protected abstract CharSequence doRequest ( ) hrows Exception ; protected String projectNamePattern ( ) hrows Exception { return project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /.* " ; } } 
protected String projectNamePattern ( ) hrows Exception { return project . getArtifactId ( ) + " - " + project . getVersion ( ) + " /.* " ; } 
protected CharSequence doRequest ( ) hrows Exception { return scs . sendRequestStop ( ) ; } 
protected CharSequence doRequest ( ) hrows Exception { return scs . sendRequestCompile ( null , rue , rue ) ; } 
protected CharSequence doRequest ( ) hrows Exception { return scs . sendRequestRemove ( projectNamePattern ( ) ) ; } 
public String sendRequestCompile ( String projectName , boolean withDependencies , boolean withDependent ) hrows Exception { StringBuilder query = new StringBuilder ( " compile " ) ; if ( StringUtils . isNotEmpty ( projectName ) ) { query . append ( " ?p= " ) . append ( projectName ) ; if ( ! withDependencies ) { query . append ( " &noDependencies=true " ) ; } not supported by scalacs 0.2 if (!withDependent) { query.append("&noDependent=true"); } } return sendRequest(query.toString(), null); } 
public void raceUrl ( URL url ) hrows Exception { String msg = " request : " + url ; if ( _mojo . displayCmd ) { _log . info ( msg ) ; 
public void startNewServer ( ) hrows Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); _mojo.addToClasspath("org.scala-tools.sbt", "sbt-launch", "0.7.2", classpath, true); String[] jvmArgs = new String[(_jvmArgs == null)?1:_jvmArgs.length + 1]; File installDir = new File(System.getProperty("user.home"), ".sbt-launch"); jvmArgs[0] = "-Dsbt.boot.properties="+ installConf(new File(installDir, "scalacs-"+ _csVersion +".boot.properties")).getCanonicalPath(); if (_jvmArgs != null) { System.arraycopy(_jvmArgs, 0, jvmArgs, 1, _jvmArgs.length); } FileTailer tailer = new FileTailer(new File(installDir, "update.log")); boolean started = false; try { JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "xsbt.boot.Boot", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), jvmArgs, null, false); SpawnMonitor mon = jcmd.spawn(_mojo.displayCmd); for(int i = 60; i>0 && !started && mon.isRunning(); i--) { try { if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } else { System.out.print("."); } Thread.sleep(1000); sendRequest("ping", null); started = true; } catch (java.net.ConnectException exc) { started = false; useless but more readable } } if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } System.out.println(""); } finally { tailer.close(); } if (!started) { throw new IllegalStateException("can't start and connect to scalacs"); 
private File installConf ( File scalaCsBootConf ) hrows Exception { if ( ! scalaCsBootConf . isFile ( ) ) { scalaCsBootConf . getParentFile ( ) . mkdirs ( ) ; InputStream is = null ; StringWriter sw = new StringWriter ( ) ; ry { is = his . getClass ( ) . getResourceAsStream ( BOOT_PROP_RSRC ) ; if ( is = = null ) { is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( BOOT_PROP_RSRC ) ; } if ( is = = null ) { String abspath = " / " + his . getClass ( ) . getPackage ( ) . getName ( ) . replace ( '.' , '/' ) + " / " + BOOT_PROP_RSRC ; is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( abspath ) ; if ( is = = null ) { hrow new IllegalStateException ( " can't find " + abspath + " in the classpath " ) ; } } IOUtil . copy ( is , sw ) ; } finally { IOUtil . close ( is ) ; IOUtil . close ( sw ) ; } Properties p = new Properties ( System . getProperties ( ) ) ; p . setProperty ( " scalacs.version " , _csVersion ) ; p . setProperty ( " scalacs.directory " , scalaCsBootConf . getParentFile ( ) . getCanonicalPath ( ) ) ; String cfg = StringUtils . interpolate ( sw . oString ( ) , p ) ; FileUtils . fileWrite ( scalaCsBootConf . getCanonicalPath ( ) , " UTF-8 " , cfg ) ; } return scalaCsBootConf ; } 
public CharSequence whatNew ( ) hrows Exception { StringBuilder back = new StringBuilder ( ) ; if ( _raf = = null & & _file . isFile ( ) ) { _raf = new RandomAccessFile ( _file , " r " ) ; } if ( _raf ! = null ) { Compare the length of the file to the file pointer long fileLength = _file.length(); if( fileLength < _filePointer ) { Log file must have been rotated or deleted; reopen the file and reset the file pointer close(); _raf = new RandomAccessFile(_file, "r" ); _filePointer = 0; } if( fileLength > _filePointer ) { There is data to read _raf.seek( _filePointer ); back = _raf.readUTF(); String line = null; while( (line = _raf.readLine())!= null ) { back.append( line ).append(''); } _filePointer = _raf.getFilePointer(); } } return back; } 
public void close ( ) { ry { if ( _raf ! = null ) { 
final protected void doExecute ( ) hrows Exception { scs = new ScalacsClient ( his , csGroupId , csArtifactId , csVersion , jvmArgs ) ; String output = doRequest ( ) . oString ( ) ; TODO use parser and maven logger to print (and find warning, error,...) TODO use Stream instead of String to allow progressive display (when scalacs will support it) System.out.println(output); if (output.contains("-ERROR")) { throw new MojoFailureException("ScalaCS reply with ERRORs"); 
public void startNewServer ( ) hrows Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); _mojo.addToClasspath("org.scala-tools.sbt", "sbt-launch", "0.7.2", classpath, true); String[] jvmArgs = new String[(_jvmArgs == null)?1:_jvmArgs.length + 1]; File installDir = new File(System.getProperty("user.home"), ".sbt-launch"); jvmArgs[0] = "-Dsbt.boot.properties="+ installConf(new File(installDir, _csArtifactId + "-"+ _csVersion +".boot.properties")).getCanonicalPath(); if (_jvmArgs != null) { System.arraycopy(_jvmArgs, 0, jvmArgs, 1, _jvmArgs.length); } FileTailer tailer = new FileTailer(new File(installDir, "update.log")); boolean started = false; try { JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "xsbt.boot.Boot", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), jvmArgs, null, false); SpawnMonitor mon = jcmd.spawn(_mojo.displayCmd); for(int i = 60; i>0 && !started && mon.isRunning(); i--) { try { if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } else { System.out.print("."); } Thread.sleep(1000); sendRequest("ping", null); started = true; } catch (java.net.ConnectException exc) { started = false; useless but more readable } } if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } System.out.println(""); } finally { tailer.close(); } if (!started) { throw new IllegalStateException("can't start and connect to scalacs"); 
private File installConf ( File scalaCsBootConf ) hrows Exception { if ( ! scalaCsBootConf . isFile ( ) ) { scalaCsBootConf . getParentFile ( ) . mkdirs ( ) ; InputStream is = null ; StringWriter sw = new StringWriter ( ) ; ry { is = his . getClass ( ) . getResourceAsStream ( BOOT_PROP_RSRC ) ; if ( is = = null ) { is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( BOOT_PROP_RSRC ) ; } if ( is = = null ) { String abspath = " / " + his . getClass ( ) . getPackage ( ) . getName ( ) . replace ( '.' , '/' ) + " / " + BOOT_PROP_RSRC ; is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( abspath ) ; if ( is = = null ) { hrow new IllegalStateException ( " can't find " + abspath + " in the classpath " ) ; } } IOUtil . copy ( is , sw ) ; } finally { IOUtil . close ( is ) ; IOUtil . close ( sw ) ; } Properties p = new Properties ( System . getProperties ( ) ) ; p . setProperty ( " scalacs.groupId " , _csGroupId ) ; p . setProperty ( " scalacs.artifactId " , _csArtifactId ) ; p . setProperty ( " scalacs.version " , _csVersion ) ; p . setProperty ( " scalacs.directory " , scalaCsBootConf . getParentFile ( ) . getCanonicalPath ( ) ) ; String cfg = StringUtils . interpolate ( sw . oString ( ) , p ) ; FileUtils . fileWrite ( scalaCsBootConf . getCanonicalPath ( ) , " UTF-8 " , cfg ) ; } return scalaCsBootConf ; } 
public String oString ( ) { return " BasicArtifact( " + groupId + " , " + artifactId + " , " + version + " ) " ; } 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", scalaVersion, classpath); addToClasspath("org.scala-lang", "scala-library", scalaVersion, classpath); addToClasspath("jline", "jline", "0.9.94", classpath); classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
private void checkArtifactForScalaVersion ( DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( scalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
public void logScalaDependents ( ) { _log . warn ( " Expected all dependencies to require Scala version: " + _version ) ; for ( String dependString : scalaDependentArtifactStrings ) { _log . warn ( dependString ) ; 
public static String makeArtifactNameString ( Artifact artifact ) { TODO - Handle version ranges... if(artifact == null) { return "<null artifact>"; } return artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getVersion(); } 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { ry { String oldWay = System . getProperty ( " maven.scala.version " ) ; 
public void execute ( ) hrows MojoExecutionException { ry { if ( sourceDir ! = null ) { 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } currentScriptIndex + + ; if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = Scopes . PLUGIN . name ( ) ; } } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); File destFile = new File(scriptDir + "/" + scriptBaseName() + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); URLClassLoader loader = createScriptClassloader(scriptDir, classpath); boolean mavenProjectDependency = hasMavenProjectDependency(classpath); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { oRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); addToClasspath("org.scala-lang", "scala-compiler", scalaVersion, classpath); addToClasspath("org.scala-lang", "scala-library", scalaVersion, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { Plugin me = ( Plugin ) project . getBuild ( ) . getPluginsAsMap ( ) . get ( " org.scala-tools:maven-scala-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( ( Collection < Dependency > ) me . getDependencies ( ) ) ; return back ; } 
public abstract Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException ; public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . rim ( ) . equalsIgnoreCase ( name . rim ( ) ) ) { return scope ; } } return null ; } } } 
public static String oClasspathString ( ClassLoader cl ) hrows Exception { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new LinkedList < String > ( ) ; appendUrltoClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . oString ( ) ; } 
public static void appendUrltoClasspathCollection ( ClassLoader cl , Collection < String > classpath ) hrows Exception { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } while ( cl ! = null ) { if ( cl instanceof URLClassLoader ) { 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { Plugin me = ( Plugin ) project . getBuild ( ) . getPluginsAsMap ( ) . get ( " org.scala-tools:maven-scala-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( ( Collection < Dependency > ) me . getDependencies ( ) ) ; return back ; } 
protected List < String > getClasspathElements ( ) hrows Exception { return TychoUtilities . addOsgiClasspathElements ( project , project . getCompileClasspathElements ( ) ) ; } 
public Method run ( ) hrows Exception { Method m = mpClazz . getDeclaredMethod ( " getContextValue " , String . class ) ; m . setAccessible ( rue ) ; return m ; } 
public Method run ( ) hrows Exception { Method m = cpeClazz . getDeclaredMethod ( " getLocations " ) ; m . setAccessible ( rue ) ; return m ; } 
public static List < String > addOsgiClasspathElements ( MavenProject project , List < String > defaultClasspathElements ) { if ( getLocationsMethod = = null ) { return defaultClasspathElements ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return defaultClasspathElements ; List < String > osgiClasspath = new ArrayList < String > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } osgiClasspath . addAll ( defaultClasspathElements ) ; return osgiClasspath ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(new VersionNumber(scalaVersion)) > 0); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } List<String> paths = project.getCompileClasspathElements(); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(new VersionNumber(scalaVersion)) <= 0) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
public void generate ( @SuppressWarnings ( " unused " ) Sink sink , @SuppressWarnings ( " unused " ) Locale locale ) hrows MavenReportException { ry { if ( ! canGenerateReport ( ) ) { 
protected void ryAggregateUpper ( MavenProject prj ) hrows Exception { if ( prj ! = null & & prj . hasParent ( ) ) { MavenProject parent = prj . getParent ( ) ; 
private String scriptBaseName ( ) { if ( scriptFile = = null ) { return " embeddedScript_ " + currentScriptIndex ; } int dot = scriptFile . getName ( ) . lastIndexOf ( '.' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + currentScriptIndex ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + currentScriptIndex ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { return project . getCompileDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { return project . getRuntimeDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { return project . getTestDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { return project . getSystemDependencies ( ) ; } 
protected List < String > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = estSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return sources ; } 
public void startNewServer ( ) hrows Exception { _log . info ( " start scala-tools-server... " ) ; Set < String > classpath = new HashSet < String > ( ) ; _mojo.addToClasspath("net.alchim31", "scalacs", _csVersion, classpath, true); JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "net_alchim31_scalacs.HttpServer", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false); _mojo.addToClasspath("org.scala-tools.sbt", "sbt-launch", "0.7.2", classpath, true); String[] jvmArgs = new String[(_jvmArgs == null)?1:_jvmArgs.length + 1]; File installDir = new File(System.getProperty("user.home"), ".sbt-launch"); jvmArgs[0] = "-Dsbt.boot.properties="+ installConf(new File(installDir, _csArtifactId + "-"+ _csVersion +".boot.properties")).getCanonicalPath(); if (_jvmArgs != null) { System.arraycopy(_jvmArgs, 0, jvmArgs, 1, _jvmArgs.length); } FileTailer tailer = new FileTailer(new File(installDir, "update.log")); boolean started = false; try { JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, "xsbt.boot.Boot", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), jvmArgs, null, false); SpawnMonitor mon = jcmd.spawn(_mojo.displayCmd); for(int i = 60; i>0 && !started && mon.isRunning(); i--) { try { if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } else { System.out.print("."); } Thread.sleep(1000); sendRequest("ping", null); started = true; } catch (java.net.ConnectException exc) { started = false; useless but more readable } } if (_mojo.displayCmd) { System.out.print(tailer.whatNew()); } System.out.println(""); } finally { tailer.close(); } if (!started) { throw new IllegalStateException("can't start and connect to scalacs"); } _mojo.getLog().info("scalacs connected"); } 
public boolean endVisit ( @SuppressWarnings ( " unused " ) DependencyNode node ) { return ! _failed ; } 
protected void processLine ( String line , @SuppressWarnings ( " unused " ) int level ) { if ( line . oLowerCase ( ) . indexOf ( " error " ) > - 1 ) { requester . getLog ( ) . error ( line ) ; 
public static String locateJar ( Class < ? > c ) hrows Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; Matcher m = p . matcher ( location . oString ( ) ) ; if ( m . find ( ) ) { return URLDecoder . decode ( m . group ( 1 ) , " UTF-8 " ) ; } hrow new ClassNotFoundException ( " Cannot parse location of ' " + location + " '. Probably not loaded from a Jar " ) ; } hrow new ClassNotFoundException ( " Cannot find class ' " + c . getName ( ) + " using the classloader " ) ; } 
public List < String > getCompileClasspathElements ( ) hrows DependencyResolutionRequiredException { return wrapped . getCompileClasspathElements ( ) ; } 
public List < String > getRuntimeClasspathElements ( ) hrows DependencyResolutionRequiredException { return wrapped . getRuntimeClasspathElements ( ) ; } 
public List < String > getSystemClasspathElements ( ) hrows DependencyResolutionRequiredException { return wrapped . getSystemClasspathElements ( ) ; } 
public List < String > getTestClasspathElements ( ) hrows DependencyResolutionRequiredException { return wrapped . getTestClasspathElements ( ) ; } 
public String apply ( String key , String defaultValue ) { String result = apply ( key ) ; if ( result = = null ) { return defaultValue ; } return result ; } 
public void update ( String key , String value ) { if ( key . equals ( " build.directory " ) | | key . equals ( " project.build.directory " ) 
public void update ( String key , int value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , boolean value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , double value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , long value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , char value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , float value ) { update ( key , String . valueOf ( value ) ) ; } 
public void update ( String key , byte value ) { update ( key , String . valueOf ( value ) ) ; } 
public void addAttachedArtifact ( Artifact artifact ) { wrapped . addAttachedArtifact ( artifact ) ; } 
public void addCompileSourceRoot ( String path ) { wrapped . addCompileSourceRoot ( path ) ; } 
public void addContributor ( Contributor contributor ) { wrapped . addContributor ( contributor ) ; } 
public void addDeveloper ( Developer developer ) { wrapped . addDeveloper ( developer ) ; } 
public void addLicense ( License license ) { wrapped . addLicense ( license ) ; } 
public void addMailingList ( MailingList mailingList ) { wrapped . addMailingList ( mailingList ) ; } 
public void addPlugin ( Plugin plugin ) { wrapped . addPlugin ( plugin ) ; } 
public void addProjectReference ( MavenProject project ) { wrapped . addProjectReference ( project ) ; } 
public void addResource ( Resource resource ) { wrapped . addResource ( resource ) ; } 
public void addScriptSourceRoot ( String path ) { wrapped . addScriptSourceRoot ( path ) ; } 
public void addTestCompileSourceRoot ( String path ) { wrapped . addTestCompileSourceRoot ( path ) ; } 
public void addTestResource ( Resource estResource ) { wrapped . addTestResource ( estResource ) ; } 
public Set < Artifact > createArtifacts ( ArtifactFactory artifactFactory , String inheritedScope , ArtifactFilter dependencyFilter ) hrows InvalidDependencyVersionException { return wrapped . createArtifacts ( artifactFactory , inheritedScope , dependencyFilter ) ; 
public boolean equals ( Object arg0 ) { return wrapped . equals ( arg0 ) ; } 
public Xpp3Dom getGoalConfiguration ( String arg0 , String arg1 , String arg2 , String arg3 ) { return wrapped . getGoalConfiguration ( arg0 , arg1 , arg2 , arg3 ) ; } 
public String getModulePathAdjustment ( MavenProject arg0 ) hrows IOException { return wrapped . getModulePathAdjustment ( arg0 ) ; } 
public boolean hasParent ( ) { return wrapped . hasParent ( ) ; } 
public void injectPluginManagementInfo ( Plugin arg0 ) { wrapped . injectPluginManagementInfo ( arg0 ) ; } 
public boolean isExecutionRoot ( ) { return wrapped . isExecutionRoot ( ) ; } 
public Artifact replaceWithActiveArtifact ( Artifact arg0 ) { return wrapped . replaceWithActiveArtifact ( arg0 ) ; } 
public void setDistributionManagement ( DistributionManagement distributionManagement ) { wrapped . setDistributionManagement ( distributionManagement ) ; } 
public void setReleaseArtifactRepository ( ArtifactRepository releaseArtifactRepository ) { wrapped . setReleaseArtifactRepository ( releaseArtifactRepository ) ; } 
public void setSnapshotArtifactRepository ( ArtifactRepository snapshotArtifactRepository ) { wrapped . setSnapshotArtifactRepository ( snapshotArtifactRepository ) ; } 
public void writeModel ( Writer writer ) hrows IOException { wrapped . writeModel ( writer ) ; } 
public void writeOriginalModel ( Writer writer ) hrows IOException { wrapped . writeOriginalModel ( writer ) ; } 
public boolean canGenerateReport ( ) { ry { sourceDir = sourceDir . getCanonicalFile ( ) ; } catch ( IOException exc ) { sourceDir = sourceDir . getAbsoluteFile ( ) ; } there is source to compile boolean back = sourceDir.exists() && (findSourceFiles().length != 0); there is modules to aggregate back = back || ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0); return back; } 
private boolean canAggregate ( ) { return StringUtils . isNotEmpty ( vscaladocVersion ) & & ( new VersionNumber ( vscaladocVersion ) . compareTo ( new VersionNumber ( " 1.1 " ) ) > = 0 ) ; } 
protected void ryAggregateUpper ( MavenProject prj ) hrows Exception { if ( prj ! = null & & prj . hasParent ( ) & & canAggregate ( ) ) { MavenProject parent = prj . getParent ( ) ; 
public List < LogEvent > parse ( String response ) hrows Exception { List < LogEvent > back = new LinkedList < LogEvent > ( ) ; BufferedReader in = new BufferedReader ( new StringReader ( response ) ) ; ry { for ( String l = in . readLine ( ) ; l ! = null ; l = in . readLine ( ) ) { Matcher m = linePattern . matcher ( l ) ; if ( m . matches ( ) ) { LogEvent e = new LogEvent ( ) ; e . level = Level . valueOf ( m . group ( 1 ) . oUpperCase ( ) ) ; e . category = m . group ( 2 ) ; e . ext = m . group ( 4 ) . replace ( '$' , '' ) ; Matcher ml = locationPattern . matcher ( m . group ( 3 ) ) ; if ( ml . matches ( ) ) { e . file = new File ( ml . group ( 1 ) ) ; e . line = Integer . parseInt ( m . group ( 2 ) ) ; e . column = Integer . parseInt ( m . group ( 3 ) ) ; e . offset = Integer . parseInt ( m . group ( 4 ) ) ; e . length = Integer . parseInt ( m . group ( 5 ) ) ; } back . add ( e ) ; } } } finally { IOUtil . close ( in ) ; } return back ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { JavaMainCaller jcmd = super . getScalaCommand ( ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " -verbose " , verbose ) ; } return jcmd ; } 
protected void postCompileActions ( ) { } private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
protected void postCompileActions ( ) hrows Exception { } private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { long 0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long 1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , 1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected boolean hasCompileErrors ( ) { return compileErrors ; } 
protected void clearCompileErrors ( ) { compileErrors = false ; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = normalize ( mainOutputDir ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = normalize ( mainSourceDir ) ; estOutputDir = normalize ( estOutputDir ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } estSourceDir = normalize ( estSourceDir ) ; if ( useFsc ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
public void sayHello ( ) { System . out . println ( " Java says:Hello Scala! " ) ; HelloScala . sayHello ( ) ; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = sourceDir.getCanonicalPath(); if(!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. String sv = findScalaVersion().toString(); Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); addToClasspath("jline", "jline", "0.9.94", classpath); classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected List < File > getSourceDirectories ( ) hrows Exception { hrow new UnsupportedOperationException ( " USELESS " ) ; } 
public boolean canGenerateReport ( ) { there is modules to aggregate boolean back = ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0); back = back || (findSourceFiles().size() != 0); return back; } 
private List < File > findSourceFiles ( ) { if ( _sourceFiles = = null ) { ry { _sourceFiles = findSourceWithFilters ( ) ; } catch ( Exception exc ) { hrow new RuntimeException ( " can't define source to process " , exc ) ; } } return _sourceFiles ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(findScalaVersion()) > 0); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } List<String> paths = project.getCompileClasspathElements(); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(findScalaVersion()) <= 0) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
protected void checkScalaVersion ( ) hrows Exception { if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( findScalaVersion ( ) . oString ( ) ) ; 
private void checkCorrectVersionsOfScalaLibrary ( String requiredScalaVersion ) hrows Exception { getLog ( ) . info ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
private void checkArtifactForScalaVersion ( String requiredScalaVersion , DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , findScalaVersion ( ) . oString ( ) , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) , classpath ) ; return MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
protected boolean isJavaSupportedByCompiler ( ) hrows Exception { return findScalaVersion ( ) . compareTo ( new VersionNumber ( " 2.7.2 " ) ) > = 0 ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; String sv = findScalaVersion ( ) . oString ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , sv , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { oRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); String sv = findScalaVersion().toString(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected List < File > normalize ( List < String > compileSourceRootsList ) { List < File > newCompileSourceRootsList = new ArrayList < File > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = normalize(new File(srcDir)); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = estSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; } 
public String oString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . oString ( ) ; } 
public void estParse ( ) hrows Exception { assertParseVN ( " 2.7.1 " , 2 , 7 , 1 , null ) ; assertParseVN ( " 2.7 " , 2 , 7 , 0 , null ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.RC " , 2 , 7 , 0 , " .RC " ) ; assertParseVN ( " 2.7-RC " , 2 , 7 , 0 , " -RC " ) ; assertParseVN ( " 2.7.1-SNAPSHOT " , 2 , 7 , 1 , " -SNAPSHOT " ) ; } 
private void assertParseVN ( String str , int major , int minor , int bugfix , String modifier ) { VersionNumber v = new VersionNumber ( str ) ; assertEquals ( " est major of " + str , major , v . major ) ; assertEquals ( " est minor of " + str , minor , v . minor ) ; assertEquals ( " est bugfix of " + str , bugfix , v . bugfix ) ; assertEquals ( " est modifier of " + str , modifier , v . modifier ) ; } 
protected List < File > findSourceWithFilters ( ) hrows Exception { return findSourceWithFilters ( getSourceDirectories ( ) ) ; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = sourceDir.getCanonicalPath(); if (!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
protected void doExecute ( ) hrows Exception { if ( StringUtils . isNotEmpty ( _mainClass ) ) { File cfg = makeJsonCfg ( ) ; 
private void oJson ( Object pojo , boolean prettyPrint , File f ) hrows Exception { ObjectMapper m = new ObjectMapper ( ) ; JsonFactory jf = new JsonFactory ( ) ; JsonGenerator jg = jf . createJsonGenerator ( f , JsonEncoding . UTF8 ) ; if ( prettyPrint ) { jg . useDefaultPrettyPrinter ( ) ; } m . writeValue ( jg , pojo ) ; } 
private File makeJsonCfg ( ) hrows Exception { initFilters ( ) ; File dir = new File ( project . getBuild ( ) . getDirectory ( ) ) ; dir . mkdirs ( ) ; File f = new File ( dir , " vscaladoc2_cfg.json " ) ; oJson ( new Cfg ( his ) , _prettyPrint , f ) ; return f ; } 
protected List < List < String > > makeDependencies ( ScalaGenJsonMojo data ) hrows Exception { List < List < String > > back = new ArrayList < List < String > > ( ) ; @SuppressWarnings ( " unchecked " ) List < Artifact > deps = data . project . getCompileArtifacts ( ) ; for ( Artifact dep : deps ) { List < String > e = new ArrayList < String > ( 3 ) ; e . add ( dep . getFile ( ) . getCanonicalPath ( ) ) ; e . add ( dep . getArtifactId ( ) ) ; e . add ( dep . getVersion ( ) ) ; back . add ( e ) ; } return back ; } 
protected List < List < Object > > makeSources ( ScalaGenJsonMojo data ) hrows Exception { List < List < Object > > back = new ArrayList < List < Object > > ( ) ; List < File > dirs = data . getSourceDirectories ( ) ; List < String > includes = new ArrayList < String > ( data . includes ) ; List < String > excludes = new ArrayList < String > ( data . excludes ) ; for ( File dir : dirs ) { List < Object > e = new ArrayList < Object > ( 3 ) ; e . add ( dir . getCanonicalPath ( ) ) ; e . add ( excludes ) ; e . add ( includes ) ; back . add ( e ) ; } return back ; } 
protected List < List < String > > makeArtifacts ( ScalaGenJsonMojo data ) hrows Exception { List < List < String > > back = new ArrayList < List < String > > ( ) ; @SuppressWarnings ( " unchecked " ) List < MavenProject > modules = data . project . getCollectedProjects ( ) ; for ( MavenProject module : modules ) { List < String > e = new ArrayList < String > ( 2 ) ; e . add ( module . getArtifactId ( ) ) ; e . add ( module . getVersion ( ) ) ; back . add ( e ) ; } return back ; } 
protected List < File > findSourceWithFilters ( List < File > sourceRootDirs ) hrows Exception { List < File > sourceFiles = new ArrayList < File > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = normalize(new File(dir, tmpLocalFile)); sourceFiles.add(tmpAbsFile); } } scalac is sensible to scala file order, file system can't garanty file order => unreproductible build error across platform to garanty reproductible command line we order file by path (os dependend). Collections.sort(sourceFiles); return sourceFiles; } 
private String makeKind ( ScalaGenJsonMojo data ) { String back = null ; String pkg = data . project . getPackaging ( ) ; if ( " pom " . equals ( pkg ) ) { back = " group " ; } else { back = pkg ; } return back ; } 
protected List < List < String > > makeDependencies ( ScalaGenJsonMojo data ) hrows Exception { List < List < String > > back = new ArrayList < List < String > > ( ) ; @SuppressWarnings ( " unchecked " ) List < Artifact > deps = data . project . getCompileArtifacts ( ) ; for ( Artifact dep : deps ) { List < String > e = new ArrayList < String > ( 3 ) ; e . add ( dep . getFile ( ) . getCanonicalPath ( ) ) ; e . add ( dep . getArtifactId ( ) + " / " + dep . getVersion ( ) ) ; back . add ( e ) ; } return back ; } 
protected List < String > makeArtifacts ( ScalaGenJsonMojo data ) hrows Exception { List < String > back = new ArrayList < String > ( ) ; @SuppressWarnings ( " unchecked " ) List < MavenProject > modules = data . project . getCollectedProjects ( ) ; for ( MavenProject module : modules ) { back . add ( module . getArtifactId ( ) + " / " + module . getVersion ( ) ) ; } return back ; } 
private void oJson ( Object pojo , boolean prettyPrint , File f ) hrows Exception { ObjectMapper m = new ObjectMapper ( ) ; JsonFactory jf = new JsonFactory ( ) ; JsonGenerator jg = jf . createJsonGenerator ( f , JsonEncoding . UTF8 ) ; if ( prettyPrint ) { jg . useDefaultPrettyPrinter ( ) ; } ObjectNode ree = m . valueToTree ( pojo ) ; if ( StringUtils . isNotEmpty ( overrideJson ) ) { JsonNode overrideTree = m . readValue ( overrideJson , JsonNode . class ) ; Iterator < String > ks = overrideTree . getFieldNames ( ) ; while ( ks . hasNext ( ) ) { String k = ks . next ( ) ; JsonNode v = overrideTree . get ( k ) ; ree . put ( k , v ) ; } } m . writeTree ( jg , ree ) ; } 
protected void doExecute ( ) hrows Exception { if ( StringUtils . isNotEmpty ( _mainClass ) ) { Cfg cfg = new Cfg ( his ) ; 
private File makeJsonCfg ( Cfg cfg ) hrows Exception { initFilters ( ) ; File dir = new File ( project . getBuild ( ) . getDirectory ( ) ) ; dir . mkdirs ( ) ; File f = new File ( dir , " vscaladoc2_cfg.json " ) ; oJson ( cfg , _prettyPrint , f ) ; return f ; } 
private void registerApidocArchiveForInstall ( Cfg cfg ) hrows Exception { File apidocArchiveFile = new File ( System . getProperty ( " user.home " ) , " .config/vscaladoc2/apis/ " + cfg . artifactId + " / " + cfg . version + " -apidoc.jar.gz " ) . getCanonicalFile ( ) ; if ( apidocArchiveFile . exists ( ) ) { projectHelper . attachArtifact ( project , " jar.gz " , " apidoc " , apidocArchiveFile ) ; 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) hrows MalformedURLException { List < URL > urls = new ArrayList < URL > ( ) ; urls.add(new File(string).toURI().toURL()); } URLClassLoader loader = new URLClassLoader(urls.toArray(new URL[urls .size()]), getClass().getClassLoader()); return loader; } 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. String sv = findScalaVersion().toString(); Set<String> classpath = new HashSet<String>(); addCompilerToClasspath(sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); addToClasspath("jline", "jline", "0.9.94", classpath); classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected void addCompilerToClasspath ( String version , Set < String > classpath ) hrows Exception { if ( StringUtils . isEmpty ( scalaHome ) ) { addToClasspath ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , version , classpath ) ; 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addCompilerToClasspath ( findScalaVersion ( ) . oString ( ) , classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; String sv = findScalaVersion ( ) . oString ( ) ; addCompilerToClasspath ( sv , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { oRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); String sv = findScalaVersion().toString(); addCompilerToClasspath(sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. String sv = findScalaVersion().toString(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(sv, classpath); addLibraryToClasspath(sv, classpath); addToClasspath("jline", "jline", "0.9.94", classpath); classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected void addLibraryToClasspath ( String version , Set < String > classpath ) hrows Exception { if ( StringUtils . isEmpty ( scalaHome ) ) { addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , version , classpath ) ; 
private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addLibraryToClasspath ( findScalaVersion ( ) . oString ( ) , classpath ) ; return MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < String > ( ) ; String sv = findScalaVersion ( ) . oString ( ) ; addCompilerToClasspath ( sv , ignoreClasspath ) ; addLibraryToClasspath ( sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { MavenProjectAdapter projectAdapter = new MavenProjectAdapter ( project ) ; Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . addAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . removeAll ( scope . elements ( projectAdapter ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { oRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); String sv = findScalaVersion().toString(); addCompilerToClasspath(sv, classpath); addLibraryToClasspath(sv, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); String sv = scalaVersion.toString(); Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", sv, classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
public static String pathOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
public static File fileOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath); if(!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); String sv = scalaVersion.toString(); Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", sv, classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("maven-scala-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+ javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = FileUtils . fileOf ( mainSourceDir , useCanonicalPath ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } estSourceDir = FileUtils . fileOf ( estSourceDir , useCanonicalPath ) ; if ( useFsc ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath); if (!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
protected void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) hrows Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( FileUtils . pathOf ( artifact . getFile ( ) , useCanonicalPath ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
protected List < File > findSourceWithFilters ( List < File > sourceRootDirs ) hrows Exception { List < File > sourceFiles = new ArrayList < File > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensible to scala file order, file system can't garanty file order => unreproductible build error across platform to garanty reproductible command line we order file by path (os dependend). Collections.sort(sourceFiles); return sourceFiles; } 
protected List < File > normalize ( List < String > compileSourceRootsList ) hrows Exception { List < File > newCompileSourceRootsList = new ArrayList < File > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = FileUtils.fileOf(new File(srcDir), useCanonicalPath); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
private static String scriptBaseNameOf ( File scriptFile , int idx ) { if ( scriptFile = = null ) { return " embeddedScript_ " + idx ; } int dot = scriptFile . getName ( ) . lastIndexOf ( '.' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + idx ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + idx ; } 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = Scopes . PLUGIN . name ( ) ; } } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); URLClassLoader loader = createScriptClassloader(scriptDir, classpath); boolean mavenProjectDependency = hasMavenProjectDependency(classpath); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader , String baseName ) hrows Exception { Class < ? > compiledScript = loader . loadClass ( baseName ) ; ry { ry { 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) hrows IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream ) ; ry { BufferedReader reader ; 
protected void processLine ( String line , @SuppressWarnings ( " unused " ) int level ) { ry { _previous = LogProcessorUtils . levelStateOf ( line , _previous ) ; 
public static LevelState levelStateOf ( String line , LevelState previous ) hrows Exception { LevelState back = new LevelState ( ) ; String lineLowerCase = line . oLowerCase ( ) ; if ( lineLowerCase . indexOf ( " error " ) > - 1 ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . indexOf ( " warn " ) > - 1 ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; } 
private LevelState assertLevelState ( String input , LevelState previous , Level expectedLevel , String expectedUntilContains ) hrows Exception { LevelState back = LogProcessorUtils . levelStateOf ( input , previous ) ; assertEquals ( expectedLevel , back . level ) ; assertEquals ( expectedUntilContains , back . untilContains ) ; return back ; } 
public void estJdkSplit ( ) hrows Exception { LevelState previous = new LevelState ( ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala:-1: info: compiling " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514 " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Recompiling 1 files " , previous , Level . INFO , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " wo errors found " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " BUILD ERROR " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " wrap: org.apache.commons.exec.ExecuteException: Process exited with an error: 1(Exit value: 1) " , previous , Level . ERROR , null ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(findScalaVersion()) > 0); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<String>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(findScalaVersion()) <= 0) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) , classpath ) ; addToClasspath ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) , classpath ) ; return MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
public void doExecute ( ) hrows Exception { if ( skip ) { getLog ( ) . info ( " Skipping javadoc generation " ) ; return ; } ry { generate ( null , Locale . getDefault ( ) ) ; 
protected void failOnError ( String prefix , Exception e ) hrows MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { hrow ( RuntimeException ) e ; } hrow new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); String sv = scalaVersion.toString(); Set<String> classpath = new HashSet<String>(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", sv, classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+ javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { Plugin me = ( Plugin ) project . getBuild ( ) . getPluginsAsMap ( ) . get ( " net.alchim31.maven:scala-maven-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( ( Collection < Dependency > ) me . getDependencies ( ) ) ; return back ; } 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader , String baseName ) hrows Exception { Class < ? > compiledScript = loader . loadClass ( baseName ) ; ClassLoader currentCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; ry { ry { 
protected void processLine ( String line , int level ) { ry { _previous = LogProcessorUtils . levelStateOf ( line , _previous ) ; 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { JavaMainCaller cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected List < String > getClasspathElements ( ) hrows Exception { List < String > back = project . getCompileClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getOutputDirectory ( ) ) ; back . add ( getOutputDir ( ) . getAbsolutePath ( ) ) ; back = TychoUtilities . addOsgiClasspathElements ( project , back ) ; return back ; } 
protected List < String > getClasspathElements ( ) hrows Exception { List < String > back = project . getTestClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; back . add ( getOutputDir ( ) . getAbsolutePath ( ) ) ; return back ; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); } else { cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null); } cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); return cmd; } 
protected void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; Toolchain oolchain = oolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( his , mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile , oolchain ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ i ] . mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , oolchain ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ 0 ] . mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , oolchain ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
public void compile ( List < String > classpathElements , List < File > sourcesList , File outputDir , List < String > scalacOptions , List < String > javacOptions ) { Seq < File > classpath = listToSeq ( pathsToFiles ( classpathElements ) ) ; Seq < File > sources = listToSeq ( sourcesList ) ; Seq < String > soptions = listToSeq ( scalacOptions ) ; Seq < String > joptions = listToSeq ( javacOptions ) ; compiler . compile ( classpath , sources , outputDir , soptions , joptions ) ; } 
public < A > Seq < A > listToSeq ( List < A > list ) { return JavaConverters . collectionAsScalaIterableConverter ( list ) . asScala ( ) . oSeq ( ) ; } 
public List < File > pathsToFiles ( List < String > paths ) { List < File > files = new ArrayList < File > ( paths . size ( ) ) ; for ( String path : paths ) { files . add ( new File ( path ) ) ; } return files ; } 
public void error ( F0 < String > msg ) { if ( log . isErrorEnabled ( ) ) { log . error ( msg . apply ( ) ) ; 
public void warn ( F0 < String > msg ) { if ( log . isWarnEnabled ( ) ) { log . warn ( msg . apply ( ) ) ; 
public void info ( F0 < String > msg ) { if ( log . isInfoEnabled ( ) ) { log . info ( msg . apply ( ) ) ; 
public void debug ( F0 < String > msg ) { if ( log . isDebugEnabled ( ) ) { log . debug ( msg . apply ( ) ) ; 
public void race ( F0 < Throwable > exception ) { if ( log . isDebugEnabled ( ) ) { log . debug ( exception . apply ( ) ) ; 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( INCREMENTAL . equals ( recompileMode ) ) { return incrementalCompile ( getClasspathElements ( ) , getSourceDirectories ( ) , outputDir ) ; } long 0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long 1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , 1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir ) hrows Exception , InterruptedException { String scalaVersion = findScalaVersion ( ) . oString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = " org.scala-sbt " ; String xsbtiArtifactId = " interface " ; String compilerInterfaceArtifactId = " compiler-interface " ; String sbtVersion = findVersionFromPluginArtifacts ( " org.scala-sbt " , " sbt-incremental-compiler " ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , " src " ) ; if ( incremental = = null ) incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , getLog ( ) ) ; List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; incremental . compile ( classpathElements , sources , outputDir , scalacOptions , new ArrayList < String > ( ) ) ; return 1 ; } 
private String findScalaVersionFromDependencies ( ) hrows Exception { return findVersionFromDependencies ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID ) ; } 
private void checkCorrectVersionsOfScalaLibrary ( String requiredScalaVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { JavaMainCaller cmd = getEmptyScalaCommand ( scalaClassName ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected List < String > getScalaOptions ( ) hrows Exception { List < String > options = new ArrayList < String > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; return options ; } 
protected File getLibraryJar ( ) hrows Exception { return getArtifactJar ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getCompilerJar ( ) hrows Exception { return getArtifactJar ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getArtifactJar ( String groupId , String artifactId , String version ) hrows Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , " jar " ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected File getArtifactJar ( String groupId , String artifactId , String version , String classifier ) hrows Exception { Artifact artifact = factory . createArtifactWithClassifier ( groupId , artifactId , version , " jar " , classifier ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected List < File > findSourceWithFilters ( List < File > sourceRootDirs ) hrows Exception { List < File > sourceFiles = new ArrayList < File > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensible to scala file order, file system can't garanty file order => unreproductible build error across platform to garanty reproductible command line we order file by path (os dependend). Collections.sort(sourceFiles); return sourceFiles; } 
public String oString ( ) { return " BasicArtifact( " + groupId + " , " + artifactId + " , " + version + " , " + classifier + " ) " ; } 
public void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) hrows Exception { addToClasspath ( factory . createDependencyArtifact ( groupId , artifactId , VersionRange . createFromVersion ( version ) , " jar " , classifier , Artifact . SCOPE_RUNTIME ) , classpath , addDependencies ) ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new HashSet < String > ( ) ; String sv = findScalaVersion ( ) . oString ( ) ; addToClasspath ( SCALA_GROUPID , " scala-compiler " , sv , ignoreClasspath ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
public static Analysis readAnalysis ( File file ) { AnalysisStore store = analysisStore ( file ) ; Option < Tuple2 < Analysis , CompileSetup > > result = store . get ( ) ; if ( result . isDefined ( ) ) { return result . get ( ) . _1 ( ) ; 
public static AnalysisStore analysisStore ( File file ) { Format < String > formatString = DefaultProtocol$ . MODULE$ . StringFormat ( ) ; Format < File > formatFile = fileFormat ( ) ; Format < Stamp > formatStamp = stampFormat ( hashStampFormat ( ) , lastModFormat ( ) , existsFormat ( ) ) ; Format < Map < File , Stamp > > formatMapFileStamp = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatStamp ) ; Format < Map < File , String > > formatMapFileString = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatString ) ; Format < Stamps > formatStamps = stampsFormat ( formatMapFileStamp , formatMapFileStamp , formatMapFileStamp , formatMapFileString ) ; Format < Map < File , Source > > formatMapFileSource = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , sourceFormat ( ) ) ; Format < Map < String , Source > > formatMapStringSource = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatString , sourceFormat ( ) ) ; Format < APIs > formatAPIs = apisFormat ( formatMapFileSource , formatMapStringSource ) ; Format < Set < File > > formatSetFile = DefaultProtocol$ . MODULE$ . immutableSetFormat ( formatFile ) ; Format < Set < String > > formatSetString = DefaultProtocol$ . MODULE$ . immutableSetFormat ( formatString ) ; Format < Map < File , Set < File > > > formatMapFileSetFile = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatSetFile ) ; Format < Map < File , Set < String > > > formatMapFileSetString = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatSetString ) ; Format < Map < String , Set < File > > > formatMapStringSetFile = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatString , formatSetFile ) ; Format < Relation < File , File > > formatRFF = relationFormat ( formatMapFileSetFile , formatMapFileSetFile ) ; Format < Relation < File , String > > formatRFS = relationFormat ( formatMapFileSetString , formatMapStringSetFile ) ; Format < Relations > formatRelations = relationsFormat ( formatRFF , formatRFF , formatRFF , formatRFS , formatRFS ) ; Format < Problem > formatProblem = problemFormat ( positionFormat ( ) , formatString , severityFormat ( ) ) ; Format < SourceInfo > formatSourceInfo = infoFormat ( formatProblem ) ; Format < Map < File , SourceInfo > > formatMapFileSourceInfo = DefaultProtocol$ . MODULE$ . immutableMapFormat ( formatFile , formatSourceInfo ) ; Format < SourceInfos > formatSourceInfos = infosFormat ( formatMapFileSourceInfo ) ; Format < Analysis > formatAnalysis = analysisFormat ( formatStamps , formatAPIs , formatRelations , formatSourceInfos ) ; Format < CompileOptions > formatOptions = optsFormat ( formatString ) ; Format < CompileSetup > formatSetup = setupFormat ( formatFile , formatOptions , formatString , orderFormat ( ) ) ; return FileBasedStore . apply ( file , formatAnalysis , formatSetup ) ; } 
public static File cacheLocation ( File file ) { return new File ( new File ( file . getParent ( ) , " cache " ) , file . getName ( ) ) ; } 
public < A > Seq < A > emptySeq ( ) { return scala . collection . Seq$ . MODULE$ . < A > empty ( ) ; } 
public ClassLoader scalaLoader ( File libraryJar , File compilerJar ) hrows Exception { File [ ] allJars = { libraryJar , compilerJar } ; return new URLClassLoader ( FileUtils . oURLs ( allJars ) , getClass ( ) . getClassLoader ( ) . getParent ( ) ) ; } 
public File compilerInterface ( String sbtVersion , File interfaceSrcJar , File xsbtiJar , sbt . ScalaInstance scalaInstance , xsbti . Logger log ) { File componentDir = new File ( SBT_INC_DIR , sbtVersion ) ; String id = COMPILER_INTERFACE_ID + " - " + scalaInstance . actualVersion ( ) + " - " + JAVA_VERSION ; File interfaceDir = new File ( componentDir , id ) ; interfaceDir . mkdirs ( ) ; File interfaceJar = new File ( interfaceDir , COMPILER_INTERFACE_ID + " .jar " ) ; if ( ! interfaceJar . exists ( ) ) { IC . compileInterfaceJar ( COMPILER_INTERFACE_ID , interfaceSrcJar , interfaceJar , xsbtiJar , scalaInstance , log ) ; } return interfaceJar ; } 
public void compile ( List < String > classpathElements , List < File > sourcesList , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = pathsToFiles ( classpathElements ) ; File [ ] classpath = fullClasspath . oArray ( new File [ fullClasspath . size ( ) ] ) ; File [ ] sources = sourcesList . oArray ( new File [ sourcesList . size ( ) ] ) ; String [ ] soptions = scalacOptions . oArray ( new String [ scalacOptions . size ( ) ] ) ; String [ ] joptions = javacOptions . oArray ( new String [ javacOptions . size ( ) ] ) ; Options options = new Options ( classpath , sources , classesDirectory , soptions , joptions ) ; Setup setup = new Setup ( classesDirectory , compilerCache ) ; Inputs inputs = new Inputs ( compilers , options , setup ) ; IC . compile ( inputs , logger ) ; } 
public File [ ] classpath ( ) { return classpath ; } 
public File classesDirectory ( ) { return classesDirectory ; } 
public String [ ] options ( ) { return scalacOptions ; } 
public String [ ] javacOptions ( ) { return javacOptions ; } 
public CompileOrder order ( ) { return CompileOrder . Mixed ; } 
public Maybe < Analysis > analysisMap ( File file ) { return SbtAnalysis . analysisMap ( file , classesDirectory ) ; } 
public DefinesClass definesClass ( File file ) { return SbtLocate . definesClass ( file ) ; } 
public GlobalsCache cache ( ) { return compilerCache ; } 
public xsbti . compile . Compilers < AnalyzingCompiler > compilers ( ) { return compilers ; } 
public xsbti . compile . Options options ( ) { return options ; } 
public xsbti . compile . Setup < Analysis > setup ( ) { return setup ; } 
public static DefinesClass definesClass ( File file ) { if ( file . isDirectory ( ) ) { return new DirectoryDefinesClass ( file ) ; 
public boolean apply ( String className ) { return entries . contains ( className ) ; } 
public boolean apply ( String className ) { return Locate . classFile ( file , className ) . isFile ( ) ; } 
public boolean apply ( String className ) { return false ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir ) hrows Exception , InterruptedException { String scalaVersion = findScalaVersion ( ) . oString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; if ( incremental = = null ) incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; incremental . compile ( classpathElements , sources , outputDir , scalacOptions , new ArrayList < String > ( ) ) ; return 1 ; } 
public void compile ( List < String > classpathElements , List < File > sourcesList , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = pathsToFiles ( classpathElements ) ; File [ ] classpath = fullClasspath . oArray ( new File [ fullClasspath . size ( ) ] ) ; File [ ] sources = sourcesList . oArray ( new File [ sourcesList . size ( ) ] ) ; String [ ] soptions = scalacOptions . oArray ( new String [ scalacOptions . size ( ) ] ) ; String [ ] joptions = javacOptions . oArray ( new String [ javacOptions . size ( ) ] ) ; Options options = new Options ( classpath , sources , classesDirectory , soptions , joptions ) ; Setup setup = new Setup ( fullClasspath , classesDirectory , compilerCache ) ; Inputs inputs = new Inputs ( compilers , options , setup ) ; IC . compile ( inputs , logger ) ; } 
public Maybe < Analysis > analysisMap ( File file ) { Maybe < Analysis > analysis = analysisMap . get ( file ) ; return ( analysis = = null ) ? SbtAnalysis . JUST_EMPTY_ANALYSIS : analysis ; } 
public static synchronized Analysis get ( File cacheFile ) { Analysis analysis = null ; SoftReference < Analysis > ref = cached . get ( cacheFile ) ; if ( ref ! = null ) { analysis = ref . get ( ) ; } if ( analysis = = null ) { if ( cacheFile . exists ( ) ) { analysis = IC . readAnalysis ( cacheFile ) ; } else { analysis = EMPTY_ANALYSIS ; } cached . put ( cacheFile , new SoftReference ( analysis ) ) ; } return analysis ; } 
public static synchronized void put ( File cacheFile , Analysis analysis ) { cached . put ( cacheFile , new SoftReference ( analysis ) ) ; } 
public void compile ( List < String > classpathElements , List < File > sourcesList , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = pathsToFiles ( classpathElements ) ; File [ ] classpath = fullClasspath . oArray ( new File [ fullClasspath . size ( ) ] ) ; File [ ] sources = sourcesList . oArray ( new File [ sourcesList . size ( ) ] ) ; String [ ] soptions = scalacOptions . oArray ( new String [ scalacOptions . size ( ) ] ) ; String [ ] joptions = javacOptions . oArray ( new String [ javacOptions . size ( ) ] ) ; Options options = new Options ( classpath , sources , classesDirectory , soptions , joptions ) ; Setup setup = new Setup ( fullClasspath , classesDirectory , compilerCache ) ; Inputs inputs = new Inputs ( compilers , options , setup ) ; Analysis analysis = IC . compile ( inputs , logger ) ; SbtAnalysis . put ( SbtAnalysis . cacheLocation ( classesDirectory ) , analysis ) ; } 
public Maybe < Analysis > analysisMap ( File file ) { Maybe < Analysis > analysis = analysisCache . get ( file ) ; return ( analysis = = null ) ? SbtAnalysis . JUST_EMPTY_ANALYSIS : analysis ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { long 0 = System . currentTimeMillis ( ) ; LastCompilationInfo lastCompilationInfo = LastCompilationInfo . find ( sourceRootDirs , outputDir ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = lastCompilationInfo . getLastSuccessfullTS ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long 1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , 1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) hrows Exception { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . oString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . oString ( ) . hashCode ( ) + " .timestamp " ) , outputDir ) ; } 
long getLastSuccessfullTS ( ) hrows Exception { long back = - 1 ; if ( _lastCompileAtFile . exists ( ) & & _outputDir . exists ( ) & & ( _outputDir . list ( ) . length > 0 ) ) { back = _lastCompileAtFile . lastModified ( ) ; } return back ; } 
void setLastSuccessfullTS ( long v ) hrows Exception { if ( ! _lastCompileAtFile . exists ( ) ) { FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
public static File fallbackCacheLocation ( File file ) { return new File ( new File ( file . getParent ( ) , " analysis " ) , file . getName ( ) ) ; } 
public void compile ( List < String > classpathElements , List < File > sourcesList , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap ) { List < File > fullClasspath = pathsToFiles ( classpathElements ) ; File [ ] classpath = fullClasspath . oArray ( new File [ fullClasspath . size ( ) ] ) ; File [ ] sources = sourcesList . oArray ( new File [ sourcesList . size ( ) ] ) ; String [ ] soptions = scalacOptions . oArray ( new String [ scalacOptions . size ( ) ] ) ; String [ ] joptions = javacOptions . oArray ( new String [ javacOptions . size ( ) ] ) ; Options options = new Options ( classpath , sources , classesDirectory , soptions , joptions ) ; cacheFile = ( cacheFile ! = null ) ? cacheFile : SbtAnalysis . fallbackCacheLocation ( classesDirectory ) ; Setup setup = new Setup ( fullClasspath , classesDirectory , cacheFile , cacheMap , compilerCache ) ; Inputs inputs = new Inputs ( compilers , options , setup ) ; Analysis analysis = IC . compile ( inputs , logger ) ; SbtAnalysis . put ( cacheFile , analysis ) ; } 
protected File getAnalysisCacheFile ( ) hrows Exception { return analysisCacheFile . getAbsoluteFile ( ) ; } 
protected int compile ( File sourceDir , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { getLog().warn("Using older form of compile"); return compile(Arrays.asList(sourceDir), outputDir, analysisCacheFile, classpathElements, compileInLoop); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( INCREMENTAL . equals ( recompileMode ) ) { return incrementalCompile ( getClasspathElements ( ) , getSourceDirectories ( ) , outputDir , analysisCacheFile ) ; } long 0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long 1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , 1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile ) hrows Exception , InterruptedException { String scalaVersion = findScalaVersion ( ) . oString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; if ( incremental = = null ) incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; incremental . compile ( classpathElements , sources , outputDir , scalacOptions , new ArrayList < String > ( ) , cacheFile , cacheMap ) ; return 1 ; } 
protected File defaultAnalysisDirectory ( MavenProject project ) { return new File ( project . getBuild ( ) . getDirectory ( ) , " analysis " ) ; } 
protected File defaultAnalysisCacheFile ( MavenProject project ) { return new File ( defaultAnalysisDirectory ( project ) , " compile " ) ; } 
protected File defaultTestAnalysisCacheFile ( MavenProject project ) { return new File ( defaultAnalysisDirectory ( project ) , " est-compile " ) ; } 
protected File getAnalysisCacheFile ( ) hrows Exception { hrow new UnsupportedOperationException ( " USELESS " ) ; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = FileUtils . fileOf ( mainSourceDir , useCanonicalPath ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } estSourceDir = FileUtils . fileOf ( estSourceDir , useCanonicalPath ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; estAnalysisCacheFile = FileUtils . fileOf ( estAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected File getAnalysisCacheFile ( ) hrows Exception { return estAnalysisCacheFile . getAbsoluteFile ( ) ; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < String > ( sources ) ; clone the list to keep the original unmodified sources.add(scalaSourceDir); } return normalize(sources); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile ) hrows Exception , InterruptedException { if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . oString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; } List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap ) ; return 1 ; } 
protected List < String > getJavacOptions ( ) hrows Exception { List < String > options = new ArrayList < String > ( ) ; if ( javacArgs ! = null ) Collections . addAll ( options , javacArgs ) ; if ( StringUtils . isNotEmpty ( addJavacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addJavacArgs , " | " ) ) ; } return options ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( INCREMENTAL . equals ( recompileMode ) ) { return incrementalCompile ( classpathElements , sourceRootDirs , outputDir , analysisCacheFile , compileInLoop ) ; } long 0 = System . currentTimeMillis ( ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = findLastSuccessfullCompilation ( outputDir ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } long 1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , 1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { setLastSuccessfullCompilation(outputDir, t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , Boolean compileInLoop ) hrows Exception , InterruptedException { if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . oString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; } List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } mainSourceDir = FileUtils . fileOf ( mainSourceDir , useCanonicalPath ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } estSourceDir = FileUtils . fileOf ( estSourceDir , useCanonicalPath ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; estAnalysisCacheFile = FileUtils . fileOf ( estAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & ! INCREMENTAL . equals ( recompileMode ) ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < String > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } List < String > estSources = new ArrayList < String > ( project . getTestCompileSourceRoots ( ) ) ; estSources . add ( FileUtils . pathOf ( estSourceDir , useCanonicalPath ) ) ; List < File > estSourceDirs = normalize ( estSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; estAnalysisCacheFile = FileUtils . fileOf ( estAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & ! INCREMENTAL . equals ( recompileMode ) ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception , InterruptedException { if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . oString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( scalaVersion , libraryJar , compilerJar , sbtVersion , xsbtiJar , interfaceSrcJar , residentCompilerLimit , getLog ( ) ) ; } List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { long 0 = System . currentTimeMillis ( ) ; LastCompilationInfo lastCompilationInfo = LastCompilationInfo . find ( sourceRootDirs , outputDir ) ; if ( _lastCompileAt < 0 ) { _lastCompileAt = lastCompilationInfo . getLastSuccessfullTS ( ) ; } List < File > files = getFilesToCompile ( sourceRootDirs , _lastCompileAt ) ; if ( files = = null ) { return - 1 ; } if ( files . size ( ) < 1 ) { return 0 ; } if ( ! outputDir . exists ( ) ) { outputDir . mkdirs ( ) ; } long 1 = System . currentTimeMillis ( ) ; getLog ( ) . info ( String . format ( " Compiling %d source files to %s at %d " , files . size ( ) , outputDir . getAbsolutePath ( ) , 1 ) ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . redirectToLog ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( classpathElements ) ) ; jcmd . addArgs ( " -d " , outputDir . getAbsolutePath ( ) ) ; jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
public void compile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) hrows Exception { if ( useServer ) { zincCompile ( baseDir , classpathElements , sources , classesDirectory , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) hrows Exception { List < String > arguments = new ArrayList < String > ( ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . oMultiPath ( extraPaths ) ) ; arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . oMultiPath ( classpathElements ) ) ; arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -J " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
private List < File > pathsToFiles ( List < String > paths ) { List < File > files = new ArrayList < File > ( paths . size ( ) ) ; for ( String path : paths ) { files . add ( new File ( path ) ) ; } return files ; } 
private String logLevelToString ( Log log ) { if ( log . isDebugEnabled ( ) ) return " debug " ; else if ( log . isInfoEnabled ( ) ) return " info " ; 
private String cacheMapToString ( Map < File , File > cacheMap ) hrows Exception { String analysisMap = " " ; boolean addComma = false ; for ( Map . Entry < File , File > entry : cacheMap . entrySet ( ) ) { if ( addComma ) analysisMap + = " , " ; analysisMap + = entry . getKey ( ) . getAbsolutePath ( ) ; analysisMap + = " : " ; analysisMap + = entry . getValue ( ) . getAbsolutePath ( ) ; addComma = rue ; } return analysisMap ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . oString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( useZincServer , zincPort , scalaVersion , libraryJar , compilerJar , extraJars , sbtVersion , xsbtiJar , interfaceSrcJar , getLog ( ) ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
protected Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) hrows Exception { Set < Artifact > result = new HashSet < Artifact > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , " pom " ) ; MavenProject project = mavenProjectBuilder . buildFromRepository ( pom , remoteRepos , localRepo ) ; Set < Artifact > dependencies = resolveDependencyArtifacts ( project ) ; result . addAll ( dependencies ) ; for ( Artifact dependency : dependencies ) { Set < Artifact > ransitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( ransitive ) ; } return result ; } 
private String logLevelToString ( Log l ) { if ( l . isDebugEnabled ( ) ) return " debug " ; else if ( l . isInfoEnabled ( ) ) return " info " ; 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this dupliated here? if (!outputDir.exists()) { outputDir.mkdirs(); } return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected File defaultAnalysisDirectory ( MavenProject p ) { return new File ( p . getBuild ( ) . getDirectory ( ) , " analysis " ) ; } 
protected File defaultAnalysisCacheFile ( MavenProject p ) { return new File ( defaultAnalysisDirectory ( p ) , " compile " ) ; } 
protected File defaultTestAnalysisCacheFile ( MavenProject p ) { return new File ( defaultAnalysisDirectory ( p ) , " est-compile " ) ; } 
private void oJson ( Object pojo , boolean prettyPrint , File f ) hrows Exception { ObjectMapper m = new ObjectMapper ( ) ; JsonFactory jf = new JsonFactory ( ) ; JsonGenerator jg = jf . createJsonGenerator ( f , JsonEncoding . UTF8 ) ; ry { if ( prettyPrint ) { 
protected List < List < String > > makeDependencies ( ScalaGenJsonMojo data ) hrows Exception { List < List < String > > back = new ArrayList < List < String > > ( ) ; List < Artifact > deps = data . project . getCompileArtifacts ( ) ; for ( Artifact dep : deps ) { List < String > e = new ArrayList < String > ( 3 ) ; e . add ( dep . getFile ( ) . getCanonicalPath ( ) ) ; e . add ( dep . getArtifactId ( ) + " / " + dep . getVersion ( ) ) ; back . add ( e ) ; } return back ; } 
protected List < String > makeArtifacts ( ScalaGenJsonMojo data ) hrows Exception { List < String > back = new ArrayList < String > ( ) ; List < MavenProject > modules = data . project . getCollectedProjects ( ) ; for ( MavenProject module : modules ) { back . add ( module . getArtifactId ( ) + " / " + module . getVersion ( ) ) ; } return back ; } 
protected Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) hrows Exception { Set < Artifact > result = new HashSet < Artifact > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , " pom " ) ; MavenProject p = mavenProjectBuilder . buildFromRepository ( pom , remoteRepos , localRepo ) ; Set < Artifact > d = resolveDependencyArtifacts ( p ) ; result . addAll ( d ) ; for ( Artifact dependency : d ) { Set < Artifact > ransitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( ransitive ) ; } return result ; } 
protected File getPluginArtifactJar ( String groupId , String artifactId , String version ) hrows Exception { return getPluginArtifactJar ( groupId , artifactId , version , null ) ; } 
public Collection < Dependency > elements ( MavenProjectAdapter project ) hrows DependencyResolutionRequiredException { Plugin me = project . getBuild ( ) . getPluginsAsMap ( ) . get ( " net.alchim31.maven:scala-maven-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( me . getDependencies ( ) ) ; return back ; } 
public void addJvmArgs ( String . . . args1 ) { if ( args1 ! = null ) { for ( String arg : args1 ) { 
public void addArgs ( String . . . args1 ) { if ( args1 ! = null ) { for ( String arg : args1 ) { 
private void ryDeleteArgFile ( List < String > cmd ) hrows Exception { String last = cmd . get ( cmd . size ( ) - 1 ) ; if ( last . endsWith ( MainHelper . argFileSuffix ) ) { File f = new File ( last ) ; 
public static File createArgFile ( List < String > args ) hrows IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); final PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile))); try { for(String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } finally { out.close(); } return argFile; } 
private String cacheMapToString ( Map < File , File > cacheMap ) hrows Exception { String analysisMap = " " ; boolean addComma = false ; for ( Map . Entry < File , File > entry : cacheMap . entrySet ( ) ) { if ( addComma ) analysisMap + = " , " ; analysisMap + = entry . getKey ( ) . getAbsolutePath ( ) ; analysisMap + = " ; " ; analysisMap + = entry . getValue ( ) . getAbsolutePath ( ) ; addComma = rue ; } return analysisMap ; } 
private String cacheMapToString ( Map < File , File > cacheMap ) hrows Exception { String analysisMap = " " ; boolean addArgSeparator = false ; for ( Map . Entry < File , File > entry : cacheMap . entrySet ( ) ) { if ( addArgSeparator ) analysisMap + = ANALYSIS_MAP_ARG_SEPARATOR ; analysisMap + = entry . getKey ( ) . getAbsolutePath ( ) ; analysisMap + = ANALYSIS_MAP_PAIR_SEPARATOR ; analysisMap + = entry . getValue ( ) . getAbsolutePath ( ) ; addArgSeparator = rue ; } return analysisMap ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { String scalaVersion = findScalaVersion ( ) . oString ( ) ; File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( useZincServer , zincPort , scalaVersion , libraryJar , compilerJar , extraJars , sbtVersion , xsbtiJar , interfaceSrcJar , getLog ( ) ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
private boolean hasMavenProjectDependency ( Set < String > classpath ) hrows MalformedURLException { ry { List < URL > urls = new ArrayList < URL > ( ) ; 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . addAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . removeAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { oRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); String sv = findScalaVersion().toString(); addToClasspath("org.scala-lang", "scala-compiler", sv, classpath); addToClasspath("org.scala-lang", "scala-library", sv, classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
public Collection < Dependency > elements ( MavenProject project ) hrows DependencyResolutionRequiredException { return project . getCompileDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProject project ) hrows DependencyResolutionRequiredException { return project . getRuntimeDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProject project ) hrows DependencyResolutionRequiredException { return project . getTestDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProject project ) hrows DependencyResolutionRequiredException { return project . getSystemDependencies ( ) ; } 
public Collection < Dependency > elements ( MavenProject project ) hrows DependencyResolutionRequiredException { Plugin me = project . getBuild ( ) . getPluginsAsMap ( ) . get ( " net.alchim31.maven:scala-maven-plugin " ) ; Set < Dependency > back = new HashSet < Dependency > ( ) ; Dependency dep = new Dependency ( ) ; dep . setArtifactId ( me . getArtifactId ( ) ) ; dep . setGroupId ( me . getGroupId ( ) ) ; dep . setVersion ( me . getVersion ( ) ) ; back . add ( dep ) ; back . addAll ( me . getDependencies ( ) ) ; return back ; } 
public abstract Collection < Dependency > elements ( MavenProject project ) hrows DependencyResolutionRequiredException ; public static Scopes lookup ( String name ) { for ( Scopes scope : Scopes . values ( ) ) { if ( scope . name ( ) . rim ( ) . equalsIgnoreCase ( name . rim ( ) ) ) { return scope ; } } return null ; } } } 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = Scopes . PLUGIN . name ( ) ; } } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = true;hasMavenProjectDependency(loader); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
public void estClassworldSeftFirstStrategy ( ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
protected List < String > getJavacOptions ( ) hrows Exception { List < String > options = new ArrayList < String > ( ) ; if ( javacArgs ! = null ) Collections . addAll ( options , javacArgs ) ; if ( StringUtils . isNotEmpty ( addJavacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addJavacArgs , " | " ) ) ; } issue #116 if (javacGenerateDebugSymbols) { options.add("-g"); } return options; } 
private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new HashSet < String > ( ) ; addToClasspath ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) , classpath ) ; addToClasspath(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString(), classpath); return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
protected List < String > getJavacOptions ( ) hrows Exception { List < String > options = new ArrayList < String > ( ) ; if ( javacArgs ! = null ) Collections . addAll ( options , javacArgs ) ; if ( StringUtils . isNotEmpty ( addJavacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addJavacArgs , " | " ) ) ; } issue #116 if (javacGenerateDebugSymbols) { options.add("-g"); } if (target != null) { options.add("-target"); options.add(target); } if (source != null) { options.add("-source"); options.add(source); } if (encoding != null) { options.add("-encoding"); options.add(encoding); } return options; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < String > ( ) ; String sv = findScalaVersion ( ) . oString ( ) ; addCompilerToClasspath ( sv , ignoreClasspath ) ; addLibraryToClasspath ( sv , ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", scalaVersion.toString(), classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected void addLibraryToClasspath ( Set < String > classpath ) hrows Exception { classpath . add ( FileUtils . pathOf ( getLibraryJar ( ) , useCanonicalPath ) ) ; } 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addCompilerToClasspath ( classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
private String getBootClasspath ( ) hrows Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addLibraryToClasspath ( classpath ) ; return MainHelper . oMultiPath ( classpath . oArray ( new String [ classpath . size ( ) ] ) ) ; } 
protected File getLibraryJar ( ) hrows Exception { if ( ! StringUtils . isEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-library.jar " ) ; } return getArtifactJar ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getCompilerJar ( ) hrows Exception { if ( ! StringUtils . isEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-compiler.jar " ) ; } return getArtifactJar ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < String > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < String > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<String>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . addAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . removeAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , VersionRange . createFromVersion ( dependency . getVersion ( ) ) , dependency . getType ( ) , dependency . getClassifier ( ) , dependency . getScope ( ) , dependency . isOptional ( ) ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { oRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( useZincServer , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
public boolean include ( Artifact artifact ) { SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public boolean accept ( DependencyNode node ) { return include ( node . getArtifact ( ) ) ; } 
public SpawnMonitor spawn ( boolean displayCmd ) hrows Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < String > ( ) ; String cmdStr = StringUtils . join ( cmd . iterator ( ) , " " ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . add ( cmdStr ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . add ( cmdStr ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return new SpawnMonitor(){ @Override 
public void addJvmArgs ( String . . . args0 ) { TODO - Ignore classpath if (args0 != null) { for (String arg : args0) { 
public SpawnMonitor spawn ( final boolean displayCmd ) hrows Exception { final Thread = new Thread ( ) { @Override public void run ( ) { ry { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } } }; t.start(); return new SpawnMonitor() { @Override 
public void addJvmArgs ( String . . . args0 ) { if ( args0 ! = null ) { for ( String arg : args0 ) { 
protected Set < Artifact > resolveDependencyArtifacts ( MavenProject heProject ) hrows Exception { AndArtifactFilter filter = new AndArtifactFilter(); filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST)); filter.add(new ArtifactFilter(){ public boolean include(Artifact artifact) { return !artifact.isOptional(); } }); TODO follow the dependenciesManagement and override rules Set<Artifact> artifacts = theProject.createArtifacts(factory, Artifact.SCOPE_RUNTIME, filter); for (Artifact artifact : artifacts) { resolver.resolve(artifact, remoteRepos, localRepo); } return artifacts; return theProject.getArtifacts(); } 
public void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) hrows Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( " jar " ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
private void configureClasspath ( Set < String > classpath ) hrows Exception , DependencyResolutionRequiredException { Collection < Dependency > oInclude = new ArrayList < Dependency > ( ) ; if ( includeScopes = = null | | includeScopes . length ( ) = = 0 ) { getLog ( ) . warn ( " No scopes were included " ) ; } else { String [ ] include = includeScopes . split ( " , " ) ; for ( String string : include ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . addAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Included Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } if ( excludeScopes ! = null & & excludeScopes . length ( ) > 0 ) { String [ ] exclude = excludeScopes . split ( " , " ) ; for ( String string : exclude ) { Scopes scope = Scopes . lookup ( string . oUpperCase ( ) ) ; if ( scope ! = null ) { oInclude . removeAll ( scope . elements ( project ) ) ; } else { getLog ( ) . warn ( " Excluded Scope: " + string + " is not one of: " + Arrays . asList ( Scopes . values ( ) ) ) ; } } } for ( Dependency dependency : oInclude ) { addToClasspath ( factory . createDependencyArtifact ( dependency ) , classpath , rue ) ; } if ( addToClasspath ! = null ) { classpath . addAll ( Arrays . asList ( addToClasspath . split ( " , " ) ) ) ; } if ( removeFromClasspath ! = null ) { ArrayList < String > oRemove = new ArrayList < String > ( ) ; String [ ] jars = removeFromClasspath . rim ( ) . split ( " , " ) ; for ( String string : classpath ) { for ( String jar : jars ) { if ( string . contains ( jar . rim ( ) ) ) { oRemove . add ( string ) ; } } } classpath . removeAll ( oRemove ) ; } String outputDirectory = project.getBuild().getOutputDirectory(); if(!outputDirectory.endsWith("/")){ need it to end with / for URLClassloader outputDirectory+="/"; } classpath.add( outputDirectory); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); TODO check that every entry from the classpath exists ! boolean ok = true; for (String s : classpath) { File f = new File(s); getLog().debug("classpath entry for running and compiling scripts: " + f); if (!f.exists()) { getLog().error("classpath entry for script not found : " + f); ok = false; } } if (!ok) { throw new MojoFailureException("some script dependencies not found (see log)"); } getLog().debug("Using the following classpath for running and compiling scripts: "+classpath); 
protected Set < Artifact > resolveDependencyArtifacts ( MavenProject heProject ) hrows Exception { AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( new ArtifactFilter ( ) { public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } } ) ; TODO follow the dependenciesManagement and override rules Set<Artifact> artifacts = theProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, filter); for (Artifact artifact : artifacts) { resolver.resolve(artifact, remoteRepos, localRepo); } return artifacts; } 
protected void checkScalaVersion ( ) hrows Exception { String sv = findScalaVersion ( ) . oString ( ) ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { getLog ( ) . warn ( String . format ( " local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s " , scalaHome , sv ) ) ; } if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( sv ) ; 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) hrows Exception { List < String > arguments = new ArrayList < String > ( ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . oMultiPath ( extraPaths ) ) ; arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . oMultiPath ( classpathElements ) ) ; arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -C " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; if(fork) { scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); } else { cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null); } HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:"+ getBootClasspath()); } return cmd; } 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if(fork) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<String>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new LinkedHashSet < String > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; addToClasspath(SCALA_GROUPID, "scala-decoder", scalaVersion, classpath); addToClasspath(SCALA_GROUPID, "scala-dbc", scalaVersion, classpath); if (dependencies != null) { for(BasicArtifact artifact: dependencies) { addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath); } } return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); } 
protected File getLibraryJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-library.jar " ) ; } return getArtifactJar ( SCALA_GROUPID , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getCompilerJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-compiler.jar " ) ; } return getArtifactJar ( SCALA_GROUPID , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
public boolean isZero ( ) { return ( major = = 0 ) & & ( minor = = 0 ) & & ( bugfix = = 0 ) ; } 
public void addToClasspath ( File entry ) hrows Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean found = false ; boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; if ( isClasspath ) { item = item + File . pathSeparator + entry . getCanonicalPath ( ) ; jvmArgs . set ( i , item ) ; isClasspath = false ; found = rue ; break ; } isClasspath = " -classpath " . equals ( item ) ; } if ( ! found ) { addJvmArgs ( " -classpath " , entry . getCanonicalPath ( ) ) ; 
protected List < File > findSourceWithFilters ( List < File > sourceRootDirs ) hrows Exception { List < File > sourceFiles = new ArrayList < File > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()])); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensitive to scala file order, file system can't guarantee file order => unreproducible build error across platforms sort files by path (OS dependent) to guarantee reproducible command line. Collections.sort(sourceFiles); return sourceFiles; } 
public SpawnMonitor spawn ( boolean displayCmd ) hrows Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < String > ( ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . addAll ( cmd ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . addAll ( cmd ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return new SpawnMonitor(){ @Override 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) hrows Exception { List < String > arguments = new ArrayList < String > ( extraArgs ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . oMultiPath ( extraPaths ) ) ; arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . oMultiPath ( classpathElements ) ) ; arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -C " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < String > ( ) : ( List < String > ) Arrays . asList ( addZincArgs . split ( " \\ | " ) ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( useZincServer , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) , zincArgs ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = true;hasMavenProjectDependency(loader); wrapScript(destFile, mavenProjectDependency); try { compileScript(scriptDir, destFile, classpath); 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this dupliated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if(failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory, artifactMetadataSource, null, artifactCollector )); 
private void checkArtifactForScalaVersion ( VersionNumber requiredScalaVersion , DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
public String oString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . oString ( ) ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( major < o . major ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( minor > o . minor ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( minor < o . minor ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( bugfix > o . bugfix ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( bugfix < o . bugfix ) ) { back = - 1 ; } return back ; } 
public boolean isZero ( ) { return ( major = = 0 ) & & ( minor = = 0 ) & & ( bugfix = = 0 ) ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( major < o . major ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( minor > - 1 ) & & ( minor > o . minor ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( minor > - 1 ) & & ( minor < o . minor ) ) { back = - 1 ; } if ( ( back = = 0 ) & & ( bugfix > - 1 ) & & ( bugfix > o . bugfix ) ) { back = 1 ; } if ( ( back = = 0 ) & & ( bugfix > - 1 ) & & ( bugfix < o . bugfix ) ) { back = - 1 ; } return back ; } 
public void estCompare ( ) hrows Exception { assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; } 
public void estParse ( ) hrows Exception { assertParseVN ( " 2.7.1 " , 2 , 7 , 1 , null ) ; assertParseVN ( " 2.7 " , 2 , 7 , 0 , null ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.RC " , 2 , 7 , 0 , " .RC " ) ; assertParseVN ( " 2.7-RC " , 2 , 7 , 0 , " -RC " ) ; assertParseVN ( " 2.7.1-SNAPSHOT " , 2 , 7 , 1 , " -SNAPSHOT " ) ; } 
private void assertParseVN ( String str , int major , int minor , int bugfix , String modifier ) { VersionNumber v = new VersionNumber ( str ) ; assertEquals ( " est major of " + str , major , v . major ) ; assertEquals ( " est minor of " + str , minor , v . minor ) ; assertEquals ( " est bugfix of " + str , bugfix , v . bugfix ) ; assertEquals ( " est modifier of " + str , modifier , v . modifier ) ; } 
public void estCompareMask ( ) hrows Exception { assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7-rc " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.0 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.2-rc1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; } 
private String findScalaVersionFromDependencies ( ) hrows Exception { return findVersionFromDependencies ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID ) ; } 
private void checkArtifactForScalaVersion ( VersionNumber requiredScalaVersion , DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) , getScalaOrganization ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < ArtifactFilter > filters = new ArrayList < ArtifactFilter > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( getScalaOrganization ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
protected File getLibraryJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-library.jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getCompilerJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , " scala-compiler.jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
public boolean isScalaDistroArtifact ( Artifact artifact ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
public boolean include ( Artifact artifact ) { SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder ) hrows Exception { List < String > arguments = new ArrayList < String > ( extraArgs ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . oMultiPath ( extraPaths ) ) ; if ( ! classpathElements . isEmpty ( ) ) { arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . oMultiPath ( classpathElements ) ) ; } arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -C " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
protected List < String > getClasspathElements ( ) hrows Exception { List < String > back = project . getCompileClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); back = TychoUtilities.addOsgiClasspathElements(project, back); return back; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this dupliated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<String>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { if (!paths.isEmpty())jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
private void compileScript ( File scriptDir , File destFile , Set < String > classpath ) hrows Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; if ( ! classpath . isEmpty ( ) ) jcmd . addArgs ( " -classpath " , MainHelper . oMultiPath ( new ArrayList < String > ( classpath ) ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
protected List < String > getClasspathElements ( ) hrows Exception { List < String > back = project . getTestClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); return back; } 
public static void main ( String [ ] args ) { System . out . println ( " Hello world " ) ; } 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private void compileScript ( File scriptDir , File destFile , URLClassLoader loader ) hrows Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oClasspathString ( loader ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); if (new VersionNumber("2.11.0").compareTo(scalaVersion) <= 0) { addToClasspath("jline", "jline", scalaVersion.toString(), classpath); } else if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", scalaVersion.toString(), classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); if (new VersionNumber("2.11.0").compareTo(scalaVersion) <= 0) { String version = scalaVersion.major + "." + scalaVersion.minor; addToClasspath("jline", "jline", version, classpath); } else if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", scalaVersion.toString(), classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
private IncOptions defaultOptions ( ) { sbt . inc . IncOptions defaultSbtOptions = sbt . inc . IncOptions . Default ( ) ; return new IncOptions ( defaultSbtOptions . ransitiveStep ( ) , 
protected void doExecute ( ) hrows Exception { TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability. VersionNumber scalaVersion = findScalaVersion(); Set<String> classpath = new LinkedHashSet<String>(); addCompilerToClasspath(classpath); addLibraryToClasspath(classpath); if (new VersionNumber("2.11.0").compareTo(scalaVersion) <= 0) { addToClasspath("jline", "jline", "2.12", classpath); } else if (new VersionNumber("2.9.0").compareTo(scalaVersion) <= 0) { addToClasspath("org.scala-lang", "jline", scalaVersion.toString(), classpath); } else { addToClasspath("jline", "jline", "0.9.94", classpath); } classpath.addAll(project.getCompileClasspathElements()); if (useTestClasspath) { classpath.addAll(project.getTestClasspathElements()); } if (useRuntimeClasspath) { classpath.addAll(project.getRuntimeClasspathElements()); } String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); JavaMainCaller jcmd = null; List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3); if(args != null) { for(String arg : args) { list.add(arg); } } list.add("-cp"); list.add(classpathStr); if(fork) { getLog().warn("scala-maven-plugin cannot fork scala console!! Running in process"); } jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()])); We need to make sure compiler plugins are sent into the interpreter as well! addCompilerPluginOptions(jcmd); if (javaRebelPath != null) { if (!javaRebelPath.exists()) { getLog().warn("javaRevelPath '"+javaRebelPath.getCanonicalPath()+"' not found"); } else { jcmd.addJvmArgs("-noverify", "-javaagent:" + javaRebelPath.getCanonicalPath()); } } jcmd.run(displayCmd); } 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader , String baseName ) hrows Exception { Class < ? > compiledScript = loader . loadClass ( baseName ) ; ClassLoader currentCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; ry { ry { 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) hrows IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream ) ; BufferedReader reader = null ; ry { if ( scriptFile ! = null ) { 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) hrows IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream , false , encoding ) ; BufferedReader reader = null ; ry { if ( scriptFile ! = null ) { 
public void estJdkSplit ( ) hrows Exception { assertEquals ( " Are you using JDK > 7? This failure is expected above JDK 7. " , 6 , " hello " . split ( " | " ) . length ) ; assertEquals ( 1 , " hello " . split ( " \\ | " ) . length ) ; assertEquals ( 2 , " hel|lo " . split ( " \\ | " ) . length ) ; assertEquals ( 3 , " hel||lo " . split ( " \\ | " ) . length ) ; } 
public static String fromToolchain ( Toolchain oolchain ) { String _javaExec = null ; if ( oolchain ! = null ) _javaExec = oolchain . findTool ( " java " ) ; if ( oolchain = = null | | _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; if ( _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { hrow new IllegalStateException ( " Couldn't locate java, try setting JAVA_HOME environment variable. " ) ; } } _javaExec + = File . separator + " bin " + File . separator + " java " ; } return _javaExec ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { String _javaExec = null ; if ( oolchain ! = null ) _javaExec = oolchain . findTool ( " java " ) ; if ( oolchain = = null | | _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; if ( _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { hrow new IllegalStateException ( " Couldn't locate java, try setting JAVA_HOME environment variable. " ) ; } } _javaExec + = File . separator + " bin " + File . separator + " java " ; } return _javaExec ; } 
public void compile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder , Toolchain oolchain ) hrows Exception { if ( useServer ) { zincCompile ( baseDir , classpathElements , sources , classesDirectory , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder , oolchain ) ; 
private void zincCompile ( File baseDir , List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , File cacheFile , Map < File , File > cacheMap , String compileOrder , Toolchain oolchain ) hrows Exception { List < String > arguments = new ArrayList < String > ( extraArgs ) ; arguments . add ( " -log-level " ) ; arguments . add ( logLevelToString ( log ) ) ; arguments . add ( " -scala-compiler " ) ; arguments . add ( compilerJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-library " ) ; arguments . add ( libraryJar . getAbsolutePath ( ) ) ; arguments . add ( " -scala-extra " ) ; List < String > extraPaths = new ArrayList < String > ( ) ; for ( File extraJar : extraJars ) { extraPaths . add ( extraJar . getAbsolutePath ( ) ) ; } arguments . add ( MainHelper . oMultiPath ( extraPaths ) ) ; if ( ! classpathElements . isEmpty ( ) ) { arguments . add ( " -classpath " ) ; arguments . add ( MainHelper . oMultiPath ( classpathElements ) ) ; } arguments . add ( " -d " ) ; arguments . add ( classesDirectory . getAbsolutePath ( ) ) ; for ( String scalacOption : scalacOptions ) { arguments . add ( " -S " + scalacOption ) ; } String javaHome = JavaLocator . findHomeFromToolchain ( oolchain ) ; if ( javaHome ! = null ) { log . info ( " Toolchain in scala-maven-plugin: " + javaHome ) ; arguments . add ( " -java-home " ) ; arguments . add ( javaHome ) ; } for ( String javacOption : javacOptions ) { arguments . add ( " -C " + javacOption ) ; } arguments . add ( " -compile-order " ) ; arguments . add ( compileOrder ) ; arguments . add ( " -analysis-cache " ) ; arguments . add ( cacheFile . getAbsolutePath ( ) ) ; arguments . add ( " -analysis-map " ) ; arguments . add ( cacheMapToString ( cacheMap ) ) ; for ( File source : sources ) { arguments . add ( source . getAbsolutePath ( ) ) ; } int exitCode = zinc . run ( arguments , baseDir , System . out , System . err ) ; if ( exitCode ! = 0 ) { xsbti . Problem [ ] problems = null ; 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < String > ( ) : ( List < String > ) Arrays . asList ( addZincArgs . split ( " \\ | " ) ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( useZincServer , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) , zincArgs ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder , oolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
public static String findHomeFromToolchain ( Toolchain oolchain ) { String executable = findExecutableFromToolchain ( oolchain ) ; if ( executable ! = null ) { File executableParent = new File ( executable ) . getParentFile ( ) ; 
protected JavaMainCaller getEmptyScalaCommand ( String mainClass ) hrows Exception { TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if(fork) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
public void estClassworldSeftFirstStrategy ( ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
protected void doExecute ( ) hrows Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private void handleJavaRebel ( final JavaMainCaller jcmd ) hrows IOException { if ( his . javaRebelPath ! = null ) { final String canonicalJavaRebelPath = his . javaRebelPath . getCanonicalPath ( ) ; 
private Set < String > setupClassPathForConsole ( final VersionNumber scalaVersion ) hrows Exception { final Set < String > classpath = new HashSet < String > ( ) ; classpath . addAll ( his . setupProjectClasspaths ( ) ) ; classpath . addAll ( his . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < String > setupProjectClasspaths ( ) hrows Exception { final Set < String > classpath = new HashSet < String > ( ) ; super . addCompilerToClasspath ( classpath ) ; super . addLibraryToClasspath ( classpath ) ; if ( his . useTestClasspath ) { classpath . addAll ( super . project . getTestClasspathElements ( ) ) ; } if ( his . useRuntimeClasspath ) { classpath . addAll ( super . project . getRuntimeClasspathElements ( ) ) ; } return classpath ; } 
private Set < String > setupConsoleClasspaths ( final VersionNumber scalaVersion ) hrows Exception { final Set < String > classpath = new HashSet < String > ( ) ; super . addToClasspath ( his . resolveJLine ( scalaVersion , his . fallbackJLine ( scalaVersion ) ) , classpath , rue ) ; return classpath ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) hrows Exception { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . oString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { super . getLog ( ) . warn ( a . oString ( ) ) ; if ( his . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; if ( artifactId . equals ( ScalaConsoleMojo . JLINE ) & & ( groupId . equals ( ScalaConsoleMojo . JLINE ) | | 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scala2_12_0M4.compareTo(scalaVersion) <= 0) { return super.factory.createArtifact(ScalaConsoleMojo.JLINE, ScalaConsoleMojo.JLINE, "2.14.1", "", ScalaMojoSupport.JAR); 
protected final Artifact scalaCompilerArtifact ( final String scalaVersion ) { return his . factory . createArtifact ( his . getScalaOrganization ( ) , ScalaMojoSupport . SCALA_COMPILER_ARTIFACTID , 
protected final Set < Artifact > resolveArtifactDependencies ( final Artifact artifact ) hrows Exception { final AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( new ArtifactFilter ( ) { public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } } ) ; Use the collection filter as the resolution filter. return resolveDependencyArtifacts(artifact, filter, 
public boolean include ( Artifact artifact ) { return ! artifact . isOptional ( ) ; } 
protected final Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter ) hrows Exception { return his . resolveDependencyArtifacts ( artifact , collectionFilter , 
protected final Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) hrows Exception { final ArtifactResolutionRequest arr = his . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return this.resolver.resolve(arr).getArtifacts(); } 
private ArtifactResolutionRequest createArtifactResolutionRequest ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = new ArtifactResolutionRequest ( ) ; arr . setArtifact ( artifact ) ; arr . setCollectionFilter ( collectionFilter ) ; arr . setResolutionFilter ( resolutionFilter ) ; arr . setResolveRoot ( false ) ; arr . setResolveTransitively ( rue ) ; arr . setRemoteRepositories ( remoteRepositories ) ; arr . setLocalRepository ( localRepository ) ; return arr ; } 
public void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) hrows Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) , classpath , addDependencies ) ; } 
public void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) hrows Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( ScalaMojoSupport . JAR ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { return his . getScalaCommand ( his . fork , his . scalaClassName ) ; 
protected final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) hrows Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected final JavaMainCaller getEmptyScalaCommand ( final String mainClass ) hrows Exception { return his . getEmptyScalaCommand ( mainClass , his . fork ) ; } 
protected JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) hrows Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != this.fork) { super.getLog().info("Fork behavior overridden"); super.getLog().info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if(forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
protected File getArtifactJar ( String groupId , String artifactId , String version ) hrows Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected File getArtifactJar ( String groupId , String artifactId , String version , String classifier ) hrows Exception { Artifact artifact = factory . createArtifactWithClassifier ( groupId , artifactId , version , ScalaMojoSupport . JAR , classifier ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) hrows Exception { Set < Artifact > result = new HashSet < Artifact > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , ScalaMojoSupport . POM ) ; Set < Artifact > d = resolveArtifactDependencies ( pom ) ; result . addAll ( d ) ; for ( Artifact dependency : d ) { Set < Artifact > ransitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( ransitive ) ; } return result ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < String > ( ) : ( List < String > ) Arrays . asList ( StringUtils . split ( addZincArgs , " | " ) ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( useZincServer , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) , zincArgs ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder , oolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) hrows Exception { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . oString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( his . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
public void jdkSplit ( ) hrows Exception { LevelState previous = new LevelState ( ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala:-1: info: compiling " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514 " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Recompiling 1 files " , previous , Level . INFO , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " wo errors found " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " BUILD ERROR " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " wrap: org.apache.commons.exec.ExecuteException: Process exited with an error: 1(Exit value: 1) " , previous , Level . ERROR , null ) ; } 
public void stringUtilsSplit ( ) hrows Exception { assertEquals ( 1 , StringUtils . split ( " hello " , " | " ) . length ) ; assertEquals ( 1 , StringUtils . split ( " hello| " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel|lo " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel||lo " , " | " ) . length ) ; } 
public void classworldSeftFirstStrategy ( ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
public void compare ( ) hrows Exception { assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; } 
public void parse ( ) hrows Exception { assertParseVN ( " 2.7.1 " , 2 , 7 , 1 , null ) ; assertParseVN ( " 2.7 " , 2 , 7 , 0 , null ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.RC " , 2 , 7 , 0 , " .RC " ) ; assertParseVN ( " 2.7-RC " , 2 , 7 , 0 , " -RC " ) ; assertParseVN ( " 2.7.1-SNAPSHOT " , 2 , 7 , 1 , " -SNAPSHOT " ) ; } 
public void compareMask ( ) hrows Exception { assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7-rc " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.0 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.2-rc1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; } 
private void assertParseVN ( String str , int major , int minor , int bugfix , String modifier ) { VersionNumber v = new VersionNumber ( str ) ; assertEquals ( " est major of " + str , major , v . major ) ; assertEquals ( " est minor of " + str , minor , v . minor ) ; assertEquals ( " est bugfix of " + str , bugfix , v . bugfix ) ; assertEquals ( " est modifier of " + str , modifier , v . modifier ) ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { String _javaExec = null ; if ( oolchain ! = null ) { _javaExec = oolchain . findTool ( " java " ) ; } if ( oolchain = = null | | _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; if ( _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { hrow new IllegalStateException ( " Couldn't locate java, try setting JAVA_HOME environment variable. " ) ; } } _javaExec + = File . separator + " bin " + File . separator + " java " ; } return _javaExec ; } 
public static String findHomeFromToolchain ( Toolchain oolchain ) { String executable = findExecutableFromToolchain ( oolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParent ( ) ; } 
public void shouldReturnNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain oolchain = new NullReturningToolChain ( ) ; System . setProperty ( " java.home " , " est " ) ; assertEquals ( " est/bin/java " , JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) hrows Exception { Toolchain oolchain = new ReturningToolChain ( ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
public void shouldThrowExceptionWhenNothingCouldBeFound ( ) { Toolchain oolchain = new NullReturningToolChain ( ) ; System . clearProperty ( " java.home " ) ; environmentVariables . set ( " JAVA_HOME " , null ) ; ry { JavaLocator . findExecutableFromToolchain ( oolchain ) ; 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) hrows Exception { String home = JavaLocator . findHomeFromToolchain ( new TestStringReturningToolChain ( ) ) ; assertEquals ( " parent " , home ) ; } 
public void shouldReturnWhenFileIsNotPresent ( ) hrows Exception { String home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( ) ) ; assertNull ( home ) ; } 
public String findTool ( String s ) { return null ; } 
public String findTool ( String s ) { return " parent/child/my-path-to-java " ; } 
public String findTool ( String s ) { return " my-path-to-java " ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { String _javaExec = null ; if ( oolchain ! = null ) { _javaExec = oolchain . findTool ( " java " ) ; } if ( oolchain = = null | | _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; Points to JRE home if (_javaExec == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } } _javaExec += File.separator + "bin" + File.separator + "java"; } return _javaExec; } 
public void shouldReturnNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain oolchain = new NullReturningToolChain ( ) ; environmentVariables . set ( " JAVA_HOME " , " est " ) ; assertEquals ( " est/bin/java " , JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) hrows Exception { String home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( ) ) ; assertNull ( home ) ; } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if(failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(project.getProjectBuildingRequest(), null)); } 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < DependencyNodeFilter > filters = new ArrayList < DependencyNodeFilter > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( getScalaOrganization ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if(failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = project.getProjectBuildingRequest(); request.setProject(project); checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(request, null)); } 
private static void downloadFileFromURL ( String urlString , File destination ) hrows Exception { URL website = new URL ( urlString ) ; ReadableByteChannel rbc ; rbc = Channels . newChannel ( website . openStream ( ) ) ; FileOutputStream fos = new FileOutputStream ( destination ) ; fos . getChannel ( ) . ransferFrom ( rbc , 0 , Long . MAX_VALUE ) ; fos . close ( ) ; rbc . close ( ) ; } 
protected void doExecute ( ) hrows Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
public void doExecute ( ) hrows Exception { if ( skip ) { getLog ( ) . info ( " Skipping javadoc generation " ) ; return ; } ry { generate ( null , Locale . getDefault ( ) ) ; 
protected void failOnError ( String prefix , Exception e ) hrows MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { hrow ( RuntimeException ) e ; } hrow new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception , InterruptedException { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; String sbtGroupId = SbtIncrementalCompiler . SBT_GROUP_ID ; String xsbtiArtifactId = SbtIncrementalCompiler . XSBTI_ARTIFACT_ID ; String compilerInterfaceArtifactId = SbtIncrementalCompiler . COMPILER_INTERFACE_ARTIFACT_ID ; String compilerInterfaceClassifier = SbtIncrementalCompiler . COMPILER_INTERFACE_CLASSIFIER ; String sbtVersion = findVersionFromPluginArtifacts ( sbtGroupId , SbtIncrementalCompiler . COMPILER_INTEGRATION_ARTIFACT_ID ) ; File xsbtiJar = getPluginArtifactJar ( sbtGroupId , xsbtiArtifactId , sbtVersion ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < String > ( ) : ( List < String > ) Arrays . asList ( StringUtils . split ( addZincArgs , " | " ) ) ; File interfaceSrcJar = getPluginArtifactJar ( sbtGroupId , compilerInterfaceArtifactId , sbtVersion , compilerInterfaceClassifier ) ; incremental = new SbtIncrementalCompiler ( useZincServer , zincHost , zincPort , libraryJar , compilerJar , extraJars , xsbtiJar , interfaceSrcJar , getLog ( ) , zincArgs ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; Map < File , File > cacheMap = getAnalysisCacheMap ( ) ; ry { incremental . compile ( project . getBasedir ( ) , classpathElements , sources , outputDir , scalacOptions , javacOptions , cacheFile , cacheMap , compileOrder , oolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<String>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { if (!paths.isEmpty())jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
protected List < String > getClasspathElements ( ) hrows Exception { List < String > back = project . getCompileClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); if (addToClasspath != null) { back.addAll(Arrays.asList(StringUtils.split(addToClasspath,","))); } back.addAll(TychoUtilities.addOsgiClasspathElements(project, back)); return back; } 
public Optional < CompileAnalysis > analysis ( File classpathEntry ) { return Optional . empty ( ) ; } 
public DefinesClass definesClass ( File classpathEntry ) { return Locate . definesClass ( classpathEntry ) ; } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions , String compileOrder ) { Inputs inputs = compiler . inputs ( classpathElements . stream ( ) . map ( File : : new ) . oArray ( size - > new File [ size ] ) , classpath sources.toArray(new File[]{}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[]{}), scalacOptions javacOptions.toArray(new String[]{}), javacOptions 100, maxErrors new Function[]{}, sourcePositionMappers toCompileOrder(compileOrder), order compilers, setup, compiler.emptyPreviousResult() ); Optional<AnalysisContents> analysisContents = analysisStore.get(); if (analysisContents.isPresent()) { AnalysisContents analysisContents0 = analysisContents.get(); CompileAnalysis previousAnalysis = analysisContents0.getAnalysis(); MiniSetup previousSetup = analysisContents0.getMiniSetup(); PreviousResult previousResult = PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup)); inputs = inputs.withPreviousResult(previousResult); } CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
private CompileOrder oCompileOrder ( String name ) { if ( name . equalsIgnoreCase ( CompileOrder . Mixed . name ( ) ) ) { return CompileOrder . Mixed ; 
public void race ( Function0 < Throwable > ) { if ( log . isDebugEnabled ( ) ) { log . debug ( . apply ( ) ) ; 
public void success ( Function0 < String > message ) { if ( log . isInfoEnabled ( ) ) { log . info ( " Success: " + message . apply ( ) ) ; 
public void log ( Enumeration . Value level , Function0 < String > message ) { if ( level . equals ( Level . Error ( ) ) ) { log . error ( message . apply ( ) ) ; 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; List < String > zincArgs = StringUtils . isEmpty ( addZincArgs ) ? new LinkedList < > ( ) : Arrays . asList ( StringUtils . split ( addZincArgs , " | " ) ) ; incremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , zincArgs , cacheFile ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; ry { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
protected File getLibraryJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_LIBRARY_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getReflectJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_REFLECT_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_REFLECT_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getCompilerJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_COMPILER_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getCompilerBridgeJar ( ) hrows Exception { VersionNumber scalaVersion = findScalaVersion ( ) ; String zincVersion = findVersionFromPluginArtifacts ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . ZINC_ARTIFACT_ID ) ) ; return getArtifactJar ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . COMPILER_BRIDGE_ARTIFACT_ID ) , zincVersion ) ; } 
public String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + major + '.' + minor ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { lgtm [java/constant-comparison] back = 1; } if ((back == 0) && (major < o.major)) { back = -1; } if ((back == 0) && (minor > o.minor)) { back = 1; } if ((back == 0) && (minor < o.minor)) { back = -1; } if ((back == 0) && (bugfix > o.bugfix)) { back = 1; } if ((back == 0) && (bugfix < o.bugfix)) { back = -1; } return back; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { lgtm [java/constant-comparison] back = 1; } if ((back == 0) && (major < o.major)) { back = -1; } if ((back == 0) && (minor > -1) && (minor > o.minor)) { back = 1; } if ((back == 0) && (minor > -1) && (minor < o.minor)) { back = -1; } if ((back == 0) && (bugfix > -1) && (bugfix > o.bugfix)) { back = 1; } if ((back == 0) && (bugfix > -1) && (bugfix < o.bugfix)) { back = -1; } return back; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; incremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , cacheFile ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; ry { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions , compileOrder ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { Inputs inputs = compiler . inputs ( classpathElements . stream ( ) . map ( File : : new ) . oArray ( size - > new File [ size ] ) , classpath sources.toArray(new File[]{}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[]{}), scalacOptions javacOptions.toArray(new String[]{}), javacOptions 100, maxErrors new Function[]{}, sourcePositionMappers compileOrder, order compilers, setup, compiler.emptyPreviousResult() ); Optional<AnalysisContents> analysisContents = analysisStore.get(); if (analysisContents.isPresent()) { AnalysisContents analysisContents0 = analysisContents.get(); CompileAnalysis previousAnalysis = analysisContents0.getAnalysis(); MiniSetup previousSetup = analysisContents0.getMiniSetup(); PreviousResult previousResult = PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup)); inputs = inputs.withPreviousResult(previousResult); } CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; incremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , cacheFile , compileOrder ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; ry { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
public static String pathOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
public static File fileOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) hrows Exception { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . oString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . oString ( ) . hashCode ( ) + " .timestamp " ) , outputDir ) ; } 
long getLastSuccessfullTS ( ) hrows Exception { long back = - 1 ; if ( _lastCompileAtFile . exists ( ) & & _outputDir . exists ( ) & & ( _outputDir . list ( ) . length > 0 ) ) { back = _lastCompileAtFile . lastModified ( ) ; } return back ; } 
void setLastSuccessfullTS ( long v ) hrows Exception { if ( ! _lastCompileAtFile . exists ( ) ) { FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; incremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , cacheFile , compileOrder ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; ry { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
protected void doExecute ( ) hrows Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private Set < String > setupClassPathForConsole ( final VersionNumber scalaVersion ) hrows Exception { final Set < String > classpath = new HashSet < String > ( ) ; classpath . addAll ( his . setupProjectClasspaths ( ) ) ; classpath . addAll ( his . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < String > setupProjectClasspaths ( ) hrows Exception { final Set < String > classpath = new HashSet < String > ( ) ; super . addCompilerToClasspath ( classpath ) ; super . addLibraryToClasspath ( classpath ) ; if ( his . useTestClasspath ) { classpath . addAll ( super . project . getTestClasspathElements ( ) ) ; } if ( his . useRuntimeClasspath ) { classpath . addAll ( super . project . getRuntimeClasspathElements ( ) ) ; } return classpath ; } 
private Set < String > setupConsoleClasspaths ( final VersionNumber scalaVersion ) hrows Exception { final Set < String > classpath = new HashSet < String > ( ) ; super . addToClasspath ( his . resolveJLine ( scalaVersion , his . fallbackJLine ( scalaVersion ) ) , classpath , rue ) ; return classpath ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) hrows Exception { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . oString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( his . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; if ( artifactId . equals ( ScalaConsoleMojo . JLINE ) & & ( groupId . equals ( ScalaConsoleMojo . JLINE ) | | 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scala2_12_0M4.compareTo(scalaVersion) <= 0) { return super.factory.createArtifact(ScalaConsoleMojo.JLINE, ScalaConsoleMojo.JLINE, "2.14.1", "", ScalaMojoSupport.JAR); 
protected List < File > getSourceDirectories ( ) hrows Exception { hrow new UnsupportedOperationException ( " USELESS " ) ; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < String > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } List < String > estSources = new ArrayList < String > ( project . getTestCompileSourceRoots ( ) ) ; estSources . add ( FileUtils . pathOf ( estSourceDir , useCanonicalPath ) ) ; List < File > estSourceDirs = normalize ( estSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; estAnalysisCacheFile = FileUtils . fileOf ( estAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & ! INCREMENTAL . equals ( recompileMode ) ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected void postCompileActions ( ) hrows Exception { } private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } } } 
protected void addLibraryToClasspath ( Set < String > classpath ) hrows Exception { classpath . add ( FileUtils . pathOf ( getLibraryJar ( ) , useCanonicalPath ) ) ; } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if(failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = project.getProjectBuildingRequest(); request.setProject(project); checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(request, null)); } 
protected final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) hrows Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
protected List < String > getJavacOptions ( ) hrows Exception { List < String > options = new ArrayList < String > ( ) ; if ( javacArgs ! = null ) Collections . addAll ( options , javacArgs ) ; if ( StringUtils . isNotEmpty ( addJavacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addJavacArgs , " | " ) ) ; } issue #116 if (javacGenerateDebugSymbols) { options.add("-g"); } if (target != null) { options.add("-target"); options.add(target); } if (source != null) { options.add("-source"); options.add(source); } if (encoding != null) { options.add("-encoding"); options.add(encoding); } return options; } 
protected File getLibraryJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_LIBRARY_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getCompilerJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_COMPILER_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
private static String scriptBaseNameOf ( File scriptFile , int idx ) { if ( scriptFile = = null ) { return " embeddedScript_ " + idx ; } int dot = scriptFile . getName ( ) . lastIndexOf ( '.' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + idx ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + idx ; } 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
protected List < String > getClasspathElements ( ) hrows Exception { List < String > back = project . getTestClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); return back; } 
public String oString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . oString ( ) ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { lgtm [java/constant-comparison] back = 1; } if ((back == 0) && (major < o.major)) { back = -1; } if ((back == 0) && (minor > o.minor)) { back = 1; } if ((back == 0) && (minor < o.minor)) { back = -1; } if ((back == 0) && (bugfix > o.bugfix)) { back = 1; } if ((back == 0) && (bugfix < o.bugfix)) { back = -1; } return back; } 
public boolean isZero ( ) { return ( major = = 0 ) & & ( minor = = 0 ) & & ( bugfix = = 0 ) ; } 
public String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + major + '.' + minor ; } 
public int compareTo ( VersionNumber o ) { int back = 0 ; if ( ( back = = 0 ) & & ( major > o . major ) ) { lgtm [java/constant-comparison] back = 1; } if ((back == 0) && (major < o.major)) { back = -1; } if ((back == 0) && (minor > -1) && (minor > o.minor)) { back = 1; } if ((back == 0) && (minor > -1) && (minor < o.minor)) { back = -1; } if ((back == 0) && (bugfix > -1) && (bugfix > o.bugfix)) { back = 1; } if ((back == 0) && (bugfix > -1) && (bugfix < o.bugfix)) { back = -1; } return back; } 
public boolean include ( Artifact artifact ) { TODO - Are we checking the right artifacts? return scalaOrganization.equalsIgnoreCase(artifact.getGroupId()) && SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public boolean accept ( DependencyNode node ) { return include ( node . getArtifact ( ) ) ; } 
protected void processLine ( String line , int level ) { ry { _previous = LogProcessorUtils . levelStateOf ( line , _previous ) ; 
public void addToClasspath ( File entry ) hrows Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean found = false ; boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; if ( isClasspath ) { item = item + File . pathSeparator + entry . getCanonicalPath ( ) ; jvmArgs . set ( i , item ) ; isClasspath = false ; found = rue ; break ; } isClasspath = " -classpath " . equals ( item ) ; } if ( ! found ) { addJvmArgs ( " -classpath " , entry . getCanonicalPath ( ) ) ; 
public static LevelState levelStateOf ( String line , LevelState previous ) hrows Exception { LevelState back = new LevelState ( ) ; String lineLowerCase = line . oLowerCase ( ) ; if ( lineLowerCase . indexOf ( " error " ) > - 1 ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . indexOf ( " warn " ) > - 1 ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; } 
public static File createArgFile ( List < String > args ) hrows IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); final PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile))); try { for(String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } finally { out.close(); } return argFile; } 
public static List < String > readArgFile ( File argFile ) hrows IOException { ArrayList < String > back = new ArrayList < String > ( ) ; final BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ; ry { String line = null ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } finally { in . close ( ) ; } return back ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { String _javaExec = null ; if ( oolchain ! = null ) { _javaExec = oolchain . findTool ( " java " ) ; } if ( oolchain = = null | | _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; Points to JRE home if (_javaExec == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } } _javaExec += File.separator + "bin" + File.separator + "java"; } return _javaExec; } 
public static String findHomeFromToolchain ( Toolchain oolchain ) { String executable = findExecutableFromToolchain ( oolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParent ( ) ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( ! compileInLoop & & INCREMENTAL . equals ( recompileMode ) ) { TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && INCREMENTAL.equals(recompileMode)) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } if ( incremental = = null ) { File libraryJar = getLibraryJar ( ) ; File reflectJar = getReflectJar ( ) ; File compilerJar = getCompilerJar ( ) ; List < File > extraJars = getCompilerDependencies ( ) ; extraJars . remove ( libraryJar ) ; File compilerBridgeJar = getCompilerBridgeJar ( ) ; incremental = new SbtIncrementalCompiler ( libraryJar , reflectJar , compilerJar , findScalaVersion ( ) , extraJars , compilerBridgeJar , getLog ( ) , cacheFile , compileOrder ) ; } classpathElements . remove ( outputDir . getAbsolutePath ( ) ) ; List < String > scalacOptions = getScalaOptions ( ) ; List < String > javacOptions = getJavacOptions ( ) ; ry { incremental . compile ( classpathElements , sources , outputDir , scalacOptions , javacOptions ) ; } catch ( xsbti . CompileFailed e ) { if ( compileInLoop ) { compileErrors = rue ; } else { hrow e ; } } return 1 ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) hrows Exception { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . oString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( his . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; if ( artifactId . equals ( ScalaConsoleMojo . JLINE ) & & ( groupId . equals ( ScalaConsoleMojo . JLINE ) | | 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } Inputs inputs = compiler . inputs ( fullClasspath . oArray ( new File [ ] { } ) , classpath sources.toArray(new File[]{}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[]{}), scalacOptions javacOptions.toArray(new String[]{}), javacOptions 100, maxErrors new Function[]{}, sourcePositionMappers compileOrder, order compilers, setup, compiler.emptyPreviousResult() ); Optional<AnalysisContents> analysisContents = analysisStore.get(); if (analysisContents.isPresent()) { AnalysisContents analysisContents0 = analysisContents.get(); CompileAnalysis previousAnalysis = analysisContents0.getAnalysis(); MiniSetup previousSetup = analysisContents0.getMiniSetup(); PreviousResult previousResult = PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup)); inputs = inputs.withPreviousResult(previousResult); } CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception , InterruptedException { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, compileInLoop); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
protected int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); File reflectJar = getReflectJar(); File compilerJar = getCompilerJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File compilerBridgeJar = getCompilerBridgeJar(); incremental = new SbtIncrementalCompiler(libraryJar, reflectJar, compilerJar, findScalaVersion(), extraJars, compilerBridgeJar, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < String > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } List < String > estSources = new ArrayList < String > ( project . getTestCompileSourceRoots ( ) ) ; estSources . add ( FileUtils . pathOf ( estSourceDir , useCanonicalPath ) ) ; List < File > estSourceDirs = normalize ( estSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; estAnalysisCacheFile = FileUtils . fileOf ( estAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & recompileMode ! = RecompileMode . incremental ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
public void execute ( ) { ry { if ( sourceDir ! = null ) { 
static String pathOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
static File fileOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < > ( sources ) ; clone the list to keep the original unmodified sources.add(scalaSourceDir); } return normalize(sources); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info(String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . oString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . oString ( ) . hashCode ( ) + " .timestamp " ) , outputDir ) ; } 
private int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); File reflectJar = getReflectJar(); File compilerJar = getCompilerJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File compilerBridgeJar = getCompilerBridgeJar(); incremental = new SbtIncrementalCompiler(libraryJar, reflectJar, compilerJar, findScalaVersion(), extraJars, compilerBridgeJar, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void doExecute ( ) hrows Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[]{})); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private Set < String > setupClassPathForConsole ( final VersionNumber scalaVersion ) hrows Exception { final Set < String > classpath = new HashSet < > ( ) ; classpath . addAll ( his . setupProjectClasspaths ( ) ) ; classpath . addAll ( his . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < String > setupProjectClasspaths ( ) hrows Exception { final Set < String > classpath = new HashSet < > ( ) ; super . addCompilerToClasspath ( classpath ) ; super . addLibraryToClasspath ( classpath ) ; if ( his . useTestClasspath ) { classpath . addAll ( super . project . getTestClasspathElements ( ) ) ; } if ( his . useRuntimeClasspath ) { classpath . addAll ( super . project . getRuntimeClasspathElements ( ) ) ; } return classpath ; } 
private Set < String > setupConsoleClasspaths ( final VersionNumber scalaVersion ) hrows Exception { final Set < String > classpath = new HashSet < > ( ) ; addToClasspath ( his . resolveJLine ( scalaVersion , his . fallbackJLine ( scalaVersion ) ) , classpath , rue ) ; return classpath ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . oString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( his . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; return artifactId . equals ( ScalaConsoleMojo . JLINE ) & & groupId . equals ( ScalaConsoleMojo . JLINE ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { JavaMainCaller jcmd = super . getScalaCommand ( ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " -verbose " , rue ) ; } return jcmd ; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } List < String > estSources = new ArrayList < > ( project . getTestCompileSourceRoots ( ) ) ; estSources . add ( FileUtils . pathOf ( estSourceDir , useCanonicalPath ) ) ; List < File > estSourceDirs = normalize ( estSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; estAnalysisCacheFile = FileUtils . fileOf ( estAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & recompileMode ! = RecompileMode . incremental ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
private void failOnError ( String prefix , Exception e ) hrows MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { hrow ( RuntimeException ) e ; } hrow new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271){ jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { if (!paths.isEmpty())jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
private void ryAggregateUpper ( MavenProject prj ) hrows Exception { if ( prj ! = null & & prj . hasParent ( ) & & canAggregate ( ) ) { MavenProject parent = prj . getParent ( ) ; 
public void doExecute ( ) hrows Exception { JavaMainCaller jcmd ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -help " ) ; jcmd . addArgs ( " -X " ) ; jcmd . addArgs ( " -Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -version " ) ; jcmd . run ( displayCmd ) ; } 
final Artifact scalaCompilerArtifact ( final String scalaVersion ) { return his . factory . createArtifact ( his . getScalaOrganization ( ) , ScalaMojoSupport . SCALA_COMPILER_ARTIFACTID , 
final Set < Artifact > resolveArtifactDependencies ( final Artifact artifact ) { final AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( art - > ! art . isOptional ( ) ) ; Use the collection filter as the resolution filter. return resolveDependencyArtifacts(artifact, filter, 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter ) { return resolveDependencyArtifacts ( artifact , collectionFilter , 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = his . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return this.resolver.resolve(arr).getArtifacts(); } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) hrows Exception { addToClasspath ( groupId , artifactId , version , classpath , rue ) ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) hrows Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) , classpath , addDependencies ) ; } 
private void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) hrows Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( ScalaMojoSupport . JAR ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) hrows Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( FileUtils . pathOf ( artifact . getFile ( ) , useCanonicalPath ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
void addLibraryToClasspath ( Set < String > classpath ) hrows Exception { classpath . add ( FileUtils . pathOf ( getLibraryJar ( ) , useCanonicalPath ) ) ; } 
private String findScalaVersionFromDependencies ( ) { return findVersionFromDependencies ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID ) ; } 
void checkScalaVersion ( ) hrows Exception { String sv = findScalaVersion ( ) . oString ( ) ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { getLog ( ) . warn ( String . format ( " local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s " , scalaHome , sv ) ) ; } if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( sv ) ; 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < DependencyNodeFilter > filters = new ArrayList < > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( getScalaOrganization ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { return getScalaCommand ( fork , scalaClassName ) ; } 
final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) hrows Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
final JavaMainCaller getEmptyScalaCommand ( final String mainClass ) hrows Exception { return getEmptyScalaCommand ( mainClass , fork ) ; } 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) hrows Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog().info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if(forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for(String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new LinkedHashSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return MainHelper . oMultiPath ( classpath . oArray ( new String [ ] { } ) ) ; } 
protected List < String > getScalaOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; return options ; } 
private File getArtifactJar ( String groupId , String artifactId , String version ) hrows Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
private Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) hrows Exception { Set < Artifact > result = new HashSet < > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , ScalaMojoSupport . POM ) ; Set < Artifact > d = resolveArtifactDependencies ( pom ) ; result . addAll ( d ) ; for ( Artifact dependency : d ) { Set < Artifact > ransitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( ransitive ) ; } return result ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
List < File > findSourceWithFilters ( ) hrows Exception { return findSourceWithFilters ( getSourceDirectories ( ) ) ; } 
List < File > findSourceWithFilters ( List < File > sourceRootDirs ) hrows Exception { List < File > sourceFiles = new ArrayList < > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[]{}), excludes.toArray(new String[]{})); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensitive to scala file order, file system can't guarantee file order => unreproducible build error across platforms sort files by path (OS dependent) to guarantee reproducible command line. Collections.sort(sourceFiles); return sourceFiles; } 
List < File > normalize ( List < String > compileSourceRootsList ) hrows Exception { List < File > newCompileSourceRootsList = new ArrayList < > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = FileUtils.fileOf(new File(srcDir), useCanonicalPath); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
static List < String > addOsgiClasspathElements ( MavenProject project , List < String > defaultClasspathElements ) { if ( getLocationsMethod = = null ) { return defaultClasspathElements ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return defaultClasspathElements ; List < String > osgiClasspath = new ArrayList < > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } osgiClasspath . addAll ( defaultClasspathElements ) ; return osgiClasspath ; } 
String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + major + '.' + minor ; } 
private boolean isScalaDistroArtifact ( Artifact artifact ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
void addJvmArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , String value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , File value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , boolean value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) void run(boolean displayCmd) throws Exception; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void run ( boolean displayCmd ) hrows Exception ; SpawnMonitor spawn ( boolean displayCmd ) hrows Exception ; } 
boolean run ( boolean displayCmd , boolean hrowFailure ) hrows Exception ; SpawnMonitor spawn ( boolean displayCmd ) hrows Exception ; } 
public SpawnMonitor spawn ( boolean displayCmd ) hrows Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < > ( ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . addAll ( cmd ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . addAll ( cmd ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return () -> { try { 
private List < String > buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back ; } 
private void ryDeleteArgFile ( List < String > cmd ) { String last = cmd . get ( cmd . size ( ) - 1 ) ; if ( last . endsWith ( MainHelper . argFileSuffix ) ) { File f = new File ( last ) ; 
private long lengthOf ( List < String > l , long sepLength ) { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
public SpawnMonitor spawn ( final boolean displayCmd ) { final Thread = new Thread ( ( ) - > { ry { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } }); t.start(); return t::isAlive; } 
private void runInternal ( boolean displayCmd ) hrows Exception { String [ ] argArray = args . oArray ( new String [ ] { } ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
public static LevelState levelStateOf ( String line , LevelState previous ) { LevelState back = new LevelState ( ) ; String lineLowerCase = line . oLowerCase ( ) ; if ( lineLowerCase . contains ( " error " ) ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . contains ( " warn " ) ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; } 
public static String oClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new LinkedList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . oString ( ) ; } 
private static void appendUrlToClasspathCollection ( ClassLoader cl , Collection < String > classpath ) { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } while ( cl ! = null ) { if ( cl instanceof URLClassLoader ) { 
static File createArgFile ( List < String > args ) hrows IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile)))) { for (String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } return argFile; } 
static List < String > readArgFile ( File argFile ) hrows IOException { ArrayList < String > back = new ArrayList < > ( ) ; ry ( BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ) { String line ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } return back ; } 
static String locateJar ( Class < ? > c ) hrows Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; Matcher m = p . matcher ( location . oString ( ) ) ; if ( m . find ( ) ) { return URLDecoder . decode ( m . group ( 1 ) , " UTF-8 " ) ; } hrow new ClassNotFoundException ( " Cannot parse location of ' " + location + " '. Probably not loaded from a Jar " ) ; } hrow new ClassNotFoundException ( " Cannot find class ' " + c . getName ( ) + " using the classloader " ) ; } 
static String findHomeFromToolchain ( Toolchain oolchain ) { String executable = findExecutableFromToolchain ( oolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParent ( ) ; } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } Inputs inputs = compiler . inputs ( fullClasspath . oArray ( new File [ ] { } ) , classpath sources.toArray(new File[] {}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors new Function[] {}, sourcePositionMappers compileOrder, order compilers, setup, compiler.emptyPreviousResult()); Optional<AnalysisContents> analysisContents = analysisStore.get(); if (analysisContents.isPresent()) { AnalysisContents analysisContents0 = analysisContents.get(); CompileAnalysis previousAnalysis = analysisContents0.getAnalysis(); MiniSetup previousSetup = analysisContents0.getMiniSetup(); PreviousResult previousResult = PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup)); inputs = inputs.withPreviousResult(previousResult); } CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
static String pathOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
static File fileOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < > ( sources ) ; clone the list to keep the original unmodified sources.add(scalaSourceDir); } return normalize(sources); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately return incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); } long t0 = System.currentTimeMillis(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long t1 = System.currentTimeMillis(); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info( String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %d s", (t1 - t0) / 1000)); getLog().info(String.format("compile in %d s", (System.currentTimeMillis() - t1) / 1000)); _lastCompileAt = t1; return files.size(); } 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . oString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . oString ( ) . hashCode ( ) + " .timestamp " ) , outputDir ) ; 
private int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); File reflectJar = getReflectJar(); File compilerJar = getCompilerJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File compilerBridgeJar = getCompilerBridgeJar(); incremental = new SbtIncrementalCompiler(libraryJar, reflectJar, compilerJar, findScalaVersion(), extraJars, compilerBridgeJar, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void doExecute ( ) hrows Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[] {})); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . oString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( his . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scala2_12_0M4.compareTo(scalaVersion) <= 0) { return super.factory.createArtifact(ScalaConsoleMojo.JLINE, ScalaConsoleMojo.JLINE, "2.14.1", "", 
protected void postCompileActions ( ) hrows Exception { } private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) 
private void failOnError ( String prefix , Exception e ) hrows MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { hrow ( RuntimeException ) e ; } hrow new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; Quick fix in case the user has not added the "add-source" goal. String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath); if (!sources.contains(scalaSourceDir)) { sources.add(scalaSourceDir); } return normalize(sources); } 
public boolean canGenerateReport ( ) { there is modules to aggregate boolean back = ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0); back = back || (findSourceFiles().size() != 0); return back; } 
private boolean canAggregate ( ) { return StringUtils . isNotEmpty ( vscaladocVersion ) & & ( new VersionNumber ( vscaladocVersion ) . compareTo ( new VersionNumber ( " 1.1 " ) ) > = 0 ) ; 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271) { jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 List<String> paths = new ArrayList<>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { if (!paths.isEmpty()) jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
final Artifact scalaCompilerArtifact ( final String scalaVersion ) { return his . factory . createArtifact ( his . getScalaOrganization ( ) , ScalaMojoSupport . SCALA_COMPILER_ARTIFACTID , scalaVersion , " " , ScalaMojoSupport . POM ) ; 
final Set < Artifact > resolveArtifactDependencies ( final Artifact artifact ) { final AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( art - > ! art . isOptional ( ) ) ; Use the collection filter as the resolution filter. return resolveDependencyArtifacts(artifact, filter, filter); } 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter ) { return resolveDependencyArtifacts ( artifact , collectionFilter , resolutionFilter , his . remoteRepos , his . localRepo ) ; 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = his . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return this.resolver.resolve(arr).getArtifacts(); } 
private ArtifactResolutionRequest createArtifactResolutionRequest ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = new ArtifactResolutionRequest ( ) ; arr . setArtifact ( artifact ) ; arr . setCollectionFilter ( collectionFilter ) ; arr . setResolutionFilter ( resolutionFilter ) ; arr . setResolveRoot ( false ) ; arr . setResolveTransitively ( rue ) ; arr . setRemoteRepositories ( remoteRepositories ) ; arr . setLocalRepository ( localRepository ) ; return arr ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) hrows Exception { addToClasspath ( groupId , artifactId , version , classpath , rue ) ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) hrows Exception { addToClasspath ( factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) , 
private void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) hrows Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( ScalaMojoSupport . JAR ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
void checkScalaVersion ( ) hrows Exception { String sv = findScalaVersion ( ) . oString ( ) ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { getLog ( ) . warn ( String . format ( " local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s " , scalaHome , sv ) ) ; } if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( sv ) ; 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = project.getProjectBuildingRequest(); request.setProject(project); checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(request, null)); } 
private void checkArtifactForScalaVersion ( VersionNumber requiredScalaVersion , DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) , getScalaOrganization ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) hrows Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) hrows Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog().info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if (forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for (String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext("jdk", session)); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new LinkedHashSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return MainHelper . oMultiPath ( classpath . oArray ( new String [ ] { } ) ) ; } 
protected List < String > getScalaOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; return options ; } 
protected File getCompilerJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_COMPILER_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; } 
protected File getCompilerBridgeJar ( ) hrows Exception { VersionNumber scalaVersion = findScalaVersion ( ) ; String zincVersion = findVersionFromPluginArtifacts ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . ZINC_ARTIFACT_ID ) ) ; return getArtifactJar ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . COMPILER_BRIDGE_ARTIFACT_ID ) , 
protected List < File > getCompilerDependencies ( ) hrows Exception { List < File > d = new ArrayList < > ( ) ; if ( StringUtils . isEmpty ( scalaHome ) ) { for ( Artifact artifact : getAllDependencies ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ) { d . add ( artifact . getFile ( ) ) ; } } else { for ( File f : new File ( scalaHome , " lib " ) . listFiles ( ) ) { String name = f . getName ( ) ; if ( name . endsWith ( " .jar " ) & & ! name . contains ( " scala-library " ) & & ! name . contains ( " scala-compiler " ) ) { d . add ( f ) ; } } } return d ; } 
private File getArtifactJar ( String groupId , String artifactId , String version ) hrows Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
private Set < Artifact > getAllDependencies ( String groupId , String artifactId , String version ) hrows Exception { Set < Artifact > result = new HashSet < > ( ) ; Artifact pom = factory . createArtifact ( groupId , artifactId , version , " " , ScalaMojoSupport . POM ) ; Set < Artifact > d = resolveArtifactDependencies ( pom ) ; result . addAll ( d ) ; for ( Artifact dependency : d ) { Set < Artifact > ransitive = getAllDependencies ( dependency . getGroupId ( ) , dependency . getArtifactId ( ) , dependency . getVersion ( ) ) ; result . addAll ( ransitive ) ; } return result ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<>(); TODO - Pull in transitive dependencies. addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; Toolchain oolchain = oolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( his , mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile , oolchain ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ i ] . mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , oolchain ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ 0 ] . mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , oolchain ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript.importFrom("mojo", MavenProject.class.getPackage().getName()); rScript.importFrom("mojo", MavenSession.class.getPackage().getName()); rScript.importFrom("mojo", Log.class.getPackage().getName()); rScript.importFrom("mojo", "org.apache.maven"); add the script directory to the classpath rScript.addURL(scriptDir.toURI().toURL()); for (String string : classpath) { rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
List < File > findSourceWithFilters ( List < File > sourceRootDirs ) hrows Exception { List < File > sourceFiles = new ArrayList < > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles(dir, includes.toArray(new String[] {}), excludes.toArray(new String[] {})); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensitive to scala file order, file system can't guarantee file order => unreproducible build error across platforms sort files by path (OS dependent) to guarantee reproducible command line. Collections.sort(sourceFiles); return sourceFiles; } 
protected List < String > getClasspathElements ( ) hrows Exception { List < String > back = project . getTestClasspathElements ( ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; back.add(getOutputDir().getAbsolutePath()); return back; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = estSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; } 
public String oString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . oString ( ) ; } 
private boolean isScalaDistroArtifact ( Artifact artifact ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
public void logScalaDependents ( ) { _log . warn ( " Expected all dependencies to require Scala version: " + _version ) ; for ( String dependString : scalaDependentArtifactStrings ) { _log . warn ( dependString ) ; 
public boolean include ( Artifact artifact ) { TODO - Are we checking the right artifacts? return scalaOrganization.equalsIgnoreCase(artifact.getGroupId()) && SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public static String makeArtifactNameString ( Artifact artifact ) { TODO - Handle version ranges... if (artifact == null) { return "<null artifact>"; } return artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getVersion(); } 
void addJvmArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , String value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , File value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , boolean value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) void run(boolean displayCmd) throws Exception; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void run ( boolean displayCmd ) hrows Exception ; SpawnMonitor spawn ( boolean displayCmd ) hrows Exception ; } 
public SpawnMonitor spawn ( boolean displayCmd ) hrows Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < > ( ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . addAll ( cmd ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . addAll ( cmd ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return () -> { try { 
private void ryDeleteArgFile ( List < String > cmd ) { String last = cmd . get ( cmd . size ( ) - 1 ) ; if ( last . endsWith ( MainHelper . argFileSuffix ) ) { File f = new File ( last ) ; 
public void addJvmArgs ( String . . . args0 ) { TODO - Ignore classpath if (args0 != null) { for (String arg : args0) { 
private void runInternal ( boolean displayCmd ) hrows Exception { String [ ] argArray = args . oArray ( new String [ ] { } ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
public void addJvmArgs ( String . . . args0 ) { if ( args0 ! = null ) { for ( String arg : args0 ) { 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addArgs ( String . . . args1 ) { if ( args1 ! = null ) { for ( String arg : args1 ) { 
public static String oClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new LinkedList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . oString ( ) ; } 
private static String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " .* \\ s.* " ) ) { return '"' + arg + '"' ; } return arg ; } 
private static String unescapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . charAt ( 0 ) = = '"' & & arg . charAt ( arg . length ( ) - 1 ) = = '"' ) { return arg . substring ( 1 , arg . length ( ) - 1 ) ; } return arg ; } 
static File createArgFile ( List < String > args ) hrows IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile)))) { for (String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } return argFile; } 
static String locateJar ( Class < ? > c ) hrows Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; Matcher m = p . matcher ( location . oString ( ) ) ; if ( m . find ( ) ) { return URLDecoder . decode ( m . group ( 1 ) , " UTF-8 " ) ; } hrow new ClassNotFoundException ( " Cannot parse location of ' " + location + " '. Probably not loaded from a Jar " ) ; } hrow new ClassNotFoundException ( " Cannot find class ' " + c . getName ( ) + " using the classloader " ) ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { String _javaExec = null ; if ( oolchain ! = null ) { _javaExec = oolchain . findTool ( " java " ) ; } if ( oolchain = = null | | _javaExec = = null ) { _javaExec = System . getenv ( " JAVA_HOME " ) ; if ( _javaExec = = null ) { _javaExec = System . getProperty ( " java.home " ) ; Points to JRE home if (_javaExec == null) { throw new IllegalStateException( "Couldn't locate java, try setting JAVA_HOME environment variable."); } } _javaExec += File.separator + "bin" + File.separator + "java"; } return _javaExec; } 
static String findHomeFromToolchain ( Toolchain oolchain ) { String executable = findExecutableFromToolchain ( oolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParent ( ) ; } 
public void jdkSplit ( ) hrows Exception { LevelState previous = new LevelState ( ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala:-1: info: compiling " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514 " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Recompiling 1 files " , previous , Level . INFO , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " wo errors found " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " BUILD ERROR " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " wrap: org.apache.commons.exec.ExecuteException: Process exited with an error: 1(Exit value: 1) " , previous , 
private LevelState assertLevelState ( String input , LevelState previous , Level expectedLevel , String expectedUntilContains ) hrows Exception { LevelState back = LogProcessorUtils . levelStateOf ( input , previous ) ; assertEquals ( expectedLevel , back . level ) ; assertEquals ( expectedUntilContains , back . untilContains ) ; return back ; } 
public void classworldSeftFirstStrategy ( ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
public void compare ( ) hrows Exception { assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; } 
public void parse ( ) hrows Exception { assertParseVN ( " 2.7.1 " , 2 , 7 , 1 , null ) ; assertParseVN ( " 2.7 " , 2 , 7 , 0 , null ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.1.RC " , 2 , 7 , 1 , " .RC " ) ; assertParseVN ( " 2.7.RC " , 2 , 7 , 0 , " .RC " ) ; assertParseVN ( " 2.7-RC " , 2 , 7 , 0 , " -RC " ) ; assertParseVN ( " 2.7.1-SNAPSHOT " , 2 , 7 , 1 , " -SNAPSHOT " ) ; } 
public void compareMask ( ) hrows Exception { assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( 0 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( - 1 , new VersionNumberMask ( " 2.7 " ) . compareTo ( new VersionNumber ( " 3.0 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7-rc " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.0 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; assertEquals ( 1 , new VersionNumber ( " 2.7.2-rc1 " ) . compareTo ( new VersionNumberMask ( " 2.7 " ) ) ) ; } 
String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + ( modifier = = null ? ( major + " . " + minor ) : oString ( ) ) ; } 
protected File getCompilerBridgeJar ( ) hrows Exception { VersionNumber scalaVersion = findScalaVersion ( ) ; String zincVersion = findVersionFromPluginArtifacts ( SbtIncrementalCompiler . SBT_GROUP_ID , SbtIncrementalCompiler . ZINC_ARTIFACT_ID ) ; return getArtifactJar ( SbtIncrementalCompiler . SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( SbtIncrementalCompiler . COMPILER_BRIDGE_ARTIFACT_ID ) , 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , List < String > classpathElements , boolean compileInLoop ) hrows Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info( String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private PreviousResult previousResult ( ) { Optional < AnalysisContents > analysisContents = analysisStore . get ( ) ; if ( analysisContents . isPresent ( ) ) { AnalysisContents analysisContents0 = analysisContents . get ( ) ; 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } Inputs inputs = compiler . inputs ( fullClasspath.toArray(new File[] {}), classpath sources.toArray(new File[] {}), sources classesDirectory, classesDirectory scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors new Function[] {}, sourcePositionMappers compileOrder, order compilers, compilers setup, setup previousResult(), pr Optional.empty() temporaryClassesDirectory ); CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } CompileOptions options = CompileOptions . of ( fullClasspath.toArray(new File[] {}), classpath sources.toArray(new File[] {}), sources classesDirectory, scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors pos -> pos, sourcePositionMappers compileOrder, order Optional.empty() temporaryClassesDirectory ); Inputs inputs = Inputs.of(compilers, options, setup, previousResult()); CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
protected File getCompilerBridgeJar ( ) hrows Exception { VersionNumber scalaVersion = findScalaVersion ( ) ; String zincVersion = findVersionFromPluginArtifacts ( SBT_GROUP_ID , ZINC_ARTIFACT_ID ) ; return getArtifactJar ( SBT_GROUP_ID , scalaVersion . applyScalaArtifactVersioningScheme ( COMPILER_BRIDGE_ARTIFACT_ID ) , zincVersion ) ; 
private int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, getCompilerBridgeJar(), getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected File getArtifactJar ( String groupId , String artifactId , String version ) hrows Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
public void compile ( List < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } CompileOptions options = CompileOptions . of ( fullClasspath.toArray(new File[] {}), classpath sources.toArray(new File[] {}), sources classesDirectory, scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors pos -> pos, sourcePositionMappers compileOrder, order Optional.empty() temporaryClassesDirectory ); Inputs inputs = Inputs.of(compilers, options, setup, previousResult()); CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
private String compilerBridgeArtifactId ( String scalaVersion ) { if ( scalaVersion . startsWith ( " 2.10. " ) ) { return " compiler-bridge_2.10 " ; 
private Artifact createJarArtifact ( String groupId , String artifactId , String version , String classifier ) { return classifier = = null ? repositorySystem . createArtifact ( groupId , artifactId , version , ScalaMojoSupport . JAR ) : repositorySystem . createArtifactWithClassifier ( groupId , artifactId , version , ScalaMojoSupport . JAR , 
private Set < Artifact > resolve ( Artifact artifact , boolean ransitively ) { ArtifactResolutionRequest request = new ArtifactResolutionRequest ( ) .setArtifact(artifact) .setResolveRoot(true) .setResolveTransitively(transitively) .setServers(session.getRequest().getServers()) .setMirrors(session.getRequest().getMirrors()) .setProxies(session.getRequest().getProxies()) .setLocalRepository(session.getLocalRepository()) .setRemoteRepositories(session.getCurrentProject().getRemoteArtifactRepositories()); return repositorySystem.resolve(request).getArtifacts(); } 
private int incrementalCompile ( List < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
final Artifact scalaCompilerArtifact ( String scalaVersion ) { return factory . createArtifact ( getScalaOrganization ( ) , ScalaMojoSupport . SCALA_COMPILER_ARTIFACTID , scalaVersion , " " , ScalaMojoSupport . POM ) ; 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = his . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return factory.resolve(arr).getArtifacts(); } 
public static List < File > listDirectoryContent ( Path directory , Function < File , Boolean > filter ) hrows IOException { List < File > files = new ArrayList < > ( ) ; Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) { File f = file . oFile ( ) ; if ( filter . apply ( f ) ) { files . add ( f ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { File f = dir . oFile ( ) ; if ( ! dir . equals ( directory ) & & filter . apply ( f ) ) { files . add ( f ) ; } return FileVisitResult . CONTINUE ; } } ) ; return files ; } 
public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) { File f = file . oFile ( ) ; if ( filter . apply ( f ) ) { files . add ( f ) ; } return FileVisitResult . CONTINUE ; } 
public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { File f = dir . oFile ( ) ; if ( ! dir . equals ( directory ) & & filter . apply ( f ) ) { files . add ( f ) ; } return FileVisitResult . CONTINUE ; } 
public static void deleteDirectory ( Path directory ) { ry { Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { 
public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) hrows IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } 
public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) hrows IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } 
public void shouldReturnNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain oolchain = new NullReturningToolChain ( ) ; environmentVariables . set ( " JAVA_HOME " , " est " ) ; assertEquals ( Paths . get ( " est " , " bin " , " java " ) . oString ( ) , JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
static List < String > addOsgiClasspathElements ( MavenProject project ) { if ( getLocationsMethod = = null ) { return Collections . emptyList ( ) ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return Collections . emptyList ( ) ; List < String > osgiClasspath = new ArrayList < > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } return osgiClasspath ; } 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format("Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest()); request.setProject(project); checkArtifactForScalaVersion(requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null)); } 
public void log ( Enumeration . Value level , Function0 < String > message ) { String s = message . apply ( ) ; String prefix = " [ " + level . oString ( ) + " ] " ; if ( s . regionMatches ( rue , 0 , prefix , 0 , prefix . length ( ) ) ) { s = s . substring ( prefix . length ( ) ) ; } if ( level . equals ( Level . Error ( ) ) ) { log . error ( s ) ; 
public void compile ( Set < String > classpathElements , List < File > sources , File classesDirectory , List < String > scalacOptions , List < String > javacOptions ) { List < File > fullClasspath = new ArrayList < > ( ) ; fullClasspath . add ( classesDirectory ) ; for ( String classpathElement : classpathElements ) { fullClasspath . add ( new File ( classpathElement ) ) ; } CompileOptions options = CompileOptions . of ( fullClasspath.toArray(new File[] {}), classpath sources.toArray(new File[] {}), sources classesDirectory, scalacOptions.toArray(new String[] {}), scalacOptions javacOptions.toArray(new String[] {}), javacOptions 100, maxErrors pos -> pos, sourcePositionMappers compileOrder, order Optional.empty() temporaryClassesDirectory ); Inputs inputs = Inputs.of(compilers, options, setup, previousResult()); CompileResult newResult = compiler.compile(inputs, logger); analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup())); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < String > classpathElements , boolean compileInLoop ) hrows Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info( String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271) { jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 Set<String> paths = new HashSet<>(project.getCompileClasspathElements()); paths.remove(project.getBuild().getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { addAdditionalDependencies(paths); if (!paths.isEmpty()) jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
protected void addAdditionalDependencies ( Set < String > back ) hrows Exception { if ( additionalDependencies ! = null ) { for ( Dependency dependency : additionalDependencies ) { 
protected Set < String > getClasspathElements ( ) hrows Exception { Set < String > back = new HashSet < > ( project . getTestClasspathElements ( ) ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; addAdditionalDependencies ( back ) ; return back ; } 
public static String oMultiPath ( Collection < String > paths ) { return StringUtils . join ( paths . iterator ( ) , File . pathSeparator ) ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { String javaExec = null ; if ( oolchain ! = null ) { javaExec = oolchain . findTool ( " java " ) ; } if ( javaExec = = null ) { String javaHome = System . getenv ( " JAVA_HOME " ) ; if ( javaHome = = null ) { javaHome = System . getProperty ( " java.home " ) ; fallback to JRE } if (javaHome == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } javaExec = javaHome + File.separator + "bin" + File.separator + "java"; } return javaExec; } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) hrows Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog().info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if (forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for (String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, getToolchain()); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
public static File findHomeFromToolchain ( Toolchain oolchain ) { String executable = findExecutableFromToolchain ( oolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; } 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) { File home = JavaLocator . findHomeFromToolchain ( new TestStringReturningToolChain ( ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( ) ) ; assertNull ( home ) ; } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = new SbtIncrementalCompiler(libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources, outputDir, scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < String > classpathElements , boolean compileInLoop ) hrows Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog().info( String.format("Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = new SbtIncrementalCompiler(libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, javaHome.toPath(), new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile(classpathElements, sources.stream().map(File::toPath).collect(Collectors.toList()), outputDir.toPath(), scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
public static List < Path > listDirectoryContent ( Path directory , Function < Path , Boolean > filter ) hrows IOException { List < Path > paths = new ArrayList < > ( ) ; Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } } ) ; return paths ; } 
public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } 
public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } 
public void race ( Function0 < Throwable > ) { if ( log . isDebugEnabled ( ) ) { log . debug ( . apply ( ) ) ; 
public void success ( Function0 < String > message ) { if ( log . isInfoEnabled ( ) ) { log . info ( " Success: " + message . apply ( ) ) ; 
public void log ( Enumeration . Value level , Function0 < String > message ) { String s = message . apply ( ) ; String prefix = " [ " + level . oString ( ) + " ] " ; if ( s . regionMatches ( rue , 0 , prefix , 0 , prefix . length ( ) ) ) { s = s . substring ( prefix . length ( ) ) ; } if ( level . equals ( Level . Error ( ) ) ) { log . error ( s ) ; 
public String oString ( ) { return " BasicArtifact( " + groupId + " , " + artifactId + " , " + version + " , " + classifier + " ) " ; } 
static String pathOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
static File fileOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
public Set < Artifact > getJarAndDependencies ( String groupId , String artifactId , String version , String classifier ) { Artifact artifact = createJarArtifact ( groupId , artifactId , version , classifier ) ; return resolve ( artifact , rue ) ; } 
private Artifact createJarArtifact ( String groupId , String artifactId , String version , String classifier ) { return classifier = = null ? repositorySystem . createArtifact ( groupId , artifactId , version , ScalaMojoSupport . JAR ) 
private Set < Artifact > resolve ( Artifact artifact , boolean ransitively ) { ArtifactResolutionRequest request = new ArtifactResolutionRequest ( ) .setArtifact(artifact) .setResolveRoot(true) .setResolveTransitively(transitively) .setServers(session.getRequest().getServers()) .setMirrors(session.getRequest().getMirrors()) .setProxies(session.getRequest().getProxies()) .setLocalRepository(session.getLocalRepository()) .setRemoteRepositories(session.getCurrentProject().getRemoteArtifactRepositories()); return repositorySystem.resolve(request).getArtifacts(); } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getCompileSourceRoots ( ) ; String scalaSourceDir = FileUtils . pathOf ( sourceDir , useCanonicalPath ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources = new LinkedList < > ( sources ) ; clone the list to keep the original unmodified sources.add(scalaSourceDir); } return normalize(sources); } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < String > classpathElements , boolean compileInLoop ) hrows Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile( classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog() .info( String.format( "Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", MainHelper.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private void notifyCompilation ( List < File > files ) hrows Exception { if ( notifyCompilation ) { for ( File f : files ) { 
static LastCompilationInfo find ( List < File > sourceRootDirs , File outputDir ) { StringBuilder hash = new StringBuilder ( ) ; for ( File f : sourceRootDirs ) { hash . append ( f . oString ( ) ) ; } return new LastCompilationInfo ( new File ( outputDir . getAbsolutePath ( ) + " . " + hash . oString ( ) . hashCode ( ) + " .timestamp " ) , 
void setLastSuccessfullTS ( long v ) hrows Exception { if ( ! _lastCompileAtFile . exists ( ) ) { FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
private int incrementalCompile ( Set < String > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { File libraryJar = getLibraryJar(); List<File> extraJars = getCompilerDependencies(); extraJars.remove(libraryJar); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = new SbtIncrementalCompiler( libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars, javaHome.toPath(), new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder); } classpathElements.remove(outputDir.getAbsolutePath()); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile( classpathElements, sources.stream().map(File::toPath).collect(Collectors.toList()), outputDir.toPath(), scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void doExecute ( ) hrows Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaVersion(); final Set<String> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[] {})); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private void handleJavaRebel ( final JavaMainCaller jcmd ) hrows IOException { if ( his . javaRebelPath ! = null ) { final String canonicalJavaRebelPath = his . javaRebelPath . getCanonicalPath ( ) ; 
private Set < String > setupClassPathForConsole ( final VersionNumber scalaVersion ) hrows Exception { final Set < String > classpath = new HashSet < > ( ) ; classpath . addAll ( his . setupProjectClasspaths ( ) ) ; classpath . addAll ( his . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < String > setupProjectClasspaths ( ) hrows Exception { final Set < String > classpath = new HashSet < > ( ) ; super . addCompilerToClasspath ( classpath ) ; super . addLibraryToClasspath ( classpath ) ; if ( his . useTestClasspath ) { classpath . addAll ( super . project . getTestClasspathElements ( ) ) ; } if ( his . useRuntimeClasspath ) { classpath . addAll ( super . project . getRuntimeClasspathElements ( ) ) ; } return classpath ; } 
private Set < String > setupConsoleClasspaths ( final VersionNumber scalaVersion ) hrows Exception { final Set < String > classpath = new HashSet < > ( ) ; addToClasspath ( his . resolveJLine ( scalaVersion , his . fallbackJLine ( scalaVersion ) ) , classpath , rue ) ; return classpath ; } 
private Artifact resolveJLine ( final VersionNumber scalaVersion , final Artifact defaultFallback ) { final Artifact compilerArtifact = super . scalaCompilerArtifact ( scalaVersion . oString ( ) ) ; final Set < Artifact > compilerDeps = super . resolveArtifactDependencies ( compilerArtifact ) ; for ( final Artifact a : compilerDeps ) { if ( his . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
private boolean filterForJline ( final Artifact artifact ) { final String artifactId = artifact . getArtifactId ( ) ; final String groupId = artifact . getGroupId ( ) ; return artifactId . equals ( ScalaConsoleMojo . JLINE ) & & groupId . equals ( ScalaConsoleMojo . JLINE ) ; } 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scala2_12_0M4.compareTo(scalaVersion) <= 0) { return super.factory.createArtifact( 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { JavaMainCaller jcmd = super . getScalaCommand ( ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " -verbose " , rue ) ; } return jcmd ; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } List < String > estSources = new ArrayList < > ( project . getTestCompileSourceRoots ( ) ) ; estSources . add ( FileUtils . pathOf ( estSourceDir , useCanonicalPath ) ) ; List < File > estSourceDirs = normalize ( estSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; estAnalysisCacheFile = FileUtils . fileOf ( estAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & recompileMode ! = RecompileMode . incremental ) { getLog ( ) . info ( " use fsc for compilation " ) ; scalaClassName = " scala.tools.nsc.CompileClient " ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
protected void postCompileActions ( ) hrows Exception { } private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) 
public void run ( ) { ry { getLog ( ) . info ( " stop server(s)... " ) ; 
public void doExecute ( ) hrows Exception { if ( skip ) { getLog ( ) . info ( " Skipping javadoc generation " ) ; return ; } ry { generate ( null , Locale . getDefault ( ) ) ; 
private void failOnError ( String prefix , Exception e ) hrows MojoExecutionException { if ( failOnError ) { if ( e instanceof RuntimeException ) { hrow ( RuntimeException ) e ; } hrow new MojoExecutionException ( prefix + " : " + e . getMessage ( ) , e ) ; } getLog ( ) . error ( prefix + " : " + e . getMessage ( ) , e ) ; } 
public boolean canGenerateReport ( ) { there is modules to aggregate boolean back = ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0); back = back || (findSourceFiles().size() != 0); return back; } 
private List < File > findSourceFiles ( ) { if ( _sourceFiles = = null ) { ry { _sourceFiles = findSourceWithFilters ( ) ; } catch ( Exception exc ) { hrow new RuntimeException ( " can't define source to process " , exc ) ; } } return _sourceFiles ; } 
private boolean canAggregate ( ) { return StringUtils . isNotEmpty ( vscaladocVersion ) & & ( new VersionNumber ( vscaladocVersion ) . compareTo ( new VersionNumber ( " 1.1 " ) ) > = 0 ) ; 
public void doExecute ( ) hrows Exception { SiteRendererSink sink = siteRenderer.createSink(new File(project.getReporting().getOutputDirectory(), getOutputName() + ".html"); generate(null, Locale.getDefault()); } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { This ensures we have a valid scala version... checkScalaVersion(); VersionNumber sv = findScalaVersion(); boolean isPreviousScala271 = (new VersionNumber("2.7.1").compareTo(sv) > 0 && !sv.isZero()); if (StringUtils.isEmpty(scaladocClassName)) { if (!isPreviousScala271) { scaladocClassName = "scala.tools.nsc.ScalaDoc"; } else { scaladocClassName = scalaClassName; } } JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName); jcmd.addArgs(args); jcmd.addJvmArgs(jvmArgs); addCompilerPluginOptions(jcmd); if (isPreviousScala271) { jcmd.addArgs("-Ydoc"); } copy the classpathElements to not modify the global project definition see https:github.com/davidB/maven-scala-plugin/issues/60 Set<String> paths = new HashSet<>(project.getCompileClasspathElements()); paths.remove( project .getBuild() .getOutputDirectory()); remove output to avoid "error for" : error: XXX is already defined as package XXX ... object XXX { addAdditionalDependencies(paths); if (!paths.isEmpty()) jcmd.addOption("-classpath", MainHelper.toMultiPath(paths)); jcmd.addOption("-sourcepath", sourceDir.getAbsolutePath()); boolean isScaladoc2 = (new VersionNumber("2.8.0").compareTo(sv) <= 0 || sv.isZero()) && ("scala.tools.nsc.ScalaDoc".equals(scaladocClassName)); if (isScaladoc2) { jcmd.addArgs("-doc-format:html"); jcmd.addOption("-doc-title", doctitle); } else { jcmd.addOption("-bottom", getBottomText()); jcmd.addOption("-charset", charset); jcmd.addOption("-doctitle", doctitle); jcmd.addOption("-footer", footer); jcmd.addOption("-header", header); jcmd.addOption("-linksource", linksource); jcmd.addOption("-nocomment", nocomment); jcmd.addOption("-stylesheetfile", stylesheetfile); jcmd.addOption("-top", top); jcmd.addOption("-windowtitle", windowtitle); } return jcmd; } 
public void generate ( Sink sink , Locale locale ) hrows MavenReportException { ry { if ( ! canGenerateReport ( ) ) { 
private void ryAggregateUpper ( MavenProject prj ) hrows Exception { if ( prj ! = null & & prj . hasParent ( ) & & canAggregate ( ) ) { MavenProject parent = prj . getParent ( ) ; 
public void doExecute ( ) hrows Exception { JavaMainCaller jcmd ; if ( ! versionOnly ) { jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -help " ) ; jcmd . addArgs ( " -X " ) ; jcmd . addArgs ( " -Y " ) ; jcmd . run ( displayCmd ) ; } jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -version " ) ; jcmd . run ( displayCmd ) ; } 
final Artifact scalaCompilerArtifact ( String scalaVersion ) { return factory . createArtifact ( getScalaOrganization ( ) , 
final Set < Artifact > resolveArtifactDependencies ( final Artifact artifact ) { final AndArtifactFilter filter = new AndArtifactFilter ( ) ; filter . add ( new ScopeArtifactFilter ( Artifact . SCOPE_TEST ) ) ; filter . add ( art - > ! art . isOptional ( ) ) ; Use the collection filter as the resolution filter. return resolveDependencyArtifacts(artifact, filter, filter); } 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter ) { return resolveDependencyArtifacts ( artifact , collectionFilter , resolutionFilter , his . remoteRepos , his . localRepo ) ; 
private Set < Artifact > resolveDependencyArtifacts ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = his . createArtifactResolutionRequest ( artifact , collectionFilter , resolutionFilter , remoteRepositories , localRepository ) ; TODO follow the dependenciesManagement and override rules return factory.resolve(arr).getArtifacts(); } 
private ArtifactResolutionRequest createArtifactResolutionRequest ( final Artifact artifact , final ArtifactFilter collectionFilter , final ArtifactFilter resolutionFilter , final List < ArtifactRepository > remoteRepositories , final ArtifactRepository localRepository ) { final ArtifactResolutionRequest arr = new ArtifactResolutionRequest ( ) ; arr . setArtifact ( artifact ) ; arr . setCollectionFilter ( collectionFilter ) ; arr . setResolutionFilter ( resolutionFilter ) ; arr . setResolveRoot ( false ) ; arr . setResolveTransitively ( rue ) ; arr . setRemoteRepositories ( remoteRepositories ) ; arr . setLocalRepository ( localRepository ) ; return arr ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath ) hrows Exception { addToClasspath ( groupId , artifactId , version , classpath , rue ) ; } 
private void addToClasspath ( String groupId , String artifactId , String version , Set < String > classpath , boolean addDependencies ) hrows Exception { addToClasspath ( factory . createArtifact ( 
private void addToClasspath ( String groupId , String artifactId , String version , String classifier , Set < String > classpath , boolean addDependencies ) hrows Exception { Dependency d = new Dependency ( ) ; d . setGroupId ( groupId ) ; d . setArtifactId ( artifactId ) ; d . setVersion ( version ) ; d . setType ( ScalaMojoSupport . JAR ) ; d . setClassifier ( classifier ) ; d . setScope ( Artifact . SCOPE_RUNTIME ) ; addToClasspath ( factory . createDependencyArtifact ( d ) , classpath , addDependencies ) ; } 
void addToClasspath ( Artifact artifact , Set < String > classpath , boolean addDependencies ) hrows Exception { resolver . resolve ( artifact , remoteRepos , localRepo ) ; classpath . add ( FileUtils . pathOf ( artifact . getFile ( ) , useCanonicalPath ) ) ; if ( addDependencies ) { for ( Artifact dep : resolveArtifactDependencies ( artifact ) ) { 
void addLibraryToClasspath ( Set < String > classpath ) hrows Exception { classpath . add ( FileUtils . pathOf ( getLibraryJar ( ) , useCanonicalPath ) ) ; } 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { ry { String oldWay = System . getProperty ( " maven.scala.version " ) ; 
private String findScalaVersionFromDependencies ( ) { return findVersionFromDependencies ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID ) ; } 
void checkScalaVersion ( ) hrows Exception { String sv = findScalaVersion ( ) . oString ( ) ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { getLog ( ) . warn ( String . format ( " local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s " , scalaHome , sv ) ) ; } if ( checkMultipleScalaVersions ) { checkCorrectVersionsOfScalaLibrary ( sv ) ; 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest()); request.setProject(project); checkArtifactForScalaVersion( requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null)); 
private void checkArtifactForScalaVersion ( VersionNumber requiredScalaVersion , DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( requiredScalaVersion , getLog ( ) , getScalaOrganization ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) { List < DependencyNodeFilter > filters = new ArrayList < > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( getScalaOrganization ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { return getScalaCommand ( fork , scalaClassName ) ; } 
final JavaMainCaller getScalaCommand ( final boolean forkOverride , final String mainClass ) hrows Exception { JavaMainCaller cmd = getEmptyScalaCommand ( mainClass , forkOverride ) ; cmd . addArgs ( args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { cmd . addArgs ( StringUtils . split ( addScalacArgs , " | " ) ) ; } addCompilerPluginOptions ( cmd ) ; cmd . addJvmArgs ( jvmArgs ) ; return cmd ; } 
final JavaMainCaller getEmptyScalaCommand ( final String mainClass ) hrows Exception { return getEmptyScalaCommand ( mainClass , fork ) ; } 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) hrows Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog() .info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if (forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for (String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork( this, mainClass, cp, null, null, forceUseArgFile, getToolchain()); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null); } return cmd; } 
private String getToolClasspath ( ) hrows Exception { Set < String > classpath = new LinkedHashSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , classpath ) ; } } return MainHelper . oMultiPath ( classpath . oArray ( new String [ ] { } ) ) ; } 
protected List < String > getScalaOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; return options ; } 
protected File getLibraryJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_LIBRARY_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_LIBRARY_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; 
protected File getReflectJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_REFLECT_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_REFLECT_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; 
protected File getCompilerJar ( ) hrows Exception { if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , SCALA_COMPILER_ARTIFACTID + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ; 
protected File getArtifactJar ( String groupId , String artifactId , String version ) hrows Exception { Artifact artifact = factory . createArtifact ( groupId , artifactId , version , Artifact . SCOPE_RUNTIME , ScalaMojoSupport . JAR ) ; resolver . resolve ( artifact , remoteRepos , localRepo ) ; return artifact . getFile ( ) ; } 
protected boolean isJavaSupportedByCompiler ( ) hrows Exception { return findScalaVersion ( ) . compareTo ( new VersionNumber ( " 2.7.2 " ) ) > = 0 ; } 
private Set < String > getCompilerPlugins ( ) hrows Exception { Set < String > plugins = new HashSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < String > ignoreClasspath = new LinkedHashSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<String> pluginClassPath = new HashSet<>(); TODO - Pull in transitive dependencies. addToClasspath( artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; Toolchain oolchain = oolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( his , mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , jvmArgs , args , forceUseArgFile , oolchain ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ i ] . mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , oolchain ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ 0 ] . mainClass , MainHelper . oMultiPath ( project . getTestClasspathElements ( ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , oolchain ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
private static String scriptBaseNameOf ( File scriptFile , int idx ) { if ( scriptFile = = null ) { return " embeddedScript_ " + idx ; } int dot = scriptFile . getName ( ) . lastIndexOf ( '.' ) ; if ( dot = = - 1 ) { return scriptFile . getName ( ) + " _ " + idx ; } return scriptFile . getName ( ) . substring ( 0 , dot ) + " _ " + idx ; } 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<String> classpath = new HashSet<String>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private void runScript ( boolean mavenProjectDependency , URLClassLoader loader , String baseName ) hrows Exception { Class < ? > compiledScript = loader . loadClass ( baseName ) ; ClassLoader currentCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; ry { ry { 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < String > classpath ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript.importFrom("mojo", MavenProject.class.getPackage().getName()); rScript.importFrom("mojo", MavenSession.class.getPackage().getName()); rScript.importFrom("mojo", Log.class.getPackage().getName()); rScript.importFrom("mojo", "org.apache.maven"); add the script directory to the classpath rScript.addURL(scriptDir.toURI().toURL()); for (String string : classpath) { rScript.addURL(new File(string).toURI().toURL()); } return rScript; } 
private void compileScript ( File scriptDir , File destFile , URLClassLoader loader ) hrows Exception { JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( " -classpath " , MainHelper . oClasspathString ( loader ) ) ; jcmd . addArgs ( " -d " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( " -sourcepath " , scriptDir . getAbsolutePath ( ) ) ; jcmd . addArgs ( destFile . getAbsolutePath ( ) ) ; jcmd . run ( displayCmd ) ; } 
private void wrapScript ( File destFile , boolean mavenProjectDependency ) hrows IOException { destFile . delete ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( destFile ) ; PrintStream out = new PrintStream ( fileOutputStream , false , encoding ) ; BufferedReader reader = null ; ry { if ( scriptFile ! = null ) { 
private void delete ( File scriptDir ) { if ( scriptDir . isDirectory ( ) ) { for ( File file : scriptDir . listFiles ( ) ) { delete ( file ) ; } } scriptDir . deleteOnExit ( ) ; scriptDir . delete ( ) ; } 
List < File > findSourceWithFilters ( ) hrows Exception { return findSourceWithFilters ( getSourceDirectories ( ) ) ; } 
List < File > findSourceWithFilters ( List < File > sourceRootDirs ) hrows Exception { List < File > sourceFiles = new ArrayList < > ( ) ; initFilters ( ) ; TODO - Since we're making files anyway, perhaps we should just test for existence here... for (File dir : sourceRootDirs) { String[] tmpFiles = MainHelper.findFiles( dir, includes.toArray(new String[] {}), excludes.toArray(new String[] {})); for (String tmpLocalFile : tmpFiles) { File tmpAbsFile = FileUtils.fileOf(new File(dir, tmpLocalFile), useCanonicalPath); sourceFiles.add(tmpAbsFile); } } scalac is sensitive to scala file order, file system can't guarantee file order => unreproducible build error across platforms sort files by path (OS dependent) to guarantee reproducible command line. Collections.sort(sourceFiles); return sourceFiles; } 
List < File > normalize ( List < String > compileSourceRootsList ) hrows Exception { List < File > newCompileSourceRootsList = new ArrayList < > ( ) ; if ( compileSourceRootsList ! = null ) { copy as I may be modifying it for (String srcDir : compileSourceRootsList) { File srcDirFile = FileUtils.fileOf(new File(srcDir), useCanonicalPath); if (!newCompileSourceRootsList.contains(srcDirFile) && srcDirFile.exists()) { newCompileSourceRootsList.add(srcDirFile); } } } return newCompileSourceRootsList; } 
protected void addAdditionalDependencies ( Set < String > back ) hrows Exception { if ( additionalDependencies ! = null ) { for ( Dependency dependency : additionalDependencies ) { 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { if ( skip ) { return ; } super . execute ( ) ; } 
protected Set < String > getClasspathElements ( ) hrows Exception { Set < String > back = new HashSet < > ( project . getTestClasspathElements ( ) ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; addAdditionalDependencies ( back ) ; return back ; } 
protected List < File > getSourceDirectories ( ) hrows Exception { List < String > sources = project . getTestCompileSourceRoots ( ) ; String scalaSourceDir = estSourceDir . getAbsolutePath ( ) ; if ( ! sources . contains ( scalaSourceDir ) ) { sources . add ( scalaSourceDir ) ; } return normalize ( sources ) ; } 
static List < String > addOsgiClasspathElements ( MavenProject project ) { if ( getLocationsMethod = = null ) { return Collections . emptyList ( ) ; } List < Object > classpath = ( List < Object > ) getContextValue ( project , TychoConstants_CTX_ECLIPSE_PLUGIN_CLASSPATH ) ; if ( classpath = = null | | classpath . isEmpty ( ) ) return Collections . emptyList ( ) ; List < String > osgiClasspath = new ArrayList < > ( ) ; for ( Object classpathEntry : classpath ) { for ( File file : getLocations ( classpathEntry ) ) osgiClasspath . add ( file . getAbsolutePath ( ) ) ; } return osgiClasspath ; } 
public String oString ( ) { StringBuilder str = new StringBuilder ( ) ; str . append ( major ) . append ( '.' ) . append ( minor ) . append ( '.' ) . append ( bugfix ) ; if ( ( modifier ! = null ) & & ( modifier . length ( ) > 0 ) ) { str . append ( modifier ) ; } return str . oString ( ) ; } 
String applyScalaArtifactVersioningScheme ( String name ) { return name + '_' + ( modifier = = null ? ( major + " . " + minor ) : oString ( ) ) ; } 
private boolean isScalaDistroArtifact ( Artifact artifact ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & SCALA_DISTRO_ARTIFACTS . contains ( artifact . getArtifactId ( ) ) ; 
public void logScalaDependents ( ) { _log . warn ( " Expected all dependencies to require Scala version: " + _version ) ; for ( String dependString : scalaDependentArtifactStrings ) { _log . warn ( dependString ) ; 
public boolean include ( Artifact artifact ) { TODO - Are we checking the right artifacts? return scalaOrganization.equalsIgnoreCase(artifact.getGroupId()) && SCALA_DISTRO_ARTIFACTS.contains(artifact.getArtifactId()); 
public boolean accept ( DependencyNode node ) { return include ( node . getArtifact ( ) ) ; } 
public static String makeArtifactNameString ( Artifact artifact ) { TODO - Handle version ranges... if (artifact == null) { return "<null artifact>"; } return artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getVersion(); } 
void addJvmArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addArgs ( String . . . args ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , String value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , File value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void addOption ( String key , boolean value ) ; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void redirectToLog ( ) ; TODO: avoid to have several Thread to pipe stream TODO: add support to inject startup command and shutdown command (on :quit) void run(boolean displayCmd) throws Exception; SpawnMonitor spawn(boolean displayCmd) throws Exception;} 
void run ( boolean displayCmd ) hrows Exception ; SpawnMonitor spawn ( boolean displayCmd ) hrows Exception ; } 
boolean run ( boolean displayCmd , boolean hrowFailure ) hrows Exception ; SpawnMonitor spawn ( boolean displayCmd ) hrows Exception ; } 
public boolean run ( boolean displayCmd , boolean hrowFailure ) hrows Exception { List < String > cmd = buildCommand ( ) ; displayCmd ( displayCmd , cmd ) ; Executor exec = new DefaultExecutor ( ) ; err and out are redirected to out if (!_redirectToLog) { exec.setStreamHandler(new PumpStreamHandler(System.out, System.err, System.in)); } else { exec.setStreamHandler( new PumpStreamHandler( new LogOutputStream() { private LevelState _previous = new LevelState(); @Override protected void processLine(String line, int level) { try { _previous = LogProcessorUtils.levelStateOf(line, _previous); switch (_previous.level) { case ERROR: requester.getLog().error(line); break; case WARNING: requester.getLog().warn(line); break; default: requester.getLog().info(line); break; } } catch (Exception e) { e.printStackTrace(); } } })); } CommandLine cl = new CommandLine(cmd.get(0)); for (int i = 1; i < cmd.size(); i++) { cl.addArgument(cmd.get(i), false); } try { int exitValue = exec.execute(cl); 
public SpawnMonitor spawn ( boolean displayCmd ) hrows Exception { List < String > cmd = buildCommand ( ) ; File out = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .out " ) ; out . delete ( ) ; cmd . add ( " > " + out . getCanonicalPath ( ) ) ; File err = new File ( System . getProperty ( " java.io.tmpdir " ) , mainClassName + " .err " ) ; err . delete ( ) ; cmd . add ( " 2> " + err . getCanonicalPath ( ) ) ; List < String > cmd2 = new ArrayList < > ( ) ; if ( OS . isFamilyDOS ( ) ) { cmd2 . add ( " cmd.exe " ) ; cmd2 . add ( " /C " ) ; cmd2 . addAll ( cmd ) ; } else { cmd2 . add ( " /bin/sh " ) ; cmd2 . add ( " -c " ) ; cmd2 . addAll ( cmd ) ; } displayCmd ( displayCmd , cmd2 ) ; ProcessBuilder pb = new ProcessBuilder ( cmd2 ) ; pb.redirectErrorStream(true); final Process p = pb.start(); return () -> { try { 
private void displayCmd ( boolean displayCmd , List < String > cmd ) { if ( displayCmd ) { requester . getLog ( ) . info ( " cmd: " + " " + StringUtils . join ( cmd . iterator ( ) , " " ) ) ; 
private List < String > buildCommand ( ) hrows Exception { ArrayList < String > back = new ArrayList < > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; requester . getLog ( ) . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back ; } 
private void ryDeleteArgFile ( List < String > cmd ) { String last = cmd . get ( cmd . size ( ) - 1 ) ; if ( last . endsWith ( MainHelper . argFileSuffix ) ) { File f = new File ( last ) ; 
private long lengthOf ( List < String > l , long sepLength ) { long back = 0 ; for ( String str : l ) { back + = str . length ( ) + sepLength ; } return back ; } 
public void addJvmArgs ( String . . . args0 ) { TODO - Ignore classpath if (args0 != null) { for (String arg : args0) { 
public boolean run ( boolean displayCmd , boolean hrowFailure ) hrows Exception { ry { runInternal ( displayCmd ) ; 
public SpawnMonitor spawn ( final boolean displayCmd ) { final Thread = new Thread ( ( ) - > { ry { runInternal ( displayCmd ) ; } catch ( Exception e ) { Ignore } }); t.start(); return t::isAlive; } 
private void runInternal ( boolean displayCmd ) hrows Exception { String [ ] argArray = args . oArray ( new String [ ] { } ) ; if ( displayCmd ) { requester . getLog ( ) . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
public void redirectToLog ( ) { requester . getLog ( ) . warn ( " redirection to log is not supported for 'inProcess' mode " ) ; } 
public void addJvmArgs ( String . . . args0 ) { if ( args0 ! = null ) { for ( String arg : args0 ) { 
public void addToClasspath ( File entry ) hrows Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean found = false ; boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; if ( isClasspath ) { item = item + File . pathSeparator + entry . getCanonicalPath ( ) ; jvmArgs . set ( i , item ) ; isClasspath = false ; found = rue ; break ; } isClasspath = " -classpath " . equals ( item ) ; } if ( ! found ) { addJvmArgs ( " -classpath " , entry . getCanonicalPath ( ) ) ; 
public void addOption ( String key , String value ) { if ( StringUtils . isEmpty ( value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value ) ; } 
public void addOption ( String key , File value ) { if ( ( value = = null ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key , value . getAbsolutePath ( ) ) ; } 
public void addOption ( String key , boolean value ) { if ( ( ! value ) | | StringUtils . isEmpty ( key ) ) { return ; } addArgs ( key ) ; } 
public void addArgs ( String . . . args1 ) { if ( args1 ! = null ) { for ( String arg : args1 ) { 
public void run ( boolean displayCmd ) hrows Exception { run ( displayCmd , rue ) ; } 
public static LevelState levelStateOf ( String line , LevelState previous ) { LevelState back = new LevelState ( ) ; String lineLowerCase = line . oLowerCase ( ) ; if ( lineLowerCase . contains ( " error " ) ) { back . level = Level . ERROR ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( lineLowerCase . contains ( " warn " ) ) { back . level = Level . WARNING ; if ( lineLowerCase . contains ( " .scala " ) ) { back . untilContains = " ^ " ; } } else if ( previous . untilContains ! = null ) { if ( ! lineLowerCase . contains ( previous . untilContains ) ) { back = previous ; } else { back . level = previous . level ; back . untilContains = null ; } } return back ; } 
public static String oMultiPath ( Collection < String > paths ) { return StringUtils . join ( paths . iterator ( ) , File . pathSeparator ) ; } 
public static String oMultiPath ( String [ ] paths ) { return StringUtils . join ( paths , File . pathSeparator ) ; } 
public static String [ ] findFiles ( File dir , String [ ] includes , String [ ] excludes ) { DirectoryScanner scanner = new DirectoryScanner ( ) ; scanner . setBasedir ( dir ) ; scanner . setIncludes ( includes ) ; scanner . setExcludes ( excludes ) ; scanner . addDefaultExcludes ( ) ; scanner . scan ( ) ; return scanner . getIncludedFiles ( ) ; } 
public static String oClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new LinkedList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . oString ( ) ; } 
private static void appendUrlToClasspathCollection ( ClassLoader cl , Collection < String > classpath ) { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } while ( cl ! = null ) { if ( cl instanceof URLClassLoader ) { 
private static String escapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . matches ( " .* \\ s.* " ) ) { return '"' + arg + '"' ; } return arg ; } 
private static String unescapeArgumentForScalacArgumentFile ( String arg ) { if ( arg . charAt ( 0 ) = = '"' & & arg . charAt ( arg . length ( ) - 1 ) = = '"' ) { return arg . substring ( 1 , arg . length ( ) - 1 ) ; } return arg ; } 
static File createArgFile ( List < String > args ) hrows IOException { final File argFile = File . createTempFile ( argFilePrefix , argFileSuffix ) ; argFile.deleteOnExit(); try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(argFile)))) { for (String arg : args) { out.println(escapeArgumentForScalacArgumentFile(arg)); } } return argFile; } 
static List < String > readArgFile ( File argFile ) hrows IOException { ArrayList < String > back = new ArrayList < > ( ) ; ry ( BufferedReader in = new BufferedReader ( new FileReader ( argFile ) ) ) { String line ; while ( ( line = in . readLine ( ) ) ! = null ) { back . add ( unescapeArgumentForScalacArgumentFile ( line ) ) ; } } return back ; } 
static void runMain ( String mainClassName , List < String > args , ClassLoader cl ) hrows Exception { if ( cl = = null ) { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } Class < ? > mainClass = cl . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( " main " , String [ ] . class ) ; int mods = mainMethod . getModifiers ( ) ; if ( mainMethod . getReturnType ( ) ! = void . class | | ! Modifier . isStatic ( mods ) | | ! Modifier . isPublic ( mods ) ) { hrow new NoSuchMethodException ( " main " ) ; } String [ ] argArray = args . oArray ( new String [ ] { } ) ; TODO - Redirect System.in System.err and System.out mainMethod.invoke(null, new Object[] {argArray}); } 
static String locateJar ( Class < ? > c ) hrows Exception { final URL location ; final String classLocation = c . getName ( ) . replace ( '.' , '/' ) + " .class " ; final ClassLoader loader = c . getClassLoader ( ) ; if ( loader = = null ) { location = ClassLoader . getSystemResource ( classLocation ) ; } else { location = loader . getResource ( classLocation ) ; } if ( location ! = null ) { Pattern p = Pattern . compile ( " ^.*file:(.*)!.*$ " ) ; Matcher m = p . matcher ( location . oString ( ) ) ; if ( m . find ( ) ) { return URLDecoder . decode ( m . group ( 1 ) , " UTF-8 " ) ; } hrow new ClassNotFoundException ( " Cannot parse location of ' " + location + " '. Probably not loaded from a Jar " ) ; } hrow new ClassNotFoundException ( " Cannot find class ' " + c . getName ( ) + " using the classloader " ) ; 
public static void main ( String [ ] args ) { ry { String mainClassName = args [ 0 ] ; 
public static List < Path > listDirectoryContent ( Path directory , Function < Path , Boolean > filter ) hrows IOException { List < Path > paths = new ArrayList < > ( ) ; Files . walkFileTree ( directory , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } } ) ; return paths ; } 
public FileVisitResult visitFile ( Path path , BasicFileAttributes attrs ) { if ( filter . apply ( path ) ) { paths . add ( path ) ; } return FileVisitResult . CONTINUE ; } 
public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { if ( ! dir . equals ( directory ) & & filter . apply ( dir ) ) { paths . add ( dir ) ; } return FileVisitResult . CONTINUE ; } 
public static void deleteDirectory ( Path directory ) { ry { Files . walkFileTree ( 
public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) hrows IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } 
public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) hrows IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { String javaExec = null ; if ( oolchain ! = null ) { javaExec = oolchain . findTool ( " java " ) ; } if ( javaExec = = null ) { String javaHome = System . getenv ( " JAVA_HOME " ) ; if ( javaHome = = null ) { javaHome = System . getProperty ( " java.home " ) ; fallback to JRE } if (javaHome == null) { throw new IllegalStateException( "Couldn't locate java, try setting JAVA_HOME environment variable."); } javaExec = javaHome + File.separator + "bin" + File.separator + "java"; } return javaExec; } 
public static File findHomeFromToolchain ( Toolchain oolchain ) { String executable = findExecutableFromToolchain ( oolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; } 
public void jdkSplit ( ) hrows Exception { LevelState previous = new LevelState ( ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala:-1: info: compiling " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514 " , previous , Level . INFO , null ) ; previous = assertLevelState ( " Recompiling 1 files " , previous , Level . INFO , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " /home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch; " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " found : Unit " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " required: () => Any " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " f() " , previous , Level . ERROR , " ^ " ) ; previous = assertLevelState ( " ^ " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " wo errors found " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( " BUILD ERROR " , previous , Level . ERROR , null ) ; previous = assertLevelState ( " ------------------------------------------------------------------------ " , previous , Level . INFO , null ) ; previous = assertLevelState ( 
private LevelState assertLevelState ( String input , LevelState previous , Level expectedLevel , String expectedUntilContains ) hrows Exception { LevelState back = LogProcessorUtils . levelStateOf ( input , previous ) ; assertEquals ( expectedLevel , back . level ) ; assertEquals ( expectedUntilContains , back . untilContains ) ; return back ; } 
public void stringUtilsSplit ( ) hrows Exception { assertEquals ( 1 , StringUtils . split ( " hello " , " | " ) . length ) ; assertEquals ( 1 , StringUtils . split ( " hello| " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel|lo " , " | " ) . length ) ; assertEquals ( 2 , StringUtils . split ( " hel||lo " , " | " ) . length ) ; } 
public void classworldSeftFirstStrategy ( ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; ClassRealm rMojo = w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript . importFrom ( " mojo " , MavenProject . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , MavenSession . class . getPackage ( ) . getName ( ) ) ; rScript . importFrom ( " mojo " , Log . class . getPackage ( ) . getName ( ) ) ; assertEquals ( rScript , rScript . getStrategy ( ) . getRealm ( ) ) ; assertEquals ( SelfFirstStrategy . class , rScript . getStrategy ( ) . getClass ( ) ) ; File olderjar = new File ( System . getProperty ( " user.home " ) , " .m2/repository/net/alchim31/maven/scala-maven-plugin/3.1.0/scala-maven-plugin-3.1.0.jar " ) ; if ( olderjar . exists ( ) ) { System . out . println ( " found older jar " ) ; 
public void shouldReturnNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain oolchain = new NullReturningToolChain ( ) ; environmentVariables . set ( " JAVA_HOME " , " est " ) ; assertEquals ( Paths . get ( " est " , " bin " , " java " ) . oString ( ) , 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) hrows Exception { Toolchain oolchain = new ReturningToolChain ( ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
public void shouldThrowExceptionWhenNothingCouldBeFound ( ) { Toolchain oolchain = new NullReturningToolChain ( ) ; System . clearProperty ( " java.home " ) ; environmentVariables . set ( " JAVA_HOME " , null ) ; ry { JavaLocator . findExecutableFromToolchain ( oolchain ) ; 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) { File home = JavaLocator . findHomeFromToolchain ( new TestStringReturningToolChain ( ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( ) ) ; assertNull ( home ) ; } 
public String findTool ( String s ) { return " parent/child/my-path-to-java " ; } 
public String findTool ( String s ) { return " my-path-to-java " ; } 
private Set < Artifact > resolve ( Artifact artifact , boolean ransitively ) { ArtifactResolutionRequest request = new ArtifactResolutionRequest ( ) . setArtifact ( artifact ) . setResolveRoot ( rue ) . setResolveTransitively ( ransitively ) . setServers ( session . getRequest ( ) . getServers ( ) ) . setMirrors ( session . getRequest ( ) . getMirrors ( ) ) . setProxies ( session . getRequest ( ) . getProxies ( ) ) . setLocalRepository ( session . getLocalRepository ( ) ) . setRemoteRepositories ( session . getCurrentProject ( ) . getRemoteArtifactRepositories ( ) ) ; return repositorySystem . resolve ( request ) . getArtifacts ( ) ; } 
public Class < ? > loadClass ( String className , boolean resolve ) hrows ClassNotFoundException { if ( className . startsWith ( " xsbti. " ) ) { We can't use the loadClass overload with two arguments because it's 
private Artifact fallbackJLine ( final VersionNumber scalaVersion ) { https:github.com/scala/scala/blob/365ac035a863a666f86151371db77c6d401e88a2/versions.properties#L29 final VersionNumber scala2_12_0M4 = new VersionNumber("2.12.0-M4"); final VersionNumber scala2_11_0 = new VersionNumber("2.11.0"); final VersionNumber scala2_9_0 = new VersionNumber("2.9.0"); if (scalaVersion.major == 3) { return super.factory.createArtifact( 
protected final Artifact scalaCompilerArtifact ( String scalaVersion ) { return factory . createArtifact ( getScalaOrganization ( ) , 
private String findScalaVersionFromDependencies ( ) { return findVersionFromDependencies ( getScalaOrganization ( ) , 
protected File getLibraryJar ( ) hrows Exception { return getLibraryJar ( findScalaVersion ( ) ) ; } 
protected File getLibraryJar ( VersionNumber versionNumber ) hrows Exception { String scalaLibrary = _scalaVersionN . major = = 3 ? getScala3ArtifactId ( SCALA3_LIBRARY_ARTIFACTID ) : SCALA_LIBRARY_ARTIFACTID ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , scalaLibrary + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , scalaLibrary , versionNumber . oString ( ) ) ; } 
protected File getReflectJar ( ) hrows Exception { if ( _scalaVersionN . major ! = 3 ) { String scalaReflect = _scalaVersionN . major = = 3 ? getScala3ArtifactId ( SCALA3_REFLECT_ARTIFACTID ) : SCALA_REFLECT_ARTIFACTID ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , scalaReflect + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , scalaReflect , findScalaVersion ( ) . oString ( ) ) ; } return null ; } 
protected File getCompilerJar ( ) hrows Exception { return getCompilerJar ( findScalaVersion ( ) ) ; } 
protected File getCompilerJar ( VersionNumber versionNumber ) hrows Exception { String scalaCompile = _scalaVersionN . major = = 3 ? getScala3ArtifactId ( SCALA3_COMPILER_ARTIFACTID ) : SCALA_COMPILER_ARTIFACTID ; if ( StringUtils . isNotEmpty ( scalaHome ) ) { File lib = new File ( scalaHome , " lib " ) ; return new File ( lib , scalaCompile + " .jar " ) ; } return getArtifactJar ( getScalaOrganization ( ) , scalaCompile , versionNumber . oString ( ) ) ; } 
protected List < File > getCompilerDependencies ( ) hrows Exception { List < File > d = new ArrayList < > ( ) ; if ( StringUtils . isEmpty ( scalaHome ) ) { for ( Artifact artifact : getAllDependencies ( getScalaOrganization ( ) , _scalaVersionN . major = = 3 ? getScala3ArtifactId ( SCALA3_COMPILER_ARTIFACTID ) : SCALA_COMPILER_ARTIFACTID , findScalaVersion ( ) . oString ( ) ) ) { d . add ( artifact . getFile ( ) ) ; } } else { for ( File f : new File ( scalaHome , " lib " ) . listFiles ( ) ) { String name = f . getName ( ) ; if ( name . endsWith ( " .jar " ) & & ( ! name . contains ( " scala-library " ) | | ! name . contains ( " scala3-library " ) ) & & ( ! name . contains ( " scala-compiler " ) | | ! name . contains ( " scala3-compiler " ) ) ) { d . add ( f ) ; } } } return d ; } 
private boolean isScalaDistroArtifact ( Artifact artifact ) { if ( _version . major = = 2 | | _version . major = = 3 ) { return _scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) 
public void addToClasspath ( File entry ) hrows Exception { if ( ( entry = = null ) | | ! entry . exists ( ) ) { return ; } boolean found = false ; boolean isClasspath = false ; for ( int i = 0 ; i < jvmArgs . size ( ) ; i + + ) { String item = jvmArgs . get ( i ) ; if ( isClasspath ) { item = item + File . pathSeparator + entry . getCanonicalPath ( ) ; jvmArgs . set ( i , item ) ; found = rue ; break ; } isClasspath = " -classpath " . equals ( item ) ; } if ( ! found ) { addJvmArgs ( " -classpath " , entry . getCanonicalPath ( ) ) ; 
private Artifact createJarArtifact ( String groupId , String artifactId , String version , String classifier ) { return classifier = = null ? repositorySystem . createArtifact ( groupId , artifactId , version , JAR ) 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < File > classpathElements , boolean compileInLoop ) hrows Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile( classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfullTS(t1); } return retCode; } getLog() .info( String.format( "Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", FileUtils.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } try { if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfullTS(t1); } else { compileErrors = true; } } catch (Exception e) { compileErrors = true; getLog().error("exception compilation error occurred!!!", e); } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
private int incrementalCompile ( Set < File > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { Context sc = findScalaContext(); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); ScalaInstance instance = makeScalaInstance(sc); incremental = new SbtIncrementalCompiler( javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder, instance); } classpathElements.remove(outputDir); List<String> scalacOptions = getScalaOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile( classpathElements.stream().map(File::toPath).collect(Collectors.toSet()), sources.stream().map(File::toPath).collect(Collectors.toList()), outputDir.toPath(), scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void doExecute ( ) hrows Exception { Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, this.mainConsole); Determine Scala Version final VersionNumber scalaVersion = super.findScalaContext().version(); final Set<File> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = FileUtils.toMultiPath(classpath); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
private Set < File > setupClassPathForConsole ( final VersionNumber scalaVersion ) hrows Exception { final Set < File > classpath = new HashSet < > ( ) ; classpath . addAll ( his . setupProjectClasspaths ( ) ) ; classpath . addAll ( his . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < File > setupConsoleClasspaths ( final VersionNumber scalaVersion ) hrows Exception { final Set < File > classpath = new HashSet < > ( ) ; Artifact a = his . resolveJLine ( his . fallbackJLine ( scalaVersion ) ) ; addToClasspath ( a . getGroupId ( ) , a . getArtifactId ( ) , a . getVersion ( ) , a . getClassifier ( ) , classpath , rue ) ; return classpath ; } 
private Artifact resolveJLine ( final Artifact defaultFallback ) hrows Exception { final Set < Artifact > compilerDeps = super . findScalaContext ( ) . findCompilerAndDependencies ( ) ; for ( final Artifact a : compilerDeps ) { if ( his . filterForJline ( a ) ) { return a ; } } super . getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; super . getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
public MavenArtifactResolver findMavenArtifactResolver ( ) { if ( mavenArtifactResolver = = null ) { mavenArtifactResolver = new MavenArtifactResolver ( factory , session ) ; } return mavenArtifactResolver ; } 
public Context findScalaContext ( ) hrows Exception { reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be stateless) if (scalaContext == null) { VersionNumber scalaVersion = findScalaVersion(); ArtifactIds aids = (scalaVersion.major == 3) ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2(); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : scalaVersion; if (requiredScalaVersion.compareTo(scalaVersion) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", scalaVersion, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } scalaContext = StringUtils.isNotEmpty(scalaHome) ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome)) : new Context4ScalaRemote( scalaVersion, requiredScalaVersion, aids, scalaOrganization, findMavenArtifactResolver()); } return scalaContext; } 
void addCompilerToClasspath ( Set < File > classpath ) hrows Exception { Context sc = findScalaContext ( ) ; for ( Artifact dep : sc . findCompilerAndDependencies ( ) ) { classpath . add ( dep . getFile ( ) ) ; 
void addLibraryToClasspath ( Set < File > classpath ) hrows Exception { Context sc = findScalaContext ( ) ; for ( Artifact dep : sc . findLibraryAndDependencies ( ) ) { classpath . add ( dep . getFile ( ) ) ; 
private void checkCorrectVersionsOfScalaLibrary ( String scalaDefVersion ) hrows Exception { getLog ( ) . debug ( " Checking for multiple versions of scala " ) ; TODO - Make sure we handle bad artifacts.... TODO: note that filter does not get applied due to MNG-3236 VersionNumber sv = new VersionNumber(scalaDefVersion); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv; if (requiredScalaVersion.compareTo(sv) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", sv, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } ProjectBuildingRequest request = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest()); request.setProject(project); checkArtifactForScalaVersion( findScalaContext(), dependencyGraphBuilder.buildDependencyGraph(request, null)); 
private void checkArtifactForScalaVersion ( Context scalaContext , DependencyNode rootNode ) hrows Exception { final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor ( scalaContext , getLog ( ) ) ; CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor ( ) ; DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor ( collectingVisitor , createScalaDistroDependencyFilter ( ) ) ; rootNode . accept ( firstPassVisitor ) ; DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter ( collectingVisitor . getNodes ( ) ) ; DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor ( visitor , secondPassFilter ) ; rootNode . accept ( filteredVisitor ) ; if ( visitor . isFailed ( ) ) { visitor . logScalaDependents ( ) ; 
private DependencyNodeFilter createScalaDistroDependencyFilter ( ) hrows Exception { List < DependencyNodeFilter > filters = new ArrayList < > ( ) ; filters . add ( new ScalaDistroArtifactFilter ( findScalaContext ( ) ) ) ; return new AndDependencyNodeFilter ( filters ) ; } 
private String getToolClasspath ( ) hrows Exception { Set < File > classpath = new TreeSet < > ( ) ; addLibraryToClasspath ( classpath ) ; addCompilerToClasspath ( classpath ) ; if ( dependencies ! = null ) { for ( BasicArtifact artifact : dependencies ) { addToClasspath ( artifact . groupId , artifact . artifactId , artifact . version , " " , classpath , rue ) ; } } return FileUtils . oMultiPath ( classpath ) ; } 
private Set < File > getCompilerPlugins ( ) hrows Exception { Set < File > plugins = new HashSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < File > ignoreClasspath = new LinkedHashSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<File> pluginClassPath = new HashSet<>(); addToClasspath( artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; Toolchain oolchain = oolchainManager . getToolchainFromBuildContext ( " jdk " , session ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( his , mainClass , FileUtils . oMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , jvmArgs , args , forceUseArgFile , oolchain ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ i ] . mainClass , FileUtils . oMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , oolchain ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( his , launchers [ 0 ] . mainClass , FileUtils . oMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , oolchain ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<File> classpath = new HashSet<>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private URLClassLoader createScriptClassloader ( File scriptDir , Set < File > classpath ) hrows Exception { ClassWorld w = new ClassWorld ( " zero " , null ) ; w . newRealm ( " mojo " , getClass ( ) . getClassLoader ( ) ) ; Strategy s = new SelfFirstStrategy ( w . newRealm ( " scalaScript " , null ) ) ; ClassRealm rScript = s . getRealm ( ) ; rScript . setParentClassLoader ( getClass ( ) . getClassLoader ( ) ) ; rScript.importFrom("mojo", MavenProject.class.getPackage().getName()); rScript.importFrom("mojo", MavenSession.class.getPackage().getName()); rScript.importFrom("mojo", Log.class.getPackage().getName()); rScript.importFrom("mojo", "org.apache.maven"); add the script directory to the classpath rScript.addURL(scriptDir.toURI().toURL()); for (File f : classpath) { rScript.addURL(f.toURI().toURL()); } return rScript; } 
protected void addAdditionalDependencies ( Set < File > back ) hrows Exception { if ( additionalDependencies ! = null ) { for ( Dependency dependency : additionalDependencies ) { 
protected Set < File > getClasspathElements ( ) hrows Exception { Set < File > back = FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ; back . remove ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ; addAdditionalDependencies ( back ) ; return back ; } 
public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; VersionNumber hat = ( VersionNumber ) o ; return major = = hat . major & & minor = = hat . minor 
public int hashCode ( ) { return Objects . hash ( major , minor , bugfix , modifier ) ; } 
public VersionNumber max ( VersionNumber v ) { if ( his . compareTo ( v ) < 0 ) return v ; return his ; } 
List < String > scalaDistroArtifactIds ( ) hrows Exception ; String scalaLibraryArtifactId ( ) hrows Exception ; String scalaCompilerArtifactId ( ) hrows Exception ; } 
String scalaLibraryArtifactId ( ) hrows Exception ; String scalaCompilerArtifactId ( ) hrows Exception ; } 
public List < String > scalaDistroArtifactIds ( ) hrows Exception { return SCALA_DISTRO_ARTIFACTS ; } 
public String scalaLibraryArtifactId ( ) hrows Exception { return SCALA_LIBRARY_ARTIFACTID ; } 
public String scalaCompilerArtifactId ( ) hrows Exception { return SCALA_COMPILER_ARTIFACTID ; } 
public String scalaLibraryArtifactId ( ) hrows Exception { return getScala3ArtifactId ( SCALA_LIBRARY_ARTIFACTID ) ; } 
public String scalaCompilerArtifactId ( ) hrows Exception { return getScala3ArtifactId ( SCALA_COMPILER_ARTIFACTID ) ; } 
public void logScalaDependents ( ) { _log . warn ( " Expected all dependencies to require Scala version: " + _scalaContext . version ( ) ) ; for ( String dependString : scalaDependentArtifactStrings ) { _log . warn ( dependString ) ; 
boolean hasInDistro ( Artifact artifact ) hrows Exception ; VersionNumber version ( ) ; VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) hrows Exception ; Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; } 
VersionNumber version ( ) ; VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) hrows Exception ; Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; } 
VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) hrows Exception ; Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; } 
Set < Artifact > findLibraryAndDependencies ( ) hrows Exception ; Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; } 
public boolean hasInDistro ( Artifact artifact ) hrows Exception { return false ; } 
public VersionNumber versionCompat ( ) { return scalaCompatVersion ; } 
public Set < Artifact > findLibraryAndDependencies ( ) hrows Exception { File lib = new File ( scalaHome , " lib " ) ; File f = new File ( lib , aids . scalaLibraryArtifactId ( ) + " .jar " ) ; Set < Artifact > d = new TreeSet < > ( ) ; d . add ( new LocalFileArtifact ( " local " , aids . scalaLibraryArtifactId ( ) , scalaVersion . oString ( ) , f ) ) ; return d ; } 
public Set < Artifact > findCompilerAndDependencies ( ) hrows Exception { String compiler = aids.scalaCompilerArtifactId(); Set<Artifact> d = new TreeSet<>(); for (File f : new File(scalaHome, "lib").listFiles()) { String name = f.getName(); if (name.endsWith(".jar")) { d.add( new LocalFileArtifact( "local", name.substring(0, name.length() - 4), scalaVersion.toString(), f)); } } return d; } 
public void addMetadata ( ArtifactMetadata metadata ) { hrow new UnsupportedOperationException ( " not implemented " ) ; } 
public void updateVersion ( String version , ArtifactRepository localRepository ) { hrow new UnsupportedOperationException ( " not implemented " ) ; } 
public void selectVersion ( String version ) { hrow new UnsupportedOperationException ( " not implemented " ) ; } 
public ArtifactVersion getSelectedVersion ( ) hrows OverConstrainedVersionException { hrow new UnsupportedOperationException ( " not implemented " ) ; } 
public boolean isSelectedVersionKnown ( ) hrows OverConstrainedVersionException { hrow new UnsupportedOperationException ( " not implemented " ) ; } 
public int compareTo ( Artifact o ) { int c = groupId . compareTo ( o . getGroupId ( ) ) ; if ( c ! = 0 ) return c ; c = artifactId . compareTo ( o . getArtifactId ( ) ) ; if ( c ! = 0 ) return c ; TODO compare on classifier ? return version.compareTo(o.getVersion()); } 
public boolean hasInDistro ( Artifact artifact ) hrows Exception { return scalaOrganization . equalsIgnoreCase ( artifact . getGroupId ( ) ) & & aids . scalaDistroArtifactIds ( ) . contains ( artifact . getArtifactId ( ) ) ; 
public Set < Artifact > findLibraryAndDependencies ( ) hrows Exception { return mavenArtifactResolver . getJarAndDependencies ( scalaOrganization , aids . scalaLibraryArtifactId ( ) , scalaVersion . oString ( ) , null ) ; 
public Set < Artifact > findCompilerAndDependencies ( ) hrows Exception { return mavenArtifactResolver . getJarAndDependencies ( scalaOrganization , aids . scalaCompilerArtifactId ( ) , scalaVersion . oString ( ) , null ) ; 
public boolean include ( Artifact artifact ) { ry { return scalaContext . hasInDistro ( artifact ) ; 
public void max ( ) hrows Exception { assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 1.0 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 1.9 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.0 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7-rc " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7.0 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7.1 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.7.2-rc1 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.7.2-rc1 " ) ) ) ; assertEquals ( new VersionNumber ( " 2.8 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 2.8 " ) ) ) ; assertEquals ( new VersionNumber ( " 3.0 " ) , new VersionNumber ( " 2.7.1 " ) . max ( new VersionNumber ( " 3.0 " ) ) ) ; 
private Set < File > setupClassPathForConsole ( final VersionNumber scalaVersion ) hrows Exception { final Set < File > classpath = new TreeSet < File > ( ) ; classpath . addAll ( his . setupProjectClasspaths ( ) ) ; classpath . addAll ( his . setupConsoleClasspaths ( scalaVersion ) ) ; return classpath ; } 
private Set < File > setupConsoleClasspaths ( final VersionNumber scalaVersion ) hrows Exception { final Set < File > classpath = new TreeSet < File > ( ) ; Artifact a = his . resolveJLine ( his . fallbackJLine ( scalaVersion ) ) ; addToClasspath ( a . getGroupId ( ) , a . getArtifactId ( ) , a . getVersion ( ) , a . getClassifier ( ) , classpath , rue ) ; return classpath ; } 
private Set < File > getCompilerPlugins ( ) hrows Exception { Set < File > plugins = new TreeSet < > ( ) ; if ( compilerPlugins ! = null ) { Set < File > ignoreClasspath = new TreeSet < > ( ) ; addCompilerToClasspath ( ignoreClasspath ) ; addLibraryToClasspath ( ignoreClasspath ) ; for ( BasicArtifact artifact : compilerPlugins ) { getLog ( ) . info ( " compiler plugin: " + artifact . oString ( ) ) ; TODO - Ensure proper scala version for plugins Set<File> pluginClassPath = new TreeSet<>(); addToClasspath( artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false); pluginClassPath.removeAll(ignoreClasspath); plugins.addAll(pluginClassPath); } } return plugins; } 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<File> classpath = new TreeSet<File>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
protected Set < File > getClasspathElements ( ) hrows Exception { Set < File > back = FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ; back . remove ( new File ( project . getBuild ( ) . getTestOutputDirectory ( ) ) ) ; addAdditionalDependencies ( back ) ; return back ; } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { Context sc = findScalaContext ( ) ; return getScalaCommand ( fork , sc . compilerMainClassName ( scalaClassName , false ) ) ; } 
protected void doExecute ( ) hrows Exception { Context sc = findScalaContext ( ) ; Force no forking final JavaMainCaller jcmd = super.getScalaCommand(false, sc.consoleMainClassName(mainConsole)); Determine Scala Version final VersionNumber scalaVersion = super.findScalaContext().version(); final Set<File> classpath = this.setupClassPathForConsole(scalaVersion); Log if we are violating the user settings. if (super.fork) { super.getLog().info("Ignoring fork for console execution."); } Setup the classpath Build the classpath string. final String classpathStr = FileUtils.toMultiPath(classpath); Setup the JavaMainCaller jcmd.addArgs(super.args); jcmd.addOption("-cp", classpathStr); super.addCompilerPluginOptions(jcmd); Check for Java Rebel this.handleJavaRebel(jcmd); Run jcmd.run(super.displayCmd); } 
protected JavaMainCaller getScalaCommand ( ) hrows Exception { Context sc = findScalaContext ( ) ; JavaMainCaller jcmd = getScalaCommand ( fork , sc . compilerMainClassName ( scalaClassName , useFsc ) ) ; if ( useFsc & & verbose ) { jcmd . addOption ( " -verbose " , rue ) ; } return jcmd ; } 
protected final void doExecute ( ) hrows Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( ! mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; estOutputDir = FileUtils . fileOf ( estOutputDir , useCanonicalPath ) ; if ( ! estOutputDir . exists ( ) ) { estOutputDir . mkdirs ( ) ; } List < String > estSources = new ArrayList < > ( project . getTestCompileSourceRoots ( ) ) ; estSources . add ( FileUtils . pathOf ( estSourceDir , useCanonicalPath ) ) ; List < File > estSourceDirs = normalize ( estSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; estAnalysisCacheFile = FileUtils . fileOf ( estAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc & & recompileMode ! = RecompileMode . incremental ) { getLog ( ) . info ( " use fsc for compilation " ) ; if ( ! once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( " wait for files to compile... " ) ; do { clearCompileErrors ( ) ; 
List < String > scalaDistroArtifactIds ( ) hrows Exception ; String scalaLibraryArtifactId ( ) hrows Exception ; String scalaCompilerArtifactId ( ) hrows Exception ; String compilerMainClassName ( boolean useFsc ) hrows Exception ; String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( VersionNumber sv ) hrows Exception ; } 
String scalaLibraryArtifactId ( ) hrows Exception ; String scalaCompilerArtifactId ( ) hrows Exception ; String compilerMainClassName ( boolean useFsc ) hrows Exception ; String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( VersionNumber sv ) hrows Exception ; } 
String scalaCompilerArtifactId ( ) hrows Exception ; String compilerMainClassName ( boolean useFsc ) hrows Exception ; String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( VersionNumber sv ) hrows Exception ; } 
String compilerMainClassName ( boolean useFsc ) hrows Exception ; String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( VersionNumber sv ) hrows Exception ; } 
String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( VersionNumber sv ) hrows Exception ; } 
public String compilerMainClassName ( boolean useFsc ) hrows Exception { return useFsc ? " scala.tools.nsc.CompileClient " : " scala.tools.nsc.Main " ; } 
public String consoleMainClassName ( ) hrows Exception { return " scala.tools.nsc.MainGenericRunner " ; } 
public String apidocMainClassName ( VersionNumber sv ) hrows Exception { boolean isPreviousScala271 = ( new VersionNumber ( " 2.7.1 " ) . compareTo ( sv ) > 0 & & ! sv . isZero ( ) ) ; if ( ! isPreviousScala271 ) { return " scala.tools.nsc.ScalaDoc " ; 
public String compilerMainClassName ( boolean useFsc ) hrows Exception { return " dotty.tools.dotc.Main " ; } 
public String consoleMainClassName ( ) hrows Exception { return "dotty.tools.dotc.Run"; return "dotty.tools.repl.Main"; } 
public String apidocMainClassName ( VersionNumber sv ) hrows Exception { return " dotty.tools.dotc.Main " ; } 
boolean hasInDistro ( Artifact artifact ) hrows Exception ; VersionNumber version ( ) ; VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) hrows Exception ; Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; String compilerMainClassName ( String override , boolean useFsc ) hrows Exception ; String consoleMainClassName ( String override ) hrows Exception ; String apidocMainClassName ( String override ) hrows Exception ; } 
VersionNumber version ( ) ; VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) hrows Exception ; Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; String compilerMainClassName ( String override , boolean useFsc ) hrows Exception ; String consoleMainClassName ( String override ) hrows Exception ; String apidocMainClassName ( String override ) hrows Exception ; } 
VersionNumber versionCompat ( ) ; Set < Artifact > findLibraryAndDependencies ( ) hrows Exception ; Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; String compilerMainClassName ( String override , boolean useFsc ) hrows Exception ; String consoleMainClassName ( String override ) hrows Exception ; String apidocMainClassName ( String override ) hrows Exception ; } 
Set < Artifact > findLibraryAndDependencies ( ) hrows Exception ; Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; String compilerMainClassName ( String override , boolean useFsc ) hrows Exception ; String consoleMainClassName ( String override ) hrows Exception ; String apidocMainClassName ( String override ) hrows Exception ; } 
Set < Artifact > findCompilerAndDependencies ( ) hrows Exception ; String compilerMainClassName ( String override , boolean useFsc ) hrows Exception ; String consoleMainClassName ( String override ) hrows Exception ; String apidocMainClassName ( String override ) hrows Exception ; } 
String compilerMainClassName ( String override , boolean useFsc ) hrows Exception ; String consoleMainClassName ( String override ) hrows Exception ; String apidocMainClassName ( String override ) hrows Exception ; } 
String consoleMainClassName ( String override ) hrows Exception ; String apidocMainClassName ( String override ) hrows Exception ; } 
public String compilerMainClassName ( String override , boolean useFsc ) hrows Exception { if ( StringUtils . isEmpty ( override ) ) { return his . aids . compilerMainClassName ( useFsc ) ; 
public String consoleMainClassName ( String override ) hrows Exception { if ( StringUtils . isEmpty ( override ) ) { return his . aids . consoleMainClassName ( ) ; 
public String apidocMainClassName ( String override ) hrows Exception { if ( StringUtils . isEmpty ( override ) ) { return his . aids . apidocMainClassName ( his . scalaVersion ) ; 
public boolean canGenerateReport ( ) { return findSourceFiles ( ) . size ( ) ! = 0 ; } 
List < String > scalaDistroArtifactIds ( ) hrows Exception ; String scalaLibraryArtifactId ( ) hrows Exception ; String scalaCompilerArtifactId ( ) hrows Exception ; String compilerMainClassName ( boolean useFsc ) hrows Exception ; String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( ) hrows Exception ; } 
String scalaLibraryArtifactId ( ) hrows Exception ; String scalaCompilerArtifactId ( ) hrows Exception ; String compilerMainClassName ( boolean useFsc ) hrows Exception ; String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( ) hrows Exception ; } 
String scalaCompilerArtifactId ( ) hrows Exception ; String compilerMainClassName ( boolean useFsc ) hrows Exception ; String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( ) hrows Exception ; } 
String compilerMainClassName ( boolean useFsc ) hrows Exception ; String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( ) hrows Exception ; } 
String consoleMainClassName ( ) hrows Exception ; String apidocMainClassName ( ) hrows Exception ; } 
public String apidocMainClassName ( ) hrows Exception { return " scala.tools.nsc.ScalaDoc " ; } 
public String apidocMainClassName ( ) hrows Exception { return " dotty.tools.dotc.Main " ; } 
public String apidocMainClassName ( String override ) hrows Exception { if ( StringUtils . isEmpty ( override ) ) { return his . aids . apidocMainClassName ( ) ; 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { if ( skipMain ) { getLog ( ) . info ( " Not compiling main sources " ) ; return ; } super . execute ( ) ; } 
public void execute ( ) hrows MojoExecutionException , MojoFailureException { if ( skip ) { getLog ( ) . info ( " Not compiling test sources " ) ; return ; } super . execute ( ) ; } 
public Context findScalaContext ( ) hrows Exception { reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be stateless) if (scalaContext == null) { VersionNumber scalaVersion = findScalaVersion(); ArtifactIds aids = scalaVersion.major == 3 ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2(); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : scalaVersion; if (requiredScalaVersion.compareTo(scalaVersion) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", scalaVersion, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } scalaContext = StringUtils.isNotEmpty(scalaHome) ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome)) : new Context4ScalaRemote( scalaVersion, requiredScalaVersion, aids, scalaOrganization, findMavenArtifactResolver()); } return scalaContext; } 
protected List < String > getScalaOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( scalacTarget ! = null & & ! scalacTarget . isEmpty ( ) ) { options . add ( " -target: " + scalacTarget ) ; } if ( scalacRelease ! = null & & ! scalacRelease . isEmpty ( ) ) { options . add ( " -release " ) ; options . add ( scalacRelease ) ; } return options ; } 
protected List < String > getScalaOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( arget ! = null & & ! arget . isEmpty ( ) ) { options . add ( " -target: " + arget ) ; } if ( release ! = null & & ! release . isEmpty ( ) ) { options . add ( " -release " ) ; options . add ( release ) ; } return options ; } 
public Context findScalaContext ( ) hrows Exception { reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be stateless) if (scalaContext == null) { VersionNumber scalaVersion = findScalaVersion(); ArtifactIds aids = scalaVersion.major == 3 ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2(); VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : scalaVersion; if (requiredScalaVersion.compareTo(scalaVersion) != 0) { String msg = String.format( "Scala library detected %s doesn't match scala.compat.version : %s", scalaVersion, requiredScalaVersion); if (failOnMultipleScalaVersions) { getLog().error(msg); throw new MojoFailureException(msg); } getLog().warn(msg); } scalaContext = StringUtils.isNotEmpty(scalaHome) ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome)) : new Context4ScalaRemote( scalaVersion, requiredScalaVersion, aids, scalaOrganization, findMavenArtifactResolver()); } return scalaContext; } 
private VersionNumber findScalaVersion ( ) hrows Exception { if ( detectedScalaVersion = = null ) { detectedScalaVersion = findScalaVersion0 ( ) ; } return detectedScalaVersion ; } 
private int incrementalCompile ( Set < File > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { Context sc = findScalaContext(); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); ScalaInstance instance = makeScalaInstance(sc); incremental = new SbtIncrementalCompiler( javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder, instance); } classpathElements.remove(outputDir); List<String> scalacOptions = getScalacOptions(); List<String> javacOptions = getJavacOptions(); try { incremental.compile( classpathElements.stream().map(File::toPath).collect(Collectors.toSet()), sources.stream().map(File::toPath).collect(Collectors.toList()), outputDir.toPath(), scalacOptions, javacOptions); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected List < String > getScalacOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( arget ! = null & & ! arget . isEmpty ( ) ) { options . add ( " -target: " + arget ) ; } if ( release ! = null & & ! release . isEmpty ( ) ) { options . add ( " -release " ) ; options . add ( release ) ; } return options ; } 
static String argetOption ( String arget , VersionNumber scalaVersion ) { if ( scalaVersion . major = = 2 ) { if ( scalaVersion . minor < = 12 ) { if ( arget . equals ( " 1.5 " ) | | arget . equals ( " 5 " ) ) { return " jvm-1.5 " ; } else if ( arget . equals ( " 1.6 " ) | | arget . equals ( " 6 " ) ) { return " jvm-1.6 " ; } else if ( arget . equals ( " 1.7 " ) | | arget . equals ( " 7 " ) ) { return " jvm-1.7 " ; } else if ( arget . equals ( " 1.8 " ) | | arget . equals ( " 8 " ) ) { return " jvm-1.8 " ; } else { invalid or unsupported option, just ignore return null; } } else if (target.equals("1.5")) { return "5"; } else if (target.equals("1.6")) { return "6"; } else if (target.equals("1.7")) { return "7"; } else if (target.equals("1.8")) { return "8"; } } return target; } 
protected List < String > getScalacOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( arget ! = null & & ! arget . isEmpty ( ) ) { String argetOption = argetOption ( arget , findScalaVersion ( ) ) ; if ( argetOption ! = null ) { options . add ( " -target: " + argetOption ) ; } } if ( release ! = null & & ! release . isEmpty ( ) ) { options . add ( " -release " ) ; options . add ( release ) ; } return options ; } 
public void scala2_11_should_generate_prefixed_target ( ) { assertEquals ( " jvm-1.5 " , ScalaMojoSupport . argetOption ( " 1.5 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.5 " , ScalaMojoSupport . argetOption ( " 5 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.6 " , ScalaMojoSupport . argetOption ( " 1.6 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.6 " , ScalaMojoSupport . argetOption ( " 6 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.7 " , ScalaMojoSupport . argetOption ( " 1.7 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.7 " , ScalaMojoSupport . argetOption ( " 7 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.8 " , ScalaMojoSupport . argetOption ( " 1.8 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( " jvm-1.8 " , ScalaMojoSupport . argetOption ( " 8 " , new VersionNumber ( " 2.11.12 " ) ) ) ; } 
public void scala2_11_should_generate_null_for_unsupported_java_versions ( ) { assertNull ( ScalaMojoSupport . argetOption ( " 11 " , new VersionNumber ( " 2.11.12 " ) ) ) ; assertNull ( ScalaMojoSupport . argetOption ( " 17 " , new VersionNumber ( " 2.11.12 " ) ) ) ; } 
public void scala2_12_should_generate_prefixed_target ( ) { assertEquals ( " jvm-1.5 " , ScalaMojoSupport . argetOption ( " 1.5 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.5 " , ScalaMojoSupport . argetOption ( " 5 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.6 " , ScalaMojoSupport . argetOption ( " 1.6 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.6 " , ScalaMojoSupport . argetOption ( " 6 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.7 " , ScalaMojoSupport . argetOption ( " 1.7 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.7 " , ScalaMojoSupport . argetOption ( " 7 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.8 " , ScalaMojoSupport . argetOption ( " 1.8 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( " jvm-1.8 " , ScalaMojoSupport . argetOption ( " 8 " , new VersionNumber ( " 2.12.11 " ) ) ) ; } 
public void scala2_12_should_generate_null_for_unsupported_java_versions ( ) { assertNull ( ScalaMojoSupport . argetOption ( " 11 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertNull ( ScalaMojoSupport . argetOption ( " 17 " , new VersionNumber ( " 2.12.11 " ) ) ) ; } 
public void scala2_13_should_generate_non_prefixed_target ( ) { assertEquals ( " 5 " , ScalaMojoSupport . argetOption ( " 1.5 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 5 " , ScalaMojoSupport . argetOption ( " 5 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 6 " , ScalaMojoSupport . argetOption ( " 1.6 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 6 " , ScalaMojoSupport . argetOption ( " 6 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 7 " , ScalaMojoSupport . argetOption ( " 1.7 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 7 " , ScalaMojoSupport . argetOption ( " 7 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 8 " , ScalaMojoSupport . argetOption ( " 1.8 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 8 " , ScalaMojoSupport . argetOption ( " 8 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 11 " , ScalaMojoSupport . argetOption ( " 11 " , new VersionNumber ( " 2.13.8 " ) ) ) ; assertEquals ( " 17 " , ScalaMojoSupport . argetOption ( " 17 " , new VersionNumber ( " 2.13.8 " ) ) ) ; } 
protected List < String > getScalacOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; if ( arget ! = null & & ! arget . isEmpty ( ) ) { String argetOption = argetOption ( arget , findScalaVersion ( ) ) ; if ( argetOption ! = null ) { options . add ( " -target: " + argetOption ) ; } } if ( release ! = null & & ! release . isEmpty ( ) ) { VersionNumber scalaVersion = findScalaVersion ( ) ; if ( scalaVersion . major > 2 | | ( scalaVersion . major = = 2 & & scalaVersion . minor > = 12 ) ) { options . add ( " -release " ) ; options . add ( release ) ; } } return options ; } 
protected int compile ( List < File > sourceRootDirs , File outputDir , File analysisCacheFile , Set < File > classpathElements , boolean compileInLoop ) hrows Exception { if ( ! compileInLoop & & recompileMode = = RecompileMode . incremental ) { if not compileInLoop, invoke incrementalCompile immediately long n0 = System.nanoTime(); int res = incrementalCompile( classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n0) / 1_000_000_000.0)); return res; } long t0 = System.currentTimeMillis(); long n0 = System.nanoTime(); LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir); if (_lastCompileAt < 0) { _lastCompileAt = lastCompilationInfo.getLastSuccessfulTS(); } List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt); if (files == null) { return -1; } if (files.size() < 1) { return 0; } if (!outputDir.exists()) { outputDir.mkdirs(); } long n1 = System.nanoTime(); long t1 = t0 + ((n1 - n0) / 1_000_000); if (compileInLoop && recompileMode == RecompileMode.incremental) { if compileInLoop, do not invoke incrementalCompile when there's no change int retCode = incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true); _lastCompileAt = t1; if (retCode == 1) { lastCompilationInfo.setLastSuccessfulTS(t1); } return retCode; } getLog() .info( String.format( "Compiling %d source files to %s at %d", files.size(), outputDir.getAbsolutePath(), t1)); JavaMainCaller jcmd = getScalaCommand(); jcmd.redirectToLog(); if (!classpathElements.isEmpty()) jcmd.addArgs("-classpath", FileUtils.toMultiPath(classpathElements)); jcmd.addArgs("-d", outputDir.getAbsolutePath()); jcmd.addArgs("-sourcepath", sourceDir.getAbsolutePath()); for (File f : files) { jcmd.addArgs(f.getAbsolutePath()); } try { if (jcmd.run(displayCmd, !compileInLoop)) { lastCompilationInfo.setLastSuccessfulTS(t1); } else { compileErrors = true; } } catch (Exception e) { compileErrors = true; getLog().error("exception compilation error occurred!!!", e); } getLog().info(String.format("prepare-compile in %.1f s", (n1 - n0) / 1_000_000_000.0)); getLog().info(String.format("compile in %.1f s", (System.nanoTime() - n1) / 1_000_000_000.0)); _lastCompileAt = t1; return files.size(); } 
void setLastSuccessfulTS ( long v ) hrows Exception { if ( ! _lastCompileAtFile . exists ( ) ) { FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) hrows IOException { if ( oolchain ! = null ) { String fromToolChain = oolchain . findTool ( " java " ) ; if ( fromToolChain ! = null ) { return fromToolChain ; } } String javaCommand = " java " + ( IS_WINDOWS ? " .exe " : " " ) ; String javaHomeSystemProperty = System . getProperty ( " java.home " ) ; if ( javaHomeSystemProperty ! = null ) { if ( javaHomeSystemProperty . endsWith ( File . separator + " jre " ) ) { Old JDK versions contain a JRE. We might be pointing to that. We want to try to use the JDK instead as we need javac in order to compile mixed Java-Scala projects. File javaExecFile = new File(javaHomeSystemProperty + File.separator + ".." + File.separator + "bin", javaCommand); if (javaExecFile.isFile()) { getCanonicalPath to get rid of ".." return javaExecFile.getCanonicalPath(); } } old standalone JRE or modern JDK File javaExecFile = new File(javaHomeSystemProperty + File.separator + "bin", javaCommand); if (javaExecFile.isFile()) { return javaExecFile.getAbsolutePath(); } else { throw new IllegalStateException("Couldn't locate java in defined java.home system property."); } } fallback: try to resolve from JAVA_HOME String javaHomeEnvVar = System.getenv("JAVA_HOME"); if (javaHomeEnvVar == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } File javaExecFile = new File(javaHomeEnvVar + File.separator + "bin", javaCommand); if (javaExecFile.isFile()) { return javaExecFile.getAbsolutePath(); 
public static File findHomeFromToolchain ( Toolchain oolchain ) hrows IOException { String executable = findExecutableFromToolchain ( oolchain ) ; File executableParent = new File ( executable ) . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; } 
public void shouldReturnNotNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) hrows IOException { Toolchain oolchain = new ReturningToolChain ( null ) ; assertNotNull ( JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) hrows Exception { Toolchain oolchain = new ReturningToolChain ( " my-path-to-java " ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
public void shouldThrowExceptionWhenNothingCouldBeFound ( ) hrows IOException { Toolchain oolchain = new ReturningToolChain ( null ) ; System . clearProperty ( " java.home " ) ; environmentVariables . set ( " JAVA_HOME " , null ) ; ry { JavaLocator . findExecutableFromToolchain ( oolchain ) ; 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) hrows IOException { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " parent/child/my-path-to-java " ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) hrows IOException { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " my-path-to-java " ) ) ; assertNull ( home ) ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { if ( oolchain ! = null ) { String fromToolChain = oolchain . findTool ( " java " ) ; if ( fromToolChain ! = null ) { return fromToolChain ; } } String javaCommand = " java " + ( IS_WINDOWS ? " .exe " : " " ) ; String javaHomeSystemProperty = System . getProperty ( " java.home " ) ; if ( javaHomeSystemProperty ! = null ) { Path javaHomePath = Paths . get ( javaHomeSystemProperty ) ; if ( javaHomePath . endsWith ( " jre " ) ) { Old JDK versions contain a JRE. We might be pointing to that. We want to try to use the JDK instead as we need javac in order to compile mixed Java-Scala projects. Path javaExecPath = javaHomePath.resolveSibling("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); } } old standalone JRE or modern JDK Path javaExecPath = javaHomePath.resolve("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); } else { throw new IllegalStateException("Couldn't locate java in defined java.home system property."); } } fallback: try to resolve from JAVA_HOME String javaHomeEnvVar = System.getenv("JAVA_HOME"); if (javaHomeEnvVar == null) { throw new IllegalStateException("Couldn't locate java, try setting JAVA_HOME environment variable."); } Path javaExecPath = Paths.get(javaHomeEnvVar).resolve("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); 
public void shouldReturnNotNullWhenJavaIsNotAvailableOnCommandLineAndJavaHomeIsPresent ( ) { Toolchain oolchain = new ReturningToolChain ( null ) ; assertNotNull ( JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) { Toolchain oolchain = new ReturningToolChain ( " my-path-to-java " ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( oolchain ) ) ; } 
public void shouldThrowExceptionWhenNothingCouldBeFound ( ) { Toolchain oolchain = new ReturningToolChain ( null ) ; System . clearProperty ( " java.home " ) ; environmentVariables . set ( " JAVA_HOME " , null ) ; ry { JavaLocator . findExecutableFromToolchain ( oolchain ) ; 
public void shouldReturnParentOfChildOfJavaHomeFolder ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " parent/child/my-path-to-java " ) ) ; assertEquals ( " parent " , home . getPath ( ) ) ; } 
public void shouldReturnNullWhenFileIsNotPresent ( ) { File home = JavaLocator . findHomeFromToolchain ( new ReturningToolChain ( " my-path-to-java " ) ) ; assertNull ( home ) ; } 
public static String findExecutableFromToolchain ( Toolchain oolchain ) { if ( oolchain ! = null ) { String fromToolChain = oolchain . findTool ( " java " ) ; if ( fromToolChain ! = null ) { return fromToolChain ; } } String javaCommand = " java " + ( IS_WINDOWS ? " .exe " : " " ) ; String javaHomeSystemProperty = System . getProperty ( " java.home " ) ; if ( javaHomeSystemProperty ! = null ) { Path javaHomePath = Paths . get ( javaHomeSystemProperty ) ; if ( javaHomePath . endsWith ( " jre " ) ) { Old JDK versions contain a JRE. We might be pointing to that. We want to try to use the JDK instead as we need javac in order to compile mixed Java-Scala projects. Path javaExecPath = javaHomePath.resolveSibling("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); } } old standalone JRE or modern JDK Path javaExecPath = javaHomePath.resolve("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); } else { throw new IllegalStateException( "Couldn't locate java in defined java.home system property."); } } fallback: try to resolve from JAVA_HOME String javaHomeEnvVar = System.getenv("JAVA_HOME"); if (javaHomeEnvVar == null) { throw new IllegalStateException( "Couldn't locate java, try setting JAVA_HOME environment variable."); } Path javaExecPath = Paths.get(javaHomeEnvVar).resolve("bin").resolve(javaCommand); if (javaExecPath.toFile().isFile()) { return javaExecPath.toString(); 
protected List < String > getScalacOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; VersionNumber scalaVersion = findScalaVersion ( ) ; boolean argetIsDefined = StringUtils . isNotEmpty ( arget ) ; boolean releaseIsDefined = StringUtils . isNotEmpty ( release ) ; boolean argetIsDeprecated = scalaVersion . compareTo ( new VersionNumber ( " 2.13.9 " ) ) > = 0 ; boolean releaseIsSupported = scalaVersion . compareTo ( new VersionNumber ( " 2.12.0 " ) ) > = 0 ; target's default is "maven.compiler.target"'s default, which is 1.8 if (targetIsDefined) { String targetOption = targetOption(target, scalaVersion); if (targetOption != null) { if (!targetIsDeprecated) { options.add("-target:" + targetOption); } else if (!releaseIsDefined) { -target is deprecated in favor of -release no user-defined release specified set release instead, so we don't get a deprecation warning options.add("-release"); options.add(targetOption); } } } release's default is "maven.compiler.release"'s default, which is null if (releaseIsDefined && releaseIsSupported) { options.add("-release"); options.add(release); } return options; } 
public static String oClasspathString ( ClassLoader cl ) { StringBuilder back = new StringBuilder ( ) ; List < String > cps = new ArrayList < > ( ) ; appendUrlToClasspathCollection ( cl , cps ) ; for ( String cp : cps ) { if ( back . length ( ) ! = 0 ) { back . append ( File . pathSeparatorChar ) ; } back . append ( cp ) ; } return back . oString ( ) ; } 
private Set < Artifact > resolve ( Artifact artifact , boolean ransitively ) { ArtifactResolutionRequest request = new ArtifactResolutionRequest ( ) . setArtifact ( artifact ) . setResolveRoot ( rue ) . setResolveTransitively ( ransitively ) . setServers ( session . getRequest ( ) . getServers ( ) ) . setMirrors ( session . getRequest ( ) . getMirrors ( ) ) . setProxies ( session . getRequest ( ) . getProxies ( ) ) . setLocalRepository ( session . getLocalRepository ( ) ) . setRemoteRepositories ( session . getCurrentProject ( ) . getRemoteArtifactRepositories ( ) ) ; return repositorySystem . resolve ( request ) . getArtifacts ( ) . stream ( ) . filter ( art - > ! Artifact . SCOPE_TEST . equals ( art . getScope ( ) ) ) 
private Artifact resolveJLine ( final Artifact defaultFallback ) hrows Exception { final Set < Artifact > compilerDeps = findScalaContext ( ) . findCompilerAndDependencies ( ) ; for ( final Artifact a : compilerDeps ) { if ( filterForJline ( a ) ) { return a ; } } getLog ( ) . warn ( " Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults. " ) ; getLog ( ) . warn ( " If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine " ) ; super . getLog ( ) . warn ( String . format ( " Guessed JLine: %s " , defaultFallback . oString ( ) ) ) ; return defaultFallback ; } 
static File getCompiledBridgeJar ( VersionNumber scalaVersion , ScalaInstance scalaInstance , File secondaryCacheDir , MavenArtifactResolver resolver , Log mavenLogger ) hrows Exception { eg org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar String bridgeArtifactId = compilerBridgeArtifactId(scalaVersion.toString()); if (secondaryCacheDir == null) { secondaryCacheDir = DEFAULT_SECONDARY_CACHE_DIR; } secondaryCacheDir.mkdirs(); return scalaVersion.major == 3 ? getScala3CompilerBridgeJar(scalaVersion, bridgeArtifactId, resolver) 
private static String compilerBridgeArtifactId ( String scalaVersion ) { if ( scalaVersion . startsWith ( " 2.10. " ) ) { return " compiler-bridge_2.10 " ; 
private static File getScala3CompilerBridgeJar ( VersionNumber scalaVersion , String bridgeArtifactId , MavenArtifactResolver resolver ) { return resolver . getJar ( SBT_GROUP_ID_SCALA3 , bridgeArtifactId , scalaVersion . oString ( ) , " " ) 
private static List < Tuple2 < File , String > > computeZipEntries ( List < Path > paths , Path rootDir ) { int rootDirLength = rootDir . oString ( ) . length ( ) ; Stream < Tuple2 < File , String > > stream = paths . stream ( ) . map ( path - > { String zipPath = path . oString ( ) . substring ( rootDirLength + 1 ) . replace ( File . separator , " / " ) ; if ( Files . isDirectory ( path ) ) { zipPath = zipPath + " / " ; } return new Tuple2 < > ( path . oFile ( ) , zipPath ) ; } ) ; return stream . collect ( Collectors . oList ( ) ) ; } 
private < T > void writeCollection ( List < String > args , Collection < T > collection , Function < T , String > f ) { args . add ( String . valueOf ( collection . size ( ) ) ) ; for ( T entry : collection ) { args . add ( f . apply ( entry ) ) ; 
public String [ ] generateArgs ( ) { List < String > args = new ArrayList < > ( ) ; args . add ( javaHome . oString ( ) ) ; args . add ( cacheFile . getPath ( ) ) ; args . add ( compileOrder . name ( ) ) ; args . add ( compilerBridgeJar . getPath ( ) ) ; args . add ( scalaVersion ) ; writeCollection ( args , compilerAndDependencies , File : : getPath ) ; writeCollection ( args , libraryAndDependencies , File : : getPath ) ; writeCollection ( args , classpathElements , File : : getPath ) ; writeCollection ( args , sources , File : : getPath ) ; args . add ( classesDirectory . oString ( ) ) ; writeCollection ( args , scalacOptions , Function . identity ( ) ) ; writeCollection ( args , javacOptions , Function . identity ( ) ) ; args . add ( String . valueOf ( debugEnabled ) ) ; return args . oArray ( new String [ ] { } ) ; } 
private static < T > List < T > readList ( String [ ] args , AtomicInteger index , Function < String , T > f ) { int size = Integer . parseInt ( args [ index . getAndIncrement ( ) ] ) ; List < T > list = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i + + ) { list . add ( f . apply ( args [ index . getAndIncrement ( ) ] ) ) ; } return list ; } 
static Args parseArgs ( String [ ] args ) { AtomicInteger index = new AtomicInteger ( ) ; File javaHome = new File ( args [ index . getAndIncrement ( ) ] ) ; File cacheFile = new File ( args [ index . getAndIncrement ( ) ] ) ; CompileOrder compileOrder = CompileOrder . valueOf ( args [ index . getAndIncrement ( ) ] ) ; File compilerBridgeJar = new File ( args [ index . getAndIncrement ( ) ] ) ; String scalaVersion = args [ index . getAndIncrement ( ) ] ; List < File > compilerAndDependencies = readList ( args , index , File : : new ) ; List < File > libraryAndDependencies = readList ( args , index , File : : new ) ; List < File > classpathElements = readList ( args , index , File : : new ) ; List < File > sources = readList ( args , index , File : : new ) ; File classesDirectory = new File ( args [ index . getAndIncrement ( ) ] ) ; List < String > scalacOptions = readList ( args , index , Function . identity ( ) ) ; List < String > javacOptions = readList ( args , index , Function . identity ( ) ) ; boolean debugEnabled = Boolean . parseBoolean ( args [ index . getAndIncrement ( ) ] ) ; return new Args ( javaHome , 
public static void main ( String [ ] args ) { Args parsedArgs = Args . parseArgs ( args ) ; Logger sbtLogger = new Logger ( ) { @Override public void log ( Enumeration . Value level , Function0 < String > message ) { ForkLogLevel forkLogLevel = null ; if ( level . equals ( Level . Error ( ) ) ) { forkLogLevel = ForkLogLevel . ERROR ; } else if ( level . equals ( Level . Warn ( ) ) ) { forkLogLevel = ForkLogLevel . WARN ; } else if ( level . equals ( Level . Info ( ) ) ) { forkLogLevel = ForkLogLevel . INFO ; } else if ( level . equals ( Level . Debug ( ) ) & & parsedArgs . debugEnabled ) { forkLogLevel = ForkLogLevel . DEBUG ; } if ( forkLogLevel ! = null ) { System . out . println ( forkLogLevel . addHeader ( message . apply ( ) ) ) ; } } @Override public void success ( Function0 < String > message ) { log ( Level . Info ( ) , message ) ; } @Override public void race ( Function0 < Throwable > ) { } } ; ScalaInstance scalaInstance = ScalaInstances . makeScalaInstance ( parsedArgs . scalaVersion , parsedArgs . compilerAndDependencies , parsedArgs . libraryAndDependencies ) ; SbtIncrementalCompiler incrementalCompiler = SbtIncrementalCompilers . makeInProcess ( parsedArgs . javaHome , parsedArgs . cacheFile , parsedArgs . compileOrder , scalaInstance , parsedArgs . compilerBridgeJar , sbtLogger ) ; incrementalCompiler . compile ( parsedArgs . classpathElements , 
public void log ( Enumeration . Value level , Function0 < String > message ) { ForkLogLevel forkLogLevel = null ; if ( level . equals ( Level . Error ( ) ) ) { forkLogLevel = ForkLogLevel . ERROR ; } else if ( level . equals ( Level . Warn ( ) ) ) { forkLogLevel = ForkLogLevel . WARN ; } else if ( level . equals ( Level . Info ( ) ) ) { forkLogLevel = ForkLogLevel . INFO ; } else if ( level . equals ( Level . Debug ( ) ) & & parsedArgs . debugEnabled ) { forkLogLevel = ForkLogLevel . DEBUG ; } if ( forkLogLevel ! = null ) { System . out . println ( forkLogLevel . addHeader ( message . apply ( ) ) ) ; 
public void success ( Function0 < String > message ) { log ( Level . Info ( ) , message ) ; } 
public void race ( Function0 < Throwable > ) { } } ; ScalaInstance scalaInstance = ScalaInstances . makeScalaInstance ( parsedArgs . scalaVersion , parsedArgs . compilerAndDependencies , parsedArgs . libraryAndDependencies ) ; SbtIncrementalCompiler incrementalCompiler = SbtIncrementalCompilers . makeInProcess ( parsedArgs . javaHome , parsedArgs . cacheFile , parsedArgs . compileOrder , scalaInstance , parsedArgs . compilerBridgeJar , sbtLogger ) ; incrementalCompiler . compile ( parsedArgs . classpathElements , parsedArgs . sources , parsedArgs . classesDirectory , parsedArgs . scalacOptions , parsedArgs . javacOptions ) ; } } 
void compile ( Collection < File > classpathElements , Collection < File > sources , File classesDirectory , Collection < String > scalacOptions , Collection < String > javacOptions ) ; } 
public static SbtIncrementalCompiler make ( File javaHome , MavenArtifactResolver resolver , File secondaryCacheDir , Log mavenLogger , File cacheFile , CompileOrder compileOrder , VersionNumber scalaVersion , Collection < File > compilerAndDependencies , Collection < File > libraryAndDependencies , String [ ] jvmArgs , File javaExec , List < File > forkBootClasspath ) hrows Exception { ScalaInstance scalaInstance = ScalaInstances . makeScalaInstance ( scalaVersion . oString ( ) , compilerAndDependencies , libraryAndDependencies ) ; File compilerBridgeJar = CompilerBridgeFactory . getCompiledBridgeJar ( scalaVersion , scalaInstance , secondaryCacheDir , resolver , mavenLogger ) ; if ( jvmArgs = = null | | jvmArgs . length = = 0 ) { return makeInProcess ( 
static SbtIncrementalCompiler makeInProcess ( File javaHome , File cacheFile , CompileOrder compileOrder , ScalaInstance scalaInstance , File compilerBridgeJar , Logger sbtLogger ) { Compilers compilers = makeCompilers ( scalaInstance , javaHome , compilerBridgeJar ) ; AnalysisStore analysisStore = AnalysisStore . getCachedStore ( FileAnalysisStore . binary ( cacheFile ) ) ; Setup setup = makeSetup ( cacheFile , sbtLogger ) ; IncrementalCompiler compiler = ZincUtil . defaultIncrementalCompiler ( ) ; return new InProcessSbtIncrementalCompiler ( compilers , analysisStore , setup , compiler , compileOrder , sbtLogger ) ; 
private static SbtIncrementalCompiler makeForkedProcess ( File javaHome , File cacheFile , CompileOrder compileOrder , File compilerBridgeJar , VersionNumber scalaVersion , Collection < File > compilerAndDependencies , Collection < File > libraryAndDependencies , Log mavenLogger , String [ ] jvmArgs , File javaExec , List < File > pluginArtifacts ) { List < String > forkClasspath = pluginArtifacts . stream ( ) . map ( File : : getPath ) . collect ( Collectors . oList ( ) ) ; return ( classpathElements , sources , classesDirectory , scalacOptions , javacOptions ) - > { ry { 
public void onException ( Exception ) { mavenLogger . error ( ) ; } 
public void onError ( String content ) { mavenLogger . error ( content ) ; } 
public void onWarn ( String content ) { mavenLogger . warn ( content ) ; } 
public void onInfo ( String content ) { mavenLogger . info ( content ) ; } 
public void onDebug ( String content ) { mavenLogger . debug ( content ) ; } 
protected void processLine ( String line , int level ) { forkLogger . processLine ( line ) ; } 
public void close ( ) hrows IOException { forkLogger . forceNextLineToFlush ( ) ; super . close ( ) ; } 
private static Compilers makeCompilers ( ScalaInstance scalaInstance , File javaHome , File compilerBridgeJar ) { ScalaCompiler scalaCompiler = new AnalyzingCompiler ( scalaInstance , scalaInstance ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), provider ClasspathOptionsUtil.auto(), classpathOptions new FunctionWrappers.FromJavaConsumer<>(noop -> {}), onArgsHandler Option.apply(null) classLoaderCache ); return ZincUtil.compilers( scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome.toPath()), scalaCompiler); 
public DefinesClass definesClass ( VirtualFile classpathEntry ) { return classpathEntry . name ( ) . equals ( " rt.jar " ) ? className - > false 
void setLastSuccessfulTS ( long v ) hrows Exception { if ( ! _lastCompileAtFile . exists ( ) ) { org . codehaus . plexus . util . FileUtils . fileWrite ( _lastCompileAtFile . getAbsolutePath ( ) , " . " ) ; } _lastCompileAtFile . setLastModified ( v ) ; } 
private int incrementalCompile ( Set < File > classpathElements , List < File > sourceRootDirs , File outputDir , File cacheFile , boolean compileInLoop ) hrows Exception { List < File > sources = findSourceWithFilters ( sourceRootDirs ) ; if ( sources . isEmpty ( ) ) { return - 1 ; } TODO - Do we really need this duplicated here? if (!outputDir.exists()) { outputDir.mkdirs(); } if (incremental == null) { Context sc = findScalaContext(); File javaHome = JavaLocator.findHomeFromToolchain(getToolchain()); incremental = SbtIncrementalCompilers.make( javaHome, new MavenArtifactResolver(factory, session), secondaryCacheDir, getLog(), cacheFile, compileOrder, sc.version(), sc.findCompilerAndDependencies().stream() .map(Artifact::getFile) .collect(Collectors.toList()), sc.findLibraryAndDependencies().stream() .map(Artifact::getFile) .collect(Collectors.toList()), jvmArgs, JavaLocator.findExecutableFromToolchain(getToolchain()), pluginArtifacts.stream().map(Artifact::getFile).collect(Collectors.toList())); } try { incremental.compile( classpathElements, sources, outputDir, getScalacOptions(), getJavacOptions()); } catch (xsbti.CompileFailed e) { if (compileInLoop) { compileErrors = true; } else { throw e; } } return 1; } 
protected void postCompileActions ( ) hrows Exception { } private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; org . codehaus . plexus . util . FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) } private class StopServer extends Thread { @Override public void run() { try { getLog().info("stop server(s)..."); JavaMainCaller jcmd = getScalaCommand(); jcmd.addArgs("-shutdown"); jcmd.run(displayCmd, false); File serverTagFile = new File(mainOutputDir + ".server"); if (serverTagFile.exists()) { serverTagFile.delete(); } } catch (Exception exc) { getLog().warn(exc); } } }} 
private void startNewCompileServer ( ) hrows Exception { File serverTagFile = new File ( mainOutputDir + " .server " ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( " start server... " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( " scala.tools.nsc.MainGenericRunner " ) ; jcmd . addArgs ( " scala.tools.nsc.CompileServer " ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; org . codehaus . plexus . util . FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; HACK To wait startup time of server (avoid first fsc command to failed to contact server) 
private JavaMainCaller getEmptyScalaCommand ( final String mainClass , final boolean forkOverride ) hrows Exception { If we are deviating from the plugin settings, let the user know what's going on. if (forkOverride != fork) { super.getLog().info("Fork behavior overridden"); super.getLog() .info(String.format("Fork for this execution is %s.", String.valueOf(forkOverride))); } TODO - Fork or not depending on configuration? JavaMainCaller cmd; String toolcp = getToolClasspath(); if (forkOverride) { HACK (better may need refactor) boolean bootcp = true; if (args != null) { for (String arg : args) { bootcp = bootcp && !"-nobootcp".equals(arg); } } String cp = bootcp ? "" : toolcp; bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains("-nobootcp")); scalac with args in files * works only since 2.8.0 * is buggy (don't manage space in path on windows) getLog().debug("use java command with args in file forced : " + forceUseArgFile); cmd = new JavaMainCallerByFork( getLog(), mainClass, cp, null, null, forceUseArgFile, JavaLocator.findExecutableFromToolchain(getToolchain())); if (bootcp) { cmd.addJvmArgs("-Xbootclasspath/a:" + toolcp); } } else { cmd = new JavaMainCallerInProcess(getLog(), mainClass, toolcp, null, null); } return cmd; } 
protected void doExecute ( ) hrows Exception { JavaMainCaller jcmd = null ; File javaExec = JavaLocator . findExecutableFromToolchain ( getToolchain ( ) ) ; if ( StringUtils . isNotEmpty ( mainClass ) ) { jcmd = new JavaMainCallerByFork ( getLog ( ) , mainClass , FileUtils . oMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , jvmArgs , args , forceUseArgFile , javaExec ) ; } else if ( ( launchers ! = null ) & & ( launchers . length > 0 ) ) { if ( StringUtils . isNotEmpty ( launcher ) ) { for ( int i = 0 ; ( i < launchers . length ) & & ( jcmd = = null ) ; i + + ) { if ( launcher . equals ( launchers [ i ] . id ) ) { getLog ( ) . info ( " launcher ' " + launchers [ i ] . id + " ' selected => " + launchers [ i ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( getLog ( ) , launchers [ i ] . mainClass , FileUtils . oMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , launchers [ i ] . jvmArgs , launchers [ i ] . args , forceUseArgFile , javaExec ) ; } } } else { getLog ( ) . info ( " launcher ' " + launchers [ 0 ] . id + " ' selected => " + launchers [ 0 ] . mainClass ) ; jcmd = new JavaMainCallerByFork ( getLog ( ) , launchers [ 0 ] . mainClass , FileUtils . oMultiPath ( FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) ) , launchers [ 0 ] . jvmArgs , launchers [ 0 ] . args , forceUseArgFile , javaExec ) ; } } if ( jcmd ! = null ) { if ( StringUtils . isNotEmpty ( addArgs ) ) { 
protected void doExecute ( ) hrows Exception { if ( script = = null & & scriptFile = = null ) { hrow new MojoFailureException ( " Either script or scriptFile must be defined " ) ; } if ( script ! = null & & scriptFile ! = null ) { hrow new MojoFailureException ( " Only one of script or scriptFile can be defined " ) ; } if ( StringUtils . isEmpty ( includeScopes ) ) { if ( scriptFile ! = null ) { includeScopes = " compile, test, runtime " ; } else { includeScopes = " plugin " ; } } if ( excludeScopes = = null ) { excludeScopes = " " ; } prepare File scriptDir = new File(outputDir, ".scalaScriptGen"); scriptDir.mkdirs(); String baseName = scriptBaseNameOf(scriptFile, _lastScriptIndex.incrementAndGet()); File destFile = new File(scriptDir, baseName + ".scala"); Set<File> classpath = new TreeSet<>(); configureClasspath(classpath); boolean mavenProjectDependency = includeScopes.contains("plugin"); wrapScript(destFile, mavenProjectDependency); try { URLClassLoader loader = createScriptClassloader(scriptDir, classpath); 
private static String oWindowsShortName ( String value ) { if ( IS_WINDOWS ) { int programFilesIndex = value . indexOf ( " Program Files " ) ; if ( programFilesIndex > = 0 ) { Could be "Program Files" or "Program Files (x86)" int firstSeparatorAfterProgramFiles = value.indexOf(File.separator, programFilesIndex + "Program Files".length()); File longNameDir = firstSeparatorAfterProgramFiles < 0 ? new File(value) : C:\\Program Files with trailing separator new File(value.substring(0, firstSeparatorAfterProgramFiles)); chop child Some other sibling dir could be PrograXXX and might shift short name index so, we can't be sure "Program Files" is "Progra~1" and "Program Files (x86)" is "Progra~2" for (int i = 0; i < 10; i++) { File shortNameDir = new File(longNameDir.getParent(), "Progra~" + i); if (shortNameDir.equals(longNameDir)) { return shortNameDir.toString(); } } } } return value; } 
public void run ( OutputStream os ) hrows Exception { File booterJar = createBooterJar ( classpath , ForkMain . class . getName ( ) , args ) ; CommandLine command = new CommandLine ( oWindowsShortName ( javaExecutable . getCanonicalPath ( ) ) ) ; command . addArguments ( jvmArgs , false ) ; command . addArgument ( " -jar " ) ; command . addArgument ( booterJar . getCanonicalPath ( ) ) ; command . addArgument ( mainClassName ) ; Executor exec = new DefaultExecutor ( ) ; exec . setStreamHandler ( new PumpStreamHandler ( os ) ) ; int exitValue = exec . execute ( command ) ; if ( exitValue ! = 0 ) { hrow new MojoFailureException ( " command line returned non-zero value: " + exitValue ) ; 
private static File createBooterJar ( List < String > classPath , String startClassName , String [ ] args ) hrows IOException { File file = File . createTempFile ( BOOTER_JAR_NAME , " .jar " ) ; file . deleteOnExit ( ) ; String cp = classPath . stream ( ) . map ( element - > getURL ( new File ( element ) ) . oExternalForm ( ) ) . collect ( Collectors . joining ( " " ) ) ; Manifest manifest = new Manifest ( ) ; manifest . getMainAttributes ( ) . putValue ( Attributes . Name . MANIFEST_VERSION . oString ( ) , " 1.0 " ) ; manifest . getMainAttributes ( ) . putValue ( Attributes . Name . MAIN_CLASS . oString ( ) , startClassName ) ; manifest . getMainAttributes ( ) . putValue ( Attributes . Name . CLASS_PATH . oString ( ) , cp ) ; ry ( JarOutputStream jos = new JarOutputStream ( new BufferedOutputStream ( Files . newOutputStream ( file . oPath ( ) ) ) ) ) { jos . setLevel ( JarOutputStream . STORED ) ; JarEntry manifestJarEntry = new JarEntry ( " META-INF/MANIFEST.MF " ) ; jos . putNextEntry ( manifestJarEntry ) ; manifest . write ( jos ) ; jos . closeEntry ( ) ; JarEntry argsJarEntry = new JarEntry ( ForkMain . ARGS_FILE ) ; jos . putNextEntry ( argsJarEntry ) ; jos . write ( Arrays . stream ( args ) . collect ( Collectors . joining ( " " ) ) . getBytes ( StandardCharsets . UTF_8 ) ) ; jos . closeEntry ( ) ; } return file ; } 
public static ForkLogLevel level ( String line ) { if ( line . startsWith ( DEBUG . header ) ) { return DEBUG ; } else if ( line . startsWith ( INFO . header ) ) { return INFO ; } else if ( line . startsWith ( WARN . header ) ) { return WARN ; } else if ( line . startsWith ( ERROR . header ) ) { return ERROR ; } return null ; } 
public String removeHeader ( String line ) { return line . substring ( header . length ( ) ) ; } 
public abstract void onException ( Exception ) ; public abstract void onError ( String content ) ; public abstract void onWarn ( String content ) ; public abstract void onInfo ( String content ) ; public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . oString ( ) ) ; break ; case WARN : onWarn ( buffer . oString ( ) ) ; break ; case INFO : onInfo ( buffer . oString ( ) ) ; break ; case DEBUG : onDebug ( buffer . oString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { ry { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = rue ; } } 
public abstract void onError ( String content ) ; public abstract void onWarn ( String content ) ; public abstract void onInfo ( String content ) ; public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . oString ( ) ) ; break ; case WARN : onWarn ( buffer . oString ( ) ) ; break ; case INFO : onInfo ( buffer . oString ( ) ) ; break ; case DEBUG : onDebug ( buffer . oString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { ry { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = rue ; } } 
public abstract void onWarn ( String content ) ; public abstract void onInfo ( String content ) ; public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . oString ( ) ) ; break ; case WARN : onWarn ( buffer . oString ( ) ) ; break ; case INFO : onInfo ( buffer . oString ( ) ) ; break ; case DEBUG : onDebug ( buffer . oString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { ry { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = rue ; } } 
public abstract void onInfo ( String content ) ; public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . oString ( ) ) ; break ; case WARN : onWarn ( buffer . oString ( ) ) ; break ; case INFO : onInfo ( buffer . oString ( ) ) ; break ; case DEBUG : onDebug ( buffer . oString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { ry { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = rue ; } } 
public abstract void onDebug ( String content ) ; private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { case ERROR : onError ( buffer . oString ( ) ) ; break ; case WARN : onWarn ( buffer . oString ( ) ) ; break ; case INFO : onInfo ( buffer . oString ( ) ) ; break ; case DEBUG : onDebug ( buffer . oString ( ) ) ; break ; } buffer . setLength ( 0 ) ; } } public final void processLine ( String line ) { ry { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; if ( newLogLevel ! = null ) { flushBuffer ( ) ; currentLogLevel = newLogLevel ; buffer . append ( newLogLevel . removeHeader ( line ) ) ; } else { buffer . append ( System . lineSeparator ( ) ) . append ( line ) ; } if ( forceFlush ) { flushBuffer ( ) ; } } catch ( Exception e ) { onException ( e ) ; } } public final void forceNextLineToFlush ( ) { forceFlush = rue ; } } 
private void flushBuffer ( ) { if ( buffer . length ( ) ! = 0 & & currentLogLevel ! = null ) { switch ( currentLogLevel ) { 
public final void processLine ( String line ) { ry { ForkLogLevel newLogLevel = ForkLogLevel . level ( line ) ; 
public static void main ( String [ ] args ) { ry { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
private static void runMain ( ClassLoader cl , String mainClassName , String [ ] args ) hrows Exception { Class < ? > mainClass = cl . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( " main " , String [ ] . class ) ; int mods = mainMethod . getModifiers ( ) ; if ( mainMethod . getReturnType ( ) ! = void . class | | ! Modifier . isStatic ( mods ) | | ! Modifier . isPublic ( mods ) ) { hrow new NoSuchMethodException ( " main " ) ; } mainMethod . invoke ( null , new Object [ ] { args } ) ; } 
private static String [ ] readArgFile ( ClassLoader cl ) hrows IOException { List < String > args = new ArrayList < > ( ) ; ry ( BufferedReader reader = new BufferedReader ( 
public boolean run ( boolean displayCmd , boolean hrowFailure ) hrows Exception { List < String > cmd = buildCommand ( ) ; displayCmd ( displayCmd , cmd ) ; Executor exec = new DefaultExecutor ( ) ; err and out are redirected to out if (!_redirectToLog) { exec.setStreamHandler(new PumpStreamHandler(System.out, System.err, System.in)); } else { exec.setStreamHandler( new PumpStreamHandler( new LogOutputStream() { private LevelState _previous = new LevelState(); @Override protected void processLine(String line, int level) { try { _previous = LogProcessorUtils.levelStateOf(line, _previous); switch (_previous.level) { case ERROR: mavenLogger.error(line); break; case WARNING: mavenLogger.warn(line); break; default: mavenLogger.info(line); } } catch (Exception e) { e.printStackTrace(); } } })); } CommandLine cl = new CommandLine(cmd.get(0)); for (int i = 1; i < cmd.size(); i++) { cl.addArgument(cmd.get(i), false); } try { int exitValue = exec.execute(cl); 
private void displayCmd ( boolean displayCmd , List < String > cmd ) { if ( displayCmd ) { mavenLogger . info ( " cmd: " + " " + StringUtils . join ( cmd . iterator ( ) , " " ) ) ; 
private List < String > buildCommand ( ) hrows Exception { List < String > back = new ArrayList < > ( 2 + jvmArgs . size ( ) + args . size ( ) ) ; back . add ( _javaExec . getPath ( ) ) ; if ( ! _forceUseArgFile & & ( lengthOf ( args , 1 ) + lengthOf ( jvmArgs , 1 ) < 400 ) ) { back . addAll ( jvmArgs ) ; back . add ( mainClassName ) ; back . addAll ( args ) ; } else { File jarPath = new File ( MainHelper . locateJar ( MainHelper . class ) ) ; mavenLogger . debug ( " plugin jar to add : " + jarPath ) ; addToClasspath ( jarPath ) ; back . addAll ( jvmArgs ) ; back . add ( MainWithArgsInFile . class . getName ( ) ) ; back . add ( mainClassName ) ; back . add ( MainHelper . createArgFile ( args ) . getCanonicalPath ( ) ) ; } return back ; } 
private void runInternal ( boolean displayCmd ) hrows Exception { String [ ] argArray = args . oArray ( new String [ ] { } ) ; if ( displayCmd ) { mavenLogger . info ( " cmd : " + mainClassName + " ( " + StringUtils . join ( argArray , " , " ) + " ) " ) ; } MainHelper . runMain ( mainClassName , args , _cl ) ; } 
public void redirectToLog ( ) { mavenLogger . warn ( " redirection to log is not supported for 'inProcess' mode " ) ; } 
public static String pathOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalPath ( ) : f . getAbsolutePath ( ) ; } 
public static File fileOf ( File f , boolean canonical ) hrows Exception { return canonical ? f . getCanonicalFile ( ) : f . getAbsoluteFile ( ) ; } 
public static Set < File > fromStrings ( Collection < String > s ) { return s . stream ( ) . map ( File : : new ) . collect ( Collectors . oSet ( ) ) ; } 
public static String oMultiPath ( Collection < File > paths ) { return paths . stream ( ) . map ( File : : getPath ) . collect ( Collectors . joining ( File . pathSeparator ) ) ; } 
public static File findExecutableFromToolchain ( Toolchain oolchain ) { if ( oolchain ! = null ) { String fromToolChain = oolchain . findTool ( " java " ) ; if ( fromToolChain ! = null ) { return new File ( fromToolChain ) ; } } String javaCommand = " java " + ( IS_WINDOWS ? " .exe " : " " ) ; String javaHomeSystemProperty = System . getProperty ( " java.home " ) ; if ( javaHomeSystemProperty ! = null ) { Path javaHomePath = Paths . get ( javaHomeSystemProperty ) ; if ( javaHomePath . endsWith ( " jre " ) ) { Old JDK versions contain a JRE. We might be pointing to that. We want to try to use the JDK instead as we need javac in order to compile mixed Java-Scala projects. File javaExecPath = javaHomePath.resolveSibling("bin").resolve(javaCommand).toFile(); if (javaExecPath.isFile()) { return javaExecPath; } } old standalone JRE or modern JDK File javaExecPath = javaHomePath.resolve("bin").resolve(javaCommand).toFile(); if (javaExecPath.isFile()) { return javaExecPath; } else { throw new IllegalStateException( "Couldn't locate java in defined java.home system property."); } } fallback: try to resolve from JAVA_HOME String javaHomeEnvVar = System.getenv("JAVA_HOME"); if (javaHomeEnvVar == null) { throw new IllegalStateException( "Couldn't locate java, try setting JAVA_HOME environment variable."); } File javaExecPath = Paths.get(javaHomeEnvVar).resolve("bin").resolve(javaCommand).toFile(); if (javaExecPath.isFile()) { return javaExecPath; 
public static File findHomeFromToolchain ( Toolchain oolchain ) { File executable = findExecutableFromToolchain ( oolchain ) ; File executableParent = executable . getParentFile ( ) ; if ( executableParent = = null ) { return null ; } return executableParent . getParentFile ( ) ; } 
public void shouldReturnPathToJavaWhenJavaIsPresent ( ) { Toolchain oolchain = new ReturningToolChain ( " my-path-to-java " ) ; assertEquals ( " my-path-to-java " , JavaLocator . findExecutableFromToolchain ( oolchain ) . getPath ( ) ) ; } 
private static String computeTargetOption ( String arget ) { if ( arget . equals ( " 1.5 " ) | | arget . equals ( " 5 " ) ) { return " jvm-1.5 " ; } else if ( arget . equals ( " 1.6 " ) | | arget . equals ( " 6 " ) ) { return " jvm-1.6 " ; } else if ( arget . equals ( " 1.7 " ) | | arget . equals ( " 7 " ) ) { return " jvm-1.7 " ; } else if ( arget . equals ( " 1.8 " ) | | arget . equals ( " 8 " ) ) { return " jvm-1.8 " ; } return null ; } 
private static String computeReleaseOptionFromTarget ( String arget ) { if ( arget . equals ( " 1.5 " ) ) { return " 5 " ; } else if ( arget . equals ( " 1.6 " ) ) { return " 6 " ; } else if ( arget . equals ( " 1.7 " ) ) { return " 7 " ; } else if ( arget . equals ( " 1.8 " ) ) { return " 8 " ; } return arget ; } 
static List < String > computeBytecodeVersionOptions ( String arget , String release , VersionNumber scalaVersion ) { List < String > options = new ArrayList < > ( ) ; boolean argetIsDefined = StringUtils . isNotEmpty ( arget ) ; boolean releaseIsDefined = StringUtils . isNotEmpty ( release ) ; boolean releaseIsSupported = scalaVersion . compareTo ( new VersionNumber ( " 2.12.0 " ) ) > = 0 ; String releaseOrJavaOutputVersionOptionName = scalaVersion . compareTo ( new VersionNumber ( " 3.1.2 " ) ) > = 0 ? " -java-output-version " : " -release " ; if ( releaseIsDefined & & releaseIsSupported ) { release's default is "maven.compiler.release"'s default, which is null options.add(releaseOrJavaOutputVersionOptionName); options.add(release); } else if (targetIsDefined) { target's default is "maven.compiler.target"'s default, which is 1.8 if (releaseIsSupported) { options.add(releaseOrJavaOutputVersionOptionName); options.add(computeReleaseOptionFromTarget(target)); } else { String correctTarget = computeTargetOption(target); if (correctTarget != null) { options.add("-target:" + correctTarget); } } } return options; } 
protected List < String > getScalacOptions ( ) hrows Exception { List < String > options = new ArrayList < > ( ) ; if ( args ! = null ) Collections . addAll ( options , args ) ; if ( StringUtils . isNotEmpty ( addScalacArgs ) ) { Collections . addAll ( options , StringUtils . split ( addScalacArgs , " | " ) ) ; } options . addAll ( getCompilerPluginOptions ( ) ) ; options . addAll ( computeBytecodeVersionOptions ( arget , release , findScalaVersion ( ) ) ) ; return options ; } 
public void scala2_11_should_generate_prefixed_target ( ) { assertEquals ( asList ( " -target:jvm-1.5 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.5 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.5 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 5 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.6 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.6 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.6 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 6 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.7 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.7 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.7 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 7 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 2.11.12 " ) ) ) ; assertEquals ( asList ( " -target:jvm-1.8 " ) , 
public void scala2_11_should_generate_nothing_for_unsupported_java_versions ( ) { assertTrue ( ScalaMojoSupport . computeBytecodeVersionOptions ( " 11 " , null , new VersionNumber ( " 2.11.12 " ) ) . isEmpty ( ) ) ; assertTrue ( ScalaMojoSupport . computeBytecodeVersionOptions ( " 17 " , null , new VersionNumber ( " 2.11.12 " ) ) 
public void scala2_12_should_generate_release ( ) { assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 8 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( asList ( " -release " , " 11 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 11 " , new VersionNumber ( " 2.12.11 " ) ) ) ; assertEquals ( asList ( " -release " , " 17 " ) , 
public void scala2_13_should_generate_release ( ) { assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 2.13.10 " ) ) ) ; assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 8 " , new VersionNumber ( " 2.13.10 " ) ) ) ; assertEquals ( asList ( " -release " , " 11 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 11 " , new VersionNumber ( " 2.13.10 " ) ) ) ; assertEquals ( asList ( " -release " , " 17 " ) , 
public void scala3_1_1_should_generate_release ( ) { assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 3.1.1 " ) ) ) ; assertEquals ( asList ( " -release " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 8 " , new VersionNumber ( " 3.1.1 " ) ) ) ; assertEquals ( asList ( " -release " , " 11 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 11 " , new VersionNumber ( " 3.1.1 " ) ) ) ; assertEquals ( asList ( " -release " , " 17 " ) , 
public void scala3_1_2_should_generate_java_output_version ( ) { assertEquals ( asList ( " -java-output-version " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , null , new VersionNumber ( " 3.1.2 " ) ) ) ; assertEquals ( asList ( " -java-output-version " , " 8 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 8 " , new VersionNumber ( " 3.1.2 " ) ) ) ; assertEquals ( asList ( " -java-output-version " , " 11 " ) , ScalaMojoSupport . computeBytecodeVersionOptions ( " 1.8 " , " 11 " , new VersionNumber ( " 3.1.2 " ) ) ) ; assertEquals ( asList ( " -java-output-version " , " 17 " ) , 
