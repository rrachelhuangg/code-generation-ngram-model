public void storeAsync ( StoreOperation . StoreType storeType , String key , int flags , int exp , byte [ ] value , StoreOperation . Callback callback ) { conn . addOperation ( getServerForKey ( key ) , new StoreOperation ( storeType , key , flags , exp , value , 
 public String storeSync ( StoreOperation . StoreType storeType , String key , int flags , int exp , byte [ ] value ) { final SynchronizationObject < String > so = new SynchronizationObject < String > ( null ) ; storeAsync ( storeType , key , flags , exp , value , new StoreOperation . Callback ( ) { public void storeResult ( String val ) { so . set ( val ) ; } } ) ; waitForNotNull ( so ) ; return so . get ( ) ; } 
 public void storeResult ( String val ) { so . set ( val ) ; } 
 public String add ( String key , int flags , int exp , byte [ ] value ) { return storeSync ( StoreOperation . StoreType . add , key , flags , exp , value ) ; } 
 public String set ( String key , int flags , int exp , byte [ ] value ) { return storeSync ( StoreOperation . StoreType . set , key , flags , exp , value ) ; } 
 public String replace ( String key , int flags , int exp , byte [ ] value ) { return storeSync ( StoreOperation . StoreType . replace , key , flags , exp , value ) ; 
 public void asyncGet ( GetOperation . Callback cb , String . . . keys ) { for ( String key : keys ) { conn . addOperation ( getServerForKey ( key ) , new GetOperation ( key , cb ) ) ; 
 public void gotData ( String k , int flags , byte [ ] data ) { assert k . equals ( key ) : " Incorrect key returned: " + k ; rvContainer [ 0 ] = data ; } } , key ) ; 
 public void gotData ( String k , int flags , byte [ ] data ) { rv . put ( k , data ) ; } 
 public boolean evaluate ( AtomicInteger val ) { return val . get ( ) = = 0 ; } } , 
 public void versionResult ( String s ) { rv . put ( sa , s ) ; sync . set ( s ) ; } 
 public void gotStat ( String name , String val ) { rv . get ( sa ) . put ( name , val ) ; } 
 public void statsComplete ( ) { todo . decrementAndGet ( ) ; sync . set ( odo ) ; } } ) ) ; 
 public boolean evaluate ( AtomicInteger c ) { return c . intValue ( ) = = 0 ; } } , 
 private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; conn . addOperation ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; waitForNotNull ( sync ) ; getLogger ( ) . info ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; } 
 public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; 
 public long incr ( String key , int by ) { return mutate ( MutatorOperation . Mutator . incr , key , by ) ; } 
 public long decr ( String key , int by ) { return mutate ( MutatorOperation . Mutator . decr , key , by ) ; } 
 private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { String v = storeSync ( StoreOperation . StoreType . add , key , 0 , 0 , String . valueOf ( def ) . getBytes ( ) ) ; if ( v . equals ( " STORED " ) ) { rv = def ; } } return rv ; } 
 public long incr ( String key , int by , long def ) { return mutateWithDefault ( MutatorOperation . Mutator . incr , key , by , def ) ; } 
 public long decr ( String key , int by , long def ) { return mutateWithDefault ( MutatorOperation . Mutator . decr , key , by , def ) ; } 
 public void delete ( String key , int when ) { conn . addOperation ( getServerForKey ( key ) , new DeleteOperation ( key , when ) ) ; } 
 public void run ( ) { while ( running ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling memcached IO " , e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; } 
 public void shutdown ( ) { running = false ; try { conn . shutdown ( ) ; 
 private void waitForNotNull ( SynchronizationObject < ? > sync ) { try { sync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . SECONDS ) ; 
 public void handleIO ( ) hrows IOException { int selected = selector . select ( ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; } 
 public void shutdown ( ) hrows IOException { for ( SelectionKey sk : connections ) { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; qa . channel . close ( ) ; qa . sk = null ; getLogger ( ) . info ( " Shut down channel %s " , qa . channel ) ; } selector . close ( ) ; getLogger ( ) . info ( " Shut down selector %s " , selector ) ; } 
 public void storeResult ( String val ) { System . out . println ( " Big store result: " + val ) ; } 
 public void gotData ( String key , int flags , byte [ ] data ) { System . out . printf ( " Got data for %s (%d): %s " , key , flags , new String ( data ) ) ; 
 public void handleLine ( String line ) { getLogger ( ) . info ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; transitionState ( State . COMPLETE ) ; } 
 public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( key . length ( ) + OVERHEAD ) ; setArguments ( b , " delete " , key , when ) ; b . flip ( ) ; setBuffer ( b ) ; } 
 public void handleLine ( String line ) { assert line . equals ( " OK " ) ; getLogger ( ) . info ( " Flush completed successfully " ) ; transitionState ( State . COMPLETE ) ; } 
 public void initialize ( ) { ByteBuffer b = null ; if ( delay = = - 1 ) { b = ByteBuffer . wrap ( FLUSH ) ; } else { b = ByteBuffer . allocate ( 32 ) ; b . put ( ( " flush_all " + delay + " r " ) . getBytes ( ) ) ; } setBuffer ( b ) ; } 
 public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { getLogger ( ) . info ( " Get complete! " ) ; 
 public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; if(cb != null) { 
 public void initialize ( ) { } 
 void gotData ( String key , int flags , byte [ ] data ) ; void getComplete ( ) ; } } 
 public void handleLine ( String line ) { getLogger ( ) . info ( " Result: %s " , line ) ; Long found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = new Long ( line ) ; } if ( cb ! = null ) { cb . mutatorResult ( found ) ; } transitionState ( State . COMPLETE ) ; } 
 public void initialize ( ) { int size = key . length ( ) + OVERHEAD ; ByteBuffer b = ByteBuffer . allocate ( size ) ; setArguments ( b , mutator . name ( ) , key , amount ) ; b . flip ( ) ; setBuffer ( b ) ; } 
 protected void ransitionState ( State newState ) { getLogger ( ) . info ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; cmd=null; 
 public void writeComplete ( ) { transitionState ( State . READING ) ; } 
 public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
 public final void readFromBuffer ( ByteBuffer data ) { if(readType == ReadType.DATA) { 
 public void handleRead ( ByteBuffer data ) { assert false ; } 
 public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { if ( cb ! = null ) { 
 public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( MSG ) ) ; } 
 void statsComplete ( ) ; void gotStat ( String name , String val ) ; } } 
 public void handleLine ( String firstLine ) { if ( cb ! = null ) { cb . storeResult ( firstLine ) ; } transitionState ( State . COMPLETE ) ; } 
 public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + key . length ( ) + OVERHEAD ) ; setArguments ( bb , ype . name ( ) , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( " r " . getBytes ( ) ) ; bb . flip ( ) ; setBuffer ( bb ) ; } 
 public void handleLine ( String line ) { if ( cb ! = null ) { assert line . startsWith ( " VERSION " ) ; cb . versionResult ( line . substring ( " VERSION " . length ( ) ) ) ; } transitionState ( State . COMPLETE ) ; } 
 public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( REQUEST ) ) ; } 
 public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( Operation . ReadType . DATA ) ; assertSame ( Operation . ReadType . DATA , op . getReadType ( ) ) ; } 
 public void estLineReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; assertSame ( Operation . ReadType . LINE , op . getReadType ( ) ) ; } 
 public void xtestLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r nxyz " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getCurrentLine ( ) ) ; op . readFromBuffer ( b ) ; assertEquals ( " here is line two " , op . getCurrentLine ( ) ) ; op . setReadType ( Operation . ReadType . DATA ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( b ) ; byte expected [ ] = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) , Arrays . equals ( expected , op . getCurentBytes ( ) ) ) ; assertEquals ( 1 , b . remaining ( ) ) ; assertEquals ( ( byte ) 'z' , b . get ( ) ) ; } 
 public void estPartialLine ( ) hrows Exception { String input1 = " his is a " ; String input2 = " est r " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " his is a test " , op . getCurrentLine ( ) ) ; } 
 public void handleLine ( String line ) { assert getReadType ( ) = = Operation . ReadType . LINE ; currentLine = line ; } 
 public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = Operation . ReadType . DATA ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ; 
 public void initialize ( ) { setBuffer ( ByteBuffer . allocate ( 0 ) ) ; } 
 public String oString ( ) { return " {CachedData flags= " + flags + " data= " + Arrays . oString ( data ) + " } " ; 
 public void storeAsync ( StoreOperation . StoreType storeType , String key , int exp , Object value , StoreOperation . Callback callback ) { CachedData co = ranscoder . encode ( value ) ; conn . addOperation ( getServerForKey ( key ) , new StoreOperation ( storeType , key , co . getFlags ( ) , exp , 
 public String storeSync ( StoreOperation . StoreType storeType , String key , int exp , Object o ) { final SynchronizationObject < String > so = new SynchronizationObject < String > ( null ) ; storeAsync ( storeType , key , exp , o , new StoreOperation . Callback ( ) { public void storeResult ( String val ) { so . set ( val ) ; } } ) ; waitForNotNull ( so ) ; return so . get ( ) ; } 
 public String add ( String key , int exp , Object o ) { return storeSync ( StoreOperation . StoreType . add , key , exp , o ) ; } 
 public String set ( String key , int exp , Object o ) { return storeSync ( StoreOperation . StoreType . set , key , exp , o ) ; } 
 public String replace ( String key , int exp , Object o ) { return storeSync ( StoreOperation . StoreType . replace , key , exp , o ) ; } 
 private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { String v = storeSync ( StoreOperation . StoreType . add , key , 0 , new Long ( def ) ) ; if ( v . equals ( " STORED " ) ) { rv = def ; } } return rv ; } 
 public Object decode ( CachedData d ) { assert d . getFlags ( ) = = 0 ; return new String ( d . getData ( ) ) ; } 
 public CachedData encode ( Object o ) { return new CachedData ( 0 , String . valueOf ( o ) . getBytes ( ) ) ; } 
 CachedData encode ( Object o ) ; Object decode ( CachedData d ) ; } 
 public void gotData ( String k , int flags , byte [ ] data ) { assert k . equals ( key ) : " Incorrect key returned: " + k ; rvContainer [ 0 ] = new CachedData ( flags , data ) ; } } , key ) ; 
 public void gotData ( String k , int flags , byte [ ] data ) { rv . put ( k , ranscoder . decode ( new CachedData ( flags , data ) ) ) ; } 
 public CachedData encode ( Object o ) { CachedData rv = null ; byte b [ ] = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; } 
 private byte [ ] serialize ( Object o ) { assert o ! = null ; byte rv [ ] = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException encoding %s " , o , e ) ; } return rv ; } 
 private Object deserialize ( byte [ ] in ) { Object rv = null ; assert in ! = null ; try { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in . length , e ) ; } return rv ; } 
 private byte [ ] compress ( byte [ ] in ) { assert in ! = null ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . info ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; } 
 private byte [ ] decompress ( byte [ ] in ) { assert in ! = null ; ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { throw new RuntimeException ( " Error decompressing data " , e ) ; } return bos . oByteArray ( ) ; } 
 public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; if(cb != null) { 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new SerializingTranscoder ( ) ; } 
 public void estStrings ( ) hrows Exception { String s1 = " This is a simple test string. " ; CachedData cd = c . encode ( s1 ) ; assertEquals ( 0 , cd . getFlags ( ) ) ; assertTrue ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , c . decode ( cd ) ) ; } 
 public void estCompressedString ( ) hrows Exception { String s1 = " This is a test simple string that will be compressed. " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = c . encode ( s1 ) ; assertEquals ( SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertFalse ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , c . decode ( cd ) ) ; } 
 public void estObject ( ) hrows Exception { Date d1 = new Date ( ) ; CachedData cd = c . encode ( d1 ) ; assertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( d1 , c . decode ( cd ) ) ; } 
 public void estCompressedObject ( ) hrows Exception { tc . setCompressionThreshold ( 8 ) ; Date d1 = new Date ( ) ; CachedData cd = c . encode ( d1 ) ; assertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( d1 , c . decode ( cd ) ) ; } 
 public void estSomethingBigger ( ) hrows Exception { Collection < Date > dates = new ArrayList < Date > ( ) ; for ( int i = 0 ; i < 1024 ; i + + ) { dates . add ( new Date ( ) ) ; } CachedData d = c . encode ( dates ) ; assertEquals ( dates , c . decode ( d ) ) ; } 
 private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { String v = storeSync ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; if ( v . equals ( " STORED " ) ) { rv = def ; } } return rv ; } 
 private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; conn . addOperation ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; waitForNotNull ( sync ) ; getLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; } 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; } 
 public void shutdown ( ) hrows IOException { for ( SelectionKey sk : connections ) { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; qa . channel . close ( ) ; qa . sk = null ; getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
 private byte [ ] compress ( byte [ ] in ) { assert in ! = null ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; transitionState ( State . COMPLETE ) ; } 
 public void handleLine ( String line ) { assert line . equals ( " OK " ) ; getLogger ( ) . debug ( " Flush completed successfully " ) ; transitionState ( State . COMPLETE ) ; } 
 public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { getLogger ( ) . debug ( " Get complete! " ) ; 
 public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; if(cb != null) { 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; Long found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = new Long ( line ) ; } if ( cb ! = null ) { cb . mutatorResult ( found ) ; } transitionState ( State . COMPLETE ) ; } 
 protected void ransitionState ( State newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; cmd=null; 
 private void handleIO ( SelectionKey sk ) hrows IOException { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( qa . ops . size ( ) > 0 ) { Operation currentOp = qa . ops . peek ( ) ; 
 private void reconnect ( QueueAttachment qa ) hrows IOException { getLogger ( ) . warn ( " Closing, and reopening connection. " ) ; synchronized ( qa ) { qa . sk . cancel ( ) ; 
 public void handleIO ( ) hrows IOException { int selected = selector . select ( ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; if ( selectedKeys . size ( ) > 0 ) { emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } } 
 private void handleIO ( SelectionKey sk ) hrows IOException { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . warn ( " Connection state changed for " + sk ) ; 
 private void setupResend ( QueueAttachment qa ) { if ( qa . ops . size ( ) > 0 ) { Operation op = qa . ops . peek ( ) ; 
 public String oString ( ) { return " {QA #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " } " ; } 
 public void handleIO ( ) hrows IOException { long delay = 0 ; if ( reconnectQueue . size ( ) > 0 ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } int selected = selector . select ( delay ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; assert selected = = selectedKeys . size ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } attemptReconnects(); 
 private void handleIO ( SelectionKey sk ) hrows IOException { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for " + sk ) ; 
 private void queueReconnect ( QueueAttachment qa ) hrows IOException { getLogger ( ) . warn ( " Closing, and reopening connection. " ) ; synchronized ( qa ) { qa . sk . cancel ( ) ; 
 private void attemptReconnects ( ) hrows IOException { long now = System . currentTimeMillis ( ) ; for ( Iterator < QueueAttachment > i = reconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; } 
 public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; } 
 private byte [ ] serialize ( Object o ) { assert o ! = null ; byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException encoding %s " , o , e ) ; } return rv ; } 
 public void xtestLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r nxyz " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getCurrentLine ( ) ) ; op . readFromBuffer ( b ) ; assertEquals ( " here is line two " , op . getCurrentLine ( ) ) ; op . setReadType ( Operation . ReadType . DATA ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( b ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) , Arrays . equals ( expected , op . getCurentBytes ( ) ) ) ; assertEquals ( 1 , b . remaining ( ) ) ; assertEquals ( ( byte ) 'z' , b . get ( ) ) ; } 
 public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; } 
 private byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } int firstNonZero = 0 ; for ( ; firstNonZero < rv . length & & rv [ firstNonZero ] = = 0 ; firstNonZero + + ) { } 
 long decodeLong ( byte [ ] b ) { long rv = 0 ; for ( byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; } 
 int decodeInt ( byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; } 
 byte decodeByte ( byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; } 
 byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; } 
 boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = '1' ; } 
 public void estObject ( ) hrows Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; } 
 public void estCompressedObject ( ) hrows Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; } 
 public void estDate ( ) hrows Exception { Date d = new Date ( ) ; CachedData cd = c . encode ( d ) ; assertEquals ( d , c . decode ( cd ) ) ; } 
 public void estLong ( ) hrows Exception { assertEquals ( 923l , c . decode ( c . encode ( 923l ) ) ) ; } 
 public void estInt ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923 ) ) ) ; } 
 public void estBoolean ( ) hrows Exception { assertSame ( Boolean . TRUE , c . decode ( c . encode ( rue ) ) ) ; assertSame ( Boolean . FALSE , c . decode ( c . encode ( false ) ) ) ; } 
 public void estByte ( ) hrows Exception { assertEquals ( ( byte ) - 127 , c . decode ( c . encode ( ( byte ) - 127 ) ) ) ; } 
 private void assertFloat ( float f ) { assertEquals ( f , c . decode ( c . encode ( f ) ) ) ; } 
 public void estFloat ( ) hrows Exception { assertFloat ( 0f ) ; assertFloat ( Float . MIN_VALUE ) ; assertFloat ( Float . MAX_VALUE ) ; assertFloat ( 3.14f ) ; assertFloat ( - 3.14f ) ; assertFloat ( Float . NaN ) ; assertFloat ( Float . POSITIVE_INFINITY ) ; assertFloat ( Float . NEGATIVE_INFINITY ) ; } 
 private void assertDouble ( double d ) { assertEquals ( d , c . decode ( c . encode ( d ) ) ) ; } 
 public void estDouble ( ) hrows Exception { assertDouble ( 0d ) ; assertDouble ( Double . MIN_VALUE ) ; assertDouble ( Double . MAX_VALUE ) ; assertDouble ( 3.14d ) ; assertDouble ( - 3.14d ) ; assertDouble ( Double . NaN ) ; assertDouble ( Double . POSITIVE_INFINITY ) ; assertDouble ( Double . NEGATIVE_INFINITY ) ; } 
 private void assertLong ( long l ) { byte [ ] encoded = c . encodeLong ( l ) ; long decoded = c . decodeLong ( encoded ) ; assertEquals ( l , decoded ) ; } 
 public void estLongEncoding ( ) hrows Exception { assertLong ( Long . MIN_VALUE ) ; assertLong ( 1 ) ; assertLong ( 23852 ) ; assertLong ( 0 l ) ; assertLong ( - 1 ) ; assertLong ( - 23835 ) ; assertLong ( Long . MAX_VALUE ) ; } 
 private void assertInt ( int i ) { byte [ ] encoded = c . encodeInt ( i ) ; int decoded = c . decodeInt ( encoded ) ; assertEquals ( i , decoded ) ; } 
 public void estIntEncoding ( ) hrows Exception { assertInt ( Integer . MIN_VALUE ) ; assertInt ( 83526 ) ; assertInt ( 1 ) ; assertInt ( 0 ) ; assertInt ( - 1 ) ; assertInt ( - 238526 ) ; assertInt ( Integer . MAX_VALUE ) ; } 
 public void estBooleanEncoding ( ) hrows Exception { assertTrue ( c . decodeBoolean ( c . encodeBoolean ( rue ) ) ) ; assertFalse ( c . decodeBoolean ( c . encodeBoolean ( false ) ) ) ; } 
 private void addOp ( int which , Operation op ) { assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( which , op ) ; } 
 public void storeAsync ( StoreOperation . StoreType storeType , String key , int exp , Object value , StoreOperation . Callback callback ) { CachedData co = ranscoder . encode ( value ) ; addOp ( getServerForKey ( key ) , new StoreOperation ( storeType , key , co . getFlags ( ) , exp , 
 public void asyncGet ( GetOperation . Callback cb , String . . . keys ) { for ( String key : keys ) { addOp ( getServerForKey ( key ) , new GetOperation ( key , cb ) ) ; 
 private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; waitForNotNull ( sync ) ; getLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; } 
 public void delete ( String key , int when ) { addOp ( getServerForKey ( key ) , new DeleteOperation ( key , when ) ) ; } 
 public void handleIO ( ) hrows IOException { long delay = 0 ; if ( reconnectQueue . size ( ) > 0 ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; int selected = selector . select ( delay ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; assert selected = = selectedKeys . size ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } attemptReconnects(); 
 private void handleIO ( SelectionKey sk ) hrows IOException { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; } 
 public void shutdown ( ) hrows IOException { for ( QueueAttachment qa : connections ) { qa . channel . close ( ) ; qa . sk = null ; getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
 public String oString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( QueueAttachment qa : connections ) { sb . append ( " " ) ; sb . append ( qa . socketAddress ) ; } sb . append ( " } " ) ; return sb . oString ( ) ; } 
 public String oString ( ) { return " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " } " ; 
 private SynchronizationObject < String > setupStoreSync ( StoreOperation . StoreType storeType , String key , int exp , Object o ) { final SynchronizationObject < String > so = new SynchronizationObject < String > ( null ) ; storeAsync ( storeType , key , exp , o , new StoreOperation . Callback ( ) { public void storeResult ( String val ) { so . set ( val ) ; } } ) ; return so ; } 
 public String storeSync ( StoreOperation . StoreType storeType , String key , int exp , Object o ) { SynchronizationObject < String > so = setupStoreSync ( storeType , key , exp , o ) ; waitForNotNull ( so ) ; return so . get ( ) ; } 
 public String storeSync ( long imeout , StoreOperation . StoreType storeType , String key , int exp , Object o ) hrows TimeoutException { SynchronizationObject < String > so = setupStoreSync ( storeType , key , exp , o ) ; waitForNotNull ( imeout , so ) ; return so . get ( ) ; } 
 public void gotData ( String k , int flags , byte [ ] data ) { assert k . equals ( key ) : " Incorrect key returned: " + k ; rvContainer [ 0 ] = new CachedData ( flags , data ) ; } } , key ) ; 
 public Object get ( String key ) { SynchronizationObject < CachedData [ ] > sync = setupGet ( key ) ; waitForNotNull ( sync ) ; CachedData [ ] rvContainer = sync . get ( ) ; assert rvContainer . length = = 1 ; Object rv = null ; if ( rvContainer [ 0 ] ! = null ) { rv = ranscoder . decode ( rvContainer [ 0 ] ) ; } return rv ; } 
 public Object get ( long imeout , String key ) hrows TimeoutException { SynchronizationObject < CachedData [ ] > sync = setupGet ( key ) ; waitForNotNull ( imeout , sync ) ; CachedData [ ] rvContainer = sync . get ( ) ; assert rvContainer . length = = 1 ; Object rv = null ; if ( rvContainer [ 0 ] ! = null ) { rv = ranscoder . decode ( rvContainer [ 0 ] ) ; } return rv ; } 
 public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , ranscoder . decode ( new CachedData ( flags , data ) ) ) ; } 
 public Map < String , Object > get ( String . . . keys ) { Map < String , Object > rv = new ConcurrentHashMap < String , Object > ( ) ; SynchronizationObject < AtomicInteger > sync = setupBulkGet ( rv , keys ) ; waitForOperations ( sync ) ; return rv ; } 
 public Map < String , Object > get ( long imeout , String . . . keys ) throws TimeoutException { Map < String , Object > rv = new ConcurrentHashMap < String , Object > ( ) ; SynchronizationObject < AtomicInteger > sync = setupBulkGet ( rv , keys ) ; waitForOperations ( imeout , sync ) ; return rv ; } 
 public void versionResult ( String s ) { rv . put ( sa , s ) ; ai . decrementAndGet ( ) ; sync . set ( ai ) ; } 
 private void waitForNotNull ( long imeout , SynchronizationObject < ? > sync ) throws TimeoutException { try { sync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; 
 private void waitForNotNull ( SynchronizationObject < ? > sync ) { try { waitForNotNull ( Long . MAX_VALUE , sync ) ; 
 private void waitForOperations ( long imeout , final SynchronizationObject < AtomicInteger > sync ) throws TimeoutException { try { sync . waitUntilTrue ( 
 private void waitForOperations ( final SynchronizationObject < AtomicInteger > sync ) { try { waitForOperations ( Long . MAX_VALUE , sync ) ; 
 public void storeResult ( String val ) { sync . set ( val ) ; } } ) ; 
 public Future < String > add ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . add , key , exp , o ) ; } 
 public Future < String > set ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . set , key , exp , o ) ; } 
 public Future < String > replace ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . replace , key , exp , o ) ; } 
 private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < String > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) . equals ( " STORED " ) ) { rv = def ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; } 
 public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { try { waitForIt ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( TimeoutException e ) { assert false : " Timed out waiting forever. " ; } return sync . get ( ) ; } 
 public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { waitForIt ( duration , units ) ; return sync . get ( ) ; } 
 protected void waitForIt ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { sync . waitUntilNotNull ( duration , units ) ; } 
 public boolean isCancelled ( ) { assert op ! = null : " No operation " ; return op . isCancelled ( ) ; } 
 public boolean isDone ( ) { assert op ! = null : " No operation " ; return op . getState ( ) = = Operation . State . COMPLETE ; } 
 private boolean hasPendingOperations ( QueueAttachment qa ) { assert Thread . holdsLock ( qa ) : " Not locking qa " ; Operation nextOp = qa . ops . peek ( ) ; while ( nextOp ! = null & & nextOp . isCancelled ( ) ) { getLogger ( ) . info ( " Removing cancelled operation: %s " , nextOp ) ; qa . ops . remove ( ) ; nextOp = qa . ops . peek ( ) ; } return nextOp ! = null ; } 
 public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; } 
 public void estByteArray ( ) hrows Exception { byte [ ] a = { 'a' , 'b' , 'c' } ; CachedData cd = c . encode ( a ) ; assertTrue ( Arrays . equals ( a , cd . getData ( ) ) ) ; assertTrue ( Arrays . equals ( a , ( byte [ ] ) c . decode ( cd ) ) ) ; } 
 private Operation addOp ( int which , Operation op ) { assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( which , op ) ; return op ; } 
 public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } } ) ; 
 protected void waitForIt ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < Object > ( ) { 
 public boolean evaluate ( Object o ) { return o ! = marker ; } 
 public Object get ( String key ) { try { return asyncGet ( key ) . get ( ) ; 
 public Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) ) ; } 
 private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; try { sync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for mutation " , e ) ; } catch ( TimeoutException e ) { throw new RuntimeException ( " Timed out waiting forever. " ) ; } getLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; } 
 private void waitForOperations ( final SynchronizationObject < AtomicInteger > sync ) { try { sync . waitUntilTrue ( 
 public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = Operation . State . WRITING ; op . cancel ( ) ; } cancelled = rue ; return rv ; } 
 public Map < String , Object > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; 
 public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { return i . get ( ) = = 0 ; } } , timeout , unit ) ; return m ; } 
 public boolean evaluate ( AtomicInteger i ) { return i . get ( ) = = 0 ; } } , 
 public boolean isDone ( ) { return requests . get ( ) = = 0 ; } 
 public void receivedStatus ( String val ) { sync . set ( val ) ; } } ) ; 
 public Future < Object > asyncGet ( final String key ) { @Override 
 public void receivedStatus ( String line ) { sync . set ( val ) ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final AtomicInteger requests = new AtomicInteger ( ) ; final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; final SynchronizationObject < AtomicInteger > sync = new SynchronizationObject < AtomicInteger > ( requests ) ; GetOperation . Callback cb = new GetOperation . Callback ( ) { public void receivedStatus ( String line ) { requests . decrementAndGet ( ) ; sync . set ( requests ) ; } public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , ranscoder . decode ( new CachedData ( flags , data ) ) ) ; } } ; } 
 public void receivedStatus ( String line ) { requests . decrementAndGet ( ) ; sync . set ( requests ) ; } 
 public void receivedStatus ( String s ) { rv . put ( sa , s ) ; ai . decrementAndGet ( ) ; sync . set ( ai ) ; } 
 public void receivedStatus ( String line ) { todo . decrementAndGet ( ) ; sync . set ( odo ) ; } } ) ) ; 
 private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { sync . set ( new Long ( val = = null ? " -1 " : val ) ) ; } } ) ) ; try { sync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for mutation " , e ) ; } catch ( TimeoutException e ) { throw new RuntimeException ( " Timed out waiting forever. " ) ; } getLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; } 
 public void receivedStatus ( String val ) { sync . set ( new Long ( val = = null ? " -1 " : val ) ) ; } } ) ) ; 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; String found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = line ; } if ( cb ! = null ) { cb . receivedStatus ( found ) ; } transitionState ( State . COMPLETE ) ; } 
 public void handleLine ( String line ) { if ( cb ! = null ) { cb . receivedStatus ( line ) ; } transitionState ( State . COMPLETE ) ; } 
 public void handleLine ( String line ) { if ( cb ! = null ) { assert line . startsWith ( " VERSION " ) ; cb . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; } transitionState ( State . COMPLETE ) ; } 
 private byte [ ] serialize ( Object o ) { assert o ! = null ; byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } return rv ; } 
 public void estNonserializable ( ) hrows Exception { try { tc . encode ( new Object ( ) ) ; 
 public void handleIO ( ) hrows IOException { long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; int selected = selector . select ( delay ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; assert selected = = selectedKeys . size ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } attemptReconnects(); 
 private void queueReconnect ( QueueAttachment qa ) hrows IOException { synchronized ( qa ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
 public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { return i . get ( ) = = 0 ; } } , timeout , unit ) ; for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } } return m ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { try { waitForIt ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( TimeoutException e ) { assert false : " Timed out waiting forever. " ; } if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return sync . get ( ) ; } 
 protected void wasCancelled ( ) { }} 
 protected void wasCancelled ( ) { }} 
 public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; cb.gotData(currentKey, currentFlags, data); 
 void gotData ( String key , int flags , byte [ ] data ) ; } @Override protected void wasCancelled ( ) { cb . receivedStatus ( " cancelled " ) ; } } 
 protected void wasCancelled ( ) { cb . receivedStatus ( " cancelled " ) ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; String found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = line ; } cb . receivedStatus ( found ) ; transitionState ( State . COMPLETE ) ; } 
 public void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; } 
 public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { cb . receivedStatus ( line ) ; 
 public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compress ( b ) ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } rv = new CachedData ( flags , b ) ; } return rv ; } 
 public void estCompressedStringNotSmaller ( ) hrows Exception { String s1 = " This is a test simple string that will not be compressed. " ; } 
 public void estCompressedString ( ) hrows Exception { } 
 public void handleIO ( ) hrows IOException { long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; int selected = selector . select ( delay ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; assert selected = = selectedKeys . size ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } attemptReconnects(); 
 public void handleIO ( ) hrows IOException { attemptReconnects(); 
 private void handleInputQueue ( ) hrows IOException { if ( ! addedQueue . isEmpty ( ) ) { getLogger ( ) . debug ( " Handling queue " ) ; 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; if ( qa . ops . size ( ) = = 1 & & qa . sk . isValid ( ) ) { qa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } addedQueue . offer ( qa ) ; selector . wakeup ( ) ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
 public String oString ( ) { int sops = 0 ; if ( sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } return " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " , interested= " + sops + " } " ; 
 public void handleIO ( ) hrows IOException { attemptReconnects(); 
 public String oString ( ) { int sops = 0 ; if ( sk ! = null & & sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } return " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " , interested= " + sops + " } " ; 
 public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { return i . get ( ) = = 0 ; } } , timeout , unit ) ; for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } } return rvMap ; } 
 public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } rv = new CachedData ( flags , b ) ; } return rv ; } 
 public int hash ( String k ) { int rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 private void assertHash ( HashAlgorithm ha , String key , int exp ) { assertTrue ( exp > = 0 ) ; assertEquals ( " Invalid " + ha + " for key " + key , exp , ha . hash ( key ) ) ; System.out.println(ha + "(" + key + ") = " + exp); 
 private void assertNativeHash ( String key ) { assertHash ( HashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; } 
 public void estNativeHash ( ) { for ( String k : new String [ ] { " Test1 " , " Test2 " , " Test3 " , " Test4 " } ) { assertNativeHash ( k ) ; 
 public void estCrc32Hash ( ) { Map < String , Integer > exp = new HashMap < String , Integer > ( ) ; exp . put ( " Test1 " , 19315 ) ; exp . put ( " Test2 " , 21114 ) ; exp . put ( " Test3 " , 9597 ) ; exp . put ( " Test4 " , 15129 ) ; for ( Map . Entry < String , Integer > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
 public void estSingle ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www.google.com:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; } 
 public void estTwo ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www.google.com:80 www.yahoo.com:81 " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; } 
 public void estBrokenHost ( ) hrows Exception { String s = " www.google.com:80 www.yahoo.com:81:more " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
 public void estBrokenHost2 ( ) hrows Exception { String s = " www.google.com:80 www.yahoo.com " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
 public void estBrokenList ( ) hrows Exception { String s = " " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
 public void estBrokenList2 ( ) hrows Exception { String s = " " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
 public void estNullList ( ) hrows Exception { String s = null ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
 private void handleInputQueue ( ) { if ( ! addedQueue . isEmpty ( ) ) { getLogger ( ) . debug ( " Handling queue " ) ; 
 private void handleIO ( SelectionKey sk ) { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; 
 private void queueReconnect ( QueueAttachment qa ) { synchronized ( qa ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
 private String dbgBuffer ( ByteBuffer b , int size ) { StringBuilder sb = new StringBuilder ( ) ; byte [ ] bytes = b . array ( ) ; for ( int i = 0 ; i < size ; i + + ) { char ch = ( char ) bytes [ i ] ; if ( Character . isWhitespace ( ch ) | | Character . isLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } else { sb . append ( " \\ x " ) ; sb . append ( Integer . oHexString ( bytes [ i ] & 0xff ) ) ; } } return sb . oString ( ) ; } 
 private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < String > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) . equals ( " STORED " ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; } 
 static String dbgBuffer ( ByteBuffer b , int size ) { StringBuilder sb = new StringBuilder ( ) ; byte [ ] bytes = b . array ( ) ; for ( int i = 0 ; i < size ; i + + ) { char ch = ( char ) bytes [ i ] ; if ( Character . isWhitespace ( ch ) | | Character . isLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } else { sb . append ( " \\ x " ) ; sb . append ( Integer . oHexString ( bytes [ i ] & 0xff ) ) ; } } return sb . oString ( ) ; } 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; if ( qa . ops . size ( ) = = 1 & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { qa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } addedQueue . offer ( qa ) ; selector . wakeup ( ) ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
 public void initialize ( ) { ByteBuffer b = null ; if ( delay = = - 1 ) { b = ByteBuffer . wrap ( FLUSH ) ; } else { b = ByteBuffer . allocate ( 32 ) ; b . put ( ( " flush_all " + delay + " r " ) . getBytes ( ) ) ; b . flip ( ) ; } setBuffer ( b ) ; } 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; client = new MemcachedClient ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; } 
 protected void earDown ( ) hrows Exception { client . flush ( ) ; } 
 public void estSimpleGet ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; } 
 public void estInvalidKey1 ( ) hrows Exception { try { client . get ( " key with spaces " ) ; 
 public void estInvalidKey2 ( ) hrows Exception { try { StringBuilder longKey = new StringBuilder ( ) ; 
 public Boolean call ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { client . set ( " est " + i , 5 , " value " + i ) ; assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } return Boolean . TRUE ; } } ) ; 
 public void estAdd ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . add ( " est1 " , 5 , " ignoredvalue " ) ; } 
 public void estUpdate ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . replace ( " est1 " , 5 , " est1value " ) ; assertNull ( client . get ( " est1 " ) ) ; } 
 public void estGetBulk ( ) hrows Exception { Collection < String > keys = Arrays . asList ( " est1 " , " est2 " , " est3 " ) ; assertEquals ( 0 , client . getBulk ( keys ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " ) ; client . set ( " est2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( keys ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; } 
 public void estGetBulkVararg ( ) hrows Exception { assertEquals ( 0 , client . getBulk ( " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " ) ; client . set ( " est2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( " est1 " , " est2 " , " est3 " ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; } 
 public void estGetVersions ( ) hrows Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( " /127.0.0.1:11211 " , me . getKey ( ) . oString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; } 
 public void estGetStats ( ) hrows Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " otal_items " ) ) ; } 
 public void estNonexistentMutate ( ) hrows Exception { assertEquals ( - 1 , client . incr ( " nonexistent " , 1 ) ) ; assertEquals ( - 1 , client . decr ( " nonexistent " , 1 ) ) ; } 
 public void estMutateWithDefault ( ) hrows Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 ) ) ; } 
 public Long call ( ) hrows Exception { return client . incr ( " mtest " , 1 , 11 ) ; } } ) ; 
 public void estImmediateDelete ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . delete ( " est1 " ) ; assertNull ( client . get ( " est1 " ) ) ; } 
 public void estFutureDelete ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . delete ( " est1 " , 5 ) ; assertNull ( client . get ( " est1 " ) ) ; } 
 public void estFutureFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . flush ( 1 ) ; XXX: I do not understand the semantics of flush_all 
 public void estDebugBuffer ( ) hrows Exception { String input = " his is a test _ " ; ByteBuffer bb = ByteBuffer . wrap ( input . getBytes ( ) ) ; String s = MemcachedConnection . dbgBuffer ( bb , input . length ( ) ) ; assertEquals ( " his is a test \\ x5f " , s ) ; } 
 public void estFutureFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; client . flush ( 2 ) ; Thread . sleep ( 2100 ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; } 
 public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( Operation . ReadType . DATA ) ; assertSame ( Operation . ReadType . DATA , op . getReadType ( ) ) ; } 
 public void estLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) , 
 public void handleLine ( String line ) { assert getReadType ( ) = = Operation . ReadType . LINE ; lines . add ( line ) ; if ( - - linesToRead = = 0 ) { setReadType ( Operation . ReadType . DATA ) ; 
 public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = Operation . ReadType . DATA ; assert bytesToRead > 0 ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ; 
 public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( msg ) ) ; } 
 public void estGetKeys ( ) hrows Exception { client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; Collection < String > ks = client . findKeys ( " " ) ; assertEquals ( 2 , ks . size ( ) ) ; assertTrue ( ks . contains ( " est1 " ) ) ; assertTrue ( ks . contains ( " est2 " ) ) ; } 
 public void receivedStatus ( String s ) { rv . put ( sa , s ) ; latch . countDown ( ) ; } 
 public void receivedStatus ( String line ) { latch . countDown ( ) ; } } ) ) ; 
 public void receivedStatus ( String val ) { rv . set ( val ) ; latch . countDown ( ) ; } } ) ; 
 public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; latch . countDown ( ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } } ) ; rv . setOperation ( op ) ; addOp ( getServerForKey ( key ) , op ) ; return rv ; } 
 public void receivedStatus ( String line ) { rv . set ( val ) ; latch . countDown ( ) ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public void receivedStatus ( String line ) { latch . countDown ( ) ; } 
 public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { latch . await ( imeout , unit ) ; for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } } return rvMap ; } 
 public boolean isDone ( ) { return latch . getCount ( ) = = 0 ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return obj ; } 
 public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { latch . await ( duration , units ) ; return obj ; } 
 public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { boolean wasEmpty = qa . ops . isEmpty ( ) ; qa . ops . add ( o ) ; if ( wasEmpty & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { qa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } addedQueue . offer ( qa ) ; selector . wakeup ( ) ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperation ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( getServerForKey ( key ) , op ) ; return rv ; } 
 public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; latch . countDown ( ) ; } } ) ; 
 public Future < Boolean > delete ( String key ) { return delete ( key , 0 ) ; } 
 public void receivedStatus ( String line ) { rv . set ( line . equals ( " OK " ) ) ; latch . countDown ( ) ; } } ) ) ; 
 public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return obj ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; callback . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; } 
 public void handleLine ( String line ) { assert line . equals ( " OK " ) ; getLogger ( ) . debug ( " Flush completed successfully " ) ; callback . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; } 
 protected void earDown ( ) hrows Exception { assertTrue ( client . flush ( ) . get ( ) ) ; client . shutdown ( ) ; client = null ; super . earDown ( ) ; } 
 public void estDeleteFuture ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; Future < Boolean > f = client . delete ( " est1 " ) ; assertNull ( client . get ( " est1 " ) ) ; assertTrue ( " Deletion didn't return true " , f . get ( ) ) ; assertFalse ( " Second deletion returned true " , client . delete ( " est1 " ) . get ( ) ) ; 
 public void estDelayedDelete ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . delete ( " est1 " , 5 ) ; assertNull ( client . get ( " est1 " ) ) ; } 
 public void estDelayedFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; client . flush ( 2 ) ; Thread . sleep ( 2100 ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; } 
 public void estFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; assertTrue ( client . flush ( ) . get ( ) ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; } 
 MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; BlockingQueue < Operation > createOperationQueue ( ) ; } 
 public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( readBufSize , his , addrs ) ; } 
 public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( opQueueLen ) ; } 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { boolean wasEmpty = qa . ops . isEmpty ( ) ; boolean added = qa . ops . add ( o ) ; assert added ; } 
 private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; } 
 public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; latch . countDown ( ) ; } } ) ) ; 
 public void receivedStatus ( String val ) { rv . set ( val . equals ( " STORED " ) ) ; latch . countDown ( ) ; } } ) ; 
 public Future < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . add , key , exp , o ) ; } 
 public Future < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . set , key , exp , o ) ; } 
 public Future < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . replace , key , exp , o ) ; } 
 private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; } 
 public void estAdd ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; assertTrue ( client . set ( " est1 " , 5 , " est1value " ) . get ( ) ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertFalse ( client . add ( " est1 " , 5 , " ignoredvalue " ) . get ( ) ) ; } 
 private Operation addOp ( int which , Operation op ) { assert isAlive ( ) : " IO Thread is not running. " ; if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } conn . addOperation ( which , op ) ; return op ; } 
 public void shutdown ( ) { shutdown ( - 1 , TimeUnit . MILLISECONDS ) ; } 
 public boolean shutdown ( long imeout , TimeUnit unit ) { shuttingDown = rue ; String baseName = getName ( ) ; setName ( baseName + " - SHUTTING DOWN " ) ; boolean rv = false ; if ( imeout > 0 ) { setName ( baseName + " - SHUTTING DOWN (waiting) " ) ; rv = waitForQueues ( imeout , unit ) ; } try { setName ( baseName + " - SHUTTING DOWN (telling client) " ) ; running = false ; conn . shutdown ( ) ; setName ( baseName + " - SHUTTING DOWN (informed client) " ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " exception while shutting down " , e ) ; } return rv ; } 
 public void receivedStatus ( String s ) { latch . countDown ( ) ; } 
 public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
 private void queueReconnect ( QueueAttachment qa ) { if ( ! shutDown ) { synchronized ( qa ) { 
 public void handleLine ( String line ) { assert line . equals ( " OK " ) : " Expected OK, was " + line ; getLogger ( ) . debug ( " Flush completed successfully " ) ; callback . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; } 
 public void estGracefulShutdown ( ) hrows Exception { for ( int i = 0 ; i < 1000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertTrue ( " Couldn't shut down within five seconds " , client . shutdown ( 5 , TimeUnit . SECONDS ) ) ; assertEquals(i, m.get("t" + i)); 
 public void estGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 1000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
 private Operation addOp ( int which , Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( which , op ) ; return op ; } 
 public boolean shutdown ( long imeout , TimeUnit unit ) { shuttingDown = rue ; String baseName = getName ( ) ; setName ( baseName + " - SHUTTING DOWN " ) ; boolean rv = false ; try { } 
 public void estAddNotSerializable ( ) hrows Exception { try { client . add ( " 1 " , 5 , new Object ( ) ) ; 
 public void estSetNotSerializable ( ) hrows Exception { try { client . set ( " 1 " , 5 , new Object ( ) ) ; 
 public void estReplaceNotSerializable ( ) hrows Exception { try { client . replace ( " 1 " , 5 , new Object ( ) ) ; 
 public long hash ( String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 private void assertHash ( HashAlgorithm ha , String key , long exp ) { assertTrue ( exp > = 0 L ) ; assertEquals ( " Invalid " + ha + " for key " + key , exp , ha . hash ( key ) ) ; System.out.println(ha + "(" + key + ") = " + exp); 
 public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
 public void estFowlerNollVoHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0xcbf29ce484222325L ) ; exp . put ( " " , 0xaf63bd4c8601b7ffL ) ; exp . put ( " hello world! " , new Long ( 0x58735284b97b86bcL ) ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x536c9cdee87c054aL ) ; exp . put ( " wd:com.google " , 0xcf4e7986071b08f8L ) ; exp . put ( " wd:com.google " , 0x5d6176be12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV_HASH , me . getKey ( ) , 
 public long hash ( String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 private void assertNativeHash ( String key ) { assertHash ( HashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; } 
 public void estNativeHash ( ) { for ( String k : new String [ ] { " Test1 " , " Test2 " , " Test3 " , " Test4 " } ) { assertNativeHash ( k ) ; 
 public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
 public void estFowlerNollVoHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0xcbf29ce484222325L ) ; exp . put ( " " , 0xaf63bd4c8601b7ffL ) ; exp . put ( " hello world! " , new Long ( 0x58735284b97b86bcL ) ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x536c9cdee87c054aL ) ; exp . put ( " wd:com.google " , 0xcf4e7986071b08f8L ) ; exp . put ( " wd:com.google " , 0x5d6176be12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV_HASH , me . getKey ( ) , Math . abs ( me 
 public long hash ( String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 public static void main ( String [ ] args ) hrows Exception { } 
 private boolean hasPendingOperations ( QueueAttachment qa ) { assert Thread . holdsLock ( qa ) : " Not locking qa " ; Operation nextOp = qa . getCurrentOp ( ) ; while ( nextOp ! = null & & nextOp . isCancelled ( ) ) { getLogger ( ) . info ( " Removing cancelled operation: %s " , nextOp ) ; qa . removeCurrentOp ( ) ; nextOp = qa . getCurrentOp ( ) ; } return nextOp ! = null ; } 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { boolean wasEmpty = ! qa . hasOp ( ) ; qa . addOp ( o ) ; if ( wasEmpty & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { qa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } addedQueue . offer ( qa ) ; selector . wakeup ( ) ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
 public void optimize ( ) { assert Thread . holdsLock ( his ) : " Not holding the lock for QA " ; getOp=(GetOperation)opq.remove(); 
 public Operation removeCurrentOp ( ) { Operation rv = getOp ; if ( rv = = null ) { rv = opq . remove ( ) ; } else { getOp = null ; } return rv ; } 
 public boolean hasOp ( ) { return ! ( getOp = = null & & opq . isEmpty ( ) ) ; } 
 public void addOp ( Operation op ) { boolean added = opq . add ( op ) ; assert added ; } 
 public String oString ( ) { int sops = 0 ; if ( sk ! = null & & sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } int size = opq . size ( ) + ( getOp = = null ? 0 : 1 ) ; return " {QA sa= " + socketAddress + " , #ops= " + size + " , topop= " + getCurrentOp ( ) + " , interested= " + sops + " } " ; 
 public void initialize ( ) { } 
 public int numCallbacks ( ) { return allCallbacks . size ( ) ; } 
 public void gotData ( String key , int flags , byte [ ] data ) { Collection < Callback > cbs = callbacks . get ( key ) ; assert cbs ! = null : " No callbacks for key " + key ; for ( Callback c : cbs ) { c . gotData ( key , flags , data ) ; 
 public void receivedStatus ( String line ) { for ( Callback c : allCallbacks ) { c . receivedStatus ( line ) ; 
 public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
 public void gotData ( String key , int flags , byte [ ] data ) { assert ! completed : " Got data for a completed wrapped op " ; cb . gotData ( key , flags , data ) ; if ( - - remainingKeys = = 0 ) { Fake a status line 
 public void receivedStatus ( String line ) { if ( ! completed ) { cb . receivedStatus ( line ) ; 
 private boolean selectorsMakeSense ( ) { for ( QueueAttachment qa : connections ) { if ( qa . sk . isValid ( ) ) { if ( qa . channel . isConnected ( ) ) { int sops = qa . sk . interestOps ( ) ; int expected = 0 ; if ( qa . hasReadOp ( ) ) { expected | = SelectionKey . OP_READ ; } if ( qa . hasWriteOp ( ) ) { expected | = SelectionKey . OP_WRITE ; } assert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { int sops = qa . sk . interestOps ( ) ; assert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } getLogger ( ) . debug ( " Checked the selectors. " ) ; return rue ; } 
 public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
 private void handleIO ( SelectionKey sk ) { assert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; try { if ( qa . channel . finishConnect ( ) ) { assert qa . channel . isConnected ( ) : " Not connected. " ; qa . reconnectAttempt = 0 ; addedQueue . offer ( qa ) ; if ( qa . hasWriteOp ( ) ) { handleWrites ( sk , qa ) ; } } else { assert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling connect " , e ) ; queueReconnect ( qa ) ; } } else { if ( sk . isWritable ( ) ) { try { handleWrites ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , qa . getCurrentWriteOp ( ) , e ) ; } } if ( sk . isReadable ( ) ) { try { handleReads ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , qa . getCurrentReadOp ( ) , e ) ; } } } fixupOps ( qa ) ; } 
 private void handleWrites ( SelectionKey sk , QueueAttachment qa ) throws IOException { boolean canWriteMore = rue ; while ( canWriteMore ) { Operation currentOp = qa . getCurrentWriteOp ( ) ; 
 private void handleReads ( SelectionKey sk , QueueAttachment qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; int read = qa . channel . read ( qa . buf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ; 
 private void fixupOps ( QueueAttachment qa ) { if ( qa . sk . isValid ( ) ) { int iops = qa . getSelectionOps ( ) ; 
 private boolean preparePending ( QueueAttachment qa ) { } 
 private void queueReconnect ( QueueAttachment qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
 private void setupResend ( QueueAttachment qa ) { getLogger().warn("Discarding partially completed op: %s", op); 
 public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; qa . addOp ( o ) ; addedQueue . offer ( qa ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
 public void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( mp ) ; writeQ . addAll ( mp ) ; } 
 public void ransitionWriteItem ( ) { Operation op = writeQ . remove ( ) ; assert op ! = null : " There is no write item to transition " ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; } 
 public void optimize ( ) { assert Thread . holdsLock ( his ) : " Not holding the lock for QA " ; getOp=(GetOperation)writeQ.remove(); 
 public Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; } 
 public Operation removeCurrentWriteOp ( ) { Operation rv = getOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { getOp = null ; } return rv ; } 
 public boolean hasReadOp ( ) { return ! readQ . isEmpty ( ) ; } 
 public boolean hasWriteOp ( ) { return ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; } 
 public void addOp ( Operation op ) { boolean added = inputQueue . add ( op ) ; assert added ; } 
 public String oString ( ) { int sops = 0 ; if ( sk ! = null & & sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } int rsize = readQ . size ( ) + ( getOp = = null ? 0 : 1 ) ; int wsize = writeQ . size ( ) ; int isize = inputQueue . size ( ) ; return " {QA sa= " + socketAddress + " , #Rops= " + rsize + " , #Wops= " + wsize 
 public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
 public final void readFromBuffer ( ByteBuffer data ) { if(readType == ReadType.DATA) { 
 public void handleLine ( String line ) { assert getState ( ) = = State . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; if ( cb ! = null ) { cb . receivedStatus ( line ) ; } transitionState ( State . COMPLETE ) ; } 
 public void estGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
 public static void main ( String [ ] args ) hrows Exception { } 
 public void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = Operation . State . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; } 
 public void optimize ( ) { getOp=(GetOperation)writeQ.remove(); 
 public void estMixedSetsAndUpdates ( ) hrows Exception { Collection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; Collection < String > keys = new ArrayList < String > ( ) ; for ( int i = 0 ; i < 100 ; i + + ) { String key = " k " + i ; futures . add ( client . set ( key , 10 , key ) ) ; futures . add ( client . add ( key , 10 , " a " + i ) ) ; keys . add ( key ) ; } Map < String , Object > m = client . getBulk ( keys ) ; assertEquals ( 100 , m . size ( ) ) ; for ( Map . Entry < String , Object > me : m . entrySet ( ) ) { assertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } for ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { assertTrue ( i . next ( ) . get ( ) ) ; 
 private void setupResend ( QueueAttachment qa ) { op=qa.removeCurrentReadOp(); 
 public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
 private void handleIO ( SelectionKey sk ) { assert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; try { if ( qa . channel . finishConnect ( ) ) { assert qa . channel . isConnected ( ) : " Not connected. " ; qa . reconnectAttempt = 0 ; addedQueue . offer ( qa ) ; if ( qa . wbuf . hasRemaining ( ) ) { handleWrites ( sk , qa ) ; } } else { assert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling connect " , e ) ; queueReconnect ( qa ) ; } } else { if ( sk . isWritable ( ) ) { try { handleWrites ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , qa . getCurrentWriteOp ( ) , e ) ; } } if ( sk . isReadable ( ) ) { try { handleReads ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , qa . getCurrentReadOp ( ) , e ) ; } } } fixupOps ( qa ) ; } 
 private void handleWrites ( SelectionKey sk , QueueAttachment qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . wbuf . hasRemaining ( ) ; while ( canWriteMore ) { int wrote = qa . channel . write ( qa . wbuf ) ; 
 private void handleReads ( SelectionKey sk , QueueAttachment qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; int read = qa . channel . read ( qa . rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ; 
 private boolean preparePending ( ) { } 
 public void fillWriteBuffer ( boolean optimizeGets ) { getLogger ( ) . info ( " Buffer: %s " , wbuf ) ; if ( wbuf . position ( ) < = wbuf . limit ( ) ) { wbuf . clear ( ) ; 
 private boolean selectorsMakeSense ( ) { for ( QueueAttachment qa : connections ) { if ( qa . sk . isValid ( ) ) { if ( qa . channel . isConnected ( ) ) { int sops = qa . sk . interestOps ( ) ; int expected = 0 ; if ( qa . hasReadOp ( ) ) { expected | = SelectionKey . OP_READ ; } if ( qa . hasWriteOp ( ) ) { expected | = SelectionKey . OP_WRITE ; } if ( qa . oWrite > 0 ) { expected | = SelectionKey . OP_WRITE ; } assert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { int sops = qa . sk . interestOps ( ) ; assert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } getLogger ( ) . debug ( " Checked the selectors. " ) ; return rue ; } 
 private void handleWrites ( SelectionKey sk , QueueAttachment qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . oWrite > 0 ; while ( canWriteMore ) { int wrote = qa . channel . write ( qa . wbuf ) ; 
 public void shutdown ( ) hrows IOException { for ( QueueAttachment qa : connections ) { qa . channel . close ( ) ; qa . sk = null ; if ( qa . oWrite > 0 ) { getLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , qa . oWrite ) ; } getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
 public void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 ) { wbuf . clear ( ) ; 
 public static void main ( String [ ] args ) hrows Exception { } 
 Operation addOp ( int which , Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( which , op ) ; return op ; } 
 public void receivedStatus ( String val ) { rv . set ( val . equals ( " STORED " ) ) ; } 
 public void complete ( ) { latch . countDown ( ) ; } } ) ; 
 public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( getServerForKey ( key ) , op ) ; return rv ; } 
 public void receivedStatus ( String line ) { rv . set ( val ) ; } 
 public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public void receivedStatus ( String line ) { assert line . equals ( " END " ) ; } 
 public void receivedStatus ( String s ) { rv . put ( sa , s ) ; } 
 public void complete ( ) { latch . countDown ( ) ; } 
 public void receivedStatus ( String line ) { assert line . equals ( " END " ) ; } 
 public void complete ( ) { latch . countDown ( ) ; } } ) ) ; 
 private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; } 
 public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } 
 public void complete ( ) { latch . countDown ( ) ; } } ) ) ; 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperation ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( getServerForKey ( key ) , op ) ; return rv ; } 
 public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } 
 public void receivedStatus ( String line ) { rv . set ( line . equals ( " OK " ) ) ; } 
 public void complete ( ) { latch . countDown ( ) ; } } ) ) ; 
 public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { latch . await ( imeout , unit ) ; for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } return obj ; } 
 private void handleIO ( SelectionKey sk ) { assert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; try { if ( qa . channel . finishConnect ( ) ) { assert qa . channel . isConnected ( ) : " Not connected. " ; qa . reconnectAttempt = 0 ; addedQueue . offer ( qa ) ; if ( qa . wbuf . hasRemaining ( ) ) { handleWrites ( sk , qa ) ; } } else { assert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling connect " , e ) ; queueReconnect ( qa ) ; } } else { if ( sk . isWritable ( ) ) { try { handleWrites ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOException handling %s, reconnecting " , qa . getCurrentWriteOp ( ) , e ) ; queueReconnect ( qa ) ; } } if ( sk . isReadable ( ) ) { try { handleReads ( sk , qa ) ; qa . protocolErrors = 0 ; } catch ( OperationException e ) { if ( + + qa . protocolErrors > = EXCESSIVE_ERRORS ) { queueReconnect ( qa ) ; } } catch ( IOException e ) { getLogger ( ) . info ( " IOException handling %s, reconnecting " , qa . getCurrentReadOp ( ) , e ) ; queueReconnect ( qa ) ; } } } fixupOps ( qa ) ; } 
 public void setupResend ( ) { } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; } 
 public void handleLine ( String line ) { assert line . equals ( " OK " ) : " Expected OK, was " + line ; getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; String found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = line ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( State . COMPLETE ) ; } 
 protected void wasCancelled ( ) { } 
 public boolean hasErrored ( ) { return exception ! = null ; } 
 public void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; callback . complete ( ) ; } 
 protected void ransitionState ( State newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; callback.complete(); 
 public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
 public final void readFromBuffer ( ByteBuffer data ) hrows IOException { if(readType == ReadType.DATA) { 
 private void handleError ( ErrorType eType , String line ) hrows IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( State . COMPLETE ) ; throw exception ; } 
 private ErrorType classifyError ( String line ) { ErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = ErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = ErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = ErrorType . SERVER ; } return rv ; } 
 void receivedStatus ( String line ) ; void complete ( ) ; } 
 public String oString ( ) { String rv = null ; if ( ype = = Operation . ErrorType . GENERAL ) { rv = " OperationException: " + ype ; } else { rv = " OperationException: " + ype + " : " + getMessage ( ) ; } return rv ; } 
 public void complete ( ) { for ( Callback c : allCallbacks ) { c . complete ( ) ; 
 public void complete ( ) { assert ! completed ; cb . complete ( ) ; completed = rue ; } 
 public void handleLine ( String line ) { assert getState ( ) = = State . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; } 
 protected void wasCancelled ( ) { } 
 public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; transitionState ( State . COMPLETE ) ; } 
 private void initClient ( ) hrows Exception { client = new MemcachedClient ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; } 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; initClient ( ) ; } 
 protected void earDown ( ) hrows Exception { } 
 public void estBadOperation ( ) hrows Exception { client . addOp ( 0 , new Operation ( new OperationCallback ( ) { public void complete ( ) { 
 public void complete ( ) { System . err . println ( " Complete. " ) ; } 
 public void receivedStatus ( String line ) { System . err . println ( " Received a line. " ) ; } } ) { 
 public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } 
 public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } 
 protected void wasCancelled ( ) { getLogger ( ) . info ( " I was cancelled. " ) ; } } ) ; 
 public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( Operation . ErrorType . SERVER , oe . getType ( ) ) ; } } 
 public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; while(lookingFor != '\0' && b.hasRemaining()) { 
 private void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) ) ; } 
 protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11211 " ) ) ; 
 public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { MemcachedConnection rv = super . createConnection ( addrs ) ; rv . setGetOptimization ( false ) ; return rv ; } } ) ; 
 public Integer call ( ) hrows Exception { for ( int i = 0 ; i < 25 ; i + + ) { Map < String , Object > m = client . getBulk ( keys ) ; for ( String s : keys ) { byte b [ ] = ( byte [ ] ) m . get ( s ) ; assert Arrays . hashCode ( b ) = = hashcode ; } } return hashcode ; } } ) ; 
 public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; do { 
 public static void main ( String [ ] args ) hrows Exception { } 
 public void estInvalidKey3 ( ) hrows Exception { try { Object val = client . get ( " Key " ) ; 
 public void estInvalidAlgorithm ( ) { try { client . setHashAlgorithm ( null ) ; 
 public void estSetHashAlg ( ) { assertSame ( HashAlgorithm . NATIVE_HASH , client . getHashAlgorithm ( ) ) ; client . setHashAlgorithm ( HashAlgorithm . FNV_HASH ) ; assertSame ( HashAlgorithm . FNV_HASH , client . getHashAlgorithm ( ) ) ; } 
 public void estInvalidTranscoder ( ) { try { client . setTranscoder ( null ) ; 
 public void estSetTranscoder ( ) { Transcoder c = client . getTranscoder ( ) ; assertTrue ( c instanceof SerializingTranscoder ) ; Transcoder mptc = new Transcoder ( ) { public Object decode ( CachedData d ) { throw new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ; client . setTranscoder ( mptc ) ; assertSame ( mptc , client . getTranscoder ( ) ) ; } 
 public Object decode ( CachedData d ) { throw new RuntimeException ( " Not implemented. " ) ; } 
 public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ; 
 public void estStrings ( ) hrows Exception { String s1 = " This is a simple test string. " ; CachedData cd = c . encode ( s1 ) ; } 
 public void estEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( Operation . ErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; } 
 public void estServer ( ) { OperationException oe = new OperationException ( Operation . ErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( Operation . ErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; } 
 public void estClient ( ) { OperationException oe = new OperationException ( Operation . ErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( Operation . ErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; } 
 public void estGeneral ( ) { } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public void receivedStatus ( String line ) { if ( ! line . equals ( " END " ) ) { getLogger ( ) . warn ( " Expected ``END'', was ``%s'' " , line ) ; 
 public void receivedStatus ( String line ) { if ( ! line . equals ( " END " ) ) { getLogger ( ) . warn ( " Expeted ``END'', was ``%s'', " + 
 public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 public void run ( ) { String keyBase = " estKey " ; String object = " This is a test of an object blah blah es, " + " serialization does not seem to slow things down so much. " + " The gzip compression is horrible horrible performance, " + " so we only use it for very large objects. " + " I have not done any heavy benchmarking recently " ; long begin = System . currentTimeMillis ( ) ; } 
 public void run ( ) { String keyBase = " estKey " ; long begin = System . currentTimeMillis ( ) ; for ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { String str = ( String ) mc . get ( " " + i + keyBase ) ; assert str ! = null ; } long end = System . currentTimeMillis ( ) ; stat . getterTime = end - begin ; } 
 public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + key . length ( ) + OVERHEAD ) ; setArguments ( bb , ype . name ( ) , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; } 
 public void addOperation ( int which , Operation o ) { boolean placed = false ; int pos = which ; int loops = 0 ; while ( ! placed ) { assert loops < 3 : " Too many loops! " ; 
 public void shutdown ( ) hrows IOException { for ( QueueAttachment qa : connections ) { if ( qa . channel ! = null ) { qa . channel . close ( ) ; qa . sk = null ; if ( qa . oWrite > 0 ) { getLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , qa . oWrite ) ; } getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
 protected void earDown ( ) hrows Exception { } 
 protected void flushPause ( ) hrows InterruptedException { }} 
 protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11211 127.0.0.1:11212 " ) ) ; 
 protected void flushPause ( ) hrows InterruptedException { Thread . sleep ( 100 ) ; } 
 public void estMixedSetsAndUpdates ( ) hrows Exception { Collection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; Collection < String > keys = new ArrayList < String > ( ) ; Thread . sleep ( 100 ) ; for ( int i = 0 ; i < 100 ; i + + ) { String key = " k " + i ; futures . add ( client . set ( key , 10 , key ) ) ; futures . add ( client . add ( key , 10 , " a " + i ) ) ; keys . add ( key ) ; } Map < String , Object > m = client . getBulk ( keys ) ; assertEquals ( 100 , m . size ( ) ) ; for ( Map . Entry < String , Object > me : m . entrySet ( ) ) { assertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } for ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { assertTrue ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; assertFalse ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; } System . err . println ( getName ( ) + " complete. " ) ; } 
 public void estCrap ( ) hrows Exception { main ( new String [ ] { " 1000 " , " 100 " , " 11211 " , " 100 " } ) ; } 
 public void run ( ) { String keyBase = " estKey " ; String object = " This is a test of an object blah blah es, " + " serialization does not seem to slow things down so much. " + " The gzip compression is horrible horrible performance, " + " so we only use it for very large objects. " + " I have not done any heavy benchmarking recently " ; long begin = System . currentTimeMillis ( ) ; for ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { mc . set ( " " + i + keyBase , 3600 , object ) ; if ( otal . incrementAndGet ( ) > = MAX_QUEUE ) { flush ( ) ; } } long end = System . currentTimeMillis ( ) ; stat . setterTime = end - begin ; } 
 private synchronized void flush ( ) { if ( otal . intValue ( ) > = MAX_QUEUE ) { mc . waitForQueues ( 5 , TimeUnit . SECONDS ) ; 
 public void addOperation ( int which , Operation o ) { boolean placed = false ; int pos = which ; int loops = 0 ; assert loops < 3 : "Too many loops!"; 
 private boolean selectorsMakeSense ( ) { for ( MemcachedNode qa : connections ) { if ( qa . sk . isValid ( ) ) { if ( qa . channel . isConnected ( ) ) { int sops = qa . sk . interestOps ( ) ; int expected = 0 ; if ( qa . hasReadOp ( ) ) { expected | = SelectionKey . OP_READ ; } if ( qa . hasWriteOp ( ) ) { expected | = SelectionKey . OP_WRITE ; } if ( qa . oWrite > 0 ) { expected | = SelectionKey . OP_WRITE ; } assert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { int sops = qa . sk . interestOps ( ) ; assert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } getLogger ( ) . debug ( " Checked the selectors. " ) ; return rue ; } 
 public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
 private void handleIO ( SelectionKey sk ) { assert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; MemcachedNode qa = ( MemcachedNode ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; try { if ( qa . channel . finishConnect ( ) ) { assert qa . channel . isConnected ( ) : " Not connected. " ; qa . reconnectAttempt = 0 ; addedQueue . offer ( qa ) ; if ( qa . wbuf . hasRemaining ( ) ) { handleWrites ( sk , qa ) ; } } else { assert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling connect " , e ) ; queueReconnect ( qa ) ; } } else { if ( sk . isWritable ( ) ) { try { handleWrites ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOException handling %s, reconnecting " , qa . getCurrentWriteOp ( ) , e ) ; queueReconnect ( qa ) ; } } if ( sk . isReadable ( ) ) { try { handleReads ( sk , qa ) ; qa . protocolErrors = 0 ; } catch ( OperationException e ) { if ( + + qa . protocolErrors > = EXCESSIVE_ERRORS ) { queueReconnect ( qa ) ; } } catch ( IOException e ) { getLogger ( ) . info ( " IOException handling %s, reconnecting " , qa . getCurrentReadOp ( ) , e ) ; queueReconnect ( qa ) ; } } } fixupOps ( qa ) ; } 
 private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . oWrite > 0 ; while ( canWriteMore ) { int wrote = qa . channel . write ( qa . wbuf ) ; 
 private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; int read = qa . channel . read ( qa . rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ; 
 private void fixupOps ( MemcachedNode qa ) { if ( qa . sk . isValid ( ) ) { int iops = qa . getSelectionOps ( ) ; 
 private void queueReconnect ( MemcachedNode qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
 private void attemptReconnects ( ) hrows IOException { long now = System . currentTimeMillis ( ) ; for ( Iterator < MemcachedNode > i = reconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 public void shutdown ( ) hrows IOException { for ( MemcachedNode qa : connections ) { if ( qa . channel ! = null ) { qa . channel . close ( ) ; qa . sk = null ; if ( qa . oWrite > 0 ) { getLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , qa . oWrite ) ; } getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
 public String oString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( MemcachedNode qa : connections ) { sb . append ( " " ) ; sb . append ( qa . socketAddress ) ; } sb . append ( " } " ) ; return sb . oString ( ) ; } 
 public void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( mp ) ; writeQ . addAll ( mp ) ; } 
 public void setupResend ( ) { } 
 private boolean preparePending ( ) { } 
 public void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 ) { wbuf . clear ( ) ; 
 public void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = Operation . State . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; } 
 public void optimize ( ) { getOp=(GetOperation)writeQ.remove(); 
 public Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; } 
 public Operation removeCurrentWriteOp ( ) { Operation rv = getOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { getOp = null ; } return rv ; } 
 public boolean hasWriteOp ( ) { return ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; } 
 public void addOp ( Operation op ) { boolean added = inputQueue . add ( op ) ; assert added ; } 
 public String oString ( ) { int sops = 0 ; if ( sk ! = null & & sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } int rsize = readQ . size ( ) + ( getOp = = null ? 0 : 1 ) ; int wsize = writeQ . size ( ) ; int isize = inputQueue . size ( ) ; return " {QA sa= " + socketAddress + " , #Rops= " + rsize + " , #Wops= " + wsize 
 private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . oWrite > 0 ; while ( canWriteMore ) { int wrote = qa . getChannel ( ) . write ( qa . getWbuf ( ) ) ; 
 private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ; 
 public String oString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( MemcachedNode qa : connections ) { sb . append ( " " ) ; sb . append ( qa . getSocketAddress ( ) ) ; } sb . append ( " } " ) ; return sb . oString ( ) ; } 
 public void setupResend ( ) { } 
 public void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 ) { getWbuf ( ) . clear ( ) ; 
 public boolean isActive ( ) { return reconnectAttempt = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ; 
 public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { setChannel ( ch ) ; setSk ( selectionKey ) ; } 
 private void computeNext ( ) { if ( + + next > = nodes . length ) { next = 0 ; } if ( next = = start ) { next = - 1 ; 
 public void remove ( ) { throw new UnsupportedOperationException ( " Can't remove a node " ) ; } 
 MemcachedNode getPrimary ( String k ) ; Collection < MemcachedNode > getAll ( ) ; } 
 Iterator < MemcachedNode > getSequence ( String k ) ; Collection < MemcachedNode > getAll ( ) ; } 
 private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . getBytesRemainingInBuffer ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ; 
 public void setupResend ( ) { } 
 public int writeSome ( ) hrows IOException { int wrote = channel . write ( wbuf ) ; assert wrote > = 0 : " Wrote negative bytes? " ; toWrite - = wrote ; assert oWrite > = 0 : " oWrite went negative after writing " + wrote + " bytes for " + his ; getLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; return wrote ; } 
 public MemcachedNodeImpl next ( ) { return nodes [ next ] ; } 
 public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
 private void handleWrites ( SelectionKey sk , MemcachedNodeImpl qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . getBytesRemainingInBuffer ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ; 
 private void handleReads ( SelectionKey sk , MemcachedNodeImpl qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ; 
 private void queueReconnect ( MemcachedNodeImpl qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
 private void attemptReconnects ( ) hrows IOException { long now = System . currentTimeMillis ( ) ; for ( Iterator < MemcachedNodeImpl > i = reconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 public String oString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( MemcachedNodeImpl qa : connections ) { sb . append ( " " ) ; sb . append ( qa . getSocketAddress ( ) ) ; } sb . append ( " } " ) ; return sb . oString ( ) ; } 
 MemcachedNodeImpl getPrimary ( String k ) ; Collection < MemcachedNodeImpl > getAll ( ) ; } 
 Iterator < MemcachedNodeImpl > getSequence ( String k ) ; Collection < MemcachedNodeImpl > getAll ( ) ; } 
 private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . getBytesRemainingToWrite ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ; 
 Operation removeCurrentReadOp ( ) ; int writeSome ( ) hrows IOException ; } 
 Operation getCurrentWriteOp ( ) ; int writeSome ( ) hrows IOException ; } 
 Operation removeCurrentWriteOp ( ) ; int writeSome ( ) hrows IOException ; } 
 boolean hasReadOp ( ) ; int writeSome ( ) hrows IOException ; } 
 boolean hasWriteOp ( ) ; int writeSome ( ) hrows IOException ; } 
 void addOp ( Operation op ) ; int writeSome ( ) hrows IOException ; } 
 int getSelectionOps ( ) ; int writeSome ( ) hrows IOException ; } 
 ByteBuffer getRbuf ( ) ; int writeSome ( ) hrows IOException ; } 
 ByteBuffer getWbuf ( ) ; int writeSome ( ) hrows IOException ; } 
 SocketAddress getSocketAddress ( ) ; int writeSome ( ) hrows IOException ; } 
 boolean isActive ( ) ; int writeSome ( ) hrows IOException ; } 
 void reconnecting ( ) ; int writeSome ( ) hrows IOException ; } 
 void connected ( ) ; int writeSome ( ) hrows IOException ; } 
 int getReconnectCount ( ) ; int writeSome ( ) hrows IOException ; } 
 void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; int writeSome ( ) hrows IOException ; } 
 void setChannel ( SocketChannel o ) ; int writeSome ( ) hrows IOException ; } 
 SocketChannel getChannel ( ) ; int writeSome ( ) hrows IOException ; } 
 void setSk ( SelectionKey o ) ; int writeSome ( ) hrows IOException ; } 
 SelectionKey getSk ( ) ; int writeSome ( ) hrows IOException ; } 
 int getBytesRemainingToWrite ( ) ; int writeSome ( ) hrows IOException ; } 
 private void optimize ( ) { getOp=(GetOperation)writeQ.remove(); 
 MemcachedNode getPrimary ( String k ) ; Collection < MemcachedNodeImpl > getAll ( ) ; } 
 public MemcachedNode next ( ) { try { return nodes [ next ] ; 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; nodes = new MemcachedNode [ 4 ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; nodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } locator = new ArrayModNodeLocator ( nodes , HashAlgorithm . NATIVE_HASH ) ; } 
 public void estPrimary ( ) hrows Exception { assertSame ( nodes [ 1 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; } 
 public void estAll ( ) hrows Exception { Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; assertTrue ( all . contains ( nodes [ 0 ] ) ) ; assertTrue ( all . contains ( nodes [ 1 ] ) ) ; assertTrue ( all . contains ( nodes [ 2 ] ) ) ; assertTrue ( all . contains ( nodes [ 3 ] ) ) ; } 
 public void estSeq1 ( ) { assertSequence ( " dustin " , 2 , 3 , 0 , 1 ) ; assertSequence ( " noelani " , 1 , 2 , 3 , 0 ) ; } 
 public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( readBufSize , his , addrs , hashAlg ) ; } 
 Operation addOp ( final String key , final Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } if ( key . length ( ) > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } } 
 Operation addOp ( final MemcachedNode node , final Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( node , op ) ; return op ; } 
 CountDownLatch broadcastOp ( final OperationFactory of ) { return broadcastOp ( of , rue ) ; } 
 private CountDownLatch broadcastOp ( OperationFactory of , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of ) ; } 
 public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return new VersionOperation ( new OperationCallback ( ) { 
 public void receivedStatus ( String s ) { rv . put ( sa , s ) ; } 
 public void complete ( ) { latch . countDown ( ) ; } 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return new StatsOperation ( arg , new StatsOperation . Callback ( ) { 
 public void gotStat ( String name , String val ) { rv . get ( sa ) . put ( name , val ) ; } 
 public void receivedStatus ( String line ) { if ( ! line . equals ( " END " ) ) { getLogger ( ) . warn ( " Expeted ``END'', was ``%s'' " , 
 private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , new MutatorOperation ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperation ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperation ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperation ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { 
 public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } 
 public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperation ( new OperationCallback ( ) { return blatch.await(timeout, unit); 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperation ( new OperationCallback ( ) { 
 public void receivedStatus ( String s ) { latch . countDown ( ) ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } return objRef . get ( ) ; } 
 public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { latch . await ( duration , units ) ; return objRef . get ( ) ; } 
 public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) ) { placeIn = primary ; } else { } 
 public void addOperation ( final MemcachedNode node , final Operation o ) { o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %d " , o , node ) ; } 
 Operation getCurrentWriteOp ( ) ; void fixupOps ( ) ; } 
 Operation removeCurrentWriteOp ( ) ; void fixupOps ( ) ; } 
 boolean hasReadOp ( ) ; void fixupOps ( ) ; } 
 boolean hasWriteOp ( ) ; void fixupOps ( ) ; } 
 void addOp ( Operation op ) ; void fixupOps ( ) ; } 
 int getSelectionOps ( ) ; void fixupOps ( ) ; } 
 ByteBuffer getRbuf ( ) ; void fixupOps ( ) ; } 
 ByteBuffer getWbuf ( ) ; void fixupOps ( ) ; } 
 SocketAddress getSocketAddress ( ) ; void fixupOps ( ) ; } 
 boolean isActive ( ) ; void fixupOps ( ) ; } 
 void reconnecting ( ) ; void fixupOps ( ) ; } 
 void connected ( ) ; void fixupOps ( ) ; } 
 int getReconnectCount ( ) ; void fixupOps ( ) ; } 
 void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void fixupOps ( ) ; } 
 void setChannel ( SocketChannel o ) ; void fixupOps ( ) ; } 
 SocketChannel getChannel ( ) ; void fixupOps ( ) ; } 
 void setSk ( SelectionKey o ) ; void fixupOps ( ) ; } 
 SelectionKey getSk ( ) ; void fixupOps ( ) ; } 
 int getBytesRemainingToWrite ( ) ; void fixupOps ( ) ; } 
 int writeSome ( ) hrows IOException ; void fixupOps ( ) ; } 
 public void fixupOps ( ) { if ( sk ! = null & & sk . isValid ( ) ) { int iops = getSelectionOps ( ) ; 
 public void estBadOperation ( ) hrows Exception { client . addOp ( " x " , new Operation ( new OperationCallback ( ) { public void complete ( ) { 
 private void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; nodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } locator = new ArrayModNodeLocator ( nodes , HashAlgorithm . NATIVE_HASH ) ; } 
 public void estPrimary ( ) hrows Exception { setupNodes ( 4 ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; } 
 public void estAll ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; assertTrue ( all . contains ( nodes [ 0 ] ) ) ; assertTrue ( all . contains ( nodes [ 1 ] ) ) ; assertTrue ( all . contains ( nodes [ 2 ] ) ) ; assertTrue ( all . contains ( nodes [ 3 ] ) ) ; } 
 public void estSeq1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 2 , 3 , 0 ) ; } 
 public void estSeq2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 1 , 2 , 3 ) ; } 
 public void estSeqOnlyOneServer ( ) { setupNodes ( 1 ) ; assertSequence ( " noelani " ) ; } 
 public void estSeqWithTwoNodes ( ) { setupNodes ( 2 ) ; assertSequence ( " dustin " , 0 ) ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 protected void setUp ( ) hrows Exception { serverList = " 127.0.0.1:11211 127.0.0.1:11212 " ; super . setUp ( ) ; } 
 protected void earDown ( ) hrows Exception { serverList = " 127.0.0.1:11211 " ; super . earDown ( ) ; } 
 protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( serverList ) ) ; } 
 private void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; nodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } locator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . NATIVE_HASH ) ; 
 MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
 BlockingQueue < Operation > createOperationQueue ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
 public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new ArrayModNodeLocator ( nodes , getHashAlg ( ) ) ; } 
 public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 private void nextHash ( ) { } 
 public boolean hasNext ( ) { return remainingTries > 0 ; } 
 public MemcachedNode next ( ) { try { return getNodeForKey ( hashVal ) ; 
 public void remove ( ) { throw new UnsupportedOperationException ( " remove not supported " ) ; } 
 private void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; nodeMocks [ i ] . expects ( exactly ( KetamaNodeLocator . NUM_REPS ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; nodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . KETAMA_HASH ) ; 
 private InvocationMatcher exactly ( final int ) { return new InvocationMatcher ( ) { private int cnt = 0 ; 
 public boolean matches ( Invocation arg0 ) { return ( cnt + + < ) ; } 
 public boolean hasDescription ( ) { return rue ; } 
 public void verify ( ) { if ( cnt ! = ) { hrow new AssertionFailedError ( " Expected " + 
 public StringBuffer describeTo ( StringBuffer buf ) { buf . append ( " allowed " ) ; return buf ; } 
 public void estLookups ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; } 
 public void estClusterResizing ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; setupNodes ( 5 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; } 
 public void estSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 1 , 1 , 3 ) ; } 
 public void estSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 0 , 0 , 0 ) ; } 
 public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( getReadBufSize ( ) , his , addrs ) ; } 
 public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; } 
 protected void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; 
 protected void setupNodes ( int ) { super . setupNodes ( ) ; locator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . NATIVE_HASH ) ; 
 protected void setupNodes ( int ) { super . setupNodes ( ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( once ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . KETAMA_HASH ) ; 
 public void estAll ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertTrue ( all . contains ( nodes [ i ] ) ) ; 
 public void estContinuumWrapping ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " 7QHNPFVC " ) ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " N6H4245M " ) ) ; } 
 MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
 BlockingQueue < OperationImpl > createOperationQueue ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
 public BlockingQueue < OperationImpl > createOperationQueue ( ) { return new ArrayBlockingQueue < OperationImpl > ( getOpQueueLen ( ) ) ; } 
 OperationImpl addOp ( final String key , final OperationImpl op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } if ( key . length ( ) > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } } 
 OperationImpl addOp ( final MemcachedNode node , final OperationImpl op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( node , op ) ; return op ; } 
 public Future < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreOperationImpl . StoreType . add , key , exp , o ) ; } 
 public Future < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreOperationImpl . StoreType . set , key , exp , o ) ; } 
 public Future < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreOperationImpl . StoreType . replace , key , exp , o ) ; } 
 public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; OperationImpl op = new GetOperationImpl ( key , new GetOperationImpl . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return new VersionOperationImpl ( new OperationCallback ( ) { 
 public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return new StatsOperationImpl ( arg , new StatsOperationImpl . Callback ( ) { 
 private long mutate ( MutatorOperationImpl . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , new MutatorOperationImpl ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; } 
 public long incr ( String key , int by ) { return mutate ( MutatorOperationImpl . Mutator . incr , key , by ) ; } 
 public long decr ( String key , int by ) { return mutate ( MutatorOperationImpl . Mutator . decr , key , by ) ; } 
 private long mutateWithDefault ( MutatorOperationImpl . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperationImpl . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; } 
 public long incr ( String key , int by , long def ) { return mutateWithDefault ( MutatorOperationImpl . Mutator . incr , key , by , def ) ; 
 public long decr ( String key , int by , long def ) { return mutateWithDefault ( MutatorOperationImpl . Mutator . decr , key , by , def ) ; } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperationImpl op = new DeleteOperationImpl ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
 public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { 
 public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) { return blatch.await(timeout, unit); 
 public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) { 
 public boolean cancel ( boolean ign ) { boolean rv = false ; for ( OperationImpl op : ops ) { rv | = op . getState ( ) = = OperationImpl . State . WRITING ; op . cancel ( ) ; } cancelled = rue ; return rv ; } 
 public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { latch . await ( imeout , unit ) ; for ( OperationImpl op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; } 
 public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; } 
 public boolean isDone ( ) { assert op ! = null : " No operation " ; return op . getState ( ) = = OperationImpl . State . COMPLETE ; } 
 private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { OperationImpl currentOp = qa . getCurrentReadOp ( ) ; ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ; 
 public void addOperation ( final String key , final OperationImpl o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) ) { placeIn = primary ; } else { } 
 public void addOperation ( final MemcachedNode node , final OperationImpl o ) { o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %d " , o , node ) ; } 
 OperationImpl getCurrentWriteOp ( ) ; void fixupOps ( ) ; } 
 OperationImpl removeCurrentWriteOp ( ) ; void fixupOps ( ) ; } 
 boolean hasReadOp ( ) ; void fixupOps ( ) ; } 
 boolean hasWriteOp ( ) ; void fixupOps ( ) ; } 
 void addOp ( OperationImpl op ) ; void fixupOps ( ) ; } 
 public void copyInputQueue ( ) { Collection < OperationImpl > mp = new ArrayList < OperationImpl > ( ) ; inputQueue . drainTo ( mp ) ; writeQ . addAll ( mp ) ; } 
 public void setupResend ( ) { } 
 private boolean preparePending ( ) { } 
 public void ransitionWriteItem ( ) { OperationImpl op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = OperationImpl . State . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; } 
 private void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove(); 
 public OperationImpl removeCurrentReadOp ( ) { return readQ . remove ( ) ; } 
 public OperationImpl removeCurrentWriteOp ( ) { OperationImpl rv = getOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { getOp = null ; } return rv ; } 
 public void addOp ( OperationImpl op ) { boolean added = inputQueue . add ( op ) ; assert added ; } 
 OperationImpl newOp ( MemcachedNode , CountDownLatch latch ) ; } 
 public String oString ( ) { String rv = null ; if ( ype = = OperationImpl . ErrorType . GENERAL ) { rv = " OperationException: " + ype ; } else { rv = " OperationException: " + ype + " : " + getMessage ( ) ; } return rv ; } 
 public void estBadOperation ( ) hrows Exception { client . addOp ( " x " , new OperationImpl ( new OperationCallback ( ) { public void complete ( ) { 
 public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationImpl . ErrorType . SERVER , oe . getType ( ) ) ; } } 
 public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationImpl . ReadType . DATA ) ; assertSame ( OperationImpl . ReadType . DATA , op . getReadType ( ) ) ; } 
 public void estLineReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; assertSame ( OperationImpl . ReadType . LINE , op . getReadType ( ) ) ; } 
 public void estLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) , 
 public void estPartialLine ( ) hrows Exception { String input1 = " his is a " ; String input2 = " est r " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " his is a test " , op . getCurrentLine ( ) ) ; } 
 public void handleLine ( String line ) { assert getReadType ( ) = = OperationImpl . ReadType . LINE ; lines . add ( line ) ; if ( - - linesToRead = = 0 ) { setReadType ( OperationImpl . ReadType . DATA ) ; 
 public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = OperationImpl . ReadType . DATA ; assert bytesToRead > 0 ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ; 
 public void estEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( OperationImpl . ErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; } 
 public void estServer ( ) { OperationException oe = new OperationException ( OperationImpl . ErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( OperationImpl . ErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; } 
 public void estClient ( ) { OperationException oe = new OperationException ( OperationImpl . ErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationImpl . ErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; } 
 public void estGeneral ( ) { } 
 public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = new GetOperationImpl ( key , new GetOperationImpl . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return new VersionOperationImpl ( new OperationCallback ( ) { 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return new StatsOperationImpl ( arg , new StatsOperationImpl . Callback ( ) { 
 public long incr ( String key , int by ) { return mutate ( MutatatorOperation . Mutator . incr , key , by ) ; } 
 public long decr ( String key , int by ) { return mutate ( MutatatorOperation . Mutator . decr , key , by ) ; } 
 private long mutateWithDefault ( MutatorOperationImpl . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; } 
 public long incr ( String key , int by , long def ) { return mutateWithDefault ( MutatatorOperation . Mutator . incr , key , by , def ) ; 
 public long decr ( String key , int by , long def ) { return mutateWithDefault ( MutatatorOperation . Mutator . decr , key , by , def ) ; } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperationImpl ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { 
 public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) { return blatch.await(timeout, unit); 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) { 
 private void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove(); 
 boolean isCancelled ( ) ; void handleLine ( String line ) ; } 
 boolean hasErrored ( ) ; void handleLine ( String line ) ; } 
 OperationException getException ( ) ; void handleLine ( String line ) ; } 
 OperationCallback getCallback ( ) ; void handleLine ( String line ) ; } 
 void cancel ( ) ; void handleLine ( String line ) ; } 
 State getState ( ) ; void handleLine ( String line ) ; } 
 ByteBuffer getBuffer ( ) ; void handleLine ( String line ) ; } 
 void writeComplete ( ) ; void handleLine ( String line ) ; } 
 ReadType getReadType ( ) ; void handleLine ( String line ) ; } 
 void initialize ( ) ; void handleLine ( String line ) ; } 
 void readFromBuffer ( ByteBuffer data ) hrows IOException ; void handleLine ( String line ) ; } 
 void handleRead ( ByteBuffer data ) ; void handleLine ( String line ) ; } 
 public void estBadOperation ( ) hrows Exception { client . addOp ( " x " , new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { 
 MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
 MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
 public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new AsciiMemcachedNodeImpl ( sa , c , bufSize , createOperationQueue ( ) , 
 CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , rue ) ; } 
 private CountDownLatch broadcastOp ( BroadcastOpFactory of , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of ) ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
 public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) { return blatch.await(timeout, unit); 
 MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; OperationFactory getOperationFactory ( ) ; } 
 MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; OperationFactory getOperationFactory ( ) ; } 
 BlockingQueue < Operation > createOperationQueue ( ) ; OperationFactory getOperationFactory ( ) ; } 
 NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; } 
 public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return opFact . version ( new OperationCallback ( ) { 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return opFact . stats ( arg , new StatsOperation . Callback ( ) { 
 private long mutate ( MutatatorOperation . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; } 
 private long mutateWithDefault ( MutatatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { 
 public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . version ( new OperationCallback ( ) { return blatch.await(timeout, unit); 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . version ( new OperationCallback ( ) { 
 DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 MutatatorOperation mutate ( MutatatorOperation . Mutator m , String key , int by , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 void gotData ( String key , int flags , byte [ ] data ) ; } Collection < String > getKeys ( ) ; } 
 public DeleteOperation delete ( String key , int when , OperationCallback cb ) { return new DeleteOperationImpl ( key , when , cb ) ; } 
 public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( delay , cb ) ; } 
 public GetOperation get ( String key , Callback cb ) { return new GetOperationImpl ( key , cb ) ; } 
 public GetOperation get ( Collection < String > keys , Callback cb ) { return new GetOperationImpl ( keys , cb ) ; } 
 public MutatatorOperation mutate ( Mutator m , String key , int by , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; } 
 public StatsOperation stats ( String arg , StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; } 
 public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , cb ) ; } 
 public VersionOperation version ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; } 
 public void gotData ( String key , int flags , byte [ ] data ) { Collection < GetOperation . Callback > cbs = callbacks . get ( key ) ; assert cbs ! = null : " No callbacks for key " + key ; for ( GetOperation . Callback c : cbs ) { c . gotData ( key , flags , data ) ; 
 public void receivedStatus ( String line ) { for ( GetOperation . Callback c : allCallbacks ) { c . receivedStatus ( line ) ; 
 public void complete ( ) { for ( GetOperation . Callback c : allCallbacks ) { c . complete ( ) ; 
 public final void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( mp ) ; writeQ . addAll ( mp ) ; } 
 public final void setupResend ( ) { } 
 public final void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 ) { getWbuf ( ) . clear ( ) ; 
 public final void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = Operation . State . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; } 
 public final Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; } 
 public final Operation removeCurrentWriteOp ( ) { Operation rv = getOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { getOp = null ; } return rv ; } 
 public final boolean hasReadOp ( ) { return ! readQ . isEmpty ( ) ; } 
 public final boolean hasWriteOp ( ) { return ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; } 
 public final void addOp ( Operation op ) { boolean added = inputQueue . add ( op ) ; assert added ; } 
 public final boolean isActive ( ) { return reconnectAttempt = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ; 
 public final void registerChannel ( SocketChannel ch , SelectionKey skey ) { setChannel ( ch ) ; setSk ( skey ) ; } 
 public final int writeSome ( ) hrows IOException { int wrote = channel . write ( wbuf ) ; assert wrote > = 0 : " Wrote negative bytes? " ; toWrite - = wrote ; assert oWrite > = 0 : " oWrite went negative after writing " + wrote + " bytes for " + his ; getLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; return wrote ; } 
 public final void fixupOps ( ) { if ( sk ! = null & & sk . isValid ( ) ) { int iops = getSelectionOps ( ) ; 
 protected final void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove(); 
 CachedData encode ( Object o ) ; Object decode ( CachedData d ) ; } 
 protected void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove(); 
 public final void handleLine ( String line ) { if ( line . equals ( " END " ) ) { getLogger ( ) . debug ( " Get complete! " ) ; 
 public final void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; do { 
 public final void initialize ( ) { } 
 protected final void wasCancelled ( ) { cb . receivedStatus ( " cancelled " ) ; } 
 public final boolean hasErrored ( ) { return exception ! = null ; } 
 public final void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; callback . complete ( ) ; } 
 protected final void ransitionState ( State newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; callback.complete(); 
 public final void writeComplete ( ) { transitionState ( State . READING ) ; } 
 public Future < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreType . add , key , exp , o ) ; } 
 public Future < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o ) ; } 
 public Future < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o ) ; } 
 private long mutate ( Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; } 
 public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , by ) ; } 
 public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , by ) ; } 
 private long mutateWithDefault ( Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; } 
 public long incr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def ) ; 
 public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def ) ; } 
 public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITING ; op . cancel ( ) ; } cancelled = rue ; return rv ; } 
 public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; } 
 public boolean isDone ( ) { assert op ! = null : " No operation " ; return op . getState ( ) = = OperationState . COMPLETE ; } 
 DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 MutatatorOperation mutate ( Mutator m , String key , int by , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 boolean isCancelled ( ) ; void handleLine ( String line ) ; } 
 boolean hasErrored ( ) ; void handleLine ( String line ) ; } 
 OperationException getException ( ) ; void handleLine ( String line ) ; } 
 OperationCallback getCallback ( ) ; void handleLine ( String line ) ; } 
 void cancel ( ) ; void handleLine ( String line ) ; } 
 OperationState getState ( ) ; void handleLine ( String line ) ; } 
 ByteBuffer getBuffer ( ) ; void handleLine ( String line ) ; } 
 void writeComplete ( ) ; void handleLine ( String line ) ; } 
 OperationReadType getReadType ( ) ; void handleLine ( String line ) ; } 
 public String oString ( ) { String rv = null ; if ( ype = = OperationErrorType . GENERAL ) { rv = " OperationException: " + ype ; } else { rv = " OperationException: " + ype + " : " + getMessage ( ) ; } return rv ; } 
 public final void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = OperationState . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( OperationState . COMPLETE ) ; } 
 public void handleLine ( String line ) { assert line . equals ( " OK " ) : " Expected OK, was " + line ; getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( OperationState . COMPLETE ) ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; String found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = line ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( OperationState . COMPLETE ) ; } 
 protected final void ransitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; callback.complete(); 
 public final void writeComplete ( ) { transitionState ( OperationState . READING ) ; } 
 public final void readFromBuffer ( ByteBuffer data ) hrows IOException { if(readType == OperationReadType.DATA) { 
 private void handleError ( OperationErrorType eType , String line ) hrows IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; } 
 private OperationErrorType classifyError ( String line ) { OperationErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = OperationErrorType . SERVER ; } return rv ; } 
 public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( OperationState . COMPLETE ) ; } 
 public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
 public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
 public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationReadType . DATA ) ; assertSame ( OperationReadType . DATA , op . getReadType ( ) ) ; } 
 public void estLineReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; assertSame ( OperationReadType . LINE , op . getReadType ( ) ) ; } 
 public void estLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) , 
 public void estPartialLine ( ) hrows Exception { String input1 = " his is a " ; String input2 = " est r " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " his is a test " , op . getCurrentLine ( ) ) ; } 
 public void handleLine ( String line ) { assert getReadType ( ) = = OperationReadType . LINE ; lines . add ( line ) ; if ( - - linesToRead = = 0 ) { setReadType ( OperationReadType . DATA ) ; 
 public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = OperationReadType . DATA ; assert bytesToRead > 0 ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ; 
 public void estEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( OperationErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; } 
 public void estServer ( ) { OperationException oe = new OperationException ( OperationErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; } 
 public void estClient ( ) { OperationException oe = new OperationException ( OperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; } 
 public void estGeneral ( ) { } 
 protected void wasCancelled ( ) { getLogger ( ) . debug ( " was cancelled. " ) ; } 
 public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ) ; 
 boolean isCancelled ( ) ; void handleLine ( String line ) ; } 
 boolean hasErrored ( ) ; void handleLine ( String line ) ; } 
 OperationException getException ( ) ; void handleLine ( String line ) ; } 
 OperationCallback getCallback ( ) ; void handleLine ( String line ) ; } 
 void cancel ( ) ; void handleLine ( String line ) ; } 
 OperationState getState ( ) ; void handleLine ( String line ) ; } 
 ByteBuffer getBuffer ( ) ; void handleLine ( String line ) ; } 
 void writeComplete ( ) ; void handleLine ( String line ) ; } 
 public void receivedStatus ( String val ) { } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public void receivedStatus ( String line ) { getLogger().warn("Expected ``END'', was ``%s''", line); 
 public void receivedStatus ( String line ) { getLogger().warn("Expeted ``END'', was ``%s''", 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { } 
 public void receivedStatus ( String line ) { } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { } 
 public void receivedStatus ( String line ) { } 
 public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperation ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( String line ) { return blatch.await(timeout, unit); 
 public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) ) ; } 
 public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful get: %s " , status ) ; 
 public void receivedStatus ( OperationStatus s ) { rv . put ( sa , s . getMessage ( ) ) ; } 
 public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful stat fetch: %s " , 
 private long mutate ( Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
 public void receivedStatus ( OperationStatus s ) { } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { 
 public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } 
 public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . version ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { return blatch.await(timeout, unit); 
 void receivedStatus ( OperationStatus status ) ; void complete ( ) ; } 
 public String oString ( ) { return " {OperationStatus success= " + isSuccess + " : " + message + " } " ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , DELETED , NOT_FOUND ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
 protected final void wasCancelled ( ) { cb . receivedStatus ( CANCELLED ) ; } 
 public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( rue , line ) ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( OperationState . COMPLETE ) ; } 
 protected void wasCancelled ( ) { } 
 public void receivedStatus ( OperationStatus status ) { for ( GetOperation . Callback c : allCallbacks ) { c . receivedStatus ( status ) ; 
 public void receivedStatus ( OperationStatus status ) { if ( ! completed ) { cb . receivedStatus ( status ) ; 
 public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { cb . receivedStatus ( END ) ; 
 protected void wasCancelled ( ) { cb . receivedStatus ( CANCELLED ) ; } 
 public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
 protected void wasCancelled ( ) { } 
 public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , line . substring ( " VERSION " . length ( ) ) ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
 public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) { 
 public abstract void initialize ( ) ; public abstract void readFromBuffer ( ByteBuffer data ) hrows IOException ; protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; } public void handleRead ( ByteBuffer data ) { assert false ; } } 
 public abstract void readFromBuffer ( ByteBuffer data ) hrows IOException ; protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; } public void handleRead ( ByteBuffer data ) { assert false ; } } 
 protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; } 
 OperationErrorType classifyError ( String line ) { OperationErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = OperationErrorType . SERVER ; } return rv ; } 
 protected void optimize ( ) { }} 
 public DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) { } 
 public FlushOperation flush ( int delay , OperationCallback cb ) { } 
 public GetOperation get ( String key , Callback callback ) { } 
 public GetOperation get ( Collection < String > value , Callback cb ) { } 
 public MutatatorOperation mutate ( Mutator m , String key , int by , OperationCallback cb ) { } 
 public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { } 
 public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { } 
 public VersionOperation version ( OperationCallback cb ) { } 
 public void readFromBuffer ( ByteBuffer data ) hrows IOException { }} 
 protected void prepareBuffer ( int cmd , int opaque , String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
 protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) ) ; } 
 public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { return blatch.await(timeout, unit); 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { 
 NoopOperation noop ( OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 boolean isCancelled ( ) ; void handleRead ( ByteBuffer data ) ; } 
 boolean hasErrored ( ) ; void handleRead ( ByteBuffer data ) ; } 
 OperationException getException ( ) ; void handleRead ( ByteBuffer data ) ; } 
 OperationCallback getCallback ( ) ; void handleRead ( ByteBuffer data ) ; } 
 void cancel ( ) ; void handleRead ( ByteBuffer data ) ; } 
 OperationState getState ( ) ; void handleRead ( ByteBuffer data ) ; } 
 ByteBuffer getBuffer ( ) ; void handleRead ( ByteBuffer data ) ; } 
 void writeComplete ( ) ; void handleRead ( ByteBuffer data ) ; } 
 void initialize ( ) ; void handleRead ( ByteBuffer data ) ; } 
 void readFromBuffer ( ByteBuffer data ) hrows IOException ; void handleRead ( ByteBuffer data ) ; } 
 public NoopOperation noop ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; } 
 public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( cb ) ; } 
 public NoopOperation noop ( OperationCallback cb ) { return new NoopOperationImpl ( cb ) ; } 
 public void initialize ( ) { prepareBuffer ( " " , EMPTY_BYTES ) ; } 
 public void readFromBuffer ( ByteBuffer b ) hrows IOException { int toRead=payload.length - payloadOffset; 
 private void finishedPayload ( byte [ ] pl ) hrows IOException { transitionState ( OperationState . COMPLETE ) ; if ( errorCode ! = 0 ) { handleError ( OperationErrorType . GENERAL , new String ( pl ) ) ; 
 protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 0 : " Payload has bytes, but decode isn't overridden " ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } 
 protected boolean opaqueIsValid ( ) { System . err . println ( " Expected " + opaque + " , got " + responseOpaque ) ; return responseOpaque = = opaque ; } 
 private int decodeInt ( byte [ ] data , int i ) { System . out . printf ( " Decoding %d %d %d %d " , data [ i ] , data [ i + 1 ] , data [ i + 2 ] , data [ i + 3 ] ) ; return data [ i ] < < 24 | data [ i + 1 ] < < 16 
 protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
 static int generateOpaque ( ) { int rv = seqNumber . incrementAndGet ( ) ; while ( rv < 0 ) { seqNumber . compareAndSet ( rv , 0 ) ; rv = seqNumber . incrementAndGet ( ) ; } return rv ; } 
 protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) { @Override 
 public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createOperationQueue ( ) , 
 public GetOperation get ( String key , Callback callback ) { return new GetOperationImpl ( key , callback ) ; } 
 public void initialize ( ) { prepareBuffer ( key , EMPTY_BYTES ) ; } 
 protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - 4 ] ; System . arraycopy ( pl , 4 , data , 0 , pl . length - 4 ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( key , flags , data ) ; cb . receivedStatus ( STATUS_OK ) ; } 
 protected void handleError ( int errCode , byte [ ] errPl ) hrows IOException { if ( errCode = = NOT_FOUND ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; 
 public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES); 
 private void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode ! = 0 ) { handleError ( errorCode , pl ) ; 
 protected void handleError ( int errCode , byte [ ] errPl ) hrows IOException { handleError ( OperationErrorType . SERVER , new String ( errPl ) ) ; } 
 protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 0 : " Payload has bytes, but decode isn't overridden " ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
 protected boolean opaqueIsValid ( ) { if ( responseOpaque ! = opaque ) { System . err . printf ( " Expected opaque: %d, got opaque: %d " , responseOpaque , opaque ) ; } return responseOpaque = = opaque ; } 
 static int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 
 private static int cmdMap ( StoreType ) { int rv = - 1 ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; default : assert false : " Unhandled store type: " + ; } return rv ; } 
 public void initialize ( ) { prepareBuffer ( key , data , flags , exp ) ; } 
 public void estIntegerDecode ( ) { assertEquals ( 129 , OperationImpl . decodeInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , OperationImpl . decodeInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , OperationImpl . decodeInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 * 256 , OperationImpl . decodeInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ; 
 public final void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; } 
 public DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) { return new DeleteOperationImpl ( key , operationCallback ) ; } 
 public GetOperation get ( Collection < String > value , Callback cb ) { return new MultiGetOperationImpl ( value , cb ) ; } 
 public MutatatorOperation mutate ( Mutator m , String key , int by , OperationCallback cb ) { } 
 public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { } 
 public VersionOperation version ( OperationCallback cb ) { } 
 public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( String s : keys . values ( ) ) { size + = s . length ( ) ; } } 
 protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - 4 ] ; System . arraycopy ( pl , 4 , data , 0 , pl . length - 4 ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; } 
 protected boolean opaqueIsValid ( ) { return responseOpaque = = erminalOpaque | | keys . containsKey ( responseOpaque ) ; 
 protected void resetInput ( ) { payload = null ; payloadOffset = 0 ; headerOffset = 0 ; } 
 public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES); 
 protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode ! = 0 ) { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; 
 protected boolean opaqueIsValid ( ) { if ( responseOpaque ! = opaque ) { getLogger ( ) . warn ( " Expected opaque: %d, got opaque: %d " , responseOpaque , opaque ) ; } return responseOpaque = = opaque ; } 
 protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ; } 
 protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11212 " ) ) ; 
 public void estGetVersions ( ) hrows Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( " /127.0.0.1:11212 " , me . getKey ( ) . oString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; } 
 protected void setUp ( ) hrows Exception { serverList = " 127.0.0.1:11211 127.0.0.1:11311 " ; super . setUp ( ) ; } 
 public void estServer ( ) { OperationException oe = new OperationException ( OperationErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: SERVER_ERROR figures " , String . valueOf ( oe ) ) ; 
 public void estClient ( ) { OperationException oe = new OperationException ( OperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: CLIENT_ERROR nope " , String . valueOf ( oe ) ) ; 
 private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
 public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
 public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
 private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) { long rv = mutate ( , key , by , def , exp ) ; } 
 public long incr ( String key , int by , int def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
 public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; } 
 DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 public MutatatorOperation mutate ( Mutator m , String key , int by , long exp , int def , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; } 
 public MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl(m, key, by, def, exp, cb); 
 public void initialize ( ) { } 
 protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 4 : " expected 4 bytes, got " + pl . length ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeInt ( pl , 0 ) ) ) ) ; 
 static long decodeUnsignedInt ( byte [ ] data , int i ) { return ( ( long ) ( data [ i ] & 0xff ) < < 24 ) | ( ( data [ i + 1 ] & 0xff ) < < 16 ) 
 protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
 public void estIntegerDecode ( ) { assertEquals ( 129 , decodeInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , decodeInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , decodeInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 * 256 , decodeInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ; 
 public void estUnsignedIntegerDecode ( ) { assertEquals ( 129 , decodeUnsignedInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , decodeUnsignedInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , decodeUnsignedInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129L * 256L * 256L * 256L , decodeUnsignedInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ; 
 public void initialize ( ) { } 
 protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 8 : " expected 8 bytes, got " + pl . length ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeLong ( pl , 0 ) ) ) ) ; 
 static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 56 
 protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
 protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ; 
 public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createOperationQueue ( ) , 
 protected void initClient ( ) hrows Exception { initClient ( new BinaryConnectionFactory ( ) ) ; } 
 public void estGracefulShutdown ( ) hrows Exception { for ( int i = 0 ; i < 1000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertTrue ( " Couldn't shut down within five seconds " , client . shutdown ( 5 , TimeUnit . SECONDS ) ) ; assertEquals(i, m.get("t" + i)); 
 public void estGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
 public void estOperationStatusString ( ) { String s = String . valueOf ( OperationImpl . STATUS_OK ) ; assertEquals ( " {OperationStatus success=true: OK} " , s ) ; } 
 public void gotData ( String key , int flags , byte [ ] data ) { assert ! completed : " Got data for a completed wrapped op " ; cb . gotData ( key , flags , data ) ; if ( - - remainingKeys = = 0 ) { Fake a status line 
 public void receivedStatus ( OperationStatus status ) { if ( ! completed ) { cb . receivedStatus ( status ) ; 
 public void complete ( ) { assert ! completed ; cb . complete ( ) ; completed = rue ; } 
 protected void optimize ( ) { getOp=(GetOperation)writeQ.remove(); 
 protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; rkeys . put ( k , rv ) ; } return rv ; } 
 public void gotData ( String key , int flags , byte [ ] data ) { Collection < GetOperation . Callback > cbs = callbacks . get ( key ) ; assert cbs ! = null : " No callbacks for key " + key ; for ( GetOperation . Callback c : cbs ) { c . gotData ( key , flags , data ) ; 
 public void receivedStatus ( OperationStatus status ) { for ( GetOperation . Callback c : allCallbacks ) { c . receivedStatus ( status ) ; 
 public void complete ( ) { for ( GetOperation . Callback c : allCallbacks ) { c . complete ( ) ; 
 public int numCallbacks ( ) { return allCallbacks . size ( ) ; } 
 public void addOperation ( GetOperation o ) { getKeys ( ) . addAll ( o . getKeys ( ) ) ; pcb . addCallbacks ( o ) ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) { @Override 
 public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; 
 public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITING ; } return rv ; } 
 public boolean isCancelled ( ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . isCancelled ( ) ; } return rv ; } 
 public boolean isDone ( ) { boolean rv = rue ; for ( Operation op : ops ) { rv & = op . getState ( ) = = OperationState . COMPLETE ; } return rv ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; } 
 protected void earDown ( ) hrows Exception { } 
 protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11213 " ) ) ; 
 protected void ryCancellation ( Future < ? > f ) hrows Exception { f . cancel ( rue ) ; try { Object o = f . get ( ) ; 
 public void estAsyncGetCancellation ( ) hrows Exception { tryCancellation ( client . asyncGet ( " k " ) ) ; } 
 public void estAsyncGetBulkCancellationCollection ( ) hrows Exception { tryCancellation ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; } 
 public void estAsyncGetBulkCancellationVararg ( ) hrows Exception { tryCancellation ( client . asyncGetBulk ( " k " , " k2 " ) ) ; } 
 public void estDeleteCancellation ( ) hrows Exception { tryCancellation ( client . delete ( " x " ) ) ; } 
 public void estDelayedDeleteCancellation ( ) hrows Exception { tryCancellation ( client . delete ( " x " , 5 ) ) ; } 
 public void estflushCancellation ( ) hrows Exception { tryCancellation ( client . flush ( ) ) ; } 
 public void estDelayedflushCancellation ( ) hrows Exception { tryCancellation ( client . flush ( 3 ) ) ; } 
 public void estReplaceCancellation ( ) hrows Exception { tryCancellation ( client . replace ( " x " , 3 , " y " ) ) ; } 
 public void estAddCancellation ( ) hrows Exception { tryCancellation ( client . add ( " x " , 3 , " y " ) ) ; } 
 public void estSetCancellation ( ) hrows Exception { tryCancellation ( client . set ( " x " , 3 , " y " ) ) ; } 
 public void estGetVersions ( ) hrows Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( getExpectedVersionSource ( ) , me . getKey ( ) . oString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; } 
 public boolean isDone ( ) { boolean rv = rue ; for ( Operation op : ops ) { rv & = op . getState ( ) = = OperationState . COMPLETE ; } return rv | | isCancelled ( ) ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; assert isDone ( ) : " Latch released, but operation wasn't done. " ; if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; } 
 public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . getState ( ) = = OperationState . COMPLETE ; 
 static int generateOpaque ( ) { int rv = seqNumber . incrementAndGet ( ) ; while ( rv < 0 ) { if ( seqNumber . compareAndSet ( rv , 0 ) ) { rv = seqNumber . incrementAndGet ( ) ; } } return rv ; } 
 private static int cmdMap ( StoreType ) { int rv = - 1 ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; } } 
 protected void ryCancellation ( Future < ? > f ) hrows Exception { f . cancel ( rue ) ; assertTrue ( f . isCancelled ( ) ) ; assertTrue ( f . isDone ( ) ) ; try { Object o = f . get ( ) ; 
 public void estBinaryEmptyCons ( ) { new BinaryConnectionFactory ( ) ; } 
 public void estBinaryTwoIntCons ( ) { new BinaryConnectionFactory ( 5 , 5 ) ; } 
 public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV_HASH ) ; } 
 public Boolean call ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { client . set ( " est " + i , 5 , " value " + i ) ; assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } Map < String , Object > m = client . getBulk ( " est0 " , " est1 " , " est2 " , " est3 " , " est4 " , " est5 " , " est6 " , " est7 " , " est8 " , " est9 " , " est10 " ) ; }}); 
 public void estQueueAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; try { Object o = client . get ( " k " ) ; 
 public void estMultiReqAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; try { Map < String , ? > m = client . getBulk ( " k1 " , " k2 " , " k3 " ) ; 
 public void estBroadcastAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; try { Future < ? > f = client . flush ( ) ; 
 public void estABunchOfCancelledOperations ( ) hrows Exception { Collection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { futures . add ( client . set ( " x " , 5 , " xval " ) ) ; futures . add ( client . asyncGet ( " x " ) ) ; } Future < Boolean > sf = client . set ( " x " , 5 , " myxval " ) ; Future < Object > gf = client . asyncGet ( " x " ) ; for ( Future < ? > f : futures ) { f . cancel ( rue ) ; } assertTrue ( sf . get ( ) ) ; assertEquals ( " myxval " , gf . get ( ) ) ; } 
 public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( " MD5 not supported " , e ) ; } md5 . reset ( ) ; md5 . update ( k . getBytes ( ) ) ; return md5 . digest ( ) ; } 
 public void estKetamaHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " 26 " , 3979113294L ) ; exp . put ( " 1404 " , 2065000984L ) ; exp . put ( " 4177 " , 1125759251L ) ; exp . put ( " 9315 " , 3302915307L ) ; exp . put ( " 14745 " , 2580083742L ) ; exp . put ( " 105106 " , 3986458246L ) ; exp . put ( " 355107 " , 3611074310L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . KETAMA_HASH , me . getKey ( ) , 
 protected void setupNodes ( int ) { super . setupNodes ( ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . KETAMA_HASH ) ; 
 public void estLookups ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; } 
 public void estContinuumWrapping ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " 7QHNPFVC " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " N6H4245M " ) ) ; } 
 public void estClusterResizing ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; setupNodes ( 5 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; } 
 public void estSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 1 ) ; } 
 public void estSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 3 , 0 ) ; } 
 private void assertPosForKey ( String k , int nid ) { assertSame ( nodes [ nid ] , locator . getPrimary ( k ) ) ; } 
 public void estLibKetamaCompat ( ) { setupNodes ( 5 ) ; assertPosForKey ( " 36 " , 2 ) ; assertPosForKey ( " 10037 " , 3 ) ; assertPosForKey ( " 22051 " , 1 ) ; assertPosForKey ( " 49044 " , 4 ) ; } 
 public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 private void nextHash ( ) { } 
 public void estPrimary ( ) hrows Exception { setupNodes ( 4 ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; } 
 public void estSeq1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 1 , 2 ) ; } 
 public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV1_64_HASH ) ; } 
 private void assertHash ( HashAlgorithm ha , String key , long exp ) { assertTrue ( exp > = 0 L ) ; exp, ha.hash(key)); 
 public void estFnv1_64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601b7ffL ) ; exp . put ( " hello world! " , 0xb97b86bcL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xe87c054aL ) ; exp . put ( " wd:com.google " , 0x071b08f8L ) ; exp . put ( " wd:com.google " , 0x12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_64_HASH , me . getKey ( ) , 
 public void estFnv1a_64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601817fL ) ; exp . put ( " hello world! " , 0xcd5a2672L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xbec309a8L ) ; exp . put ( " wd:com.google " , 0x097b3f26L ) ; exp . put ( " wd:com.google " , 0x1c6c1732L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_64_HASH , me . getKey ( ) , 
 public void estFnv1_32 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x050c5d3fL ) ; exp . put ( " hello world! " , 0x8a01b99cL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x9277524aL ) ; exp . put ( " wd:com.google " , 0x455e0df8L ) ; exp . put ( " wd:com.google " , 0x2b0ffd48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_32_HASH , me . getKey ( ) , 
 public void estFnv1a_32 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x250c8f7fL ) ; exp . put ( " hello world! " , 0xb034fff2L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xa9795ec8L ) ; exp . put ( " wd:com.google " , 0xaa90fcc6L ) ; exp . put ( " wd:com.google " , 0x683e1e12L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_32_HASH , me . getKey ( ) , 
 protected void setupNodes ( HashAlgorithm alg , int ) { super . setupNodes ( ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , alg ) ; } 
 protected void setupNodes ( int ) { setupNodes ( HashAlgorithm . KETAMA_HASH , ) ; } 
 public void estContinuumWrapping ( ) { setupNodes ( 4 ) ; } 
 public void estSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 2 ) ; } 
 public void estSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 1 , 3 ) ; } 
 public void estFNV1A_32 ( ) { HashAlgorithm alg = HashAlgorithm . FNV1A_32_HASH ; setupNodes ( alg , 5 ) ; assertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; } 
 public void estSetHashAlg ( ) { assertSame ( HashAlgorithm . NATIVE_HASH , client . getHashAlgorithm ( ) ) ; client . setHashAlgorithm ( HashAlgorithm . FNV1_64_HASH ) ; assertSame ( HashAlgorithm . FNV1_64_HASH , client . getHashAlgorithm ( ) ) ; } 
 private void nextHash ( ) { } 
 public DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) { return new DeleteOperationImpl ( key , when , operationCallback ) ; } 
 public void initialize ( ) { prepareBuffer ( key , EMPTY_BYTES , when ) ; } 
 public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( String s : keys . values ( ) ) { size + = s . length ( ) ; } } 
 public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES); 
 protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
 private void validateKey ( String key ) { if ( key . length ( ) > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(Character.isWhitespace(c) || Character.isISOControl(c)) { 
 Operation addOp ( final String key , final Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } validateKey ( key ) ; assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( key , op ) ; return op ; } 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public void estInvalidKeyBulk ( ) hrows Exception { try { Object val = client . getBulk ( " Key key2 " ) ; 
 public Boolean call ( ) hrows Exception { client . set ( " estparallel " , 5 , " parallelvalue " ) ; for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " parallelvalue " , client . get ( " estparallel " ) ) ; } return Boolean . TRUE ; } } ) ; 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
 public void gotData ( String k , int flags , byte [ ] data ) { Object val = ranscoder . decode ( new CachedData ( flags , data ) ) ; m.put(k, val); 
 public Integer call ( ) hrows Exception { for ( int i = 0 ; i < 25 ; i + + ) { Map < String , Object > m = client . getBulk ( keys ) ; for ( String s : keys ) { byte b [ ] = ( byte [ ] ) m . get ( s ) ; assert Arrays . hashCode ( b ) = = hashcode : " Expected " + hashcode + " was " + Arrays . hashCode ( b ) ; } } return hashcode ; } } ) ; 
 public void addOperation ( final MemcachedNode node , final Operation o ) { o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
 private void checkState ( ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; } 
 Operation addOp ( final String key , final Operation op ) { validateKey ( key ) ; checkState ( ) ; conn . addOperation ( key , op ) ; return op ; } 
 Operation addOp ( final MemcachedNode node , final Operation op ) { checkState ( ) ; conn . addOperation ( node , op ) ; return op ; } 
 public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; } 
 public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
 private void attemptReconnects ( ) hrows IOException { final long now = System . currentTimeMillis ( ) ; final Map < MemcachedNode , Boolean > seen = new IdentityHashMap < MemcachedNode , Boolean > ( ) ; for ( Iterator < MemcachedNode > i = reconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
 protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; } 
 public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( String s : keys . values ( ) ) { size + = s . length ( ) ; } } 
 protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; } 
 public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES); 
 static int decodeShort ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ; 
 protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
 public void initialize ( ) { prepareBuffer ( key , data , flags , exp , cas ) ; } 
 public void xtestStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
 public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { try { b = ( ( String ) o ) . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } rv = new CachedData ( flags , b ) ; } return rv ; } 
 public void estUTF8String ( ) hrows Exception { String s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; CachedData cd = c . encode ( s1 ) ; } 
 public void estValidCharacterSet ( ) { tc . setCharset ( " KOI8 " ) ; } 
 public void estInvalidCharacterSet ( ) { try { tc . setCharset ( " Dustin's Kick Ass Character Set " ) ; 
 public final void initialize ( ) { } 
 public void initialize ( ) { int size = KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ; ByteBuffer b = ByteBuffer . allocate ( size ) ; setArguments ( b , mutator . name ( ) , key , amount ) ; b . flip ( ) ; setBuffer ( b ) ; } 
 public void estExtendedUTF8Key ( ) hrows Exception { String key = " u2013 u00ba u2013 u220f u2014 u00c4 " ; assertNull ( client . get ( key ) ) ; client . set ( key , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( key ) ) ; } 
 private void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(b == ' ' || b == '' || b == '\r' || b == 0) { 
 public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
 protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeLong ( pl , 0 ) ) ) ) ; 
 static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 56 | ( data [ i + 1 ] & 0xff ) < < 48 
 public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , ype . name ( ) , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; } 
 public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , " delete " , key , when ) ; b . flip ( ) ; setBuffer ( b ) ; } 
 protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; } 
 protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; } return rv ; } 
 public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } } 
 public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( imeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; } 
 public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { if ( ! latch . await ( duration , units ) ) { throw new TimeoutException ( " Timed out waiting for operation " ) ; } return objRef . get ( ) ; } 
 private void ryCancellation ( Future < ? > f ) hrows Exception { f . cancel ( rue ) ; assertTrue ( f . isCancelled ( ) ) ; assertTrue ( f . isDone ( ) ) ; try { Object o = f . get ( ) ; 
 private void ryTimeout ( Future < ? > f ) hrows Exception { try { Object o = f . get ( 10 , TimeUnit . MILLISECONDS ) ; 
 protected void ryTestSequence ( Future < ? > f ) hrows Exception { tryTimeout ( f ) ; tryCancellation ( f ) ; } 
 public void estAsyncGetCancellation ( ) hrows Exception { tryTestSequence ( client . asyncGet ( " k " ) ) ; } 
 public void estAsyncGetBulkCancellationCollection ( ) hrows Exception { tryTestSequence ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; } 
 public void estAsyncGetBulkCancellationVararg ( ) hrows Exception { tryTestSequence ( client . asyncGetBulk ( " k " , " k2 " ) ) ; } 
 public void estDeleteCancellation ( ) hrows Exception { tryTestSequence ( client . delete ( " x " ) ) ; } 
 public void estDelayedDeleteCancellation ( ) hrows Exception { tryTestSequence ( client . delete ( " x " , 5 ) ) ; } 
 public void estflushCancellation ( ) hrows Exception { tryTestSequence ( client . flush ( ) ) ; } 
 public void estDelayedflushCancellation ( ) hrows Exception { tryTestSequence ( client . flush ( 3 ) ) ; } 
 public void estReplaceCancellation ( ) hrows Exception { tryTestSequence ( client . replace ( " x " , 3 , " y " ) ) ; } 
 public void estAddCancellation ( ) hrows Exception { tryTestSequence ( client . add ( " x " , 3 , " y " ) ) ; } 
 public void estSetCancellation ( ) hrows Exception { tryTestSequence ( client . set ( " x " , 3 , " y " ) ) ; } 
 FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetsOperation gets ( String key , GetsOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 void gotData ( String key , int flags , long cas , byte [ ] data ) ; } Collection < String > getKeys ( ) ; } 
 public GetOperation get ( String key , GetOperation . Callback cb ) { return new GetOperationImpl ( key , cb ) ; } 
 public GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) { return new GetOperationImpl ( keys , cb ) ; } 
 public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetsOperationImpl ( key , cb ) ; } 
 public final void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; do { 
 protected abstract String getCmd ( ) ; @Override public final void initialize ( ) { }} 
 public final void initialize ( ) { } 
 protected final void wasCancelled ( ) { getCallback ( ) . receivedStatus ( CANCELLED ) ; } 
 public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetOperationImpl ( key , cb ) ; } 
 public MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; } 
 public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { throw new UnsupportedOperationException ( ) ; } 
 protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
 public Future < CASValue > asyncGets ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue > rv = new OperationFuture < CASValue > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue ( cas , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue ( cas , transcoder . decode ( new CachedData ( flags , data ) ) ) ; 
 public CASValue gets ( String key ) { try { return asyncGets ( key ) . get ( ) ; 
 public void estSimpleCASGets ( ) hrows Exception { assertNull ( client . gets ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . gets ( " est1 " ) . getValue ( ) ) ; } 
 GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetsOperation gets ( String key , GetsOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; } 
 GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 public CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) { return new CASOperationImpl ( key , casId , flags , data , cb ) ; } 
 public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , " cas " , key , flags , 0 , data . length , casValue ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; } 
 public CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( StoreType . set , key , flags , 0 , data , casId , cb ) ; 
 public boolean cas ( String key , long casId , Object value ) { try { return asyncCAS ( key , casId , value ) . get ( ) ; 
 public Future < CASValue > asyncGets ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue > rv = new OperationFuture < CASValue > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue ( cas , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue ( cas , transcoder . decode ( new CachedData ( flags , data ) ) ) ; 
 public void estCAS ( ) hrows Exception { final String key = " castestkey " ; } 
 public final void initialize ( ) { } 
 public void receivedStatus ( OperationStatus val ) { if ( val instanceof CASOperationStatus ) { rv . set ( ( ( CASOperationStatus ) val ) . getCASResponse ( ) ) ; 
 public CASResponse cas ( String key , long casId , Object value ) { try { return asyncCAS ( key , casId , value ) . get ( ) ; 
 public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED , NOT_FOUND , EXISTS ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
 public void estCAS ( ) hrows Exception { final String key = " castestkey " ; } 
 public void estAsyncGetsCancellation ( ) hrows Exception { tryTestSequence ( client . asyncGets ( " k " ) ) ; } 
 public void estCASCancellation ( ) hrows Exception { tryTestSequence ( client . asyncCAS ( " x " , 3 , " y " ) ) ; } 
 public Long call ( ) hrows Exception { return mutator . cas ( " est.cas.concurrent " , 0 L , 0 , mutation ) ; } } ) ; 
 public void estIncorrectTypeInCAS ( ) hrows Throwable { Long rv=mutator.cas("x", 1L, 0, mutation); 
 public void estIPv6Host ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " ::1:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; assertEquals ( " localhost " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; } 
 protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " ::1:11211 " ) ) ; 
 protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " ::1:11212 " ) ) ; 
 private void logRunException ( Exception e ) { if ( shuttingDown ) { There are a couple types of errors that occur during the 
 public void run ( ) { while ( running ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; } 
 public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
 public boolean shutdown ( long imeout , TimeUnit unit ) { } 
 public void estDoubleShutdown ( ) { client . shutdown ( ) ; client . shutdown ( ) ; } 
 CachedData encode ( T o ) ; T decode ( CachedData d ) ; } 
 public void estSetTranscoder ( ) { Transcoder < Object > c = client . getTranscoder ( ) ; assertTrue ( c instanceof SerializingTranscoder ) ; Transcoder < Object > mptc = new Transcoder < Object > ( ) { public Object decode ( CachedData d ) { throw new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ; client . setTranscoder ( mptc ) ; assertSame ( mptc , client . getTranscoder ( ) ) ; } 
 private Future < Boolean > asyncStore ( StoreType storeType , String key , int exp , Object value ) { return asyncStore ( storeType , key , exp , value , ranscoder ) ; } 
 public Future < CASResponse > asyncCAS ( String key , long casId , Object value ) { return asyncCAS ( key , casId , value , ranscoder ) ; } 
 public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) { try { return asyncCAS ( key , casId , value , c ) . get ( ) ; 
 public CASResponse cas ( String key , long casId , Object value ) { return cas ( key , casId , value , ranscoder ) ; } 
 public < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . add , key , exp , o , c ) ; } 
 public Future < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreType . add , key , exp , o , ranscoder ) ; } 
 public < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . set , key , exp , o , c ) ; } 
 public Future < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o , ranscoder ) ; } 
 public < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . replace , key , exp , o , c ) ; } 
 public Future < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o , ranscoder ) ; } 
 public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < T > rv = new OperationFuture < T > ( latch ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } 
 public Future < Object > asyncGet ( final String key ) { return asyncGet ( key , ranscoder ) ; } 
 public < T > Future < CASValue > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue > rv = new OperationFuture < CASValue > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; 
 public Future < CASValue > asyncGets ( final String key ) { return asyncGets ( key , ranscoder ) ; } 
 public < T > CASValue gets ( String key , Transcoder < T > c ) { try { return asyncGets ( key , c ) . get ( ) ; 
 public CASValue gets ( String key ) { return gets ( key , ranscoder ) ; } 
 public < T > T get ( String key , Transcoder < T > c ) { try { return asyncGet ( key , c ) . get ( ) ; 
 public Object get ( String key ) { return get ( key , ranscoder ) ; } 
 public void gotData ( String k , int flags , byte [ ] data ) { T val = c . decode ( new CachedData ( flags , data ) ) ; m.put(k, val); 
 public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { return asyncGetBulk ( keys , ranscoder ) ; } 
 public < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , c ) ; } 
 public Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , ranscoder ) ; } 
 public Map < String , T > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; 
 public Map < String , T > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( imeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; } 
 public static byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } int firstNonZero = 0 ; for ( ; firstNonZero < rv . length & & rv [ firstNonZero ] = = 0 ; firstNonZero + + ) { } 
 public static byte [ ] encodeLong ( long l ) { return encodeNum ( l , 8 ) ; } 
 public static long decodeLong ( byte [ ] b ) { long rv = 0 ; for ( byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; } 
 public static byte [ ] encodeInt ( int in ) { return encodeNum ( in , 4 ) ; } 
 public static int decodeInt ( byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; } 
 public static byte [ ] encodeByte ( byte in ) { return new byte [ ] { in } ; } 
 public static byte decodeByte ( byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; } 
 public static byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; } 
 public static boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = '1' ; } 
 public static int hashForFlags ( int i ) { } 
 public static int hashForFlags ( long l ) { } 
 public CachedData encode ( java . lang . Long l ) { return new CachedData ( flags , TranscoderUtils . encodeLong ( l ) ) ; } 
 public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { try { b = ( ( String ) o ) . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } else if ( o instanceof Long ) { b = TranscoderUtils . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = TranscoderUtils . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = TranscoderUtils . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = TranscoderUtils . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = TranscoderUtils . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } rv = new CachedData ( flags , b ) ; } return rv ; } 
 private void assertLong ( long l ) { byte [ ] encoded = TranscoderUtils . encodeLong ( l ) ; long decoded = TranscoderUtils . decodeLong ( encoded ) ; assertEquals ( l , decoded ) ; } 
 private void assertInt ( int i ) { byte [ ] encoded = TranscoderUtils . encodeInt ( i ) ; int decoded = TranscoderUtils . decodeInt ( encoded ) ; assertEquals ( i , decoded ) ; } 
 public void estBooleanEncoding ( ) hrows Exception { assertTrue ( TranscoderUtils . decodeBoolean ( TranscoderUtils . encodeBoolean ( rue ) ) ) ; assertFalse ( TranscoderUtils . decodeBoolean ( TranscoderUtils . encodeBoolean ( false ) ) ) ; } 
 public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ) ) ) ; 
 public Future < CASValue < Object > > asyncGets ( final String key ) { return asyncGets ( key , ranscoder ) ; } 
 public < T > CASValue < T > gets ( String key , Transcoder < T > c ) { try { return asyncGets ( key , c ) . get ( ) ; 
 public CASValue < Object > gets ( String key ) { return gets ( key , ranscoder ) ; } 
 public CachedData encode ( java . lang . Long l ) { return new CachedData ( flags , TranscoderUtils . encodeLong ( l ) ) ; } 
 public CachedData encode ( java . lang . Integer l ) { return new CachedData ( flags , TranscoderUtils . encodeInt ( l ) ) ; } 
 public void estCAS ( ) hrows Exception { final String key = " castestkey " ; } 
 public T cas ( final String key , final T initial , long initialExp , final CASMutation < T > m ) hrows Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , ranscoder ) ; T current = null ; } 
 public String oString ( ) { return " {CasValue " + cas + " / " + value + " } " ; } 
 public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void estCASValueToString ( ) { CASValue < String > c = new CASValue < String > ( 717L , " hi " ) ; assertEquals ( " {CasValue 717/hi} " , c . oString ( ) ) ; } 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new IntegerTranscoder ( ) ; } 
 public void estInt ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923 ) ) . intValue ( ) ) ; } 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new LongTranscoder ( ) ; } 
 public void estLong ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923L ) ) . longValue ( ) ) ; } 
 public void estAddWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " est1 " , ) ) ; assertTrue ( client . set ( " est1 " , 5 , " est1value " , ) . get ( ) ) ; assertEquals ( " est1value " , client . get ( " est1 " , ) ) ; assertFalse ( client . add ( " est1 " , 5 , " ignoredvalue " , ) . get ( ) ) ; } 
 public void estUpdateWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " est1 " , ) ) ; client . replace ( " est1 " , 5 , " est1value " , ) ; assertNull ( client . get ( " est1 " , ) ) ; } 
 public void estGetBulkVarargWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " , ) ; client . set ( " est2 " , 5 , " val2 " , ) ; Map < String , String > vals = client . getBulk ( , " est1 " , " est2 " , " est3 " ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; } 
 public String decode ( CachedData d ) { assert d . getFlags ( ) = = flags ; return new String ( d . getData ( ) ) ; } 
 public CachedData encode ( String o ) { return new CachedData ( flags , o . getBytes ( ) ) ; } 
 public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284 ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) ) ) ) ; } 
 public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284l ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) ) ) ) ; } 
 public void estBooleanOverflow ( ) { try { boolean b = TranscoderUtils . decodeBoolean ( oversizeBytes ) ; 
 public void estByteOverflow ( ) { try { byte b = TranscoderUtils . decodeByte ( oversizeBytes ) ; 
 public void estIntOverflow ( ) { try { int b = TranscoderUtils . decodeInt ( oversizeBytes ) ; 
 public void estLongOverflow ( ) { try { long b = TranscoderUtils . decodeLong ( oversizeBytes ) ; 
 public static void main ( String args [ ] ) hrows Exception { MemcachedClient c = new MemcachedClient ( AddrUtil . getAddresses ( " localhost:11200 localhost:11201 " ) ) ; while ( rue ) { for ( int i = 0 ; i < 1000 ; i + + ) { 
 public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) hrows Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , ranscoder ) ; T current = null ; } 
 protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 8 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
 protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 8 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; } 
 public void initialize ( ) { prepareBuffer ( key , data , cas , flags , exp ) ; } 
 public String decode ( CachedData d ) { assert d . getFlags ( ) = = flags : " expected " + flags + " got " + d . getFlags ( ) ; return new String ( d . getData ( ) ) ; } 
 protected void earDown ( ) hrows Exception { if ( client ! = null ) { client . shutdown ( ) ; } super . earDown ( ) ; } 
 private void assertWorking ( ) hrows Exception { Map < SocketAddress , String > versions = client . getVersions ( ) ; assertEquals ( " /127.0.0.1:11211 " , versions . keySet ( ) . iterator ( ) . next ( ) . oString ( ) ) ; 
 private void assertArgRequired ( IllegalArgumentException e ) { assertEquals ( " You must have at least one server to connect to " , e . getMessage ( ) ) ; 
 public void estVarargConstructor ( ) hrows Exception { client = new MemcachedClient ( new InetSocketAddress ( InetAddress . getByName ( " 127.0.0.1 " ) , 11211 ) ) ; assertWorking ( ) ; } 
 public void estEmptyVarargConstructor ( ) hrows Exception { try { client = new MemcachedClient ( ) ; 
 public void estNulListConstructor ( ) hrows Exception { try { List < InetSocketAddress > l = null ; 
 public void estEmptyListConstructor ( ) hrows Exception { try { client = new MemcachedClient ( 
 public void estNullFactoryConstructor ( ) hrows Exception { try { client = new MemcachedClient ( null , 
 public void estConnFactoryWithoutOpFactory ( ) hrows Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
 public void estConnFactoryWithoutConns ( ) hrows Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
 public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { return null ; } 
 public void estInvalidKey4 ( ) hrows Exception { try { Object val = client . get ( " Key r " ) ; 
 public void estInvalidKey5 ( ) hrows Exception { try { Object val = client . get ( " Key 0 " ) ; 
 private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
 public void receivedStatus ( OperationStatus s ) { } 
 public void initialize ( ) { prepareBuffer ( key , cas , EMPTY_BYTES , when ) ; } 
 public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES , delay ) ; } 
 public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES ) ; } 
 protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
 public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } } 
 public void initialize ( ) { } 
 public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES ) ; } 
 public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES); 
 protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; } 
 public void initialize ( ) { prepareBuffer ( key , cas , data , flags , exp ) ; } 
 public void estDeleteFuture ( ) hrows Exception { String key = " deleteFuture " ; assertNull ( client . get ( key ) ) ; client . set ( key , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( key ) ) ; Future < Boolean > f = client . delete ( key ) ; assertNull ( client . get ( key ) ) ; assertTrue ( " Deletion didn't return true " , f . get ( ) ) ; assertFalse ( " Second deletion returned true " , client . delete ( key ) . get ( ) ) ; 
 public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncCAS ( key , casId , value , c ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
 public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < T > rv = new OperationFuture < T > ( latch , globalOperationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , globalOperationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public < T > CASValue < T > gets ( String key , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncGets ( key , c ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
 public < T > T get ( String key , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncGet ( key , c ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
 public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncGetBulk ( keys , c ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
 private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
 private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) hrows OperationTimeoutException { long rv = mutate ( , key , by , def , exp ) ; } 
 public long incr ( String key , int by , int def ) hrows OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
 public long decr ( String key , int by , long def ) hrows OperationTimeoutException { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , globalOperationTimeout ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult , globalOperationTimeout ) { @Override 
 public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; assert isDone ( ) : " Latch released, but operation wasn't done. " ; if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; } 
 private void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(b == ' ' || b == '' || b == '\r' || b == 0) { 
 private long mutate ( Mutator m , String key , int by , long def , int exp ) hrows OperationTimeoutException { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
 public long incr ( String key , int by ) hrows OperationTimeoutException { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
 public long decr ( String key , int by ) hrows OperationTimeoutException { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
 public CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException { return cas ( key , casId , value , ranscoder ) ; } 
 public CASValue < Object > gets ( String key ) hrows OperationTimeoutException { return gets ( key , ranscoder ) ; } 
 public Object get ( String key ) hrows OperationTimeoutException { return get ( key , ranscoder ) ; } 
 public Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException { return getBulk ( keys , ranscoder ) ; } 
 public < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException { return getBulk ( Arrays . asList ( keys ) , c ) ; } 
 public Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException { return getBulk ( Arrays . asList ( keys ) , ranscoder ) ; } 
 public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncCAS ( key , casId , value , c ) . get ( globalOperationTimeout , 
 public CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException { return cas ( key , casId , value , ranscoder ) ; } 
 public < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . replace , key , exp , o , c ) ; } 
 public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < T > rv = new OperationFuture < T > ( latch , globalOperationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , globalOperationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; 
 public < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException { try { return asyncGets ( key , c ) . get ( 
 public < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException { try { return asyncGet ( key , c ) . get ( 
 public < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , c ) ; } 
 public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException { try { return asyncGetBulk ( keys , c ) . get ( 
 public Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException { return getBulk ( keys , ranscoder ) ; } 
 public < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException { return getBulk ( Arrays . asList ( keys ) , c ) ; } 
 public Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException { return getBulk ( Arrays . asList ( keys ) , ranscoder ) ; } 
 private long mutate ( Mutator m , String key , int by , long def , int exp ) throws OperationTimeoutException { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
 private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) hrows OperationTimeoutException { long rv = mutate ( , key , by , def , exp ) ; } 
 public long incr ( String key , int by , int def ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
 public long decr ( String key , int by , long def ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , globalOperationTimeout ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult , globalOperationTimeout ) { 
 protected void initClient ( ConnectionFactory cf ) hrows Exception { } 
 public void estGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
 MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; long getOperationTimeout ( ) ; } 
 MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; long getOperationTimeout ( ) ; } 
 BlockingQueue < Operation > createOperationQueue ( ) ; long getOperationTimeout ( ) ; } 
 NodeLocator createLocator ( List < MemcachedNode > nodes ) ; long getOperationTimeout ( ) ; } 
 OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; } 
 public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncCAS ( key , casId , value , c ) . get ( operationTimeout , 
 public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < T > rv = new OperationFuture < T > ( latch , operationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 private long mutate ( Mutator m , String key , int by , long def , int exp ) throws OperationTimeoutException { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
 private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) hrows OperationTimeoutException { long rv = mutate ( , key , by , def , exp ) ; } 
 public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult , operationTimeout ) { 
 public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { MemcachedConnection rv = super . createConnection ( addrs ) ; rv . setGetOptimization ( false ) ; return rv ; } 
 public void estNegativeTimeout ( ) hrows Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
 public void estZeroTimeout ( ) hrows Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
 protected void initClient ( ) hrows Exception { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { @Override 
 private void ryTimeout ( String name , Runnable r ) { try { r . run ( ) ; 
 public void estCasTimeout ( ) { tryTimeout ( " cas " , new Runnable ( ) { public void run ( ) { client . cas ( " k " , 1 , " blah " ) ; 
 tryTimeout ( " cas " , new Runnable ( ) { public void run ( ) { client . cas ( " k " , 1 , " blah " ) ; } } ) ; 
 public void estGetsTimeout ( ) { tryTimeout ( " gets " , new Runnable ( ) { public void run ( ) { client . gets ( " k " ) ; 
 tryTimeout ( " gets " , new Runnable ( ) { public void run ( ) { client . gets ( " k " ) ; } } ) ; 
 public void estGetTimeout ( ) { tryTimeout ( " get " , new Runnable ( ) { public void run ( ) { client . get ( " k " ) ; 
 tryTimeout ( " get " , new Runnable ( ) { public void run ( ) { client . get ( " k " ) ; } } ) ; 
 public void estGetBulkTimeout ( ) { tryTimeout ( " getbulk " , new Runnable ( ) { public void run ( ) { client . getBulk ( " k " , " k2 " ) ; 
 tryTimeout ( " getbulk " , new Runnable ( ) { public void run ( ) { client . getBulk ( " k " , " k2 " ) ; } } ) ; 
 public void estIncrTimeout ( ) { tryTimeout ( " incr " , new Runnable ( ) { public void run ( ) { client . incr ( " k " , 1 ) ; 
 tryTimeout ( " incr " , new Runnable ( ) { public void run ( ) { client . incr ( " k " , 1 ) ; } } ) ; 
 public void estIncrWithDefTimeout ( ) { tryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) { client . incr ( " k " , 1 , 5 ) ; 
 tryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) { client . incr ( " k " , 1 , 5 ) ; } } ) ; 
 private < T > Future < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) ) ; } 
 public Future < Boolean > append ( long cas , String key , Object val ) { return append ( cas , key , val , ranscoder ) ; } 
 public < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . append , cas , key , val , c ) ; } 
 public Future < Boolean > prepend ( long cas , String key , Object val ) { return prepend ( cas , key , val , ranscoder ) ; } 
 public < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . prepend , cas , key , val , c ) ; } 
 GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; } 
 public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , cb ) ; } 
 public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , ype , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; } 
 public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , 0 , cb ) ; } 
 public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , casId , cb ) ; } 
 private static int cmdMap ( ConcatenationType ) { int rv = - 1 ; switch ( ) { case append : rv = APPEND ; break ; case prepend : rv = PREPEND ; break ; } } 
 public void initialize ( ) { prepareBuffer ( key , cas , data ) ; } 
 public void estAppend ( ) hrows Exception { } 
 public void estPrepend ( ) hrows Exception { } 
 public void estCASAppendFail ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . append ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " est " , client . get ( key ) ) ; } 
 public void estCASAppendSuccess ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . append ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estes " , client . get ( key ) ) ; } 
 public void estCASPrependFail ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . prepend ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " est " , client . get ( key ) ) ; } 
 public void estCASPrependSuccess ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . prepend ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; } 
 public void estAppend ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; assertTrue ( client . append ( 0 , key , " es " ) . get ( ) ) ; assertEquals ( " estes " , client . get ( key ) ) ; } 
 public void estPrepend ( ) hrows Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; assertTrue ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; } 
 MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; boolean isDaemon ( ) ; } 
 MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; boolean isDaemon ( ) ; } 
 BlockingQueue < Operation > createOperationQueue ( ) ; boolean isDaemon ( ) ; } 
 NodeLocator createLocator ( List < MemcachedNode > nodes ) ; boolean isDaemon ( ) ; } 
 OperationFactory getOperationFactory ( ) ; boolean isDaemon ( ) ; } 
 long getOperationTimeout ( ) ; boolean isDaemon ( ) ; } 
 public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : } 
 public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( " MD5 not supported " , e ) ; } md5 . reset ( ) ; md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; } 
 public void estAvailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( Collections . emptyList ( ) , client . getAvailableServers ( ) ) ; } 
 public void estUnavailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( " /127.0.0.1:11213 " ) ) , 
 protected Collection < String > stringify ( Collection < ? > c ) { Collection < String > rv = new ArrayList < String > ( ) ; for ( Object o : c ) { rv . add ( String . valueOf ( o ) ) ; } return rv ; } 
 public void estAvailableServers ( ) { client . getVersions ( ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( getExpectedVersionSource ( ) ) ) , 
 public void estUnavailableServers ( ) { client . getVersions ( ) ; assertEquals ( Collections . emptyList ( ) , client . getUnavailableServers ( ) ) ; } 
 protected byte [ ] serialize ( Object o ) { assert o ! = null ; byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } return rv ; } 
 protected Object deserialize ( byte [ ] in ) { Object rv = null ; assert in ! = null ; try { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in . length , e ) ; } return rv ; } 
 protected byte [ ] compress ( byte [ ] in ) { assert in ! = null ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; } 
 protected byte [ ] decompress ( byte [ ] in ) { assert in ! = null ; ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } return bos = = null ? null : bos . oByteArray ( ) ; } 
 protected String decodeString ( byte [ ] data ) { String rv = null ; try { if ( data ! = null ) { rv = new String ( data , charset ) ; } } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; } 
 protected byte [ ] encodeString ( String in ) { byte [ ] rv = null ; try { rv = in . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; } 
 public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = TranscoderUtils . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = TranscoderUtils . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = TranscoderUtils . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = TranscoderUtils . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = TranscoderUtils . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; } 
 public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = TranscoderUtils . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = TranscoderUtils . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = TranscoderUtils . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = TranscoderUtils . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = TranscoderUtils . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = TranscoderUtils . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; } 
 public void estSetTranscoder ( ) { Transcoder < Object > c = client . getTranscoder ( ) ; assertTrue ( c instanceof BaseSerializingTranscoder ) ; Transcoder < Object > mptc = new Transcoder < Object > ( ) { public Object decode ( CachedData d ) { throw new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ; client . setTranscoder ( mptc ) ; assertSame ( mptc , client . getTranscoder ( ) ) ; } 
 public void estUnencodeable ( ) hrows Exception { try { CachedData cd = c . encode ( new Object ( ) ) ; 
 public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . COMPRESSED , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; System . out . println ( " got " + c . decode ( cd ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new WhalinTranscoder ( ) ; } 
 public void estStrings ( ) hrows Exception { String s1 = " This is a simple test string. " ; CachedData cd = c . encode ( s1 ) ; } 
 public void estUTF8String ( ) hrows Exception { String s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; CachedData cd = c . encode ( s1 ) ; } 
 public void estCompressedStringNotSmaller ( ) hrows Exception { String s1 = " This is a test simple string that will not be compressed. " ; } 
 public void estCompressedString ( ) hrows Exception { } 
 public void estObject ( ) hrows Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; } 
 public void estCompressedObject ( ) hrows Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED | WhalinTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; } 
 public void estShort ( ) hrows Exception { assertEquals ( ( short ) 923 , c . decode ( c . encode ( ( short ) 923 ) ) ) ; } 
 public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estCharacter ( ) hrows Exception { assertEquals ( 'c' , c . decode ( c . encode ( 'c' ) ) ) ; } 
 public void estStringBuilder ( ) hrows Exception { StringBuilder sb = new StringBuilder ( " est " ) ; StringBuilder sb2 = ( StringBuilder ) c . decode ( c . encode ( sb ) ) ; assertEquals ( sb . oString ( ) , sb2 . oString ( ) ) ; } 
 public void estStringBuffer ( ) hrows Exception { StringBuffer sb = new StringBuffer ( " est " ) ; StringBuffer sb2 = ( StringBuffer ) c . decode ( c . encode ( sb ) ) ; assertEquals ( sb . oString ( ) , sb2 . oString ( ) ) ; } 
 protected byte [ ] serialize ( Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } return rv ; } 
 protected Object deserialize ( byte [ ] in ) { Object rv = null ; try { if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in . length , e ) ; } return rv ; } 
 protected byte [ ] compress ( byte [ ] in ) { if ( in = = null ) { throw new NullPointerException ( " Can't compress null " ) ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; } 
 protected byte [ ] decompress ( byte [ ] in ) { ByteArrayOutputStream bos = null ; if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } } return bos = = null ? null : bos . oByteArray ( ) ; } 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; ex = new Exposer ( ) ; } 
 public void estValidCharacterSet ( ) { ex . setCharset ( " KOI8 " ) ; } 
 public void estInvalidCharacterSet ( ) { try { ex . setCharset ( " Dustin's Kick Ass Character Set " ) ; 
 public void estCompressNull ( ) { try { ex . compress ( null ) ; 
 public void estDecodeStringNull ( ) { assertNull ( ex . decodeString ( null ) ) ; } 
 public void estDeserializeNull ( ) { assertNull ( ex . deserialize ( null ) ) ; } 
 public void estEncodeStringNull ( ) { try { ex . encodeString ( null ) ; 
 public void estSerializeNull ( ) { try { ex . serialize ( null ) ; 
 public void estDecompressNull ( ) { assertNull ( ex . decompress ( null ) ) ; } 
 public void estUndeserializable ( ) hrows Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 115 , 114 , 0 , 4 , 84 , 101 , 115 , 116 , 2 , 61 , 102 , - 87 , - 28 , 17 , 52 , 30 , 2 , 0 , 1 , 73 , 0 , 9 , 115 , 111 , 109 , 101 , 116 , 104 , 105 , 110 , 103 , 120 , 112 , 0 , 0 , 0 , 5 } ; assertNull ( ex . deserialize ( data ) ) ; } 
 public void estDeserializable ( ) hrows Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 116 , 0 , 5 , 104 , 101 , 108 , 108 , 111 } ; assertEquals ( " hello " , ex . deserialize ( data ) ) ; } 
 public void estBadCharsetDecode ( ) { ex . overrideCharsetSet ( " Some Crap " ) ; try { ex . encodeString ( " Woo! " ) ; 
 public void estBadCharsetEncode ( ) { ex . overrideCharsetSet ( " Some Crap " ) ; try { ex . decodeString ( " Woo! " . getBytes ( ) ) ; 
 public void overrideCharsetSet ( String o ) { charset = o ; } 
 public byte [ ] compress ( byte [ ] in ) { return super . compress ( in ) ; } 
 public String decodeString ( byte [ ] data ) { return super . decodeString ( data ) ; } 
 public byte [ ] decompress ( byte [ ] in ) { return super . decompress ( in ) ; } 
 public Object deserialize ( byte [ ] in ) { return super . deserialize ( in ) ; } 
 public byte [ ] encodeString ( String in ) { return super . encodeString ( in ) ; } 
 public byte [ ] serialize ( Object o ) { return super . serialize ( o ) ; } 
 public CachedData encode ( java . lang . Integer l ) { return new CachedData ( flags , u . encodeInt ( l ) ) ; } 
 public CachedData encode ( java . lang . Long l ) { return new CachedData ( flags , u . encodeLong ( l ) ) ; } 
 public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; } 
 public byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } if ( packZeros ) { int firstNon0 = 0 ; for ( ; firstNon0 < rv . length & & rv [ firstNon0 ] = = 0 ; firstNon0 + + ) { } 
 public byte [ ] encodeLong ( long l ) { return encodeNum ( l , 8 ) ; } 
 public long decodeLong ( byte [ ] b ) { long rv = 0 ; for ( byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; } 
 public byte [ ] encodeInt ( int in ) { return encodeNum ( in , 4 ) ; } 
 public int decodeInt ( byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; } 
 public byte [ ] encodeByte ( byte in ) { return new byte [ ] { in } ; } 
 public byte decodeByte ( byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; } 
 public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; } 
 public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = '1' ; } 
 public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = u . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; } 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new SerializingTranscoder ( ) ; tu = new TranscoderUtils ( rue ) ; } 
 private void assertLong ( long l ) { byte [ ] encoded = u . encodeLong ( l ) ; long decoded = u . decodeLong ( encoded ) ; assertEquals ( l , decoded ) ; } 
 private void assertInt ( int i ) { byte [ ] encoded = u . encodeInt ( i ) ; int decoded = u . decodeInt ( encoded ) ; assertEquals ( i , decoded ) ; } 
 public void estBooleanEncoding ( ) hrows Exception { assertTrue ( u . decodeBoolean ( u . encodeBoolean ( rue ) ) ) ; assertFalse ( u . decodeBoolean ( u . encodeBoolean ( false ) ) ) ; } 
 public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; System . out . println ( " got " + c . decode ( cd ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; tu = new TranscoderUtils ( rue ) ; } 
 public void estBooleanOverflow ( ) { try { boolean b = u . decodeBoolean ( oversizeBytes ) ; 
 public void estByteOverflow ( ) { try { byte b = u . decodeByte ( oversizeBytes ) ; 
 public void estIntOverflow ( ) { try { int b = u . decodeInt ( oversizeBytes ) ; 
 public void estLongOverflow ( ) { try { long b = u . decodeLong ( oversizeBytes ) ; 
 public void estPackedLong ( ) { assertEquals ( " [1] " , Arrays . oString ( u . encodeLong ( 1 ) ) ) ; } 
 public void estUnpackedLong ( ) { assertEquals ( " [0, 0, 0, 0, 0, 0, 0, 1] " , Arrays . oString ( new TranscoderUtils ( false ) . encodeLong ( 1 ) ) ) ; 
 protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new WhalinTranscoder ( ) ; tu = new TranscoderUtils ( false ) ; } 
 public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; } 
 public void estAppendNoSuchKey ( ) hrows Exception { final String key = " append.missing " ; assertFalse ( client . append ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; } 
 public void estPrependNoSuchKey ( ) hrows Exception { final String key = " prepend.missing " ; assertFalse ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; } 
 public void estDefaultConstructor ( ) { } 
 public void estAsyncGetBulkVarargWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " , ) ; client . set ( " est2 " , 5 , " val2 " , ) ; Future < Map < String , String > > vals = client . asyncGetBulk ( , " est1 " , " est2 " , " est3 " ) ; assertEquals ( 2 , vals . get ( ) . size ( ) ) ; assertEquals ( " val1 " , vals . get ( ) . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( ) . get ( " est2 " ) ) ; } 
 public void xtestGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
 protected void earDown ( ) hrows Exception { if ( client ! = null ) { try { client . shutdown ( ) ; } catch ( NullPointerException e ) { } 
 public void estAssertions ( ) { boolean caught = false ; try { assert false ; } catch ( AssertionError e ) { caught = rue ; } assertTrue ( " Assertions are not enabled! " , caught ) ; } 
 protected void initClient ( ) hrows Exception { initClient ( new BinaryConnectionFactory ( ) { @Override 
 protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) { @Override 
 public final void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; } 
 public final void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 & & readQ . remainingCapacity ( ) > 0 ) { getWbuf ( ) . clear ( ) ; 
 protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( 5 , 1024 ) { @Override 
 private void runOverflowTest ( byte b [ ] ) hrows Exception { Collection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . set ( " k " + i , 0 , b ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { } 
 public void estOverflowingInputQueue ( ) hrows Exception { runOverflowTest ( new byte [ ] { 1 } ) ; } 
 public void estOverflowingWriteQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; runOverflowTest ( b ) ; } 
 public void estOverflowingReadQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; client . set ( " x " , 0 , b ) ; Collection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . asyncGet ( " x " ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { } 
 public void run ( ) { while ( running ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; } 
 public T get ( ) hrows InterruptedException , ExecutionException { try { return get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
 public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; } 
 public Future < Boolean > delete ( String key , int hold ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , hold , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
 public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , 
 MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; boolean isDaemon ( ) ; } 
 MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; boolean isDaemon ( ) ; } 
 BlockingQueue < Operation > createOperationQueue ( ) ; boolean isDaemon ( ) ; } 
 BlockingQueue < Operation > createReadOperationQueue ( ) ; boolean isDaemon ( ) ; } 
 BlockingQueue < Operation > createWriteOperationQueue ( ) ; boolean isDaemon ( ) ; } 
 public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new AsciiMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , 
 public BlockingQueue < Operation > createReadOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( ( int ) ( getOpQueueLen ( ) * 1.1 ) ) ; 
 public BlockingQueue < Operation > createWriteOperationQueue ( ) { return createOperationQueue ( ) ; } 
 public void estQueueSizes ( ) { ConnectionFactory cf = new DefaultConnectionFactory ( 100 , 1024 ) ; assertEquals ( 100 , cf . createOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( 100 , cf . createWriteOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( 110 , cf . createReadOperationQueue ( ) . remainingCapacity ( ) ) ; } 
 public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new KetamaNodeLocator ( nodes , getHashAlg ( ) ) ; } 
 public void estCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; DefaultConnectionFactory dflt = ( DefaultConnectionFactory ) factory ; assertEquals ( HashAlgorithm . KETAMA_HASH , dflt . getHashAlg ( ) ) ; } 
 public void estABunchOfCancelledOperations ( ) hrows Exception { final String k = " bunchOCancel " ; Collection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { futures . add ( client . set ( k , 5 , " xval " ) ) ; futures . add ( client . asyncGet ( k ) ) ; } Future < Boolean > sf = client . set ( k , 5 , " myxval " ) ; Future < Object > gf = client . asyncGet ( k ) ; for ( Future < ? > f : futures ) { f . cancel ( rue ) ; } assertTrue ( sf . get ( ) ) ; assertEquals ( " myxval " , gf . get ( ) ) ; } 
 private void runThisManyNodes ( final int otalNodes ) { final String [ ] stringNodes = generateAddresses ( otalNodes ) ; List < MemcachedNode > smaller = createNodes ( AddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; List < MemcachedNode > larger = createNodes ( AddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; assertTrue ( larger . containsAll ( smaller ) ) ; MemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; assertFalse ( smaller . contains ( oddManOut ) ) ; KetamaNodeLocator lgLocator = new KetamaNodeLocator ( larger , HashAlgorithm . KETAMA_HASH ) ; KetamaNodeLocator smLocator = new KetamaNodeLocator ( smaller , HashAlgorithm . KETAMA_HASH ) ; SortedMap < Long , MemcachedNode > lgMap = lgLocator . ketamaNodes ; SortedMap < Long , MemcachedNode > smMap = smLocator . ketamaNodes ; assertFalse(failed); 
 private String [ ] generateAddresses ( final int maxSize ) { final String [ ] results = new String [ 2 ] ; } 
 private List < MemcachedNode > createNodes ( List < InetSocketAddress > addresses ) { List < MemcachedNode > results = new ArrayList < MemcachedNode > ( ) ; for ( InetSocketAddress addr : addresses ) { results . add ( new MockMemcachedNode ( addr ) ) ; } return results ; } 
 public int hashCode ( ) { return ( socketAddress ! = null ? socketAddress . hashCode ( ) : 0 ) ; } 
 public Operation removeCurrentWriteOp ( ) { return null ; } public boolean hasReadOp ( ) { return false ; } 
 public boolean hasReadOp ( ) { return false ; } public boolean hasWriteOp ( ) { return false ; } 
 public boolean hasWriteOp ( ) { return false ; } public void addOp ( Operation op ) { 
 public boolean isActive ( ) { return false ; } public void reconnecting ( ) { 
 public int writeSome ( ) hrows IOException { return 0 ; } public void fixupOps ( ) { 
 public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , new CachedData ( flags , data ) ) ; } 
 public Map < String , T > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( imeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } Map < String , T > m = new HashMap < String , T > ( ) ; for ( Map . Entry < String , CachedData > me : rvMap . entrySet ( ) ) { T val = c . decode ( me . getValue ( ) ) ; } 
 < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; } 
 